var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// ../chronograph/src/class/Base.js
var Base = class {
  /**
   * This method applies its 1st argument (if any) to the current instance using `Object.assign()`.
   *
   * Supposed to be overridden in the subclasses to customize the instance creation process.
   *
   * @param props
   */
  initialize(props) {
    props && Object.assign(this, props);
  }
  /**
   * This is a type-safe static constructor method, accepting a single argument, with the object, corresponding to the
   * class properties. It will generate a compilation error, if unknown property is provided.
   *
   * For example:
   *
   * ```ts
   * class MyClass extends Base {
   *     prop     : string
   * }
   *
   * const instance : MyClass = MyClass.new({ prop : 'prop', wrong : 11 })
   * ```
   *
   * will produce:
   *
   * ```plaintext
   * TS2345: Argument of type '{ prop: string; wrong: number; }' is not assignable to parameter of type 'Partial<MyClass>'.
   * Object literal may only specify known properties, and 'wrong' does not exist in type 'Partial<MyClass>'
   * ```
   *
   * The only thing this constructor does is create an instance and call the [[initialize]] method on it, forwarding
   * the first argument. The customization of instance is supposed to be performed in that method.
   *
   * @param props
   */
  static new(props) {
    const instance = new this();
    instance.initialize(props);
    return instance;
  }
};

// ../chronograph/src/collection/Iterator.js
function split(iterable) {
  const gen1Pending = [];
  const gen2Pending = [];
  let iterator;
  const gen1 = function* () {
    if (!iterator)
      iterator = iterable[Symbol.iterator]();
    while (true) {
      if (gen1Pending.length) {
        yield* gen1Pending;
        gen1Pending.length = 0;
      }
      if (!iterator)
        break;
      const { value, done } = iterator.next();
      if (done) {
        iterator = null;
        iterable = null;
        break;
      }
      gen2Pending.push(value);
      yield value;
    }
  };
  const gen2 = function* () {
    if (!iterator)
      iterator = iterable[Symbol.iterator]();
    while (true) {
      if (gen2Pending.length) {
        yield* gen2Pending;
        gen2Pending.length = 0;
      }
      if (!iterator)
        break;
      const { value, done } = iterator.next();
      if (done) {
        iterator = null;
        iterable = null;
        break;
      }
      gen1Pending.push(value);
      yield value;
    }
  };
  return [gen1(), gen2()];
}
function* inBatchesBySize(iterator, batchSize) {
  if (batchSize < 0)
    throw new Error("Batch size needs to a natural number");
  batchSize = batchSize | 0;
  const runningBatch = [];
  for (const el of iterator) {
    if (runningBatch.length === batchSize) {
      yield runningBatch;
      runningBatch.length = 0;
    }
    runningBatch.push(el);
  }
  if (runningBatch.length > 0)
    yield runningBatch;
}
function* filter(iterator, func) {
  let i = 0;
  for (const el of iterator) {
    if (func(el, i++))
      yield el;
  }
}
function* drop(iterator, howMany) {
  let i = 0;
  for (const el of iterator) {
    if (++i > howMany)
      yield el;
  }
}
function every(iterator, func) {
  let i = 0;
  for (const el of iterator) {
    if (!func(el, i++))
      return false;
  }
  return true;
}
function some(iterator, func) {
  let i = 0;
  for (const el of iterator) {
    if (func(el, i++))
      return true;
  }
  return false;
}
function* map(iterator, func) {
  let i = 0;
  for (const el of iterator)
    yield func(el, i++);
}
function reduce(iterator, func, initialAcc) {
  let i = 0;
  let acc = initialAcc;
  for (const el of iterator) {
    acc = func(acc, el, i++);
  }
  return acc;
}
function* uniqueOnly(iterator) {
  const seen = /* @__PURE__ */ new Set();
  for (const el of iterator) {
    if (!seen.has(el)) {
      seen.add(el);
      yield el;
    }
  }
}
function* uniqueOnlyBy(iterator, func) {
  const seen = /* @__PURE__ */ new Set();
  for (const el of iterator) {
    const uniqueBy = func(el);
    if (!seen.has(uniqueBy)) {
      seen.add(uniqueBy);
      yield el;
    }
  }
}
function* takeWhile(iterator, func) {
  let i = 0;
  for (const el of iterator) {
    if (func(el, i++))
      yield el;
    else
      return;
  }
}
function* concat(...iterators) {
  for (let i = 0; i < iterators.length; i++)
    yield* iterators[i];
}
function* concatIterable(iteratorsProducer) {
  for (const iterator of iteratorsProducer)
    yield* iterator;
}
var ChainedIteratorClass = class {
  constructor(iterable) {
    this.iterable = void 0;
    if (!iterable)
      throw new Error("Require an iterable instance for chaining");
    this.iterable = iterable;
  }
  derive(iterable) {
    this.iterable = void 0;
    return new ChainedIteratorClass(iterable);
  }
  copy() {
    const [iter1, iter2] = split(this.iterable);
    this.iterable = iter2;
    return new ChainedIteratorClass(iter1);
  }
  split() {
    const [iter1, iter2] = split(this.iterable);
    return [new ChainedIteratorClass(iter1), this.derive(iter2)];
  }
  inBatchesBySize(batchSize) {
    return this.derive(inBatchesBySize(this.iterable, batchSize));
  }
  filter(func) {
    return this.derive(filter(this.iterable, func));
  }
  drop(howMany) {
    return this.derive(drop(this.iterable, howMany));
  }
  map(func) {
    return this.derive(map(this.iterable, func));
  }
  reduce(func, initialAcc) {
    return reduce(this, func, initialAcc);
  }
  concat() {
    return this.derive(concatIterable(this.iterable));
  }
  uniqueOnly() {
    return this.derive(uniqueOnly(this.iterable));
  }
  uniqueOnlyBy(func) {
    return this.derive(uniqueOnlyBy(this.iterable, func));
  }
  every(func) {
    return every(this, func);
  }
  some(func) {
    return some(this, func);
  }
  takeWhile(func) {
    return this.derive(takeWhile(this.iterable, func));
  }
  *[Symbol.iterator]() {
    let iterable = this.iterable;
    if (!iterable)
      throw new Error("Chained iterator already exhausted or used to derive the new one");
    this.iterable = void 0;
    yield* iterable;
    iterable = void 0;
  }
  toArray() {
    return Array.from(this);
  }
  sort(order) {
    return Array.from(this).sort(order);
  }
  toSet() {
    return new Set(this);
  }
  toMap() {
    return new Map(this);
  }
  // toMap<K, V> () : T extends [ K, V ] ? Map<K, V> : never  {
  //     return new Map<K, V>(this.iterable as (T extends [ K, V ] ? Iterable<T> : never)) as (T extends [ K, V ] ? Map<K, V> : never)
  // }
  flush() {
    for (const element of this) {
    }
  }
  memoize() {
    return new MemoizedIteratorClass(this);
  }
};
var ChainedIterator = (iterator) => new ChainedIteratorClass(iterator);
var CI = ChainedIterator;
var MemoizedIteratorClass = class extends ChainedIteratorClass {
  constructor() {
    super(...arguments);
    this.elements = [];
    this.$iterator = void 0;
  }
  set iterable(iterable) {
    this.$iterable = iterable;
  }
  get iterable() {
    return this;
  }
  derive(iterable) {
    return new ChainedIteratorClass(iterable);
  }
  *[Symbol.iterator]() {
    const elements = this.elements;
    if (this.$iterable) {
      if (!this.$iterator)
        this.$iterator = this.$iterable[Symbol.iterator]();
      let iterator = this.$iterator;
      let alreadyConsumed = elements.length;
      if (alreadyConsumed > 0)
        yield* elements;
      while (true) {
        if (elements.length > alreadyConsumed) {
          for (let i = alreadyConsumed; i < elements.length; i++)
            yield elements[i];
          alreadyConsumed = elements.length;
        }
        if (!iterator)
          break;
        const { value, done } = iterator.next();
        if (done) {
          iterator = this.$iterator = null;
          this.$iterable = null;
        } else {
          elements.push(value);
          alreadyConsumed++;
          yield value;
        }
      }
    } else {
      yield* elements;
    }
  }
};
var MemoizedIterator = (iterator) => new MemoizedIteratorClass(iterator);
var MI = MemoizedIterator;

// ../chronograph/src/util/Helpers.js
var MIN_SMI = -Math.pow(2, 30);
var MAX_SMI = Math.pow(2, 30) - 1;
var uppercaseFirst = (str) => str.slice(0, 1).toUpperCase() + str.slice(1);
var isAtomicValue = (value) => Object(value) !== value;
var defineProperty = (target, property, value) => {
  Object.defineProperty(target, property, { value, enumerable: true, configurable: true });
  return value;
};
var prototypeValue = (value) => {
  return function(target, propertyKey) {
    target[propertyKey] = value;
  };
};
var copySetInto = (sourceSet, targetSet) => {
  for (const value of sourceSet)
    targetSet.add(value);
  return targetSet;
};
var delay = (timeout) => new Promise((resolve) => setTimeout(resolve, timeout));
var matchAll = function* (regexp, testStr) {
  let match;
  while ((match = regexp.exec(testStr)) !== null) {
    yield match;
  }
};
var isRegeneratorRuntime = null;
var isGeneratorFunction = function(func) {
  if (isRegeneratorRuntime === null)
    isRegeneratorRuntime = typeof regeneratorRuntime !== "undefined";
  if (isRegeneratorRuntime === true) {
    return regeneratorRuntime.isGeneratorFunction(func);
  } else {
    return func.constructor.name === "GeneratorFunction";
  }
};
var isPromise = function(obj) {
  return obj && typeof obj.then === "function";
};

// ../chronograph/src/chrono/Effect.js
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var BreakCurrentStackExecution = Symbol("BreakCurrentStackExecution");
var Effect = class extends Base {
};
__decorate([
  prototypeValue(true)
], Effect.prototype, "sync", void 0);
__decorate([
  prototypeValue(true)
], Effect.prototype, "pure", void 0);
var ProposedOrPreviousSymbol = Symbol("ProposedOrPreviousSymbol");
var ProposedOrPrevious = Effect.new({ handler: ProposedOrPreviousSymbol });
var RejectSymbol = Symbol("RejectSymbol");
var RejectEffect = class extends Effect {
  constructor() {
    super(...arguments);
    this.handler = RejectSymbol;
  }
};
__decorate([
  prototypeValue(false)
], RejectEffect.prototype, "pure", void 0);
var Reject = (reason) => RejectEffect.new({ reason });
var TransactionSymbol = Symbol("TransactionSymbol");
var GetTransaction = Effect.new({ handler: TransactionSymbol });
var OwnQuarkSymbol = Symbol("OwnQuarkSymbol");
var OwnQuark = Effect.new({ handler: OwnQuarkSymbol });
var OwnIdentifierSymbol = Symbol("OwnIdentifierSymbol");
var OwnIdentifier = Effect.new({ handler: OwnIdentifierSymbol });
var WriteSymbol = Symbol("WriteSymbol");
var WriteEffect = class extends Effect {
  constructor() {
    super(...arguments);
    this.handler = WriteSymbol;
  }
};
__decorate([
  prototypeValue(false)
], WriteEffect.prototype, "pure", void 0);
var Write = (identifier, proposedValue, ...proposedArgs) => WriteEffect.new({ identifier, proposedArgs: [proposedValue, ...proposedArgs] });
var WriteSeveralSymbol = Symbol("WriteSeveralSymbol");
var WriteSeveralEffect = class extends Effect {
  constructor() {
    super(...arguments);
    this.handler = WriteSeveralSymbol;
  }
};
__decorate([
  prototypeValue(false)
], WriteSeveralEffect.prototype, "pure", void 0);
var WriteSeveral = (writes) => WriteSeveralEffect.new({ writes });
var PreviousValueOfSymbol = Symbol("PreviousValueOfSymbol");
var PreviousValueOfEffect = class extends Effect {
  constructor() {
    super(...arguments);
    this.handler = PreviousValueOfSymbol;
  }
};
var PreviousValueOf = (identifier) => PreviousValueOfEffect.new({ identifier });
var ProposedValueOfSymbol = Symbol("ProposedValueOfSymbol");
var ProposedValueOfEffect = class extends Effect {
  constructor() {
    super(...arguments);
    this.handler = ProposedValueOfSymbol;
  }
};
var ProposedValueOf = (identifier) => ProposedValueOfEffect.new({ identifier });
var HasProposedValueSymbol = Symbol("HasProposedValueSymbol");
var HasProposedValueEffect = class extends Effect {
  constructor() {
    super(...arguments);
    this.handler = HasProposedValueSymbol;
  }
};
var HasProposedValue = (identifier) => HasProposedValueEffect.new({ identifier });
var HasProposedNotPreviousValueSymbol = Symbol("HasProposedNotPreviousValueSymbol");
var HasProposedNotPreviousValueEffect = class extends Effect {
  constructor() {
    super(...arguments);
    this.handler = HasProposedNotPreviousValueSymbol;
  }
};
var HasProposedNotPreviousValue = (identifier) => HasProposedNotPreviousValueEffect.new({ identifier });
var ProposedOrPreviousValueOfSymbol = Symbol("ProposedOrPreviousValueOfSymbol");
var ProposedOrPreviousValueOfEffect = class extends Effect {
  constructor() {
    super(...arguments);
    this.handler = ProposedOrPreviousValueOfSymbol;
  }
};
var ProposedOrPreviousValueOf = (identifier) => ProposedOrPreviousValueOfEffect.new({ identifier });
var ProposedArgumentsOfSymbol = Symbol("ProposedArgumentsOfSymbol");
var ProposedArgumentsOfEffect = class extends Effect {
  constructor() {
    super(...arguments);
    this.handler = ProposedArgumentsOfSymbol;
  }
};
var ProposedArgumentsOf = (identifier) => ProposedArgumentsOfEffect.new({ identifier });
var UnsafeProposedOrPreviousValueOfSymbol = Symbol("UnsafeProposedOrPreviousValueOfSymbol");
var UnsafeProposedOrPreviousValueOfEffect = class extends Effect {
  constructor() {
    super(...arguments);
    this.handler = UnsafeProposedOrPreviousValueOfSymbol;
  }
};
var UnsafeProposedOrPreviousValueOf = (identifier) => UnsafeProposedOrPreviousValueOfEffect.new({ identifier });
var UnsafePreviousValueOfSymbol = Symbol("UnsafePreviousValueOfSymbol");
var UnsafePreviousValueOfEffect = class extends Effect {
  constructor() {
    super(...arguments);
    this.handler = UnsafePreviousValueOfSymbol;
  }
};
var UnsafePreviousValueOf = (identifier) => UnsafePreviousValueOfEffect.new({ identifier });

// ../chronograph/src/class/Mixin.js
var MixinInstanceOfProperty = Symbol("MixinIdentity");
var MixinStateProperty = Symbol("MixinStateProperty");
var MixinWalkDepthState = class {
  constructor() {
    this.baseEl = void 0;
    this.sourceEl = void 0;
    this.$elementsByTopoLevel = void 0;
    this.$topoLevels = void 0;
    this.linearizedByTopoLevelsSource = MI(this.linearizedByTopoLevels());
  }
  static new(props) {
    const me = new this();
    props && Object.assign(me, props);
    return me;
  }
  get topoLevels() {
    if (this.$topoLevels !== void 0)
      return this.$topoLevels;
    return this.$topoLevels = this.buildTopoLevels();
  }
  buildTopoLevels() {
    return Array.from(this.elementsByTopoLevel.keys()).sort((level1, level2) => level1 - level2);
  }
  get elementsByTopoLevel() {
    if (this.$elementsByTopoLevel !== void 0)
      return this.$elementsByTopoLevel;
    return this.$elementsByTopoLevel = this.buildElementsByTopoLevel();
  }
  getOrCreateLevel(map2, topoLevel) {
    let elementsAtLevel = map2.get(topoLevel);
    if (!elementsAtLevel) {
      elementsAtLevel = [];
      map2.set(topoLevel, elementsAtLevel);
    }
    return elementsAtLevel;
  }
  buildElementsByTopoLevel() {
    let maxTopoLevel = 0;
    const baseElements = this.baseEl ? CI(this.baseEl.walkDepthState.elementsByTopoLevel.values()).concat().toSet() : /* @__PURE__ */ new Set();
    const map2 = CI(this.sourceEl.requirements).map((mixin2) => mixin2.walkDepthState.elementsByTopoLevel).concat().reduce((elementsByTopoLevel, [topoLevel, mixins]) => {
      if (topoLevel > maxTopoLevel)
        maxTopoLevel = topoLevel;
      this.getOrCreateLevel(elementsByTopoLevel, topoLevel).push(mixins);
      return elementsByTopoLevel;
    }, /* @__PURE__ */ new Map());
    this.getOrCreateLevel(map2, maxTopoLevel + 1).push([this.sourceEl]);
    return CI(map2).map(([level, elements]) => {
      return [level, CI(elements).concat().uniqueOnly().filter((mixin2) => !baseElements.has(mixin2)).sort((mixin1, mixin2) => mixin1.id - mixin2.id)];
    }).toMap();
  }
  *linearizedByTopoLevels() {
    yield* CI(this.topoLevels).map((level) => this.elementsByTopoLevel.get(level)).concat();
  }
};
var MIXIN_ID = 1;
var identity = (a) => class extends a {
};
var ZeroBaseClass = class {
};
var MixinState = class {
  constructor() {
    this.id = MIXIN_ID++;
    this.requirements = [];
    this.baseClass = ZeroBaseClass;
    this.identitySymbol = void 0;
    this.mixinLambda = identity;
    this.walkDepthState = void 0;
    this.$minimalClass = void 0;
    this.name = "";
  }
  static new(props) {
    const me = new this();
    props && Object.assign(me, props);
    me.walkDepthState = MixinWalkDepthState.new({ sourceEl: me, baseEl: getMixinState(me.baseClass) });
    const mixinLambda = me.mixinLambda;
    const symbol = me.identitySymbol = Symbol(mixinLambda.name);
    const mixinLambdaWrapper = Object.assign(function(base) {
      const extendedClass = mixinLambda(base);
      extendedClass.prototype[symbol] = true;
      return extendedClass;
    }, {
      [MixinInstanceOfProperty]: symbol,
      [MixinStateProperty]: me
    });
    Object.defineProperty(mixinLambdaWrapper, Symbol.hasInstance, { value: isInstanceOfStatic });
    me.mixinLambda = mixinLambdaWrapper;
    return me;
  }
  get minimalClass() {
    if (this.$minimalClass !== void 0)
      return this.$minimalClass;
    return this.$minimalClass = this.buildMinimalClass();
  }
  // get hash () : MixinHash {
  //     if (this.$hash !== '') return this.$hash
  //
  //     return this.$hash = this.buildHash()
  // }
  // buildHash () : MixinHash {
  //     return String.fromCharCode(...this.walkDepthState.linearizedByTopoLevelsSource.map(mixin => mixin.id))
  // }
  getBaseClassMixinId(baseClass) {
    const constructor = this.constructor;
    const mixinId = constructor.baseClassesIds.get(baseClass);
    if (mixinId !== void 0)
      return mixinId;
    const newId = MIXIN_ID++;
    constructor.baseClassesIds.set(baseClass, newId);
    return newId;
  }
  buildMinimalClass() {
    const self2 = this.constructor;
    let baseCls = this.baseClass;
    const minimalClassConstructor = this.walkDepthState.linearizedByTopoLevelsSource.reduce((acc, mixin2) => {
      const { cls, hash } = acc;
      const nextHash = hash + String.fromCharCode(mixin2.id);
      let wrapperCls = self2.minimalClassesByLinearHash.get(nextHash);
      if (!wrapperCls) {
        wrapperCls = mixin2.mixinLambda(cls);
        mixin2.name = wrapperCls.name;
        self2.minimalClassesByLinearHash.set(nextHash, wrapperCls);
      }
      acc.cls = wrapperCls;
      acc.hash = nextHash;
      return acc;
    }, { cls: baseCls, hash: String.fromCharCode(this.getBaseClassMixinId(baseCls)) }).cls;
    const minimalClass = Object.assign(minimalClassConstructor, {
      [MixinInstanceOfProperty]: this.identitySymbol,
      [MixinStateProperty]: this,
      mix: this.mixinLambda,
      derive: (base) => Mixin([minimalClass, base], (base2) => class extends base2 {
      }),
      $: this,
      toString: this.toString.bind(this)
    });
    Object.defineProperty(minimalClass, Symbol.hasInstance, { value: isInstanceOfStatic });
    return minimalClass;
  }
  toString() {
    return this.walkDepthState.linearizedByTopoLevelsSource.reduce((acc, mixin2) => `${mixin2.name}(${acc})`, this.baseClass.name);
  }
};
MixinState.minimalClassesByLinearHash = /* @__PURE__ */ new Map();
MixinState.baseClassesIds = /* @__PURE__ */ new Map();
var isMixinClass = (func) => {
  return Object.getPrototypeOf(func.prototype).constructor.hasOwnProperty(MixinStateProperty);
};
var getMixinState = (func) => {
  return Object.getPrototypeOf(func.prototype).constructor[MixinStateProperty];
};
var mixin = (required2, mixinLambda) => {
  let baseClass;
  if (required2.length > 0) {
    const lastRequirement = required2[required2.length - 1];
    if (!isMixinClass(lastRequirement) && lastRequirement !== ZeroBaseClass)
      baseClass = lastRequirement;
  }
  const requirements = [];
  required2.forEach((requirement, index) => {
    const mixinState2 = requirement[MixinStateProperty];
    if (mixinState2 !== void 0) {
      const currentBaseClass = mixinState2.baseClass;
      if (currentBaseClass !== ZeroBaseClass) {
        if (baseClass) {
          if (baseClass !== currentBaseClass) {
            const currentIsSub = currentBaseClass.prototype.isPrototypeOf(baseClass.prototype);
            const currentIsSuper = baseClass.prototype.isPrototypeOf(currentBaseClass.prototype);
            if (!currentIsSub && !currentIsSuper)
              throw new Error("Base class mismatch");
            baseClass = currentIsSuper ? currentBaseClass : baseClass;
          }
        } else
          baseClass = currentBaseClass;
      }
      requirements.push(mixinState2);
    } else {
      if (index !== required2.length - 1)
        throw new Error("Base class should be provided as the last element of the requirements array");
    }
  });
  const mixinState = MixinState.new({
    requirements,
    mixinLambda,
    baseClass: baseClass || ZeroBaseClass
  });
  return mixinState.minimalClass;
};
var isInstanceOfStatic = function(instance) {
  return Boolean(instance && instance[this[MixinInstanceOfProperty]]);
};
var isInstanceOf = (instance, func) => {
  return Boolean(instance && instance[func[MixinInstanceOfProperty]]);
};
var Mixin = mixin;
var MixinAny = mixin;

// ../chronograph/src/environment/Debug.js
var DEBUG = false;
var emptyFn = (...args) => void 0;
var DEBUG_ONLY = (func) => DEBUG ? func : emptyFn;
var debug = DEBUG_ONLY((e) => {
  debugger;
});
var warn = DEBUG_ONLY((e) => {
  if (typeof console !== "undefined")
    console.warn(e);
});
var StackEntry = class extends Base {
};
var SourceLinePoint = class extends Base {
  constructor() {
    super(...arguments);
    this.stackEntries = [];
  }
  static fromError(e) {
    const res = SourceLinePoint.new({
      exception: e,
      stackEntries: parseErrorStack(e.stack)
    });
    return res;
  }
  static fromThisCall() {
    const sourceLinePoint = this.fromError(new Error());
    sourceLinePoint.stackEntries.splice(0, 2);
    return sourceLinePoint;
  }
};
var parseErrorStack = (stack) => {
  return CI(matchAll(/^   +at\s*(.*?)\s*\((https?:\/\/.*?):(\d+):(\d+)/gm, stack)).map((match) => StackEntry.new({
    statement: match[1],
    sourceFile: match[2],
    sourceLine: Number(match[3]),
    sourceCharPos: Number(match[4])
  })).toArray();
};

// ../chronograph/src/primitives/Calculation.js
var ContextSync = Symbol("ContextSync");
var ContextGen = Symbol("ContextGen");
var CalculationGen = class extends Mixin([], (base) => class CalculationGen extends base {
  constructor() {
    super(...arguments);
    this.iterator = void 0;
    this.iterationResult = void 0;
  }
  isCalculationStarted() {
    return Boolean(this.iterator || this.iterationResult);
  }
  isCalculationCompleted() {
    return Boolean(this.iterationResult && this.iterationResult.done);
  }
  get result() {
    return this.iterationResult && this.iterationResult.done ? this.iterationResult.value : void 0;
  }
  startCalculation(onEffect, ...args) {
    const iterator = this.iterator = this.calculation.call(this.context || this, onEffect, ...args);
    return this.iterationResult = iterator.next();
  }
  continueCalculation(value) {
    return this.iterationResult = this.iterator.next(value);
  }
  cleanupCalculation() {
    this.iterationResult = void 0;
    this.iterator = void 0;
  }
  *calculation(onEffect, ...args) {
    throw new Error("Abstract method `calculation` called");
  }
  runSyncWithEffect(onEffect, ...args) {
    this.startCalculation(onEffect, ...args);
    while (!this.isCalculationCompleted()) {
      this.continueCalculation(onEffect(this.iterationResult.value));
    }
    this.iterator = void 0;
    return this.result;
  }
  async runAsyncWithEffect(onEffect, ...args) {
    this.startCalculation(onEffect, ...args);
    while (!this.isCalculationCompleted()) {
      this.continueCalculation(await onEffect(this.iterationResult.value));
    }
    this.iterator = void 0;
    return this.result;
  }
}) {
};
var SynchronousCalculationStarted = Symbol("SynchronousCalculationStarted");
var calculationStartedConstant = { value: SynchronousCalculationStarted };
var CalculationSync = class extends Mixin([], (base) => class CalculationSync extends base {
  constructor() {
    super(...arguments);
    this.iterationResult = void 0;
  }
  isCalculationStarted() {
    return Boolean(this.iterationResult);
  }
  isCalculationCompleted() {
    return Boolean(this.iterationResult && this.iterationResult.done);
  }
  get result() {
    return this.iterationResult && this.iterationResult.done ? this.iterationResult.value : void 0;
  }
  startCalculation(onEffect, ...args) {
    this.iterationResult = calculationStartedConstant;
    return this.iterationResult = {
      done: true,
      value: this.calculation.call(this.context || this, onEffect, ...args)
    };
  }
  continueCalculation(value) {
    throw new Error("Can not continue synchronous calculation");
  }
  cleanupCalculation() {
    this.iterationResult = void 0;
  }
  calculation(onEffect, ...args) {
    throw new Error("Abstract method `calculation` called");
  }
  runSyncWithEffect(onEffect, ...args) {
    this.startCalculation(onEffect, ...args);
    return this.result;
  }
  async runAsyncWithEffect(onEffect, ...args) {
    throw new Error("Can not run synchronous calculation asynchronously");
  }
}) {
};
function runGeneratorSyncWithEffect(effect, func, args, scope) {
  const gen = func.apply(scope || null, args);
  let iteration = gen.next();
  while (!iteration.done) {
    iteration = gen.next(effect(iteration.value));
  }
  return iteration.value;
}
async function runGeneratorAsyncWithEffect(effect, func, args, scope) {
  const gen = func.apply(scope || null, args);
  let iteration = gen.next();
  while (!iteration.done) {
    let effectResolution;
    let repeat = false;
    do {
      repeat = false;
      try {
        effectResolution = effect(iteration.value);
      } catch (e) {
        if (e instanceof Effect) {
          let resolution = await effect(e);
          if (resolution === "Cancel") {
            effect(Reject(e));
            return;
          } else {
            repeat = true;
          }
        }
      }
    } while (repeat);
    if (isPromise(effectResolution))
      iteration = gen.next(await effectResolution);
    else
      iteration = gen.next(effectResolution);
  }
  return iteration.value;
}

// ../chronograph/src/graph/WalkDepth.js
var OnCycleAction;
(function(OnCycleAction2) {
  OnCycleAction2["Cancel"] = "Cancel";
  OnCycleAction2["Resume"] = "Resume";
})(OnCycleAction || (OnCycleAction = {}));
var WalkSource = Symbol("WalkSource");
var NOT_VISITED = -1;
var VISITED_TOPOLOGICALLY = -2;
var WalkContext = class extends Base {
  constructor() {
    super(...arguments);
    this.visited = /* @__PURE__ */ new Map();
    this.toVisit = [];
    this.currentEpoch = 0;
  }
  startFrom(sourceNodes) {
    this.continueFrom(sourceNodes);
  }
  continueFrom(sourceNodes) {
    this.toVisit.push.apply(this.toVisit, sourceNodes.map((node) => {
      return { node, from: WalkSource, label: void 0 };
    }));
    this.walkDepth();
  }
  onNode(node, walkStep) {
  }
  onTopologicalNode(node) {
  }
  onCycle(node, stack) {
    return OnCycleAction.Cancel;
  }
  forEachNext(node, func) {
    throw new Error("Abstract method called");
  }
  collectNext(node, toVisit, visitInfo) {
    throw new Error("Abstract method called");
  }
  getVisitedInfo(node) {
    return this.visited.get(node);
  }
  setVisitedInfo(node, visitedAt, info) {
    if (!info) {
      info = { visitedAt, visitEpoch: this.currentEpoch };
      this.visited.set(node, info);
    } else {
      info.visitedAt = visitedAt;
      info.visitEpoch = this.currentEpoch;
    }
    return info;
  }
  walkDepth() {
    const visited = this.visited;
    const toVisit = this.toVisit;
    let depth;
    while (depth = toVisit.length) {
      const node = toVisit[depth - 1].node;
      const visitedInfo = this.getVisitedInfo(node);
      if (visitedInfo && visitedInfo.visitedAt === VISITED_TOPOLOGICALLY && visitedInfo.visitEpoch === this.currentEpoch) {
        toVisit.pop();
        continue;
      }
      if (visitedInfo && visitedInfo.visitEpoch === this.currentEpoch && visitedInfo.visitedAt !== NOT_VISITED) {
        if (visitedInfo.visitedAt < depth) {
          if (this.onCycle(node, toVisit) !== OnCycleAction.Resume)
            break;
        } else {
          visitedInfo.visitedAt = VISITED_TOPOLOGICALLY;
          this.onTopologicalNode(node);
        }
        toVisit.pop();
      } else {
        if (this.onNode(node, toVisit[depth - 1]) === false)
          break;
        const visitedInfo2 = this.setVisitedInfo(node, depth, visitedInfo);
        const lengthBefore = toVisit.length;
        this.collectNext(node, toVisit, visitedInfo2);
        if (toVisit.length === lengthBefore) {
          visitedInfo2.visitedAt = VISITED_TOPOLOGICALLY;
          this.onTopologicalNode(node);
          toVisit.pop();
        }
      }
    }
  }
};
function cycleInfo(stack) {
  const length = stack.length;
  if (length === 0)
    return [];
  const cycleSource = stack[length - 1].node;
  const cycle = [cycleSource];
  let current = length - 1;
  let cursor = current;
  while (current >= 0 && stack[current].from !== cycleSource) {
    while (current >= 0 && stack[current].from === stack[cursor].from)
      current--;
    if (current >= 0) {
      cycle.push(stack[current].node);
      cursor = current;
    }
  }
  if (current < 0)
    return [];
  cycle.push(cycleSource);
  return cycle.reverse();
}

// ../chronograph/src/chrono/Quark.js
var EdgeType;
(function(EdgeType2) {
  EdgeType2[EdgeType2["Normal"] = 1] = "Normal";
  EdgeType2[EdgeType2["Past"] = 2] = "Past";
})(EdgeType || (EdgeType = {}));
var ORIGIN_ID = 0;
var Quark = class extends MixinAny([Map], (base) => class Quark extends base {
  constructor() {
    super(...arguments);
    this.createdAt = void 0;
    this.identifier = void 0;
    this.value = void 0;
    this.proposedValue = void 0;
    this.proposedIsPrevious = false;
    this.proposedArguments = void 0;
    this.usedProposedOrPrevious = false;
    this.previous = void 0;
    this.origin = void 0;
    this.originId = MIN_SMI;
    this.needToBuildProposedValue = false;
    this.edgesFlow = 0;
    this.visitedAt = NOT_VISITED;
    this.visitEpoch = 0;
    this.promise = void 0;
    this.$outgoingPast = void 0;
  }
  static new(props) {
    const instance = new this();
    props && Object.assign(instance, props);
    return instance;
  }
  get level() {
    return this.identifier.level;
  }
  get calculation() {
    return this.identifier.calculation;
  }
  get context() {
    return this.identifier.context || this.identifier;
  }
  forceCalculation() {
    this.edgesFlow = MAX_SMI;
  }
  cleanup() {
    this.cleanupCalculation();
  }
  isShadow() {
    return Boolean(this.origin && this.origin !== this);
  }
  resetToEpoch(epoch) {
    this.visitEpoch = epoch;
    this.visitedAt = NOT_VISITED;
    if (this.edgesFlow < 0)
      this.edgesFlow = 0;
    this.usedProposedOrPrevious = false;
    this.cleanupCalculation();
    this.clearOutgoing();
    this.promise = void 0;
    if (this.origin && this.origin === this) {
      this.proposedArguments = void 0;
      if (this.value !== void 0) {
        this.proposedValue = this.value;
      }
      this.value = void 0;
    } else {
      this.origin = void 0;
      this.value = void 0;
    }
    if (this.identifier.proposedValueIsBuilt && this.proposedValue !== TombStone) {
      this.needToBuildProposedValue = true;
      this.proposedValue = void 0;
    }
  }
  copyFrom(origin) {
    this.value = origin.value;
    this.proposedValue = origin.proposedValue;
    this.proposedArguments = origin.proposedArguments;
    this.usedProposedOrPrevious = origin.usedProposedOrPrevious;
  }
  clearProperties() {
    this.value = void 0;
    this.proposedValue = void 0;
    this.proposedArguments = void 0;
  }
  mergePreviousOrigin(latestScope) {
    const origin = this.origin;
    if (origin !== this.previous)
      throw new Error("Invalid state");
    this.copyFrom(origin);
    const outgoing = this.getOutgoing();
    for (const [identifier, quark] of origin.getOutgoing()) {
      const ownOutgoing = outgoing.get(identifier);
      if (!ownOutgoing) {
        const latest = latestScope.get(identifier);
        if (!latest || latest.originId === quark.originId)
          outgoing.set(identifier, latest || quark);
      }
    }
    if (origin.$outgoingPast !== void 0) {
      const outgoingPast = this.getOutgoingPast();
      for (const [identifier, quark] of origin.getOutgoingPast()) {
        const ownOutgoing = outgoingPast.get(identifier);
        if (!ownOutgoing) {
          const latest = latestScope.get(identifier);
          if (!latest || latest.originId === quark.originId)
            outgoingPast.set(identifier, latest || quark);
        }
      }
    }
    this.origin = this;
    origin.clearProperties();
    origin.clear();
  }
  setOrigin(origin) {
    this.origin = origin;
    this.originId = origin.originId;
  }
  getOrigin() {
    if (this.origin)
      return this.origin;
    return this.startOrigin();
  }
  startOrigin() {
    this.originId = ORIGIN_ID++;
    return this.origin = this;
  }
  getOutgoing() {
    return this;
  }
  getOutgoingPast() {
    if (this.$outgoingPast !== void 0)
      return this.$outgoingPast;
    return this.$outgoingPast = /* @__PURE__ */ new Map();
  }
  addOutgoingTo(toQuark, type) {
    const outgoing = type === EdgeType.Normal ? this : this.getOutgoingPast();
    outgoing.set(toQuark.identifier, toQuark);
  }
  clearOutgoing() {
    this.clear();
    if (this.$outgoingPast !== void 0)
      this.$outgoingPast.clear();
  }
  getValue() {
    const origin = this.origin;
    return origin === this ? this.value : origin ? origin.getValue() : void 0;
  }
  setValue(value) {
    if (this.origin && this.origin !== this)
      throw new Error("Can not set value to the shadow entry");
    this.getOrigin().value = value;
  }
  hasValue() {
    return this.getValue() !== void 0;
  }
  hasProposedValue() {
    if (this.isShadow())
      return false;
    return this.hasProposedValueInner();
  }
  hasProposedValueInner() {
    return this.proposedValue !== void 0;
  }
  getProposedValue(transaction) {
    if (this.needToBuildProposedValue) {
      this.proposedValue = this.identifier.buildProposedValue.call(this.identifier.context || this.identifier, this.identifier, this, transaction);
      this.needToBuildProposedValue = false;
    }
    return this.proposedValue;
  }
  outgoingInTheFutureCb(revision, forEach) {
    let current = this;
    while (current) {
      for (const outgoing of current.getOutgoing().values()) {
        if (outgoing.originId === revision.getLatestEntryFor(outgoing.identifier).originId)
          forEach(outgoing);
      }
      if (current.isShadow())
        current = current.previous;
      else
        current = null;
    }
  }
  outgoingInTheFutureAndPastCb(revision, forEach) {
    let current = this;
    while (current) {
      for (const outgoing of current.getOutgoing().values()) {
        const latestEntry = revision.getLatestEntryFor(outgoing.identifier);
        if (latestEntry && outgoing.originId === latestEntry.originId)
          forEach(outgoing);
      }
      if (current.$outgoingPast !== void 0) {
        for (const outgoing of current.$outgoingPast.values()) {
          const latestEntry = revision.getLatestEntryFor(outgoing.identifier);
          if (latestEntry && outgoing.originId === latestEntry.originId)
            forEach(outgoing);
        }
      }
      if (current.isShadow())
        current = current.previous;
      else
        current = null;
    }
  }
  outgoingInTheFutureAndPastTransactionCb(transaction, forEach) {
    let current = this;
    while (current) {
      for (const outgoing of current.getOutgoing().values()) {
        const latestEntry = transaction.getLatestStableEntryFor(outgoing.identifier);
        if (latestEntry && outgoing.originId === latestEntry.originId)
          forEach(outgoing);
      }
      if (current.$outgoingPast !== void 0) {
        for (const outgoing of current.$outgoingPast.values()) {
          const latestEntry = transaction.getLatestStableEntryFor(outgoing.identifier);
          if (latestEntry && outgoing.originId === latestEntry.originId)
            forEach(outgoing);
        }
      }
      if (current.isShadow())
        current = current.previous;
      else
        current = null;
    }
  }
  // ignores the "past" edges by design, as they do not form cycles
  outgoingInTheFutureTransactionCb(transaction, forEach) {
    let current = this;
    while (current) {
      for (const outgoing of current.getOutgoing().values()) {
        const latestEntry = transaction.getLatestEntryFor(outgoing.identifier);
        if (latestEntry && outgoing.originId === latestEntry.originId)
          forEach(outgoing);
      }
      if (current.isShadow())
        current = current.previous;
      else
        current = null;
    }
  }
}) {
};
var TombStone = Symbol("Tombstone");

// ../chronograph/src/chrono/Identifier.js
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Levels;
(function(Levels2) {
  Levels2[Levels2["UserInput"] = 0] = "UserInput";
  Levels2[Levels2["DependsOnlyOnUserInput"] = 1] = "DependsOnlyOnUserInput";
  Levels2[Levels2["DependsOnlyOnDependsOnlyOnUserInput"] = 2] = "DependsOnlyOnDependsOnlyOnUserInput";
  Levels2[Levels2["DependsOnSelfKind"] = 3] = "DependsOnSelfKind";
})(Levels || (Levels = {}));
var Meta = class extends Base {
  constructor() {
    super(...arguments);
    this.name = void 0;
    this.lazy = false;
    this.total = true;
    this.pure = true;
    this.proposedValueIsBuilt = false;
  }
  /**
   * The calculation function of the identifier. Its returning value has a generic type, that is converted to a specific type,
   * based on the generic attribute `ContextT`.
   *
   * This function will receive a single argument - current calculation context (effects handler).
   *
   * When using generators, there's no need to use this handler - one can "yield" the value directly, using the `yield` construct.
   *
   * Compare:
   *
   *     class Author extends Entity.mix(Base) {
   *         @field()
   *         firstName       : string
   *         @field()
   *         lastName        : string
   *         @field()
   *         fullName        : string
   *
   *         @calculate('fullName')
   *         * calculateFullName () : ChronoIterator<string> {
   *             return (yield this.$.firstName) + ' ' + (yield this.$.lastName)
   *         }
   *
   *         @calculate('fullName')
   *         calculateFullName (Y) : string {
   *             return Y(this.$.firstName) + ' ' + Y(this.$.lastName)
   *         }
   *     }
   *
   * @param Y
   */
  calculation(Y) {
    throw new Error("Abstract method `calculation` called");
  }
  /**
   * The equality check of the identifier. By default is performed with `===`.
   *
   * @param v1 First value
   * @param v2 Second value
   */
  equality(v1, v2) {
    return v1 === v2;
  }
};
__decorate2([
  prototypeValue(Levels.DependsOnSelfKind)
], Meta.prototype, "level", void 0);
__decorate2([
  prototypeValue(true)
], Meta.prototype, "sync", void 0);
var Identifier = class extends Meta {
  constructor() {
    super(...arguments);
    this.context = void 0;
    this.isWritingUndefined = false;
  }
  newQuark(createdAt) {
    const newQuark = this.quarkClass.new();
    newQuark.createdAt = createdAt;
    newQuark.identifier = this;
    newQuark.needToBuildProposedValue = this.proposedValueIsBuilt;
    return newQuark;
  }
  write(me, transaction, quark, proposedValue, ...args) {
    quark = quark || transaction.getWriteTarget(me);
    quark.proposedValue = proposedValue;
    quark.proposedArguments = args.length > 0 ? args : void 0;
    quark.proposedIsPrevious = transaction.graph.isWritingPreviousData;
  }
  writeToTransaction(transaction, proposedValue, ...args) {
    transaction.write(this, proposedValue, ...args);
  }
  /**
   * Write a value to this identifier, in the context of `graph`.
   *
   * @param graph
   * @param proposedValue
   * @param args
   */
  writeToGraph(graph, proposedValue, ...args) {
    graph.write(this, proposedValue, ...args);
  }
  /**
   * Read the value of this identifier, in the context of `graph`, asynchronously
   * @param graph
   */
  readFromGraphAsync(graph) {
    return graph.readAsync(this);
  }
  /**
   * Read the value of this identifier, in the context of `graph`, synchronously
   * @param graph
   */
  readFromGraph(graph) {
    return graph.read(this);
  }
  readFromTransaction(transaction) {
    return transaction.read(this);
  }
  readFromTransactionAsync(transaction) {
    return transaction.readAsync(this);
  }
  // readFromGraphDirtySync (graph : CheckoutI) : ValueT {
  //     return graph.readDirty(this)
  // }
  buildProposedValue(me, quark, transaction) {
    return void 0;
  }
  /**
   * Template method, which is called, when this identifier "enters" the graph.
   *
   * @param graph
   */
  enterGraph(graph) {
  }
  /**
   * Template method, which is called, when this identifier "leaves" the graph.
   *
   * @param graph
   */
  leaveGraph(graph) {
  }
};
var IdentifierC = (config) => Identifier.new(config);
var QuarkSync = Quark.mix(CalculationSync.mix(Map));
var QuarkGen = Quark.mix(CalculationGen.mix(Map));
var Variable = class extends Identifier {
  calculation(YIELD) {
    throw new Error("The 'calculation' method of the variables should never be called. Instead, the value will be set directly to quark");
  }
  write(me, transaction, quark, proposedValue, ...args) {
    quark = quark || transaction.getWriteTarget(me);
    quark.value = proposedValue;
    quark.proposedArguments = args.length > 0 ? args : void 0;
  }
};
__decorate2([
  prototypeValue(Levels.UserInput)
], Variable.prototype, "level", void 0);
__decorate2([
  prototypeValue(QuarkSync)
], Variable.prototype, "quarkClass", void 0);
function VariableC(...args) {
  return Variable.new(...args);
}
var CalculatedValueSync = class extends Identifier {
  calculation(YIELD) {
    return YIELD(ProposedOrPrevious);
  }
};
__decorate2([
  prototypeValue(QuarkSync)
], CalculatedValueSync.prototype, "quarkClass", void 0);
function CalculatedValueSyncC(...args) {
  return CalculatedValueSync.new(...args);
}
var CalculatedValueGen = class extends Identifier {
  *calculation(YIELD) {
    return yield ProposedOrPrevious;
  }
};
__decorate2([
  prototypeValue(QuarkGen)
], CalculatedValueGen.prototype, "quarkClass", void 0);
function CalculatedValueGenC(...args) {
  return CalculatedValueGen.new(...args);
}
var throwUnknownIdentifier = (identifier) => {
  throw new Error(`Unknown identifier ${identifier}`);
};

// ../chronograph/src/chrono/Revision.js
var CLOCK = 0;
var Revision = class extends Base {
  constructor() {
    super(...arguments);
    this.createdAt = CLOCK++;
    this.name = "revision-" + this.createdAt;
    this.previous = void 0;
    this.scope = /* @__PURE__ */ new Map();
    this.reachableCount = 0;
    this.referenceCount = 0;
    this.selfDependent = /* @__PURE__ */ new Set();
  }
  getLatestEntryFor(identifier) {
    let revision = this;
    while (revision) {
      const entry = revision.scope.get(identifier);
      if (entry)
        return entry;
      revision = revision.previous;
    }
    return null;
  }
  hasIdentifier(identifier) {
    const latestEntry = this.getLatestEntryFor(identifier);
    return Boolean(latestEntry && latestEntry.getValue() !== TombStone);
  }
  *previousAxis() {
    let revision = this;
    while (revision) {
      yield revision;
      revision = revision.previous;
    }
  }
};

// ../chronograph/src/util/LeveledQueue.js
var LeveledQueue = class {
  constructor() {
    this.length = 0;
    this.levels = [];
    this.lowestLevel = MAX_SMI;
  }
  getLowestLevel() {
    for (let i = this.lowestLevel !== MAX_SMI ? this.lowestLevel : 0; i < this.levels.length; i++) {
      if (this.levels[i])
        return this.lowestLevel = i;
    }
    return this.lowestLevel = MAX_SMI;
  }
  takeLowestLevel() {
    for (let i = this.lowestLevel !== MAX_SMI ? this.lowestLevel : 0; i < this.levels.length; i++) {
      const level = this.levels[i];
      if (level) {
        this.length -= level.length;
        this.levels[i] = null;
        this.lowestLevel = i + 1;
        return level;
      }
    }
  }
  // resetCachedPosition () {
  //     this.lowestLevel               = MAX_SMI
  // }
  // last () {
  //     for (let i = this.lowestLevel !== MAX_SMI ? this.lowestLevel : 0; i < this.levels.length; i++) {
  //         const level     = this.levels[ i ]
  //
  //         if (level && level.length > 0) {
  //             this.lowestLevel   = i
  //
  //             return level[ level.length - 1 ]
  //         }
  //     }
  // }
  pop() {
    for (let i = this.lowestLevel !== MAX_SMI ? this.lowestLevel : 0; i < this.levels.length; i++) {
      const level = this.levels[i];
      this.lowestLevel = i;
      if (level && level.length > 0) {
        this.length--;
        return level.pop();
      }
    }
    this.lowestLevel = MAX_SMI;
  }
  push(el) {
    const elLevel = el.level;
    let level = this.levels[elLevel];
    if (!level) {
      for (let i = this.levels.length; i < elLevel; i++)
        this.levels[i] = null;
      level = this.levels[elLevel] = [];
    }
    level.push(el);
    this.length++;
    if (elLevel < this.lowestLevel)
      this.lowestLevel = elLevel;
  }
  *[Symbol.iterator]() {
    for (let i = 0; i < this.levels.length; i++) {
      const level = this.levels[i];
      if (level)
        yield* level;
    }
  }
};

// ../chronograph/src/chrono/TransactionCycleDetectionWalkContext.js
var ComputationCycle = class extends Base {
  toString() {
    const cycleIdentifiers = [];
    const cycleEvents = [];
    this.cycle.forEach(({ name, context }) => {
      cycleIdentifiers.push(name);
      if (cycleEvents[cycleEvents.length - 1] !== context)
        cycleEvents.push(context);
    });
    return "events: \n" + cycleEvents.map((event) => "#" + event.id).join(" => ") + "\n\nidentifiers: \n" + cycleIdentifiers.join("\n");
  }
};
var TransactionCycleDetectionWalkContext = class extends WalkContext {
  constructor() {
    super(...arguments);
    this.transaction = void 0;
  }
  onCycle(node, stack) {
    return OnCycleAction.Cancel;
  }
  doCollectNext(from, to, toVisit) {
    let visit = this.visited.get(to);
    if (!visit) {
      visit = { visitedAt: NOT_VISITED, visitEpoch: this.currentEpoch };
      this.visited.set(to, visit);
    }
    toVisit.push({ node: to, from, label: void 0 });
  }
  collectNext(from, toVisit) {
    const latestEntry = this.transaction.getLatestEntryFor(from);
    if (latestEntry) {
      latestEntry.outgoingInTheFutureTransactionCb(this.transaction, (outgoingEntry) => {
        this.doCollectNext(from, outgoingEntry.identifier, toVisit);
      });
    }
  }
};

// ../chronograph/src/chrono/TransactionWalkDepth.js
var TransactionWalkDepth = class extends Base {
  constructor() {
    super(...arguments);
    this.visited = /* @__PURE__ */ new Map();
    this.transaction = void 0;
    this.baseRevision = void 0;
    this.pushTo = void 0;
    this.toVisit = [];
    this.currentEpoch = 0;
  }
  startFrom(sourceNodes) {
    this.continueFrom(sourceNodes);
  }
  continueFrom(sourceNodes) {
    this.toVisit.push.apply(this.toVisit, sourceNodes);
    this.walkDepth();
  }
  startNewEpoch() {
    if (this.toVisit.length)
      throw new Error("Can not start new walk epoch in the middle of the walk");
    this.currentEpoch++;
  }
  onTopologicalNode(identifier, visitInfo) {
    if (!identifier.lazy && identifier.level !== Levels.UserInput)
      this.pushTo.push(visitInfo);
  }
  onCycle(node, stack) {
    return OnCycleAction.Resume;
  }
  // it is more efficient (=faster) to create new quarks for yet unvisited identifiers
  // in batches, using this method, instead of in normal flow in the `walkDepth` method
  // this is probably because of the CPU context switch between the `this.visited` and `this.baseRevision.getLatestEntryFor`
  doCollectNext(from, to, toVisit) {
    let quark = this.visited.get(to);
    if (!quark) {
      quark = to.newQuark(this.baseRevision);
      quark.visitEpoch = this.currentEpoch;
      this.visited.set(to, quark);
    }
    toVisit.push(to);
  }
  collectNext(from, toVisit, visitInfo) {
    const latestEntry = this.baseRevision.getLatestEntryFor(from);
    if (latestEntry) {
      visitInfo.previous = latestEntry;
      latestEntry.outgoingInTheFutureAndPastTransactionCb(this.transaction, (outgoingEntry) => {
        this.doCollectNext(from, outgoingEntry.identifier, toVisit);
      });
    }
    for (const outgoingIdentifier of visitInfo.getOutgoing().keys()) {
      this.doCollectNext(from, outgoingIdentifier, toVisit);
    }
    if (visitInfo.$outgoingPast !== void 0)
      for (const outgoingIdentifier of visitInfo.getOutgoingPast().keys()) {
        this.doCollectNext(from, outgoingIdentifier, toVisit);
      }
  }
  walkDepth() {
    const visited = this.visited;
    const toVisit = this.toVisit;
    let depth;
    while (depth = toVisit.length) {
      const node = toVisit[depth - 1];
      let visitInfo = visited.get(node);
      if (visitInfo && visitInfo.visitedAt === VISITED_TOPOLOGICALLY && visitInfo.visitEpoch === this.currentEpoch) {
        visitInfo.edgesFlow++;
        toVisit.pop();
        continue;
      }
      if (visitInfo && visitInfo.visitEpoch === this.currentEpoch && visitInfo.visitedAt !== NOT_VISITED) {
        if (visitInfo.visitedAt < depth) {
          if (this.onCycle(node, toVisit) !== OnCycleAction.Resume)
            break;
          visitInfo.edgesFlow++;
        } else {
          visitInfo.visitedAt = VISITED_TOPOLOGICALLY;
          this.onTopologicalNode(node, visitInfo);
        }
        toVisit.pop();
      } else {
        const lengthBefore = toVisit.length;
        if (!visitInfo) {
          visitInfo = node.newQuark(this.baseRevision);
          visitInfo.visitEpoch = this.currentEpoch;
          visited.set(node, visitInfo);
        }
        this.collectNext(node, toVisit, visitInfo);
        if (visitInfo.visitEpoch < this.currentEpoch) {
          visitInfo.resetToEpoch(this.currentEpoch);
        }
        visitInfo.visitedAt = depth;
        visitInfo.edgesFlow++;
        if (toVisit.length === lengthBefore) {
          visitInfo.visitedAt = VISITED_TOPOLOGICALLY;
          this.onTopologicalNode(node, visitInfo);
          toVisit.pop();
        }
      }
    }
  }
};

// ../chronograph/src/chrono/Transaction.js
var EdgeTypeNormal = EdgeType.Normal;
var EdgeTypePast = EdgeType.Past;
var Transaction = class extends Base {
  constructor() {
    super(...arguments);
    this.baseRevision = void 0;
    this.candidateClass = Revision;
    this.candidate = void 0;
    this.graph = void 0;
    this.isClosed = false;
    this.walkContext = void 0;
    this.entries = /* @__PURE__ */ new Map();
    this.stackGen = new LeveledQueue();
    this.activeStack = [];
    this.onEffectSync = void 0;
    this.onEffectAsync = void 0;
    this.propagationStartDate = 0;
    this.lastProgressNotificationDate = 0;
    this.startProgressNotificationsAfterMs = 500;
    this.emitProgressNotificationsEveryMs = 200;
    this.emitProgressNotificationsEveryCalculations = 100;
    this.plannedTotalIdentifiersToCalculate = 0;
    this.ongoing = Promise.resolve();
    this.selfDependedMarked = false;
    this.rejectedWith = void 0;
    this.stopped = false;
    this.hasEntryWithProposedValue = false;
    this.hasVariableEntry = false;
  }
  initialize(...args) {
    super.initialize(...args);
    this.walkContext = TransactionWalkDepth.new({
      visited: this.entries,
      transaction: this,
      baseRevision: this.baseRevision,
      pushTo: this.stackGen
    });
    if (!this.candidate)
      this.candidate = this.candidateClass.new({ previous: this.baseRevision });
    this.onEffectSync = /*this.onEffectAsync =*/
    this.read.bind(this);
    this.onEffectAsync = this.readAsync.bind(this);
  }
  get dirty() {
    return this.entries.size > 0;
  }
  markSelfDependent() {
    if (this.selfDependedMarked)
      return;
    this.selfDependedMarked = true;
    for (const selfDependentIden of this.baseRevision.selfDependent) {
      const existing = this.entries.get(selfDependentIden);
      if (existing && existing.getValue() === TombStone)
        continue;
      this.touch(selfDependentIden);
    }
  }
  // onNewWrite () {
  //     this.writes.forEach(writeInfo => {
  //         const identifier    = writeInfo.identifier
  //
  //         identifier.write.call(identifier.context || identifier, identifier, this, null, ...writeInfo.proposedArgs)
  //     })
  //
  //     this.writes.length = 0
  // }
  getActiveEntry() {
    return this.activeStack[this.activeStack.length - 1];
  }
  yieldAsync(effect) {
    if (isPromise(effect))
      return effect;
    return this.graph[effect.handler](effect, this);
  }
  // see the comment for the `onEffectSync`
  yieldSync(effect) {
    if (isPromise(effect)) {
      throw new Error("Can not yield a promise in the synchronous context");
    }
    return this.graph[effect.handler](effect, this);
  }
  // this seems to be an optimistic version
  readAsync(identifier) {
    if (!(identifier instanceof Identifier))
      return this.yieldAsync(identifier);
    let entry;
    const activeEntry = this.getActiveEntry();
    if (activeEntry) {
      entry = this.addEdge(identifier, activeEntry, EdgeTypeNormal);
    } else {
      entry = this.entries.get(identifier);
      if (!entry) {
        const previousEntry = this.baseRevision.getLatestEntryFor(identifier);
        if (!previousEntry)
          throwUnknownIdentifier(identifier);
        entry = previousEntry.hasValue() ? previousEntry : this.touch(identifier);
      }
    }
    if (entry.hasValue())
      return entry.getValue();
    if (entry.promise)
      return entry.promise;
    if (!entry.previous || !entry.previous.hasValue())
      entry.forceCalculation();
    return this.ongoing = entry.promise = this.ongoing.then(() => {
      return (async () => {
        while (this.stackGen.lowestLevel < identifier.level) {
          await runGeneratorAsyncWithEffect(this.onEffectAsync, this.calculateTransitionsStackGen, [this.onEffectAsync, this.stackGen.takeLowestLevel()], this);
        }
        this.markSelfDependent();
        if (entry.getValue() === void 0)
          return runGeneratorAsyncWithEffect(this.onEffectAsync, this.calculateTransitionsStackGen, [this.onEffectAsync, [entry]], this);
      })();
    }).then(() => {
      if (this.rejectedWith)
        throw new Error(`Transaction rejected: ${String(this.rejectedWith.reason)}`);
      if (!entry.hasValue())
        throw new Error("Computation cycle. Sync");
      return entry.getValue();
    });
  }
  // `ignoreActiveEntry` should be used when the atom needs to be read outside the currently ongoing transaction context
  // in such case we still might need to calculate the atom, but should ignore any currently active
  // calculation of the another atom
  get(identifier) {
    if (!(identifier instanceof Identifier))
      return this.yieldSync(identifier);
    let entry;
    const activeEntry = this.getActiveEntry();
    if (activeEntry) {
      entry = this.addEdge(identifier, activeEntry, EdgeTypeNormal);
    } else {
      entry = this.entries.get(identifier);
      if (!entry) {
        const previousEntry = this.baseRevision.getLatestEntryFor(identifier);
        if (!previousEntry)
          throwUnknownIdentifier(identifier);
        entry = previousEntry.hasValue() ? previousEntry : this.touch(identifier);
      }
    }
    const value1 = entry.getValue();
    if (value1 === TombStone)
      throwUnknownIdentifier(identifier);
    if (value1 !== void 0 && entry.hasValue())
      return value1;
    if (entry.promise)
      return entry.promise;
    if (!entry.previous || !entry.previous.hasValue())
      entry.forceCalculation();
    while (this.stackGen.getLowestLevel() < identifier.level) {
      this.calculateTransitionsStackSync(this.onEffectSync, this.stackGen.takeLowestLevel());
    }
    this.markSelfDependent();
    if (identifier.sync) {
      this.calculateTransitionsStackSync(this.onEffectSync, [entry]);
      const value = entry.getValue();
      if (value === void 0)
        throw new Error("Cycle during synchronous computation");
      if (value === TombStone)
        throwUnknownIdentifier(identifier);
      return value;
    } else {
      const promise = this.ongoing = entry.promise = this.ongoing.then(() => {
        if (entry.getValue() === void 0)
          return runGeneratorAsyncWithEffect(this.onEffectAsync, this.calculateTransitionsStackGen, [this.onEffectAsync, [entry]], this);
      }).then(() => {
        if (this.rejectedWith)
          throw new Error(`Transaction rejected: ${String(this.rejectedWith.reason)}`);
        const value = entry.getValue();
        if (value === void 0)
          throw new Error("Computation cycle. Async get");
        if (value === TombStone)
          throwUnknownIdentifier(identifier);
        return value;
      });
      if (DEBUG) {
        promise.quark = entry;
      }
      return promise;
    }
  }
  // this seems to be an optimistic version
  read(identifier) {
    if (!(identifier instanceof Identifier))
      return this.yieldSync(identifier);
    let entry;
    const activeEntry = this.getActiveEntry();
    if (activeEntry) {
      entry = this.addEdge(identifier, activeEntry, EdgeTypeNormal);
    } else {
      entry = this.entries.get(identifier);
      if (!entry) {
        const previousEntry = this.baseRevision.getLatestEntryFor(identifier);
        if (!previousEntry)
          throwUnknownIdentifier(identifier);
        entry = previousEntry.hasValue() ? previousEntry : this.touch(identifier);
      }
    }
    const value1 = entry.getValue();
    if (value1 === TombStone)
      throwUnknownIdentifier(identifier);
    if (value1 !== void 0)
      return value1;
    if (!entry.previous || !entry.previous.hasValue())
      entry.forceCalculation();
    while (this.stackGen.getLowestLevel() < identifier.level) {
      this.calculateTransitionsStackSync(this.onEffectSync, this.stackGen.takeLowestLevel());
    }
    this.markSelfDependent();
    this.calculateTransitionsStackSync(this.onEffectSync, [entry]);
    const value = entry.getValue();
    if (value === void 0)
      throw new Error("Cycle during synchronous computation");
    if (value === TombStone)
      throwUnknownIdentifier(identifier);
    return value;
  }
  // semantic is actually - read the most-fresh value
  readCurrentOrProposedOrPrevious(identifier) {
    const dirtyQuark = this.entries.get(identifier);
    if (dirtyQuark) {
      const value = dirtyQuark.getValue();
      if (value !== void 0)
        return value;
      if (dirtyQuark.proposedValue !== void 0)
        return dirtyQuark.proposedValue;
    }
    return this.readPrevious(identifier);
  }
  readCurrentOrProposedOrPreviousAsync(identifier) {
    const dirtyQuark = this.entries.get(identifier);
    if (dirtyQuark) {
      const value = dirtyQuark.getValue();
      if (value !== void 0)
        return value;
      if (dirtyQuark.proposedValue !== void 0)
        return dirtyQuark.proposedValue;
    }
    return this.readPreviousAsync(identifier);
  }
  readPrevious(identifier) {
    const previousEntry = this.baseRevision.getLatestEntryFor(identifier);
    if (!previousEntry)
      return void 0;
    const value = previousEntry.getValue();
    return value !== TombStone ? value === void 0 && identifier.lazy ? this.read(identifier) : value : void 0;
  }
  readPreviousAsync(identifier) {
    const previousEntry = this.baseRevision.getLatestEntryFor(identifier);
    if (!previousEntry)
      return void 0;
    const value = previousEntry.getValue();
    return value !== TombStone ? value !== void 0 ? value : this.readAsync(identifier) : void 0;
  }
  readProposedOrPrevious(identifier) {
    const dirtyQuark = this.entries.get(identifier);
    if (dirtyQuark && dirtyQuark.proposedValue !== void 0) {
      return dirtyQuark.proposedValue;
    } else {
      return this.readPrevious(identifier);
    }
  }
  readProposedOrPreviousAsync(identifier) {
    const dirtyQuark = this.entries.get(identifier);
    if (dirtyQuark && dirtyQuark.proposedValue !== void 0) {
      return dirtyQuark.proposedValue;
    } else {
      return this.readPreviousAsync(identifier);
    }
  }
  write(identifier, proposedValue, ...args) {
    if (proposedValue === void 0)
      proposedValue = null;
    identifier.write.call(
      identifier.context || identifier,
      identifier,
      this,
      null,
      /*this.getWriteTarget(identifier),*/
      proposedValue,
      ...args
    );
    const entry = this.entries.get(identifier);
    this.hasVariableEntry = this.hasVariableEntry || !entry.isShadow() && identifier.level === Levels.UserInput;
    this.hasEntryWithProposedValue = this.hasEntryWithProposedValue || entry.hasProposedValue();
  }
  // acquireQuark<T extends Identifier> (identifier : T) : InstanceType<T[ 'quarkClass' ]> {
  //     return this.touch(identifier).startOrigin() as InstanceType<T[ 'quarkClass' ]>
  // }
  getWriteTarget(identifier) {
    return this.touch(identifier).startOrigin();
  }
  // return quark if it exists and is non-shadowing, otherwise undefined
  acquireQuarkIfExists(identifier) {
    const entry = this.entries.get(identifier);
    return entry && entry.origin === entry ? entry.origin : void 0;
  }
  touch(identifier) {
    const existingEntry = this.entries.get(identifier);
    if (!existingEntry || existingEntry.visitEpoch < this.walkContext.currentEpoch)
      this.walkContext.continueFrom([identifier]);
    const entry = existingEntry || this.entries.get(identifier);
    entry.forceCalculation();
    return entry;
  }
  // touchInvalidate (identifier : Identifier) : Quark {
  //     const existingEntry         = this.entries.get(identifier)
  //
  //     if (existingEntry && existingEntry.hasValue()) {
  //         this.walkContext.startNewEpoch()
  //     }
  //
  //     if (!existingEntry || existingEntry.visitEpoch < this.walkContext.currentEpoch) this.walkContext.continueFrom([ identifier ])
  //
  //     const entry                 = existingEntry || this.entries.get(identifier)
  //
  //     entry.forceCalculation()
  //
  //     return entry
  // }
  hasIdentifier(identifier) {
    const activeEntry = this.entries.get(identifier);
    if (activeEntry && activeEntry.getValue() === TombStone)
      return false;
    return Boolean(activeEntry || this.baseRevision.getLatestEntryFor(identifier));
  }
  // this is actually an optimized version of `write`, which skips the graph walk phase
  // (since the identifier is assumed to be new, there should be no dependent quarks)
  addIdentifier(identifier, proposedValue, ...args) {
    let entry = this.entries.get(identifier);
    const alreadyHadEntry = Boolean(entry);
    const isVariable = identifier.level === Levels.UserInput;
    if (!entry) {
      entry = identifier.newQuark(this.baseRevision);
      entry.previous = this.baseRevision.getLatestEntryFor(identifier);
      entry.forceCalculation();
      this.entries.set(identifier, entry);
      if (!identifier.lazy && !isVariable)
        this.stackGen.push(entry);
      this.hasVariableEntry = this.hasVariableEntry || !entry.isShadow() && isVariable;
      this.hasEntryWithProposedValue = this.hasEntryWithProposedValue || entry.hasProposedValue();
    }
    if (proposedValue !== void 0 || isVariable) {
      entry.startOrigin();
      const shouldNotWrite = alreadyHadEntry && (entry.proposedValue !== void 0 || entry.value !== void 0);
      if (!shouldNotWrite || entry.proposedValue === TombStone || entry.value === TombStone) {
        identifier.isWritingUndefined = proposedValue === void 0;
        identifier.write.call(identifier.context || identifier, identifier, this, entry, proposedValue === void 0 && isVariable ? null : proposedValue, ...args);
        identifier.isWritingUndefined = false;
      }
    }
    if (entry.getValue() === TombStone)
      entry.value = void 0;
    if (entry.proposedValue === TombStone)
      entry.proposedValue = void 0;
    identifier.enterGraph(this.graph);
    return entry;
  }
  removeIdentifier(identifier) {
    identifier.leaveGraph(this.graph);
    const entry = this.touch(identifier).startOrigin();
    entry.setValue(TombStone);
    this.candidate.selfDependent.delete(identifier);
  }
  populateCandidateScopeFromTransitions(candidate, scope) {
    if (candidate.scope.size === 0) {
      candidate.scope = scope;
    } else {
      for (const [identifier, quark] of scope) {
        if (quark.isShadow()) {
          const latestEntry = candidate.getLatestEntryFor(identifier);
          quark.getOutgoing().forEach((toQuark, toIdentifier) => latestEntry.getOutgoing().set(toIdentifier, toQuark));
        } else {
          candidate.scope.set(identifier, quark);
        }
      }
    }
  }
  preCommit(args) {
    if (this.isClosed)
      throw new Error("Can not propagate closed revision");
    this.markSelfDependent();
    this.isClosed = true;
    this.propagationStartDate = Date.now();
    this.plannedTotalIdentifiersToCalculate = this.stackGen.length;
  }
  postCommit() {
    this.populateCandidateScopeFromTransitions(this.candidate, this.entries);
    const entries = this.entries;
    this.walkContext = void 0;
    return { revision: this.candidate, entries, transaction: this };
  }
  commit(args) {
    this.preCommit(args);
    this.calculateTransitionsSync(this.onEffectSync);
    return this.postCommit();
  }
  reject(rejection = RejectEffect.new()) {
    this.rejectedWith = rejection;
    this.walkContext = void 0;
  }
  // stops the calculations, but does not reject
  stop() {
    this.stopped = true;
  }
  clearRejected() {
    for (const quark of this.entries.values()) {
      quark.cleanup();
    }
    this.entries.clear();
  }
  // // propagation that does not use generators at all
  // propagateSync (args? : PropagateArguments) : TransactionPropagateResult {
  //     const stack = this.prePropagate(args)
  //
  //     this.calculateTransitionsStackSync(this.onEffectSync, stack)
  //     // runGeneratorSyncWithEffect(this.onEffectSync, this.calculateTransitionsStackGen, [ this.onEffectSync, stack ], this)
  //
  //     return this.postPropagate()
  // }
  async commitAsync(args) {
    this.preCommit(args);
    return this.ongoing = this.ongoing.then(() => {
      return runGeneratorAsyncWithEffect(this.onEffectAsync, this.calculateTransitions, [this.onEffectAsync], this);
    }).then(() => {
      return this.postCommit();
    });
  }
  getLatestEntryFor(identifier) {
    let entry = this.entries.get(identifier) || this.baseRevision.getLatestEntryFor(identifier);
    if (entry && entry.getValue() === TombStone)
      return void 0;
    return entry;
  }
  // check the transaction "entries" first, but only return an entry
  // from that, if it is already calculated, otherwise - take it
  // from the base revision
  getLatestStableEntryFor(identifier) {
    let entry = this.entries.get(identifier);
    if (entry) {
      const value = entry.getValue();
      if (value === TombStone)
        return void 0;
      return value === void 0 ? this.baseRevision.getLatestEntryFor(identifier) : entry;
    } else {
      return this.baseRevision.getLatestEntryFor(identifier);
    }
  }
  addEdge(identifierRead, activeEntry, type) {
    const identifier = activeEntry.identifier;
    if (identifier.level < identifierRead.level)
      throw new Error("Identifier can not read from higher level identifier");
    let entry = this.entries.get(identifierRead);
    if (!entry) {
      const previousEntry = this.baseRevision.getLatestEntryFor(identifierRead);
      if (!previousEntry)
        throwUnknownIdentifier(identifierRead);
      entry = identifierRead.newQuark(this.baseRevision);
      entry.setOrigin(previousEntry);
      entry.previous = previousEntry;
      this.entries.set(identifierRead, entry);
    }
    entry.addOutgoingTo(activeEntry, type);
    return entry;
  }
  onQuarkCalculationCompleted(entry, value) {
    entry.cleanup();
    const identifier = entry.identifier;
    const previousEntry = entry.previous;
    const sameAsPrevious = Boolean(previousEntry && previousEntry.hasValue() && identifier.equality(value, previousEntry.getValue()));
    if (sameAsPrevious) {
      previousEntry.outgoingInTheFutureAndPastTransactionCb(this, (previousOutgoingEntry) => {
        const outgoingEntry = this.entries.get(previousOutgoingEntry.identifier);
        if (outgoingEntry)
          outgoingEntry.edgesFlow--;
      });
      entry.edgesFlow = MAX_SMI;
      entry.setOrigin(previousEntry.origin);
      entry.value = value;
    } else {
      entry.startOrigin();
      entry.setValue(value);
    }
    let ignoreSelfDependency = false;
    if (entry.usedProposedOrPrevious) {
      if (entry.proposedValue !== void 0) {
        if (identifier.equality(value, entry.proposedValue))
          ignoreSelfDependency = true;
      } else {
        if (sameAsPrevious || !previousEntry && value === null)
          ignoreSelfDependency = true;
      }
      if (!ignoreSelfDependency)
        this.candidate.selfDependent.add(identifier);
    }
  }
  onReadIdentifier(identifierRead, activeEntry, stack) {
    const requestedEntry = this.addEdge(identifierRead, activeEntry, EdgeTypeNormal);
    if (requestedEntry.hasValue() || requestedEntry.value !== void 0) {
      const value = requestedEntry.getValue();
      if (value === TombStone)
        throwUnknownIdentifier(identifierRead);
      return activeEntry.continueCalculation(value);
    } else if (requestedEntry.isShadow()) {
      requestedEntry.startOrigin();
      requestedEntry.forceCalculation();
      stack.push(requestedEntry);
      return void 0;
    } else {
      if (!requestedEntry.isCalculationStarted()) {
        stack.push(requestedEntry);
        if (!requestedEntry.previous || !requestedEntry.previous.hasValue())
          requestedEntry.forceCalculation();
        return void 0;
      } else {
        let cycle;
        const walkContext = TransactionCycleDetectionWalkContext.new({
          transaction: this,
          onCycle(node, stack2) {
            cycle = ComputationCycle.new({
              cycle: cycleInfo(stack2),
              requestedEntry,
              activeEntry
            });
            return OnCycleAction.Cancel;
          }
        });
        walkContext.startFrom([requestedEntry.identifier]);
        return cycle;
      }
    }
  }
  *calculateTransitions(context) {
    const queue = this.stackGen;
    while (queue.length) {
      yield* this.calculateTransitionsStackGen(context, queue.takeLowestLevel());
    }
  }
  calculateTransitionsSync(context) {
    const queue = this.stackGen;
    while (queue.length) {
      this.calculateTransitionsStackSync(context, queue.takeLowestLevel());
    }
  }
  // this method is not decomposed into smaller ones intentionally, as that makes benchmarks worse
  // it seems that overhead of calling few more functions in such tight loop as this outweighs the optimization
  *calculateTransitionsStackGen(context, stack) {
    if (this.rejectedWith || this.stopped)
      return;
    this.walkContext.startNewEpoch();
    const entries = this.entries;
    const propagationStartDate = this.propagationStartDate;
    const enableProgressNotifications = this.graph ? this.graph.enableProgressNotifications : false;
    let counter = 0;
    const prevActiveStack = this.activeStack;
    this.activeStack = stack;
    while (stack.length && !this.rejectedWith && !this.stopped) {
      if (enableProgressNotifications && !(counter++ % this.emitProgressNotificationsEveryCalculations)) {
        const now = Date.now();
        const elapsed = now - propagationStartDate;
        if (elapsed > this.startProgressNotificationsAfterMs) {
          const lastProgressNotificationDate = this.lastProgressNotificationDate;
          if (!lastProgressNotificationDate || now - lastProgressNotificationDate > this.emitProgressNotificationsEveryMs) {
            this.lastProgressNotificationDate = now;
            this.graph.onPropagationProgressNotification({
              total: this.plannedTotalIdentifiersToCalculate,
              remaining: this.stackGen.length + stack.length,
              phase: "propagating"
            });
            this.activeStack = prevActiveStack;
            yield delay(0);
            this.activeStack = stack;
          }
        }
      }
      if (this.rejectedWith || this.stopped)
        break;
      const entry = stack[stack.length - 1];
      const identifier = entry.identifier;
      const ownEntry = entries.get(identifier);
      if (ownEntry !== entry) {
        entry.cleanup();
        stack.pop();
        continue;
      }
      if (entry.edgesFlow == 0) {
        entry.edgesFlow--;
        const previousEntry = entry.previous;
        previousEntry && previousEntry.outgoingInTheFutureAndPastTransactionCb(this, (outgoing) => {
          const outgoingEntry = entries.get(outgoing.identifier);
          if (outgoingEntry)
            outgoingEntry.edgesFlow--;
        });
      }
      if (entry.edgesFlow < 0 && entry.previous && entry.previous.origin) {
        entry.setOrigin(entry.previous.origin);
        if (entry.size === 0) {
          entries.delete(identifier);
        }
        entry.cleanup();
        stack.pop();
        continue;
      }
      if (
        /*entry.isShadow() ||*/
        entry.hasValue() || entry.proposedValue === TombStone
      ) {
        entry.cleanup();
        stack.pop();
        continue;
      }
      const startedAtEpoch = entry.visitEpoch;
      let iterationResult = entry.isCalculationStarted() ? entry.iterationResult : entry.startCalculation(this.onEffectSync);
      while (iterationResult && !this.rejectedWith && !this.stopped) {
        const value = iterationResult.value === void 0 ? null : iterationResult.value;
        if (entry.isCalculationCompleted()) {
          if (entry.visitEpoch == startedAtEpoch) {
            this.onQuarkCalculationCompleted(entry, value);
          }
          stack.pop();
          break;
        } else if (value instanceof Identifier) {
          const onReadIdentifierResult = this.onReadIdentifier(value, entry, stack);
          if (onReadIdentifierResult instanceof ComputationCycle) {
            this.walkContext.startNewEpoch();
            yield* this.graph.onComputationCycleHandler(onReadIdentifierResult);
            entry.cleanupCalculation();
            iterationResult = void 0;
          } else {
            iterationResult = onReadIdentifierResult;
          }
        } else if (value === SynchronousCalculationStarted) {
          stack.pop();
          break;
        } else {
          const effectResult = yield value;
          if (effectResult === BreakCurrentStackExecution)
            break;
          if (entry.visitEpoch === startedAtEpoch) {
            iterationResult = entry.continueCalculation(effectResult);
          } else {
            stack.pop();
            break;
          }
        }
      }
    }
    this.activeStack = prevActiveStack;
  }
  // THIS METHOD HAS TO BE KEPT SYNCED WITH THE `calculateTransitionsStackGen` !!!
  calculateTransitionsStackSync(context, stack) {
    if (this.rejectedWith || this.stopped)
      return;
    this.walkContext.startNewEpoch();
    const entries = this.entries;
    const prevActiveStack = this.activeStack;
    this.activeStack = stack;
    while (stack.length && !this.rejectedWith && !this.stopped) {
      const entry = stack[stack.length - 1];
      const identifier = entry.identifier;
      const ownEntry = entries.get(identifier);
      if (ownEntry !== entry) {
        entry.cleanup();
        stack.pop();
        continue;
      }
      if (entry.edgesFlow == 0) {
        entry.edgesFlow--;
        const previousEntry = entry.previous;
        previousEntry && previousEntry.outgoingInTheFutureAndPastTransactionCb(this, (outgoing) => {
          const outgoingEntry = entries.get(outgoing.identifier);
          if (outgoingEntry)
            outgoingEntry.edgesFlow--;
        });
      }
      if (entry.edgesFlow < 0 && entry.previous && entry.previous.origin) {
        entry.setOrigin(entry.previous.origin);
        if (entry.size === 0) {
          entries.delete(identifier);
        }
        entry.cleanup();
        stack.pop();
        continue;
      }
      if (
        /*entry.isShadow() ||*/
        entry.hasValue() || entry.proposedValue === TombStone
      ) {
        entry.cleanup();
        stack.pop();
        continue;
      }
      const startedAtEpoch = entry.visitEpoch;
      let iterationResult = entry.isCalculationStarted() ? entry.iterationResult : entry.startCalculation(this.onEffectSync);
      while (iterationResult && !this.rejectedWith && !this.stopped) {
        const value = iterationResult.value === void 0 ? null : iterationResult.value;
        if (entry.isCalculationCompleted()) {
          if (entry.visitEpoch == startedAtEpoch) {
            this.onQuarkCalculationCompleted(entry, value);
          }
          stack.pop();
          break;
        } else if (value instanceof Identifier) {
          const onReadIdentifierResult = this.onReadIdentifier(value, entry, stack);
          if (onReadIdentifierResult instanceof ComputationCycle) {
            this.walkContext.startNewEpoch();
            this.graph.onComputationCycleHandlerSync(onReadIdentifierResult, this);
            entry.cleanupCalculation();
            iterationResult = void 0;
          } else {
            iterationResult = onReadIdentifierResult;
          }
        } else if (value === SynchronousCalculationStarted) {
          stack.pop();
          break;
        } else {
          const effectResult = context(value);
          if (isPromise(effectResult))
            throw new Error("Effect resolved to promise in the synchronous context, check that you marked the asynchronous calculations accordingly");
          if (effectResult === BreakCurrentStackExecution)
            break;
          if (entry.visitEpoch === startedAtEpoch) {
            iterationResult = entry.continueCalculation(effectResult);
          } else {
            stack.pop();
            break;
          }
        }
      }
    }
    this.activeStack = prevActiveStack;
  }
};

// ../chronograph/src/chrono/Graph.js
var CommitZero = {
  rejectedWith: null
};
var Listener = class extends Base {
  constructor() {
    super(...arguments);
    this.handlers = [];
  }
  trigger(value) {
    for (let i = 0; i < this.handlers.length; i++)
      this.handlers[i](value);
  }
};
var ChronoGraph = class extends Base {
  constructor() {
    super(...arguments);
    this.baseRevisionStable = void 0;
    this.baseRevisionTentative = void 0;
    this.baseRevision = Revision.new();
    this.topRevision = void 0;
    this.historyLimit = 0;
    this.listeners = /* @__PURE__ */ new Map();
    this.isWritingPreviousData = false;
    this.$activeTransaction = void 0;
    this.isCommitting = false;
    this.enableProgressNotifications = false;
    this.ongoing = Promise.resolve();
    this._isInitialCommit = true;
    this.autoCommitTimeoutId = null;
    this.autoCommit = false;
    this.autoCommitMode = "sync";
    this.autoCommitHandler = null;
    this.onWriteDuringCommit = "throw";
    this.onComputationCycle = "throw";
    this.transactionClass = Transaction;
    this.isJustCleared = false;
    this.$followingRevision = void 0;
  }
  initialize(...args) {
    super.initialize(...args);
    if (!this.topRevision)
      this.topRevision = this.baseRevision;
    if (this.autoCommit) {
      this.autoCommitHandler = this.autoCommitMode === "sync" ? (arg) => this.commit(arg) : async (arg) => this.commitAsync(arg);
    }
    this.markAndSweep();
  }
  /**
   * Returns boolean, indicating whether the auto-commit is pending.
   */
  hasPendingAutoCommit() {
    return this.autoCommitTimeoutId !== null;
  }
  get dirty() {
    return this.activeTransaction.dirty;
  }
  clear() {
    this.reject();
    this.unScheduleAutoCommit();
    this.baseRevision.scope && this.baseRevision.scope.clear();
    this.baseRevision.previous = null;
    this.listeners.clear();
    this.topRevision = this.baseRevision;
    this.$followingRevision = void 0;
    this.$activeTransaction = void 0;
    this.markAndSweep();
    this.isJustCleared = true;
  }
  *eachReachableRevision() {
    let isBetweenTopBottom = true;
    let counter = 0;
    for (const revision of this.topRevision.previousAxis()) {
      yield [revision, isBetweenTopBottom || counter < this.historyLimit];
      if (revision === this.baseRevision) {
        isBetweenTopBottom = false;
      } else {
        if (!isBetweenTopBottom)
          counter++;
      }
    }
  }
  get isInitialCommit() {
    return this._isInitialCommit;
  }
  set isInitialCommit(value) {
    this._isInitialCommit = value;
  }
  markAndSweep() {
    let lastReferencedRevision;
    const unreachableRevisions = [];
    for (const [revision, isReachable] of this.eachReachableRevision()) {
      if (isReachable) {
        revision.reachableCount++;
        lastReferencedRevision = revision;
      } else
        unreachableRevisions.push(revision);
      revision.referenceCount++;
    }
    unreachableRevisions.unshift(lastReferencedRevision);
    for (let i = unreachableRevisions.length - 1; i >= 1 && unreachableRevisions[i].reachableCount === 0; i--) {
      this.compactRevisions(unreachableRevisions[i - 1], unreachableRevisions[i]);
    }
  }
  compactRevisions(newRev, prevRev) {
    if (prevRev.reachableCount > 0 || newRev.previous !== prevRev)
      throw new Error("Invalid compact operation");
    if (prevRev.referenceCount <= 1) {
      for (const [identifier, entry] of newRev.scope) {
        if (entry.getValue() === TombStone) {
          prevRev.scope.delete(identifier);
        } else {
          const prevQuark = prevRev.scope.get(identifier);
          if (entry.origin === entry) {
            if (prevQuark) {
              prevQuark.clear();
              prevQuark.clearProperties();
            }
          } else if (prevQuark && entry.origin === prevQuark) {
            entry.mergePreviousOrigin(newRev.scope);
          } else if (identifier.lazy && !entry.origin && prevQuark && prevQuark.origin) {
            entry.startOrigin().proposedValue = prevQuark.origin.value !== void 0 ? prevQuark.origin.value : prevQuark.origin.proposedValue;
          }
          entry.previous = void 0;
          prevRev.scope.set(identifier, entry);
        }
      }
      copySetInto(newRev.selfDependent, prevRev.selfDependent);
      newRev.scope = prevRev.scope;
      prevRev.scope = null;
    } else {
      newRev.scope = new Map(concat(prevRev.scope, newRev.scope));
      newRev.selfDependent = new Set(concat(prevRev.selfDependent, newRev.selfDependent));
      prevRev.referenceCount--;
    }
    newRev.previous = null;
  }
  get followingRevision() {
    if (this.$followingRevision !== void 0)
      return this.$followingRevision;
    const revisions = Array.from(this.topRevision.previousAxis());
    const entries = [];
    for (let i = revisions.length - 1; i > 0; i--)
      entries.push([revisions[i], revisions[i - 1]]);
    return this.$followingRevision = new Map(entries);
  }
  get activeTransaction() {
    if (this.$activeTransaction)
      return this.$activeTransaction;
    return this.$activeTransaction = this.transactionClass.new({
      baseRevision: this.baseRevisionTentative || this.baseRevision,
      graph: this
    });
  }
  /**
   * Creates a new branch of this graph. Only committed data will be "visible" in the new branch.
   *
   * ```ts
   * const graph2 = ChronoGraph.new()
   *
   * const variable13 : Variable<number> = graph2.variable(5)
   *
   * const branch2 = graph2.branch()
   *
   * branch2.write(variable13, 10)
   *
   * const value13_1 = graph2.read(variable13)  // 5
   * const value13_2 = branch2.read(variable13) // 10
   * ```
   *
   * When using the branching feature in [[Replica]], you need to reference the field values by yielding their
   * corresponding identifiers. This is because ChronoGraph need to know in context of which branch
   * the calculation happens and this information is encoded in the outer context. This may improve in the future.
   *
   * ```ts
   * class Author extends Entity.mix(Base) {
   *     @calculate('fullName')
   *     calculateFullName (Y) : string {
   *         return Y(this.$.firstName) + ' ' + Y(this.$.lastName)
   *     }
   *
   *     @calculate('fullName')
   *     * calculateFullName (Y) : CalculationIterator<string> {
   *         return (yield this.$.firstName) + ' ' + (yield this.$.lastName)
   *     }
   * }
   * ```
   *
   * @param config Configuration object for the new graph instance.
   */
  branch(config) {
    const Constructor = this.constructor;
    return Constructor.new(Object.assign({}, config, { baseRevision: this.baseRevision }));
  }
  propagate(args) {
    return this.commit(args);
  }
  /**
   * Rejects the current changes in the graph and revert it to the state of the previous [[commit]].
   *
   * See also [[RejectEffect]].
   *
   * @param reason Any value, describing why reject has happened
   */
  reject(reason) {
    this.activeTransaction.reject(RejectEffect.new({ reason }));
    this.ongoing = Promise.resolve();
    this.$activeTransaction = void 0;
    this.baseRevisionTentative = void 0;
    if (this.baseRevisionStable) {
      this.baseRevision = this.baseRevisionStable;
      this.baseRevisionStable = void 0;
    }
  }
  /**
   * Synchronously commit the state of the graph. All potentially changed [[Identifier.lazy|strict]] identifiers
   * will be calculated during this call. If any of such identifiers will be [[Identifier.sync|async]], an exception
   * will be thrown.
   *
   * This call marks a "stable" state of the graph and a transaction border. Using the [[undo]] call one can revert to the previous
   * state.
   *
   * See also [[reject]].
   *
   * @param args
   */
  commit(args) {
    this.isJustCleared = false;
    this.unScheduleAutoCommit();
    this.baseRevisionStable = this.baseRevision;
    const activeTransaction = this.activeTransaction;
    const transactionCommitResult = activeTransaction.commit(args);
    this.$activeTransaction = void 0;
    const result = this.finalizeCommit(transactionCommitResult);
    this.baseRevisionStable = void 0;
    this.isInitialCommit = false;
    return result;
  }
  async propagateAsync(args) {
    return this.commitAsync(args);
  }
  /**
   * Asynchronously commit the state of the replica. All potentially changed strict identifiers (see [[Identifier.lazy]])
   * will be calculated during this call.
   *
   * This call marks a "stable" state of the graph and a transaction border. Using the [[undo]] call one can revert to the previous
   * state.
   *
   * See also [[reject]].
   *
   * @param args
   */
  async commitAsync(args) {
    if (this.isCommitting)
      return this.ongoing;
    this.isJustCleared = false;
    this.isCommitting = true;
    this.baseRevisionStable = this.baseRevision;
    let result;
    return this.ongoing = this.ongoing.then(() => {
      return this.doCommitAsync(args);
    }).then((res) => {
      result = res;
      return res;
    }).finally(() => {
      this.baseRevisionStable = void 0;
      this.baseRevisionTentative = void 0;
      this.isInitialCommit = false;
      this.isCommitting = false;
    });
  }
  async doCommitAsync(args) {
    this.unScheduleAutoCommit();
    const activeTransaction = this.activeTransaction;
    const transactionResult = await activeTransaction.commitAsync(args);
    const rejectedDuringCommit = Boolean(activeTransaction.rejectedWith);
    const prevBaseTentative = this.baseRevisionTentative;
    if (!rejectedDuringCommit)
      this.baseRevisionTentative = activeTransaction.candidate;
    this.$activeTransaction = void 0;
    await this.finalizeCommitAsync(transactionResult);
    if (this.isJustCleared)
      return { rejectedWith: RejectEffect.new({ reason: "Graph cleared" }) };
    if (activeTransaction.rejectedWith && !rejectedDuringCommit) {
      this.baseRevisionTentative = prevBaseTentative;
      this.$activeTransaction = void 0;
    }
    const result = this.finalizeCommit(transactionResult);
    if (activeTransaction.rejectedWith)
      activeTransaction.clearRejected();
    if (this.dirty && !activeTransaction.rejectedWith) {
      await this.doCommitAsync(args);
    }
    return result;
  }
  finalizeCommit(transactionResult) {
    const { revision, entries, transaction } = transactionResult;
    if (!transaction.rejectedWith) {
      if (revision.previous !== this.baseRevision)
        throw new Error("Invalid revisions chain");
      for (const [revision2, isReachable] of this.eachReachableRevision()) {
        if (isReachable)
          revision2.reachableCount--;
        revision2.referenceCount--;
      }
      this.baseRevision = this.topRevision = revision;
      for (const [identifier, quarkEntry] of entries) {
        quarkEntry.cleanup();
        if (quarkEntry.isShadow() || !quarkEntry.hasValue())
          continue;
        const listener = this.listeners.get(identifier);
        if (listener)
          listener.trigger(quarkEntry.getValue());
      }
      this.$followingRevision = void 0;
      this.markAndSweep();
    } else {
      if (this.baseRevisionStable)
        this.baseRevision = this.baseRevisionStable;
      this.baseRevisionStable = void 0;
      this.baseRevisionTentative = void 0;
    }
    return { rejectedWith: transaction.rejectedWith };
  }
  async finalizeCommitAsync(transactionResult) {
  }
  *onComputationCycleHandler(cycle) {
    const exception = new Error("Computation cycle:\n" + cycle);
    exception.cycle = cycle;
    switch (this.onComputationCycle) {
      case "ignore":
        console.log(exception.message);
        const { requestedEntry, activeEntry } = cycle;
        return activeEntry.continueCalculation(requestedEntry.proposedValue !== void 0 ? requestedEntry.proposedValue : requestedEntry.value);
      case "throw":
        throw exception;
      case "reject":
        this.reject(exception);
        break;
      case "warn":
        warn(exception);
        break;
    }
  }
  onComputationCycleHandlerSync(cycle, transaction) {
    const exception = new Error("Computation cycle:\n" + cycle);
    exception.cycle = cycle;
    switch (this.onComputationCycle) {
      case "ignore":
        console.log(exception.message);
        const { requestedEntry, activeEntry } = cycle;
        return activeEntry.continueCalculation(requestedEntry.proposedValue !== void 0 ? requestedEntry.proposedValue : requestedEntry.value);
      case "throw":
        throw exception;
      case "reject":
        this.reject(exception);
        break;
      case "warn":
        warn(exception);
        break;
    }
  }
  scheduleAutoCommit() {
    if (this.autoCommitTimeoutId === null && !this.isCommitting) {
      this.autoCommitTimeoutId = setTimeout(this.autoCommitHandler, 10);
    }
  }
  unScheduleAutoCommit() {
    if (this.autoCommitTimeoutId !== null) {
      clearTimeout(this.autoCommitTimeoutId);
      this.autoCommitTimeoutId = null;
    }
  }
  /**
   * Creates a variable identifier with the given initial value and adds it to graph.
   *
   * @param value The initial value. The `undefined` value will be converted to `null`
   */
  variable(value) {
    const variable = VariableC();
    return this.addIdentifier(variable, value === void 0 ? null : value);
  }
  /**
   * Creates a named variable identifier with the given initial value and adds it to graph.
   *
   * @param name The [[Variable.name]] property of the newly created variable
   * @param value The initial value. The `undefined` value will be converted to `null`
   */
  variableNamed(name, value) {
    const variable = VariableC({ name });
    return this.addIdentifier(variable, value === void 0 ? null : value);
  }
  /**
   * Creates an identifier based on the given calculation function and adds it to this graph. Depending form the type of the function
   * (sync/generator) either [[CalculatedValueGen]] or [[CalculatedValueSync]] will be created.
   *
   * To have full control on the identifier creation, instantiate it yourself and add to graph using the [[ChronoGraph.addIdentifier]] call.
   *
   * @param calculation The calculation function of the identifier.
   * @param context The [[Identifier.context|context]] property of the newly created identifier
   */
  identifier(calculation, context) {
    const identifier = isGeneratorFunction(calculation) ? CalculatedValueGenC({ calculation, context }) : CalculatedValueSyncC({ calculation, context });
    return this.addIdentifier(identifier);
  }
  /**
   * Creates a named identifier based on the given calculation function and adds it to this graph. Depending form the type of the function
   * (sync/generator) either [[CalculatedValueGen]] or [[CalculatedValueSync]] will be created.
   *
   * To have full control on the identifier creation, instantiate it yourself and add to graph using the [[ChronoGraph.addIdentifier]] call.
   *
   * @param name The [[Identifier.name]] property of the newly created identifier
   * @param calculation The calculation function of the identifier.
   * @param context The [[Identifier.context]] property of the newly created identifier
   */
  identifierNamed(name, calculation, context) {
    const identifier = calculation.constructor.name === "GeneratorFunction" ? CalculatedValueGenC({ name, calculation, context }) : CalculatedValueSyncC({ name, calculation, context });
    return this.addIdentifier(identifier);
  }
  /**
   * Adds an identifier to this graph. Optionally [[write|writes]] the `proposedValue` to it afterwards.
   *
   * @param identifier
   * @param proposedValue
   * @param args
   */
  addIdentifier(identifier, proposedValue, ...args) {
    if (this.isCommitting) {
      if (this.onWriteDuringCommit === "throw")
        throw new Error("Adding identifier during commit");
      else if (this.onWriteDuringCommit === "warn")
        warn(new Error("Adding identifier during commit"));
    }
    this.activeTransaction.addIdentifier(identifier, proposedValue, ...args);
    if (this.autoCommit)
      this.scheduleAutoCommit();
    return identifier;
  }
  /**
   * Removes an identifier from this graph.
   *
   * @param identifier
   */
  removeIdentifier(identifier) {
    if (this.isCommitting) {
      if (this.onWriteDuringCommit === "throw")
        throw new Error("Removing identifier during commit");
      else if (this.onWriteDuringCommit === "warn")
        warn(new Error("Removinfg identifier during commit"));
    }
    this.activeTransaction.removeIdentifier(identifier);
    this.listeners.delete(identifier);
    if (this.autoCommit)
      this.scheduleAutoCommit();
  }
  /**
   * Tests, whether this graph has given identifier.
   *
   * @param identifier
   */
  hasIdentifier(identifier) {
    return this.activeTransaction.hasIdentifier(identifier);
  }
  /**
   * Writes a value to the given `identifier`.
   *
   * @param identifier
   * @param proposedValue
   * @param args
   */
  write(identifier, proposedValue, ...args) {
    if (this.isCommitting) {
      if (this.onWriteDuringCommit === "throw")
        throw new Error("Write during commit");
      else if (this.onWriteDuringCommit === "warn")
        warn(new Error("Write during commit"));
    }
    this.activeTransaction.write(identifier, proposedValue, ...args);
    if (this.autoCommit)
      this.scheduleAutoCommit();
  }
  // keep if possible?
  // pin (identifier : Identifier) : Quark {
  //     return this.activeTransaction.pin(identifier)
  // }
  // Synchronously read the "previous", "stable" value from the graph. If its a lazy entry, it will be calculated
  // Synchronous read can not calculate lazy asynchronous identifiers and will throw exception
  // Lazy identifiers supposed to be "total" (or accept repeating observes?)
  readPrevious(identifier) {
    return this.activeTransaction.readPrevious(identifier);
  }
  // Asynchronously read the "previous", "stable" value from the graph. If its a lazy entry, it will be calculated
  // Asynchronous read can calculate both synchornous and asynchronous lazy identifiers.
  // Lazy identifiers supposed to be "total" (or accept repeating observes?)
  readPreviousAsync(identifier) {
    return this.activeTransaction.readPreviousAsync(identifier);
  }
  /**
   * Synchronously read the value of the given identifier from the graph.
   *
   * Synchronous read can not calculate asynchronous identifiers and will throw exception
   *
   * @param identifier
   */
  read(identifier) {
    return this.activeTransaction.read(identifier);
  }
  /**
   * Asynchronously read the value of the given identifier from the graph.
   *
   * Asynchronous read can calculate both synchronous and asynchronous identifiers
   *
   * @param identifier
   */
  readAsync(identifier) {
    return this.activeTransaction.readAsync(identifier);
  }
  /**
   * Read the value of the identifier either synchronously or asynchronously, depending on its type (see [[Identifier.sync]])
   *
   * @param identifier
   */
  get(identifier) {
    return this.activeTransaction.get(identifier);
  }
  // // read the identifier value, return the proposed value if no "current" value is calculated yet
  // readDirty<T> (identifier : Identifier<T>) : T {
  //     return this.activeTransaction.readDirty(identifier)
  // }
  //
  //
  // // read the identifier value, return the proposed value if no "current" value is calculated yet
  // readDirtyAsync<T> (identifier : Identifier<T>) : Promise<T> {
  //     return this.activeTransaction.readDirtyAsync(identifier)
  // }
  observe(observerFunc, onUpdated) {
    const identifier = this.addIdentifier(CalculatedValueGen.new({
      // observers are explicitly eager
      lazy: false,
      calculation: observerFunc
    }));
    this.addListener(identifier, onUpdated);
    return identifier;
  }
  observeContext(observerFunc, context, onUpdated) {
    const identifier = this.addIdentifier(CalculatedValueGen.new({
      // observers are explicitly eager
      lazy: false,
      calculation: observerFunc,
      context
    }));
    this.addListener(identifier, onUpdated);
    return identifier;
  }
  addListener(identifier, onUpdated) {
    let listener = this.listeners.get(identifier);
    if (!listener) {
      listener = Listener.new();
      this.listeners.set(identifier, listener);
    }
    listener.handlers.push(onUpdated);
  }
  /**
   * Revert the replica to the state of previous transaction (marked with the [[commit]] call).
   *
   * To enable this feature, you need to opt-in using the [[ChronoGraph.historyLimit|historyLimit]] configuration property.
   *
   * Returns boolean, indicating whether the state transition actually happened.
   */
  undo() {
    const baseRevision = this.baseRevision;
    const previous = baseRevision.previous;
    if (!previous)
      return false;
    this.baseRevision = previous;
    this.$activeTransaction = void 0;
    return true;
  }
  /**
   * Advance the replica to the state of next transaction (marked with the [[commit]] call). Only meaningful
   * if a [[ChronoGraph.undo|undo]] call has been made earlier.
   *
   * To enable this feature, you need to opt-in using the [[historyLimit]] configuration property.
   *
   * Returns boolean, indicating whether the state transition actually happened.
   */
  redo() {
    const baseRevision = this.baseRevision;
    if (baseRevision === this.topRevision)
      return false;
    const nextRevision = this.followingRevision.get(baseRevision);
    this.baseRevision = nextRevision;
    this.$activeTransaction = void 0;
    return true;
  }
  onPropagationProgressNotification(notification) {
  }
  [ProposedOrPreviousSymbol](effect, transaction) {
    const activeEntry = transaction.getActiveEntry();
    activeEntry.usedProposedOrPrevious = true;
    const proposedValue = activeEntry.getProposedValue(transaction);
    if (proposedValue !== void 0)
      return proposedValue;
    if (!activeEntry.previous)
      return void 0;
    const identifier = activeEntry.identifier;
    if (identifier.lazy) {
      if (activeEntry.previous.hasValue())
        return activeEntry.previous.getValue();
      if (activeEntry.previous.hasProposedValue())
        return activeEntry.previous.getProposedValue(transaction);
      return null;
    }
    return transaction.readPrevious(activeEntry.identifier);
  }
  [RejectSymbol](effect, transaction) {
    this.reject(effect.reason);
    return BreakCurrentStackExecution;
  }
  [TransactionSymbol](effect, transaction) {
    return transaction;
  }
  [OwnQuarkSymbol](effect, transaction) {
    return transaction.getActiveEntry();
  }
  [OwnIdentifierSymbol](effect, transaction) {
    const activeEntry = transaction.getActiveEntry();
    return activeEntry.identifier;
  }
  [WriteSymbol](effect, transaction) {
    const activeEntry = transaction.getActiveEntry();
    if (activeEntry.identifier.lazy)
      throw new Error("Lazy identifiers can not use `Write` effect");
    const writeToHigherLevel = effect.identifier.level > activeEntry.identifier.level;
    if (!writeToHigherLevel)
      transaction.walkContext.startNewEpoch();
    transaction.write(effect.identifier, ...effect.proposedArgs);
    return writeToHigherLevel ? void 0 : BreakCurrentStackExecution;
  }
  [WriteSeveralSymbol](effect, transaction) {
    const activeEntry = transaction.getActiveEntry();
    if (activeEntry.identifier.lazy)
      throw new Error("Lazy identifiers can not use `Write` effect");
    let writeToHigherLevel = true;
    effect.writes.forEach((writeInfo) => {
      if (writeInfo.identifier.level <= activeEntry.identifier.level && writeToHigherLevel) {
        transaction.walkContext.startNewEpoch();
        writeToHigherLevel = false;
      }
      transaction.write(writeInfo.identifier, ...writeInfo.proposedArgs);
    });
    return writeToHigherLevel ? void 0 : BreakCurrentStackExecution;
  }
  [PreviousValueOfSymbol](effect, transaction) {
    const activeEntry = transaction.getActiveEntry();
    const source = effect.identifier;
    transaction.addEdge(source, activeEntry, EdgeTypePast);
    return transaction.readPrevious(source);
  }
  [ProposedValueOfSymbol](effect, transaction) {
    const activeEntry = transaction.getActiveEntry();
    const source = effect.identifier;
    transaction.addEdge(source, activeEntry, EdgeTypePast);
    const quark = transaction.entries.get(source);
    const proposedValue = quark && !quark.isShadow() ? quark.getProposedValue(transaction) : void 0;
    return proposedValue;
  }
  [HasProposedValueSymbol](effect, transaction) {
    const activeEntry = transaction.getActiveEntry();
    const source = effect.identifier;
    transaction.addEdge(source, activeEntry, EdgeTypePast);
    const quark = transaction.entries.get(source);
    return quark ? quark.hasProposedValue() : false;
  }
  [HasProposedNotPreviousValueSymbol](effect, transaction) {
    const activeEntry = transaction.getActiveEntry();
    const source = effect.identifier;
    transaction.addEdge(source, activeEntry, EdgeTypePast);
    const quark = transaction.entries.get(source);
    return quark ? quark.hasProposedValue() && !quark.proposedIsPrevious : false;
  }
  [ProposedOrPreviousValueOfSymbol](effect, transaction) {
    const activeEntry = transaction.getActiveEntry();
    const source = effect.identifier;
    transaction.addEdge(source, activeEntry, EdgeTypePast);
    return transaction.readProposedOrPrevious(source);
  }
  [UnsafeProposedOrPreviousValueOfSymbol](effect, transaction) {
    return transaction.readProposedOrPrevious(effect.identifier);
  }
  [UnsafePreviousValueOfSymbol](effect, transaction) {
    return transaction.readPrevious(effect.identifier);
  }
  [ProposedArgumentsOfSymbol](effect, transaction) {
    const activeEntry = transaction.getActiveEntry();
    const source = effect.identifier;
    transaction.addEdge(source, activeEntry, EdgeTypePast);
    const quark = transaction.entries.get(source);
    return quark && !quark.isShadow() ? quark.proposedArguments : void 0;
  }
};

// ../chronograph/src/schema/EntityMeta.js
var EntityMeta = class extends Base {
  constructor() {
    super(...arguments);
    this.name = void 0;
    this.ownFields = /* @__PURE__ */ new Map();
    this.schema = void 0;
    this.$skeleton = {};
    this.$allFields = void 0;
  }
  /**
   * Checks whether the entity has a field with given name (possibly inherited from parent entity).
   *
   * @param name
   */
  hasField(name) {
    return this.getField(name) !== void 0;
  }
  /**
   * Returns a field with given name (possibly inherited) or `undefined` if there's none.
   *
   * @param name
   */
  getField(name) {
    return this.allFields.get(name);
  }
  /**
   * Adds a field to this entity.
   *
   * @param field
   */
  addField(field2) {
    const name = field2.name;
    if (!name)
      throw new Error(`Field must have a name`);
    if (this.ownFields.has(name))
      throw new Error(`Field with name [${name}] already exists`);
    field2.entity = this;
    this.ownFields.set(name, field2);
    return field2;
  }
  forEachParent(func) {
    let entity2 = this;
    while (entity2) {
      func(entity2);
      entity2 = entity2.parentEntity;
    }
  }
  get allFields() {
    if (this.$allFields !== void 0)
      return this.$allFields;
    const allFields = /* @__PURE__ */ new Map();
    const visited = /* @__PURE__ */ new Set();
    this.forEachParent((entity2) => {
      entity2.ownFields.forEach((field2, name) => {
        if (!visited.has(name)) {
          visited.add(name);
          allFields.set(name, field2);
        }
      });
    });
    return this.$allFields = allFields;
  }
  /**
   * Iterator for all fields of this entity (including inherited).
   *
   * @param func
   */
  forEachField(func) {
    this.allFields.forEach(func);
  }
};

// ../chronograph/src/replica/Replica.js
var ReadMode;
(function(ReadMode2) {
  ReadMode2[ReadMode2["Current"] = 0] = "Current";
  ReadMode2[ReadMode2["Previous"] = 1] = "Previous";
  ReadMode2[ReadMode2["ProposedOrPrevious"] = 2] = "ProposedOrPrevious";
  ReadMode2[ReadMode2["CurrentOrProposedOrPrevious"] = 3] = "CurrentOrProposedOrPrevious";
})(ReadMode || (ReadMode = {}));
var Replica = class extends Mixin([ChronoGraph], (base) => class Replica extends base {
  constructor() {
    super(...arguments);
    this.autoCommit = true;
    this.readMode = ReadMode.Current;
  }
  /**
   * Add entity instance to the replica
   *
   * @param entity
   */
  addEntity(entity2) {
    entity2.enterGraph(this);
  }
  /**
   * Add several entity instances to the replica
   *
   * @param entity
   */
  addEntities(entities) {
    entities.forEach((entity2) => this.addEntity(entity2));
  }
  /**
   * Remove entity instance from the replica
   *
   * @param entity
   */
  removeEntity(entity2) {
    entity2.leaveGraph(this);
  }
  /**
   * Remove several entity instances from the replica
   *
   * @param entity
   */
  removeEntities(entities) {
    entities.forEach((entity2) => this.removeEntity(entity2));
  }
}) {
};

// ../chronograph/src/replica/Identifier.js
var FieldIdentifier = class extends Mixin([Identifier], (base) => class FieldIdentifier extends base {
  constructor() {
    super(...arguments);
    this.field = void 0;
    this.self = void 0;
    this.DATA = void 0;
  }
  // standaloneQuark     : InstanceType<this[ 'quarkClass' ]>
  // readFromGraphDirtySync (graph : Checkout) {
  //     if (graph)
  //         return graph.readDirty(this)
  //     else
  //         return this.DATA
  // }
  // returns the value itself if there were no affecting writes for it
  // otherwise - promise
  getFromGraph(graph) {
    if (graph) {
      if (graph.readMode === ReadMode.Current)
        return graph.get(this);
      if (graph.readMode === ReadMode.Previous)
        return graph.activeTransaction.readPrevious(this);
      if (graph.readMode === ReadMode.ProposedOrPrevious)
        graph.activeTransaction.readProposedOrPrevious(this);
      return graph.activeTransaction.readCurrentOrProposedOrPrevious(this);
    } else
      return this.DATA;
  }
  readFromGraph(graph) {
    if (graph)
      return graph.read(this);
    else
      return this.DATA;
  }
  writeToGraph(graph, proposedValue, ...args) {
    if (graph)
      graph.write(this, proposedValue, ...args);
    else
      this.DATA = proposedValue;
  }
  leaveGraph(graph) {
    const entry = graph.activeTransaction.getLatestStableEntryFor(this);
    if (entry)
      this.DATA = entry.getValue();
    super.leaveGraph(graph);
  }
  toString() {
    return this.name;
  }
}) {
};
var MinimalFieldIdentifierSync = class extends FieldIdentifier.mix(CalculatedValueSync) {
};
var MinimalFieldIdentifierGen = class extends FieldIdentifier.mix(CalculatedValueGen) {
};
var MinimalFieldVariable = class extends FieldIdentifier.mix(Variable) {
};
var EntityIdentifier = class extends Mixin([Identifier], (base) => class EntityIdentifier extends base {
  constructor() {
    super(...arguments);
    this.entity = void 0;
    this.self = void 0;
  }
  // entity atom is considered changed if any of its incoming atoms has changed
  // this just means if it's calculation method has been called, it should always
  // assign a new value
  equality() {
    return false;
  }
  toString() {
    return `Entity identifier [${this.self}]`;
  }
}) {
};
var MinimalEntityIdentifier = class extends EntityIdentifier.mix(CalculatedValueGen) {
};

// ../chronograph/src/schema/Field.js
var Field = class extends Meta {
  constructor() {
    super(...arguments);
    this.persistent = true;
  }
  getIdentifierClass(calculationFunction) {
    if (this.identifierCls)
      return this.identifierCls;
    if (!calculationFunction)
      return MinimalFieldVariable;
    return isGeneratorFunction(calculationFunction) ? MinimalFieldIdentifierGen : MinimalFieldIdentifierSync;
  }
};

// ../chronograph/src/replica/Entity.js
var isEntityMarker = Symbol("isEntity");
var Entity = class extends Mixin([], (base) => {
  class Entity2 extends base {
    // marker in the prototype to identify whether the parent class is Entity mixin itself
    // it is not used for `instanceof` purposes and not be confused with the [MixinInstanceOfProperty]
    // (though it is possible to use MixinInstanceOfProperty for this purpose, that would require to
    // make it public
    [isEntityMarker]() {
    }
    /**
     * An [[EntityMeta]] instance, representing the "meta" information about the entity class. It is shared among all instances
     * of the class.
     */
    get $entity() {
      return createEntityOnPrototype(this.constructor.prototype);
    }
    /**
     * An object, which properties corresponds to the ChronoGraph [[Identifier]]s, created for every field.
     *
     * For example:
     *
     * ```ts
     * class Author extends Entity.mix(Base) {
     *     @field()
     *     firstName       : string
     *     @field()
     *     lastName        : string
     * }
     *
     * const author = Author.new()
     *
     * // identifier for the field `firstName`
     * author.$.firstName
     *
     * const firstName = replica.read(author.$.firstName)
     * ```
     */
    get $() {
      const $ = {};
      this.$entity.forEachField((field2, name) => {
        $[name] = this.createFieldIdentifier(field2);
      });
      if (DEBUG) {
        const proxy = new Proxy($, {
          get(entity2, property, receiver) {
            if (!entity2[property])
              debug(new Error(`Attempt to read a missing field ${String(property)} on ${entity2}`));
            entity2[property].SOURCE_POINT = SourceLinePoint.fromThisCall();
            return entity2[property];
          }
        });
        return defineProperty(this, "$", proxy);
      } else {
        return defineProperty(this, "$", $);
      }
    }
    /**
     * A graph identifier, that represents the whole entity.
     */
    get $$() {
      return defineProperty(this, "$$", MinimalEntityIdentifier.new({
        name: this.$entityName,
        entity: this.$entity,
        calculation: this.calculateSelf,
        context: this,
        self: this
      }));
    }
    get $entityName() {
      return this.constructor.name || this.$entity.name;
    }
    *calculateSelf() {
      return this;
    }
    createFieldIdentifier(field2) {
      const name = field2.name;
      const entity2 = this.$entity;
      const constructor = this.constructor;
      const skeleton = entity2.$skeleton;
      if (!skeleton[name])
        skeleton[name] = constructor.getIdentifierTemplateClass(this, field2);
      const identifier = new skeleton[name]();
      identifier.context = this;
      identifier.self = this;
      identifier.name = `${this.$$.name}.$.${field2.name}`;
      return identifier;
    }
    forEachFieldIdentifier(func) {
      this.$entity.forEachField((field2, name) => func(this.$[name], name, field2));
    }
    /**
     * This method is called when entity is added to some replica.
     *
     * @param replica
     */
    enterGraph(replica) {
      if (this.graph)
        throw new Error("Already entered replica");
      this.graph = replica;
      replica.addIdentifier(this.$$);
      this.$entity.forEachField((field2, name) => {
        const identifier = this.$[name];
        replica.addIdentifier(identifier, identifier.DATA);
        identifier.DATA = void 0;
      });
    }
    /**
     * This method is called when entity is removed from the replica it's been added to.
     */
    leaveGraph(graph) {
      const ownGraph = this.graph;
      const removeFrom = graph || ownGraph;
      if (!removeFrom)
        return;
      this.$entity.forEachField((field2, name) => removeFrom.removeIdentifier(this.$[name]));
      removeFrom.removeIdentifier(this.$$);
      if (removeFrom === ownGraph)
        this.graph = void 0;
    }
    // isPropagating () {
    //     return this.getGraph().isPropagating
    // }
    propagate(arg) {
      return this.commit(arg);
    }
    /**
     * This is a convenience method, that just delegates to the [[ChronoGraph.commit]] method of this entity's graph.
     *
     * If there's no graph (entity has not been added to any replica) a [[CommitZero]] constant will be returned.
     */
    commit(arg) {
      const graph = this.graph;
      if (!graph)
        return CommitZero;
      return graph.commit(arg);
    }
    async propagateAsync() {
      return this.commitAsync();
    }
    /**
     * This is a convenience method, that just delegates to the [[ChronoGraph.commitAsync]] method of this entity's graph.
     *
     * If there's no graph (entity has not been added to any replica) a resolved promise with [[CommitZero]] constant will be returned.
     */
    async commitAsync(arg) {
      const graph = this.graph;
      if (!graph)
        return Promise.resolve(CommitZero);
      return graph.commitAsync(arg);
    }
    /**
     * An [[EntityMeta]] instance, representing the "meta" information about the entity class. It is shared among all instances
     * of the class.
     */
    static get $entity() {
      return ensureEntityOnPrototype(this.prototype);
    }
    static getIdentifierTemplateClass(me, field2) {
      const name = field2.name;
      const config = {
        name: `${me.$$.name}.$.${name}`,
        field: field2
      };
      if (field2.hasOwnProperty("sync"))
        config.sync = field2.sync;
      if (field2.hasOwnProperty("lazy"))
        config.lazy = field2.lazy;
      if (field2.hasOwnProperty("equality"))
        config.equality = field2.equality;
      const calculationFunction = me.$calculations && me[me.$calculations[name]];
      if (calculationFunction)
        config.calculation = calculationFunction;
      const writeFunction = me.$writes && me[me.$writes[name]];
      if (writeFunction)
        config.write = writeFunction;
      const buildProposedFunction = me.$buildProposed && me[me.$buildProposed[name]];
      if (buildProposedFunction) {
        config.buildProposedValue = buildProposedFunction;
        config.proposedValueIsBuilt = true;
      }
      const template = field2.getIdentifierClass(calculationFunction).new(config);
      const TemplateClass = function() {
      };
      TemplateClass.prototype = template;
      return TemplateClass;
    }
    // unfortunately, the better typing:
    // run <Name extends AllowedNames<this, AnyFunction>> (methodName : Name, ...args : Parameters<this[ Name ]>)
    //     : ReturnType<this[ Name ]> extends CalculationIterator<infer Res> ? Res : ReturnType<this[ Name ]>
    // yields "types are exceedingly long and possibly infinite on the application side
    run(methodName, ...args) {
      const onEffect = (effect) => {
        if (effect instanceof Identifier)
          return this.graph.read(effect);
        throw new Error("Helper methods can not yield effects during computation");
      };
      const transaction = this.graph.activeTransaction;
      const prevActiveStack = transaction.activeStack;
      transaction.activeStack = [];
      const res = runGeneratorSyncWithEffect(onEffect, this[methodName], args, this);
      transaction.activeStack = prevActiveStack;
      return res;
    }
    static createPropertyAccessorsFor(fieldName) {
      const propertyKey = fieldName;
      const target = this.prototype;
      Object.defineProperty(target, propertyKey, {
        get: function() {
          return this.$[propertyKey].getFromGraph(this.graph);
        },
        set: function(value) {
          this.$[propertyKey].writeToGraph(this.graph, value);
        }
      });
    }
    static createMethodAccessorsFor(fieldName) {
      const propertyKey = fieldName;
      const target = this.prototype;
      const getterFnName = `get${uppercaseFirst(propertyKey)}`;
      const setterFnName = `set${uppercaseFirst(propertyKey)}`;
      const putterFnName = `put${uppercaseFirst(propertyKey)}`;
      if (!(getterFnName in target)) {
        target[getterFnName] = function() {
          return this.$[propertyKey].getFromGraph(this.graph);
        };
      }
      if (!(setterFnName in target)) {
        target[setterFnName] = function(value, ...args) {
          this.$[propertyKey].writeToGraph(this.graph, value, ...args);
          return this.graph ? this.graph.autoCommitMode === "sync" ? this.graph.commit() : this.graph.commitAsync() : Promise.resolve(CommitZero);
        };
      }
      if (!(putterFnName in target)) {
        target[putterFnName] = function(value, ...args) {
          this.$[propertyKey].writeToGraph(this.graph, value, ...args);
        };
      }
    }
  }
  return Entity2;
}) {
};
var createEntityOnPrototype = (proto3) => {
  let parent = Object.getPrototypeOf(proto3);
  return defineProperty(proto3, "$entity", EntityMeta.new({
    parentEntity: parent.hasOwnProperty(isEntityMarker) ? null : parent.$entity,
    name: proto3.constructor.name
  }));
};
var ensureEntityOnPrototype = (proto3) => {
  if (!proto3.hasOwnProperty("$entity"))
    createEntityOnPrototype(proto3);
  return proto3.$entity;
};
var generic_field = (fieldConfig, fieldCls = Field) => {
  return function(target, fieldName) {
    const entity2 = ensureEntityOnPrototype(target);
    const field2 = entity2.addField(fieldCls.new(Object.assign(fieldConfig || {}, {
      name: fieldName
    })));
    const cons = target.constructor;
    cons.createPropertyAccessorsFor(fieldName);
    cons.createMethodAccessorsFor(fieldName);
  };
};
var field = generic_field;
var calculate = function(fieldName) {
  return function(target, propertyKey, _descriptor) {
    ensureEntityOnPrototype(target);
    let calculations;
    if (!target.$calculations) {
      calculations = target.$calculations = {};
    } else {
      if (!target.hasOwnProperty("$calculations")) {
        calculations = target.$calculations = Object.create(target.$calculations);
      } else
        calculations = target.$calculations;
    }
    calculations[fieldName] = propertyKey;
  };
};
var write = function(fieldName) {
  return function(target, propertyKey, _descriptor) {
    ensureEntityOnPrototype(target);
    let writes;
    if (!target.$writes) {
      writes = target.$writes = {};
    } else {
      if (!target.hasOwnProperty("$writes")) {
        writes = target.$writes = Object.create(target.$writes);
      } else
        writes = target.$writes;
    }
    writes[fieldName] = propertyKey;
  };
};
var build_proposed = function(fieldName) {
  return function(target, propertyKey, _descriptor) {
    ensureEntityOnPrototype(target);
    let buildProposed;
    if (!target.$buildProposed) {
      buildProposed = target.$buildProposed = {};
    } else {
      if (!target.hasOwnProperty("$buildProposed")) {
        buildProposed = target.$buildProposed = Object.create(target.$buildProposed);
      } else
        buildProposed = target.$buildProposed;
    }
    buildProposed[fieldName] = propertyKey;
  };
};

// ../Engine/lib/Engine/scheduling/Types.js
var TimeUnit;
(function(TimeUnit2) {
  TimeUnit2["Millisecond"] = "millisecond";
  TimeUnit2["Second"] = "second";
  TimeUnit2["Minute"] = "minute";
  TimeUnit2["Hour"] = "hour";
  TimeUnit2["Day"] = "day";
  TimeUnit2["Week"] = "week";
  TimeUnit2["Month"] = "month";
  TimeUnit2["Quarter"] = "quarter";
  TimeUnit2["Year"] = "year";
})(TimeUnit || (TimeUnit = {}));
var ConstraintType;
(function(ConstraintType2) {
  ConstraintType2["MustStartOn"] = "muststarton";
  ConstraintType2["MustFinishOn"] = "mustfinishon";
  ConstraintType2["StartNoEarlierThan"] = "startnoearlierthan";
  ConstraintType2["StartNoLaterThan"] = "startnolaterthan";
  ConstraintType2["FinishNoEarlierThan"] = "finishnoearlierthan";
  ConstraintType2["FinishNoLaterThan"] = "finishnolaterthan";
  ConstraintType2["AsSoonAsPossible"] = "assoonaspossible";
  ConstraintType2["AsLateAsPossible"] = "aslateaspossible";
})(ConstraintType || (ConstraintType = {}));
var SchedulingMode;
(function(SchedulingMode2) {
  SchedulingMode2["Normal"] = "Normal";
  SchedulingMode2["FixedDuration"] = "FixedDuration";
  SchedulingMode2["FixedEffort"] = "FixedEffort";
  SchedulingMode2["FixedUnits"] = "FixedUnits";
})(SchedulingMode || (SchedulingMode = {}));
var DependencyValidationResult;
(function(DependencyValidationResult2) {
  DependencyValidationResult2[DependencyValidationResult2["NoError"] = 0] = "NoError";
  DependencyValidationResult2[DependencyValidationResult2["CyclicDependency"] = 1] = "CyclicDependency";
  DependencyValidationResult2[DependencyValidationResult2["DuplicatingDependency"] = 2] = "DuplicatingDependency";
})(DependencyValidationResult || (DependencyValidationResult = {}));
var DependencyType;
(function(DependencyType2) {
  DependencyType2[DependencyType2["StartToStart"] = 0] = "StartToStart";
  DependencyType2[DependencyType2["StartToEnd"] = 1] = "StartToEnd";
  DependencyType2[DependencyType2["EndToStart"] = 2] = "EndToStart";
  DependencyType2[DependencyType2["EndToEnd"] = 3] = "EndToEnd";
})(DependencyType || (DependencyType = {}));
var DependenciesCalendar;
(function(DependenciesCalendar2) {
  DependenciesCalendar2["Project"] = "Project";
  DependenciesCalendar2["FromEvent"] = "FromEvent";
  DependenciesCalendar2["ToEvent"] = "ToEvent";
})(DependenciesCalendar || (DependenciesCalendar = {}));
var ProjectType;
(function(ProjectType2) {
  ProjectType2[ProjectType2["SchedulerBasic"] = 1] = "SchedulerBasic";
  ProjectType2[ProjectType2["SchedulerPro"] = 2] = "SchedulerPro";
  ProjectType2[ProjectType2["Gantt"] = 3] = "Gantt";
})(ProjectType || (ProjectType = {}));
var Direction;
(function(Direction2) {
  Direction2["Forward"] = "Forward";
  Direction2["Backward"] = "Backward";
  Direction2["None"] = "None";
})(Direction || (Direction = {}));
var isEqualEffectiveDirection = (a, b) => {
  if (a && !b || !a && b)
    return false;
  if (!a && !b)
    return true;
  return a.direction === b.direction && (a.kind === "own" && b.kind === "own" || a.kind === "enforced" && b.kind === "enforced" && a.enforcedBy === b.enforcedBy || a.kind === "inherited" && b.kind === "inherited" && a.inheritedFrom === b.inheritedFrom);
};
var ConstraintIntervalSide;
(function(ConstraintIntervalSide2) {
  ConstraintIntervalSide2["Start"] = "Start";
  ConstraintIntervalSide2["End"] = "End";
})(ConstraintIntervalSide || (ConstraintIntervalSide = {}));

// ../Engine/lib/Engine/util/Constants.js
var MIN_DATE = /* @__PURE__ */ new Date(-864e13);
var MAX_DATE = /* @__PURE__ */ new Date(864e13);
var isDateFinite = (date) => {
  if (!date)
    return false;
  const time = date.getTime();
  return time !== MIN_DATE.getTime() && time !== MAX_DATE.getTime();
};

// ../chronograph/src/class/RequiredProperty.js
var RequiredProperties = Symbol("RequiredProperties");
var required = DEBUG_ONLY((proto3, propertyKey) => {
  let required2 = proto3[RequiredProperties];
  if (!required2)
    required2 = proto3[RequiredProperties] = [];
  required2.push(propertyKey);
});
var validateRequiredProperties = DEBUG_ONLY((context) => {
  const required2 = context[RequiredProperties];
  if (required2) {
    for (let i = 0; i < required2.length; i++)
      if (context[required2[i]] === void 0)
        throw new Error(`Required attribute [${String(required2[i])}] is not provided`);
  }
});

// ../chronograph/src/cycle_resolver/CycleResolver.js
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var FORMULA_ID = 0;
var CalculateProposed = FORMULA_ID++;
var Formula = class extends Base {
  constructor() {
    super(...arguments);
    this.formulaId = FORMULA_ID++;
    this.inputs = /* @__PURE__ */ new Set();
  }
};
var VariableWalkContext = class extends WalkContext {
  collectNext(sourceNode, toVisit) {
    if (sourceNode instanceof Formula) {
      toVisit.push({ node: sourceNode.output, from: sourceNode, label: void 0 });
    } else {
      const formulas = this.cache.formulasByInput.get(sourceNode);
      formulas && formulas.forEach((formula) => toVisit.push({ node: formula, from: sourceNode, label: void 0 }));
    }
  }
};
var FormulasCache = class extends Mixin([Base], (base) => class FormulasCache extends base {
  constructor() {
    super(...arguments);
    this.variables = /* @__PURE__ */ new Set();
    this.formulas = /* @__PURE__ */ new Set();
    this.$formulasByInput = void 0;
    this.$formulasByOutput = void 0;
  }
  get formulasByInput() {
    if (this.$formulasByInput !== void 0)
      return this.$formulasByInput;
    this.fillCache();
    return this.$formulasByInput;
  }
  get formulasByOutput() {
    if (this.$formulasByOutput !== void 0)
      return this.$formulasByOutput;
    this.fillCache();
    return this.$formulasByOutput;
  }
  add(formula) {
    this.$formulasByInput = void 0;
    this.$formulasByOutput = void 0;
    this.formulas.add(formula);
  }
  has(formula) {
    return this.formulas.has(formula);
  }
  fillCache() {
    this.$formulasByInput = /* @__PURE__ */ new Map();
    this.$formulasByOutput = /* @__PURE__ */ new Map();
    this.formulas.forEach((formula) => {
      let formulasByOutput = this.$formulasByOutput.get(formula.output);
      if (!formulasByOutput) {
        formulasByOutput = /* @__PURE__ */ new Set();
        this.$formulasByOutput.set(formula.output, formulasByOutput);
      }
      formulasByOutput.add(formula);
      formula.inputs.forEach((input) => {
        let formulasByInput = this.$formulasByInput.get(input);
        if (!formulasByInput) {
          formulasByInput = /* @__PURE__ */ new Set();
          this.$formulasByInput.set(input, formulasByInput);
        }
        formulasByInput.add(formula);
      });
    });
  }
  allInputVariables() {
    return uniqueOnly(concatIterable(map(this.formulas, (formula) => formula.inputs.values())));
  }
  isCyclic() {
    let isCyclic = false;
    const walkContext = VariableWalkContext.new({ cache: this, onCycle: () => {
      isCyclic = true;
      return OnCycleAction.Cancel;
    } });
    walkContext.startFrom(Array.from(this.allInputVariables()));
    return isCyclic;
  }
}) {
};
var CycleDescription = class extends FormulasCache {
};
var CycleResolution = class extends Base {
  constructor() {
    super(...arguments);
    this.description = void 0;
    this.defaultResolutionFormulas = /* @__PURE__ */ new Set();
    this.resolutionsByInputHash = /* @__PURE__ */ new Map();
  }
  // the caching space is 3^var_num might need to clear the memory at some time
  clear() {
    this.resolutionsByInputHash.clear();
  }
  /**
   * This method accepts an input object and returns a cycle resolution.
   * Resolution are memoized, based on the input.
   *
   * @param input
   */
  resolve(input) {
    const cached = this.resolutionsByInputHash.get(input.hash);
    if (cached !== void 0)
      return cached;
    const resolution = this.buildResolution(input);
    this.resolutionsByInputHash.set(input.hash, resolution);
    return resolution;
  }
  buildResolution(input) {
    const walkContext = WalkState.new({ context: this, input });
    const allResolutions = Array.from(walkContext.next()).map((state) => {
      return {
        resolution: state.asResolution(),
        nbrOfDefaultFormulas: Array.from(state.activatedFormulas.formulas).reduce((count, formula) => state.formulaIsDefault(formula) ? count + 1 : count, 0),
        unCoveredInputWeight: state.unCoveredInputWeight()
      };
    });
    allResolutions.sort((res1, res2) => {
      if (res1.unCoveredInputWeight < res2.unCoveredInputWeight)
        return -1;
      if (res1.unCoveredInputWeight > res2.unCoveredInputWeight)
        return 1;
      return res2.nbrOfDefaultFormulas - res1.nbrOfDefaultFormulas;
    });
    if (allResolutions.length > 0)
      return allResolutions[0].resolution;
    else
      debugger;
  }
};
var VariableInputState;
(function(VariableInputState2) {
  VariableInputState2[VariableInputState2["NoInput"] = 0] = "NoInput";
  VariableInputState2[VariableInputState2["HasPreviousValue"] = 1] = "HasPreviousValue";
  VariableInputState2[VariableInputState2["HasProposedValue"] = 2] = "HasProposedValue";
  VariableInputState2[VariableInputState2["KeepIfPossible"] = 4] = "KeepIfPossible";
})(VariableInputState || (VariableInputState = {}));
var CycleResolutionInput = class extends Base {
  constructor() {
    super(...arguments);
    this.context = void 0;
    this.input = void 0;
    this.$hash = "";
  }
  get hash() {
    if (this.$hash !== "")
      return this.$hash;
    return this.$hash = this.buildHash();
  }
  get description() {
    return this.context.description;
  }
  /**
   * Returns the same result as calling [[CycleResolution.resolve]] on this input instance
   */
  get resolution() {
    return this.context.resolve(this);
  }
  initialize(...args) {
    super.initialize(...args);
    validateRequiredProperties(this);
    this.input = new Map(CI(this.description.variables).map((variable) => [variable, VariableInputState.NoInput]));
  }
  buildHash() {
    return String.fromCharCode(...CI(this.description.variables).inBatchesBySize(5).map((batch) => this.batchToCharCode(batch)));
  }
  batchToCharCode(batch) {
    return batch.reduceRight((charCode, variable, index) => charCode | this.input.get(variable) << index * 3, 0);
  }
  //---------------------
  /**
   * This method sets the [[HasProposedValue]] flag for the specified variable.
   *
   * @param variable
   */
  addProposedValueFlag(variable) {
    if (DEBUG) {
      if (!this.description.variables.has(variable))
        throw new Error("Unknown variable");
      if (this.$hash !== "")
        throw new Error("Already hashed");
    }
    const input = this.input.get(variable);
    this.input.set(variable, input | VariableInputState.HasProposedValue);
  }
  hasProposedValue(variable) {
    return Boolean(this.input.get(variable) & VariableInputState.HasProposedValue);
  }
  hasProposedValueVars() {
    return CI(this.description.variables).filter((variable) => this.hasProposedValue(variable));
  }
  //---------------------
  /**
   * This method sets the [[HasPreviousValue]] flag for the specified variable.
   *
   * @param variable
   */
  addPreviousValueFlag(variable) {
    if (DEBUG) {
      if (!this.description.variables.has(variable))
        throw new Error("Unknown variable");
      if (this.$hash !== "")
        throw new Error("Already hashed");
    }
    const input = this.input.get(variable);
    this.input.set(variable, input | VariableInputState.HasPreviousValue);
  }
  hasPreviousValue(variable) {
    return Boolean(this.input.get(variable) & VariableInputState.HasPreviousValue);
  }
  hasPreviousValueVars() {
    return CI(this.description.variables).filter((variable) => this.hasPreviousValue(variable));
  }
  //---------------------
  /**
   * This method sets the [[KeepIfPossible]] flag for the specified variable.
   *
   * @param variable
   */
  addKeepIfPossibleFlag(variable) {
    if (DEBUG) {
      if (!this.description.variables.has(variable))
        throw new Error("Unknown variable");
      if (this.$hash !== "")
        throw new Error("Already hashed");
    }
    const input = this.input.get(variable);
    this.input.set(variable, input | VariableInputState.KeepIfPossible);
  }
  keepIfPossible(variable) {
    return Boolean(this.input.get(variable) & VariableInputState.KeepIfPossible);
  }
  keepIfPossibleVars() {
    return CI(this.description.variables).filter((variable) => this.keepIfPossible(variable));
  }
};
__decorate3([
  required
], CycleResolutionInput.prototype, "context", void 0);
var WalkState = class extends Base {
  constructor() {
    super(...arguments);
    this.context = void 0;
    this.input = void 0;
    this.previous = void 0;
    this.activatedFormula = void 0;
    this.$activatedFormulas = void 0;
  }
  get activatedFormulas() {
    if (this.$activatedFormulas !== void 0)
      return this.$activatedFormulas;
    const cache = FormulasCache.new({
      variables: this.description.variables,
      formulas: CI(this.thisAndPreviousStates()).map((state) => state.activatedFormula).toSet()
    });
    return this.$activatedFormulas = cache;
  }
  get description() {
    return this.context.description;
  }
  *thisAndPreviousStates() {
    let current = this;
    while (current && current.activatedFormula) {
      yield current;
      current = current.previous;
    }
  }
  formulaHasProposedValueInInput(formula) {
    return Array.from(formula.inputs).some((variable) => this.input.hasProposedValue(variable));
  }
  // this method counts
  unCoveredInputWeight() {
    const proposedVars = map(this.input.hasProposedValueVars(), (variable) => {
      return { variable, isProposed: true };
    });
    const keepIfPossibleVars = map(this.input.keepIfPossibleVars(), (variable) => {
      return { variable, isProposed: false };
    });
    const allInputVars = CI([proposedVars, keepIfPossibleVars]).concat().uniqueOnlyBy((el) => el.variable);
    return allInputVars.reduce((totalWeight, { variable, isProposed }) => {
      let weight = 0;
      const isOverwrittenByFormulas = this.activatedFormulas.formulasByOutput.get(variable);
      if (isOverwrittenByFormulas) {
        const formula = isOverwrittenByFormulas.size === 1 ? Array.from(isOverwrittenByFormulas)[0] : null;
        if (formula && this.formulaIsDefault(formula) && this.formulaHasProposedValueInInput(formula)) {
          if (isProposed)
            weight += 1e6;
          else
            weight += 1e4;
        } else {
          if (isProposed)
            weight += 1e7;
          else
            weight += 1e5;
        }
      }
      const usedInFormulas = this.activatedFormulas.formulasByInput.get(variable);
      if (!(usedInFormulas && usedInFormulas.size > 0)) {
        if (isProposed)
          weight += 1e3;
        else
          weight += 100;
      }
      return totalWeight + weight;
    }, 0);
  }
  preferFormula(formula1, formula2) {
    const allInputsHasProposed1 = this.formulaAllInputsHasProposed(formula1);
    const allInputsHasProposed2 = this.formulaAllInputsHasProposed(formula2);
    if (allInputsHasProposed1 && !allInputsHasProposed2)
      return -1;
    if (allInputsHasProposed2 && !allInputsHasProposed1)
      return 1;
    const countInputsWithProposedOrKeep1 = this.formulaCountInputsWithProposedOrKeep(formula1);
    const countInputsWithProposedOrKeep2 = this.formulaCountInputsWithProposedOrKeep(formula2);
    if (countInputsWithProposedOrKeep1 > countInputsWithProposedOrKeep2)
      return -1;
    if (countInputsWithProposedOrKeep1 < countInputsWithProposedOrKeep2)
      return 1;
    if (this.formulaIsDefault(formula1) && !this.formulaIsDefault(formula2))
      return -1;
    if (this.formulaIsDefault(formula2) && !this.formulaIsDefault(formula1))
      return 1;
    return 0;
  }
  formulaIsDefault(formula) {
    return this.context.defaultResolutionFormulas.has(formula);
  }
  formulaCountInputsWithProposedOrKeep(formula) {
    let count = 0;
    Array.from(formula.inputs).forEach((variable) => {
      if (this.input.hasProposedValue(variable) || this.input.keepIfPossible(variable))
        count++;
    });
    return count;
  }
  formulaAllInputsHasProposedOrKeep(formula) {
    return Array.from(formula.inputs).every((variable) => this.input.hasProposedValue(variable) || this.input.keepIfPossible(variable));
  }
  formulaAllInputsHasProposed(formula) {
    return Array.from(formula.inputs).every((variable) => this.input.hasProposedValue(variable));
  }
  formulaIsApplicable(formula) {
    const everyFormulaInputHasValue = Array.from(formula.inputs).every((variable) => this.input.hasProposedValue(variable) || this.input.hasPreviousValue(variable) || this.activatedFormulas.formulasByOutput.has(variable));
    const cache = FormulasCache.new({ formulas: new Set(this.activatedFormulas.formulas) });
    cache.add(formula);
    return everyFormulaInputHasValue && !cache.isCyclic();
  }
  // in general the semantic of this method is very similar to `formulaIsApplicable`
  formulaIsInsignificant(formula) {
    const outputVariableAlreadyCalculated = this.activatedFormulas.formulasByOutput.has(formula.output);
    const outputVariableHasPreviousValue = this.input.hasPreviousValue(formula.output);
    return outputVariableAlreadyCalculated || outputVariableHasPreviousValue && Array.from(formula.inputs).some((variable) => {
      return !this.input.hasPreviousValue(variable) && !this.input.hasProposedValue(variable) && !this.activatedFormulas.formulasByOutput.has(variable);
    });
  }
  unvisitedFormulas() {
    return Array.from(this.description.formulas).filter((formula) => !this.activatedFormulas.has(formula));
  }
  *next() {
    const unvisitedFormulas = this.unvisitedFormulas();
    unvisitedFormulas.sort(this.preferFormula.bind(this));
    let isFinal = true;
    for (const formula of unvisitedFormulas) {
      if (!this.formulaIsApplicable(formula) || this.formulaIsInsignificant(formula))
        continue;
      const nextState = WalkState.new({
        previous: this,
        context: this.context,
        input: this.input,
        activatedFormula: formula
      });
      yield* nextState.next();
      isFinal = false;
    }
    if (isFinal)
      yield this;
  }
  asResolution() {
    return new Map(CI(this.description.variables).map((variable) => {
      const formulas = this.activatedFormulas.formulasByOutput.get(variable);
      if (formulas) {
        for (const firstFormula of formulas) {
          return [variable, firstFormula.formulaId];
        }
      }
      return [variable, CalculateProposed];
    }));
  }
};

// ../Core/lib/Core/helper/BrowserHelper.js
var _a;
var BrowserHelper = class {
  static cacheFlags(platform = navigator.platform, userAgent = navigator.userAgent) {
    const me = this;
    me._isLinux = Boolean(platform.match(/Linux/));
    me._isMac = Boolean(platform.match(/Mac/));
    me._isWindows = Boolean(platform.match(/Win32/));
    me._isMobile = Boolean(userAgent.match(/Mobile|Opera Mini|Opera Mobi|Puffin/) || typeof globalThis.orientation === "number");
    me._isWebkit = Boolean(userAgent.match(/WebKit/) && !userAgent.match(/Edg/));
    me._firefoxVersion = me.getVersion(userAgent, /Firefox\/(\d+)\./);
    me._isFirefox = me._firefoxVersion > 0;
    me._chromeVersion = me.getVersion(userAgent, /Chrom(?:e|ium)\/(\d+)\./);
    me._isChrome = me._chromeVersion > 0;
    me._isSafari = Boolean(userAgent.match(/Safari/)) && !me._isChrome;
    me._isMobileSafari = Boolean(userAgent.match(/Mobile.*Safari/));
    me._safariVersion = me.getVersion(userAgent, /Version\/(.*).Safari/);
    me._isAndroid = Boolean(userAgent.match(/Android/g));
  }
  //endregion
  //region Device
  /**
   * Yields `true` if the current browser supports CSS style `overflow:clip`.
   * @property {Boolean}
   * @readonly
   * @internal
   */
  static get supportsOverflowClip() {
    if (this._supportsOverflowClip == null) {
      const div = document.createElement("div");
      div.style.overflow = "clip";
      div.style.display = "none";
      document.documentElement.appendChild(div);
      this._supportsOverflowClip = div.ownerDocument.defaultView.getComputedStyle(div).getPropertyValue("overflow") === "clip";
      div.remove();
    }
    return this._supportsOverflowClip;
  }
  /**
   * Yields `true` if the current browser supports CSS style `position:sticky`.
   * @property {Boolean}
   * @readonly
   * @internal
   */
  static get supportsSticky() {
    return true;
  }
  /**
   * Returns matched version for userAgent.
   * @param {String} versionRe version match regular expression
   * @returns {Number} matched version
   * @readonly
   * @internal
   */
  static getVersion(userAgent, versionRe) {
    const match = userAgent.match(versionRe);
    return match ? parseFloat(match[1]) : 0;
  }
  /**
   * Determines if the user is using a touch device.
   * @property {Boolean}
   * @readonly
   * @internal
   */
  static get isTouchDevice() {
    if (this._isTouchDevice === void 0) {
      this._isTouchDevice = globalThis.matchMedia("(pointer:coarse)").matches;
    }
    return this._isTouchDevice;
  }
  // Reports true by default for our tests
  static get isHoverableDevice() {
    if (this._isHoverableDevice === void 0) {
      this._isHoverableDevice = globalThis.matchMedia("(any-hover: hover)").matches;
    }
    return this._isHoverableDevice;
  }
  //endregion
  //region Platform
  static get isBrowserEnv() {
    return typeof window !== "undefined";
  }
  /**
   * Checks if platform is Mac.
   * @property {Boolean}
   * @readonly
   * @category Platform
   */
  static get isMac() {
    return this._isMac;
  }
  /**
   * Checks if platform is Windows.
   * @property {Boolean}
   * @readonly
   * @category Platform
   */
  static get isWindows() {
    return this._isWindows;
  }
  /**
   * Checks if platform is Linux.
   * @property {Boolean}
   * @readonly
   * @category Platform
   */
  static get isLinux() {
    return this._isLinux;
  }
  /**
   * Checks if platform is Android.
   * @property {Boolean}
   * @readonly
   * @category Platform
   */
  static get isAndroid() {
    return this._isAndroid;
  }
  //endregion
  //region Browser
  /**
   * Checks if browser is Webkit.
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isWebkit() {
    return this._isWebkit;
  }
  /**
   * Checks if browser is Chrome or Chromium based browser.
   * Returns truthy value for Edge Chromium.
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isChrome() {
    return this._isChrome;
  }
  /**
   * Returns the major Chrome version or 0 for other browsers.
   * @property {Number}
   * @readonly
   * @category Browser
   */
  static get chromeVersion() {
    return this._chromeVersion;
  }
  /**
   * Checks if browser is Firefox.
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isFirefox() {
    return this._isFirefox;
  }
  /**
   * Returns the major Firefox version or 0 for other browsers.
   * @property {Number}
   * @readonly
   * @category Browser
   */
  static get firefoxVersion() {
    return this._firefoxVersion;
  }
  /**
   * Checks if browser is Safari.
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isSafari() {
    return this._isSafari;
  }
  static get safariVersion() {
    return this._safariVersion;
  }
  /**
   * Checks if browser is mobile Safari
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isMobileSafari() {
    return this._isMobileSafari;
  }
  /**
   * Checks if the active device is a mobile device
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isMobile() {
    return this._isMobile;
  }
  static get platform() {
    const me = this;
    return me._isLinux ? "linux" : me._isMac ? "mac" : me._isWindows ? "windows" : me._isAndroid ? "android" : me._isMobileSafari ? "ios" : null;
  }
  /**
   * Returns `true` if the browser supports passive event listeners.
   * @property {Boolean}
   * @internal
   * @deprecated Since 5.0. All modern browsers now support passive event listeners.
   * @category Browser
   */
  static get supportsPassive() {
    return true;
  }
  // Only works in secure contexts
  static get supportsRandomUUID() {
    if (this._supportsRandomUUID === void 0) {
      try {
        this._supportsRandomUUID = Boolean(globalThis.crypto.randomUUID().length > 0);
      } catch (e) {
        this._supportsRandomUUID = false;
      }
    }
    return this._supportsRandomUUID;
  }
  //endregion
  //region Storage
  // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API
  static get storageAvailable() {
    let storage, x;
    try {
      storage = localStorage;
      x = "__storage_test__";
      storage.setItem(x, x);
      storage.removeItem(x);
      return true;
    } catch (e) {
      return e instanceof DOMException && // everything except Firefox
      (e.code === 22 || // Firefox
      e.code === 1014 || // test name field too, because code might not be present
      // everything except Firefox
      e.name === "QuotaExceededError" || // Firefox
      e.name === "NS_ERROR_DOM_QUOTA_REACHED") && // acknowledge QuotaExceededError only if there's something already stored
      storage.length !== 0;
    }
  }
  static setLocalStorageItem(key, value) {
    this.storageAvailable && localStorage.setItem(key, value);
  }
  static getLocalStorageItem(key) {
    return this.storageAvailable && localStorage.getItem(key);
  }
  static removeLocalStorageItem(key) {
    this.storageAvailable && localStorage.removeItem(key);
  }
  //endregion
  //region Helpers
  /**
   * Returns parameter value from search string by parameter name.
   * @param {String} paramName search parameter name
   * @param {String} [defaultValue] default value if parameter not found
   * @param {String} [search] search string. Defaults to `document.location.search`
   * @returns {String} search parameter string value
   * @category Helper
   */
  static searchParam(paramName, defaultValue2 = null, search = document.location.search) {
    const re = new RegExp(`[?&]${paramName}=?([^&]*)`), match = search.match(re);
    return match && match[1] || defaultValue2;
  }
  /**
   * Returns cookie by name.
   * @param {String} name cookie name
   * @returns {String} cookie string value
   * @category Helper
   */
  static getCookie(name) {
    const nameEq = encodeURIComponent(name) + "=", cookieItems = document.cookie.split(";");
    for (let i = 0; i < cookieItems.length; i++) {
      let c = cookieItems[i];
      while (c.charAt(0) === " ") {
        c = c.substring(1, c.length);
      }
      if (c.indexOf(nameEq) === 0) {
        return decodeURIComponent(c.substring(nameEq.length, c.length));
      }
    }
    return "";
  }
  /**
   * Triggers a download of a file with the specified name / URL.
   * @param {String} filename The filename of the file to be downloaded
   * @param {String} [url] The URL where the file is to be downloaded from
   * @internal
   * @category Download
   */
  static download(filename, url) {
    const a = document.createElement("a");
    a.download = filename;
    a.href = url || filename;
    a.style.cssText = "display:none";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  }
  /**
   * Triggers a download of a Blob with the specified name.
   * @param {Blob} blob The Blob to be downloaded
   * @param {String} filename The filename of the file to be downloaded
   * @internal
   * @category Download
   */
  static downloadBlob(blob, filename) {
    const url = globalThis.URL.createObjectURL(blob);
    this.download(filename, url);
    globalThis.URL.revokeObjectURL(url);
  }
  static get queryString() {
    var _a2;
    const params = new URL(globalThis.location.href).searchParams;
    return (_a2 = Object.fromEntries) == null ? void 0 : _a2.call(Object, params.entries());
  }
  // Used by docs fiddle
  static copyToClipboard(code) {
    let success = true;
    const textArea = document.createElement("textarea");
    textArea.value = code;
    textArea.style.height = textArea.style.width = 0;
    document.body.appendChild(textArea);
    textArea.select();
    try {
      document.execCommand("copy");
    } catch (e) {
      success = false;
    }
    textArea.remove();
    return success;
  }
  static isBryntumOnline(searchStrings) {
    searchStrings = Array.isArray(searchStrings) ? searchStrings : [searchStrings];
    return Boolean(/^(www\.)?bryntum\.com/.test(globalThis.location.host) || (searchStrings == null ? void 0 : searchStrings.some((str) => this.queryString[str] != null)));
  }
  /**
   * Returns truthy value if page contains Content Security Policy meta tag or globalThis.bryntum.CSP is truthy value
   * @returns {Boolean}
   * @internal
   **/
  static get isCSP() {
    const { bryntum, document: document2 } = globalThis;
    if (bryntum.CSP == null) {
      bryntum.CSP = Boolean(document2.querySelector('meta[http-equiv="Content-Security-Policy"]'));
    }
    return bryntum.CSP;
  }
  //endregion
};
__publicField(BrowserHelper, "supportsPointerEvents", Boolean(globalThis.PointerEvent || globalThis.MSPointerEvent));
// Locker Service does not allow to instantiate PointerEvents. LWS apparently does, however.
// https://github.com/bryntum/support/issues/5578
__publicField(BrowserHelper, "supportsPointerEventConstructor", typeof PointerEvent !== "undefined");
__publicField(BrowserHelper, "PointerEventConstructor", globalThis.PointerEvent || globalThis.CustomEvent);
//region Init
/**
 * Yields `true` if the platform running is a phone (screen width or height <= 414 CSS pixels)
 * @property {Boolean}
 * @readonly
 * @static
 * @category Platform
 */
__publicField(BrowserHelper, "isPhone", (_a = globalThis.matchMedia) == null ? void 0 : _a.call(globalThis, "(max-height:414px) or (max-width:414px)").matches);
if (BrowserHelper.isBrowserEnv) {
  BrowserHelper.cacheFlags();
}
BrowserHelper._$name = "BrowserHelper";

// ../Core/lib/Core/helper/StringHelper.js
var charsToEncode;
var entitiesToDecode;
var htmlEncodeRe;
var htmlDecodeRe;
var camelLettersRe = /([a-z])([A-Z])/g;
var crlfRe = /[\n\r]/g;
var escapeRegExpRe = /[.*+?^${}()|[\]\\]/g;
var htmlRe = /[&<]/;
var idRe = /(^[^a-z]+[^\w]+)/gi;
var whiteSpaceRe = /\s+/;
var domIdRe = /^[^a-z]+|[^\w:.-]+/gi;
var htmlDecoder = (m, captured) => entitiesToDecode[captured.toLowerCase()] || String.fromCharCode(parseInt(captured.substr(2), 10));
var htmlEncoder = (m, captured) => charsToEncode[captured];
var hyphenateCamelLetters = (all, g1, g2) => {
  return `${g1}-${g2.toLowerCase()}`;
};
var separateCamelLetters = (all, g1, g2) => {
  return `${g1} ${g2.toLowerCase()}`;
};
var replaceNonIdChar = (c) => {
  if (c) {
    return `_x${[...c].map((ch) => ch.charCodeAt(0).toString(16)).join("")}`;
  }
  return "__blank__";
};
var hyphenateCache = {};
var separatedCache = {};
var _StringHelper = class {
  //region Transform
  /**
   * Capitalizes the first letter of a string, "myString" -> "MyString".
   * @param {String} string The string to capitalize
   * @returns {String} The capitalized string or the value of `string` if falsy.
   * @category String formatting
   */
  static capitalize(string) {
    return string && string[0].toUpperCase() + string.substr(1);
  }
  /**
   * Makes the first letter of a string lowercase, "MyString" -> "myString".
   * @param {String} string The string to un-capitalize.
   * @returns {String} The un-capitalized string or the value of `string` if falsy.
   * @category String formatting
   */
  static uncapitalize(string) {
    return string && string[0].toLowerCase() + string.substr(1);
  }
  /**
   * Converts the passed camelCased string to a hyphen-separated string. eg "minWidth" -> "min-width"
   * @param {String} string The string to convert.
   * @returns {String} The string with adjoining lower and upper case letters
   * separated by hyphens and converted to lower case.
   * @category String formatting
   * @internal
   */
  static hyphenate(string) {
    const cached = hyphenateCache[string];
    if (cached) {
      return cached;
    }
    return hyphenateCache[string] = string.replace(camelLettersRe, hyphenateCamelLetters);
  }
  /**
   * Converts the passed camelCased string to a capitalized, space-separated string. eg "startDate" -> "Start date".
   * @param {String} string The string to convert.
   * @returns {String} The string with spaces separating words.
   * @category String formatting
   * @internal
   */
  static separate(string) {
    const cached = separatedCache[string];
    if (cached) {
      return cached;
    }
    return separatedCache[string] = this.capitalize(string.replace(camelLettersRe, separateCamelLetters));
  }
  /**
   * Creates an alphanumeric identifier from any passed string. Encodes spaces and non-alpha characters.
   * @param {String} inString The string from which to strip non-identifier characters.
   * @returns {String}
   * @category Misc
   * @internal
   */
  static createId(inString) {
    return String(inString).replace(idRe, replaceNonIdChar);
  }
  static makeValidDomId(id, replaceValue = "") {
    if (id == null) {
      return null;
    }
    return String(id).replace(domIdRe, replaceValue);
  }
  //endregion
  //region Html
  static escapeRegExp(string, flags) {
    let ret = string.replace(escapeRegExpRe, "\\$&");
    if (flags !== void 0) {
      ret = new RegExp(ret, flags);
    }
    return ret;
  }
  /**
   * This method decodes HTML entities and returns the original HTML.
   *
   * See also {@link #function-encodeHtml-static}.
   * @param {String} str
   * @returns {String}
   * @category HTML
   */
  static decodeHtml(str) {
    return str && String(str).replace(htmlDecodeRe, htmlDecoder);
  }
  /**
   * This method encodes HTML entities and returns a string that can be placed in the document and produce the
   * original text rather than be interpreted as HTML. Using this method with user-entered values prevents those
   * values from executing as HTML (i.e., a cross-site scripting or "XSS" security issue).
   *
   * See also {@link #function-decodeHtml-static}.
   * @param {String} str
   * @returns {String}
   * @category HTML
   */
  static encodeHtml(str = "") {
    return str && String(str).replace(htmlEncodeRe, htmlEncoder);
  }
  /**
   * This method is similar to {@link #function-encodeHtml-static} except that `\n` and `\r` characters in the
   * given `str` are replaced by `<br>` tags _after_ first being encoded by {@link #function-encodeHtml-static}.
   * @param {String} str
   * @returns {String}
   * @category HTML
   * @internal
   */
  static encodeHtmlBR(str) {
    var _a2;
    return (_a2 = _StringHelper.encodeHtml(str)) == null ? void 0 : _a2.replace(crlfRe, "<br>");
  }
  /**
   * Returns `true` if the provided `text` contains special HTML characters.
   * @param {String} text
   * @returns {Boolean}
   * @category HTML
   * @internal
   */
  static isHtml(text) {
    return typeof text === "string" && htmlRe.test(text || "");
  }
  /**
   * Initializes HTML entities used by {@link #function-encodeHtml-static} and {@link #function-decodeHtml-static}.
   * @param {Object} [mappings] An object whose keys are characters that should be encoded and values are the HTML
   * entity for the character.
   * @private
   */
  static initHtmlEntities(mappings) {
    mappings = mappings || {
      "&": "&amp;",
      ">": "&gt;",
      "<": "&lt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    const chars = Object.keys(mappings);
    charsToEncode = mappings;
    entitiesToDecode = chars.reduce((prev, val) => {
      prev[mappings[val]] = val;
      return prev;
    }, {});
    htmlEncodeRe = new RegExp(`([${chars.map((c) => "[-]".includes(c) ? "\\" + c : c).join("")}])`, "g");
    htmlDecodeRe = new RegExp(`(${Object.values(mappings).join("|")}|&#[0-9]+;)`, "ig");
  }
  //endregion
  //region JSON
  /**
   * Parses JSON inside a try-catch block. Returns null if the string could not be parsed.
   *
   * @param {String} string String to parse
   * @returns {Object} Resulting object or `null` if parse failed
   * @category JSON
   */
  static safeJsonParse(string) {
    let parsed = null;
    try {
      parsed = JSON.parse(string);
    } catch (e) {
    }
    return parsed;
  }
  /**
   * Stringifies an object inside a try-catch block. Returns null if an exception is encountered.
   *
   * See [JSON.stringify on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)
   * for more information on the arguments.
   *
   * @param {Object} object The object to stringify
   * @param {Function|String[]|Number[]} [replacer] A function or array of string/number used to determine properties
   * to include in the JSON string
   * @param {String|Number} [space] Number of spaces to indent or string used as whitespace
   * @returns {String} Resulting object or null if stringify failed
   * @category JSON
   */
  static safeJsonStringify(object, replacer = null, space = null) {
    let result = null;
    try {
      result = JSON.stringify(object, replacer, space);
    } catch (e) {
    }
    return result;
  }
  //endregion
  //region Split & join
  /**
   * Joins all given paths together using the separator as a delimiter and normalizes the resulting path.
   * @param paths {Array} array of paths to join
   * @param pathSeparator [{String}] path separator. Default value is '/'
   * @returns {String}
   * @category Misc
   * @internal
   */
  static joinPaths(paths, pathSeparator = "/") {
    return paths.join(pathSeparator).replace(new RegExp("\\" + pathSeparator + "+", "g"), pathSeparator);
  }
  /**
   * Returns the provided string split on whitespace. If the string is empty or consists of only whitespace, the
   * returned array will be empty. If `str` is not a string, it is simply returned. This allows `null` or already
   * split strings (arrays) to be passed through.
   *
   * For example:
   * ```
   *  console.log(StringHelper.split(' abc def xyz   '));
   *  > ['abc', 'def', 'xyz']
   *  console.log(StringHelper.split(''));
   *  > []
   * ```
   * Compare to the standard `split()` method:
   * ```
   *  console.log(' abc def xyz   '.split(/\s+/));
   *  > ['', 'abc', 'def', 'xyz', '']
   *  console.log(''.split(/\s+/));
   *  > ['']
   * ```
   * @param {String} str
   * @param {String|RegExp} delimiter
   * @returns {String[]}
   * @category Misc
   * @internal
   */
  static split(str, delimiter = whiteSpaceRe) {
    let ret = str;
    if (typeof ret === "string") {
      ret = str.trim();
      ret = ret ? ret.split(delimiter) : [];
    }
    return ret;
  }
  //endregion
  //region XSS
  /**
   * This is a tagged template function that performs HTML encoding on replacement values to avoid XSS (Cross-Site
   * Scripting) attacks.
   *
   * For example:
   *
   * ```javascript
   *  eventRenderer(eventRecord) {
   *      return StringHelper.xss`<span class="${eventRecord.attrib}">${eventRecord.name}</span>`;
   *  }
   * ```
   *
   * @param {TemplateStringsArray} strings The template string array
   * @param {...any} values The interpolated values in the template string
   * @returns {String} The encoded string
   * See {@link Core.helper.StringHelper#function-encodeHtml-static}.
   */
  static xss(strings, ...values) {
    const buf = [];
    let i = values.length;
    buf[i] = strings[i];
    while (i-- > 0) {
      buf[i] = strings[i] + _StringHelper.encodeHtml(values[i]);
    }
    return buf.join("");
  }
  /**
   * This is a tagged template function that performs HTML encoding on replacement values to avoid XSS (Cross-Site
   * Scripting) attacks. Unlike {@link Core.helper.StringHelper#function-xss-static}, this method converts `\n` and
   * `\r` characters into `<br>` tags.
   *
   * For example:
   *
   * ```javascript
   *  eventRenderer(eventRecord) {
   *      return StringHelper.xssBR`<span class="${eventRecord.attrib}">${eventRecord.name}</span>`;
   *  }
   * ```
   *
   * See {@link Core.helper.StringHelper#function-encodeHtmlBR-static}.
   * @internal
   */
  static xssBR(strings, ...values) {
    const buf = [];
    let i = values.length;
    buf[i] = strings[i];
    while (i-- > 0) {
      buf[i] = strings[i] + _StringHelper.encodeHtmlBR(values[i]);
    }
    return buf.join("");
  }
  //endregion
  //region JavaScript string
  /**
   * Converts a value to a JavaScript string (not JSON).
   *
   * For example a date to `"new Date(y, m, d)"`, an array to `"[...]"` etc.
   *
   * @param {*} value
   * @param {Object} [options]
   * @returns {String}
   * @internal
   */
  static toJavaScriptValue(value, options) {
    const type = Objects.typeOf(value);
    if (type === "boolean" || type === "string" || type === "number" || value === null) {
      return _StringHelper.safeJsonStringify(value);
    }
    if (value === globalThis) {
      return "window";
    }
    if (type === "date") {
      return `new Date(${value.getFullYear()}, ${value.getMonth()}, ${value.getDate()}, ${value.getHours()}, ${value.getMinutes()}, ${value.getSeconds()}, ${value.getMilliseconds()})`;
    }
    if (type === "array") {
      return `[${value.map((v) => _StringHelper.toJavaScriptValue(v, options))}]`;
    }
    if (type === "object" || type === "instance") {
      return this.toJavaScriptString(value, options);
    }
    if (type === "function") {
      let contents = value.toString();
      if (contents.match(/^async (\w+?)\(/)) {
        contents = contents.replace(/^async (\w+?)\(/, "async function(");
      } else if (!contents.startsWith("async(") && contents.match(/^(\w+?)\(/)) {
        contents = contents.replace(/^(\w+?)\(/, "function(");
      }
      return contents;
    }
    if (type === "class") {
      if (value.toJavaScriptValue) {
        return value.toJavaScriptValue(options);
      }
      return Object.prototype.hasOwnProperty.call(value, "$name") ? value.$name : value.name;
    }
  }
  /**
   * Converts an object into a JavaScript string (not JSON).
   *
   * For example `{ a: 1, b: [2, 3] }` -> `"'{ a: 1, b: [2, 3] }'"`
   *
   * @param {Object} obj
   * @param {Object} [options]
   * @returns {String}
   * @internal
   */
  static toJavaScriptString(obj, options = {}) {
    var _a2;
    const level = (_a2 = options.level) != null ? _a2 : 0, intendSize = 2;
    return "{\n" + Object.keys(obj).map(
      (key) => (
        // All properties in an object are indented one step further than the object itself
        " ".repeat((level + 1) * intendSize) + (key.match(/[- *]/) ? `"${key}"` : key) + `: ${_StringHelper.toJavaScriptValue(obj[key], { ...options, level: level + 1 })}`
      )
    ).join(",\n") + // Closing brace is indented to same level as the object
    "\n" + " ".repeat(level * intendSize) + "}";
  }
  /**
   * Escapes " and \ in CSS attribute selectors, e.g. [data-id="somevalue"]
   *
   * Usage:
   * ```javascript
   * document.querySelector(StringHelper.cssAttributeQuery('data-id', 'id with & \\ chars'))
   * ```
   *
   * @param {String} attr
   * @param {String|Number} value
   * @returns {String}
   */
  static encodeAttributeSelector(attr, value) {
    return `[${attr}="${String(value).replace(/["\\]/g, "\\$&")}"]`;
  }
  /**
   * Generates a UUID. Uses `Crypto.randomUUID()` if available, otherwise generates a random UUID using
   * `Crypto.getRandomValues()`.
   *
   * @returns {String}
   */
  static generateUUID() {
    var _a2;
    if (BrowserHelper.supportsRandomUUID) {
      return globalThis.crypto.randomUUID();
    }
    if ((_a2 = globalThis.crypto) == null ? void 0 : _a2.getRandomValues) {
      return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(
        /[018]/g,
        (c) => (c ^ globalThis.crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
      );
    }
    return `${Date.now()}-${++_StringHelper.fakeNodeUUIDIndex}`;
  }
  //endregion
};
var StringHelper = _StringHelper;
//endregion
//region UUID
__publicField(StringHelper, "fakeNodeUUIDIndex", 0);
StringHelper.initHtmlEntities();
StringHelper._$name = "StringHelper";

// ../Core/lib/Core/helper/util/Objects.js
var { hasOwnProperty, toString } = Object.prototype;
var { isFrozen } = Object;
var afterRe = /\s*<\s*/;
var beforeRe = /\s*>\s*/;
var blendOptions = {};
var typeCache = {};
var emptyObject = Object.freeze({});
var Objects = class {
  static assign(dest, ...sources) {
    for (let source, key, i = 0; i < sources.length; i++) {
      source = sources[i];
      if (source) {
        for (key in source) {
          dest[key] = source[key];
        }
      }
    }
    return dest;
  }
  static assignIf(dest, ...sources) {
    for (let source, key, i = 0; i < sources.length; i++) {
      source = sources[i];
      if (source) {
        for (key in source) {
          if (!(key in dest) || dest[key] === void 0) {
            dest[key] = source[key];
          }
        }
      }
    }
    return dest;
  }
  static blend(dest, source, options) {
    options = options || blendOptions;
    dest = dest || {};
    const { clone = Objects.clone, merge = Objects.blend } = options;
    if (Array.isArray(source)) {
      if (source.length > 1) {
        source.forEach((s) => {
          dest = Objects.blend(dest, s, options);
        });
        return dest;
      }
      source = source[0];
    }
    if (source) {
      let destValue, key, value;
      for (key in source) {
        value = source[key];
        if (value && Objects.isObject(value)) {
          destValue = dest[key];
          options.key = key;
          if (destValue && Objects.isObject(destValue)) {
            if (isFrozen(destValue)) {
              dest[key] = destValue = clone(destValue, options);
            }
            value = merge(destValue, value, options);
          } else {
            value = isFrozen(value) ? value : clone(value, options);
          }
        }
        dest[key] = value;
      }
    }
    return dest;
  }
  static clone(value, handler) {
    let cloned = value, key;
    if (value && typeof value === "object") {
      const options = handler && typeof handler === "object" && handler;
      if (options) {
        handler = null;
      }
      if (Objects.isObject(value)) {
        if (value.skipClone) {
          cloned = value;
        } else {
          cloned = {};
          for (key in value) {
            cloned[key] = Objects.clone(value[key]);
          }
        }
      } else if (Array.isArray(value)) {
        cloned = [];
        for (key = value.length; key-- > 0; ) {
          cloned[key] = Objects.clone(value[key]);
        }
      } else if (Objects.isDate(value)) {
        cloned = new Date(value.getTime());
      } else if (handler) {
        cloned = handler(value);
      }
    }
    return cloned;
  }
  static createTruthyKeys(source) {
    const keys = StringHelper.split(source), result = keys && {};
    if (keys) {
      for (const key of keys) {
        if (key) {
          result[key] = true;
        }
      }
    }
    return result;
  }
  /**
   * Returns value for a given path in the object
   * @param {Object} object Object to check path on
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @returns {*} Value associated with passed key
   */
  static getPath(object, path) {
    return path.split(".").reduce((result, key) => {
      return (result || emptyObject)[key];
    }, object);
  }
  /**
   * Returns value for a given path in the object, placing a passed default value in at the
   * leaf property and filling in undefined properties all the way down.
   * @param {Object} object Object to get path value for.
   * @param {String|Number|String[]|Number[]} path Dot-separated path, e.g. 'firstChild.childObject.someKey',
   * or the key path as an array, e.g. ['firstChild', 'childObject', 'someKey'].
   * @param {*} [defaultValue] Optionally the value to put in as the `someKey` property.
   * @returns {*} Value at the leaf position of the path.
   */
  static getPathDefault(object, path, defaultValue2) {
    const keys = Array.isArray(path) ? path : typeof path === "string" ? path.split(".") : [path], length = keys.length - 1;
    return keys.reduce((result, key, index) => {
      if (defaultValue2 && !(key in result)) {
        result[key] = index === length ? defaultValue2 : {};
      }
      return (result || emptyObject)[key];
    }, object);
  }
  /**
   * Determines if the specified path exists
   * @param {Object} object Object to check path on
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @returns {Boolean}
   */
  static hasPath(object, path) {
    return path.split(".").every((key) => {
      if (object && key in object) {
        object = object[key];
        return true;
      }
      return false;
    });
  }
  static getTruthyKeys(source) {
    const keys = [];
    for (const key in source) {
      if (source[key]) {
        keys.push(key);
      }
    }
    return keys;
  }
  static getTruthyValues(source) {
    const values = [];
    for (const key in source) {
      if (source[key]) {
        values.push(source[key]);
      }
    }
    return values;
  }
  static isClass(object) {
    var _a2;
    if (typeof object === "function" && ((_a2 = object.prototype) == null ? void 0 : _a2.constructor) === object) {
      return true;
    }
    return false;
  }
  static isDate(object) {
    return Boolean(object == null ? void 0 : object.getUTCDate) && Objects.typeOf(object) === "date";
  }
  /**
   * Check if passed object is a Promise or contains `then` method.
   * Used to fix problems with detecting promises in code with `instance of Promise` when
   * Promise class is replaced with any other implementation like `ZoneAwarePromise` in Angular.
   * Related to these issues:
   * https://github.com/bryntum/support/issues/791
   * https://github.com/bryntum/support/issues/2990
   *
   * @param {Object} object object to check
   * @returns {Boolean} truthy value if object is a Promise
   * @internal
   */
  static isPromise(object) {
    if (Promise && Promise.resolve) {
      return Promise.resolve(object) === object || typeof (object == null ? void 0 : object.then) === "function";
    }
    throw new Error("Promise not supported in your environment");
  }
  static isEmpty(object) {
    if (object && typeof object === "object") {
      for (const p in object) {
        return false;
      }
    }
    return true;
  }
  static isObject(value) {
    const C = value == null ? void 0 : value.constructor;
    return Boolean(
      C ? (
        // An in-frame instance of Object
        C === Object || // Detect cross-frame objects, but exclude instance of custom classes named Object. typeOf(value) is
        // "object" even for instances of a class and typeOf(C) is "function" for all constructors. We'll have
        // to settle for relying on the fact that getPrototypeOf(Object.prototype) === null.
        // NOTE: this issue does come up in Scheduler unit tests at least.
        C.getPrototypeOf && C.prototype && !Object.getPrototypeOf(C.prototype)
      ) : value && typeof value === "object"
    );
  }
  static isInstantiated(object) {
    return object ? typeof object === "object" && !Objects.isObject(object) : false;
  }
  static merge(dest, ...sources) {
    return Objects.blend(dest, sources);
  }
  /**
   * Merges two "items" objects. An items object is a simple object whose keys act as identifiers and whose values
   * are "item" objects. An item can be any object type. This method is used to merge such objects while maintaining
   * their property order. Special key syntax is used to allow a source object to insert a key before or after a key
   * in the `dest` object.
   *
   * For example:
   * ```javascript
   *  let dest = {
   *      foo : {},
   *      bar : {},
   *      fiz : {}
   *  }
   *
   *  console.log(Object.keys(dest));
   *  > ["foo", "bar", "fiz"]
   *
   *  dest = mergeItems(dest, {
   *      'zip > bar' : {}    // insert "zip" before "bar"
   *      'bar < zap' : {}    // insert "zap" after "bar"
   *  });
   *
   *  console.log(Object.keys(dest));
   *  > ["foo", "zip", "bar", "zap", "fiz"]
   * ```
   *
   * @param {Object} dest The destination object.
   * @param {Object|Object[]} src The source object or array of source objects to merge into `dest`.
   * @param {Object} [options] The function to use to merge items.
   * @param {Function} [options.merge] The function to use to merge items.
   * @returns {Object} The merged object. This will be the `dest` object.
   * @internal
   */
  static mergeItems(dest, src, options) {
    options = options || blendOptions;
    let anchor, delta, index, indexMap, key, shuffle, srcVal;
    const { merge = Objects.blend } = options;
    dest = dest || {};
    if (Array.isArray(src)) {
      src.forEach((s) => {
        dest = Objects.mergeItems(dest, s, options);
      });
    } else if (src) {
      for (key in src) {
        srcVal = src[key];
        anchor = null;
        if (key.includes(">")) {
          [key, anchor] = key.split(beforeRe);
          delta = 0;
        } else if (key.includes("<")) {
          [anchor, key] = key.split(afterRe);
          delta = 1;
        }
        if (key in dest) {
          if (srcVal && dest[key] && merge) {
            options.key = key;
            srcVal = merge(dest[key], srcVal, options);
          }
          dest[key] = srcVal;
        } else if (!anchor) {
          dest[key] = srcVal;
          indexMap == null ? void 0 : indexMap.set(key, indexMap.size);
        } else {
          if (!indexMap) {
            indexMap = /* @__PURE__ */ new Map();
            index = 0;
            for (const k in dest) {
              indexMap.set(k, index++);
            }
          }
          index = indexMap.get(anchor);
          dest[key] = srcVal;
          if (index == null && delta) {
            index = indexMap.size;
          } else {
            shuffle = shuffle || [];
            index = (index || 0) + delta;
            for (const item of indexMap) {
              const [k, v] = item;
              if (index <= v) {
                shuffle && (shuffle[indexMap.size - v - 1] = k);
                indexMap.set(k, v + 1);
              }
            }
            if (shuffle) {
              while (shuffle.length) {
                const k = shuffle.pop(), v = dest[k];
                delete dest[k];
                dest[k] = v;
              }
            }
          }
          indexMap.set(key, index);
        }
      }
    }
    return dest;
  }
  /**
   * Sets value for a given path in the object
   * @param {Object} object Target object
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @param {*} value Value for a given path
   * @returns {Object} Returns passed object
   */
  static setPath(object, path, value) {
    path.split(".").reduce((result, key, index, array) => {
      const isLast = index === array.length - 1;
      if (isLast) {
        return result[key] = value;
      } else if (!(result[key] instanceof Object)) {
        result[key] = {};
      }
      return result[key];
    }, object);
    return object;
  }
  static typeOf(value) {
    let trueType, type;
    if (value === null) {
      type = "null";
    } else if (value !== value) {
      type = "nan";
    } else {
      type = typeof value;
      if (type === "object") {
        if (value.isBase) {
          type = "instance";
        } else if (Array.isArray(value)) {
          type = "array";
        } else if (!(type = typeCache[trueType = toString.call(value)])) {
          typeCache[trueType] = type = trueType.slice(8, -1).toLowerCase();
        }
      } else if (type === "function" && value.isBase) {
        type = "class";
      }
    }
    return type;
  }
};
Object.defineProperty(Objects, "hasOwn", {
  // When available, this avoids an extra layer of function call around it:
  value: Object.hasOwn || ((object, property) => hasOwnProperty.call(object, property))
});
Objects._$name = "Objects";

// ../Core/lib/Core/helper/VersionHelper.js
var VersionHelper = class {
  /**
   * Set version for specified product
   * @private
   * @param {String} product
   * @param {String} version
   */
  static setVersion(product, version) {
    product = product.toLowerCase();
    VH[product] = {
      version,
      isNewerThan(otherVersion) {
        return VersionHelper.semanticCompareVersion(otherVersion, version, "<");
      },
      isOlderThan(otherVersion) {
        return VersionHelper.semanticCompareVersion(otherVersion, version, ">");
      }
    };
    let bundleFor = "";
    if (typeof productName !== "undefined") {
      bundleFor = productName;
    }
    const globalKey = `${bundleFor}.${product}${version.replace(/\./g, "-")}`;
    if (BrowserHelper.isBrowserEnv && !globalThis.bryntum.silenceBundleException) {
      if (globalThis.bryntum[globalKey] === true) {
        if (this.isTestEnv) {
          globalThis.BUNDLE_EXCEPTION = true;
        } else {
          let errorProduct = bundleFor || product;
          if (errorProduct === "core") {
            errorProduct = "grid";
          }
          let capitalized = StringHelper.capitalize(errorProduct);
          if (errorProduct === "schedulerpro") {
            capitalized = "SchedulerPro";
          }
          throw new Error(
            `The Bryntum ${capitalized} bundle was loaded multiple times by the application.

Common reasons you are getting this error includes:

* Imports point to different types of the bundle (e.g. *.module.js and *.umd.js)
* Imports point to both sources and bundle
* Imports do not use the shortest relative path, JS treats them as different files
* Cache busters differ between imports, JS treats ${errorProduct}.module.js?1 and ${errorProduct}.module.js?2 as different files
* Imports missing file type, verify they all end in .js

See https://bryntum.com/products/${errorProduct}/docs/guide/${capitalized}/gettingstarted/es6bundle#troubleshooting for more information

`
          );
        }
      } else {
        globalThis.bryntum[globalKey] = true;
      }
    }
  }
  /**
   * Get (previously set) version for specified product
   * @private
   * @param {String} product
   */
  static getVersion(product) {
    product = product.toLowerCase();
    if (!VH[product]) {
      throw new Error("No version specified! Please check that you import VersionHelper correctly into the class from where you call `deprecate` function.");
    }
    return VH[product].version;
  }
  /**
   * Checks the version1 against the passed version2 using the comparison operator.
   * Supports `rc`, `beta`, `alpha` release states. Eg. `1.2.3-alpha-1`.
   * State which is not listed above means some version below `alpha`.
   * @param {String} version1 The version to test against
   * @param {String} version2 The version to test against
   * @param {String} [comparison] The comparison operator, `<=`, `<`, `=`, `>` or `>=`.
   * @returns {Boolean} `true` if the test passes.
   * @internal
   */
  static semanticCompareVersion(version1, version2, comparison = "=") {
    version1 = version1 || "";
    version2 = version2 || "";
    const version1Arr = version1.split(/[-.]/), version2Arr = version2.split(/[-.]/), isLower = comparison.includes("<"), normalizeArr = (arr, maxLength) => {
      const states = ["rc", "beta", "alpha"], result = arr.map((v) => {
        if (states.includes(v)) {
          return -states.indexOf(v) - 2;
        }
        const res = Number.parseInt(v);
        return Number.isNaN(res) ? -states.length : res;
      });
      while (result.length < maxLength) {
        result.push(-1);
      }
      return result;
    }, compareArr = () => {
      const maxLength = Math.max(version1Arr.length, version2Arr.length), arr1 = normalizeArr(version1Arr, maxLength), arr2 = normalizeArr(version2Arr, maxLength);
      for (let i = 0; i < maxLength; i++) {
        if (arr1[i] !== arr2[i]) {
          return isLower ? arr1[i] < arr2[i] : arr1[i] > arr2[i];
        }
      }
      return true;
    };
    switch (comparison) {
      case "=":
        return version1 === version2;
      case "<=":
      case ">=":
        return version1 === version2 || compareArr();
      case "<":
      case ">":
        return version1 !== version2 && compareArr();
    }
    return false;
  }
  /**
   * Checks the passed product against the passed version using the passed test.
   * @param {String} product The name of the product to test the version of
   * @param {String} version The version to test against
   * @param {String} operator The test operator, `<=`, `<`, `=`, `>` or `>=`.
   * @returns {Boolean} `true` if the test passes.
   * @internal
   */
  static checkVersion(product, version, operator) {
    return VersionHelper.semanticCompareVersion(VH.getVersion(product), version, operator);
  }
  /**
   * Based on a comparison of current product version and the passed version this method either outputs a console.warn
   * or throws an error.
   * @param {String} product The name of the product
   * @param {String} invalidAsOfVersion The version where the offending code is invalid (when any compatibility layer
   * is actually removed).
   * @param {String} message Required! A helpful warning message to show to the developer using a deprecated API.
   * @internal
   */
  static deprecate(product, invalidAsOfVersion, message) {
    const justWarn = VH.checkVersion(product, invalidAsOfVersion, "<");
    if (justWarn) {
      console.warn(`Deprecation warning: You are using a deprecated API which will change in v${invalidAsOfVersion}. ${message}`);
    } else {
      throw new Error(`Deprecated API use. ${message}`);
    }
  }
  /**
   * Returns truthy value if environment is in testing mode
   * @returns {Boolean}
   * @internal
   **/
  static get isTestEnv() {
    var _a2, _b, _c;
    const isTestEnv = Boolean((_a2 = globalThis.bryntum) == null ? void 0 : _a2.isTestEnv);
    try {
      return isTestEnv || Boolean((_c = (_b = globalThis.parent) == null ? void 0 : _b.bryntum) == null ? void 0 : _c.isTestEnv);
    } catch (e) {
      return isTestEnv;
    }
  }
  static get isDebug() {
    let result = false;
    return result;
  }
};
var VH = VersionHelper;
if (BrowserHelper.isBrowserEnv) {
  if (VH.isTestEnv) {
    BrowserHelper._isHoverableDevice = true;
  }
  globalThis.bryntum = Object.assign(globalThis.bryntum || {}, {
    getVersion: VH.getVersion.bind(VH),
    checkVersion: VH.checkVersion.bind(VH),
    deprecate: VH.deprecate.bind(VH),
    license: "%LICENSE%"
  });
}
VersionHelper._$name = "VersionHelper";

// ../Core/lib/Core/Config.js
var { defineProperty: defineProperty2, getOwnPropertyDescriptor } = Reflect;
var { hasOwnProperty: hasOwnProperty2, toString: toString2 } = Object.prototype;
var instancePropertiesSymbol = Symbol("instanceProperties");
var configuringSymbol = Symbol("configuring");
var lazyConfigValues = Symbol("lazyConfigValues");
var DATE_TYPE = toString2.call(/* @__PURE__ */ new Date());
var whitespace = /\s+/;
var createClsProps = (result, cls) => {
  result[cls] = 1;
  return result;
};
var Config = class {
  /**
   * Returns the `Config` instance for the given `name` and `options`.
   * @param {String} name The name of the config (e.g., 'text' for the text config).
   * @param {Object} [options] Config behavior options.
   * @returns {Core.Config}
   * @internal
   */
  static get(name, options) {
    const { cache } = this, baseCfg = cache[name] || (cache[name] = new Config(name));
    let cfg = baseCfg, key;
    if (options) {
      key = Config.makeCacheKey(name, options);
      if (!(cfg = key && cache[key])) {
        cfg = baseCfg.extend(options);
        if (key) {
          cache[key] = cfg;
        }
      }
    }
    return cfg;
  }
  constructor(name) {
    const me = this, cap = name[0].toUpperCase() + name.substr(1);
    me.base = me;
    me.name = name;
    me.field = "_" + name;
    me.capName = cap;
    me.changer = "change" + cap;
    me.initializing = "initializing" + cap;
    me.updater = "update" + cap;
  }
  /**
   * The descriptor to use with `Reflect.defineProperty()` for defining this config's getter and setter.
   * @property {Object}
   * @private
   */
  get descriptor() {
    let descriptor = this._descriptor;
    if (!descriptor || !hasOwnProperty2.call(this, "_descriptor")) {
      this._descriptor = descriptor = this.makeDescriptor();
    }
    return descriptor;
  }
  /**
   * The descriptor to use with `Reflect.defineProperty()` for defining this config's initter.
   * @property {Object}
   * @private
   */
  get initDescriptor() {
    let descriptor = this._initDescriptor;
    if (!descriptor || !hasOwnProperty2.call(this, "_initDescriptor")) {
      this._initDescriptor = descriptor = this.makeInitter();
    }
    return descriptor;
  }
  /**
   * This method compares two values for semantic equality. By default, this is based on the `===` operator. This
   * is often overridden for configs that accept `Date` or array values.
   * @param {*} value1
   * @param {*} value2
   * @returns {Boolean}
   * @internal
   */
  equal(value1, value2) {
    return value1 === value2;
  }
  /**
   * Extends this config with a given additional set of options. These objects are just prototype extensions of this
   * instance.
   * @param {Object} options
   * @returns {Core.Config}
   * @internal
   */
  extend(options) {
    const cfg = Object.assign(Object.create(this), options), { equal: equal2, merge } = options, { equalityMethods } = Config;
    if (typeof equal2 === "string") {
      if (equal2.endsWith("[]")) {
        cfg.equal = Config.makeArrayEquals(equalityMethods[equal2.substr(0, equal2.length - 2)]);
      } else {
        cfg.equal = equalityMethods[equal2];
      }
    }
    if (typeof merge === "string") {
      cfg.merge = Config.mergeMethods[merge];
    }
    return cfg;
  }
  /**
   * Defines the property on a given target object via `Reflect.defineProperty()`. If the object has its own getter,
   * it will be preserved. It is invalid to define a setter.
   * @param {Object} target
   * @internal
   */
  define(target) {
    const existing = getOwnPropertyDescriptor(target, this.name);
    let descriptor = this.descriptor;
    if (existing && existing.get) {
      descriptor = Object.assign({}, descriptor);
      descriptor.get = existing.get;
    }
    defineProperty2(target, this.name, descriptor);
  }
  /**
   * Defines the property initter on the `target`. This is a property getter/setter that propagates the configured
   * value when the property is read.
   * @param {Object} target
   * @param {*} value
   * @internal
   */
  defineInitter(target, value) {
    const { name } = this, properties = target[instancePropertiesSymbol];
    let lazyValues, prop;
    if (!properties[name] && /* assign */
    (prop = getOwnPropertyDescriptor(target, name)) && !("value" in prop)) {
      properties[name] = prop;
    }
    defineProperty2(target, name, this.initDescriptor);
    if (this.lazy) {
      lazyValues = target[lazyConfigValues] || (target[lazyConfigValues] = /* @__PURE__ */ new Map());
      lazyValues.set(name, value);
    }
  }
  /**
   * Returns an equality function for arrays of a base type, for example `'date'`.
   * @param {Function} [fn] The function to use to compare array elements. By default, operator `===` is used.
   * @returns {Function}
   * @private
   */
  static makeArrayEquals(fn2) {
    return (value1, value2) => {
      let i, equal2 = value1 && value2 && value1.length === (i = value2.length);
      if (equal2 && Array.isArray(value1) && Array.isArray(value2)) {
        if (fn2) {
          while (equal2 && i-- > 0) {
            equal2 = fn2(value1[i], value2[i]);
          }
        } else {
          while (equal2 && i-- > 0) {
            equal2 = value1[i] === value2[i];
          }
        }
      } else {
        equal2 = fn2 ? fn2(value1, value2) : value1 === value2;
      }
      return equal2;
    };
  }
  /**
   * Returns the key to use in the Config `cache`.
   * @param {String} name The name of the config property.
   * @param {Object} options The config property options.
   * @returns {String}
   * @private
   */
  static makeCacheKey(name, options) {
    const keys = Object.keys(options).sort();
    for (let key, type, value, i = keys.length; i-- > 0; ) {
      value = options[key = keys[i]];
      if (value == null && value === false) {
        keys.splice(i, 1);
      } else {
        type = typeof value;
        if (type === "function") {
          return null;
        }
        if (type === "string") {
          keys[i] = `${key}:"${value}"`;
        } else if (type === "number") {
          keys[i] = `${key}:${value}`;
        }
      }
    }
    return keys.length ? `${name}>${keys.join("|")}` : name;
  }
  /**
   * Creates and returns a property descriptor for this config suitable to be passed to `Reflect.defineProperty()`.
   * @returns {Object}
   * @private
   */
  makeDescriptor() {
    const config = this, { base, field: field2, changer, updater, name } = config;
    if (base !== config && base.equal === config.equal) {
      return base.descriptor;
    }
    return {
      get() {
        var _a2;
        (_a2 = this.configObserver) == null ? void 0 : _a2.get(name, this);
        return this[field2];
      },
      set(value) {
        var _a2, _b;
        const me = this;
        let was = me[field2], applied, newValue;
        if (typeof value === "string") {
          let resolvedValue = value;
          if (value.startsWith("up.")) {
            resolvedValue = (_a2 = me.owner) == null ? void 0 : _a2.resolveProperty(value.substr(3));
          } else if (value.startsWith("this.")) {
            resolvedValue = me.resolveProperty(value.substr(5));
          }
          if (resolvedValue !== void 0 && typeof resolvedValue !== "function") {
            value = resolvedValue;
          }
        }
        if (me[changer]) {
          applied = (newValue = me[changer](value, was)) === void 0;
          if (!applied) {
            value = newValue;
            was = me[field2];
          }
        }
        if (!applied && !(config.equal === equal ? was === value : config.equal(was, value))) {
          me[field2] = value;
          applied = true;
          (_b = me[updater]) == null ? void 0 : _b.call(me, value, was);
        }
        if (applied && !me.isDestroyed && !me.onConfigChange.$nullFn) {
          me.onConfigChange({ name, value, was, config });
        }
      }
    };
  }
  /**
   * Creates and returns a property descriptor for this config's initter suitable to pass to
   * `Reflect.defineProperty()`.
   * @returns {Object}
   * @private
   */
  makeInitter() {
    const config = this;
    if (config !== config.base) {
      if (config.lazy) {
        return config.makeLazyInitter();
      }
      return config.base.initDescriptor;
    }
    return config.makeBasicInitter();
  }
  makeBasicInitter() {
    const config = this, { initializing, name } = config;
    return {
      configurable: true,
      get() {
        const me = this;
        config.removeInitter(me);
        me[initializing] = true;
        me[name] = me[configuringSymbol][name];
        me[initializing] = false;
        me.configDone[name] = true;
        return me[name];
      },
      set(value) {
        config.removeInitter(this);
        this.configDone[name] = true;
        this[name] = value;
      }
    };
  }
  makeLazyInitter() {
    const config = this, { initializing, name } = config;
    return {
      configurable: true,
      get() {
        const me = this, value = me[lazyConfigValues].get(name);
        config.removeInitter(me);
        if (!me.isDestroying) {
          me[initializing] = true;
          me[name] = value;
          me[initializing] = false;
        }
        return me[name];
      },
      set(value) {
        config.removeInitter(this);
        this[name] = value;
      }
    };
  }
  /**
   * Removes the property initter and restores the instance to its original form.
   * @param {Object} instance
   * @private
   */
  removeInitter(instance) {
    const { name } = this, instanceProperty = instance[instancePropertiesSymbol][name], lazyValues = instance[lazyConfigValues];
    if (instanceProperty) {
      defineProperty2(instance, name, instanceProperty);
    } else {
      delete instance[name];
    }
    if ((lazyValues == null ? void 0 : lazyValues.delete(name)) && !lazyValues.size) {
      delete instance[lazyConfigValues];
    }
  }
  setDefault(cls, value) {
    defineProperty2(cls.prototype, this.field, {
      configurable: true,
      writable: true,
      // or else "this._value = x" will fail
      value
    });
  }
  /**
   * This method combines (merges) two config values. This is called in two cases:
   *
   *  - When a derived class specifies the value of a config defined in a super class.
   *  - When a value is specified in the instance config object.
   *
   * @param {*} newValue In the case of derived classes, this is the config value of the derived class. In the case
   * of the instance config, this is the instance config value.
   * @param {*} currentValue In the case of derived classes, this is the config value of the super class. In the case
   * of the instance config, this is the class config value.
   * @param {Object} metaNew The class meta object from which the `newValue` is coming. This parameter is `null` if
   * the `newValue` is from an instance configuration.
   * @param {Object} metaCurrent The class meta object from which the `currentValue` is coming. This parameter is
   * `null` if the `currentValue` is not from a class configuration.
   * @returns {*}
   * @internal
   */
  merge(newValue, currentValue) {
    if (currentValue && newValue && Objects.isObject(newValue)) {
      if (currentValue.isBase) {
        return currentValue.setConfig(newValue);
      }
      if (Objects.isObject(currentValue)) {
        newValue = Objects.merge(Objects.clone(currentValue), newValue);
      }
    }
    return newValue;
  }
};
var { prototype } = Config;
var { equal } = prototype;
Config.symbols = {
  configuring: configuringSymbol,
  instanceProperties: instancePropertiesSymbol,
  lazyConfigs: lazyConfigValues
};
Config.cache = /* @__PURE__ */ Object.create(null);
Config.equalityMethods = {
  array: Config.makeArrayEquals(),
  date(value1, value2) {
    if (value1 === value2) {
      return true;
    }
    if (value1 && value2 && toString2.call(value1) === DATE_TYPE && toString2.call(value2) === DATE_TYPE) {
      return value1.getTime() === value2.getTime();
    }
    return false;
  },
  strict: Config.equal = equal
};
Config.mergeMethods = {
  distinct(newValue, oldValue) {
    let ret = oldValue ? oldValue.slice() : [];
    if (newValue != null) {
      if (Objects.isObject(newValue)) {
        if (oldValue === void 0) {
          ret = newValue;
        } else {
          let key, index;
          for (key in newValue) {
            index = ret.indexOf(key);
            if (newValue[key]) {
              if (index < 0) {
                ret.push(key);
              }
            } else if (index > -1) {
              ret.splice(index, 1);
            }
          }
        }
      } else if (Array.isArray(newValue)) {
        newValue.forEach((v) => !ret.includes(v) && ret.push(v));
      } else if (!ret.includes(newValue)) {
        ret.push(newValue);
      }
    }
    return ret;
  },
  merge: Config.merge = prototype.merge,
  classList(newValue, oldValue) {
    if (typeof newValue === "string") {
      if (!newValue.length) {
        return oldValue;
      }
      newValue = newValue.split(whitespace);
    }
    if (Array.isArray(newValue)) {
      newValue = newValue.reduce(createClsProps, {});
    }
    return Config.merge(newValue, oldValue);
  },
  objects(newValue, oldValue) {
    return newValue === true ? oldValue || {} : Config.merge(newValue, oldValue);
  },
  replace(newValue) {
    return newValue;
  },
  items(newValue, oldValue, metaNew, metaCurrent) {
    if (metaCurrent) {
      return Objects.mergeItems(oldValue, newValue, {
        merge: (oldValue2, newValue2) => prototype.merge(newValue2, oldValue2)
      });
    }
    return prototype.merge(newValue, oldValue);
  }
};
Object.assign(prototype, {
  _descriptor: null,
  _initDescriptor: null,
  /**
   * A function that compares values for equality. This test is used to determine if the `update` method should be
   * called when the setter is invoked.
   *
   * To handle `Date` values:
   * ```
   *  class Foo extends Base {
   *      static get configurable() {
   *          return {
   *              date : {
   *                  $config : {
   *                      equal : 'date'
   *                  },
   *
   *                  value : null
   *              }
   *          }
   *      }
   *
   *      updateDate(date) {
   *          // date has changed
   *      }
   *  }
   * ```
   *
   * Also useful for some configs:
   * ```
   *  class Foo extends Base {
   *      static get configurable() {
   *          return {
   *              bar : {
   *                  $config : {
   *                      equal : ObjectHelper.isEqual
   *                  },
   *
   *                  value : null
   *              }
   *          }
   *      }
   *
   *      updateBar(value) {
   *          // value has changed
   *      }
   *  }
   * ```
   * @config {Function} equal
   * @internal
   */
  /**
   * Indicates that this config property should not automatically initialize during construction. When this property
   * is set to `true`, initialization is triggered by the first use of the config property's getter.
   *
   * This property can alternatively be set to a string, in which case it can be initialized as a group using the
   * {@link Core.Base#function-triggerConfigs} method which will initialize all lazy configs with the same value for
   * this property. Note: the config will still initialize on first use if that occurs prior to the call to
   * `triggerConfigs`.
   * @config {Boolean|String}
   * @default
   * @internal
   */
  lazy: false,
  /**
   * Indicates that this config property should automatically be set to `null` on destroy.
   * @config {Boolean}
   * @default
   * @internal
   */
  nullify: false,
  /**
   * Indicates that this config participates in rendering. This has does not affect the behavior of the property
   * directly, but allows classes that perform rendering to detect which config changes will affect the rendered
   * result.
   * @config {Boolean}
   * @default
   * @internal
   */
  render: false
});
Config._$name = "Config";

// ../Core/lib/Core/Base.js
var MetaClass = class {
  constructor(options) {
    options && Object.assign(this, options);
  }
  getInherited(name, create = true) {
    var _a2;
    let ret = this[name];
    if (!(name in this)) {
      ret = (_a2 = this.super) == null ? void 0 : _a2.getInherited(name, create);
      if (ret || create) {
        this[name] = ret = Object.create(ret || null);
      }
    }
    return ret;
  }
};
var { getPrototypeOf } = Object;
var { hasOwn } = Objects;
var { defineProperty: defineProperty3 } = Reflect;
var metaSymbol = Symbol("classMetaData");
var mixinTagSymbol = Symbol("mixinTag");
var originalConfigSymbol = Symbol("originalConfig");
var createdAtSymbol = Symbol("createdAt");
var configuringSymbol2 = Config.symbols.configuring;
var instancePropertiesSymbol2 = Config.symbols.instanceProperties;
var lazyConfigsSymbol = Config.symbols.lazyConfigs;
var defaultConfigOptions = { merge: "replace", simple: true };
var emptyFn2 = () => {
};
var newMeta = (o) => new MetaClass(o);
var setupNames = {
  /* foo : 'setupFoo' */
};
var emptyObject2 = Object.freeze({});
var emptyArray = Object.freeze([]);
var Base2 = class {
  static get isBase() {
    return true;
  }
  get isBase() {
    return true;
  }
  // defaultConfig & properties made private to not spam all other classes
  /**
   * A class property getter to add additional, special class properties.
   *
   * For example, a class adds a `declarable` class property like so:
   * ```
   *  class Something extends Base {
   *      static get declarable() {
   *          return ['extra'];
   *      }
   *
   *      static setupExtra(cls, meta) {
   *          // use cls.extra
   *      }
   *  }
   * ```
   * A derived class can then specify this property like so:
   * ```
   *  class Derived extends Something {
   *      static get extra() {
   *          // return extra information
   *      }
   *  }
   * ```
   * When the `Derived` class is initialized, the `setupExtra()` method is called and `Derived` is passed as the
   * argument. It is also the `this` pointer, but the parameter is minifiable. The second argument passed is the
   * `$meta` object for the class.
   *
   * Classes are initialized at the first occurrence of the following:
   *
   * - An instance is created
   * - The class `$meta` property is accessed
   *
   * @member {String[]} declarable
   * @static
   * @category Configuration
   * @internal
   */
  static get declarable() {
    return [
      "declarable",
      /**
       * A class property getter for the configuration properties of the class, which can be overridden by
       * configurations passed at construction time.
       *
       * Unlike a normal `static` property, this property is only ever used for the class that defines it (as in,
       * `hasOwnProperty`). It is retrieved for all classes in a class hierarchy, to gather their configs
       * individually and then combine them with those of derived classes.
       *
       * For example, a `Label` might declare a `text` config like so:
       * ```javascript
       *  class Label extends Base {
       *      static get configurable() {
       *          return {
       *              text : null
       *          };
       *      }
       *  }
       * ```
       * The `text` config is automatically inherited by classes derived from Label. By implementing
       * `get configurable()`, derived classes can change the default value of inherited configs, or define new
       * configs, or both.
       *
       * When a config property is declared in this way, the class author can also implement either of two
       * special methods that will be called when the config property is assigned a new value:
       *
       *  - `changeText()`
       *  - `updateText()`
       *
       * In the example above, the `Label` class could implement a `changeText()` method, an `updateText()`
       * method, or both. The generated property setter ensures these methods will be called when the `text`
       * property is assigned.
       *
       * The generated setter (for `text` in this example) performs the following steps:
       *
       *  - If the class defines a `changeText()` method, call it passing the new value and the current value:
       *    `changeText(newText, oldText)`.<br>
       *    Then:
       *    * If `changeText()` exits without returning a value (i.e., `undefined`), exit and do nothing
       *      further. The assumption is that the changer method has done all that is required.
       *    * Otherwise, the return value of `changeText()` replaces the incoming value passed to the setter.
       *  - If the new value (or the value returned by `changeText()`) is `!==` to the current value:
       *    * Update the stored config value in `this._text`.
       *    * If the class defines an `updateText()` method, call it passing the new value and the previous value.
       *      `updateText(newText, oldText)`
       *
       * #### Resolving a value from an owner
       * By specifying a value starting with `'up.'` for a config, the config system will resolve that value by
       * examining the ownership hierarchy. It will walk up the hierarchy looking for a property matching the name
       * (or dot separated path) after 'up.'. If one is found, the value will be read and used as the initial
       * value.
       *
       * ```javascript
       * class Parent extends Base {
       *     static get configurable() {
       *         return [
       *           'importantValue'
       *         ]
       *     }
       * }
       *
       * class Child extends Base {
       *     static get configurable() {
       *         return [
       *           'value'
       *         ]
       *     }
       * }
       *
       * const parent = new Parent({
       *     importantValue : 123
       * });
       *
       * const child = new Child({
       *     owner : parent,
       *     // Will be resolved from the owner
       *     value : 'up.importantValue'
       * });
       *
       * console.log(child.value); // logs 123
       * ```
       * Please note that this is for now a one way one time binding, the value will only be read initially and
       * not kept up to date on later changes.
       *
       * #### Value Merging
       * When a config property value is an object, the value declared by the base class is merged with values
       * declared by derived classes and the value passed to the constructor.
       * ```javascript
       *  class Example extends Base {
       *      static get configurable() {
       *          return {
       *              config : {
       *                  foo : 1,
       *                  bar : 2
       *              }
       *          };
       *      }
       *  }
       *
       *  class Example2 extends Example {
       *      static get configurable() {
       *          return {
       *              config : {
       *                  bar : 42,
       *                  zip : 'abc'
       *              }
       *          };
       *      }
       *  }
       *
       *  let ex = new Example2({
       *      config : {
       *          zip : 'xyz'
       *      }
       *  });
       * ```
       * The result of the merge would set `config` to:
       * ```javascript
       *  ex.foo = {
       *      foo : 1,    // from Example
       *      bar : 42,   // from Example2
       *      zip : 'xyz' // from constructor
       *  }
       * ```
       *
       * #### Config Options
       * Some config properties require additional options such as declarative information about the config that
       * may be useful to automate some operation. Consider a `Button`. It could declare that its `text` config
       * affects the rendered HTML by applying a `render` property to the config definition. Its base class could
       * then examine the config definition to find this property.
       *
       * To support this, config options ca be declared like so:
       * ```javascript
       *  class Button extends Widget {
       *      static get configurable() {
       *          return {
       *              text : {
       *                  value   : null,
       *                  $config : {
       *                      render : true
       *                  }
       *              }
       *          };
       *      }
       *  }
       * ```
       * The `$config` property can alternatively be just the names of the options that should be enabled (set
       * to `true`).
       *
       * For example, the following is equivalent to the above:
       * ```javascript
       *  class Button extends Widget {
       *      static get configurable() {
       *          return {
       *              text : {
       *                  value   : null,
       *                  $config : 'render'
       *              }
       *          };
       *  }
       * ```
       *
       * #### Default Value
       * It is common to set a config to a `null` value to take advantage of internal optimizations for `null`
       * values. In most cases the fact that this produces `undefined` as the actual initial value of the config
       * is acceptable. When this is not acceptable, a config can be declared like so:
       * ```javascript
       *  class Widget {
       *      static get configurable() {
       *          return {
       *              disabled : {
       *                  $config : null,
       *                  value   : null,
       *                  default : false
       *              }
       *          };
       *  }
       * ```
       * The `default` property above determines the value of the config while still gaining the benefits of
       * minimal processing due to the `null` value of the `value` property.
       * @member {Object} configurable
       * @static
       * @category Configuration
       * @internal
       */
      "configurable",
      /**
       * A class property getter for the default configuration of the class, which can be overridden by
       * configurations passed at construction time.
       *
       * Unlike a normal `static` property, this property is only ever used for the class that defines it (as in,
       * `hasOwnProperty`). It is retrieved for all classes in a class hierarchy, to gather their configs
       * individually and then combine them with those of derived classes.
       *
       * For example, a `Store` might declare its `url` config like so:
       * ```
       *  class Store extends Base {
       *      static get defaultConfig() {
       *          return {
       *              url : null
       *          };
       *      }
       *  }
       * ```
       * The `url` config is automatically inherited by classes derived from Store. By implementing
       * `get defaultConfig()`, derived classes can change the default value of inherited configs, or define new
       * configs, or both. When defining new configs, however, `configurable` is preferred.
       *
       * Config properties introduced to a class by this declaration do not participate in value merging and do
       * not get a generated setter. Config properties introduced by a base class using `configurable` can be
       * set to a different value using `defaultConfig` and in doing so, the values will be merged as appropriate
       * for `configurable`.
       *
       * @member {Object} defaultConfig
       * @static
       * @category Configuration
       * @internal
       */
      "defaultConfig",
      /**
       * A class property getter for the default values of internal properties for this class.
       * @member {Object} properties
       * @static
       * @category Configuration
       * @internal
       */
      "properties",
      /**
       * A class property getter for properties that will be applied to the class prototype.
       * @member {Object} prototypeProperties
       * @static
       * @category Configuration
       * @internal
       */
      "prototypeProperties"
    ];
  }
  /**
   * Base constructor, passes arguments to {@link #function-construct}.
   * @param {...Object} [args] Usually called with a config object, but accepts any params
   * @function constructor
   * @category Lifecycle
   * @advanced
   */
  constructor(...args) {
    const me = this, C = me.constructor;
    if (me.$meta.class !== C) {
      emptyFn2(C.$meta);
    }
    me.construct(...args);
    me.afterConstruct();
    me.isConstructing = false;
  }
  /**
   * Factory version of the Base constructor. Merges all arguments to create a config object that is passed along to
   * the constructor.
   * @param {...Object} [configs] Allows passing multiple config objects
   * @returns {Core.Base} New instance
   * @private
   */
  static new(...configs) {
    configs = configs.filter((c) => c);
    return new this(configs.length > 1 ? this.mergeConfigs(...configs) : configs[0]);
  }
  /**
   * Base implementation applies configuration.
   *
   * Subclasses need only implement this if they have to initialize instance specific
   * properties required by the class. Often a `construct` method is
   * unnecessary. All initialization of incoming configuration properties can be
   * done in a `set propName` implementation.
   * @param {...Object} [args] Usually called with a config object, but accepts any params
   * @category Lifecycle
   * @advanced
   */
  construct(...args) {
    if (args[0] !== null) {
      this.configure(...args);
    }
    this.afterConfigure();
  }
  /**
   * Destroys the provided objects by calling their {@link #function-destroy} method.
   * Skips empty values or objects that are already destroyed.
   *
   * ```javascript
   * Base.destroy(myButton, toolbar1, helloWorldMessageBox);
   * ```
   * @param {...Object} [args] Objects to be destroyed
   * @category Lifecycle
   * @advanced
   */
  static destroy(...args) {
    const shredder = (object) => {
      if (object == null ? void 0 : object.destroy) {
        object.destroy();
      } else if (Array.isArray(object)) {
        object.forEach(shredder);
      }
    };
    shredder(args);
  }
  /**
   * Destroys this object.
   *
   * {@advanced}
   * This is primarily accomplished by calling {@link #function-doDestroy}, however, prior to
   * calling `doDestroy`, {@link #property-isDestroying} is set to `true`. After {@link #function-doDestroy} returns,
   * {@link #property-isDestroyed} is set to `true`.
   *
   * Do not override this method in subclasses. To provide class-specific cleanup, implement {@link #function-doDestroy}
   * instead.
   * {/@advanced}
   *
   * @category Lifecycle
   */
  destroy() {
    const me = this, { id } = me;
    me.isDestroying = true;
    me.destroy = emptyFn2;
    me.doDestroy();
    Object.setPrototypeOf(me, null);
    for (const key in me) {
      if (key !== "destroy" && key !== "isDestroying") {
        delete me[key];
      }
    }
    delete me[originalConfigSymbol];
    me.isDestroyed = true;
    me.id = id;
  }
  /**
   * This method is required to help `unused` getters to survive production build process. Some tools, like angular,
   * will remove `unused` code in production build, making our side-effected getters behind, breaking code heavily.
   * @internal
   * @param getter Getter to evaluate
   */
  _thisIsAUsedExpression(getter) {
  }
  static get $$name() {
    return hasOwn(this, "$name") && this.$name || // _$name is filled by webpack for every class (cls._$name = '...')
    hasOwn(this, "_$name") && this._$name || this.name;
  }
  get $$name() {
    return this.constructor.$$name;
  }
  /**
   * Base implementation so that all subclasses and mixins may safely call super.startConfigure.
   *
   * This is called by the Base class before setting configuration properties, but after
   * the active initial getters have been set, so all configurations are available.
   *
   * This method allows all classes in the hierarchy to force some configs to be evaluated before others.
   * @internal
   * @category Lifecycle
   * @params {Object} config The configuration object use to set the initial state.
   */
  startConfigure(config) {
  }
  /**
   * Base implementation so that all subclasses and mixins may safely call super.finishConfigure.
   *
   * This is called by the Base class before exiting the {@link #function-configure} method.
   *
   * At this point, all configs have been applied, but the `isConfiguring` property is still set.
   *
   * This method allows all classes in the hierarchy to inject functionality
   * into the config phase.
   * @internal
   * @category Lifecycle
   * @params {Object} config The configuration object use to set the initial state.
   */
  finishConfigure(config) {
  }
  /**
   * Base implementation so that all subclasses and mixins may safely call `super.afterConfigure`. This is called by the Base class after the {@link #function-configure} method has been
   * called. At this point, all configs have been applied.
   *
   * This method allows all classes in the hierarchy to inject functionality
   * either before or after the super.afterConstruct();
   * @internal
   * @category Lifecycle
   */
  afterConfigure() {
  }
  /**
   * Base implementation so that all subclasses and mixins may safely call super.afterConstruct.
   *
   * This is called by the Base class after the {@link #function-construct} method has been
   * called.
   *
   * At this point, all configs have been applied.
   *
   * This method allows all classes in the hierarchy to inject functionality
   * either before or after the super.afterConstruct();
   * @internal
   * @function afterConstructor
   * @category Lifecycle
   */
  afterConstruct() {
  }
  /**
   * Provides a way of calling callbacks which may have been specified as the _name_ of a function
   * and optionally adds scope resolution.
   *
   * For example, if the callback is specified as a string, then if it is prefixed with `'this.'`
   * then the function is resolved in this object. This is useful when configuring listeners
   * at the class level.
   *
   * If the callback name is prefixed with `'up.'` then the ownership hierarchy is queried
   * using the `owner` property until an object with the named function is present, then the
   * named function is called upon that object.
   *
   * If a named function is not found, an error is thrown. If the function should be only called when present,
   * and may not be present, add a `?` as a suffix.
   *
   * @param {String|Function} fn The function to call, or the name of the function to call.
   * @param {Object} thisObject The `this` object of the function.
   * @param {Object[]} args The argument list to pass.
   * @category Misc
   * @advanced
   */
  callback(fn2, thisObject, args = emptyArray) {
    const { handler, thisObj } = this.resolveCallback(fn2, thisObject === "this" ? this : thisObject) || emptyObject2;
    return handler == null ? void 0 : handler.apply(thisObj, args);
  }
  resolveProperty(propertyPath) {
    let thisObj = this;
    while (thisObj) {
      if (Objects.hasPath(thisObj, propertyPath)) {
        return Objects.getPath(thisObj, propertyPath);
      }
      thisObj = thisObj.owner;
    }
    return void 0;
  }
  /**
   * Provides a way of locating callbacks which may have been specified as the _name_ of a function
   * and optionally adds scope resolution.
   *
   * For example, if the callback is specified as a string, then if it is prefixed with `'this.'`
   * then the function is resolved in this object. This is useful when configuring listeners
   * at the class level.
   *
   * If the callback name is prefixed with `'up.'` then the ownership hierarchy is queried
   * using the `owner` property until an object with the named function is present, then the
   * named function is called upon that object.
   * @param {String|Function} handler The function to call, or the name of the function to call.
   * @param {Object} thisObj The `this` object of the function.
   * @param {Boolean} [enforceCallability = true] Pass `false` if the function may not exist, and a null return value is acceptable.
   * @returns {Object} `{ handler, thisObj }`
   * @category Misc
   * @advanced
   */
  resolveCallback(handler, thisObj = this, enforceCallability = true) {
    if (handler == null ? void 0 : handler.substring) {
      if (handler.endsWith("?")) {
        enforceCallability = false;
        handler = handler.substring(0, handler.length - 1);
      }
      if (handler.startsWith("up.")) {
        handler = handler.substring(3);
        for (thisObj = this.owner; thisObj && !thisObj[handler]; thisObj = thisObj.owner)
          ;
        if (!thisObj) {
          return;
        }
      } else if (handler.startsWith("this.")) {
        handler = handler.substring(5);
        thisObj = this;
      }
      if (!thisObj || !(thisObj instanceof Object)) {
        return;
      }
      handler = thisObj[handler];
    }
    if (typeof handler === "function") {
      return { handler, thisObj };
    }
    if (enforceCallability) {
      throw new Error(`No method named ${handler} on ${thisObj.$$name || "thisObj object"}`);
    }
  }
  bindCallback(inHandler, inThisObj = this) {
    if (inHandler) {
      const { handler, thisObj } = this.resolveCallback(inHandler, inThisObj);
      if (handler) {
        return handler.bind(thisObj);
      }
    }
  }
  /**
   * Delays the execution of the passed function by the passed time quantum, or if the time is omitted
   * or not a number, delays until the next animation frame. Note that this will use
   * {@link Core.mixin.Delayable#function-setTimeout} || {@link Core.mixin.Delayable#function-requestAnimationFrame}
   * if this class mixes in `Delayable`, otherwise it uses the global methods. The function will
   * be called using `this` object as its execution scope.
   * @param {Function} fn The function to call on a delay.
   * @param {Number} [delay] The number of milliseconds to delay.
   * @param {String} [name] The name of delay
   * @returns {Number} The created timeout id.
   * @private
   */
  delay(fn2, delay3, name = fn2.name || fn2) {
    fn2 = this.setTimeout ? fn2 : fn2.bind(this);
    const invoker = this.setTimeout ? this : globalThis;
    return invoker[typeof delay3 === "number" ? "setTimeout" : "requestAnimationFrame"](fn2, delay3, name);
  }
  /**
   * Classes implement this method to provide custom cleanup logic before calling `super.doDestroy()`. The general
   * pattern is as follows:
   *
   * ```javascript
   *  class Foo extends Base {
   *      doDestroy() {
   *          // perform custom cleanup
   *
   *          super.doDestroy();
   *      }
   *  }
   * ```
   *
   * This method is called by {@link #function-destroy} which also prevents multiple calls from reaching `doDestroy`.
   * Prior to calling `doDestroy`, {@link #property-isDestroying} is set to `true`. Upon return, the object is fully
   * destructed and {@link #property-isDestroyed} is set to `true`.
   *
   * Do not call this method directly. Instead call {@link #function-destroy}.
   * @category Lifecycle
   * @advanced
   */
  doDestroy() {
    const me = this, { nullify } = me.$meta;
    if (nullify) {
      for (let i = 0; i < nullify.length; ++i) {
        if (me[nullify[i].field] != null) {
          me[nullify[i].name] = null;
        }
      }
    }
  }
  /**
   * Destroys the named properties if they have been initialized, and if they have a `destroy` method.
   * Deletes the property from this object. For example:
   *
   *      this.destroyProperties('store', 'resourceStore', 'eventStore', 'dependencyStore', 'assignmentStore');
   *
   * @param {String} properties The names of the properties to destroy.
   * @internal
   * @category Lifecycle
   */
  destroyProperties(...properties) {
    var _a2, _b;
    const me = this;
    let key;
    for (key of properties) {
      if (key in me && (!me[configuringSymbol2] || !me[configuringSymbol2][key])) {
        (_b = (_a2 = me[key]) == null ? void 0 : _a2.destroy) == null ? void 0 : _b.call(_a2);
        delete me[key];
      }
    }
  }
  /**
   * Called by the Base constructor to apply configs to this instance. This must not be called.
   * @param {Object} config The configuration object from which instance properties are initialized.
   * @private
   * @category Lifecycle
   */
  configure(config = {}) {
    const me = this, meta = me.$meta, { beforeConfigure } = config, configs = meta.configs, fullConfig = me.getDefaultConfiguration();
    let cfg, key, value;
    me.initialConfig = config;
    me.isConfiguring = true;
    Object.assign(me, me.getProperties());
    for (key in config) {
      value = config[key];
      cfg = configs[key];
      fullConfig[key] = cfg ? cfg.merge(value, fullConfig[key], null, meta) : value;
    }
    if (beforeConfigure) {
      delete fullConfig.beforeConfigure;
      beforeConfigure(me, fullConfig);
    }
    me.setConfig(me[originalConfigSymbol] = fullConfig, true);
    me.isConfiguring = false;
  }
  /**
   * Returns the value of the specified config property. This is a method to allow
   * property getters to be explicitly called in a way that does not get optimized out.
   *
   * The following triggers the getter call, but optimizers will remove it:
   *
   *      inst.foo;   // also raises "expression has no side-effects" warning
   *
   * Instead, do the following to trigger a getter:
   *
   *      inst.getConfig('foo');
   *
   * @param {String} name
   * @internal
   * @category Configuration
   */
  getConfig(name) {
    return this[name];
  }
  /**
   * Sets configuration options this object with all the properties passed in the parameter object.
   * Timing is taken care of. If the setter of one config is called first, and references
   * the value of another config which has not yet been set, that config will be set just
   * in time, and the *new* value will be used.
   * @param {Object} config An object containing configurations to change.
   * @category Lifecycle
   * @advanced
   */
  setConfig(config, isConstructing) {
    var _a2;
    const me = this, wasConfiguring = me[configuringSymbol2], configDone = wasConfiguring ? me.configDone : me.configDone = {}, configs = me.$meta.configs;
    let cfg, key;
    me[instancePropertiesSymbol2] = {};
    me[configuringSymbol2] = wasConfiguring ? Object.setPrototypeOf(Object.assign({}, config), wasConfiguring) : config;
    for (key in config) {
      if (config[key] != null || hasOwn(config, key)) {
        cfg = configs[key] || Config.get(key);
        cfg.defineInitter(me, config[key]);
        if (!isConstructing) {
          configDone[key] = false;
        }
      } else {
        configDone[key] = true;
      }
    }
    if (isConstructing) {
      me.startConfigure(config);
    }
    for (key in config) {
      if (!configDone[key] && !((_a2 = configs[key]) == null ? void 0 : _a2.lazy)) {
        me[key] = config[key];
      }
    }
    if (wasConfiguring) {
      me[configuringSymbol2] = wasConfiguring;
    } else {
      delete me[configuringSymbol2];
    }
    if (isConstructing) {
      me.finishConfigure(config);
    }
    return me;
  }
  /**
   * Returns `true` if this instance has a non-null value for the specified config. This will not activate a lazy
   * config.
   *
   * @param {String} name The name of the config property.
   * @returns {Boolean}
   * @internal
   */
  hasConfig(name) {
    var _a2;
    const me = this, config = me[configuringSymbol2];
    return Boolean(
      me["_" + name] != null || // value has been assigned to backing property
      ((_a2 = me[lazyConfigsSymbol]) == null ? void 0 : _a2.get(name)) != null || // a lazy value is pending
      // config value has not been assigned but will be
      !me.configDone[name] && config && (config[name] != null || hasOwn(config, name))
    );
  }
  /**
   * Returns the value of an uningested config *without* ingesting the config or transforming
   * it from its raw value using its `changeXxxxx` method.
   *
   * @param {String} name The name of the config property.
   * @returns {*} The raw incoming config value.
   * @internal
   */
  peekConfig(name) {
    const me = this, lazyConfig = me[lazyConfigsSymbol], config = me[configuringSymbol2];
    if (lazyConfig == null ? void 0 : lazyConfig.has(name)) {
      return lazyConfig.get(name);
    }
    if (config && name in config) {
      if (me.configDone[name]) {
        return me[name];
      }
      if (config[name] != null || hasOwn(config, name)) {
        return config[name];
      }
    }
  }
  /**
   * Ensures that the specified config is initialized if it is needed. If there is a config value specified, and it
   * was initialized by this call, this method returns `true`. If there was a config value specified, and it was
   * already initialized, this method returns `false`. If there was no value specified for the given config, this
   * method returns `null`.
   *
   * This is not the same as just reading the property, because some property getters exist that do not actually just
   * read the config value back, but instead produce some result. Reading such properties to incidentally trigger a
   * possible config initializer can lead to incorrect results. For example, the Combo items config.
   *
   * @param {String} name The name of the config property.
   * @returns {Boolean}
   * @internal
   */
  triggerConfig(name) {
    const me = this, { configDone } = me, lazyConfig = me[lazyConfigsSymbol], config = me[configuringSymbol2], triggered = (lazyConfig == null ? void 0 : lazyConfig.has(name)) || config && (config[name] != null || hasOwn(config, name)) ? !configDone[name] : null;
    if (triggered) {
      me.getConfig(name);
    }
    return triggered;
  }
  /**
   * This call will activate any pending {@link Core.Config#config-lazy} configs that were assigned a string value
   * equal to the `group` parameter.
   *
   * @param {String} group The config property group as defined by a matching {@link Core.Config#config-lazy} value.
   * @returns {String[]} The names of any configs triggered by this call or `null` if no configs were triggered.
   * @internal
   */
  triggerConfigs(group) {
    const me = this, configs = me.$meta.configs, lazyConfigs = me[lazyConfigsSymbol], triggered = lazyConfigs ? [...lazyConfigs.keys()].filter((k) => configs[k].lazy === group) : emptyArray;
    for (const key of triggered) {
      me.triggerConfig(key);
    }
    return triggered.length ? triggered : null;
  }
  onConfigChange() {
  }
  // declared above because lint/IDE get angry about not declaring the args...
  /**
   * This method is called when any config changes.
   * @param {Object} info Object containing information regarding the config change.
   * @param {String} info.name The name of the config that changed.
   * @param {*} info.value The new value of the config.
   * @param {*} info.was The previous value of the config.
   * @param {Core.Config} info.config The `Config` object for the changed config property.
   * @method onConfigChange
   * @internal
   * @category Configuration
   */
  /**
   * Returns a *copy* of the full configuration which was used to configure this object.
   * @property {Object}
   * @category Lifecycle
   * @readonly
   * @advanced
   */
  get config() {
    const result = {}, myConfig = this[originalConfigSymbol];
    for (const key in myConfig) {
      result[key] = myConfig[key];
    }
    return result;
  }
  // region Extract config
  static processConfigValue(currentValue, options) {
    if (currentValue === globalThis) {
      return globalThis;
    } else if (Array.isArray(currentValue)) {
      return currentValue.map((v) => Base2.processConfigValue(v, options));
    } else if (currentValue instanceof Base2) {
      if (options.visited.has(currentValue)) {
        return;
      }
      return currentValue.getCurrentConfig(options);
    } else if (currentValue instanceof HTMLElement || currentValue instanceof DocumentFragment) {
      return null;
    } else if (Objects.isObject(currentValue)) {
      const result = {};
      for (const key in currentValue) {
        if (key !== "owner") {
          result[key] = Base2.processConfigValue(currentValue[key], options);
        }
      }
      return result;
    }
    return currentValue;
  }
  // Recursively get the value of a config. Only intended to be called by getCurrentConfig()
  getConfigValue(name, options) {
    var _a2;
    const me = this, lazyConfigs = me[lazyConfigsSymbol];
    if (!((_a2 = me.$meta.configs[name]) == null ? void 0 : _a2.lazy)) {
      return Base2.processConfigValue(me[name], options);
    }
    if (lazyConfigs == null ? void 0 : lazyConfigs.has(name)) {
      return Base2.processConfigValue(lazyConfigs.get(name), options);
    }
  }
  // Allows removing / adding configs before values are extracted
  preProcessCurrentConfigs() {
  }
  // Extract the current values for all initially used configs, in a format that can be used to create a new instance.
  // Not intended to be called by any other code than getConfigString()
  getCurrentConfig(options = {}) {
    const me = this, configs = options.configs === "all" ? me.config : Objects.clone(me.initialConfig), visited = options.visited || (options.visited = /* @__PURE__ */ new Set()), depth = options.depth || (options.depth = 0), result = {};
    if (visited.has(me)) {
      return void 0;
    }
    visited.add(me);
    this.preProcessCurrentConfigs(configs);
    for (const name in configs) {
      const value = me.getConfigValue(name, { ...options, depth: depth + 1 });
      if (value !== void 0) {
        result[name] = value;
      }
    }
    return result;
  }
  // Extract the current values for all initially used configs and convert them to a JavaScript string
  getConfigString(options = {}) {
    return StringHelper.toJavaScriptString(this.getCurrentConfig(options));
  }
  // Experimental helper function, extracts the currently used configs and wraps them as an app, returning code as a
  // string.
  //
  // This function is intended to simplify creating test cases for issue reporting on Bryntum's support forum.
  //
  getTestCase(options = {}) {
    const Product = this.isGantt ? "Gantt" : this.isSchedulerPro ? "SchedulerPro" : this.isCalendar ? "Calendar" : this.isScheduler ? "Scheduler" : this.isGrid ? "Grid" : this.isTaskBoard ? "TaskBoard" : null;
    if (Product) {
      const product = Product.toLowerCase(), bundlePath = `../../build/${product}.module.js`;
      let preamble, postamble;
      if (options.import === "static") {
        preamble = `import * as module from "${bundlePath}";Object.assign(window, module);`;
        postamble = "";
      } else {
        preamble = `import("${bundlePath}").then(module => { Object.assign(window, module);
`;
        postamble = "});";
      }
      const version = VersionHelper.getVersion(product);
      if (version) {
        preamble += `
console.log('${Product} ${version}');
`;
      }
      return `${preamble}      
const ${product} = new ${Product}(${this.getConfigString(options)});
${postamble}`;
    }
  }
  /**
   * Experimental helper function, extracts the currently used configs and wraps them as an app, downloading the
   * resulting JS file.
   *
   * This function is intended to simplify creating test cases for issue reporting on Bryntum's support forum.
   * @category Misc
   */
  downloadTestCase(options = {}) {
    options.output = "return";
    const app = this.getTestCase(options);
    BrowserHelper.download(`app.js`, "data:application/javascript;charset=utf-8," + escape(app));
  }
  //endregion
  /**
   * Registers this class type with its Factory
   * @category Misc
   * @advanced
   */
  static initClass() {
    return this.$meta.class;
  }
  /**
   * The class's {@link #property-$meta-static meta} object.
   * @member {Object} $meta
   * @internal
   * @category Misc
   */
  /**
   * An object owned by this class that does not share properties with its super class.
   *
   * This object may contain other properties which are added as needed and are not documented here.
   *
   * @property {Object} $meta The class meta object.
   * @property {Function} $meta.class The class constructor that owns the meta object.
   * @property {Object} $meta.super The `$meta` object for the super class. This is `null` for `Base`.
   * @property {Object} $meta.config The object holding the default configuration values for this class.
   * @property {Object} $meta.configs An object keyed by config name that holds the defined configs for the class.
   * The value of each property is a {@link Core/Config} instance.
   * @property {Boolean} $meta.forkConfigs This will be `true` if the default configuration values for this class
   * (in the `config` property of the meta object) must be forked to avoid object sharing, or if the object can be
   * passed to `Object.create()` for efficiency.
   * @property {Function[]} $meta.hierarchy The array of classes in the ancestry of this class. This will start with
   * `Base` at index 0 and ends with this class.
   * @property {Function[]} $meta.properties The array of classes that define a "static get properties()" getter.
   * @internal
   * @static
   * @category Misc
   */
  static get $meta() {
    const me = this;
    let meta = me[metaSymbol];
    if (!hasOwn(me, metaSymbol)) {
      me[metaSymbol] = meta = newMeta();
      meta.class = me;
      me.setupClass(meta);
    }
    return meta;
  }
  /**
   * This optional class method is called when a class is mixed in using the {@link #function-mixin-static mixin()}
   * method.
   * @internal
   */
  static onClassMixedIn() {
  }
  /**
   * Returns the merge of the `baseConfig` and `config` config objects based on the configs defined by this class.
   * @param {Object} baseConfig The base config or defaults.
   * @param {...Object} configs One or more config objects that takes priority over `baseConfig`.
   * @returns {Object}
   * @internal
   */
  static mergeConfigs(baseConfig, ...configs) {
    const classConfigs = this.$meta.configs, result = Objects.clone(baseConfig) || {};
    let config, i, key, value;
    for (i = 0; i < configs.length; ++i) {
      config = configs[i];
      if (config) {
        for (key in config) {
          value = config[key];
          if (classConfigs[key]) {
            value = classConfigs[key].merge(value, result[key]);
          } else if (result[key] && value) {
            value = Config.merge(value, result[key]);
          }
          result[key] = value;
        }
      }
    }
    return result;
  }
  /**
   * Applies one or more `mixins` to this class and returns the produced class constructor.
   *
   * For example, instead of writing this:
   * ```
   *  class A extends Delayable(Events(Localizable(Base))) {
   *      // ...
   *  }
   * ```
   *
   * Using this method, one would write this:
   * ```
   *  class A extends Base.mixin(Localizable, Events, Delayable) {
   *      // ...
   *  }
   * ```
   * If one of the mixins specified has already been mixed into the class, it will be ignored and not mixed in a
   * second time.
   * @param {...Function} mixins
   * @returns {Function}
   * @category Misc
   * @advanced
   */
  static mixin(...mixins) {
    let C = this, i;
    for (i = 0; i < mixins.length; ++i) {
      const mixin2 = mixins[i], tag = mixin2[mixinTagSymbol] || (mixin2[mixinTagSymbol] = Symbol("mixinTag"));
      if (C[tag]) {
        continue;
      }
      C = mixin2(C);
      C[tag] = true;
      if (hasOwn(C, "onClassMixedIn")) {
        C.onClassMixedIn();
      }
    }
    return C;
  }
  /**
   * This method is called only once for any class. This can occur when the first instance is created or when the
   * `$meta` object is first requested.
   * @param {Object} meta The `$meta` object for the class.
   * @internal
   * @category Misc
   */
  static setupClass(meta) {
    var _a2;
    const cls = meta.class, base = getPrototypeOf(cls).$meta, name = cls.$$name, names = base.names, proto3 = cls.prototype;
    defineProperty3(proto3, "$meta", {
      value: meta
    });
    Object.assign(meta, {
      super: base,
      config: Object.create(base.config),
      configs: Object.create(base.configs),
      declarables: base.declarables,
      forkConfigs: base.forkConfigs,
      hierarchy: Object.freeze([...base.hierarchy, cls]),
      names: names.includes(name) ? names : Object.freeze([...names, name]),
      properties: base.properties,
      nullify: (_a2 = base.nullify) == null ? void 0 : _a2.slice()
    });
    if (names !== meta.names) {
      const isName = `is${name}`, defineIsProperty = (obj) => {
        if (!hasOwn(obj, isName)) {
          defineProperty3(obj, isName, {
            get() {
              return true;
            }
          });
        }
      };
      defineIsProperty(proto3);
      defineIsProperty(cls);
    }
    for (let decl, setupName, i = 0; i < meta.declarables.length; ++i) {
      decl = meta.declarables[i];
      if (hasOwn(cls, decl)) {
        setupName = setupNames[decl] || (setupNames[decl] = `setup${StringHelper.capitalize(decl)}`);
        cls[setupName](cls, meta);
      }
    }
  }
  /**
   * This method is called as part of `setupClass()`. It will process the `configurable()` return object and the
   * `defaultConfig` return object.
   * @param {Object} meta The `meta` object for this class.
   * @param {Object} configs The config definition object.
   * @param {Boolean} simple `true` when processing `defaultConfig` and `false` when processing `configurable`.
   * @private
   * @category Configuration
   */
  static setupConfigs(meta, configs, simple) {
    const classConfigValues = meta.config, classConfigs = meta.configs, cls = meta.class, superMeta = meta.super;
    let { nullify } = meta, cfg, defaultValue2, options, setDefault, value, wasNullify;
    for (const name in configs) {
      value = configs[name];
      if (simple) {
        if (!(cfg = classConfigs[name])) {
          cfg = Config.get(name, defaultConfigOptions);
        } else {
          value = cfg.merge(value, classConfigValues[name], meta, superMeta);
        }
      } else {
        defaultValue2 = options = setDefault = void 0;
        if (value && typeof value === "object" && "$config" in value) {
          options = value.$config;
          if (options && !Objects.isObject(options)) {
            options = Objects.createTruthyKeys(options);
          }
          setDefault = "default" in value;
          defaultValue2 = setDefault ? value.default : defaultValue2;
          value = value.value;
        }
        if (!(cfg = classConfigs[name])) {
          cfg = Config.get(name, options);
          cfg.define(cls.prototype);
          setDefault = !(cfg.field in cls.prototype);
          wasNullify = false;
        } else {
          wasNullify = cfg.nullify;
          if (options) {
            cfg = cfg.extend(options);
          }
          value = cfg.merge(value, classConfigValues[name], meta, superMeta);
        }
        if (setDefault) {
          cfg.setDefault(cls, defaultValue2);
        }
        if (cfg.nullify && !wasNullify) {
          (nullify || (nullify = meta.nullify || (meta.nullify = []))).push(cfg);
        }
      }
      if (value && (Objects.isObject(value) || Array.isArray(value)) && !Object.isFrozen(value)) {
        meta.forkConfigs = true;
      }
      classConfigs[name] = cfg;
      classConfigValues[name] = value;
    }
  }
  static setupConfigurable(cls, meta) {
    cls.setupConfigs(meta, cls.configurable, false);
  }
  static setupDefaultConfig(cls, meta) {
    cls.setupConfigs(meta, cls.defaultConfig, true);
  }
  static setupDeclarable(cls, meta) {
    const declarable = cls.declarable;
    let all = meta.declarables, forked, i;
    for (i = 0; i < declarable.length; ++i) {
      if (!all.includes(declarable[i])) {
        if (!forked) {
          meta.declarables = forked = all = all.slice();
        }
        all.push(declarable[i]);
      }
    }
  }
  static setupProperties(cls, meta) {
    meta.properties = meta.super.properties.slice();
    meta.properties.push(cls);
    Object.freeze(meta.properties);
  }
  static setupPrototypeProperties(cls) {
    Object.assign(cls.prototype, cls.prototypeProperties);
  }
  /**
   * Gets the full {@link #property-defaultConfig-static} block for this object's entire inheritance chain
   * all the way up to but not including {@link Core.Base}
   * @returns {Object} All default config values for this class.
   * @private
   * @category Configuration
   */
  getDefaultConfiguration() {
    return this.constructor.getDefaultConfiguration();
  }
  /**
   * Gets the full {@link #property-defaultConfig-static} block for the entire inheritance chain for this class
   * all the way up to but not including {@link Core.Base}
   * @returns {Object} All default config values for this class.
   * @private
   * @category Configuration
   */
  static getDefaultConfiguration() {
    const meta = this.$meta, config = meta.forkConfigs ? Base2.fork(meta.config) : Object.create(meta.config);
    if (VersionHelper.isTestEnv && BrowserHelper.isBrowserEnv && config.testConfig && globalThis.__applyTestConfigs) {
      for (const o in config.testConfig) {
        config[o] = config.testConfig[o];
      }
    }
    return config;
  }
  static fork(obj) {
    let ret = obj, key, value;
    if (obj && Objects.isObject(obj) && !Object.isFrozen(obj)) {
      ret = Object.create(obj);
      for (key in obj) {
        value = obj[key];
        if (value) {
          if (Objects.isObject(value)) {
            ret[key] = Base2.fork(value);
          } else if (Array.isArray(value)) {
            ret[key] = value.slice();
          }
        }
      }
    }
    return ret;
  }
  /**
   * Gets the full {@link #property-properties-static} block for this class's entire inheritance chain
   * all the way up to but not including {@link Core.Base}
   * @returns {Object} All default config values for this class.
   * @private
   * @category Configuration
   */
  getProperties() {
    const hierarchy = this.$meta.properties, result = {};
    for (let i = 0; i < hierarchy.length; i++) {
      Object.assign(result, hierarchy[i].properties);
    }
    return result;
  }
  static get superclass() {
    return getPrototypeOf(this);
  }
  /**
   * Used by the Widget and GridFeatureManager class internally. Returns the class hierarchy of this object
   * starting from the `topClass` class (which defaults to `Base`).
   *
   * For example `classHierarchy(Widget)` on a Combo would yield `[Widget, Field, TextField, PickerField, Combo]`
   * @param {Function} [topClass] The topmost class constructor to start from.
   * @returns {Function[]} The class hierarchy of this instance.
   * @private
   * @category Configuration
   */
  classHierarchy(topClass) {
    const hierarchy = this.$meta.hierarchy, index = topClass ? hierarchy.indexOf(topClass) : 0;
    return index > 0 ? hierarchy.slice(index) : hierarchy;
  }
  /**
   * Checks if an obj is of type using object's $$name property and doing string comparison of the property with the
   * type parameter.
   *
   * @param {String} type
   * @returns {Boolean}
   * @category Misc
   * @advanced
   */
  static isOfTypeName(type) {
    return this.$meta.names.includes(type);
  }
  /**
   * Removes all event listeners that were registered with the given `name`.
   * @param {String|Symbol} name The name of the event listeners to be removed.
   * @category Events
   * @advanced
   */
  detachListeners(name) {
    let detachers = this.$detachers;
    detachers = detachers == null ? void 0 : detachers[name];
    if (detachers) {
      while (detachers.length) {
        detachers.pop()();
      }
    }
  }
  /**
   * Tracks a detacher function for the specified listener name.
   * @param {String} name The name assigned to the associated listeners.
   * @param {Function} detacher The detacher function.
   * @private
   */
  trackDetacher(name, detacher) {
    const detachers = this.$detachers || (this.$detachers = {}), bucket2 = detachers[name] || (detachers[name] = []);
    bucket2.push(detacher);
  }
  /**
   * Removes all detacher functions for the specified `Events` object. This is called
   * by the `removeAllListeners` method on that object which is typically called by its
   * `destroy` invocation.
   * @param {Core.mixin.Events} eventer The `Events` instance to untrack.
   * @private
   */
  untrackDetachers(eventer) {
    const detachers = this.$detachers;
    if (detachers) {
      for (const name in detachers) {
        const bucket2 = detachers[name];
        for (let i = bucket2.length; i-- > 0; ) {
          if (bucket2[i].eventer === eventer) {
            bucket2.splice(i, 1);
          }
        }
      }
    }
  }
};
var proto = Base2.prototype;
proto.onConfigChange.$nullFn = emptyFn2.$nullFn = true;
Base2[metaSymbol] = proto.$meta = newMeta({
  class: Base2,
  config: Object.freeze({}),
  configs: /* @__PURE__ */ Object.create(null),
  declarables: Base2.declarable,
  forkConfigs: false,
  hierarchy: Object.freeze([Base2]),
  names: Object.freeze(["Base"]),
  nullify: null,
  properties: Object.freeze([]),
  super: null
});
Object.assign(proto, {
  $detachers: null,
  configObserver: null,
  /**
   * This property is set to `true` before the `constructor` returns.
   * @member {Boolean}
   * @readonly
   * @category Lifecycle
   * @advanced
   */
  isConstructing: true,
  /**
   * This property is set to `true` by {@link #function-destroy} after destruction.
   *
   * It is also one of the few properties that remains on the object after returning from `destroy()`. This property
   * is often checked in code paths that may encounter a destroyed object (like some event handlers) or in the
   * destruction path during cleanup.
   *
   * @member {Boolean}
   * @readonly
   * @category Lifecycle
   */
  isDestroyed: false,
  /**
   * This property is set to `true` on entry to the {@link #function-destroy} method. It remains on the objects after
   * returning from `destroy()`. If {@link #property-isDestroyed} is `true`, this property will also be `true`, so
   * there is no need to test for both (for example, `comp.isDestroying || comp.isDestroyed`).
   * @member {Boolean}
   * @readonly
   * @category Lifecycle
   * @advanced
   */
  isDestroying: false
});
Base2.emptyFn = emptyFn2;
VersionHelper.setVersion("core", "5.5.0");
Base2._$name = "Base";

// ../Core/lib/Core/helper/AjaxHelper.js
var paramValueRegExp = /^(\w+)=(.*)$/;
var parseParams = function(paramString) {
  const result = {}, params = paramString.split("&");
  for (const nameValuePair of params) {
    const [match, name, value] = paramValueRegExp.exec(nameValuePair), decodedName = decodeURIComponent(name), decodedValue = decodeURIComponent(value);
    if (match) {
      let paramValue = result[decodedName];
      if (paramValue) {
        if (!Array.isArray(paramValue)) {
          paramValue = result[decodedName] = [paramValue];
        }
        paramValue.push(decodedValue);
      } else {
        result[decodedName] = decodedValue;
      }
    }
  }
  return result;
};
var _AjaxHelper = class {
  /**
   * Make a request (using GET) to the specified url.
   * @param {String} url URL to `GET` from
   * @param {FetchOptions} [options] The options for the `fetch` API
   * @returns {Promise} The fetch Promise, which can be aborted by calling a special `abort` method
   * @async
   */
  static get(url, options) {
    return this.fetch(url, options);
  }
  /**
   * POST data to the specified URL.
   * @param {String} url URL to `POST` to
   * @param {String|Object|FormData} payload The data to post. If an object is supplied, it will be stringified
   * @param {FetchOptions} [options] The options for the `fetch` API
   * @returns {Promise} The fetch Promise, which can be aborted by calling a special `abort` method
   * @async
   */
  static post(url, payload, options = {}) {
    if (!(payload instanceof FormData) && !(typeof payload === "string")) {
      payload = JSON.stringify(payload);
      options.headers = options.headers || {};
      options.headers["Content-Type"] = options.headers["Content-Type"] || "application/json";
    }
    return this.fetch(url, Object.assign({
      method: "POST",
      body: payload
    }, options));
  }
  /**
   * Fetch the specified resource using the `fetch` API.
   * @param {String} url URL to fetch from
   * @param {FetchOptions} [options] The options for the `fetch` API
   * @returns {Promise} The fetch Promise, which can be aborted by calling a special `abort` method
   * @async
   */
  static fetch(url, options) {
    let controller;
    options = Objects.merge({}, _AjaxHelper.DEFAULT_FETCH_OPTIONS, options);
    if (typeof AbortController !== "undefined") {
      controller = options.abortController = new AbortController();
      options.signal = controller.signal;
    }
    if (!("credentials" in options)) {
      options.credentials = "include";
    }
    if (options.queryParams) {
      const params = Object.entries(options.queryParams);
      if (params.length) {
        let paramsAdded = false;
        if (options.headers && options.addQueryParamsToBody === true) {
          const contentType = new Headers(options.headers).get("Content-Type");
          let bodyClass;
          switch (contentType) {
            case "application/x-www-form-urlencoded":
              bodyClass = URLSearchParams;
              break;
            case "multipart/form-data":
              bodyClass = FormData;
              break;
          }
          if (bodyClass) {
            const body = options.body || (options.body = new bodyClass());
            if (body instanceof bodyClass) {
              params.forEach(([key, value]) => body.set(key, value));
              paramsAdded = true;
            }
          }
        }
        if (!paramsAdded) {
          url += (url.includes("?") ? "&" : "?") + params.map(
            ([param, value]) => `${param}=${encodeURIComponent(value)}`
          ).join("&");
        }
      }
    }
    const promise = new Promise((resolve, reject) => {
      fetch(url, options).then(
        (response) => {
          if (options.parseJson) {
            response.json().then((json) => {
              response.parsedJson = json;
              resolve(response);
            }).catch((error) => {
              response.parsedJson = null;
              response.error = error;
              reject(response);
            });
          } else {
            resolve(response);
          }
        }
      ).catch((error) => {
        error.stack = promise.stack;
        reject(error);
      });
    });
    promise.stack = new Error().stack;
    promise.abort = function() {
      controller == null ? void 0 : controller.abort();
    };
    return promise;
  }
  /**
   * Registers the passed URL to return the passed mocked up Fetch Response object to the
   * AjaxHelper's promise resolve function.
   * @param {String} url The url to return mock data for
   * @param {Object|Function} response A mocked up Fetch Response object which must contain
   * at least a `responseText` property, or a function to which the `url` and a `params` object
   * and the `Fetch` `options` object is passed which returns that.
   * @param {String} response.responseText The data to return.
   * @param {Boolean} [response.synchronous] resolve the Promise immediately
   * @param {Number} [response.delay=100] resolve the Promise after this number of milliseconds.
   */
  static mockUrl(url, response) {
    const me = this;
    (me.mockAjaxMap || (me.mockAjaxMap = {}))[url] = response;
    if (!_AjaxHelper.originalFetch) {
      _AjaxHelper.originalFetch = _AjaxHelper.fetch;
      _AjaxHelper.fetch = me.mockAjaxFetch.bind(me);
    }
  }
  static async mockAjaxFetch(url, options) {
    const urlAndParams = url.split("?");
    let result = this.mockAjaxMap[urlAndParams[0]], parsedJson = null;
    if (result) {
      if (typeof result === "function") {
        result = await result(urlAndParams[0], urlAndParams[1] && parseParams(urlAndParams[1]), options);
      }
      try {
        parsedJson = (options == null ? void 0 : options.parseJson) && JSON.parse(result.responseText);
      } catch (error) {
        parsedJson = null;
        result.error = error;
      }
      result = Object.assign({
        status: 200,
        ok: true,
        headers: new Headers(),
        statusText: "OK",
        url,
        parsedJson,
        text: () => new Promise((resolve) => {
          resolve(result.responseText);
        }),
        json: () => new Promise((resolve) => {
          resolve(parsedJson);
        })
      }, result);
      return new Promise(function(resolve, reject) {
        if (result.synchronous) {
          resolve(result);
        } else {
          setTimeout(function() {
            resolve(result);
          }, "delay" in result ? result.delay : 100);
        }
      });
    } else {
      return _AjaxHelper.originalFetch(url, options);
    }
  }
};
var AjaxHelper = _AjaxHelper;
/**
 * Sets default options for {@link #function-fetch-static AjaxHelper#fetch()} calls. Please see
 * {@link #typedef-FetchOptions} and
 * [fetch API](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch) for details.
 *
 * ```javascript
 * // default content-type for all requests will be "application/json"
 * AjaxHelper.DEFAULT_FETCH_OPTIONS = {
 *     headers : {
 *         'content-type' : 'application/json'
 *     }
 * };
 * ```
 * @member {FetchOptions} DEFAULT_FETCH_OPTIONS
 * @static
 */
__publicField(AjaxHelper, "DEFAULT_FETCH_OPTIONS", {});
AjaxHelper._$name = "AjaxHelper";

// ../Core/lib/Core/helper/ArrayHelper.js
var ArrayHelper = class {
  static clean(array) {
    return array.reduce((res, item) => {
      if (item !== null && item !== void 0 && !(Array.isArray(item) && item.length === 0) && item !== "")
        res.push(item);
      return res;
    }, []);
  }
  /**
   * Similar to [`Array.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from)
   * this method creates an array from an `iterable` object. Where `Array.from()` accepts a mapper function as the
   * second argument, this method accepts a `filter` function as its second argument. If a mapper function is also
   * needed, it can be passed as the third argument. Unlike `Array.from()`, if this method is passed `null`, it will
   * return an empty array.
   * @param {Array} iterable The iterable object to convert (must support `for-of` loop iteration).
   * @param {Function} [filter] A function to apply to each item of the `iterable` which must return a truthy value
   * to include that item in the resulting array.
   * @param {Function} [map] A function to apply to each item of the `iterable` that returns the actual value to put
   * into the returned array. If a `filter` is also supplied, this method is only called for those items that pass
   * the filter test.
   * @returns {Array}
   */
  static from(iterable, filter2, map2) {
    const array = [];
    if (iterable) {
      for (const it of iterable) {
        if (!filter2 || filter2(it)) {
          array.push(map2 ? map2(it) : it);
        }
      }
    }
    return array;
  }
  /**
   * Remove one or more items from an array
   * @param {Array} array Array to remove from
   * @param {Object[]|Set} items One or more items to remove, or one Set containing items to remove
   * @returns {Boolean} Returns true if any item was removed
   */
  static remove(array, ...items) {
    let index, item, removed = false;
    items = items[0] instanceof Set ? [...items[0]] : items;
    for (let i = 0; i < items.length; i++) {
      item = items[i];
      if ((index = array.indexOf(item)) !== -1) {
        array.splice(index, 1);
        removed = true;
      }
    }
    return removed;
  }
  /**
   * Calculates the insertion index of a passed object into the passed Array according
   * to the passed comparator function. Note that the passed Array *MUST* already be ordered.
   * @param {Object} item The item to calculate the insertion index for.
   * @param {Array} array The array into which the item is to be inserted.
   * @param {Function} comparatorFn The comparison function. Must return -1 or 0 or 1.
   * @param {Object} comparatorFn.lhs The left object to compare.
   * @param {Object} comparatorFn.rhs The right object to compare.
   * @param {Number} index The possible correct index to try first before a binary
   * search is instigated.
   * @internal
   */
  static findInsertionIndex(item, array, comparatorFn = this.lexicalCompare, index) {
    const len = array.length;
    let beforeCheck, afterCheck;
    if (index < len) {
      beforeCheck = index > 0 ? comparatorFn(array[index - 1], item) : 0;
      afterCheck = index < len - 1 ? comparatorFn(item, array[index]) : 0;
      if (beforeCheck < 1 && afterCheck < 1) {
        return index;
      }
    }
    return this.binarySearch(array, item, comparatorFn);
  }
  /**
   * Similar to the native `Array.find()` call, but this finds the *last* element in the array for which
   * the passed function returns a truthy value.
   * @param {Object[]} array The array to find in.
   * @param {Function} fn The testing function.
   * @param {Object} [thisObj] The scope (`this` reference) in which to call the function.
   */
  static findLast(array, fn2, thisObj) {
    for (let { length } = array, i = length - 1; i >= 0; i--) {
      if (fn2.call(thisObj, array[i], i, array)) {
        return array[i];
      }
    }
  }
  /**
   * This method returns the index that a given item would be inserted into the
   * given (sorted) `array`. Note that the given `item` may or may not be in the
   * array. This method will return the index of where the item *should* be.
   *
   * For example:
   *
   *      var array = [ 'A', 'D', 'G', 'K', 'O', 'R', 'X' ];
   *      var index = ArrayHelper.binarySearch(array, 'E');
   *
   *      console.log('index: ' + index);
   *      // logs "index: 2"
   *
   *      array.splice(index, 0, 'E');
   *
   *      console.log('array : ' + array.join(''));
   *      // logs "array: ADEGKORX"
   *
   * @param {Object[]} array The array to search.
   * @param {Object} item The item that you want to insert into the `array`.
   * @param {Number} [begin=0] The first index in the `array` to consider.
   * @param {Number} [end=array.length] The index that marks the end of the range
   * to consider. The item at this index is *not* considered.
   * @param {Function} [compareFn] The comparison function that matches the sort
   * order of the `array`. The default `compareFn` compares items using less-than
   * and greater-than operators.
   * @returns {Number} The index for the given item in the given array based on
   * the passed `compareFn`.
   */
  static binarySearch(array, item, begin = 0, end = array.length, compareFn = this.lexicalCompare) {
    const length = array.length;
    let middle, comparison;
    if (begin instanceof Function) {
      compareFn = begin;
      begin = 0;
    } else if (end instanceof Function) {
      compareFn = end;
      end = length;
    }
    --end;
    while (begin <= end) {
      middle = begin + end >> 1;
      comparison = compareFn(item, array[middle]);
      if (comparison >= 0) {
        begin = middle + 1;
      } else if (comparison < 0) {
        end = middle - 1;
      }
    }
    return begin;
  }
  magnitudeCompare(lhs, rhs) {
    return lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
  }
  lexicalCompare(lhs, rhs) {
    lhs = String(lhs);
    rhs = String(rhs);
    return lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
  }
  /**
   * Similar to Array.prototype.fill(), but constructs a new array with the specified item count and fills it with
   * clones of the supplied item.
   * @param {Number} count Number of entries to create
   * @param {Object|Array} itemOrArray Item or array of items to clone (uses object spread to create shallow clone)
   * @param {Function} [fn] An optional function that is called for each item added, to allow processing
   * @returns {Array} A new populated array
   */
  static fill(count, itemOrArray = {}, fn2 = null) {
    const result = [], items = Array.isArray(itemOrArray) ? itemOrArray : [itemOrArray];
    for (let i = 0; i < count; i++) {
      for (const item of items) {
        const processedItem = Object.assign({}, item);
        if (fn2) {
          fn2(processedItem, i);
        }
        result.push(processedItem);
      }
    }
    return result;
  }
  /**
   * Populates an array with the return value from `fn`.
   * @param {Number} count Number of entries to create
   * @param {Function} fn A function that is called `count` times, return value is added to array
   * @param {Number} fn.index Current index in the array
   * @privateparam {Boolean} [oneBased] Add 1 to the index before calling the fn (making it 1 based)
   * @returns {Array} A new populated array
   */
  static populate(count, fn2, oneBased = false) {
    const items = [];
    for (let i = 0; i < count; i++) {
      items.push(fn2(i + (oneBased ? 1 : 0)));
    }
    return items;
  }
  /**
   * Pushes `item` on to the `array` if not already included
   * @param {Array}  array Array to push to
   * @param {...Object} items Item(s) to push if not already included
   */
  static include(array, ...items) {
    for (const item of items) {
      if (!array.includes(item)) {
        array.push(item);
      }
    }
  }
  /**
   * Returns a new array with the unique items from the supplied array.
   * @param {Array} array Input array
   * @returns {Array} New array with unique items
   */
  static unique(array) {
    return [...new Set(array)];
  }
  // Kept for future reference : Wanted to create an indexer on Stores.
  static allowNegative(array) {
    return new Proxy(array, {
      get(target, name, receiver) {
        if (typeof name !== "string") {
          return Reflect.get(target, name, receiver);
        }
        const index = Number(name);
        if (Number.isNaN(index)) {
          return Reflect.get(target, name, receiver);
        }
        return target[index < 0 ? target.length + index : index];
      },
      set(target, name, value, receiver) {
        if (typeof name !== "string") {
          return Reflect.set(target, name, value, receiver);
        }
        const index = Number(name);
        if (Number.isNaN(index)) {
          return Reflect.set(target, name, value, receiver);
        }
        target[index < 0 ? target.length + index : index] = value;
        return true;
      }
    });
  }
  static delta(a, b, useRelativeNaming = false) {
    if (!b) {
      return useRelativeNaming ? { toAdd: a, toRemove: [], toKeep: [] } : { onlyInA: a, onlyInB: [], inBoth: [] };
    }
    const onlyInA = [], onlyInB = [], inBoth = /* @__PURE__ */ new Set(), bSet = new Set(b);
    for (let i = 0; i < a.length; i++) {
      const item = a[i];
      if (bSet.has(item)) {
        inBoth.add(item);
      } else {
        onlyInA.push(item);
      }
    }
    for (let i = 0; i < b.length; i++) {
      const item = b[i];
      if (!inBoth.has(item)) {
        onlyInB.push(item);
      }
    }
    if (useRelativeNaming) {
      return { toAdd: onlyInA, toRemove: onlyInB, toKeep: inBoth };
    }
    return { onlyInA, onlyInB, inBoth: [...inBoth] };
  }
  /**
   * Returns the passed object wrapped in an array. Special handling of the following cases:
   * * Passing an array returns it as is
   * * Passing a `Set` returns it converted to an Array
   * * Passing `null`/`undefined` returns the passed value
   *
   * ```javascript
   * const records = ArrayHelper.asArray(record);
   *
   * // { id : 1 } -> [{ id : 1 }]
   * // [{ id : 1 }] -> [{ id : 1 }]
   * ```
   *
   * @param {*} arrayOrObject
   * @returns {Array|null}
   * @internal
   */
  static asArray(arrayOrObject) {
    if (arrayOrObject == null) {
      return arrayOrObject;
    }
    if (arrayOrObject instanceof Set) {
      return Array.from(arrayOrObject);
    }
    return Array.isArray(arrayOrObject) ? arrayOrObject : [arrayOrObject];
  }
  /**
   * Identity function that returns its input.
   * @param {*} Any value
   * @returns {*} The input value
   * @internal
   */
  static identity(x) {
    return x;
  }
  /**
   * Transform an array into a key:value dictionary using the specified
   * key and value getters. Does not group values, so only one result will
   * appear in the output for a given key.
   *
   * ```javascript
   * const input = [{
   *     id: '1',
   *     other: 'one'
   * },{
   *     id: '2',
   *     other: 'two'
   * }];
   *
   * keyBy(input, rec => rec.id)
   *
   * // {
   * //    '1': { id: '1', other: 'one' },
   * //    '2': { id: '2', other: 'two' }
   * // }
   * ```
   *
   * @param {Array} array Array from which to build dictionary
   * @param {Function|String} getKey Function to produce the key for a given array entry, or a string property name to read
   * @param {Function} getValue Optional function to transform array elements. Defaults to returning the element itself
   * @returns {Object} A key->value dictionary with keys as returned by `getKey` and values returned by `getValue`
   * @internal
   */
  static keyBy(array, keyGetter, valueGetter = ArrayHelper.identity) {
    const getKey = typeof keyGetter === "string" ? (o) => o == null ? void 0 : o[keyGetter] : keyGetter, getValue = typeof valueGetter === "string" ? (o) => o == null ? void 0 : o[valueGetter] : valueGetter;
    return array.reduce((dict, next) => {
      dict[getKey(next)] = getValue(next);
      return dict;
    }, {});
  }
  /**
   * Combines provided arrays of by aggregating their element values.
   * For example the below code sums up numeric elements of the arrays:
   *
   * ```javascript
   * ArrayHelper.aggregate(
   *     [
   *         [0,   1,  2, 33]
   *         [10,  1, -1],
   *         [100, 1, -1]
   *     ],
   *     entry => entry || 0, // "|| 0" here to make it work for different array sizes
   *     (aggregated, entry) => aggregated + entry, // aggregate by summing up
   *     () => 0 //initial value is zero
   * );
   *
   * // returns [111, 3, 0, 33] array
   * ```
   *
   * @param {Array[]} arrays Array to combine
   * @param {Function} getEntryValueFn Function that extracts an array entry for aggregating.
   * @param {Function} aggregatorFn A function to execute for each element in the arrays. It's purpose is to
   * aggregate the element value to the corresponding entry of the resulting array.
   * The function's return value becomes the value of the `aggregated` parameter on the next invocation of
   * `aggregatorFn`.
   * The function is called with the following arguments:
   *
   * @param {Object} aggregatorFn.aggregated Resulting array entry value. On the first call
   * `getInitialValueFn` result.
   * @param {Object} aggregatorFn.entry Current entry to aggregate into `aggregated`.
   * @param {Number} aggregatorFn.arrayIndex Index of current array (in the provided `arrays`).
   * @param {Object[]} aggregatorFn.entryIndex Index of the current entry.
   * @param {Object} aggregationContext A shared object providing extra aggregation call context.
   * @param {Function} getInitialValueFn Function that returns an initial value for the combined array entries.
   * @param {Object} [aggregationContext] Optional object that is passed to all of the above functions that can
   * be used for keeping some additional parameters used when aggregating.
   * Out of the box the object will contain `arrays` and `targetArray` properties containing
   * input and resulting arrays respectively.
   */
  static aggregate(arrays, getEntryValueFn, aggregatorFn, getInitialValueFn, aggregationContext = {}) {
    const rowLength = arrays.length, columnLength = arrays[0].length, result = [];
    aggregationContext.targetArray = result;
    aggregationContext.arrays = arrays;
    for (let colIndex = 0; colIndex < columnLength; colIndex++) {
      aggregationContext.entryIndex = colIndex;
      result.push(getInitialValueFn(colIndex, aggregationContext));
    }
    for (let rowIndex = 0; rowIndex < rowLength; rowIndex++) {
      const row = arrays[rowIndex];
      aggregationContext.rowIndex = rowIndex;
      for (let colIndex = 0; colIndex < columnLength; colIndex++) {
        aggregationContext.entryIndex = colIndex;
        const entryValue = getEntryValueFn(row[colIndex], aggregationContext);
        result[colIndex] = aggregatorFn(result[colIndex], entryValue, rowIndex, colIndex, aggregationContext);
      }
    }
    return result;
  }
  /**
   * Group an array by keys (either the values in a specified property name, or the results of a string-generating function accepting
   * an array entry as input), returning an Object with those keys, whose values are arrays containing the array entries that
   * produced that key.
   *
   * ```javascript
   * const input = [{
   *     id: 1,
   *     color: 'red'
   * },{
   *     id: 2,
   *     color: 'green'
   * },{
   *     id: 3,
   *     color: 'green'
   * }];
   *
   * groupBy(input, 'color')
   *
   * // {
   * //    'red': [ { id: '1', color: 'red' } ],
   * //    'green': [ { id: '2', color: 'green' }, { id: '3', color: 'green' } ]
   * // }
   *
   * groupBy(input, rec => rec.color?.substr(0, 1))
   *
   * // {
   * //    'r': [ { id: '1', color: 'red' } ],
   * //    'g': [ { id: '2', color: 'green' }, { id: '3', color: 'green' } ]
   * // }
   * ```
   *
   * @param {Object} array Array from which to build dictionary
   * @param {Function|String} getGroupKey Function to produce the key for a given array entry, or a string property name to read
   * @returns {Object} A key->value[] dictionary with keys as returned by `getKey` and arrays of matching items in original order as values
   * @internal
   */
  static groupBy(array, groupKeyGetter) {
    const getKey = typeof groupKeyGetter === "string" ? (o) => o == null ? void 0 : o[groupKeyGetter] : groupKeyGetter;
    return array.reduce((grouped, value) => {
      const key = getKey(value);
      (grouped[key] = grouped[key] || []).push(value);
      return grouped;
    }, {});
  }
};
ArrayHelper._$name = "ArrayHelper";

// ../Core/lib/Core/helper/FunctionHelper.js
var commaSepRe = /,\s*/;
var decompiledSym = Symbol("decompiled");
var fnRe1 = /^\s*(async\s+)?([a-z_]\w*)\s*=>([\s\S]+)$/i;
var fnRe2 = /^\s*(async\s*)?\s*\(((?:[a-z_]\w*(?:, [a-z_]\w*)*)?)\)\s+=>([\s\S]+)$/i;
var fnRe3 = /^(\s*async)?(?:\s*function)?(?:\s*([a-z_]\w*))?\s*\(((?:[a-z_]\w*(?:, [a-z_]\w*)*)?)\)([\s\S]+)$/i;
var { hasOwnProperty: hasOwnProperty3 } = Object.prototype;
var FunctionHelper = class {
  /**
   * Inserts a function after the specified `method` is called on an `object`. To remove this hook, invoke the
   * function returned by this method.
   * ```
   *  class A {
   *      method() {
   *          console.log('method');
   *      }
   *  }
   *
   *  let instance = new A();
   *
   *  let detach = FunctionHelper.after(instance, 'method', () => { console.log('after') });
   *
   *  instance.method();
   *  > method
   *  > after
   *
   *  detach();
   *  instance.method();
   *  > method
   * ```
   * The value returned by the original method is passed as the first argument to `fn` followed by all the arguments
   * passed by the caller.
   *
   * If `fn` returns a value (not `undefined`), that value is returned from the method call instead of the value
   * returned by the original method.
   * ```
   *  class A {
   *      method(x) {
   *          console.log('method', x);
   *          return x * 2
   *      }
   *  }
   *
   *  let instance = new A();
   *
   *  let detach = FunctionHelper.after(instance, 'method', (ret, x) => {
   *      console.log('after', ret, x);
   *      return x / 2;
   *  });
   *
   *  console.log(instance.method(50));
   *  > method 50
   *  > after 100 50
   *  > 25
   *
   *  detach();
   *  console.log(instance.method(50));
   *  > method 50
   *  > 100
   * ```
   *
   * @param {Object} object The object to hook.
   * @param {String} method The name of the method on `object` to hook.
   * @param {Function|String} fn The function or method name (on `thisObj`) to call after `method`.
   * @param {Object} [thisObj] The `this` pointer value for calling `fn`.
   * @param {Object} [options] Additional options
   * @param {Boolean} [options.return=true] Specify `false` to not include the return value of the hooked method as
   * the first argument to `fn`.
   * @returns {Function} The function to call to remove the hook.
   */
  static after(object, method, fn2, thisObj, options) {
    const named = typeof fn2 === "string", withReturn = (options == null ? void 0 : options.return) !== false, hook = (...args) => {
      const origResult = hook.$nextHook.call(object, ...args), hookResult = (thisObj == null ? void 0 : thisObj.isDestroyed) ? void 0 : withReturn ? named ? thisObj[fn2](origResult, ...args) : fn2.call(thisObj, origResult, ...args) : named ? thisObj[fn2](...args) : fn2.call(thisObj, ...args);
      return hookResult === void 0 ? origResult : hookResult;
    };
    return FunctionHelper.hookMethod(object, method, hook);
  }
  /**
   * Inserts a function before the specified `method` is called on an `object`. To remove this hook, invoke the
   * function returned by this method.
   * ```
   *  class A {
   *      method() {
   *          console.log('method');
   *      }
   *  }
   *
   *  let instance = new A();
   *
   *  let detach = FunctionHelper.before(instance, 'method', () => { console.log('before') });
   *
   *  instance.method();
   *  > before
   *  > method
   *
   *  detach();
   *  instance.method();
   *  > method
   * ```
   * If `fn` returns `false`, the original method is not invoked and `false` is returned to the caller.
   * ```
   *  class A {
   *      method(x) {
   *          console.log('method', x);
   *          return x * 2;
   *      }
   *  }
   *
   *  let instance = new A();
   *
   *  let detach = FunctionHelper.before(instance, 'method', x => {
   *      console.log('before', x);
   *      return false;
   *  });
   *
   *  console.log(instance.method(50));
   *  > before 50
   *  > false
   *
   *  detach();
   *  console.log(instance.method(50));
   *  > method 50
   *  > 100
   * ```
   *
   * @param {Object} object The object to hook.
   * @param {String} method The name of the method on `object` to hook.
   * @param {Function|String} fn The function or method name (on `thisObj`) to call before `method`.
   * @param {Object} [thisObj] The `this` pointer value for calling `fn`.
   * @returns {Function} The function to call to remove the hook.
   */
  static before(object, method, fn2, thisObj) {
    const named = typeof fn2 === "string", hook = (...args) => {
      const ret = (thisObj == null ? void 0 : thisObj.isDestroyed) ? 0 : named ? thisObj[fn2](...args) : fn2.call(thisObj, ...args);
      return ret === false ? ret : hook.$nextHook.call(object, ...args);
    };
    return FunctionHelper.hookMethod(object, method, hook);
  }
  static curry(func) {
    return function curried(...args) {
      if (args.length >= func.length) {
        return func.apply(this, args);
      } else {
        return function(...args2) {
          return curried.apply(this, args.concat(args2));
        };
      }
    };
  }
  static bindAll(obj) {
    for (const key in obj) {
      if (typeof obj[key] === "function") {
        obj[key] = obj[key].bind(obj);
      }
    }
  }
  /**
   * Returns a function which calls the passed `interceptor` function first, and the passed `original` after
   * as long as the `interceptor` does not return `false`.
   * @param {Function} original The function to call second.
   * @param {Function} interceptor The function to call first.
   * @param {Object} [thisObj] The `this` reference when the functions are called.
   * @returns {Function} A function which yields the return value from the `original` function **if it was called**, else `false`.
   */
  static createInterceptor(original, interceptor, thisObj) {
    return function(...args) {
      const theThis = thisObj || this;
      if (interceptor.call(theThis, ...args) !== false) {
        return original.call(theThis, ...args);
      }
      return false;
    };
  }
  /**
   * Returns a function which calls the passed `sequence` function after calling
   * the passed `original`.
   * @param {Function} original The function to call first.
   * @param {Function} sequence The function to call second.
   * @param {Object} [thisObj] The `this` reference when the functions are called.
   * @returns {Function} A function which yields the value returned from the sequence if it returned a value, else the return
   * value from the original function.
   */
  static createSequence(original, sequence, thisObj) {
    return (...args) => {
      const origResult = original.call(thisObj, ...args), sequenceResult = sequence.call(thisObj, ...args);
      return sequenceResult === void 0 ? origResult : sequenceResult;
    };
  }
  /**
   * Create a "debounced" function which will call on the "leading edge" of a timer period.
   * When first invoked will call immediately, but invocations after that inside its buffer
   * period will be rejected, and *one* invocation will be made after the buffer period has expired.
   *
   * This is useful for responding immediately to a first mousemove, but from then on, only
   * calling the action function on a regular timer while the mouse continues to move.
   *
   * @param {Function} fn The function to call.
   * @param {Number} buffer The milliseconds to wait after each execution before another execution takes place.
   * @param {Object} [thisObj] `this` reference for the function.
   * @param {Array} [extraArgs] The argument list to append to those passed to the function.
   * @param {Function} [alt] A function to call when the invocation is rejected due to buffer time not having expired.
   * @returns {Function} A function which calls the passed `fn` only if at least the passed `buffer`
   * milliseconds has elapsed since its last invocation.
   */
  static createThrottled(fn2, buffer, thisObj, extraArgs, alt) {
    let lastCallTime = -Number.MAX_VALUE, callArgs, timerId;
    const invoke = () => {
      timerId = 0;
      lastCallTime = performance.now();
      callArgs.push.apply(callArgs, extraArgs);
      fn2.apply(thisObj, callArgs);
    }, result = function(...args) {
      const elapsed = performance.now() - lastCallTime;
      callArgs = args;
      if (elapsed >= buffer) {
        clearTimeout(timerId);
        invoke();
      } else {
        if (!timerId) {
          timerId = setTimeout(invoke, buffer - elapsed);
        }
        if (alt) {
          callArgs.push.apply(callArgs, extraArgs);
          alt.apply(thisObj, callArgs);
        }
      }
    };
    result.cancel = () => clearTimeout(timerId);
    return result;
  }
  /**
   * Create a "debounced" function which will call on the "trailing edge" of a timer period.
   * When first invoked will wait until the buffer period has expired to call the function, and
   * more calls within that time will restart the timer.
   *
   * This is useful for responding to keystrokes, but deferring action until the user pauses typing.
   *
   * @param {Function} fn The function to call.
   * @param {Number} buffer The milliseconds to wait after each execution before another execution takes place.
   * @param {Object} [thisObj] `this` reference for the function.
   * @param {Array} [args] The argument list to append to those passed to the function.
   * @returns {Function} A function which calls the passed `fn` when at least the passed `buffer`
   * milliseconds has elapsed since its last invocation.
   */
  static createBuffered(fn2, buffer, thisObj, args) {
    let callArgs, timerId;
    const invoke = () => {
      timerId = 0;
      result.isPending = false;
      callArgs.push.apply(callArgs, args);
      fn2.apply(thisObj, callArgs);
    }, result = function(...args2) {
      callArgs = args2;
      if (timerId) {
        clearTimeout(timerId);
      }
      result.isPending = true;
      timerId = setTimeout(invoke, buffer);
    };
    result.cancel = () => {
      result.isPending = false;
      clearTimeout(timerId);
    };
    return result;
  }
  static decompile(fn2) {
    if (!(decompiledSym in fn2)) {
      const code = fn2.toString();
      let m = fnRe1.exec(code), args, body, name, decompiled, t;
      if (m) {
        args = [m[2]];
        body = m[3];
      } else if (m = fnRe2.exec(code)) {
        t = m[2].trim();
        args = t ? t.split(commaSepRe) : [];
        body = m[3];
      } else if (m = fnRe3.exec(code)) {
        name = m[2];
        t = m[3].trim();
        args = t ? t.split(commaSepRe) : [];
        body = m[4];
      }
      body = body == null ? void 0 : body.trim();
      fn2[decompiledSym] = decompiled = m && {
        args,
        async: Boolean(m[1]),
        body: (body == null ? void 0 : body.startsWith("{")) ? body.substring(1, body.length - 1).trim() : body
      };
      if (name) {
        decompiled.name = name;
      }
    }
    return fn2[decompiledSym];
  }
  static hookMethod(object, method, hook) {
    hook.$nextHook = object[method];
    object[method] = hook;
    return () => {
      var _a2;
      if (hasOwnProperty3.call(object, method)) {
        let f = object[method], next;
        if (f === hook) {
          if (((_a2 = Object.getPrototypeOf(object)) == null ? void 0 : _a2[method]) === hook.$nextHook) {
            delete object[method];
          } else {
            object[method] = hook.$nextHook;
          }
        } else {
          for (; next = f == null ? void 0 : f.$nextHook; f = next) {
            if (next === hook) {
              f.$nextHook = hook.$nextHook;
              break;
            }
          }
        }
      }
    };
  }
  /**
   * Protects the specified `method` on a given `object` such that calling it will not throw exceptions.
   * @param {Object} object The object whose method is to be protected.
   * @param {String} method The name of the method to protect.
   * @param {Function} [handler] An optional function to call for any thrown exceptions.
   * @internal
   */
  static noThrow(object, method, handler) {
    const fn2 = object[method];
    object[method] = (...args) => {
      try {
        return fn2.apply(object, args);
      } catch (e) {
        return handler == null ? void 0 : handler(e);
      }
    };
  }
  static returnTrue() {
    return true;
  }
  static animate(duration, fn2, thisObj, easing = "linear") {
    let cancel = false;
    const result = new Promise((resolve) => {
      const start = performance.now(), iterate = () => {
        const progress = Math.min((performance.now() - start) / duration, 1), delayable = thisObj && thisObj.setTimeout ? thisObj : globalThis;
        if (!cancel) {
          if (fn2.call(thisObj, this.easingFunctions[easing](progress)) === false) {
            resolve();
          }
        }
        if (cancel || progress === 1) {
          delayable.requestAnimationFrame(() => resolve());
        } else {
          delayable.requestAnimationFrame(iterate);
        }
      };
      iterate();
    });
    result.cancel = () => {
      cancel = true;
      result.cancelled = true;
      return false;
    };
    return result;
  }
};
var half = 0.5;
var e1 = 1.70158;
var e2 = 7.5625;
var e3 = 1.525;
var e4 = 2 / 2.75;
var e5 = 2.25 / 2.75;
var e6 = 1 / 2.75;
var e7 = 1.5 / 2.75;
var e8 = 2.5 / 2.75;
var e9 = 2.625 / 2.75;
var e10 = 0.75;
var e11 = 0.9375;
var e12 = 0.984375;
var s1 = 1.70158;
var s2 = 1.70158;
FunctionHelper.easingFunctions = {
  linear: (t) => t,
  easeInQuad: (t) => Math.pow(t, 2),
  easeOutQuad: (t) => -(Math.pow(t - 1, 2) - 1),
  easeInOutQuad: (t) => (t /= half) < 1 ? half * Math.pow(t, 2) : -half * ((t -= 2) * t - 2),
  easeInCubic: (t) => Math.pow(t, 3),
  easeOutCubic: (t) => Math.pow(t - 1, 3) + 1,
  easeInOutCubic: (t) => (t /= half) < 1 ? half * Math.pow(t, 3) : half * (Math.pow(t - 2, 3) + 2),
  easeInQuart: (t) => Math.pow(t, 4),
  easeOutQuart: (t) => -(Math.pow(t - 1, 4) - 1),
  easeInOutQuart: (t) => (t /= half) < 1 ? half * Math.pow(t, 4) : -half * ((t -= 2) * Math.pow(t, 3) - 2),
  easeInQuint: (t) => Math.pow(t, 5),
  easeOutQuint: (t) => Math.pow(t - 1, 5) + 1,
  easeInOutQuint: (t) => (t /= half) < 1 ? half * Math.pow(t, 5) : half * (Math.pow(t - 2, 5) + 2),
  easeInSine: (t) => -Math.cos(t * (Math.PI / 2)) + 1,
  easeOutSine: (t) => Math.sin(t * (Math.PI / 2)),
  easeInOutSine: (t) => -half * (Math.cos(Math.PI * t) - 1),
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: (t) => t === 0 ? 0 : t === 1 ? 1 : (t /= half) < 1 ? half * Math.pow(2, 10 * (t - 1)) : half * (-Math.pow(2, -10 * --t) + 2),
  easeInCirc: (t) => -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: (t) => Math.sqrt(1 - Math.pow(t - 1, 2)),
  easeInOutCirc: (t) => (t /= half) < 1 ? -half * (Math.sqrt(1 - t * t) - 1) : half * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeOutBounce: (t) => t < e6 ? e2 * t * t : t < e4 ? e2 * (t -= e7) * t + e10 : t < e8 ? e2 * (t -= e5) * t + e11 : e2 * (t -= e9) * t + e12,
  easeInBack: (t) => t * t * ((e1 + 1) * t - e1),
  easeOutBack: (t) => (t = t - 1) * t * ((e1 + 1) * t + e1) + 1,
  easeInOutBack: (t) => {
    let v1 = s1;
    return (t /= half) < 1 ? half * (t * t * (((v1 *= e3) + 1) * t - v1)) : half * ((t -= 2) * t * (((v1 *= e3) + 1) * t + v1) + 2);
  },
  elastic: (t) => -1 * Math.pow(4, -8 * t) * Math.sin((t * 6 - 1) * (2 * Math.PI) / 2) + 1,
  swingFromTo: (t) => {
    let v2 = s2;
    return (t /= half) < 1 ? half * (t * t * (((v2 *= e3) + 1) * t - v2)) : half * ((t -= 2) * t * (((v2 *= e3) + 1) * t + v2) + 2);
  },
  swingFrom: (t) => t * t * ((e1 + 1) * t - e1),
  swingTo: (t) => (t -= 1) * t * ((e1 + 1) * t + e1) + 1,
  bounce: (t) => t < e6 ? e2 * t * t : t < e4 ? e2 * (t -= e7) * t + e10 : t < e8 ? e2 * (t -= e5) * t + e11 : e2 * (t -= e9) * t + e12,
  bouncePast: (t) => t < e6 ? e2 * t * t : t < e4 ? 2 - (e2 * (t -= e7) * t + e10) : t < e8 ? 2 - (e2 * (t -= e5) * t + e11) : 2 - (e2 * (t -= e9) * t + e12),
  easeFromTo: (t) => (t /= half) < 1 ? half * Math.pow(t, 4) : -half * ((t -= 2) * Math.pow(t, 3) - 2),
  easeFrom: (t) => Math.pow(t, 4),
  easeTo: (t) => Math.pow(t, 0.25)
};
FunctionHelper._$name = "FunctionHelper";

// ../Core/lib/Core/mixin/Events.js
var { isArray } = Array;
var { hasOwnProperty: hasOwnProperty4 } = Object.prototype;
var specialProperties = {
  thisObj: 1,
  detachable: 1,
  once: 1,
  detacher: 1,
  prio: 1,
  args: 1,
  expires: 1,
  buffer: 1,
  throttle: 1,
  name: 1,
  $internal: 1
};
var priorityComparator = (a, b) => b.prio - a.prio;
var Events_default = (Target) => class Events extends (Target || Base2) {
  constructor() {
    super(...arguments);
    __publicField(this, "eventsSuspended", null);
  }
  static get $name() {
    return "Events";
  }
  //region Events
  /**
   * Fires before an object is destroyed.
   * @event beforeDestroy
   * @param {Core.Base} source The Object that is being destroyed.
   */
  /**
   * Fires when an object is destroyed.
   * @event destroy
   * @param {Core.Base} source The Object that is being destroyed.
   */
  /**
   * Fires when any other event is fired from the object.
   *
   * **Note**: `catchAll` is fired for both public and private events. Please rely on the public events only.
   * @event catchAll
   * @param {Object} event The Object that contains event details
   * @param {String} event.type The type of the event which is caught by the listener
   */
  //endregion
  static get declarable() {
    return [
      /**
       * The list of deprecated events as an object, where `key` is an event name which is deprecated and
       * `value` is an object which contains values for
       * {@link Core.helper.VersionHelper#function-deprecate-static VersionHelper}:
       * - product {String} The name of the product;
       * - invalidAsOfVersion {String} The version where the offending code is invalid (when any compatibility
       *   layer is actually removed);
       * - message {String} Warning message to show to the developer using a deprecated API;
       *
       * For example:
       *
       * ```javascript
       * return {
       *     click : {
       *         product            : 'Grid',
       *         invalidAsOfVersion : '1.0.0',
       *         message            : 'click is deprecated!'
       *     }
       * }
       * ```
       *
       * @name deprecatedEvents
       * @returns {Object}
       * @static
       * @internal
       */
      "deprecatedEvents"
    ];
  }
  static setupDeprecatedEvents(cls, meta) {
    const all = meta.getInherited("deprecatedEvents"), add = cls.deprecatedEvents;
    for (const eventName in add) {
      all[eventName.toLowerCase()] = all[eventName] = add[eventName];
    }
  }
  //region Config
  static get configurable() {
    return {
      /**
       * Set to true to call onXXX method names (e.g. `onShow`, `onClick`), as an easy way to listen for events.
       *
       * ```javascript
       * const container = new Container({
       *     callOnFunctions : true
       *
       *     onHide() {
       *          // Do something when the 'hide' event is fired
       *     }
       * });
       * ```
       *
       * @config {Boolean} callOnFunctions
       * @category Misc
       * @default false
       */
      /**
       * The listener set for this object.
       *
       * An object whose property names are the names of events to handle, or options which modifiy
       * __how__ the handlers are called.
       *
       * See {@link #function-addListener} for details about the options.
       *
       * Listeners can be specified in target class config and they will be merged with any listeners specified in
       * the instantiation config. Class listeners will be fired first:
       *
       * ```javascript
       * class MyStore extends Store({
       *     static get configurable() {
       *         return {
       *             listeners : {
       *                 myCustomEvent() {
       *                 },
       *                 load : {
       *                     prio : 10000,
       *                     fn() { // this load listener handles things first }
       *                 }
       *             }
       *         }
       *     }
       * });
       *
       * let store = new MyStore({
       *   listeners: {
       *     load: () => { // This load listener runs after the class's },
       *     ...
       *   }
       * });
       * ```
       *
       * ### Handlers as function name
       *
       * Object event handlers may be specified as a function __name__. If a string is specified, it is the name
       * of the function in the `thisObj` object.
       *
       * If the string begins with `up.`, this object's ownership hierarchy
       * (if present) is scanned for an object which implements that function name:
       *
       * ```javascript
       * new Popup({
       *     tbar : {
       *         items : {
       *             myCombo : {
       *                 type      : 'combo',
       *                 editable  : false,
       *                 label     : 'Type',
       *                 listeners : {
       *                     // Look in owner chain for this function name
       *                     change : 'up.onFilterChange'
       *                 },
       *                 items     : [
       *                     'Event',
       *                     'Task',
       *                     'Appointment'
       *                 ]
       *             }
       *         }
       *     },
       *     items : {
       *         ...
       *     },
       *     onFilterChange({ value }) {
       *         // Handle event type selection here
       *     }
       * });
       *```
       *
       * @config {Object}
       * @category Common
       */
      listeners: {
        value: null,
        $config: {
          merge(newValue, currentValue) {
            if (newValue !== null) {
              if (!newValue) {
                return currentValue;
              }
              if (currentValue) {
                newValue = newValue ? [newValue] : [];
                newValue.push[isArray(currentValue) ? "apply" : "call"](newValue, currentValue);
              }
            }
            return newValue;
          }
        }
      },
      /**
       * Internal listeners, that cannot be removed by the user.
       * @config {Object}
       * @internal
       */
      internalListeners: null,
      /**
       * An object where property names with a truthy value indicate which events should bubble up the ownership
       * hierarchy when triggered.
       *
       * ```javascript
       * const container = new Container({
       *     items : [
       *        { type : 'text', bubbleEvents : { change : true }}
       *     ],
       *
       *     listeners : {
       *         change() {
       *             // Will catch change event from the text field
       *         }
       *     }
       * });
       * ```
       *
       * @config {Object}
       * @category Misc
       */
      bubbleEvents: null
    };
  }
  destroy() {
    this.trigger("beforeDestroy");
    super.destroy();
  }
  //endregion
  //region Init
  construct(config, ...args) {
    if (this.configuredListeners = config == null ? void 0 : config.listeners) {
      config = Objects.assign({}, config);
      delete config.listeners;
    }
    super.construct(config, ...args);
    this.processConfiguredListeners();
  }
  processConfiguredListeners() {
    if (this.configuredListeners) {
      const me = this, { isConfiguring } = me;
      me.isConfiguring = false;
      me.listeners = me.configuredListeners;
      me.configuredListeners = null;
      me.isConfiguring = isConfiguring;
    }
  }
  /**
   * Auto detaches listeners registered from start, if set as detachable
   * @internal
   */
  doDestroy() {
    this.trigger("destroy");
    this.removeAllListeners(false);
    super.doDestroy();
  }
  static setupClass(meta) {
    super.setupClass(meta);
    Events.prototype.onListen.$nullFn = true;
    Events.prototype.onUnlisten.$nullFn = true;
  }
  //endregion
  //region Listeners
  /**
   * Adds an event listener. This method accepts parameters in the following format:
   *
   * ```javascript
   *  myObject.addListener({
   *      thisObj    : this,          // The this reference for the handlers
   *      eventname2 : 'functionName' // Resolved at invocation time using the thisObj,
   *      otherevent : {
   *          fn      : 'handlerFnName',
   *          once    : true          // Just this handler is auto-removed on fire
   *      },
   *      yetanother  : {
   *          fn      : 'yetAnotherHandler',
   *          args    : [ currentState1, currentState2 ] // Capture info to be passed to handler
   *      },
   *      prio        : 100           // Higher prio listeners are called before lower
   *  });
   * ```
   *
   * When listeners have a `thisObj` option, they are linked to the lifecycle of that object.
   * When it is destroyed, those listeners are removed.
   *
   * The `config` parameter allows supplying options for the listener(s), for available options see {@link #typedef-BryntumListenerConfig}.
   *
   * A simpler signature may be used when only adding a listener for one event and no extra options
   * (such as `once` or `delay`) are required:
   *
   * ```javascript
   * myObject.addListener('click', myController.handleClicks, myController);
   * ```
   *
   * The args in this simple case are `eventName`, `handler` and `thisObj`
   *
   * @param {BryntumListenerConfig|String} config An object containing listener definitions, or the event name to listen for
   * @param {Object|Function} [thisObj] Default `this` reference for all listeners in the config object, or the handler
   * function to call if providing a string as the first arg.
   * @param {Object} [oldThisObj] The `this` reference if the old signature starting with a string event name is used..
   * @returns {Function} Returns a detacher function unless configured with `detachable: false`. Call detacher to remove listeners
   */
  addListener(config, thisObj, oldThisObj) {
    var _a2;
    if (isArray(config)) {
      for (let i = 0, { length } = config; i < length; i++) {
        this.addListener(config[i], thisObj);
      }
      return;
    }
    const me = this, deprecatedEvents = me.$meta.getInherited("deprecatedEvents");
    if (typeof config === "string") {
      return me.addListener({
        [config]: thisObj,
        detachable: thisObj.detachable !== false,
        thisObj: oldThisObj
      });
    } else {
      thisObj = config.thisObj = config.thisObj !== void 0 ? config.thisObj : thisObj;
      for (const key in config) {
        if (!specialProperties[key] && config[key] != null) {
          const eventName = key.toLowerCase(), deprecatedEvent = deprecatedEvents == null ? void 0 : deprecatedEvents[eventName], events = me.eventListeners || (me.eventListeners = {}), listenerSpec = config[key], expires = listenerSpec.expires || config.expires, listener = {
            fn: typeof listenerSpec === "object" ? listenerSpec.fn : listenerSpec,
            thisObj: listenerSpec.thisObj !== void 0 ? listenerSpec.thisObj : thisObj,
            args: listenerSpec.args || config.args,
            prio: listenerSpec.prio !== void 0 ? listenerSpec.prio : config.prio !== void 0 ? config.prio : 0,
            once: listenerSpec.once !== void 0 ? listenerSpec.once : config.once !== void 0 ? config.once : false,
            buffer: listenerSpec.buffer || config.buffer,
            throttle: listenerSpec.throttle || config.throttle,
            $internal: config.$internal,
            catchAll: key === "catchAll"
          };
          if (deprecatedEvent) {
            const { product, invalidAsOfVersion, message } = deprecatedEvent;
            VersionHelper.deprecate(product, invalidAsOfVersion, message);
          }
          if (expires) {
            const { alt } = expires, delay3 = alt ? expires.delay : expires, name2 = config.name || key, fn2 = () => {
              me.un(eventName, listener);
              if (alt && !listener.called) {
                me.callback(alt, thisObj);
              }
            };
            if (me.isDelayable) {
              me.setTimeout({ fn: fn2, name: name2, cancelOutstanding: true, delay: delay3 });
            } else {
              globalThis.setTimeout(fn2, delay3);
            }
          }
          let listeners = events[eventName] || (events[eventName] = []);
          if (listeners.$firing) {
            events[eventName] = listeners = listeners.slice();
          }
          listeners.splice(
            ArrayHelper.findInsertionIndex(listener, listeners, priorityComparator, listeners.length),
            0,
            listener
          );
          if (!me.onListen.$nullFn && listeners.length < 2) {
            me.onListen(eventName);
          }
          (_a2 = me.afterAddListener) == null ? void 0 : _a2.call(me, eventName, listener);
        }
      }
      if (config.relayAll) {
        me.relayAll(config.relayAll);
      }
      if (thisObj && thisObj !== me) {
        me.attachAutoDetacher(config, thisObj);
      }
      const detachable = config.detachable !== false, name = config.name, destroy = config.expires || detachable || name ? () => {
        if (!me.isDestroyed) {
          me.removeListener(config, thisObj);
        }
      } : null;
      if (destroy) {
        destroy.eventer = me;
        destroy.listenerName = name;
        if (name && (thisObj == null ? void 0 : thisObj.trackDetacher)) {
          thisObj.trackDetacher(name, destroy);
        }
        if (config.expires) {
          me.delay(destroy, isNaN(config.expires) ? config.expires.delay : config.expires, name);
        }
        if (detachable) {
          return destroy;
        }
      }
    }
  }
  /**
   * Alias for {@link #function-addListener}. Adds an event listener. This method accepts parameters in the following format:
   *
   * ```javascript
   *  myObject.on({
   *      thisObj    : this,          // The this reference for the handlers
   *      eventname2 : 'functionName' // Resolved at invocation time using the thisObj,
   *      otherevent : {
   *          fn      : 'handlerFnName',
   *          once    : true          // Just this handler is auto-removed on fire
   *      },
   *      yetanother  : {
   *          fn      : 'yetAnotherHandler',
   *          args    : [ currentState1, currentState2 ] // Capture info to be passed to handler
   *      },
   *      prio        : 100           // Higher prio listeners are called before lower
   *  });
   * ```
   *
   * When listeners have a `thisObj` option, they are linked to the lifecycle of that object.
   * When it is destroyed, those listeners are removed.
   *
   * The `config` parameter allows supplying options for the listener(s), for available options see {@link #typedef-BryntumListenerConfig}.
   *
   * A simpler signature may be used when only adding a listener for one event and no extra options
   * (such as `once` or `delay`) are required:
   *
   * ```javascript
   * myObject.on('click', myController.handleClicks, myController);
   * ```
   *
   * The args in this simple case are `eventName`, `handler` and `thisObj`
   *
   * @param {BryntumListenerConfig|String} config An object containing listener definitions, or the event name to listen for
   * @param {Object|Function} [thisObj] Default `this` reference for all listeners in the config object, or the handler
   * function to call if providing a string as the first arg.
   * @param {Object} [oldThisObj] The `this` reference if the old signature starting with a string event name is used..
   * @returns {Function} Returns a detacher function unless configured with `detachable: false`. Call detacher to remove listeners
   */
  on(config, thisObj, oldThisObj) {
    return this.addListener(config, thisObj, oldThisObj);
  }
  /**
   * Internal convenience method for adding an internal listener, that cannot be removed by the user.
   *
   * Alias for `on({ $internal : true, ... })`. Only supports single argument form.
   *
   * @internal
   */
  ion(config) {
    config.$internal = true;
    return this.on(config);
  }
  /**
   * Shorthand for {@link #function-removeListener}
   * @param {Object|String} config A config object or the event name
   * @param {Object|Function} [thisObj] `this` reference for all listeners, or the listener function
   * @param {Object} [oldThisObj] `this` The `this` object for the legacy way of adding listeners
   */
  un(...args) {
    this.removeListener(...args);
  }
  updateInternalListeners(internalListeners, oldInternalListeners) {
    oldInternalListeners == null ? void 0 : oldInternalListeners.detach();
    if (internalListeners) {
      internalListeners.detach = this.ion(internalListeners);
    }
  }
  get listeners() {
    return this.eventListeners;
  }
  changeListeners(listeners) {
    if (this.isConfiguring) {
      this.getConfig("internalListeners");
      if (listeners) {
        this.on(listeners, this);
      }
    } else {
      if (Array.isArray(listeners)) {
        for (let i = 0, l = listeners[0], { length } = listeners; i < length; l = listeners[++i]) {
          if (!("thisObj" in l)) {
            listeners[i] = Objects.assign({ thisObj: this }, l);
          }
        }
      } else if (listeners && !("thisObj" in listeners)) {
        listeners = Objects.assign({ thisObj: this }, listeners);
      }
      return listeners;
    }
  }
  updateListeners(listeners, oldListeners) {
    oldListeners && this.un(oldListeners);
    listeners && this.on(listeners);
  }
  /**
   * Removes an event listener. Same API signature as {@link #function-addListener}
   * @param {Object|String} config A config object or the event name
   * @param {Object|Function} thisObj `this` reference for all listeners, or the listener function
   * @param {Object} oldThisObj `this` The `this` object for the legacy way of adding listeners
   */
  removeListener(config, thisObj = config.thisObj, oldThisObj) {
    const me = this;
    if (typeof config === "string") {
      return me.removeListener({ [config]: thisObj }, oldThisObj);
    }
    Object.entries(config).forEach(([eventName, listenerToRemove]) => {
      var _a2;
      if (!specialProperties[eventName] && listenerToRemove != null) {
        eventName = eventName.toLowerCase();
        const { eventListeners } = me, index = me.findListener(eventName, listenerToRemove, thisObj);
        if (index >= 0) {
          let listeners = eventListeners[eventName];
          (_a2 = me.afterRemoveListener) == null ? void 0 : _a2.call(me, eventName, listeners[index]);
          if (listeners.length > 1) {
            if (listeners.$firing) {
              eventListeners[eventName] = listeners = listeners.slice();
            }
            listeners.splice(index, 1);
          } else {
            delete eventListeners[eventName];
            if (!me.onUnlisten.$nullFn) {
              me.onUnlisten(eventName);
            }
          }
        }
      }
    });
    if (config.thisObj && !config.thisObj.isDestroyed) {
      me.detachAutoDetacher(config);
    }
  }
  /**
   * Finds the index of a particular listener to the named event. Returns `-1` if the passed
   * function/thisObj listener is not present.
   * @param {String} eventName The name of an event to find a listener for.
   * @param {String|Function} listenerToFind The handler function to find.
   * @param {Object} defaultThisObj The `thisObj` for the required listener.
   * @internal
   */
  findListener(eventName, listenerToFind, defaultThisObj) {
    var _a2;
    const eventListeners = (_a2 = this.eventListeners) == null ? void 0 : _a2[eventName], fn2 = listenerToFind.fn || listenerToFind, thisObj = listenerToFind.thisObj || defaultThisObj;
    if (eventListeners) {
      for (let listenerEntry, i = 0, { length } = eventListeners; i < length; i++) {
        listenerEntry = eventListeners[i];
        if (listenerEntry.fn === fn2 && listenerEntry.thisObj === thisObj) {
          return i;
        }
      }
    }
    return -1;
  }
  /**
   * Check if any listener is registered for the specified eventName
   * @param {String} eventName
   * @returns {Boolean} `true` if listener is registered, otherwise `false`
   * @advanced
   */
  hasListener(eventName) {
    var _a2;
    return Boolean((_a2 = this.eventListeners) == null ? void 0 : _a2[eventName == null ? void 0 : eventName.toLowerCase()]);
  }
  /**
   * Relays all events through another object that also implements Events mixin. Adds a prefix to the event name
   * before relaying, for example add -> storeAdd
   * ```
   * // Relay all events from store through grid, will make it possible to listen for store events prefixed on grid:
   * 'storeLoad', 'storeChange', 'storeRemoveAll' etc.
   * store.relayAll(grid, 'store');
   *
   * grid.on('storeLoad', () => console.log('Store loaded');
   * ```
   * @param {Core.mixin.Events} through Object to relay the events through, needs to mix Events mixin in
   * @param {String} prefix Prefix to add to event name
   * @param {Boolean} [transformCase] Specify false to prevent making first letter of event name uppercase
   * @advanced
   */
  relayAll(through, prefix, transformCase = true) {
    if (!this.relayAllTargets) {
      this.relayAllTargets = [];
    }
    const { relayAllTargets } = this;
    through.ion({
      beforeDestroy: ({ source }) => {
        if (source === through) {
          const configs = relayAllTargets.filter((r) => r.through === through);
          configs.forEach((config) => ArrayHelper.remove(relayAllTargets, config));
        }
      }
    });
    relayAllTargets.push({ through, prefix, transformCase });
  }
  /**
   * Removes all listeners registered to this object by the application.
   */
  removeAllListeners(preserveInternal = true) {
    var _a2;
    const listeners = this.eventListeners;
    let i, thisObj;
    for (const event in listeners) {
      const bucket2 = listeners[event];
      for (i = bucket2.length; i-- > 0; ) {
        const cfg = bucket2[i];
        if (!cfg.$internal || !preserveInternal) {
          this.removeListener(event, cfg);
          thisObj = cfg.thisObj;
          (_a2 = thisObj == null ? void 0 : thisObj.untrackDetachers) == null ? void 0 : _a2.call(thisObj, this);
        }
      }
    }
  }
  relayEvents(source, eventNames, prefix = "") {
    const listenerConfig = { detachable: true, thisObj: this };
    eventNames.forEach((eventName) => {
      listenerConfig[eventName] = (event, ...params) => {
        return this.trigger(prefix + eventName, event, ...params);
      };
    });
    return source.on(listenerConfig);
  }
  /**
   * This method is called when the first listener for an event is added.
   * @param {String} eventName
   * @internal
   */
  onListen() {
  }
  /**
   * This method is called when the last listener for an event is removed.
   * @param {String} eventName
   * @internal
   */
  onUnlisten() {
  }
  destructorInterceptor() {
    const { autoDetachers, target, oldDestructor } = this;
    for (let i = 0; i < autoDetachers.length; i++) {
      const { dispatcher, config } = autoDetachers[i];
      if (!dispatcher.isDestroyed) {
        dispatcher.removeListener(config, target);
      }
    }
    oldDestructor.call(target);
  }
  /**
   * Internal function used to hook destroy() calls when using thisObj
   * @private
   */
  attachAutoDetacher(config, thisObj) {
    const target = config.thisObj || thisObj, destructorName = "doDestroy" in target ? "doDestroy" : "destroy";
    if (destructorName in target) {
      let { $autoDetachers } = target;
      if (!$autoDetachers) {
        target.$autoDetachers = $autoDetachers = [];
      }
      if (!target.$oldDestructor) {
        target.$oldDestructor = target[destructorName];
        target[destructorName] = this.destructorInterceptor.bind({
          autoDetachers: $autoDetachers,
          oldDestructor: target.$oldDestructor,
          target
        });
      }
      $autoDetachers.push({ config, dispatcher: this });
    } else {
      target[destructorName] = () => {
        this.removeListener(config);
      };
    }
  }
  /**
   * Internal function used restore hooked destroy() calls when using thisObj
   * @private
   */
  detachAutoDetacher(config) {
    const target = config.thisObj;
    if (target.$oldDestructor && !target.isDestroying) {
      ArrayHelper.remove(
        target.$autoDetachers,
        target.$autoDetachers.find((detacher) => detacher.config === config && detacher.dispatcher === this)
      );
      if (!target.$autoDetachers.length) {
        target["doDestroy" in target ? "doDestroy" : "destroy"] = target.$oldDestructor;
        target.$oldDestructor = null;
      }
    }
  }
  //endregion
  //region Promise based workflow
  // experimental, used in tests to support async/await workflow
  await(eventName, options = { checkLog: true, resetLog: true, args: null }) {
    const me = this;
    if (options === false) {
      options = { checkLog: false };
    }
    const { args } = options;
    return new Promise((resolve) => {
      var _a2;
      if (options.checkLog && ((_a2 = me._triggered) == null ? void 0 : _a2[eventName])) {
        resolve();
        if (options.resetLog) {
          me.clearLog(eventName);
        }
      }
      if (args) {
        const detacher = me.on({
          [eventName]: (...params) => {
            const argsOk = typeof args === "function" ? args(...params) : Object.keys(args).every((key) => {
              return key in params[0] && params[0][key] === args[key];
            });
            if (argsOk) {
              resolve(...params);
              if (options.resetLog) {
                me.clearLog(eventName);
              }
              detacher();
            }
          },
          prio: -1e4
          // Let others do their stuff first
        });
      } else {
        me.on({
          [eventName]: (...params) => {
            resolve(...params);
            if (options.resetLog) {
              me.clearLog(eventName);
            }
          },
          prio: -1e4,
          // Let others do their stuff first
          once: true
          // promises can only be resolved once anyway
        });
      }
    });
  }
  clearLog(eventName) {
    if (this._triggered) {
      if (eventName) {
        delete this._triggered[eventName];
      } else {
        this._triggered = {};
      }
    }
  }
  //endregion
  //region Trigger
  /**
   * Triggers an event, calling all registered listeners with the supplied arguments. Returning false from any listener
   * makes function return false.
   * @param {String} eventName Event name for which to trigger listeners
   * @param {Object} [param] Single parameter passed on to listeners, source property will be added to it (this)
   * @param {Boolean} [param.bubbles] Pass as `true` to indicate that the event will bubble up the widget
   * ownership hierarchy. For example up a `Menu`->`parent` Menu tree, or a `Field`->`Container` tree.
   * @typings param -> {{bubbles?: boolean, [key: string]: any}}
   * @returns {Boolean|Promise} Returns false if any listener returned `false`, or a `Promise` yielding
   * `true` / `false` based on what is returned from the async listener functions, otherwise `true`
   * @async
   * @advanced
   */
  trigger(eventName, param) {
    var _a2, _b, _c, _d;
    const me = this, name = eventName.toLowerCase(), {
      eventsSuspended,
      relayAllTargets,
      callOnFunctions
    } = me;
    let listeners = (_a2 = me.eventListeners) == null ? void 0 : _a2[name], handlerPromises;
    if (!me._triggered) {
      me._triggered = {};
    }
    me._triggered[eventName] = true;
    if (eventsSuspended) {
      if (eventsSuspended.shouldQueue) {
        eventsSuspended.queue.push(arguments);
      }
      return true;
    }
    if ((_b = me.eventListeners) == null ? void 0 : _b.catchall) {
      (listeners = listeners ? listeners.slice() : []).push(...me.eventListeners.catchall);
      listeners.sort(priorityComparator);
    }
    if (!listeners && !relayAllTargets && !callOnFunctions) {
      return true;
    }
    if (param) {
      if (!("source" in param)) {
        if (Object.isExtensible(param)) {
          param.source = me;
        } else {
          param = Object.setPrototypeOf({
            source: me
          }, param);
        }
      }
    } else {
      param = {
        source: me
      };
    }
    if (param.type !== name) {
      if (param.constructor !== Object) {
        Reflect.defineProperty(param, "type", { get: () => name });
      } else {
        param.type = name;
      }
    }
    param.eventName = eventName;
    if (!("bubbles" in param) && ((_c = me.bubbleEvents) == null ? void 0 : _c[eventName])) {
      param.bubbles = me.bubbleEvents[eventName];
    }
    if (callOnFunctions) {
      const fnName = "on" + StringHelper.capitalize(eventName);
      if (fnName in me) {
        const result = me[fnName] ? me.callback(me[fnName], me, [param]) : true;
        let inhibit;
        if (Objects.isPromise(result)) {
          (handlerPromises || (handlerPromises = [])).push(result);
        } else {
          inhibit = result === false || inhibit;
        }
        if (!me.isDestroyed && hasOwnProperty4.call(me, fnName) && !((_d = me.pluginFunctionChain) == null ? void 0 : _d[fnName])) {
          const myProto = Object.getPrototypeOf(me);
          if (fnName in myProto) {
            const result2 = myProto[fnName].call(me, param);
            if (Objects.isPromise(result2)) {
              (handlerPromises || (handlerPromises = [])).push(result2);
            } else {
              inhibit = result2 === false || inhibit;
            }
            if (me.isDestroyed) {
              return;
            }
          }
        }
        if (inhibit) {
          return false;
        }
      }
    }
    let ret;
    if (listeners) {
      let i = 0, internalAbort = false;
      listeners.$firing = true;
      for (i; i < listeners.length && !me.isDestroyed && !internalAbort; i++) {
        const listener = listeners[i];
        if (ret === false && !listener.$internal) {
          continue;
        }
        let handler, thisObj = listener.thisObj;
        if (!thisObj || !thisObj.isDestroyed) {
          listener.called = true;
          if (listener.once) {
            me.removeListener(name, listener);
          }
          if (typeof listener.fn === "string") {
            if (thisObj) {
              handler = thisObj[listener.fn];
            }
            if (!handler) {
              const result2 = me.resolveCallback(listener.fn);
              handler = result2.handler;
              thisObj = result2.thisObj;
            }
          } else {
            handler = listener.fn;
          }
          if (listener.buffer) {
            if (!listener.bufferFn) {
              const buffer = Number(listener.buffer);
              if (typeof buffer !== "number" || isNaN(buffer)) {
                throw new Error(`Incorrect type for buffer, got "${buffer}" (expected a Number)`);
              }
              listener.bufferFn = FunctionHelper.createBuffered(handler, buffer, thisObj, listener.args);
            }
            handler = listener.bufferFn;
          }
          if (listener.throttle) {
            const throttle = Number(listener.throttle);
            if (typeof throttle !== "number" || isNaN(throttle)) {
              throw new Error(`Incorrect type for throttle, got "${throttle}" (expected a Number)`);
            }
            if (!listener.throttledFn) {
              listener.throttledFn = FunctionHelper.createThrottled(handler, throttle, thisObj, listener.args);
            }
            handler = listener.throttledFn;
          }
          const result = handler.call(thisObj || me, ...listener.args || [], param);
          if (ret !== false) {
            ret = result;
          }
          if (listener.$internal && result === false) {
            internalAbort = true;
          }
          if (Objects.isPromise(result)) {
            result.$internal = listener.$internal;
            (handlerPromises || (handlerPromises = [])).push(result);
          }
        }
      }
      listeners.$firing = false;
      if (internalAbort) {
        return false;
      }
    }
    relayAllTargets == null ? void 0 : relayAllTargets.forEach((config) => {
      let name2 = eventName;
      if (config.transformCase) {
        name2 = StringHelper.capitalize(name2);
      }
      if (config.prefix) {
        name2 = config.prefix + name2;
      }
      if (config.through.trigger(name2, param) === false) {
        return false;
      }
    });
    if (param.bubbles && me.owner && !me.owner.isDestroyed) {
      return me.owner.trigger(eventName, param);
    }
    handlerPromises = handlerPromises == null ? void 0 : handlerPromises.filter((p) => ret !== false || p.$internal);
    if (handlerPromises == null ? void 0 : handlerPromises.length) {
      return new Promise((resolve) => {
        Promise.all(handlerPromises).then((promiseResults) => {
          const finalResult = !promiseResults.some((result) => result === false);
          resolve(finalResult);
        });
      });
    }
    return ret !== false;
  }
  /**
   * Prevents events from being triggered until {@link #function-resumeEvents()} is called. Optionally queues events that are triggered while
   * suspended. Multiple calls stack to require matching calls to `resumeEvents()` before actually resuming.
   * @param {Boolean} queue Specify true to queue events triggered while suspended
   * @advanced
   */
  suspendEvents(queue = false) {
    const eventsSuspended = this.eventsSuspended || (this.eventsSuspended = { shouldQueue: queue, queue: [], count: 0 });
    eventsSuspended.count++;
  }
  /**
   * Resume event triggering after a call to {@link #function-suspendEvents()}. If any triggered events were queued they will be triggered.
   * @returns {Boolean} `true` if events have been resumed (multiple calls to suspend require an equal number of resume calls to resume).
   * @advanced
   */
  resumeEvents() {
    const suspended = this.eventsSuspended;
    if (suspended) {
      if (--suspended.count === 0) {
        this.eventsSuspended = null;
        if (suspended.shouldQueue) {
          for (const queued of suspended.queue) {
            this.trigger(...queued);
          }
        }
      }
    }
    return !Boolean(this.eventsSuspended);
  }
  //endregion
};

// ../Core/lib/Core/localization/LocaleHelper.js
var _LocaleHelper = class {
  /**
   * Merges all properties of provided locale objects into new locale object.
   * Locales are merged in order they provided and locales which go later replace
   * same properties of previous locales.
   * @param {...Object} locales Locales to merge
   * @returns {Object} Merged locale
   */
  static mergeLocales(...locales) {
    const result = {};
    locales.forEach((locale4) => {
      Object.keys(locale4).forEach((key) => {
        if (typeof locale4[key] === "object") {
          result[key] = { ...result[key], ...locale4[key] };
        } else {
          result[key] = locale4[key];
        }
      });
    });
    return result;
  }
  /**
   * Removes all properties from `locale` that are present in the provided `toTrim`.
   * @param {Object} locale Locale to process
   * @param {Object} toTrim Object enumerating properties that should be removed.
   * When `false` throws exceptions in such cases.
   */
  static trimLocale(locale4, toTrim) {
    const remove = (key, subKey) => {
      if (locale4[key]) {
        if (subKey) {
          if (locale4[key][subKey]) {
            delete locale4[key][subKey];
          }
        } else {
          delete locale4[key];
        }
      }
    };
    Object.keys(toTrim).forEach((key) => {
      if (Object.keys(toTrim[key]).length > 0) {
        Object.keys(toTrim[key]).forEach((subKey) => remove(key, subKey));
      } else {
        remove(key);
      }
    });
  }
  /**
   * Normalizes locale object to {@link Locale} type.
   *
   * Supported configs:
   *
   * ```javascript
   * LocaleHelper.normalizeLocale({
   *     localeName : 'En',
   *     localeDesc : 'English (US)',
   *     localeCode : 'en-US',
   *     ... (localization key:value pairs)
   * });
   * ```
   *
   * and for backward compatibility
   *
   * ```javascript
   * LocaleHelper.normalizeLocale('En', {
   *     name : 'En',
   *     desc : 'English (US)',
   *     code : 'en-US',
   *     locale : {
   *         ... (localization key:value pairs)
   *     }
   * });
   * ```
   * @param {String|Object} nameOrConfig String name of locale or locale object
   * @param {Object} [config] Locale object
   * @returns {Locale} Locale object
   * @internal
   */
  static normalizeLocale(nameOrConfig, config) {
    if (!nameOrConfig) {
      throw new Error(`"nameOrConfig" parameter can not be empty`);
    }
    if (typeof nameOrConfig === "string") {
      if (!config) {
        throw new Error(`"config" parameter can not be empty`);
      }
      if (config.locale) {
        config.name = nameOrConfig || config.name;
      } else {
        config.localeName = nameOrConfig;
      }
    } else {
      config = nameOrConfig;
    }
    let locale4 = {};
    if (config.name || config.locale) {
      locale4 = Object.assign({
        localeName: config.name
      }, config.locale);
      config.desc && (locale4.localeDesc = config.desc);
      config.code && (locale4.localeCode = config.code);
      config.path && (locale4.localePath = config.path);
    } else {
      if (!config.localeName) {
        throw new Error(`"config" parameter doesn't have "localeName" property`);
      }
      locale4 = Object.assign({}, config);
    }
    for (const key of ["name", "desc", "code", "path"]) {
      if (locale4[key]) {
        delete locale4[key];
      }
    }
    if (!locale4.localeName) {
      throw new Error(`Locale name can not be empty`);
    }
    return locale4;
  }
  /**
   * Get/set currently published locales.
   * Returns an object with locales.
   *
   * Example:
   *
   * ```javascript
   * const englishLocale = LocaleHelper.locales.En;
   * ```
   *
   * `englishLocale` contains {@link Locale} object.
   *
   * @readonly
   * @member {Locales} locales
   * @static
   */
  static get locales() {
    return globalThis.bryntum.locales || {};
  }
  static set locales(locales) {
    globalThis.bryntum.locales = locales;
  }
  /**
   * Get/set current locale name. Defaults to "En"
   * @member {String} localeName
   * @static
   */
  static get localeName() {
    return globalThis.bryntum.locale || "En";
  }
  static set localeName(localeName) {
    globalThis.bryntum.locale = localeName || _LocaleHelper.localeName;
  }
  /**
   * Get current locale config specified by {@link ##property-localeName-static}.
   * If no current locale specified, returns default `En` locale or first published locale
   * or empty locale object if no published locales found.
   * @readonly
   * @member {Locales} locale
   * @static
   */
  static get locale() {
    return _LocaleHelper.localeName && this.locales[_LocaleHelper.localeName] || this.locales.En || Object.values(this.locales)[0] || { localeName: "", localeDesc: "", localeCoode: "" };
  }
  /**
   * Publishes a locale to make it available for applying.
   * Published locales are available in {@link ##property-locales-static}.
   *
   * Recommended usage:
   *
   * ```javascript
   * LocaleHelper.publishLocale({
   *     localeName : 'En',
   *     localeDesc : 'English (US)',
   *     localeCode : 'en-US',
   *     ... (localization key:value pairs)
   * });
   * ```
   *
   * for backward compatibility (prior to `5.3.0` version):
   *
   * ```javascript
   * LocaleHelper.publishLocale('En', {
   *     name : 'En',
   *     desc : 'English (US)',
   *     code : 'en-US',
   *     locale : {
   *         ... (localization key:value pairs)
   *     }
   * });
   * ```
   *
   * Publishing a locale will automatically merge it's localization keys with existing locale matching by locale name,
   * replacing existing one with new. To replace existing locale entirely pass `true` to optional `config` parameter.
   *
   * Example:
   *
   * ```javascript
   * LocaleHelper.publishLocale({
   *     localeName : 'En',
   *     localeDesc : 'English (US)',
   *     localeCode : 'en-US',
   *     ... (localization key:value pairs)
   * }, true);
   * ```
   *
   * @param {String|Locale} nameOrConfig String name of locale (for example `En` or `SvSE`) or locale object
   * @param {Locale|Boolean} [config] Locale object.
   * Not used if locale object is passed as first method parameter.
   * Path `true` value and locale object as first method parameter to publish locale without merging with existing one.
   * @returns {Locale} Locale object
   */
  static publishLocale(nameOrConfig, config) {
    const { locales } = globalThis.bryntum, locale4 = _LocaleHelper.normalizeLocale(nameOrConfig, config), { localeName } = locale4;
    if (!locales[localeName] || config === true) {
      locales[localeName] = locale4;
    } else {
      locales[localeName] = this.mergeLocales(locales[localeName] || {}, locale4 || {});
    }
    return locales[localeName];
  }
};
var LocaleHelper = _LocaleHelper;
__publicField(LocaleHelper, "skipLocaleIntegrityCheck", false);
globalThis.bryntum = globalThis.bryntum || {};
globalThis.bryntum.locales = globalThis.bryntum.locales || {};
LocaleHelper._$name = "LocaleHelper";

// ../Core/lib/Core/localization/LocaleManager.js
var LocaleManager = class extends Events_default(Base2) {
  static get defaultConfig() {
    return {
      // Enable strict locale checking by default for tests
      throwOnMissingLocale: VersionHelper.isTestEnv
    };
  }
  construct(...args) {
    var _a2;
    const me = this;
    super.construct(...args);
    if (BrowserHelper.isBrowserEnv) {
      const scriptTag = document.querySelector("script[data-default-locale]");
      if (scriptTag) {
        me.applyLocale(scriptTag.dataset.defaultLocale);
      } else if ((_a2 = me.locale) == null ? void 0 : _a2.localeName) {
        me.applyLocale(me.locale.localeName);
      }
    }
  }
  /**
   * Get/set currently registered locales.
   * Alias for {@link Core.localization.LocaleHelper#property-locales-static LocaleHelper.locales}.
   * @readonly
   * @member {Locales} locales
   */
  get locales() {
    return LocaleHelper.locales;
  }
  set locales(locales) {
    LocaleHelper.locales = locales;
  }
  /**
   * Get/set currently used locale.
   * Setter calls {@link #function-applyLocale}.
   * @member {Locales} locale
   * @accepts {String|Locale}
   */
  set locale(nameOrConfig) {
    this.applyLocale(nameOrConfig);
  }
  get locale() {
    return LocaleHelper.locale;
  }
  /**
   * Publishes a locale to make it available for applying.
   * @deprecated Since 5.3.0. Use {@link Core.localization.LocaleHelper#function-publishLocale-static LocaleHelper.publishLocale} instead.
   *
   * @param {String|Locale} nameOrConfig String name of locale (for example `En` or `SvSE`) or locale object.
   * @param {Locale} [config] Locale object. Not used if object is passed as first method parameter
   * @returns {Locale} published locale object is passed as first method parameter
   * @function registerLocale
   */
  registerLocale(nameOrConfig, config) {
    VersionHelper.deprecate("Core", "6.0.0", "LocaleManager.registerLocale deprecated, use LocaleHelper.publishLocale instead");
    LocaleHelper.publishLocale(nameOrConfig, config);
  }
  /**
   * Extends locale specified by name to add additional translations and applies it.
   * @deprecated Since 5.3.0. Use {@link ##function-applyLocale} instead.
   *
   * @param {String} name Name of locale (for example `En` or `SvSE`).
   * @param {Locale} config Locale object
   * @returns {Locale|Promise} locale object or Promise which resolves with locale object after it was loaded
   * @function extendLocale
   */
  extendLocale(name, config) {
    VersionHelper.deprecate("Core", "6.0.0", "LocaleManager.extendLocale deprecated, use LocaleManager.applyLocale instead");
    const locale4 = LocaleHelper.publishLocale(name, config);
    return this.applyLocale(locale4, true);
  }
  /**
   * Applies a locale by string name or publishes new locale configuration with
   * {@link Core.localization.LocaleHelper#function-publishLocale-static} and applies it.
   * If locale is specified by string name, like 'En', it must be published before applying it.
   *
   * @param {String|Locale} nameOrConfig String name of locale (for example `En` or `SvSE`) or locale object
   * @param {Locale|Boolean} [config] Locale object. Pass `true` to reapply locale which is passed as first method parameter.
   * @returns {Locale|Promise} locale object or Promise which resolves with locale object after it was loaded
   * @fires locale
   * @async
   * @function applyLocale
   */
  applyLocale(nameOrConfig, config, ignoreError = false) {
    const me = this;
    let localeConfig;
    if (typeof nameOrConfig === "string") {
      if (typeof config !== "object") {
        localeConfig = me.locales[nameOrConfig];
        if (!localeConfig) {
          if (ignoreError) {
            return true;
          }
          throw new Error(`Locale "${nameOrConfig}" is not published. Publish with LocaleHelper.publishLocale() before applying.`);
        }
      } else {
        localeConfig = LocaleHelper.publishLocale(nameOrConfig, config);
      }
    } else {
      localeConfig = LocaleHelper.publishLocale(nameOrConfig);
    }
    if (me.locale.localeName && me.locale.localeName === localeConfig.localeName && config !== true) {
      return me.locale;
    }
    LocaleHelper.localeName = localeConfig.localeName;
    const triggerLocaleEvent = () => {
      me.trigger("locale", localeConfig);
    };
    if (localeConfig.localePath) {
      return new Promise((resolve, reject) => {
        me.loadLocale(localeConfig.localePath).then((response) => {
          response.text().then((text) => {
            const parseLocale = new Function(text);
            parseLocale();
            if (BrowserHelper.isBrowserEnv) {
              localeConfig = me.locales[localeConfig.localeName];
              if (localeConfig) {
                delete localeConfig.localePath;
              }
            }
            triggerLocaleEvent();
            resolve(localeConfig);
          });
        }).catch((response) => reject(response));
      });
    }
    triggerLocaleEvent();
    return localeConfig;
  }
  /**
   * Loads a locale using AjaxHelper {@link Core.helper.AjaxHelper#function-get-static} request.
   * @private
   * @param {String} path Path to locale file
   * @async
   */
  loadLocale(path) {
    return AjaxHelper.get(path);
  }
  /**
   * Specifies if {@link Core.localization.Localizable#function-L-static Localizable.L()} function would throw error if no localization found at runtime.
   *
   * @member {Boolean} throwOnMissingLocale
   * @default false
   */
  set throwOnMissingLocale(value) {
    this._throwOnMissingLocale = value;
  }
  get throwOnMissingLocale() {
    return this._throwOnMissingLocale;
  }
};
var LocaleManagerSingleton = new LocaleManager();
var LocaleManager_default = LocaleManagerSingleton;

// ../Core/lib/Core/localization/Localizable.js
var ObjectProto = Object.getPrototypeOf(Object);
var localeRe = /L{.*?}/g;
var capturelocaleRe = /L{(.*?)}/g;
var classMatchRe = /((.*?)\.)?(.+)/g;
var escape2 = (txt) => txt.replace(/{(\d+)}/gm, "[[$1]]");
var unescape = (txt) => txt.replace(/\[\[(\d+)]]/gm, "{$1}");
var emptyObject3 = Object.freeze(/* @__PURE__ */ Object.create(null));
var Localizable_default = (Target) => class Localizable extends (Target || Base2) {
  static get $name() {
    return "Localizable";
  }
  static get configurable() {
    return {
      /**
       * A class translations of which are used for translating this entity.
       * This is often used when translations of an item are defined on its container class.
       * For example:
       *
       * ```js
       * // Toolbar class that has some predefined items
       * class MyToolbar extends Toolbar {
       *
       *     static get $name() {
       *         return 'MyToolbar';
       *     }
       *
       *     static get defaultConfig() {
       *         return {
       *             // this specifies default configs for the items
       *             defaults : {
       *                 // will tell items to use the toolbar locale
       *                 localeClass : this
       *             },
       *
       *             items : [
       *                 // The toolbar has 2 buttons and translation for their texts will be searched in
       *                 // the toolbar locales
       *                 { text : 'Agree' },
       *                 { text : 'Disagree' }
       *             ]
       *         };
       *     }
       *
       *    ...
       * }
       * ```
       * So if one makes a locale for the `MyToolbar` class that will include `Agree` and `Disagree` string translations:
       * ```js
       *     ...
       *     MyToolbar : {
       *         Agree    : 'Yes, I agree',
       *         Disagree : 'No, I do not agree'
       *     }
       * ```
       * They will be used for the toolbar buttons and the button captions will say `Yes, I agree` and `No, I do not agree`.
       *
       * @config {Core.Base}
       * @typings {typeof Base}
       * @category Misc
       * @advanced
       */
      localeClass: null,
      /**
       * Set to `false` to disable localization of this object.
       * @config {Boolean}
       * @default true
       * @category Misc
       * @advanced
       */
      localizable: null,
      /**
       * List of properties which values should be translated automatically upon a locale applying.
       * In case there is a need to localize not typical value (not a String value or a field with re-defined setter/getter),
       * you could use 'localeKey' meta configuration.
       * Example:
       * ```js
       *  static get configurable() {
       *     return {
       *          localizableProperties : ['width'],
       *
       *          width : {
       *              value   : '54em', // default value here
       *              $config : {
       *                  localeKey : 'L{editorWidth}' // name of the property that will be used in localization file
       *              }
       *          }
       *      };
       *  }
       * ```
       * @config {String[]}
       * @category Misc
       * @advanced
       */
      localizableProperties: {
        value: [],
        $config: {
          merge: "distinct"
        }
      }
    };
  }
  static clsName(cls) {
    var _a2, _b;
    return typeof cls === "string" ? cls : cls === ObjectProto ? "Object" : cls.$$name || cls.name || ((_a2 = cls.prototype) == null ? void 0 : _a2.$$name) || ((_b = cls.prototype) == null ? void 0 : _b.name);
  }
  static parseLocaleString(text) {
    const matches = [];
    let m;
    if (text == null ? void 0 : text.includes("L{")) {
      text = escape2(text);
      capturelocaleRe.lastIndex = 0;
      while ((m = capturelocaleRe.exec(text)) != null) {
        classMatchRe.lastIndex = 0;
        const classMatch = classMatchRe.exec(m[1]);
        matches.push({
          match: unescape(m[0]),
          localeKey: unescape(classMatch[3]),
          localeClass: classMatch[2]
        });
      }
    }
    return matches.length > 0 ? matches : [{
      match: text,
      localeKey: text,
      localeClass: void 0
    }];
  }
  construct(config = {}, ...args) {
    super.construct(config, ...args);
    LocaleManager_default.ion({ locale: "updateLocalization", thisObj: this });
    this.updateLocalization();
  }
  get localeClass() {
    return this._localeClass || null;
  }
  localizeProperty(property) {
    var _a2, _b, _c;
    const me = this, currentValue = Objects.getPath(me, property), localeKey = ((_a2 = me.$meta.configs[property]) == null ? void 0 : _a2.localeKey) || ((_c = (_b = me.fieldMap) == null ? void 0 : _b[property]) == null ? void 0 : _c.defaultValue);
    let localizedValue;
    if (localeKey) {
      localizedValue = Localizable.localize(localeKey, me, me.localeClass || me);
      if (localizedValue && !(property in (me.initialConfig || emptyObject3))) {
        Objects.setPath(me.isColumn ? me.data : me, property, localizedValue);
      }
    } else if (typeof currentValue === "string") {
      me.originalLocales = me.originalLocales || {};
      localizedValue = Objects.getPath(me.originalLocales, property);
      if (localizedValue === void 0) {
        Objects.setPath(me.originalLocales, property, currentValue);
        localizedValue = currentValue;
      }
      if (localizedValue) {
        Objects.setPath(me, property, localizedValue = me.optionalL(localizedValue, me));
      }
    }
    return localizedValue || currentValue;
  }
  /**
   * Method that is triggered when applying a locale to the instance
   * (happens on the instance construction steps and when switching to another locale).
   *
   * The method can be overridden to dynamically translate the instance when locale is switched.
   * When overriding the method please make sure you call `super.updateLocalization()`.
   * @category Misc
   * @advanced
   */
  updateLocalization() {
    var _a2, _b;
    if (this.localizable !== false) {
      (_a2 = this.localizableProperties) == null ? void 0 : _a2.forEach(this.localizeProperty, this);
      (_b = this.trigger) == null ? void 0 : _b.call(this, "localized");
    }
  }
  static getTranslation(text, templateData, localeCls) {
    const locale4 = LocaleManager_default.locale;
    let result = null, clsName, cls;
    if (locale4) {
      for (const { match, localeKey, localeClass } of this.parseLocaleString(text)) {
        const translate = (clsName2) => {
          var _a2;
          const translation = (_a2 = locale4[clsName2]) == null ? void 0 : _a2[localeKey];
          if (translation) {
            if (typeof translation === "function") {
              result = templateData != null ? translation(templateData) : translation;
            } else if (typeof translation === "object" || text === match) {
              result = translation;
            } else {
              result = (result || text).replace(match, translation);
            }
            if (typeof translation === "string" && translation.includes("L{")) {
              result = this.getTranslation(translation, templateData, localeCls);
            }
          }
          return translation;
        };
        let success = false;
        for (cls = localeCls; cls && (clsName = Localizable.clsName(cls)); cls = Object.getPrototypeOf(cls)) {
          if (success = translate(clsName)) {
            break;
          } else if (typeof cls === "string") {
            break;
          }
        }
        if (!success && localeClass) {
          translate(localeClass);
        }
      }
    }
    return result;
  }
  /**
   * Get localized string, returns `null` if no localized string found.
   * @param {String} text String key
   * @param {Object} [templateData] Data to supply to template if localized string is a function
   * @returns {String}
   * @internal
   */
  static localize(text, templateData = void 0, ...localeClasses) {
    if ((localeClasses == null ? void 0 : localeClasses.length) === 0) {
      localeClasses = [this];
    }
    let translation = null;
    localeClasses.some((cls) => {
      translation = Localizable.getTranslation(text, templateData, cls);
      return translation != null;
    });
    return translation;
  }
  /**
   * Get localized string, returns value of `text` if no localized string found.
   *
   * If {@link Core.localization.LocaleManager#property-throwOnMissingLocale LocaleManager.throwOnMissingLocale}
   * is `true` then calls to `L()` will throw `Localization is not found for 'text' in 'ClassName'` exception when no
   * localization is found.
   *
   * @param {String} text String key
   * @param {Object} [templateData] Data to supply to template if localized string is a function
   * @static
   * @returns {String}
   * @advanced
   */
  static L(text, templateData = void 0, ...localeClasses) {
    if ((localeClasses == null ? void 0 : localeClasses.length) === 0) {
      localeClasses = [this];
    }
    const translation = this.localize(text, templateData, ...localeClasses);
    if (translation == null && LocaleManager_default.throwOnMissingLocale && text.includes("L{")) {
      throw new Error(`Localization is not found for '${text}' in '${localeClasses.map((cls) => Localizable.clsName(cls)).join(", ")}'. ${LocaleManager_default.locale.localeName ? `Locale : ${LocaleManager_default.locale.localeName}` : ""}`);
    }
    return translation != null ? translation : text;
  }
  /**
   * Convenience function that can be called directly on the class that mixes Localizable in
   *
   * ```javascript
   * button.text = grid.L('L{group}');
   * ```
   *
   * @param {String} text String key
   * @param {Object} [templateData] Data to supply to template if localized string is a function
   * @returns {String}
   * @category Misc
   * @advanced
   */
  L(text, templateData) {
    const { localeClass, constructor } = this;
    if (localeClass && Localizable.clsName(localeClass) !== Localizable.clsName(constructor)) {
      return Localizable.L(text, templateData, localeClass, constructor);
    } else {
      return Localizable.L(text, templateData, constructor);
    }
  }
  /**
   * Convenience function to get an optional translation. The difference compared to `L()` is that it won't throw
   * an error when the translation is missing even if configured with `throwOnMissingLocale`
   *
   * ```javascript
   * button.text = grid.optionalL('L{group}');
   * ```
   *
   * @param {String} text String key
   * @param {Object} [templateData] Data to supply to template if localized string is a function
   * @returns {String}
   * @static
   * @category Misc
   * @advanced
   */
  static optionalL(text, templateData = void 0, ...localeClasses) {
    const shouldThrow = LocaleManager_default.throwOnMissingLocale;
    LocaleManager_default.throwOnMissingLocale = shouldThrow && localeRe.test(text);
    if ((localeClasses == null ? void 0 : localeClasses.length) === 0) {
      localeClasses = [this];
    }
    const result = Localizable.L(text, templateData, ...localeClasses);
    LocaleManager_default.throwOnMissingLocale = shouldThrow;
    return result;
  }
  /**
   * Convenience function to get an optional translation. The difference compared to `L()` is that it won't throw
   * an error when the translation is missing even if configured with `throwOnMissingLocale`
   *
   * ```javascript
   * button.text = grid.optionalL('L{group}');
   * ```
   *
   * @param {String} text String key
   * @param {Object} [templateData] Data to supply to template if localized string is a function
   * @param {Boolean} [preventThrow] Prevent throwing error even if localized text matches `L{foo}`
   * @returns {String}
   * @category Misc
   * @internal
   */
  optionalL(text, templateData = this, preventThrow = false) {
    const shouldThrow = LocaleManager_default.throwOnMissingLocale;
    LocaleManager_default.throwOnMissingLocale = shouldThrow && localeRe.test(text) && !preventThrow;
    const result = this.L(text, templateData);
    LocaleManager_default.throwOnMissingLocale = shouldThrow;
    return result;
  }
  /**
   * Get the global LocaleManager
   * @property {Core.localization.LocaleManager}
   * @typings {typeof LocaleManager}
   * @category Misc
   * @readonly
   * @advanced
   */
  get localeManager() {
    return LocaleManager_default;
  }
  /**
   * Get the global LocaleHelper
   * @property {Core.localization.LocaleHelper}
   * @typings {typeof LocaleHelper}
   * @category Misc
   * @readonly
   * @advanced
   */
  get localeHelper() {
    return LocaleHelper;
  }
};

// ../Core/lib/Core/localization/En.js
var locale = {
  localeName: "En",
  localeDesc: "English (US)",
  localeCode: "en-US",
  Object: {
    Yes: "Yes",
    No: "No",
    Cancel: "Cancel",
    Ok: "OK",
    Week: "Week"
  },
  ColorPicker: {
    noColor: "No color"
  },
  Combo: {
    noResults: "No results",
    recordNotCommitted: "Record could not be added",
    addNewValue: (value) => `Add ${value}`
  },
  FilePicker: {
    file: "File"
  },
  Field: {
    badInput: "Invalid field value",
    patternMismatch: "Value should match a specific pattern",
    rangeOverflow: (value) => `Value must be less than or equal to ${value.max}`,
    rangeUnderflow: (value) => `Value must be greater than or equal to ${value.min}`,
    stepMismatch: "Value should fit the step",
    tooLong: "Value should be shorter",
    tooShort: "Value should be longer",
    typeMismatch: "Value is required to be in a special format",
    valueMissing: "This field is required",
    invalidValue: "Invalid field value",
    minimumValueViolation: "Minimum value violation",
    maximumValueViolation: "Maximum value violation",
    fieldRequired: "This field is required",
    validateFilter: "Value must be selected from the list"
  },
  DateField: {
    invalidDate: "Invalid date input"
  },
  DatePicker: {
    gotoPrevYear: "Go to previous year",
    gotoPrevMonth: "Go to previous month",
    gotoNextMonth: "Go to next month",
    gotoNextYear: "Go to next year"
  },
  NumberFormat: {
    locale: "en-US",
    currency: "USD"
  },
  DurationField: {
    invalidUnit: "Invalid unit"
  },
  TimeField: {
    invalidTime: "Invalid time input"
  },
  TimePicker: {
    hour: "Hour",
    minute: "Minute",
    second: "Second"
  },
  List: {
    loading: "Loading...",
    selectAll: "Select All"
  },
  GridBase: {
    loadMask: "Loading...",
    syncMask: "Saving changes, please wait..."
  },
  PagingToolbar: {
    firstPage: "Go to first page",
    prevPage: "Go to previous page",
    page: "Page",
    nextPage: "Go to next page",
    lastPage: "Go to last page",
    reload: "Reload current page",
    noRecords: "No records to display",
    pageCountTemplate: (data) => `of ${data.lastPage}`,
    summaryTemplate: (data) => `Displaying records ${data.start} - ${data.end} of ${data.allCount}`
  },
  PanelCollapser: {
    Collapse: "Collapse",
    Expand: "Expand"
  },
  Popup: {
    close: "Close"
  },
  UndoRedo: {
    Undo: "Undo",
    Redo: "Redo",
    UndoLastAction: "Undo last action",
    RedoLastAction: "Redo last undone action",
    NoActions: "No items in the undo queue"
  },
  FieldFilterPicker: {
    equals: "equals",
    doesNotEqual: "does not equal",
    isEmpty: "empty",
    isNotEmpty: "not empty",
    contains: "contains",
    doesNotContain: "does not contain",
    startsWith: "starts with",
    endsWith: "ends with",
    isOneOf: "one of",
    isNotOneOf: "not one of",
    isGreaterThan: "greater than",
    isLessThan: "less than",
    isGreaterThanOrEqualTo: "greater than or equal to",
    isLessThanOrEqualTo: "less than or equal to",
    isBetween: "between",
    isNotBetween: "not between",
    isBefore: "before",
    isAfter: "after",
    isToday: "today",
    isTomorrow: "tomorrow",
    isYesterday: "yesterday",
    isThisWeek: "this week",
    isNextWeek: "next week",
    isLastWeek: "last week",
    isThisMonth: "this month",
    isNextMonth: "next month",
    isLastMonth: "last month",
    isThisYear: "this year",
    isNextYear: "next year",
    isLastYear: "last year",
    isYearToDate: "year to date",
    isTrue: "true",
    isFalse: "false",
    selectAProperty: "Select a property",
    selectAnOperator: "Select an operator",
    caseSensitive: "Case-sensitive",
    and: "and",
    dateFormat: "D/M/YY",
    selectOneOrMoreValues: "Select one or more values",
    enterAValue: "Enter a value",
    enterANumber: "Enter a number",
    selectADate: "Select a date"
  },
  FieldFilterPickerGroup: {
    addFilter: "Add filter"
  },
  DateHelper: {
    locale: "en-US",
    weekStartDay: 0,
    nonWorkingDays: {
      0: true,
      6: true
    },
    weekends: {
      0: true,
      6: true
    },
    unitNames: [
      { single: "millisecond", plural: "ms", abbrev: "ms" },
      { single: "second", plural: "seconds", abbrev: "s" },
      { single: "minute", plural: "minutes", abbrev: "min" },
      { single: "hour", plural: "hours", abbrev: "h" },
      { single: "day", plural: "days", abbrev: "d" },
      { single: "week", plural: "weeks", abbrev: "w" },
      { single: "month", plural: "months", abbrev: "mon" },
      { single: "quarter", plural: "quarters", abbrev: "q" },
      { single: "year", plural: "years", abbrev: "yr" },
      { single: "decade", plural: "decades", abbrev: "dec" }
    ],
    unitAbbreviations: [
      ["mil"],
      ["s", "sec"],
      ["m", "min"],
      ["h", "hr"],
      ["d"],
      ["w", "wk"],
      ["mo", "mon", "mnt"],
      ["q", "quar", "qrt"],
      ["y", "yr"],
      ["dec"]
    ],
    parsers: {
      L: "MM/DD/YYYY",
      LT: "HH:mm A",
      LTS: "HH:mm:ss A"
    },
    ordinalSuffix: (number) => {
      const hasSpecialCase = ["11", "12", "13"].find((n) => number.endsWith(n));
      let suffix = "th";
      if (!hasSpecialCase) {
        const lastDigit = number[number.length - 1];
        suffix = { 1: "st", 2: "nd", 3: "rd" }[lastDigit] || "th";
      }
      return number + suffix;
    }
  }
};
var En_default = LocaleHelper.publishLocale(locale);

// ../Core/lib/Core/helper/DateHelper.js
var { toString: toString3 } = Object.prototype;
var DATE_TYPE2 = toString3.call(/* @__PURE__ */ new Date());
var tempDate = /* @__PURE__ */ new Date();
var MS_PER_HOUR = 1e3 * 60 * 60;
var defaultValue = (value, defValue) => isNaN(value) || value == null ? defValue : value;
var rangeFormatPartRe = /([ES]){([^}]+)}/g;
var enOrdinalSuffix = (number) => {
  const hasSpecialCase = ["11", "12", "13"].find((n) => number.endsWith(n));
  let suffix = "th";
  if (!hasSpecialCase) {
    const lastDigit = number[number.length - 1];
    suffix = { 1: "st", 2: "nd", 3: "rd" }[lastDigit] || "th";
  }
  return number + suffix;
};
var useIntlFormat = (name, options, date) => {
  const formatter = intlFormatterCache[name] || (intlFormatterCache[name] = new Intl.DateTimeFormat(locale2, options));
  return formatter.format(date);
};
var formatTime = (name, options, date, isShort = false) => {
  let strTime = useIntlFormat(name, options, date);
  if (/am|pm/i.test(strTime)) {
    strTime = strTime.replace(/^0/, "");
    if (isShort) {
      strTime = strTime.replace(/:00/, "");
    }
  }
  return strTime;
};
var getDayDiff = (end, start) => Math.floor((end.getTime() - start.getTime() - (end.getTimezoneOffset() - start.getTimezoneOffset()) * validConversions.minute.millisecond) / validConversions.day.millisecond) + 1;
var normalizeDay = (day2) => day2 >= 0 ? day2 : day2 + 7;
var msRegExp = /([^\w])(S+)/gm;
var msReplacer = (match, g1) => g1 + "SSS";
var splitRegExp = /[:.\-/\s]/;
var locale2 = "en-US";
var ordinalSuffix = enOrdinalSuffix;
var formatCache = {};
var formatRedirects = {};
var intlFormatterCache = {};
var parserCache = {};
var redirectFormat = (format2) => {
  const intlConfig = intlFormatConfigs[format2];
  if (!intlConfig) {
    throw new Error("Only international formats should be used here");
  }
  if (formatRedirects[format2] !== void 0) {
    return formatRedirects[format2];
  }
  const intl = new Intl.DateTimeFormat(locale2, intlConfig), fmt = intl.formatToParts(new Date(2001, 1, 2, 3, 4, 5, 6)).map((part) => {
    const type = part.type, intlCfg = intlConfig[type];
    if (type === "literal") {
      return part.value.replace(/,/g, "");
    } else if (type === "day") {
      return intlCfg === "numeric" ? "D" : "DD";
    } else if (type === "month") {
      return intlCfg === "short" ? "MMM" : intlCfg === "long" ? "MMMM" : intlCfg === "numeric" ? "M" : "MM";
    } else if (type === "year") {
      return intlCfg === "numeric" ? "YYYY" : "YY";
    }
  }).join("");
  return formatRedirects[format2] = fmt;
};
var DEFAULT_YEAR = 2020;
var DEFAULT_MONTH = 0;
var DEFAULT_DAY = 1;
var intlFormatConfigs = {
  l: { year: "numeric", month: "numeric", day: "numeric" },
  ll: { year: "numeric", month: "short", day: "numeric" }
};
var formats = {
  // 1, 2, ... 11, 12
  M: (date) => date.getMonth() + 1,
  //date.toLocaleDateString(locale, { month : 'numeric' }),
  // 1st, 2nd, 3rd, 4th, ... 11th, 12th
  Mo: (date) => ordinalSuffix(formats.M(date).toString()),
  // 01, 02, ...
  MM: (date) => (date.getMonth() + 1).toString().padStart(2, "0"),
  //date.toLocaleDateString(locale, { month : '2-digit' }),
  // Jan, Feb, ...
  MMM: (date) => useIntlFormat("MMM", { month: "short" }, date),
  // January, February, ...
  MMMM: (date) => useIntlFormat("MMMM", { month: "long" }, date),
  // 1, 2, ...
  Q: (date) => Math.ceil((date.getMonth() + 1) / 3),
  // 1st, 2nd, ...
  Qo: (date) => ordinalSuffix(formats.Q(date).toString()),
  // 1, 2, ...
  D: (date) => date.getDate(),
  //date.toLocaleDateString(locale, { day : 'numeric' }),
  // 1st, 2nd, ...
  Do: (date) => ordinalSuffix(formats.D(date).toString()),
  // 01, 02, ...
  DD: (date) => date.getDate().toString().padStart(2, "0"),
  //date.toLocaleDateString(locale, { day : '2-digit' }),
  // 1, 2, ..., 365, 365
  DDD: (date) => Math.ceil(
    (new Date(date.getFullYear(), date.getMonth(), date.getDate(), 12, 0, 0) - new Date(date.getFullYear(), 0, 0, 12, 0, 0)) / validConversions.day.millisecond
  ),
  // 1st, 2nd, ...
  DDDo: (date) => ordinalSuffix(formats.DDD(date).toString()),
  // 001, 002, ...
  DDDD: (date) => formats.DDD(date).toString().padStart(3, "0"),
  // 0, 1, ..., 6
  d: (date) => date.getDay(),
  // 0th, 1st, ...
  do: (date) => ordinalSuffix(date.getDay().toString()),
  // S, M, ...
  d1: (date) => useIntlFormat("d1", { weekday: "narrow" }, date).substr(0, 1),
  // Su, Mo, ...
  dd: (date) => formats.ddd(date).substring(0, 2),
  // Sun, Mon, ...
  ddd: (date) => useIntlFormat("ddd", { weekday: "short" }, date),
  // Sunday, Monday, ...
  dddd: (date) => useIntlFormat("dddd", { weekday: "long" }, date),
  u: (date) => {
    const formatter = intlFormatterCache.u || (intlFormatterCache.u = new Intl.DateTimeFormat("en-GB", {
      timeZone: "UTC",
      year: "numeric",
      month: "2-digit",
      day: "2-digit"
    })), parts = formatter.formatToParts(date);
    return `${parts[4].value}${parts[2].value}${parts[0].value}Z`;
  },
  uu: (date) => {
    const formatter = intlFormatterCache.uu || (intlFormatterCache.uu = new Intl.DateTimeFormat("en-GB", {
      timeZone: "UTC",
      hour12: false,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    })), parts = formatter.formatToParts(date);
    return `${parts[4].value}${parts[2].value}${parts[0].value}T${parts[6].value}${parts[8].value}${parts[10].value}Z`;
  },
  e: (date) => date.getDay(),
  E: (date) => date.getDay() + 1,
  // ISO week, 1, 2, ...
  W: (date) => DateHelper.getWeekNumber(date)[1],
  Wo: (date) => ordinalSuffix(formats.W(date).toString()),
  WW: (date) => formats.W(date).toString().padStart(2, "0"),
  // ISO week, 1, 2, ... with localized 'Week ' prefix
  Wp: (date) => `${DateHelper.localize("L{Week}")} ${formats.W(date)}`,
  WWp: (date) => `${DateHelper.localize("L{Week}")} ${formats.WW(date)}`,
  Wp0: (date) => `${DateHelper.localize("L{Week}")[0]}${formats.W(date)}`,
  WWp0: (date) => `${DateHelper.localize("L{Week}")[0]}${formats.WW(date)}`,
  // 1979, 2018
  Y: (date) => date.getFullYear(),
  //date.toLocaleDateString(locale, { year : 'numeric' }),
  // 79, 18
  YY: (date) => (date.getFullYear() % 100).toString().padStart(2, "0"),
  //date.toLocaleDateString(locale, { year : '2-digit' }),
  // 1979, 2018
  YYYY: (date) => date.getFullYear(),
  //date.toLocaleDateString(locale, { year : 'numeric' }),
  // AM, PM
  A: (date) => date.getHours() < 12 ? "AM" : "PM",
  a: (date) => date.getHours() < 12 ? "am" : "pm",
  // 0, 1, ... 23
  H: (date) => date.getHours(),
  // 00, 01, ...
  HH: (date) => date.getHours().toString().padStart(2, "0"),
  // 1, 2, ... 12
  h: (date) => date.getHours() % 12 || 12,
  // 01, 02, ...
  hh: (date) => formats.h(date).toString().padStart(2, "0"),
  // 1, 2, ... 24
  k: (date) => date.getHours() || 24,
  // 01, 02, ...
  kk: (date) => formats.k(date).toString().padStart(2, "0"),
  // Locale specific (0 -> 24 or 1 AM -> 12 PM)
  K: (date) => formatTime("K", { hour: "numeric" }, date),
  // Locale specific (00 -> 24 or 1 AM -> 12 PM)
  KK: (date) => formatTime("KK", { hour: "2-digit" }, date),
  // 0, 1, ... 59
  m: (date) => date.getMinutes(),
  //date.toLocaleTimeString(locale, { minute : 'numeric' }),
  // 00, 01, ...
  mm: (date) => formats.m(date).toString().padStart(2, "0"),
  // 0, 1, ... 59
  s: (date) => date.getSeconds(),
  //date.toLocaleTimeString(locale, { second : 'numeric' }),
  // 00, 01, ...
  ss: (date) => formats.s(date).toString().padStart(2, "0"),
  // 0, 1, ... 9 which are 000, 100, 200 ... 900 in milliseconds
  S: (date) => Math.floor(date.getMilliseconds() / 100).toString(),
  // 00, 01, ... 99 which are 000, 010, 020 ... 990 in milliseconds
  SS: (date) => Math.floor(date.getMilliseconds() / 10).toString().padStart(2, "0"),
  // 000, 001, ... 999 in milliseconds
  SSS: (date) => date.getMilliseconds().toString().padStart(3, "0"),
  z: (date) => useIntlFormat("z", { timeZoneName: "short" }, date),
  zz: (date) => useIntlFormat("zz", { timeZoneName: "long" }, date),
  Z: (date) => DH.getGMTOffset(date),
  LT: (date) => formatTime("LT", { hour: "2-digit", minute: "2-digit" }, date),
  // if minutes is 0, doesn't show it
  LST: (date) => formatTime("LST", { hour: "numeric", minute: "2-digit" }, date, true),
  LTS: (date) => formatTime("LTS", { hour: "2-digit", minute: "2-digit", second: "2-digit" }, date),
  L: (date) => useIntlFormat("L", { year: "numeric", month: "2-digit", day: "2-digit" }, date),
  l: (date) => useIntlFormat("l", intlFormatConfigs.l, date),
  LL: (date) => useIntlFormat("LL", { year: "numeric", month: "long", day: "numeric" }, date),
  ll: (date) => useIntlFormat("ll", intlFormatConfigs.ll, date),
  LLL: (date) => useIntlFormat("LLL", {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit"
  }, date),
  lll: (date) => useIntlFormat("lll", {
    year: "numeric",
    month: "short",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit"
  }, date),
  LLLL: (date) => useIntlFormat("LLLL", {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit",
    weekday: "long"
  }, date),
  llll: (date) => useIntlFormat("llll", {
    year: "numeric",
    month: "short",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit",
    weekday: "short"
  }, date)
};
var formatKeys = Object.keys(formats).sort((a, b) => b.length - a.length);
var formatRegexp = `^(?:${formatKeys.join("|")})`;
var emptyFn3 = () => ({});
var isNumber = (str) => numberRegex.test(str);
var parseMilliseconds = (str) => isNumber(str) && { milliseconds: parseInt(str.padEnd(3, "0").substring(0, 3)) };
var parsers = {
  YYYY: (str) => {
    const year = parseInt(str);
    return { year: year >= 1e3 && year <= 9999 ? year : NaN };
  },
  Y: (str) => ({ year: parseInt(str) }),
  YY: (str) => {
    const year = parseInt(str);
    return { year: year + (year > 1968 ? 1900 : 2e3) };
  },
  M: (str) => ({ month: parseInt(str) - 1 }),
  MM: (str) => ({ month: parseInt(str) - 1 }),
  Mo: (str) => ({ month: parseInt(str) - 1 }),
  MMM: (str) => {
    const month2 = (str || "").toLowerCase();
    for (const [name, entry] of Object.entries(DateHelper._monthShortNamesIndex)) {
      if (month2.startsWith(name)) {
        return { month: entry.value };
      }
    }
  },
  MMMM: (str) => {
    const month2 = (str || "").toLowerCase();
    for (const [name, entry] of Object.entries(DateHelper._monthNamesIndex)) {
      if (month2.startsWith(name)) {
        return { month: entry.value };
      }
    }
  },
  DD: (str) => ({ date: parseInt(str) }),
  D: (str) => ({ date: parseInt(str) }),
  Do: (str) => ({ date: parseInt(str) }),
  DDD: emptyFn3,
  DDDo: emptyFn3,
  DDDD: emptyFn3,
  d: emptyFn3,
  do: emptyFn3,
  d1: emptyFn3,
  dd: emptyFn3,
  ddd: emptyFn3,
  dddd: emptyFn3,
  Q: emptyFn3,
  Qo: emptyFn3,
  W: emptyFn3,
  Wo: emptyFn3,
  WW: emptyFn3,
  e: emptyFn3,
  E: emptyFn3,
  HH: (str) => ({ hours: parseInt(str) }),
  hh: (str) => ({ hours: parseInt(str) }),
  mm: (str) => ({ minutes: parseInt(str) }),
  H: (str) => ({ hours: parseInt(str) }),
  m: (str) => ({ minutes: parseInt(str) }),
  ss: (str) => ({ seconds: parseInt(str) }),
  s: (str) => ({ seconds: parseInt(str) }),
  S: parseMilliseconds,
  SS: parseMilliseconds,
  SSS: parseMilliseconds,
  A: (str) => ({ amPm: str.toLowerCase() }),
  a: (str) => ({ amPm: str.toLowerCase() }),
  L: "MM/DD/YYYY",
  LT: "HH:mm A",
  LTS: "HH:mm:ss A",
  l: { type: "dynamic", parser: () => redirectFormat("l") },
  ll: { type: "dynamic", parser: () => redirectFormat("ll") },
  // Can either be Z (=UTC, 0) or +-HH:MM
  Z: (str) => {
    if (!str || !timeZoneRegEx.test(str) && str !== "Z") {
      return null;
    }
    let timeZone = 0;
    if (str !== "Z") {
      const matches = timeZoneRegEx.exec(str);
      if (matches) {
        const sign = matches[1] === "+" ? 1 : -1, hours = parseInt(matches[2]) || 0, minutes = parseInt(matches[3]) || 0;
        timeZone = sign * (hours * 60 + minutes);
      } else {
        timeZone = -1 * (/* @__PURE__ */ new Date()).getTimezoneOffset();
      }
    }
    return { timeZone };
  }
};
var parserKeys = Object.keys(parsers).sort((a, b) => b.length - a.length);
var parserRegexp = new RegExp(`(${parserKeys.join("|")})`);
var localeStrRegExp = new RegExp("^(LL|LLL|lll|LLLL|llll)$");
var validConversions = {
  // The units below assume:
  // 30 days in a month, 91 days for a quarter and 365 for a year
  // 52 weeks per year, 4 per month, 13 per quarter
  // 3652 days per decade (assuming two of the years will be leap with 366 days)
  decade: {
    decade: 1,
    year: 10,
    quarter: 40,
    month: 120,
    week: 520,
    day: 3652,
    hour: 24 * 3652,
    minute: 1440 * 3652,
    second: 86400 * 3652,
    millisecond: 864e5 * 3652
  },
  year: {
    decade: 0.1,
    year: 1,
    quarter: 4,
    month: 12,
    week: 52,
    day: 365,
    hour: 24 * 365,
    minute: 1440 * 365,
    second: 86400 * 365,
    millisecond: 864e5 * 365
  },
  quarter: {
    decade: 1 / 40,
    year: 1 / 4,
    quarter: 1,
    month: 3,
    week: 4,
    day: 91,
    hour: 24 * 91,
    minute: 1440 * 91,
    second: 86400 * 91,
    millisecond: 864e5 * 91
  },
  month: {
    decade: 1 / 120,
    year: 1 / 12,
    quarter: 1 / 3,
    month: 1,
    week: 4,
    day: -30,
    hour: -24 * 30,
    minute: -1440 * 30,
    second: -86400 * 30,
    millisecond: -864e5 * 30
  },
  week: {
    decade: -1 / 520,
    year: -1 / 52,
    quarter: -1 / 13,
    month: -1 / 4,
    day: 7,
    hour: 168,
    minute: 10080,
    second: 604800,
    millisecond: 6048e5
  },
  day: {
    decade: -1 / 3652,
    year: -1 / 365,
    quarter: -1 / 91,
    month: -1 / 30,
    week: 1 / 7,
    hour: 24,
    minute: 1440,
    second: 86400,
    millisecond: 864e5
  },
  hour: {
    decade: -1 / (3652 * 24),
    year: -1 / (365 * 24),
    quarter: -1 / (91 * 24),
    month: -1 / (30 * 24),
    week: 1 / 168,
    day: 1 / 24,
    minute: 60,
    second: 3600,
    millisecond: 36e5
  },
  minute: {
    decade: -1 / (3652 * 1440),
    year: -1 / (365 * 1440),
    quarter: -1 / (91 * 1440),
    month: -1 / (30 * 1440),
    week: 1 / 10080,
    day: 1 / 1440,
    hour: 1 / 60,
    second: 60,
    millisecond: 6e4
  },
  second: {
    decade: -1 / (3652 * 86400),
    year: -1 / (365 * 86400),
    quarter: -1 / (91 * 86400),
    month: -1 / (30 * 86400),
    week: 1 / 604800,
    day: 1 / 86400,
    hour: 1 / 3600,
    minute: 1 / 60,
    millisecond: 1e3
  },
  millisecond: {
    decade: -1 / (3652 * 864e5),
    year: -1 / (365 * 864e5),
    quarter: -1 / (91 * 864e5),
    month: -1 / (30 * 864e5),
    week: 1 / 6048e5,
    day: 1 / 864e5,
    hour: 1 / 36e5,
    minute: 1 / 6e4,
    second: 1 / 1e3
  }
};
var normalizedUnits = {
  ms: "millisecond",
  milliseconds: "millisecond",
  s: "second",
  seconds: "second",
  m: "minute",
  mi: "minute",
  min: "minute",
  minutes: "minute",
  h: "hour",
  hours: "hour",
  d: "day",
  days: "day",
  w: "week",
  weeks: "week",
  M: "month",
  mo: "month",
  mon: "month",
  months: "month",
  q: "quarter",
  quarters: "quarter",
  y: "year",
  years: "year",
  dec: "decade",
  decades: "decade"
};
var withDecimalsDurationRegex = /^\s*([-+]?\d+(?:[.,]\d*)?|[-+]?(?:[.,]\d+))\s*([^\s]+)?/i;
var noDecimalsDurationRegex = /^\s*([-+]?\d+)(?![.,])\s*([^\s]+)?/i;
var canonicalUnitNames = [
  "millisecond",
  "second",
  "minute",
  "hour",
  "day",
  "week",
  "month",
  "quarter",
  "year",
  "decade"
];
var canonicalUnitAbbreviations = [
  ["mil"],
  ["s", "sec"],
  ["m", "min"],
  ["h", "hr"],
  ["d"],
  ["w", "wk"],
  ["mo", "mon", "mnt"],
  ["q", "quar", "qrt"],
  ["y", "yr"],
  ["dec"]
];
var deltaUnits = [
  "decade",
  "year",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
var dateProperties = [
  "milliseconds",
  "seconds",
  "minutes",
  "hours",
  "date",
  "month",
  "year"
];
var parseNumber = (n) => {
  const result = parseFloat(n);
  return isNaN(result) ? null : result;
};
var numberRegex = /^[0-9]+$/;
var timeZoneRegEx = /([+-])(\d\d):*(\d\d)*$/;
var unitMagnitudes = {
  millisecond: 0,
  second: 1,
  minute: 2,
  hour: 3,
  day: 4,
  week: 5,
  month: 6,
  quarter: 7,
  year: 8,
  decade: 9
};
var snapFns = {
  round(number, step = 1) {
    return Math.round(number / step) * step;
  },
  floor(number, step = 1) {
    return Math.floor(number / step) * step;
  },
  ceil(number, step = 1) {
    return Math.ceil(number / step) * step;
  }
};
var keyCache = {};
var _DateHelper = class extends Localizable_default() {
  static get $name() {
    return "DateHelper";
  }
  //region Parse & format
  /**
   * Get/set the default format used by `format()` and `parse()`. Defaults to `'YYYY-MM-DDTHH:mm:ssZ'`
   * (~ISO 8601 Date and time, `'1962-06-17T09:21:34Z'`).
   * @member {String}
   */
  static set defaultFormat(format2) {
    DH._defaultFormat = format2;
  }
  static get defaultFormat() {
    return DH._defaultFormat || "YYYY-MM-DDTHH:mm:ssZ";
  }
  /**
   * Get/set the default format used by `parse()`. Defaults to `'YYYY-MM-DDTHH:mm:ss.SSSZ'` or {@link #property-defaultFormat-static}
   * (~ISO 8601 Date and time, `'1962-06-17T09:21:34.123Z'`).
   * @member {String}
   */
  static set defaultParseFormat(parseFormat) {
    this._defaultParseFormat = parseFormat;
  }
  static get defaultParseFormat() {
    return this._defaultParseFormat || this._defaultFormat || "YYYY-MM-DDTHH:mm:ss.SSSZ";
  }
  static buildParser(format2) {
    const parts = format2.split(parserRegexp), parser = [];
    if (parts.length === 1 || localeStrRegExp.test(format2)) {
      return [];
    } else {
      parts.reduce((prev, curr, index, array) => {
        if (index !== 0 || curr !== "") {
          if (parserRegexp.test(curr)) {
            const localeParsers = this.localize("L{parsers}") || {}, fn2 = localeParsers[curr] || parsers[curr];
            if (curr === "Z" && index < array.length - 2) {
              throw new Error(`Invalid format ${format2} TimeZone (Z) must be last token`);
            }
            const parserObj = typeof fn2 === "function" || typeof fn2 === "string" ? fn2 : fn2.parser();
            if (typeof parserObj === "string") {
              const nestedParsers = DH.buildParser(parserObj), lastItem = nestedParsers.pop();
              delete lastItem.last;
              parser.push(...nestedParsers);
              prev = lastItem;
            } else {
              prev.pattern = curr;
              prev.fn = parserObj;
            }
          } else {
            prev.splitter = curr;
            parser.push(prev);
            prev = {};
          }
        } else if (Object.prototype.hasOwnProperty.call(prev, "pattern")) {
          parser.push(prev);
        }
        return prev;
      }, {});
    }
    parser[parser.length - 1].last = true;
    return parser;
  }
  /**
   * A utility function to create a sortable string key for the passed date or ms timestamp using the `'YYYY-MM-DD'`
   * format.
   * @param {Number|Date} ms The Date instance or ms timestamp to generate a key for
   * @returns {String} Date/timestamp as a string with `'YYYY-M-D'` format
   * @internal
   */
  static makeKey(ms) {
    if (ms.length === 10) {
      return ms;
    }
    if (ms.getTime) {
      ms = ms.getTime();
    }
    const cached = keyCache[Math.trunc(ms / MS_PER_HOUR)];
    if (cached) {
      return cached;
    }
    tempDate.setTime(ms);
    const month2 = tempDate.getMonth() + 1, date = tempDate.getDate();
    return keyCache[Math.trunc(ms / MS_PER_HOUR)] = `${tempDate.getFullYear()}-${month2 < 10 ? "0" + month2 : month2}-${date < 10 ? "0" + date : date}`;
  }
  /**
   * A utility function to parse a sortable string to a date using the `'YYYY-MM-DD'` format.
   * @param {String} key The string to return a date for
   * @returns {Date} new Date instance
   * @internal
   */
  static parseKey(key) {
    return DH.parse(key, "YYYY-MM-DD");
  }
  /**
   * Returns a date created from the supplied string using the specified format. Will try to create even if format
   * is left out, by first using the default format (see {@link #property-defaultFormat-static}, by default
   * `YYYY-MM-DDTHH:mm:ssZ`) and then using `new Date(dateString)`.
   * Supported tokens:
   *
   * | Unit        | Token | Description                       |
   * |-------------|-------|-----------------------------------|
   * | Year        | YYYY  | 2018                              |
   * |             | YY    | < 68 -> 2000, > 68 -> 1900        |
   * | Month       | MM    | 01 - 12                           |
   * | Date        | DD    | 01 - 31                           |
   * | Hour        | HH    | 00 - 23 or 1 - 12                 |
   * | Minute      | mm    | 00 - 59                           |
   * | Second      | ss    | 00 - 59                           |
   * | Millisecond | S     | 0 - 9 [000, 100, 200 .. 900 ]     |
   * |             | SS    | 00 - 99 [000, 010, 020 .. 990 ]   |
   * |             | SSS   | 000 - 999 [000, 001, 002 .. 999 ] |
   * | AM/PM       | A     | AM or PM                          |
   * |             | a     | am or pm                          |
   * | TimeZone    | Z     | Z for UTC or +-HH:mm              |
   * | Predefined  | L     | Long date, MM/DD/YYYY             |
   * |             | LT    | Long time, HH:mm A                |
   *
   * Predefined formats and functions used to parse tokens can be localized, see for example the swedish locale SvSE.js
   *
   * NOTE: If no date parameters are provided then `Jan 01 2020` is used as a default date
   *
   * @param {String} dateString Date string
   * @param {String} [format] Date format (or {@link #property-defaultParseFormat-static} if left out)
   * @returns {Date} new Date instance parsed from the string
   * @category Parse & format
   */
  static parse(dateString, format2 = DH.defaultParseFormat, strict = false) {
    if (dateString instanceof Date) {
      return dateString;
    }
    if (typeof dateString !== "string" || !dateString) {
      return null;
    }
    const config = {
      year: null,
      month: null,
      date: null,
      hours: null,
      minutes: null,
      seconds: null,
      milliseconds: null
    };
    format2 = format2.replace(msRegExp, msReplacer);
    let parser = parserCache[format2], result;
    if (!parser) {
      parser = parserCache[format2] = DH.buildParser(format2);
    }
    if (dateString.includes("\u202F")) {
      dateString = dateString.replace(/\s/g, " ");
    }
    parser.reduce((dateString2, parser2) => {
      var _a2;
      if (parser2.last) {
        Object.assign(config, parser2.fn(dateString2));
      } else {
        let splitAt;
        if (parser2.splitter === "T" && dateString2.indexOf("T") === -1) {
          splitAt = dateString2.indexOf(" ");
        } else {
          const timeZoneIndex = dateString2.indexOf("+");
          let { splitter } = parser2;
          if (!strict && splitRegExp.test(splitter)) {
            splitter = splitRegExp;
          }
          splitAt = parser2.splitter !== "" ? dateString2.search(typeof splitter === "string" ? StringHelper.escapeRegExp(splitter) : splitter) : ((_a2 = parser2.pattern) == null ? void 0 : _a2.length) || -1;
          if (timeZoneIndex > -1 && splitAt > timeZoneIndex) {
            splitAt = -1;
          }
        }
        let part, rest;
        if (splitAt === -1 || parser2.pattern === "SSS" && dateString2.match(/^\d+Z$/)) {
          const chunks = dateString2.split(/([Z\-+])/);
          if (chunks.length === 1) {
            part = dateString2;
            rest = "";
          } else {
            part = chunks[0];
            rest = `${chunks[1]}${chunks[2]}`;
          }
        } else {
          part = dateString2.substring(0, splitAt) || dateString2;
          rest = dateString2.substring(splitAt + parser2.splitter.length);
        }
        if (parser2.fn) {
          const res = parser2.fn(part);
          if (res) {
            Object.assign(config, res);
          } else {
            rest = part + rest;
          }
        }
        return rest;
      }
    }, dateString);
    if (config.year && !config.date) {
      config.date = 1;
    }
    if (config.date > 31 || config.month > 12) {
      return null;
    }
    const date = DH.create(config, strict);
    if (date) {
      result = date;
    } else if (!strict) {
      result = new Date(dateString);
    }
    return result;
  }
  /**
   * Creates a date from a date definition object. The object can have the following properties:
   * - year
   * - month
   * - date (day in month)
   * - hours
   * - minutes
   * - seconds
   * - milliseconds
   * - amPm : 'am' or 'pm', implies 12-hour clock
   * - timeZone : offset from UTC in minutes
   * @param {Object} definition
   * @param {Number} definition.year
   * @param {Number} [definition.month]
   * @param {Number} [definition.date]
   * @param {Number} [definition.hours]
   * @param {Number} [definition.minutes]
   * @param {Number} [definition.seconds]
   * @param {Number} [definition.milliseconds]
   * @param {Number} [definition.amPm]
   * @param {Number} [definition.timeZone]
   * @returns {Date} new Date instance
   * @category Parse & format
   */
  static create(definition, strict = false) {
    const def = { ...definition };
    let invalid = isNaN(def.year) || strict && (isNaN(def.month) || isNaN(def.date)), useUTC = false;
    if (!invalid) {
      let allNull = true;
      dateProperties.forEach((property) => {
        if (!(property in def) || isNaN(def[property])) {
          def[property] = 0;
        }
        allNull = allNull && def[property] === null;
      });
      invalid = allNull;
    }
    if (invalid) {
      return null;
    }
    if (def.amPm === "am") {
      def.hours = def.hours % 12;
    } else if (def.amPm === "pm") {
      def.hours = def.hours % 12 + 12;
    }
    if ("timeZone" in def) {
      useUTC = true;
      def.minutes -= def.timeZone;
    }
    if (strict && (def.year == null || def.month == null || def.date == null)) {
      return null;
    }
    const args = [
      defaultValue(def.year, DEFAULT_YEAR),
      defaultValue(def.month, DEFAULT_MONTH),
      defaultValue(def.date, DEFAULT_DAY),
      def.hours,
      def.minutes,
      def.seconds,
      def.milliseconds
    ];
    return useUTC ? new Date(Date.UTC(...args)) : new Date(...args);
  }
  static toUTC(date) {
    return new Date(Date.UTC(
      date.getUTCFullYear(),
      date.getUTCMonth(),
      date.getUTCDate(),
      date.getUTCHours(),
      date.getUTCMinutes(),
      date.getUTCSeconds(),
      date.getUTCMilliseconds()
    ));
  }
  /**
   * Converts a date to string with the specified format. Formats heavily inspired by https://momentjs.com.
   * Available formats (input used for output below is `new Date(2018,8,9,18,7,8,145)`):
   *
   * | Unit                  | Token | Description & output                  |
   * |-----------------------|-------|---------------------------------------|
   * | Year                  | YYYY  | 2018                                  |
   * |                       | YY    | 18                                    |
   * |                       | Y     | 2018                                  |
   * | Quarter               | Q     | 3                                     |
   * |                       | Qo    | 3rd                                   |
   * | Month                 | MMMM  | September                             |
   * |                       | MMM   | Sep                                   |
   * |                       | MM    | 09                                    |
   * |                       | Mo    | 9th                                   |
   * |                       | M     | 9                                     |
   * | Week (iso)            | WW    | 37 (2 digit, zero padded)             |
   * |                       | Wo    | 37th                                  |
   * |                       | W     | 37                                    |
   * |                       | WWp   | Week 37 (localized prefix, zero pad)  |
   * |                       | Wp    | Week 37 (localized prefix)            |
   * |                       | WWp0  | W37 (localized prefix)                |
   * |                       | Wp0   | W37 (localized prefix)                |
   * | Date                  | DDDD  | Day of year, 3 digits                 |
   * |                       | DDDo  | Day of year, ordinal                  |
   * |                       | DDD   | Day of year                           |
   * |                       | DD    | 09                                    |
   * |                       | Do    | 9th                                   |
   * |                       | D     | 9                                     |
   * | Weekday               | dddd  | Sunday                                |
   * |                       | ddd   | Sun                                   |
   * |                       | dd    | Su                                    |
   * |                       | d1    | S                                     |
   * |                       | do    | 0th                                   |
   * |                       | d     | 0                                     |
   * | Hour                  | HH    | 18 (00 - 23)                          |
   * |                       | H     | 18 (0 - 23)                           |
   * |                       | hh    | 06 (00 - 12)                          |
   * |                       | h     | 6 (0 - 12)                            |
   * |                       | KK    | 19 (01 - 24)                          |
   * |                       | K     | 19 (1 - 24)                           |
   * |                       | kk    | 06 or 18, locale determines           |
   * |                       | k     | 6 or 18, locale determines            |
   * | Minute                | mm    | 07                                    |
   * |                       | m     | 7                                     |
   * | Second                | ss    | 08                                    |
   * |                       | s     | 8                                     |
   * | Millisecond           | S     | 1 (100ms)                             |
   * |                       | SS    | 14 (140ms)                            |
   * |                       | SSS   | 145 (145ms)                           |
   * | AM/PM                 | A     | AM or PM                              |
   * |                       | a     | am or pm                              |
   * | Predefined            | LT    | H: 2-digit (2d), m: 2d                |
   * | (uses browser locale) | LTS   | H: 2d, m: 2d, s : 2d                  |
   * |                       | LST   | Depends on 12 or 24 hour clock        |
   * |                       |       | 12h, H : 1d, m : 0 or 2d              |
   * |                       |       | 24h, H : 2d, m : 2d                   |
   * |                       | L     | Y: numeric (n), M : 2d, D : 2d        |
   * |                       | l     | Y: n, M : n, D : n                    |
   * |                       | LL    | Y: n, M : long (l), D : n             |
   * |                       | ll    | Y: n, M : short (s), D : n            |
   * |                       | LLL   | Y: n, M : l, D : n, H: n, m: 2d       |
   * |                       | lll   | Y: n, M : s, D : n, H: n, m: 2d       |
   * |                       | LLLL  | Y: n, M : l, D : n, H: n, m: 2d, d: l |
   * |                       | llll  | Y: n, M : s, D : n, H: n, m: 2d, d: s |
   *
   * Some examples:
   *
   * ```javascript
   * DateHelper.format(new Date(2019, 7, 16), 'dddd') -> Friday
   * DateHelper.format(new Date(2019, 7, 16, 14, 27), 'HH:mm') --> 14:27
   * DateHelper.format(new Date(2019, 7, 16, 14, 27), 'L HH') --> 2019-07-16 14
   * ```
   *
   * Arbitrary text can be embedded in the format string by wrapping it with {}:
   *
   * ```javascript
   * DateHelper.format(new Date(2019, 7, 16), '{It is }dddd{, yay!}') -> It is Friday, yay!
   * ```
   *
   * @param {Date} date Date
   * @param {String} [format] Desired format (uses `defaultFormat` if left out)
   * @returns {String} Formatted string
   * @category Parse & format
   */
  static format(date, format2 = DH.defaultFormat) {
    if (!date || isNaN(date)) {
      return null;
    }
    let formatter = formatCache[format2], output = "";
    if (!formatter) {
      formatter = formatCache[format2] = [];
      for (let i = 0; i < format2.length; i++) {
        const formatMatch = format2.slice(i).match(formatRegexp), predefined = formatMatch == null ? void 0 : formatMatch[0];
        if (predefined) {
          const localeFormats = this.localize("L{formats}") || {}, fn2 = localeFormats[predefined] || formats[predefined];
          formatter.push(fn2);
          i += predefined.length - 1;
        } else if (format2[i] === "{") {
          const index = format2.indexOf("}", i + 1);
          if (index === -1) {
            formatter.push(format2.substr(i + 1));
            i = format2.length;
          } else {
            formatter.push(format2.substring(i + 1, index));
            i = index;
          }
        } else {
          formatter.push(format2[i]);
        }
      }
    }
    formatter.forEach((step) => {
      if (typeof step === "string") {
        output += step;
      } else {
        output += step(date);
      }
    });
    return output;
  }
  /**
   * Formats a range of `dates` using the specified `format`. Because two dates are involved, the `format` specifier
   * uses the tokens `S{}` and `E{}`. The text contained between the `{}` is the {@link #function-format-static format}
   * for the start date or end date, respectively. Text not inside these tokens is retained verbatim.
   *
   * For example:
   *
   * ```javascript
   *  DateHelper.formatRange(dates, 'S{DD MMM YYYY} - E{DD MMM YYYY}');
   * ```
   *
   * The above will format `dates[0]` based on the `S{DD MMM YYYY}` segment and `dates[1] using `E{DD MMM YYYY}`. The
   * `' - '` between these will remain between the two formatted dates.
   *
   * @param {Date[]} dates An array of start date and end date (`[startDate, endDate]`)
   * @param {String} format The format specifier
   * @returns {String}
   */
  static formatRange(dates, format2) {
    return format2.replace(
      rangeFormatPartRe,
      (s, which, fmt) => _DateHelper.format(dates[which === "S" ? 0 : 1], fmt)
    );
  }
  /**
   * Converts the specified amount of desired unit into milliseconds. Can be called by only specifying a unit as the
   * first argument, it then uses `amount = 1`.
   *
   * For example:
   *
   * ```javascript
   * asMilliseconds('hour') == asMilliseconds(1, 'hour')
   * ```
   *
   * @param {Number|String} amount Amount, what of is decided by specifying unit (also takes a unit which implies an amount of 1)
   * @param {String} [unit] Time unit (s, hour, months etc.)
   * @returns {Number}
   * @category Parse & format
   */
  static asMilliseconds(amount, unit = null) {
    if (typeof amount === "string") {
      unit = amount;
      amount = 1;
    }
    return DH.as("millisecond", amount, unit);
  }
  /**
   * Converts the passed Date to an accurate number of months passed since the epoch start.
   * @param {Date} time The Date to find the month value of
   * @returns {Number} The number of months since the system time epoch start. May be a fractional value
   */
  static asMonths(time) {
    const monthLength = DH.as("ms", DH.daysInMonth(time), "day"), fraction = (time.valueOf() - DH.startOf(time, "month").valueOf()) / monthLength;
    return time.getYear() * 12 + time.getMonth() + fraction;
  }
  static monthsToDate(months) {
    const intMonths = Math.floor(months), fraction = months - intMonths, result = new Date(0, intMonths), msInMonth = DH.as("ms", DH.daysInMonth(result), "days");
    result.setTime(result.getTime() + fraction * msInMonth);
    return result;
  }
  /**
   * Converts a millisecond time delta to a human-readable form. For example `1000 * 60 * 60 * 50`
   * milliseconds would be rendered as `'2 days, 2 hours'`.
   * @param {Number} delta The millisecond delta value
   * @param {Object} [options] Formatting options
   * @param {Boolean} [options.abbrev] Pass `true` to use abbreviated unit names, eg `'2d, 2h'` for the above example
   * @param {String} [options.precision] The minimum precision unit
   * @param {String} [options.separator] The separator to use
   * @param {Boolean} [options.asString] Pass `false` to return the result as an array, eg ['2d', '2h'] for the above example
   * @returns {String} Formatted string
   * @category Parse & format
   */
  static formatDelta(delta, options) {
    let abbrev, unitName;
    if (typeof options === "boolean") {
      abbrev = options;
    } else if (options) {
      abbrev = options.abbrev;
    }
    const deltaObj = this.getDelta(delta, options), result = [], sep = (options == null ? void 0 : options.separator) || (abbrev ? "" : " ");
    for (unitName in deltaObj) {
      result.push(`${deltaObj[unitName]}${sep}${unitName}`);
    }
    return (options == null ? void 0 : options.asString) === false ? result : result.join(", ");
  }
  /**
   * Converts a millisecond time delta to an object structure. For example `1000 * 60 * 60 * 50`
   * milliseconds the result would be as:
   *
   * ```javascript
   * {
   *     day  : 2,
   *     hour : 2
   * }
   *```
   *
   * @param {Number} delta The millisecond delta value
   * @param {Object} [options] Formatting options
   * @param {Boolean} [options.abbrev] Pass `true` to use abbreviated unit names, eg `{ d: 2, h: 2 }` for the above example
   * @param {String} [options.precision] The minimum precision unit
   * @param {Boolean} [options.ignoreLocale] Pass true to return unlocalized unit name. Requires `abbrev` to be false
   * @param {String} [options.maxUnit] Name of the maximum unit in the output. e.g. if you pass `day` then you'll get
   * `{ h: 25 }` instead of `{ d: 1, h: 1 }`
   * @returns {Object} The object with the values for each unit
   */
  static getDelta(delta, options) {
    let abbrev, d, done, precision, unitName, maxUnit, ignoreLocale;
    if (typeof options === "boolean") {
      abbrev = options;
    } else if (options) {
      abbrev = options.abbrev;
      precision = DH.normalizeUnit(options.precision);
      maxUnit = options.maxUnit;
      ignoreLocale = !abbrev && options.ignoreLocale;
    }
    const result = {}, getUnit = abbrev ? DH.getShortNameOfUnit : DH.getLocalizedNameOfUnit;
    const units = maxUnit ? deltaUnits.slice(deltaUnits.indexOf(maxUnit)) : deltaUnits;
    for (unitName of units) {
      d = DH.as(unitName, delta);
      done = precision === unitName;
      d = Math[done ? "round" : "floor"](d);
      if (d || done && !result.length) {
        result[ignoreLocale ? unitName : getUnit.call(DH, unitName, d !== 1)] = d;
        delta -= DH.as("ms", d, unitName);
      }
      if (done || !delta) {
        break;
      }
    }
    return result;
  }
  /**
   * Converts the specified amount of one unit (`fromUnit`) into an amount of another unit (`toUnit`).
   * @param {String} toUnit The name of units to convert to, eg: `'ms'`
   * @param {Number|String} amount The time to convert. Either the magnitude number form or a duration string such as '2d'
   * @param {String} [fromUnit='ms'] If the amount was passed as a number, the units to use to convert from
   * @returns {Number}
   * @category Parse & format
   */
  static as(toUnit, amount, fromUnit = "ms") {
    if (typeof amount === "string") {
      amount = DH.parseDuration(amount);
    }
    if (typeof amount === "object") {
      fromUnit = amount.unit;
      amount = amount.magnitude;
    }
    if (toUnit === fromUnit) {
      return amount;
    }
    toUnit = DH.normalizeUnit(toUnit);
    fromUnit = DH.normalizeUnit(fromUnit);
    if (toUnit === fromUnit) {
      return amount;
    } else if (unitMagnitudes[fromUnit] > unitMagnitudes[toUnit]) {
      return amount * Math.abs(validConversions[fromUnit][toUnit]);
    } else {
      return amount / Math.abs(validConversions[toUnit][fromUnit]);
    }
  }
  static formatContainsHourInfo(format2) {
    const stripEscapeRe = /(\\.)/g, hourInfoRe = /([HhKkmSsAa]|LT|L{3,}|l{3,})/;
    return hourInfoRe.test(format2.replace(stripEscapeRe, ""));
  }
  /**
   * Returns `true` for 24-hour format.
   * @param {String} format Date format
   * @returns {Boolean} `true` for 24-hour format
   * @category Parse & format
   */
  static is24HourFormat(format2) {
    return DH.format(DH.getTime(13, 0, 0), format2).includes("13");
  }
  //endregion
  //region Manipulate
  /**
   * Add days, hours etc. to a date. Always clones the date, original will be left unaffected.
   * @param {Date|String} date Original date
   * @param {Number|String|Core.data.Duration|DurationConfig} amount Amount of days, hours etc. or a string representation of a duration
   * as accepted by {@link #function-parseDuration-static} or an object with `{ magnitude, unit }` properties
   * @param {String} [unit='ms'] Unit for amount
   * @privateparam {Boolean} [clone=true] Pass `false` to affect the original
   * @returns {Date} New calculated date
   * @category Manipulate
   */
  static add(date, amount, unit = "ms", clone = true) {
    let d;
    if (typeof date === "string") {
      d = DH.parse(date);
    } else if (clone) {
      d = new Date(date.getTime());
    } else {
      d = date;
    }
    if (typeof amount === "string") {
      const duration = _DateHelper.parseDuration(amount);
      amount = duration.magnitude;
      unit = duration.unit;
    } else if (amount && typeof amount === "object") {
      unit = amount.unit;
      amount = amount.magnitude;
    }
    if (!unit || amount === 0) {
      return d;
    }
    unit = DH.normalizeUnit(unit);
    switch (unit) {
      case "millisecond":
        d.setTime(d.getTime() + amount);
        break;
      case "second":
        d.setTime(d.getTime() + amount * 1e3);
        break;
      case "minute":
        d.setTime(d.getTime() + amount * 6e4);
        break;
      case "hour":
        d.setTime(d.getTime() + amount * 36e5);
        break;
      case "day":
        if (amount % 1 === 0) {
          d.setDate(d.getDate() + amount);
          if (d.getHours() === 23 && date.getHours() === 0) {
            d.setHours(d.getHours() + 1);
          }
        } else {
          d.setTime(d.getTime() + amount * 864e5);
        }
        break;
      case "week":
        d.setDate(d.getDate() + amount * 7);
        break;
      case "month": {
        let day2 = d.getDate();
        if (day2 > 28) {
          day2 = Math.min(day2, DH.getLastDateOfMonth(DH.add(DH.getFirstDateOfMonth(d), amount, "month")).getDate());
        }
        d.setDate(day2);
        d.setMonth(d.getMonth() + amount);
        break;
      }
      case "quarter":
        DH.add(d, amount * 3, "month", false);
        break;
      case "year":
        d.setFullYear(d.getFullYear() + amount);
        break;
      case "decade":
        d.setFullYear(d.getFullYear() + amount * 10);
        break;
    }
    return d;
  }
  /**
   * Calculates the difference between two dates, in the specified unit.
   * @param {Date} start First date
   * @param {Date} end Second date
   * @param {String} [unit='ms'] Unit to calculate difference in
   * @param {Boolean} [fractional=true] Specify false to round result
   * @returns {Number} Difference in the specified unit
   * @category Manipulate
   */
  static diff(start, end, unit = "ms", fractional = true) {
    unit = DH.normalizeUnit(unit);
    if (!start || !end)
      return 0;
    let amount;
    switch (unit) {
      case "year":
        amount = DH.diff(start, end, "month") / 12;
        break;
      case "quarter":
        amount = DH.diff(start, end, "month") / 3;
        break;
      case "month":
        amount = (end.getFullYear() - start.getFullYear()) * 12 + (end.getMonth() - start.getMonth());
        if (amount === 0 && fractional) {
          amount = DH.diff(start, end, "day", fractional) / DH.daysInMonth(start);
        }
        break;
      case "week":
        amount = DH.diff(start, end, "day") / 7;
        break;
      case "day": {
        const dstDiff = start.getTimezoneOffset() - end.getTimezoneOffset();
        amount = (end - start + dstDiff * 60 * 1e3) / 864e5;
        break;
      }
      case "hour":
        amount = (end - start) / 36e5;
        break;
      case "minute":
        amount = (end - start) / 6e4;
        break;
      case "second":
        amount = (end - start) / 1e3;
        break;
      case "millisecond":
        amount = end - start;
        break;
    }
    return fractional ? amount : Math.round(amount);
  }
  /**
   * Sets the date to the start of the specified unit, by default returning a clone of the date instead of changing it
   * in place.
   * @param {Date} date Original date
   * @param {String} [unit='day'] Start of this unit, `'day'`, `'month'` etc
   * @param {Boolean} [clone=true] Manipulate a copy of the date
   * @param {Number} [weekStartDay] The first day of week, `0-6` (Sunday-Saturday). Defaults to the {@link #property-weekStartDay-static}
   * @returns {Date} Manipulated date
   * @category Manipulate
   */
  static startOf(date, unit = "day", clone = true, weekStartDay = DH.weekStartDay) {
    if (!date) {
      return null;
    }
    unit = DH.normalizeUnit(unit);
    if (clone) {
      date = DH.clone(date);
    }
    switch (unit) {
      case "year":
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
        return date;
      case "quarter":
        date.setMonth((DH.get(date, "quarter") - 1) * 3, 1);
        date.setHours(0, 0, 0, 0);
        return date;
      case "month":
        date.setDate(1);
        date.setHours(0, 0, 0, 0);
        return date;
      case "week": {
        const delta = date.getDay() - weekStartDay;
        date.setDate(date.getDate() - delta);
        date.setHours(0, 0, 0, 0);
        return date;
      }
      case "day":
        date.setHours(0, 0, 0, 0);
        return date;
      case "hour":
        date.getMinutes() > 0 && date.setMinutes(0);
      case "minute":
        date.getSeconds() > 0 && date.setSeconds(0);
      case "second":
        date.getMilliseconds() > 0 && date.setMilliseconds(0);
      case "millisecond":
        return date;
    }
  }
  /**
   * Returns the end point of the passed date, that is 00:00:00 of the day after the passed date.
   * @param {Date} date The date to return the end point of
   * @returns {Date} Manipulated date
   */
  static endOf(date) {
    return new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);
  }
  /**
   * Creates a clone of the specified date
   * @param {Date} date Original date
   * @returns {Date} Cloned date
   * @category Manipulate
   */
  static clone(date) {
    return new Date(date.getTime());
  }
  /**
   * Removes time from a date (same as calling {@link #function-startOf-static startOf(date)}).
   * @param {Date} date Date to remove time from
   * @param {Boolean} [clone=true] Manipulate a copy of the date
   * @returns {Date} Manipulated date
   * @category Manipulate
   */
  static clearTime(date, clone = true) {
    if (!date) {
      return null;
    }
    if (clone) {
      date = new Date(date.getTime());
    }
    date.setHours(0, 0, 0, 0);
    return date;
  }
  static midnight(date, inclusive) {
    let ret = DH.clearTime(date);
    if (inclusive && ret < date) {
      ret = DH.add(ret, 1, "d");
    }
    return ret;
  }
  /**
   * Returns the elapsed milliseconds from the start of the specified date.
   * @param {Date} date Date to remove date from
   * @param {String} [unit='ms'] The time unit to return
   * @returns {Number} The elapsed milliseconds from the start of the specified date
   * @category Manipulate
   */
  static getTimeOfDay(date, unit = "ms") {
    const t = date.getHours() * validConversions.hour.millisecond + date.getMinutes() * validConversions.minute.millisecond + date.getSeconds() * validConversions.second.millisecond + date.getMilliseconds();
    return unit === "ms" ? t : DH.as(unit, t, "ms");
  }
  /**
   * Sets a part of a date (in place).
   * @param {Date} date Date to manipulate
   * @param {String|Object} unit Part of date to set, for example `'minute'`. Or an object like `{ second: 1, minute: 1 }`
   * @param {Number} amount Value to set
   * @returns {Date} Passed date instance modified according to the arguments
   * @category Manipulate
   */
  static set(date, unit, amount) {
    if (!unit) {
      return date;
    }
    if (typeof unit === "string") {
      switch (DH.normalizeUnit(unit)) {
        case "millisecond":
          if (amount !== 0 || date.getMilliseconds() > 0) {
            date.setMilliseconds(amount);
          }
          break;
        case "second":
          if (amount !== 0 || date.getSeconds() > 0) {
            date.setSeconds(amount);
          }
          break;
        case "minute":
          if (amount !== 0 || date.getMinutes() > 0) {
            date.setMinutes(amount);
          }
          break;
        case "hour":
          date.setHours(amount);
          break;
        case "day":
        case "date":
          date.setDate(amount);
          break;
        case "week":
          throw new Error("week not implemented");
        case "month":
          date.setMonth(amount);
          break;
        case "quarter":
          date.setDate(1);
          date.setMonth((amount - 1) * 3);
          break;
        case "year":
          date.setFullYear(amount);
          break;
      }
    } else {
      Object.entries(unit).sort((a, b) => unitMagnitudes[a[0]] - unitMagnitudes[b[0]]).forEach(([unit2, amount2]) => {
        DH.set(date, unit2, amount2);
      });
    }
    return date;
  }
  static setDateToMidday(date, clone = true) {
    return DH.set(DH.clearTime(date, clone), "hour", 12);
  }
  /**
   * Constrains the date within a min and a max date.
   * @param {Date} date The date to constrain
   * @param {Date} [min] Min date
   * @param {Date} [max] Max date
   * @returns {Date} The constrained date
   * @category Manipulate
   */
  static constrain(date, min2, max) {
    if (min2 != null) {
      date = DH.max(date, min2);
    }
    return max == null ? date : DH.min(date, max);
  }
  /**
   * Returns time with default year, month, and day (Jan 1, 2020).
   * @param {Number|Date} hours Hours value or the full date to extract the time of
   * @param {Number} [minutes=0] Minutes value
   * @param {Number} [seconds=0] Seconds value
   * @param {Number} [ms=0] Milliseconds value
   * @returns {Date} A new default date with the time extracted from the given date or from the time values provided individually
   * @category Manipulate
   */
  static getTime(hours, minutes = 0, seconds = 0, ms = 0) {
    if (hours instanceof Date) {
      ms = hours.getMilliseconds();
      seconds = hours.getSeconds();
      minutes = hours.getMinutes();
      hours = hours.getHours();
    }
    return new Date(DEFAULT_YEAR, DEFAULT_MONTH, DEFAULT_DAY, hours, minutes, seconds, ms);
  }
  /**
   * Copies hours, minutes, seconds, milliseconds from one date to another.
   *
   * @param {Date} targetDate The target date
   * @param {Date} sourceDate The source date
   * @returns {Date} The adjusted target date
   * @category Manipulate
   * @static
   */
  static copyTimeValues(targetDate, sourceDate) {
    targetDate.setHours(sourceDate.getHours());
    targetDate.setMinutes(sourceDate.getMinutes());
    targetDate.setSeconds(sourceDate.getSeconds());
    targetDate.setMilliseconds(sourceDate.getMilliseconds());
    return targetDate;
  }
  //endregion
  //region Comparison
  static get isDSTEnabled() {
    const year = (/* @__PURE__ */ new Date()).getFullYear(), jan = new Date(year, 0, 1), jul = new Date(year, 6, 1);
    return jan.getTimezoneOffset() !== jul.getTimezoneOffset();
  }
  static isDST(date) {
    const year = date.getFullYear(), jan = new Date(year, 0, 1), jul = new Date(year, 6, 1);
    return date.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
  }
  /**
   * Determines if a date precedes another.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @returns {Boolean} `true` if first precedes second, otherwise false
   * @category Comparison
   */
  static isBefore(first, second) {
    return first < second;
  }
  /**
   * Determines if a date succeeds another.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @returns {Boolean} `true` if first succeeds second, otherwise false
   * @category Comparison
   */
  static isAfter(first, second) {
    return first > second;
  }
  /**
   * Checks if two dates are equal.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @param {String} [unit] Unit to calculate difference in. If not given, the comparison will be done up to a millisecond
   * @returns {Boolean} `true` if the dates are equal
   * @category Comparison
   */
  static isEqual(first, second, unit = null) {
    if (unit === null) {
      return first && second && first.getTime() === second.getTime();
    }
    return DH.startOf(first, unit) - DH.startOf(second, unit) === 0;
  }
  /**
   * Compares two dates using the specified precision.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @param {String} [unit] Unit to calculate difference in. If not given, the comparison will be done up to a millisecond
   * @returns {Number} `0` = equal, `-1` = first before second, `1` = first after second
   * @category Comparison
   */
  static compare(first, second, unit = null) {
    if (unit) {
      first = DH.startOf(first, unit);
      second = DH.startOf(second, unit);
    }
    if (first < second)
      return -1;
    if (first > second)
      return 1;
    return 0;
  }
  /**
   * Coerces the passed Date between the passed minimum and maximum values.
   * @param {Date} date The date to clamp between the `min` and `max`
   * @param {Date} min The minimum Date
   * @param {Date} max The maximum Date
   * @returns {Date} If the passed `date` is valid, a *new* Date object which is clamped between the `min` and `max`
   */
  static clamp(date, min2, max) {
    if (!isNaN(date)) {
      if (min2 != null) {
        date = Math.max(date, min2);
      }
      if (max != null) {
        date = Math.min(date, max);
      }
      return new Date(date);
    }
  }
  static isSameDate(first, second) {
    return DH.compare(first, second, "d") === 0;
  }
  static isSameTime(first, second) {
    return first.getHours() === second.getHours() && first.getMinutes() === second.getMinutes() && first.getSeconds() === second.getSeconds() && first.getMilliseconds() === second.getMilliseconds();
  }
  /**
   * Checks if date is the start of specified unit.
   * @param {Date} date Date
   * @param {String} unit Time unit
   * @returns {Boolean} `true` if date is the start of specified unit
   * @category Comparison
   */
  static isStartOf(date, unit) {
    return DH.isEqual(date, DH.startOf(date, unit));
  }
  /**
   * Checks if this date is `>= start` and `< end`.
   * @param {Date} date The source date
   * @param {Date} start Start date
   * @param {Date} end End date
   * @returns {Boolean} `true` if this date falls on or between the given start and end dates
   * @category Comparison
   */
  static betweenLesser(date, start, end) {
    return start.getTime() <= date.getTime() && date.getTime() < end.getTime();
  }
  /**
   * Checks if this date is `>= start` and `<= end`.
   * @param {Date} date The source date
   * @param {Date} start Start date
   * @param {Date} end End date
   * @returns {Boolean} `true` if this date falls on or between the given start and end dates
   * @category Comparison
   */
  static betweenLesserEqual(date, start, end) {
    return start.getTime() <= date.getTime() && date.getTime() <= end.getTime();
  }
  /**
   * Returns `true` if dates intersect.
   * @param {Date} date1Start Start date of first span
   * @param {Date} date1End End date of first span
   * @param {Date} date2Start Start date of second span
   * @param {Date} date2End End date of second span
   * @returns {Boolean} Returns `true` if dates intersect
   * @category Comparison
   */
  static intersectSpans(date1Start, date1End, date2Start, date2End) {
    return DH.betweenLesser(date1Start, date2Start, date2End) || DH.betweenLesser(date2Start, date1Start, date1End);
  }
  /**
   * Compare two units. Returns `1` if first param is a greater unit than second param, `-1` if the opposite is true or `0` if they're equal.
   * @param {String} unit1 The 1st unit
   * @param {String} unit2 The 2nd unit
   * @returns {Number} Returns `1` if first param is a greater unit than second param, `-1` if the opposite is true or `0` if they're equal
   * @category Comparison
   */
  static compareUnits(unit1, unit2) {
    return Math.sign(unitMagnitudes[DH.normalizeUnit(unit1)] - unitMagnitudes[DH.normalizeUnit(unit2)]);
  }
  /**
   * Returns `true` if the first time span completely 'covers' the second time span.
   *
   * @example
   * DateHelper.timeSpanContains(
   *     new Date(2010, 1, 2),
   *     new Date(2010, 1, 5),
   *     new Date(2010, 1, 3),
   *     new Date(2010, 1, 4)
   * ) ==> true
   * DateHelper.timeSpanContains(
   *   new Date(2010, 1, 2),
   *   new Date(2010, 1, 5),
   *   new Date(2010, 1, 3),
   *   new Date(2010, 1, 6)
   * ) ==> false
   *
   * @param {Date} spanStart The start date for initial time span
   * @param {Date} spanEnd The end date for initial time span
   * @param {Date} otherSpanStart The start date for the 2nd time span
   * @param {Date} otherSpanEnd The end date for the 2nd time span
   * @returns {Boolean} `true` if the first time span completely 'covers' the second time span
   * @category Comparison
   */
  static timeSpanContains(spanStart, spanEnd, otherSpanStart, otherSpanEnd) {
    return otherSpanStart - spanStart >= 0 && spanEnd - otherSpanEnd >= 0;
  }
  //endregion
  //region Query
  /**
   * Get the first day of week, 0-6 (Sunday-Saturday).
   * This is determined by the current locale's `DateHelper.weekStartDay` parameter.
   * @property {Number}
   * @readonly
   */
  static get weekStartDay() {
    if (DH._weekStartDay == null) {
      DH._weekStartDay = this.localize("L{weekStartDay}") || 0;
    }
    return DH._weekStartDay;
  }
  /**
   * Get non-working days as an object where keys are day indices, 0-6 (Sunday-Saturday), and the value is `true`.
   * This is determined by the current locale's `DateHelper.nonWorkingDays` parameter.
   *
   * For example:
   * ```javascript
   * {
   *     0 : true, // Sunday
   *     6 : true  // Saturday
   * }
   * ```
   *
   * @property {Object<Number,Boolean>}
   * @readonly
   */
  static get nonWorkingDays() {
    return { ...this.localize("L{nonWorkingDays}") };
  }
  /**
   * Get non-working days as an array of day indices, 0-6 (Sunday-Saturday).
   * This is determined by the current locale's `DateHelper.nonWorkingDays` parameter.
   *
   * For example:
   *
   * ```javascript
   * [ 0, 6 ] // Sunday & Saturday
   * ```
   *
   * @property {Number[]}
   * @readonly
   * @internal
   */
  static get nonWorkingDaysAsArray() {
    return Object.keys(this.nonWorkingDays).map(Number);
  }
  /**
   * Get weekend days as an object where keys are day indices, 0-6 (Sunday-Saturday), and the value is `true`.
   * Weekends are days which are declared as weekend days by the selected country and defined by the current locale's
   * `DateHelper.weekends` parameter.
   * To get non-working days see {@link #property-nonWorkingDays-static}.
   *
   * For example:
   * ```javascript
   * {
   *     0 : true, // Sunday
   *     6 : true  // Saturday
   * }
   * ```
   * @property {Object<Number,Boolean>}
   * @readonly
   * @internal
   */
  static get weekends() {
    return { ...this.localize("L{weekends}") };
  }
  /**
   * Get the specified part of a date.
   * @param {Date} date
   * @param {String} unit Part of date, hour, minute etc.
   * @returns {Number} The requested part of the specified date
   * @category Query
   */
  static get(date, unit) {
    switch (DH.normalizeUnit(unit)) {
      case "millisecond":
        return date.getMilliseconds();
      case "second":
        return date.getSeconds();
      case "minute":
        return date.getMinutes();
      case "hour":
        return date.getHours();
      case "date":
      case "day":
        return date.getDate();
      case "week":
        return formats.W(date);
      case "month":
        return date.getMonth();
      case "quarter":
        return Math.floor(date.getMonth() / 3) + 1;
      case "year":
        return date.getFullYear();
    }
    return null;
  }
  /**
   * Get number of days in the current year for the supplied date.
   * @param {Date} date Date to check
   * @returns {Number} Days in year
   * @category Query
   * @internal
   */
  static daysInYear(date) {
    const fullYear = date.getFullYear(), duration = new Date(fullYear + 1, 0, 1) - new Date(fullYear, 0, 1);
    return this.as("day", duration);
  }
  /**
   * Get number of days in the current month for the supplied date.
   * @param {Date} date Date which month should be checked
   * @returns {Number} Days in month
   * @category Query
   */
  static daysInMonth(date) {
    return 32 - new Date(date.getFullYear(), date.getMonth(), 32).getDate();
  }
  /**
   * Get number of hours in the current day for the supplied date.
   * @param {Date} date Date to check
   * @returns {Number} Hours in day
   * @category Query
   * @internal
   */
  static hoursInDay(date) {
    const fullYear = date.getFullYear(), month2 = date.getMonth(), day2 = date.getDate(), duration = new Date(fullYear, month2, day2 + 1) - new Date(fullYear, month2, day2);
    return this.as("hour", duration);
  }
  /**
   * Converts unit related to the date to actual amount of milliseconds in it. Takes into account leap years and
   * different duration of months.
   * @param {Date} date Date
   * @param {String} unit Time unit
   * @returns {Number} Returns amount of milliseconds
   * @internal
   */
  static getNormalizedUnitDuration(date, unit) {
    let result;
    switch (unit) {
      case "month":
        result = DH.asMilliseconds(DH.daysInMonth(date), "day");
        break;
      case "year":
        result = DH.asMilliseconds(DH.daysInYear(date), "day");
        break;
      case "day":
        result = DH.asMilliseconds(DH.hoursInDay(date), "hour");
        break;
      default:
        result = DH.asMilliseconds(unit);
    }
    return result;
  }
  /**
   * Get the first date of the month for the supplied date.
   * @param {Date} date Date
   * @returns {Date} New Date instance
   * @category Query
   */
  static getFirstDateOfMonth(date) {
    return new Date(date.getFullYear(), date.getMonth(), 1);
  }
  /**
   * Get the last date of the month for the supplied date.
   * @param {Date} date Date
   * @returns {Date} New Date instance
   * @category Query
   */
  static getLastDateOfMonth(date) {
    return new Date(date.getFullYear(), date.getMonth() + 1, 0);
  }
  /**
   * Get the earliest of two dates.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @returns {Date} Earliest date
   * @category Query
   */
  static min(first, second) {
    return first.getTime() < second.getTime() ? first : second;
  }
  /**
   * Get the latest of two dates.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @returns {Date} Latest date
   * @category Query
   */
  static max(first, second) {
    return first.getTime() > second.getTime() ? first : second;
  }
  /**
   * Get an incremented date. Incrementation based on specified unit and optional amount.
   * @param {Date} date Date
   * @param {String} unit Time unit
   * @param {Number} [increment=1] Increment amount
   * @param {Number} [weekStartDay] Will default to what is set in locale
   * @returns {Date} New Date instance
   * @category Query
   */
  static getNext(date, unit, increment = 1, weekStartDay = DH.weekStartDay) {
    if (unit === "week") {
      const dt = DH.clone(date), day2 = dt.getDay();
      DH.startOf(dt, "day", false);
      DH.add(dt, weekStartDay - day2 + 7 * (increment - (weekStartDay <= day2 ? 0 : 1)), "day", false);
      if (dt.getDay() !== weekStartDay) {
        DH.add(dt, 1, "hour");
      }
      return dt;
    }
    return DH.startOf(DH.add(date, increment, unit), unit, false);
  }
  /**
   * Checks if date object is valid.
   *
   * For example:
   *
   * ```javascript
   * date = new Date('foo')
   * date instanceof Date // true
   * date.toString() // Invalid Date
   * isNaN(date) // true
   * DateHelper.isValidDate(date) // false
   *
   * date = new Date()
   * date instanceof Date // true
   * date.toString() // Mon Jan 13 2020 18:27:38 GMT+0300 (GMT+03:00)
   * isNaN(date) // false
   * DateHelper.isValidDate(date) // true
   * ```
   *
   * @param {Date} date Date
   * @returns {Boolean} `true` if date object is valid
   */
  static isValidDate(date) {
    return DH.isDate(date) && !isNaN(date);
  }
  /**
   * Checks if value is a date object. Allows to recognize date object even from another context,
   * like the top frame when used in an iframe.
   *
   * @param {*} value Value to check
   * @returns {Boolean} `true` if value is a date object
   */
  static isDate(value) {
    return value && toString3.call(value) === DATE_TYPE2;
  }
  /**
   * Get the start of the next day.
   * @param {Date} date Date
   * @param {Boolean} [clone=false] Clone date
   * @param {Boolean} [noNeedToClearTime=false] Flag to not clear time from the result
   * @returns {Date} Passed Date or new Date instance, depending on the `clone` flag
   * @category Query
   */
  static getStartOfNextDay(date, clone = false, noNeedToClearTime = false) {
    let nextDay = DH.add(noNeedToClearTime ? date : DH.clearTime(date, clone), 1, "day");
    if (nextDay.getDate() === date.getDate()) {
      const offsetNextDay = DH.add(DH.clearTime(date, clone), 2, "day").getTimezoneOffset(), offsetDate = date.getTimezoneOffset();
      nextDay = DH.add(nextDay, offsetDate - offsetNextDay, "minute");
    }
    return nextDay;
  }
  /**
   * Get the end of previous day.
   * @param {Date} date Date
   * @param {Boolean} [noNeedToClearTime=false] Flag to not clear time from the result
   * @returns {Date} New Date instance
   * @category Query
   */
  static getEndOfPreviousDay(date, noNeedToClearTime = false) {
    const dateOnly = noNeedToClearTime ? date : DH.clearTime(date, true);
    if (dateOnly - date) {
      return dateOnly;
    } else {
      return DH.add(dateOnly, -1, "day");
    }
  }
  /**
   * Returns a string describing the specified week. For example, `'39, September 2020'` or `'40, Sep - Oct 2020'`.
   * @param {Date} startDate Start date
   * @param {Date} [endDate] End date
   * @returns {String} String describing the specified week
   * @internal
   */
  static getWeekDescription(startDate, endDate = startDate) {
    const monthDesc = startDate.getMonth() === endDate.getMonth() ? _DateHelper.format(startDate, "MMMM") : `${_DateHelper.format(startDate, "MMM")} - ${_DateHelper.format(endDate, "MMM")}`, week = _DateHelper.getWeekNumber(startDate);
    return `${week[1]}, ${monthDesc} ${week[0]}`;
  }
  /**
   * Get week number for the date.
   * @param {Date} date The date
   * @param {Number} [weekStartDay] The first day of week, 0-6 (Sunday-Saturday). Defaults to the {@link #property-weekStartDay-static}
   * @returns {Number[]} year and week number
   * @category Query
   */
  static getWeekNumber(date, weekStartDay = _DateHelper.weekStartDay) {
    const jan01 = new Date(date.getFullYear(), 0, 1), dec31 = new Date(date.getFullYear(), 11, 31), firstDay = normalizeDay(jan01.getDay() - weekStartDay), lastDay = normalizeDay(dec31.getDay() - weekStartDay), dayNumber = getDayDiff(date, jan01);
    let weekNumber;
    if (firstDay < 4) {
      weekNumber = Math.floor((dayNumber + firstDay - 1) / 7) + 1;
    } else {
      weekNumber = Math.floor((dayNumber + firstDay - 1) / 7);
    }
    if (weekNumber) {
      let year = date.getFullYear();
      if (weekNumber === 53 && lastDay < 3) {
        year++;
        weekNumber = 1;
      }
      return [year, weekNumber];
    }
    const lastWeekOfLastYear = _DateHelper.getWeekNumber(new Date(date.getFullYear() - 1, 11, 31))[1];
    return [date.getFullYear() - 1, lastWeekOfLastYear];
  }
  //endregion
  //region Unit helpers
  /**
   * Turns `(10, 'day')` into `'10 days'` etc.
   * @param {Number} count Amount of unit
   * @param {String} unit Unit, will be normalized (days, d -> day etc.)
   * @returns {String} Amount formatted to string
   * @category Unit helpers
   */
  static formatCount(count, unit) {
    unit = DH.normalizeUnit(unit);
    if (count !== 1)
      unit += "s";
    return count + " " + unit;
  }
  /**
   * Get the ratio between two units ( year, month -> 1/12 ).
   * @param {String} baseUnit Base time unit
   * @param {String} unit Time unit
   * @param {Boolean} [acceptEstimate=false] If `true`, process negative values of validConversions
   * @returns {Number} Ratio
   * @category Unit helpers
   */
  static getUnitToBaseUnitRatio(baseUnit, unit, acceptEstimate = false) {
    baseUnit = DH.normalizeUnit(baseUnit);
    unit = DH.normalizeUnit(unit);
    if (baseUnit === unit)
      return 1;
    if (validConversions[baseUnit] && validConversions[baseUnit][unit] && (acceptEstimate || validConversions[baseUnit][unit] > 0)) {
      return 1 / DH.as(unit, 1, baseUnit);
    }
    if (validConversions[unit] && validConversions[unit][baseUnit] && (acceptEstimate || validConversions[unit][baseUnit] > 0)) {
      return DH.as(baseUnit, 1, unit);
    }
    return -1;
  }
  /**
   * Returns a localized abbreviated form of the name of the duration unit.
   * For example in the `EN` locale, for `'qrt'` it will return `'q'`.
   * @param {String} unit Duration unit
   * @returns {String} Localized abbreviated form of the name of the duration unit
   * @category Unit helpers
   */
  static getShortNameOfUnit(unit) {
    unit = DH.parseTimeUnit(unit);
    return DH.unitLookup[unit].abbrev;
  }
  /**
   * Returns a localized full name of the duration unit.
   *
   * For example in the `EN` locale, for `'d'` it will return either
   * `'day'` or `'days'`, depending on the `plural` argument
   *
   * Preserves casing of first letter.
   *
   * @static
   * @param {String} unit Time unit
   * @param {Boolean} [plural=false] Whether to return a plural name or singular
   * @returns {String} Localized full name of the duration unit
   * @category Unit helpers
   */
  static getLocalizedNameOfUnit(unit, plural = false) {
    const capitalize = unit.charAt(0) === unit.charAt(0).toUpperCase();
    unit = DH.normalizeUnit(unit);
    unit = DH.parseTimeUnit(unit);
    unit = DH.unitLookup[unit][plural ? "plural" : "single"];
    if (capitalize) {
      unit = StringHelper.capitalize(unit);
    }
    return unit;
  }
  /**
   * Normalizes a unit for easier usage in conditionals. For example `'year'`, `'years'`, `'y'` -> `'year'`.
   * @param {String} unit Time unit
   * @returns {String} Normalized unit name
   * @category Unit helpers
   */
  static normalizeUnit(unit) {
    if (!unit) {
      return null;
    }
    const unitLower = unit.toLowerCase();
    if (unitLower === "date") {
      return unitLower;
    }
    return canonicalUnitNames.includes(unitLower) ? unitLower : normalizedUnits[unit] || normalizedUnits[unitLower];
  }
  static getUnitByName(name) {
    return DH.normalizeUnit(name) || DH.normalizeUnit(DH.parseTimeUnit(name));
  }
  /**
   * Returns a duration of the timeframe in the given unit.
   * @param {Date} start The start date of the timeframe
   * @param {Date} end The end date of the timeframe
   * @param {String} unit Duration unit
   * @privateparam {Boolean} [doNotRound]
   * @returns {Number} The duration in the units
   * @category Unit helpers
   * @ignore
   */
  static getDurationInUnit(start, end, unit, doNotRound) {
    return DH.diff(start, end, unit, doNotRound);
  }
  /**
   * Checks if two date units align.
   * @private
   * @param {String} majorUnit Major time unit
   * @param {String} minorUnit Minor time unit
   * @returns {Boolean} `true` if two date units align
   * @category Unit helpers
   */
  static doesUnitsAlign(majorUnit, minorUnit) {
    return !(majorUnit !== minorUnit && minorUnit === "week");
  }
  static getSmallerUnit(unit) {
    return canonicalUnitNames[unitMagnitudes[DH.normalizeUnit(unit)] - 1] || null;
  }
  static getLargerUnit(unit) {
    return canonicalUnitNames[unitMagnitudes[DH.normalizeUnit(unit)] + 1] || null;
  }
  /**
   *
   * Rounds the passed Date value to the nearest `increment` value.
   *
   * Optionally may round relative to a certain base time point.
   *
   * For example `DH.round(new Date('2020-01-01T09:35'), '30 min', new Date('2020-01-01T09:15'))`
   * would round to 9:45 because that's the nearest integer number of 30 minute increments
   * from the base.
   *
   * Note that `base` is ignored when rounding to weeks. The configured {@link #property-weekStartDay-static}
   * dictates what the base of a week is.
   *
   * @param {Date} time The time to round
   * @param {String|Number} increment A millisecond value by which to round the time
   * May be specified in string form eg: `'15 minutes'`
   * @param {Date} [base] The start from which to apply the rounding
   * @param {Number} [weekStartDay] Will default to what is set in locale
   * @returns {Date} New Date instance
   */
  static round(time, increment, base, weekStartDay) {
    return DH.snap("round", time, increment, base, weekStartDay);
  }
  /**
   *
   * Floor the passed Date value to the nearest `increment` value.
   *
   * Optionally may floor relative to a certain base time point.
   *
   * For example `DH.floor(new Date('2020-01-01T09:35'), '30 min', new Date('2020-01-01T09:15'))`
   * would floor to 9:15 because that's the closest lower integer number of 30 minute increments
   * from the base.
   *
   * Note that `base` is ignored when flooring to weeks. The configured {@link #property-weekStartDay-static}
   * dictates what the base of a week is.
   *
   * @param {Date} time The time to floor
   * @param {String|Number|DurationConfig|Object} increment A numeric millisecond value by which to floor the time.
   * or a duration in string form eg `'30 min'` or object form : `{unit: 'minute', magnitude: 30}`
   * or `{unit: 'minute', increment: 30}`
   * @param {Date} [base] The start from which to apply the flooring
   * @param {Number} [weekStartDay] Will default to what is set in locale
   * @returns {Date} New Date instance
   */
  static floor(time, increment, base, weekStartDay) {
    return DH.snap("floor", time, increment, base, weekStartDay);
  }
  /**
   *
   * Ceils the passed Date value to the nearest `increment` value.
   *
   * Optionally may ceil relative to a certain base time point.
   *
   * For example `DH.ceil(new Date('2020-01-01T09:35'), '30 min', new Date('2020-01-01T09:15'))`
   * would ceil to 9:45 because that's the closest higher integer number of 30 minute increments
   * from the base.
   *
   * Note that `base` is ignored when ceiling to weeks. Use weekStartDay argument which default to the configured
   * {@link #property-weekStartDay-static} dictates what the base of a week is
   *
   * @param {Date} time The time to ceil
   * @param {String|Number|DurationConfig|Object} increment A numeric millisecond value by which to ceil the time
   * or a duration in string form eg `'30 min'` or object form : `{unit: 'minute', magnitude: 30}`
   * or `{unit: 'minute', increment: 30}`
   * @param {Date} [base] The start from which to apply the ceiling
   * @param {Number} [weekStartDay] Will default to what is set in locale
   * @returns {Date} New Date instance
   */
  static ceil(time, increment, base, weekStartDay) {
    return DH.snap("ceil", time, increment, base, weekStartDay);
  }
  /**
   * Implementation for round, floor and ceil.
   * @internal
   */
  static snap(operation, time, increment, base, weekStartDay = DH.weekStartDay) {
    const snapFn = snapFns[operation];
    if (typeof increment === "string") {
      increment = DH.parseDuration(increment);
    }
    if (Objects.isObject(increment)) {
      const magnitude = increment.magnitude || increment.increment;
      switch (increment.unit) {
        case "week": {
          const weekDay = time.getDay();
          base = DH.add(
            DH.clearTime(time),
            weekDay >= weekStartDay ? weekStartDay - weekDay : -(weekDay - weekStartDay + 7),
            "day"
          );
          return DH[operation](time, `${magnitude * 7} days`, base);
        }
        case "month": {
          time = DH.asMonths(time);
          let resultMonths;
          if (base) {
            base = DH.asMonths(base);
            resultMonths = time + snapFn(time - base, magnitude);
          } else {
            resultMonths = snapFn(time, magnitude);
          }
          return DH.monthsToDate(resultMonths);
        }
        case "quarter":
          return DH[operation](time, `${magnitude * 3} months`, base);
        case "year":
          return DH[operation](time, `${magnitude * 12} months`, base);
        case "decade":
          return DH[operation](time, `${magnitude * 10} years`, base);
      }
      increment = DH.as("ms", magnitude, increment.unit);
    }
    if (base) {
      const tzChange = DH.as("ms", base.getTimezoneOffset() - time.getTimezoneOffset(), "ms");
      return new Date(base.valueOf() + snapFn(DH.diff(base, time, "ms") + tzChange, increment));
    } else {
      const offset = time.getTimezoneOffset() * 60 * 1e3;
      return new Date(snapFn(time.valueOf() - offset, increment) + offset);
    }
  }
  //endregion
  //region Date picker format
  /**
   * Parses a typed duration value according to locale rules.
   *
   * The value is taken to be a string consisting of the numeric magnitude and the units:
   * - The numeric magnitude can be either an integer or a float value. Both `','` and `'.'` are valid decimal separators.
   * - The units may be a recognised unit abbreviation of this locale or the full local unit name.
   *
   * For example:
   * `'2d'`, `'2 d'`, `'2 day'`, `'2 days'` will be turned into `{ magnitude : 2, unit : 'day' }`
   * `'2.5d'`, `'2,5 d'`, `'2.5 day'`, `'2,5 days'` will be turned into `{ magnitude : 2.5, unit : 'day' }`
   *
   * **NOTE:** Doesn't work with complex values like `'2 days, 2 hours'`
   *
   * @param {String} value The value to parse
   * @param {Boolean} [allowDecimals=true] Decimals are allowed in the magnitude
   * @param {String} [defaultUnit] Default unit to use if only magnitude passed
   * @returns {DurationConfig} If successfully parsed, the result contains two properties, `magnitude` being a number, and
   * `unit` being the canonical unit name, *NOT* a localized name. If parsing was unsuccessful, `null` is returned
   * @category Parse & format
   */
  static parseDuration(value, allowDecimals = true, defaultUnit) {
    var _a2;
    const durationRegEx = allowDecimals ? withDecimalsDurationRegex : noDecimalsDurationRegex, match = durationRegEx.exec(value);
    if (value == null || !match) {
      return null;
    }
    const magnitude = parseNumber((_a2 = match[1]) == null ? void 0 : _a2.replace(",", ".")), unit = DH.parseTimeUnit(match[2]) || defaultUnit;
    if (!unit) {
      return null;
    }
    return {
      magnitude,
      unit
    };
  }
  /**
   * Parses a typed unit name, for example `'ms'` or `'hr'` or `'yr'` into the
   * canonical form of the unit name which may be passed to {@link #function-add-static}
   * or {@link #function-diff-static}.
   * @param {*} unitName Time unit name
   * @category Parse & format
   */
  static parseTimeUnit(unitName) {
    const unitMatch = unitName == null ? null : DH.durationRegEx.exec(unitName.toLowerCase());
    if (!unitMatch) {
      return null;
    }
    for (let unitOrdinal = 0; unitOrdinal < canonicalUnitNames.length; unitOrdinal++) {
      if (unitMatch[unitOrdinal + 1]) {
        return canonicalUnitNames[unitOrdinal];
      }
    }
  }
  //endregion
  //region Internal
  static getGMTOffset(date = /* @__PURE__ */ new Date()) {
    if (!date) {
      return;
    }
    const offsetInMinutes = date.getTimezoneOffset();
    if (!offsetInMinutes)
      return "Z";
    return (offsetInMinutes > 0 ? "-" : "+") + Math.abs(Math.trunc(offsetInMinutes / 60)).toString().padStart(2, "0") + ":" + Math.abs(offsetInMinutes % 60).toString().padStart(2, "0");
  }
  static fillDayNames() {
    const tempDate2 = /* @__PURE__ */ new Date("2000-01-01T12:00:00"), dayNames = DH._dayNames || [], dayShortNames = DH._dayShortNames || [];
    dayNames.length = 0;
    dayShortNames.length = 0;
    for (let day2 = 2; day2 < 9; day2++) {
      tempDate2.setDate(day2);
      dayNames.push(DH.format(tempDate2, "dddd"));
      dayShortNames.push(DH.format(tempDate2, "ddd"));
    }
    DH._dayNames = dayNames;
    DH._dayShortNames = dayShortNames;
  }
  static getDayNames() {
    return DH._dayNames;
  }
  static getDayName(day2) {
    return DH._dayNames[day2];
  }
  static getDayShortNames() {
    return DH._dayShortNames;
  }
  static getDayShortName(day2) {
    return DH._dayShortNames[day2];
  }
  static fillMonthNames() {
    const tempDate2 = /* @__PURE__ */ new Date("2000-01-15T12:00:00"), monthNames = DH._monthNames || [], monthShortNames = DH._monthShortNames || [], monthNamesIndex = {}, monthShortNamesIndex = {};
    monthNames.length = 0;
    monthShortNames.length = 0;
    for (let month2 = 0; month2 < 12; month2++) {
      tempDate2.setMonth(month2);
      const monthName = DH.format(tempDate2, "MMMM");
      monthNames.push(monthName);
      const monthShortName = DH.format(tempDate2, "MMM");
      monthShortNames.push(monthShortName);
      monthNamesIndex[monthName.toLowerCase()] = { name: monthName, value: month2 };
      monthShortNamesIndex[monthShortName.toLowerCase()] = { name: monthShortName, value: month2 };
    }
    DH._monthNames = monthNames;
    DH._monthShortNames = monthShortNames;
    DH._monthNamesIndex = monthNamesIndex;
    DH._monthShortNamesIndex = monthShortNamesIndex;
  }
  static getMonthShortNames() {
    return DH._monthShortNames;
  }
  static getMonthShortName(month2) {
    return DH._monthShortNames[month2];
  }
  static getMonthNames() {
    return DH._monthNames;
  }
  static getMonthName(month2) {
    return DH._monthNames[month2];
  }
  static set locale(name) {
    locale2 = name;
    intlFormatterCache = {};
    formatCache = {};
    formatRedirects = {};
  }
  static get locale() {
    return locale2;
  }
  static setupDurationRegEx(unitNames = [], unitAbbreviations = []) {
    const me = this, unitLookup = {};
    let unitAbbrRegEx = "";
    for (let i = 0; i < unitAbbreviations.length; i++) {
      const abbreviations = unitAbbreviations[i], unitNamesCfg = unitNames[i];
      unitNamesCfg.canonicalUnitName = canonicalUnitNames[i];
      unitLookup[unitNamesCfg.single] = unitLookup[unitNamesCfg.single.toUpperCase()] = unitLookup[unitNamesCfg.canonicalUnitName] = unitLookup[unitNamesCfg.canonicalUnitName.toUpperCase()] = unitNamesCfg;
      unitAbbrRegEx += `${i ? "|" : ""}(`;
      for (let j = 0; j < abbreviations.length; j++) {
        unitAbbrRegEx += `${abbreviations[j]}|`;
      }
      locale2 = me.localize("L{locale}") || "en-US";
      if (locale2 !== "en-US") {
        const canonicalAbbreviations = canonicalUnitAbbreviations[i];
        for (let j = 0; j < canonicalAbbreviations.length; j++) {
          unitAbbrRegEx += `${canonicalAbbreviations[j]}|`;
        }
      }
      unitAbbrRegEx += `${unitNamesCfg.single}|${unitNamesCfg.plural}|${unitNamesCfg.canonicalUnitName}|${unitNamesCfg.canonicalUnitName}s)`;
    }
    me.unitLookup = unitLookup;
    me.durationRegEx = new RegExp(`^(?:${unitAbbrRegEx})$`);
  }
  static applyLocale() {
    const me = this, unitAbbreviations = me.localize("L{unitAbbreviations}") || [], unitNames = me.unitNames = me.localize("L{unitNames}");
    if (unitNames === "unitNames") {
      return;
    }
    locale2 = me.localize("L{locale}") || "en-US";
    if (locale2 === "en-US") {
      ordinalSuffix = enOrdinalSuffix;
    } else {
      ordinalSuffix = me.localize("L{ordinalSuffix}") || ordinalSuffix;
    }
    formatCache = {};
    formatRedirects = {};
    parserCache = {};
    intlFormatterCache = {};
    DH._weekStartDay = null;
    DH.setupDurationRegEx(unitNames, unitAbbreviations);
    DH.fillDayNames();
    DH.fillMonthNames();
  }
  //endregion
};
var DateHelper = _DateHelper;
__publicField(DateHelper, "MS_PER_DAY", MS_PER_HOUR * 24);
var DH = DateHelper;
DH.useIntlFormat = useIntlFormat;
LocaleManager_default.ion({
  locale: "applyLocale",
  prio: 1e3,
  thisObj: DH
});
if (LocaleManager_default.locale) {
  DH.applyLocale();
}
DateHelper._$name = "DateHelper";

// ../chronograph/src/replica/Reference.js
var __decorate4 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ReferenceField = class extends Mixin([Field], (base) => class ReferenceField extends base {
  constructor() {
    super(...arguments);
    this.identifierCls = MinimalReferenceIdentifier;
  }
}) {
};
var reference = (fieldConfig, fieldCls = ReferenceField) => generic_field(fieldConfig, fieldCls);
var ReferenceIdentifier = class extends Mixin([FieldIdentifier], (base) => {
  class ReferenceIdentifier2 extends base {
    constructor() {
      super(...arguments);
      this.field = void 0;
      this.proposedValueIsBuilt = true;
    }
    hasBucket() {
      return Boolean(this.field.bucket);
    }
    getBucket(entity2) {
      return entity2.$[this.field.bucket];
    }
    buildProposedValue(me, quark, transaction) {
      const proposedValue = quark.proposedValue;
      if (proposedValue === null)
        return null;
      const value = isInstanceOf(proposedValue, Entity) ? proposedValue : me.resolve(proposedValue);
      if (value && me.hasBucket()) {
        me.getBucket(value).addToBucket(transaction, me.self);
      }
      return value;
    }
    resolve(locator) {
      const resolver = this.field.resolver;
      return resolver ? resolver.call(this.self, locator) : null;
    }
    enterGraph(graph) {
      if (this.hasBucket()) {
        const value = graph.activeTransaction.readProposedOrPrevious(this);
        if (value instanceof Entity) {
          this.getBucket(value).addToBucket(graph.activeTransaction, this.self);
        }
      }
      super.enterGraph(graph);
    }
    leaveGraph(graph) {
      if (this.hasBucket()) {
        const value = graph.activeTransaction.readProposedOrPrevious(this);
        if (value instanceof Entity) {
          this.getBucket(value).removeFromBucket(graph.activeTransaction, this.self);
        }
      }
      super.leaveGraph(graph);
    }
    write(me, transaction, q, proposedValue, ...args) {
      const quark = q || transaction.acquireQuarkIfExists(me);
      if (me.hasBucket()) {
        if (quark) {
          const prevValue = quark.getValue();
          if (prevValue instanceof Entity) {
            me.getBucket(prevValue).removeFromBucket(transaction, me.self);
          }
        } else if (transaction.baseRevision.hasIdentifier(me)) {
          const value = transaction.readPrevious(me);
          if (value instanceof Entity) {
            me.getBucket(value).removeFromBucket(transaction, me.self);
          }
        }
      }
      super.write(me, transaction, q, proposedValue);
    }
  }
  __decorate4([
    prototypeValue(Levels.DependsOnlyOnUserInput)
  ], ReferenceIdentifier2.prototype, "level", void 0);
  __decorate4([
    prototypeValue(QuarkSync)
  ], ReferenceIdentifier2.prototype, "quarkClass", void 0);
  return ReferenceIdentifier2;
}) {
};
var MinimalReferenceIdentifier = class extends ReferenceIdentifier.mix(FieldIdentifier.mix(CalculatedValueSync)) {
};

// ../chronograph/src/replica/ReferenceBucket.js
var __decorate5 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ReferenceBucketField = class extends Mixin([Field], (base) => class ReferenceBucketField extends base {
  constructor() {
    super(...arguments);
    this.persistent = false;
    this.identifierCls = MinimalReferenceBucketIdentifier;
  }
}) {
};
var bucket = (fieldConfig, fieldCls = ReferenceBucketField) => generic_field(fieldConfig, fieldCls);
var BucketMutationType;
(function(BucketMutationType2) {
  BucketMutationType2["Add"] = "Add";
  BucketMutationType2["Remove"] = "Remove";
})(BucketMutationType || (BucketMutationType = {}));
var ReferenceBucketQuark = class extends Mixin([Quark], (base) => class ReferenceBucketQuark extends base {
  constructor() {
    super(...arguments);
    this.mutations = [];
    this.previousValue = void 0;
  }
  hasProposedValueInner() {
    return this.mutations.length > 0;
  }
}) {
};
var MinimalReferenceBucketQuark = ReferenceBucketQuark.mix(QuarkSync);
var ReferenceBucketIdentifier = class extends Mixin([FieldIdentifier], (base) => {
  class ReferenceBucketIdentifier2 extends base {
    constructor() {
      super(...arguments);
      this.proposedValueIsBuilt = true;
    }
    addToBucket(transaction, entity2) {
      const quark = transaction.getWriteTarget(this);
      quark.mutations.push({ type: BucketMutationType.Add, entity: entity2 });
      const baseRevision = transaction.baseRevision;
      if (!quark.previousValue && baseRevision.hasIdentifier(this))
        quark.previousValue = transaction.readPrevious(this);
    }
    removeFromBucket(transaction, entity2) {
      const preQuark = transaction.entries.get(this);
      if (preQuark && preQuark.getValue() === TombStone)
        return;
      const quark = transaction.getWriteTarget(this);
      quark.mutations.push({ type: BucketMutationType.Remove, entity: entity2 });
      const baseRevision = transaction.baseRevision;
      if (!quark.previousValue && baseRevision.hasIdentifier(this))
        quark.previousValue = transaction.readPrevious(this);
    }
    buildProposedValue(me, quarkArg, transaction) {
      const quark = quarkArg;
      const newValue = new Set(quark.previousValue);
      for (let i = 0; i < quark.mutations.length; i++) {
        const { type, entity: entity2 } = quark.mutations[i];
        if (type === BucketMutationType.Remove) {
          newValue.delete(entity2);
        } else if (type === BucketMutationType.Add) {
          newValue.add(entity2);
        }
      }
      return newValue;
    }
    leaveGraph(graph) {
      super.leaveGraph(graph);
      this.DATA = void 0;
    }
  }
  __decorate5([
    prototypeValue(Levels.DependsOnlyOnDependsOnlyOnUserInput)
  ], ReferenceBucketIdentifier2.prototype, "level", void 0);
  __decorate5([
    prototypeValue(MinimalReferenceBucketQuark)
  ], ReferenceBucketIdentifier2.prototype, "quarkClass", void 0);
  return ReferenceBucketIdentifier2;
}) {
};
var MinimalReferenceBucketIdentifier = class extends ReferenceBucketIdentifier.mix(FieldIdentifier.mix(CalculatedValueSync)) {
};

// ../Engine/lib/Engine/chrono/ModelFieldAtom.js
var __decorate6 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var isSerializableEqual = function(oldValue, newValue) {
  return oldValue === newValue || ((newValue == null ? void 0 : newValue.isBase) ? this.serialize(newValue) : newValue) === ((oldValue == null ? void 0 : oldValue.isBase) ? this.serialize(oldValue) : oldValue);
};
var ModelField = class extends Field {
  constructor() {
    super(...arguments);
    this.modelFieldConfig = {};
  }
  getIdentifierClass(calculationFunction) {
    if (this.identifierCls)
      return this.identifierCls;
    if (!calculationFunction)
      return MinimalChronoModelFieldVariable;
    return isGeneratorFunction(calculationFunction) ? MinimalChronoModelFieldIdentifierGen : MinimalChronoModelFieldIdentifierSync;
  }
};
var ModelReferenceField = class extends ReferenceField.mix(ModelField) {
  constructor() {
    super(...arguments);
    this.identifierCls = ChronoModelReferenceFieldIdentifier;
  }
};
var ModelBucketField = class extends ReferenceBucketField.mix(Field) {
  constructor() {
    super(...arguments);
    this.identifierCls = ChronoModelReferenceBucketFieldIdentifier;
  }
};
var IsChronoModelSymbol = Symbol("IsChronoModelSymbol");
var ChronoModelFieldIdentifier = class extends Mixin([FieldIdentifier], (base) => {
  const superProto = base.prototype;
  class ChronoModelFieldIdentifier2 extends base {
    [IsChronoModelSymbol]() {
    }
    getFromGraph(graph) {
      var _a2, _b;
      if (graph) {
        if (graph.readMode === ReadMode.CurrentOrProposedOrPrevious) {
          const higherLevel = graph.isCommitting && this.level > ((_b = (_a2 = graph.activeTransaction.getActiveEntry()) == null ? void 0 : _a2.level) != null ? _b : Number.MAX_SAFE_INTEGER);
          if (this.sync && !this.context.project.isDelayingCalculation && !higherLevel)
            return graph.get(this);
          else
            return graph.activeTransaction.readCurrentOrProposedOrPrevious(this);
        }
        return superProto.getFromGraph.call(this, graph);
      } else
        return this.DATA;
    }
    writeToGraph(graph, proposedValue, ...args) {
      if (graph) {
        superProto.writeToGraph.call(this, graph, proposedValue, ...args);
      } else {
        this.DATA = proposedValue;
        if (!this.self.inSetting && !this.self.isConstructing) {
          this.self.set(this.field.name, proposedValue, false, false, true);
        }
      }
    }
    write(me, transaction, quark, proposedValue, ...args) {
      proposedValue = me.convert(proposedValue);
      superProto.write.call(this, me, transaction, quark, proposedValue, ...args);
    }
    convert(value) {
      const field2 = this.field;
      const fieldDefinition = this.self.getFieldDefinition(field2.name);
      if (fieldDefinition == null ? void 0 : fieldDefinition.convert) {
        value = fieldDefinition.convert(value, this.context.data, this.context);
      } else if (field2.converter) {
        value = field2.converter(value, field2);
      }
      return value;
    }
    equality(v1, v2) {
      if (v1 instanceof Date && v2 instanceof Date)
        return v1.getTime() === v2.getTime();
      return v1 === v2;
    }
  }
  __decorate6([
    prototypeValue(false)
  ], ChronoModelFieldIdentifier2.prototype, "sync", void 0);
  return ChronoModelFieldIdentifier2;
}) {
};
var ChronoModelReferenceFieldQuark = class extends Mixin([QuarkSync], (base) => {
  const superProto = base.prototype;
  class ChronoModelReferenceFieldQuark2 extends base {
    setValue(value) {
      superProto.setValue.call(this, value);
      if (value !== TombStone)
        this.identifier.DATA = value;
    }
  }
  return ChronoModelReferenceFieldQuark2;
}) {
};
var ChronoModelReferenceFieldIdentifier = class extends ReferenceIdentifier.mix(ChronoModelFieldIdentifier.mix(MinimalFieldIdentifierSync)) {
  buildProposedValue(me, q, transaction) {
    const quark = q;
    const proposedValue = quark.proposedValue;
    if (proposedValue === null || proposedValue === void 0) {
      transaction.candidate.failedResolutionReferences.delete(quark.identifier);
      return null;
    }
    if (isInstanceOf(proposedValue, Entity) && proposedValue.graph) {
      if (me.hasBucket())
        me.getBucket(proposedValue).addToBucket(transaction, me.self);
      transaction.candidate.failedResolutionReferences.delete(quark.identifier);
      return proposedValue;
    }
    const resolved = me.resolve(proposedValue);
    if (isInstanceOf(resolved, Entity) && resolved.graph) {
      if (me.hasBucket())
        me.getBucket(resolved).addToBucket(transaction, me.self);
      transaction.candidate.failedResolutionReferences.delete(quark.identifier);
      return resolved;
    } else {
      transaction.candidate.failedResolutionReferences.set(quark.identifier, proposedValue);
      return null;
    }
  }
};
__decorate6([
  prototypeValue(true)
], ChronoModelReferenceFieldIdentifier.prototype, "sync", void 0);
__decorate6([
  prototypeValue(ChronoModelReferenceFieldQuark)
], ChronoModelReferenceFieldIdentifier.prototype, "quarkClass", void 0);
var ChronoModelReferenceBucketFieldIdentifier = class extends ReferenceBucketIdentifier.mix(ChronoModelFieldIdentifier.mix(MinimalFieldIdentifierSync)) {
};
__decorate6([
  prototypeValue(true)
], ChronoModelReferenceBucketFieldIdentifier.prototype, "sync", void 0);
var MinimalChronoModelFieldIdentifierSync = class extends ChronoModelFieldIdentifier.mix(MinimalFieldIdentifierSync) {
};
var MinimalChronoModelFieldIdentifierGen = class extends ChronoModelFieldIdentifier.mix(MinimalFieldIdentifierGen) {
};
var MinimalChronoModelFieldVariable = class extends ChronoModelFieldIdentifier.mix(MinimalFieldVariable) {
};
var model_field = function(modelFieldConfig = {}, chronoFieldConfig = {}, chronoFieldClass = ModelField) {
  return function(target, propertyKey) {
    const decoratorFn = generic_field({ modelFieldConfig, ...chronoFieldConfig }, chronoFieldClass);
    decoratorFn(target, propertyKey);
    injectStaticFieldsProperty(target.constructor);
  };
};
var injectStaticFieldsProperty = (prototype2) => {
  if (!prototype2.hasOwnProperty("fields")) {
    Object.defineProperty(prototype2, "fields", {
      get: function() {
        return getDecoratedModelFields(this);
      }
    });
  }
};
var getDecoratedModelFields = (constr) => {
  const proto3 = constr.prototype;
  const result = [];
  if (proto3.hasOwnProperty("$entity")) {
    proto3.$entity.ownFields.forEach((field2) => {
      if (field2 instanceof ModelField) {
        const config = field2.modelFieldConfig || {};
        if (!config.convert && field2.converter && field2.converter !== dateConverter) {
          config.convert = field2.converter;
        }
        result.push(Object.assign(config, {
          $chrono: field2,
          name: field2.name
        }));
      }
    });
  }
  return result;
};
var dateConverter = (date, field2) => {
  var _a2, _b;
  if (date === null) {
    return null;
  }
  if (!(date instanceof Date)) {
    date = DateHelper.parse(date, ((_a2 = field2.modelFieldConfig) == null ? void 0 : _a2.format) || ((_b = field2.modelFieldConfig) == null ? void 0 : _b.dateFormat) || DateHelper.defaultParseFormat);
  }
  return date || void 0;
};

// ../Engine/lib/Engine/chrono/SchedulingIssueEffect.js
var __decorate7 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var EffectResolutionResult;
(function(EffectResolutionResult2) {
  EffectResolutionResult2["Cancel"] = "Cancel";
  EffectResolutionResult2["Resume"] = "Resume";
})(EffectResolutionResult || (EffectResolutionResult = {}));
var SchedulingIssueEffectResolution = class extends Base2 {
  /**
   * Returns the resolution description.
   */
  getDescription() {
    throw new Error("Abstract method");
  }
  /**
   * Resolves the [[SchedulingIssueEffect|scheduling issue]].
   */
  resolve(...args) {
    throw new Error("Abstract method");
  }
};
var SchedulingIssueEffect = class extends Effect {
  /**
   * Returns the list of possible effect resolutions.
   */
  getResolutions() {
    return this._resolutions;
  }
  getDescriptionBuilderClass() {
    return this._descriptionBuilderClass;
  }
  setDescriptionBuilderClass(cls) {
    this._descriptionBuilderClass = cls;
  }
  /**
   * Returns the effect human readable description.
   */
  getDescription() {
    return this.getDescriptionBuilderClass().getDescription(this);
  }
};
__decorate7([
  prototypeValue("schedulingIssueEffect")
], SchedulingIssueEffect.prototype, "type", void 0);
__decorate7([
  prototypeValue(false)
], SchedulingIssueEffect.prototype, "sync", void 0);

// ../Engine/lib/Engine/util/Functions.js
var isNotNumber = (value) => Number(value) !== value;
var CIFromSetOrArrayOrValue = (value) => {
  if (value instanceof Set || value instanceof Array)
    return CI(value);
  return CI([value]);
};
var delay2 = (value) => new Promise((resolve) => setTimeout(resolve, value));
var format = (format2, ...values) => {
  return format2.replace(/{(\d+)}/g, (match, number) => typeof values[number] !== "undefined" ? values[number] : match);
};

// ../Core/lib/Core/helper/ObjectHelper.js
var { hasOwn: hasOwn2 } = Objects;
var toFixedFix = 1.005.toFixed(2) === "1.01" ? null : function(number, fractionDigits) {
  const split2 = number.toString().split("."), newNumber = +(!split2[1] ? split2[0] : split2.join(".") + "1");
  return number.toFixed.call(newNumber, fractionDigits);
};
var ObjectHelper = class extends Objects {
  // These methods are inherited from Objects (an internal class) but need to be documented here for public use.
  // This is primarily because static methods, while inherited by JavaScript classes, are not displayed in derived
  // classes in the docs.
  /**
   * Copies all enumerable properties from the supplied source objects to `dest`. Unlike `Object.assign`, this copy
   * also includes inherited properties.
   * @param {Object} dest The destination object.
   * @param {...Object} sources The source objects.
   * @returns {Object} The `dest` object.
   * @method assign
   * @static
   */
  /**
   * Copies all enumerable properties from the supplied source objects to `dest`, only including properties that does
   * not already exist on `dest`. Unlike `Object.assign`, this copy also includes inherited properties.
   * @param {Object} dest The destination object.
   * @param {...Object} sources The source objects.
   * @returns {Object} The `dest` object.
   * @method assignIf
   * @static
   */
  /**
   * Creates a deep copy of the `value`. Simple objects ({@link #function-isObject-static}, arrays and `Date` objects
   * are cloned. The enumerable properties of simple objects and the elements of arrays are cloned recursively.
   * @param {*} value The value to clone.
   * @param {Function} [handler] An optional function to call for values of types other than simple object, array or
   * `Date`. This function should return the clone of the `value` passed to it. It is only called for truthy values
   * whose `typeof` equals `'object'`.
   * @param {*} handler.value The value to clone.
   * @returns {*} The cloned value.
   * @method clone
   * @static
   */
  /**
   * Converts a list of names (either a space separated string or an array), into an object with those properties
   * assigned truthy values. The converse of {@link #function-getTruthyKeys-static}.
   * @param {String|String[]} source The list of names to convert to object form.
   * @method createTruthyKeys
   * @static
   */
  /**
   * Gathers the names of properties which have truthy values into an array.
   *
   * This is useful when gathering CSS class names for complex element production.
   * Instead of appending to an array or string which may already contain the
   * name, and instead of contending with space separation and concatenation
   * and conditional execution, just set the properties of an object:
   *
   *     cls = {
   *         [this.selectedCls] : this.isSelected(thing),
   *         [this.dirtyCls] : this.isDirty(thing)
   *     };
   *
   * @param {Object} source Source of keys to gather into an array.
   * @returns {String[]} The keys which had a truthy value.
   * @method getTruthyKeys
   * @static
   */
  /**
   * Gathers the values of properties which are truthy into an array.
   * @param {Object} source Source of values to gather into an array.
   * @returns {String[]} The truthy values from the passed object.
   * @method getTruthyValues
   * @static
   */
  /**
   * Tests whether a passed object has any enumerable properties.
   * @param {Object} object
   * @returns {Boolean} `true` if the passed object has no enumerable properties.
   * @method isEmpty
   * @static
   */
  /**
   * Returns `true` if the `value` is a simple `Object`.
   * @param {Object} value
   * @returns {Boolean} `true` if the `value` is a simple `Object`.
   * @method isObject
   * @static
   */
  /**
   * Copies all enumerable properties from the supplied source objects to `dest`, recursing when the properties of
   * both the source and `dest` are objects.
   * ```
   *  const o = {
   *      a : 1,
   *      b : {
   *          c : 2
   *      }
   *  };
   *  const o2 = {
   *      b : {
   *          d : 3
   *      }
   *  }
   *
   *  console.log(merge(o, o2));
   *
   *  > { a : 1, b : { c : 2, d : 3 } }
   * ```
   * @param {Object} dest The destination object.
   * @param {...Object} sources The source objects.
   * @returns {Object} The `dest` object.
   * @method merge
   * @static
   */
  /**
   * Returns the specific type of the given `value`. Unlike the `typeof` operator, this function returns the text
   * from the `Object.prototype.toString` result allowing `Date`, `Array`, `RegExp`, and others to be differentiated.
   * ```
   *  console.log(typeOf(null));
   *  > null
   *
   *  console.log(typeOf({}));
   *  > object
   *
   *  console.log(typeOf([]));
   *  > array
   *
   *  console.log(typeOf(new Date()));
   *  > date
   *
   *  console.log(typeOf(NaN));
   *  > nan
   *
   *  console.log(typeOf(/a/));
   *  > regexp
   * ```
   * @param {*} value
   * @returns {String}
   * @method typeOf
   * @static
   */
  /**
   * Returns value for a given path in the object
   * @param {Object} object Object to check path on
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @returns {*} Value associated with passed key
   * @method getPath
   * @static
   */
  /**
   * Sets value for a given path in the object
   * @param {Object} object Target object
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @param {*} value Value for a given path
   * @returns {Object} Returns passed object
   * @method setPath
   * @static
   */
  /**
   * Creates a new object where key is a property in array item (`ref` by default) or index in the array and value is array item.
   *
   * From:
   * ```
   * [
   *     {
   *          text : 'foo',
   *          ref : 'fooItem'
   *     },
   *     {
   *          text : 'bar'
   *     }
   * ]
   * ```
   *
   * To:
   * ```
   * {
   *     fooItem : {
   *         text : 'foo',
   *         ref  : 'fooItem'
   *     },
   *     1 : {
   *         text : 'bar'
   *     }
   * }
   * ```
   *
   * @param {Object[]} arrayOfItems Array to transform.
   * @param {String} [prop] Property to read the key from. `ref` by default.
   * @returns {Object} namedItems
   */
  static transformArrayToNamedObject(arrayOfItems, prop = "ref") {
    const namedItems = {};
    arrayOfItems.forEach((item, index) => {
      const key = item[prop] != null && item[prop].toString().length ? item[prop] : index;
      namedItems[key] = item;
    });
    return namedItems;
  }
  /**
   * Creates a new array from object values and saves key in a property (`ref` by default) of each item.
   *
   * From:
   * ```
   * {
   *     fooItem : {
   *         text : 'foo'
   *     },
   *     1 : {
   *         text : 'bar'
   *     },
   *     barItem : false // will be ignored
   * }
   * ```
   *
   * To:
   * ```
   * [
   *     {
   *          text : 'foo',
   *          ref : 'fooItem'
   *     },
   *     {
   *          text : 'bar',
   *          ref : 1
   *     }
   * ]
   * ```
   *
   * @param {Object} namedItems Object to transform.
   * @param {String} [prop] Property to save the key to. `ref` by default.
   * @returns {Object[]} arrayOfItems
   */
  static transformNamedObjectToArray(namedItems, prop = "ref") {
    return Object.keys(namedItems).filter((key) => namedItems[key]).map((key) => {
      const item = namedItems[key];
      item[prop] = key;
      return item;
    });
  }
  /**
   * Checks if two values are equal. Basically === but special handling of dates.
   * @param {*} a First value
   * @param {*} b Second value
   * @returns {*} true if values are equal, otherwise false
   */
  static isEqual(a, b, useIsDeeply = false) {
    if (a === null && b !== null || a === void 0 && b !== void 0 || b === null && a !== null || b === void 0 && a !== void 0) {
      return false;
    }
    if (a == null && b == null) {
      return true;
    }
    if (a === b) {
      return true;
    }
    const typeA = typeof a, typeB = typeof b;
    if (typeA === typeB) {
      switch (typeA) {
        case "number":
        case "string":
        case "boolean":
          return a === b;
      }
      switch (true) {
        case (a instanceof Date && b instanceof Date):
          return a.getTime() === b.getTime();
        case (Array.isArray(a) && Array.isArray(b)):
          return a.length === b.length ? a.every((v, idx) => OH.isEqual(v, b[idx], useIsDeeply)) : false;
        case (typeA === "object" && a.constructor.prototype === b.constructor.prototype):
          return useIsDeeply ? OH.isDeeplyEqual(a, b, useIsDeeply) : StringHelper.safeJsonStringify(a) === StringHelper.safeJsonStringify(b);
      }
    }
    return String(a) === String(b);
  }
  /**
   * Checks if two objects are deeply equal
   * @param {Object} a
   * @param {Object} b
   * @param {Object} [options] Additional comparison options
   * @param {Object} [options.ignore] Map of property names to ignore when comparing
   * @param {Function} [options.shouldEvaluate] Function used to evaluate if a property should be compared or not.
   * Return false to prevent comparison
   * @param {Function} [options.evaluate] Function used to evaluate equality. Return `true`/`false` as evaluation
   * result or anything else to let `isEqual` handle the comparison
   * @returns {Boolean}
   */
  static isDeeplyEqual(a, b, options = {}) {
    if (a === b) {
      return true;
    }
    if (!a || !b) {
      return false;
    }
    const aKeys = OH.keys(a, options.ignore), bKeys = OH.keys(b, options.ignore);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
    for (let i = 0; i < aKeys.length; i++) {
      const aKey = aKeys[i], bKey = bKeys[i];
      if (aKey !== bKey) {
        return false;
      }
      const aVal = a[aKey], bVal = b[bKey];
      if (options.shouldEvaluate) {
        if (options.shouldEvaluate(
          aKey,
          {
            value: aVal,
            object: a
          },
          {
            value: bVal,
            object: b
          }
        ) === false) {
          continue;
        }
      }
      if (options.evaluate) {
        const result = options.evaluate(aKey, {
          value: aVal,
          object: a
        }, {
          value: bVal,
          object: b
        });
        if (result === false) {
          return false;
        }
        if (result === true) {
          continue;
        }
      }
      if (!OH.isEqual(aVal, bVal, options)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Checks if value B is partially equal to value A.
   * @param {*} a First value
   * @param {*} b Second value
   * @returns {Boolean} true if values are partially equal, false otherwise
   */
  static isPartial(a, b) {
    a = String(a).toLowerCase();
    b = String(b).toLowerCase();
    return a.indexOf(b) !== -1;
  }
  /**
   * Checks if value a is smaller than value b.
   * @param {*} a First value
   * @param {*} b Second value
   * @returns {Boolean} true if a < b
   */
  static isLessThan(a, b) {
    if (a instanceof Date && b instanceof Date) {
      return DateHelper.isBefore(a, b);
    }
    return a < b;
  }
  /**
   * Checks if value a is bigger than value b.
   * @param {*} a First value
   * @param {*} b Second value
   * @returns {Boolean} true if a > b
   */
  static isMoreThan(a, b) {
    if (a instanceof Date && b instanceof Date) {
      return DateHelper.isAfter(a, b);
    }
    return a > b;
  }
  /**
   * Used by the Base class to make deep copies of defaultConfig blocks
   * @private
   */
  static fork(obj) {
    let ret, key, value;
    if (obj && obj.constructor === Object) {
      ret = Object.setPrototypeOf({}, obj);
      for (key in obj) {
        value = obj[key];
        if (value) {
          if (value.constructor === Object) {
            ret[key] = OH.fork(value);
          } else if (value instanceof Array) {
            ret[key] = value.slice();
          }
        }
      }
    } else {
      ret = obj;
    }
    return ret;
  }
  /**
   * Copies the named properties from the `source` parameter into the `dest` parameter.
   * @param {Object} dest The destination into which properties are copied.
   * @param {Object} source The source from which properties are copied.
   * @param {String[]} props The list of property names.
   * @returns {Object} The `dest` object.
   */
  static copyProperties(dest, source, props) {
    let prop, i;
    for (i = 0; i < props.length; i++) {
      prop = props[i];
      if (prop in source) {
        dest[prop] = source[prop];
      }
    }
    return dest;
  }
  /**
   * Copies the named properties from the `source` parameter into the `dest` parameter
   * unless the property already exists in the `dest`.
   * @param {Object} dest The destination into which properties are copied.
   * @param {Object} source The source from which properties are copied.
   * @param {String[]} props The list of property names.
   * @returns {Object} The `dest` object.
   */
  static copyPropertiesIf(dest, source, props) {
    if (source) {
      for (const prop of props) {
        if (!(prop in dest) && prop in source) {
          dest[prop] = source[prop];
        }
      }
    }
    return dest;
  }
  /**
   * Returns an array containing the keys and values of all enumerable properties from every prototype level for the
   * object. If `object` is `null`, this method returns an empty array.
   * @param {Object} object Object from which to retrieve entries.
   * @param {Object|Function} [ignore] Optional object of names to ignore or a function accepting the name and value
   * which returns `true` to ignore the item.
   * @returns {Array}
   * @internal
   */
  static entries(object, ignore) {
    const result = [], call = typeof ignore === "function";
    if (object) {
      for (const p in object) {
        if (call ? !ignore(p, object[p]) : !(ignore == null ? void 0 : ignore[p])) {
          result.push([p, object[p]]);
        }
      }
    }
    return result;
  }
  /**
   * Populates an `object` with the provided `entries`.
   * @param {Array} entries The key/value pairs (2-element arrays).
   * @param {Object} [object={}] The object onto which to add `entries`.
   * @returns {Object} The passed `object` (by default, a newly created object).
   * @internal
   */
  static fromEntries(entries, object) {
    object = object || {};
    if (entries) {
      for (let i = 0; i < entries.length; ++i) {
        object[entries[i][0]] = entries[i][1];
      }
    }
    return object;
  }
  /**
   * Returns an array containing all enumerable property names from every prototype level for the object. If `object`
   * is `null`, this method returns an empty array.
   * @param {Object} object Object from which to retrieve property names.
   * @param {Object|Function} [ignore] Optional object of names to ignore or a function accepting the name and value
   * which returns `true` to ignore the item.
   * @param {Function} [mapper] Optional function to call for each non-ignored item. If provided, the result of this
   * function is stored in the returned array. It is called with the array element as the first parameter, and the
   * index in the result array as the second argument (0 for the first, non-ignored element, 1 for the second and so
   * on).
   * @returns {String[]}
   */
  static keys(object, ignore, mapper) {
    const result = [], call = typeof ignore === "function";
    if (object) {
      let index = 0;
      for (const p in object) {
        if (call ? !ignore(p, object[p]) : !(ignore == null ? void 0 : ignore[p])) {
          result.push(mapper ? mapper(p, index) : p);
          ++index;
        }
      }
    }
    return result;
  }
  /**
   * Returns an array containing the values of all enumerable properties from every prototype level for the object.
   * If `object` is `null`, this method returns an empty array.
   * @param {Object} object Object from which to retrieve values.
   * @param {Object|Function} [ignore] Optional object of names to ignore or a function accepting the name and value
   * which returns `true` to ignore the item.
   * @param {Function} [mapper] Optional function to call for each non-ignored item. If provided, the result of this
   * function is stored in the returned array. It is called with the array element as the first parameter, and the
   * index in the result array as the second argument (0 for the first, non-ignored element, 1 for the second and so
   * on).
   * @returns {Array}
   * @internal
   */
  static values(object, ignore, mapper) {
    const result = [], call = typeof ignore === "function";
    if (object) {
      let index = 0;
      for (const p in object) {
        if (call ? !ignore(p, object[p]) : !(ignore == null ? void 0 : ignore[p])) {
          result.push(mapper ? mapper(object[p], index) : object[p]);
          ++index;
        }
      }
    }
    return result;
  }
  //region Path
  /**
   * Checks if a given path exists in an object
   * @param {Object} object Object to check path on
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @returns {Boolean} Returns `true` if path exists or `false` if it does not
   */
  static pathExists(object, path) {
    const properties = path.split(".");
    return properties.every((property) => {
      if (!object || !(property in object)) {
        return false;
      }
      object = object[property];
      return true;
    });
  }
  /**
   * Creates a simple single level key-value object from complex deep object.
   * @param {Object} object Object to extract path and values from
   * @returns {Object} Key-value object where key is a path to the corresponding value
   * @internal
   *
   * ```javascript
   * // converts deep object
   * {
   *     foo : {
   *         bar : {
   *             test : 1
   *         }
   *     }
   * }
   * // into a single level object
   * {
   *     'foo.bar.test' : 1
   * }
   * ```
   */
  static pathifyKeys(object, fieldDataSourceMap) {
    const result = {};
    for (const key in object) {
      if (hasOwn2(object, key)) {
        const field2 = fieldDataSourceMap == null ? void 0 : fieldDataSourceMap[key];
        const usesPathKeys = (field2 == null ? void 0 : field2.type) === "object" || (field2 == null ? void 0 : field2.complexMapping) || !Boolean(fieldDataSourceMap);
        if (usesPathKeys && Array.isArray(object[key])) {
          result[key] = object[key].slice();
        } else if (usesPathKeys && object[key] instanceof Object) {
          const paths = this.pathifyKeys(object[key]);
          for (const path in paths) {
            result[`${key}.${path}`] = paths[path];
          }
        } else {
          result[key] = object[key];
        }
      }
    }
    return result;
  }
  /**
   * Removes value for a given path in the object. Doesn't cleanup empty objects.
   * @param {Object} object
   * @param {String} path Dot-separated path, e.g. `obj.child.someKey`
   * @internal
   */
  static deletePath(object, path) {
    path.split(".").reduce((result, key, index, array) => {
      if (result == null) {
        return null;
      }
      if (hasOwn2(result, key)) {
        if (index === array.length - 1) {
          delete result[key];
        } else {
          return result[key];
        }
      }
    }, object);
  }
  //endregion
  static coerce(from, to) {
    const fromType = Objects.typeOf(from), toType = Objects.typeOf(to), isString = typeof from === "string";
    if (fromType !== toType) {
      switch (toType) {
        case "string":
          return String(from);
        case "number":
          return Number(from);
        case "boolean":
          return isString && (!from || from === "false" || from === "0") ? false : Boolean(from);
        case "null":
          return isString && (!from || from === "null") ? null : false;
        case "undefined":
          return isString && (!from || from === "undefined") ? void 0 : false;
        case "date":
          return isString && isNaN(from) ? DateHelper.parse(from) : Date(Number(from));
      }
    }
    return from;
  }
  static wrapProperty(object, propertyName, newGetter, newSetter, deep = true) {
    const newProperty = {};
    let proto3 = Object.getPrototypeOf(object), existingProperty = Object.getOwnPropertyDescriptor(proto3, propertyName);
    while (!existingProperty && proto3 && deep) {
      proto3 = Object.getPrototypeOf(proto3);
      if (proto3) {
        existingProperty = Object.getOwnPropertyDescriptor(proto3, propertyName);
      }
    }
    if (existingProperty) {
      if (existingProperty.set) {
        newProperty.set = (v) => {
          existingProperty.set.call(object, v);
          newSetter && newSetter.call(object, existingProperty.get.call(object));
        };
      } else {
        newProperty.set = newSetter;
      }
      if (existingProperty.get) {
        newProperty.get = () => {
          let result = existingProperty.get.call(object);
          if (newGetter) {
            result = newGetter.call(object, result);
          }
          return result;
        };
      } else {
        newProperty.get = newGetter;
      }
    } else {
      newProperty.set = (v) => {
        object[`_${propertyName}`] = v;
        newSetter && newSetter.call(object, v);
      };
      newProperty.get = () => {
        let result = object[`_${propertyName}`];
        if (newGetter) {
          result = newGetter.call(object, result);
        }
        return result;
      };
    }
    Object.defineProperty(object, propertyName, newProperty);
  }
  /**
   * Intercepts access to a `property` of a given `object`.
   *
   * ```javascript
   *      ObjectHelper.hookProperty(object, 'prop', class {
   *          get value() {
   *              return super.value;
   *          }
   *          set value(v) {
   *              super.value = v;
   *          }
   *      });
   * ```
   * The use of `super` allows the hook's getter and setter to invoke the object's existing get/set.
   *
   * @param {Object} object
   * @param {String} property
   * @param {Function} hook A `class` defining a `value` property getter and/or setter.
   * @returns {Function} A function that removes the hook when called.
   * @internal
   */
  static hookProperty(object, property, hook) {
    const desc = ObjectHelper.getPropertyDescriptor(hook.prototype, "value"), existingDesc = ObjectHelper.getPropertyDescriptor(object, property), fieldName = `_${property}`, base = class {
      get value() {
        return existingDesc ? existingDesc.get.call(this) : this[fieldName];
      }
      set value(v) {
        if (existingDesc) {
          existingDesc.set.call(this, v);
        } else {
          this[fieldName] = v;
        }
      }
    }, baseDesc = ObjectHelper.getPropertyDescriptor(base.prototype, "value");
    Object.setPrototypeOf(hook.prototype, base.prototype);
    Object.defineProperty(object, property, {
      configurable: true,
      get: desc.get || baseDesc.get,
      set: desc.set || baseDesc.set
    });
    return () => delete object[property];
  }
  /**
   * Finds a property descriptor for the passed object from all inheritance levels.
   * @param {Object} object The Object whose property to find.
   * @param {String} propertyName The name of the property to find.
   * @returns {Object} An ECMA property descriptor is the property was found, otherwise `null`
   */
  static getPropertyDescriptor(object, propertyName) {
    let result = null;
    for (let o = object; o && !result && !hasOwn2(o, "isBase"); o = Object.getPrototypeOf(o)) {
      result = Object.getOwnPropertyDescriptor(o, propertyName);
    }
    return result;
  }
  /**
   * Changes the passed object and removes all null and undefined properties from it
   * @param {Object} object Target object
   * @param {Boolean} [keepNull] Pass true to only remove undefined properties
   * @returns {Object} Passed object
   */
  static cleanupProperties(object, keepNull = false) {
    Object.entries(object).forEach(([key, value]) => {
      if (keepNull) {
        value === void 0 && delete object[key];
      } else {
        value == null && delete object[key];
      }
    });
    return object;
  }
  /**
   * Changes the passed object and removes all properties from it.
   * Used while mutating when need to keep reference to the object but replace its properties.
   * @param {Object} object Target object
   * @returns {Object} Passed object
   */
  static removeAllProperties(obj) {
    Object.keys(obj).forEach((key) => delete obj[key]);
    return obj;
  }
  //region Assert type
  /**
   * Checks that the supplied value is of the specified type.Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} type Expected type
   * @param {String} name Name of the value, used in error message
   * @param {Boolean} [allowNull] Accept `null` without throwing
   */
  static assertType(value, type, name) {
    const valueType = Objects.typeOf(value);
    if (value != null && valueType !== type) {
      throw new Error(`Incorrect type "${valueType}" for ${name}, expected "${type}"`);
    }
  }
  /**
   * Checks that the supplied value is a plain object. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertObject(value, name) {
    OH.assertType(value, "object", name);
  }
  /**
   * Checks that the supplied value is an instance of a Bryntum class. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertInstance(value, name) {
    OH.assertType(value, "instance", name);
  }
  /**
   * Checks that the supplied value is a Bryntum class. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertClass(value, name) {
    OH.assertType(value, "class", name);
  }
  /**
   * Checks that the supplied value is a function. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertFunction(value, name) {
    if (typeof value !== "function" || value.isBase || value.$$name) {
      throw new Error(`Incorrect type for ${name}, got "${value}" (expected a function)`);
    }
  }
  /**
   * Checks that the supplied value is a number. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertNumber(value, name) {
    const asNumber = Number(value);
    if (typeof value !== "number" || isNaN(asNumber)) {
      throw new Error(`Incorrect type for ${name}, got "${value}" (expected a Number)`);
    }
  }
  /**
   * Checks that the supplied value is a boolean. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertBoolean(value, name) {
    OH.assertType(value, "boolean", name);
  }
  /**
   * Checks that the supplied value is a string. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertString(value, name) {
    OH.assertType(value, "string", name);
  }
  /**
   * Checks that the supplied value is an array. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertArray(value, name) {
    OH.assertType(value, "array", name);
  }
  //endregion
  /**
   * Number.toFixed(), with polyfill for browsers that needs it
   * @param {Number} number
   * @param {Number} digits
   * @returns {String} A fixed point string representation of the passed number.
   */
  static toFixed(number, digits) {
    if (toFixedFix) {
      return toFixedFix(number, digits);
    }
    return number.toFixed(digits);
  }
  /**
   * Round the passed number to closest passed step value.
   * @param {Number} number The number to round.
   * @param {Number} [step] The step value to round to.
   * @returns {Number} The number rounded to the closest step.
   */
  static roundTo(number, step = 1) {
    return Math.round(number / step) * step;
  }
  /**
   * Round the passed number to the passed number of decimals.
   * @param {Number} number The number to round.
   * @param {Number} digits The number of decimal places to round to.
   * @returns {Number} The number rounded to the passed number of decimal places.
   */
  static round(number, digits) {
    if (digits == null) {
      return number;
    }
    const factor = 10 ** digits;
    return Math.round(number * factor) / factor;
  }
  /**
   * Returns a non-null entry from a Map for a given key path. This enables a specified defaultValue to be added "just
   * in time" which is returned if the key is not already present.
   * @param {Map} map The Map to find the key in (and potentially add to).
   * @param {String|Number|String[]|Number[]} path Dot-separated path, e.g. 'firstChild.childObject.someKey',
   * or the key path as an array, e.g. ['firstChild', 'childObject', 'someKey'].
   * @param {Object} [defaultValue] Optionally the value to insert if the key is not found.
   */
  static getMapPath(map2, path, defaultValue2) {
    const keyPath = Array.isArray(path) ? path : typeof path === "string" ? path.split(".") : [path], simpleKey = keyPath.length === 1, topKey = keyPath[0], topValue = map2.has(topKey) ? map2.get(topKey) : map2.set(topKey, simpleKey ? defaultValue2 : {}).get(topKey);
    if (simpleKey) {
      return topValue;
    }
    return OH.getPathDefault(topValue, keyPath.slice(1), defaultValue2);
  }
};
var OH = ObjectHelper;
ObjectHelper._$name = "ObjectHelper";

// ../Core/lib/Core/data/stm/mixin/ModelStm.js
var STM_PROP = Symbol("STM_PROP");
var unrecordedFields = {
  // This field's value is a by product of node insertion and must not be recorded here.
  // It's the node insertion operation which is recorded by STM.
  parentIndex: 1
};
var ModelStm_default = (Target) => class ModelStm extends (Target || Base2) {
  static get $name() {
    return "ModelStm";
  }
  static get defaultConfig() {
    return {
      stm: null
    };
  }
  joinStore(store) {
    if (!this.stm) {
      this.stm = store.stm;
    }
  }
  unjoinStore(store, isReplacing = false) {
    var _a2;
    if (this.stm === store.stm) {
      this.stm = null;
    }
    (_a2 = super.unjoinStore) == null ? void 0 : _a2.call(this, store, isReplacing);
  }
  /**
   * Reference to STM manager, if used
   * @member {Core.data.stm.StateTrackingManager}
   * @category Misc
   */
  get stm() {
    return this[STM_PROP];
  }
  set stm(stm) {
    this[STM_PROP] = stm;
  }
  // Hook for chronograph entity field accessors, for example; task.duration = 123.
  // Triggers before setting the value.
  beforeChronoFieldSet(fieldName, value) {
    var _a2;
    const me = this;
    if (!me.inSetting && ((_a2 = me.stm) == null ? void 0 : _a2.enabled) && !unrecordedFields[fieldName] && !me.constructor.nonPersistableFields[fieldName]) {
      if (me.getFieldDefinition(fieldName)) {
        return { [fieldName]: { value, oldValue: me[fieldName] } };
      }
    }
    return null;
  }
  // Hook for chronograph entity field accessors, for example; task.duration = 123
  // Triggers after setting the value.
  afterChronoFieldSet(fieldName, value, wasSet) {
    wasSet && this.afterSet(fieldName, value, false, false, wasSet, true);
  }
  shouldRecordFieldChange(fieldName, oldValue, newValue) {
    const store = this.firstStore;
    return !(this.constructor.nonPersistableFields[fieldName] || oldValue == null && newValue == null || oldValue === newValue || oldValue instanceof Date && newValue instanceof Date && oldValue.getTime() === newValue.getTime() || fieldName === "id" || fieldName === "$PhantomId" || fieldName === "parentId" && store && store.oldIdMap[oldValue] === store.getById(newValue));
  }
  /**
   * Overridden to store initial data of the changed fields and to notify STM
   * manager about the change action if anything has been changed in result.
   *
   * The method is called from within {@link Core/data/Model#function-set} method.
   *
   * @private
   */
  afterSet(field2, value, silent, fromRelationUpdate, wasSet, isChronoFieldSet) {
    const { stm } = this, nonPersistableFields = this.constructor.nonPersistableFields;
    if ((stm == null ? void 0 : stm.isBase) && stm.enabled && !unrecordedFields[field2] && !nonPersistableFields[field2]) {
      if (wasSet) {
        let shouldRecord;
        const [newData, oldData] = Object.keys(wasSet).reduce(
          (data, fieldName) => {
            const { value: value2, oldValue } = wasSet[fieldName];
            if (this.shouldRecordFieldChange(fieldName, oldValue, value2)) {
              shouldRecord = true;
              data[0][fieldName] = value2;
              data[1][fieldName] = oldValue;
            }
            return data;
          },
          [{}, {}]
        );
        if (shouldRecord) {
          stm.onModelUpdate(this, newData, oldData, isChronoFieldSet);
        }
      }
    }
  }
  /**
   * Called from {@link Core/data/mixin/TreeNode#function-insertChild} to obtain inserted
   * records initial parents and parent index, to be able to restore the state back upon undo.
   *
   * @param {Core.data.Model[]} childRecords
   * @returns {Array} Array of results from this call and any of super calls if any.
   *               This result is consumed by {@link #function-afterInsertChild} which pops
   *               from the result array to take only results of this method call and leave
   *               results from super calls untouched.
   *
   * @private
   */
  beforeInsertChild(childRecords) {
    var _a2;
    const preResult = ((_a2 = super.beforeInsertChild) == null ? void 0 : _a2.call(this, childRecords)) || [], { stm } = this;
    if (stm == null ? void 0 : stm.enabled) {
      preResult.push(
        childRecords.reduce((result, childRecord) => {
          if (childRecord.root === this.root) {
            result.set(childRecord, {
              parent: childRecord.parent,
              index: childRecord.parent ? childRecord.parentIndex : void 0
            });
          }
          return result;
        }, /* @__PURE__ */ new Map())
      );
    }
    return preResult;
  }
  /**
   * Called from {@link Core/data/mixin/TreeNode#function-insertChild} to notify {@link Core/data/stm/StateTrackingManager}
   * about children insertion. Provides it with all necessary context information collected
   * in {@link #function-beforeInsertChild} required to undo/redo the action.
   *
   * @private
   */
  afterInsertChild(index, childRecords, beforeResult, inserted) {
    var _a2;
    const { stm } = this;
    if (stm == null ? void 0 : stm.enabled) {
      const context = beforeResult.pop();
      if (inserted) {
        stm.onModelInsertChild(this, index, inserted, context);
      }
    }
    (_a2 = super.afterInsertChild) == null ? void 0 : _a2.call(this, index, childRecords, beforeResult, inserted);
  }
  /**
   * Called from {@link Core/data/mixin/TreeNode#function-removeChild} to obtain removed
   * records initial parent index, to be able to restore the state back upon undo.
   *
   * @param {Core.data.Model[]} childRecords
   * @param {Boolean} isMove
   * @returns {Array} Array of results from this call and any of super calls if any.
   *               This result is consumed by {@link #function-afterRemoveChild} which pops
   *               from the result array to take only results of this method call and leave
   *               results from super calls untouched.
   *
   * @private
   */
  beforeRemoveChild(childRecords, isMove) {
    const preResult = super.beforeRemoveChild ? super.beforeRemoveChild(childRecords, isMove) : [], { stm } = this;
    if ((stm == null ? void 0 : stm.enabled) && !isMove) {
      preResult.push(
        childRecords.reduce((result, childRecord) => {
          result.set(childRecord, { parentIndex: childRecord.parentIndex, orderedParentIndex: childRecord.orderedParentIndex });
          return result;
        }, /* @__PURE__ */ new Map())
      );
    }
    return preResult;
  }
  /**
   * Called from {@link Core/data/mixin/TreeNode#function-removeChild} to notify {@link Core/data/stm/StateTrackingManager}
   * about children removing. Provides it with all necessary context information collected
   * in {@link #function-beforeRemoveChild} required to undo/redo the action.
   *
   * @private
   */
  afterRemoveChild(childRecords, beforeResult, isMove) {
    var _a2;
    const { stm } = this;
    if ((stm == null ? void 0 : stm.enabled) && !isMove) {
      const context = beforeResult.pop();
      if (childRecords && childRecords.length) {
        stm.onModelRemoveChild(this, childRecords, context);
      }
    }
    (_a2 = super.afterRemoveChild) == null ? void 0 : _a2.call(this, childRecords, beforeResult, isMove);
  }
};

// ../Core/lib/Core/data/mixin/TreeNode.js
var defaultTraverseOptions = {
  includeFilteredOutRecords: false
};
var fixTraverseOptions = (options) => {
  options = options || false;
  if (typeof options === "boolean") {
    options = {
      includeFilteredOutRecords: options
    };
  }
  return options || defaultTraverseOptions;
};
var TreeNode_default = (Target) => class TreeNode extends (Target || Base2) {
  static get $name() {
    return "TreeNode";
  }
  /**
   * This static configuration option allows you to control whether an empty parent task should be converted into a
   * leaf. Enable/disable it for a whole class:
   *
   * ```javascript
   * Model.convertEmptyParentToLeaf = false;
   * ```
   *
   * By specifying `true`, all empty parents will be considered leafs. Can also be assigned a configuration object
   * with the following Boolean properties to customize the behaviour:
   *
   * ```javascript
   * Model.convertEmptyParentToLeaf = {
   *     onLoad   : false,
   *     onRemove : true
   * }
   * ```
   *
   * @member {Boolean|{ onLoad : Boolean, onRemove : Boolean }} convertEmptyParentToLeaf
   * @property {Boolean} onLoad Apply the transformation on load to any parents without children (`children : []`)
   * @property {Boolean} onRemove Apply the transformation when all children have been removed from a parent
   * @default false
   * @static
   * @category Parent & children
   * */
  static set convertEmptyParentToLeaf(value) {
    if (value === true) {
      value = {
        onLoad: true,
        onRemove: true
      };
    } else if (value === false) {
      value = {
        onLoad: false,
        onRemove: false
      };
    }
    this._convertEmptyParentToLeaf = value;
  }
  constructor(...args) {
    super(...args);
    if (this.children) {
      this.orderedChildren = this.orderedChildren || [];
    }
  }
  static get convertEmptyParentToLeaf() {
    return this._convertEmptyParentToLeaf || { onLoad: false, onRemove: false };
  }
  /**
   * This is a read-only property providing access to the parent node.
   * @member {Core.data.Model} parent
   * @readonly
   * @category Parent & children
   */
  /**
   * This is a read-only field provided in server synchronization packets to specify
   * which record id is the parent of the record.
   * @readonly
   * @field {String|Number|null} parentId
   * @category Tree
   */
  /**
   * This is a read-only field provided in server synchronization packets to specify
   * which position the node takes in the parent's children array.
   * This index is set on load and gets updated automatically after row reordering, sorting, etc.
   * To save the order, need to persist the field on the server and when data is fetched to be loaded,
   * need to sort by this field.
   * @readonly
   * @field {Number} parentIndex
   * @category Tree
   */
  /**
   * This is a read-only field provided in server synchronization packets to specify
   * which position the node takes in the parent's ordered children array.
   * This index is set on load and gets updated on reordering nodes in tree. Sorting and filtering
   * have no effect on it.
   * @readonly
   * @field {Number} orderedParentIndex
   * @category Tree
   */
  ingestChildren(childRecord, stores = this.stores) {
    const { inProcessChildren, constructor: MyClass } = this, store = stores[0];
    if (childRecord === true) {
      if (inProcessChildren) {
        return true;
      }
      return [];
    }
    if (childRecord) {
      childRecord = ArrayHelper.asArray(childRecord);
      const len = childRecord.length, result = [];
      for (let i = 0, child; i < len; i++) {
        child = childRecord[i];
        child = child.isModel ? child : store ? store.createRecord(child, false, true) : new MyClass(child, null, null, true);
        child = store ? store.processRecord(child) : child;
        result.push(child);
      }
      if (this.children === true && store) {
        const sorter = store.createSorterFn(store.sorters);
        result.sort(sorter);
      }
      return result;
    }
  }
  /**
   * Child nodes. To allow loading children on demand, specify `children : true` in your data. Omit the field for leaf
   * tasks.
   *
   * Note, if the tree store loads data from a remote origin, make sure {@link Core/data/AjaxStore#config-readUrl}
   * is specified, and optionally {@link Core/data/AjaxStore#config-parentIdParamName} is set, otherwise
   * {@link Core/data/Store#function-loadChildren} has to be implemented.
   *
   * @field {Boolean|Object[]|Core.data.Model[]} children
   * @category Parent & children
   */
  /**
   * Array of sorted tree nodes but without a filter applied
   * @member {Core.data.Model[]|null} unfilteredChildren
   * @category Parent & children
   * @private
   */
  /**
   * Array of children unaffected by sorting and filtering, keeps original tree structure
   * @member {Core.data.Model[]|null} orderedChildren
   * @category Parent & children
   * @private
   */
  /**
   * Called during creation to also turn any children into Models joined to the same stores as this model
   * @internal
   * @category Parent & children
   */
  processChildren(stores = this.stores) {
    const me = this, { meta } = me;
    me.inProcessChildren = true;
    const children = me.ingestChildren(me.data[me.constructor.childrenField], stores);
    if (children) {
      const { convertEmptyParentToLeaf } = me.constructor, shouldConvert = convertEmptyParentToLeaf === true || convertEmptyParentToLeaf.onLoad;
      if (shouldConvert ? children.length : Array.isArray(children)) {
        meta.isLeaf = false;
        if (me.children === true) {
          me.children = [];
        } else if (children.length === 0) {
          me.children = children;
          return;
        }
        me.insertChild(children);
      } else if (children === true) {
        meta.isLeaf = false;
        me.children = true;
      } else if (!me.isRoot) {
        meta.isLeaf = me.constructor.convertEmptyParentToLeaf.onLoad;
      }
    }
    me.inProcessChildren = false;
  }
  /**
   * This method returns `true` if this record has all expanded ancestors and is therefore
   * eligible for inclusion in a UI.
   * @param {Core.data.Store} [store] Optional store, defaults to nodes first store
   * @returns {Boolean}
   * @readonly
   * @category Parent & children
   * @returns {Boolean}
   */
  ancestorsExpanded(store = this.firstStore) {
    const { parent } = this;
    return !parent || parent.isExpanded(store) && parent.ancestorsExpanded(store);
  }
  /**
   * Used by stores to assess the record's collapsed/expanded state in that store.
   * @param {Core.data.Store} store
   * @category Parent & children
   * @returns {Boolean}
   */
  isExpanded(store = this.firstStore) {
    const mapMeta = this.instanceMeta(store.id);
    if (!Object.prototype.hasOwnProperty.call(mapMeta, "collapsed")) {
      mapMeta.collapsed = !this.expanded;
    }
    return !mapMeta.collapsed;
  }
  // A read-only property. It provides the initial state upon load
  // The UI's expanded/collapsed state is in the store's meta map.
  get expanded() {
    return this.data.expanded;
  }
  /**
   * Depth in the tree at which this node exists. First visual level of nodes are at level 0, their direct children at
   * level 1 and so on.
   * @property {Number}
   * @readonly
   * @category Parent & children
   */
  get childLevel() {
    let node = this, ret = -1;
    while (node && !node.isRoot) {
      ++ret;
      node = node.parent;
    }
    return ret;
  }
  /**
   * Is a leaf node in a tree structure?
   * @property {Boolean}
   * @readonly
   * @category Parent & children
   */
  get isLeaf() {
    return this.meta.isLeaf !== false && !this.isRoot;
  }
  /**
   * Returns `true` if this node is the root of the tree
   * @member {Boolean} isRoot
   * @readonly
   * @category Parent & children
   */
  /**
   * Is a parent node in a tree structure?
   * @property {Boolean}
   * @readonly
   * @category Parent & children
   */
  get isParent() {
    return !this.isLeaf;
  }
  /**
   * Returns true for parent nodes with children loaded (there might still be no children)
   * @property {Boolean}
   * @readonly
   * @category Parent & children
   */
  get isLoaded() {
    return this.isParent && Array.isArray(this.children);
  }
  /**
   * Count all children (including sub-children) for a node (in its `firstStore)
   * @member {Number}
   * @category Parent & children
   */
  get descendantCount() {
    return this.getDescendantCount();
  }
  /**
   * Count visible (expanded) children (including sub-children) for a node (in its `firstStore`)
   * @member {Number}
   * @category Parent & children
   */
  get visibleDescendantCount() {
    return this.getDescendantCount(true);
  }
  /**
   * Count visible (expanded)/all children for this node, optionally specifying for which store.
   * @param {Boolean} [onlyVisible] Specify `true` to only count visible (expanded) children.
   * @param {Core.data.Store} [store] A Store to which this node belongs
   * @returns {Number}
   * @category Parent & children
   */
  getDescendantCount(onlyVisible = false, store = this.firstStore) {
    const { children } = this;
    if (!children || !Array.isArray(children) || onlyVisible && !this.isExpanded(store)) {
      return 0;
    }
    return children.reduce((count, child) => count + child.getDescendantCount(onlyVisible), children.length);
  }
  /**
   * Retrieve all children, not including filtered out nodes (by traversing sub nodes)
   * @property {Core.data.Model[]}
   * @category Parent & children
   */
  get allChildren() {
    return this.getAllChildren(false);
  }
  /**
   * Retrieve all children, including filtered out nodes (by traversing sub nodes)
   * @property {Core.data.Model[]}
   * @private
   * @category Parent & children
   */
  get allUnfilteredChildren() {
    return this.getAllChildren(true);
  }
  getAllChildren(unfiltered = false) {
    const { [unfiltered ? "unfilteredChildren" : "children"]: children } = this;
    if (!children || children === true) {
      return [];
    }
    return children.reduce((all, child) => {
      all.push(child);
      all.push.apply(all, unfiltered ? child.allUnfilteredChildren : child.allChildren);
      return all;
    }, []);
  }
  /**
   * Get the first child of this node
   * @property {Core.data.Model}
   * @readonly
   * @category Parent & children
   */
  get firstChild() {
    const { children } = this;
    return (children == null ? void 0 : children.length) && children[0] || null;
  }
  /**
   * Get the last child of this node
   * @property {Core.data.Model}
   * @readonly
   * @category Parent & children
   */
  get lastChild() {
    const { children } = this;
    return (children == null ? void 0 : children.length) && children[children.length - 1] || null;
  }
  /**
   * Get the previous sibling of this node
   * @member {Core.data.Model} previousSibling
   * @readonly
   * @category Parent & children
   */
  /**
   * Get the next sibling of this node
   * @member {Core.data.Model} nextSibling
   * @readonly
   * @category Parent & children
   */
  /**
   * Returns count of all preceding sibling nodes (including their children).
   * @property {Number}
   * @category Parent & children
   */
  get previousSiblingsTotalCount() {
    let task = this.previousSibling, count = this.parentIndex;
    while (task) {
      count += task.descendantCount;
      task = task.previousSibling;
    }
    return count;
  }
  get previousOrderedSibling() {
    var _a2;
    return (_a2 = this.parent) == null ? void 0 : _a2.orderedChildren[this.orderedParentIndex - 1];
  }
  get nextOrderedSibling() {
    var _a2;
    return (_a2 = this.parent) == null ? void 0 : _a2.orderedChildren[this.orderedParentIndex + 1];
  }
  get root() {
    var _a2;
    return ((_a2 = this.parent) == null ? void 0 : _a2.root) || this;
  }
  /**
   * Reading this property returns the id of the parent node, if this record is a child of a node.
   *
   * Setting this property appends this record to the record with the passed id **in the same store that this record
   * is already in**.
   *
   * Note that setting this property is **only valid if this record is already part of a tree store**.
   *
   * This is not intended for general use. This is for when a server responds to a record mutation and the server
   * decides to move a record to a new parent. If a `parentId` property is passed in the response data for a record,
   * that record will be moved.
   *
   * @property {Number|String|null}
   * @category Parent & children
   */
  get parentId() {
    return this.parent && !this.parent.isAutoRoot ? this.parent.id : null;
  }
  set parentId(parentId) {
    const me = this, { parent } = me, newParent = parentId === null ? me.firstStore.rootNode : me.firstStore.getById(parentId);
    if (!(newParent === parent || !parent && !newParent)) {
      if (me.isBatchUpdating) {
        me.meta.batchChanges.parentId = parentId;
      } else {
        if (newParent) {
          newParent.appendChild(me);
        } else {
          me.parent.removeChild(me);
        }
      }
    }
  }
  static set parentIdField(parentIdField) {
    this._parentIdField = parentIdField;
    Object.defineProperty(this.prototype, parentIdField, {
      set: function(parentId) {
        this.parentId = parentId;
      },
      get: function() {
        return this.parentId;
      }
    });
  }
  static get parentIdField() {
    return this._parentIdField || "parentId";
  }
  getChildren(options) {
    let result;
    if (options.includeFilteredOutRecords) {
      result = this.unfilteredChildren || this.children;
    } else if (options.useOrderedTree) {
      result = this.orderedChildren;
    } else {
      result = this.children;
    }
    return result;
  }
  /**
   * Traverses all child nodes recursively calling the passed function
   * on a target node **before** iterating the child nodes.
   * @param {Function} fn The function to call
   * @param {Boolean} [skipSelf=false] True to ignore self
   * @param {Object|Boolean} [options] A boolean for includeFilteredOutRecords, or an options object
   * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records
   * @param {Boolean} [options.useOrderedTree] True to traverse unsorted/unfiltered tree
   * @category Parent & children
   */
  traverse(fn2, skipSelf, options) {
    options = fixTraverseOptions(options);
    const me = this, children = me.getChildren(options);
    if (!skipSelf) {
      fn2.call(me, me);
    }
    for (let i = 0, l = children == null ? void 0 : children.length; i < l; i++) {
      children[i].traverse(fn2, false, options);
    }
  }
  /**
   * Traverses all child nodes recursively calling the passed function
   * on child nodes of a target **before** calling it on the node.
   * @param {Function} fn The function to call
   * @param {Boolean} [skipSelf=false] True to skip this node in the traversal
   * @param {Object|Boolean} [options] A boolean for includeFilteredOutRecords, or an options object
   * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records
   * @category Parent & children
   */
  traverseBefore(fn2, skipSelf, options) {
    options = fixTraverseOptions(options);
    const me = this, children = me.getChildren(options);
    for (let i = 0, l = children == null ? void 0 : children.length; i < l; i++) {
      children[i].traverse(fn2, false, options);
    }
    if (!skipSelf) {
      fn2.call(me, me);
    }
  }
  /**
   * Traverses child nodes recursively while fn returns true
   * @param {Function} fn
   * @param {Boolean} [skipSelf=false] True to skip this node in the traversal
   * @param {Object|Boolean} [options] A boolean for includeFilteredOutRecords, or an options object
   * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records
   * @category Parent & children
   * @returns {Boolean}
   */
  traverseWhile(fn2, skipSelf, options) {
    options = fixTraverseOptions(options);
    const me = this;
    let goOn = skipSelf || fn2.call(me, me) !== false;
    if (goOn) {
      const children = me.getChildren(options);
      if (children == null ? void 0 : children.length) {
        goOn = children.every((child) => child.traverseWhile(fn2, false, options));
      }
    }
    return goOn;
  }
  /**
   * Bubbles up from this node, calling the specified function with each node.
   *
   * @param {Function} fn The function to call for each node
   * @param {Boolean} [skipSelf] True to skip this node in the traversal
   * @category Parent & children
   */
  bubble(fn2, skipSelf = false) {
    let me = this;
    if (!skipSelf) {
      fn2.call(me, me);
    }
    while (me.parent) {
      me = me.parent;
      fn2.call(me, me);
    }
  }
  /**
   * Bubbles up from this node, calling the specified function with each node,
   * while the function returns true.
   *
   * @param {Function} fn The function to call for each node
   * @param {Boolean} [skipSelf] True to skip this node in the traversal
   * @category Parent & children
   * @returns {Boolean}
   */
  bubbleWhile(fn2, skipSelf = false) {
    let me = this, goOn = true;
    if (!skipSelf) {
      goOn = fn2.call(me, me);
    }
    while (goOn && me.parent) {
      me = me.parent;
      goOn = fn2.call(me, me);
    }
    return goOn;
  }
  /**
   * Checks if this model contains another model as one of it's descendants
   *
   * @param {Core.data.Model|String|Number} childOrId child node or id
   * @param {Boolean} [skipSelf=false] True to ignore self in the traversal
   * @category Parent & children
   * @returns {Boolean}
   */
  contains(childOrId, skipSelf = false) {
    if (childOrId && typeof childOrId === "object") {
      childOrId = childOrId.id;
    }
    return !this.traverseWhile((node) => node.id != childOrId, skipSelf);
  }
  getTopParent(all) {
    let result;
    if (all) {
      result = [];
      this.bubbleWhile((t) => {
        result.push(t);
        return t.parent && !t.parent.isRoot;
      });
    } else {
      result = null;
      this.bubbleWhile((t) => {
        result = t;
        return t.parent && !t.parent.isRoot;
      });
    }
    return result;
  }
  /**
   * Append a child record(s) to any current children.
   * @param {Core.data.Model|Core.data.Model[]|Object|Object[]} childRecord Array of records/data or a single
   * record/data to append
   * @param {Boolean} [silent] Pass `true` to not trigger events during append
   * @returns {Core.data.Model|Core.data.Model[]|null}
   * @category Parent & children
   */
  appendChild(childRecord, silent = false) {
    return this.insertChild(childRecord, null, silent);
  }
  /**
   * Insert a child record(s) before an existing child record.
   * @param {Core.data.Model|Core.data.Model[]|Object|Object[]} childRecord Array of records/data or a single
   * record/data to insert
   * @param {Core.data.Model} [before] Optional record to insert before, leave out to append to the end
   * @param {Boolean} [silent] Pass `true` to not trigger events during append
   * @returns {Core.data.Model|Core.data.Model[]|null}
   * @category Parent & children
   */
  insertChild(childRecord, before = null, silent = false, options = {}) {
    var _a2, _b, _c, _d, _e, _f, _g;
    const me = this, returnArray = Array.isArray(childRecord);
    childRecord = ArrayHelper.asArray(childRecord);
    if (typeof before === "number") {
      before = (_b = (_a2 = me.children) == null ? void 0 : _a2[before]) != null ? _b : null;
    }
    if (!silent && !me.stores.every((s) => s.trigger("beforeAdd", {
      records: childRecord,
      parent: me
    }) !== false)) {
      return null;
    }
    childRecord = me.ingestChildren(childRecord);
    const index = (_e = (_d = before == null ? void 0 : before.parentIndex) != null ? _d : (_c = me.children) == null ? void 0 : _c.length) != null ? _e : 0, preResult = (_f = me.beforeInsertChild) == null ? void 0 : _f.call(me, childRecord), inserted = me.internalAppendInsert(childRecord, before, silent, options);
    if (inserted.length) {
      me.convertToParent(silent);
    }
    (_g = me.afterInsertChild) == null ? void 0 : _g.call(me, index, childRecord, preResult, inserted);
    return returnArray || !inserted ? inserted : inserted[0];
  }
  /**
   * Converts a leaf node to a parent node, assigning an empty array as its children
   * @param {Boolean} [silent] Pass `true` to not trigger any event
   * @category Parent & children
   */
  convertToParent(silent = false) {
    const me = this, wasLeaf = me.isLeaf;
    me.meta.isLeaf = false;
    if (!me.children) {
      me.children = [];
    }
    if (wasLeaf && !me.root.isLoading && !silent) {
      me.signalNodeChanged({
        isLeaf: {
          value: false,
          oldValue: true
        }
      });
    }
  }
  signalNodeChanged(changes, stores = this.stores) {
    stores.forEach((s) => {
      s.trigger("update", { record: this, records: [this], changes });
      s.trigger("change", { action: "update", record: this, records: [this], changes });
    });
  }
  tryInsertChild() {
    return this.insertChild(...arguments);
  }
  internalAppendInsert(recordsToInsert, beforeRecord, silent, options) {
    const me = this, { stores, root, children } = me, { firstStore: rootStore } = root, { parentIdField } = me.constructor, parentId = me.id;
    let isNoop, start, i, newRecordsCloned, oldParentIndices, isMove;
    if (!root.isLoading && rootStore) {
      isMove = {};
      oldParentIndices = [];
      for (i = 0; i < recordsToInsert.length; i++) {
        const newRecord = recordsToInsert[i];
        isMove[newRecord.id] = newRecord.root === root;
        oldParentIndices[i] = newRecord.parentIndex;
      }
    }
    if (beforeRecord && beforeRecord.parent !== me) {
      beforeRecord = null;
    }
    if (children) {
      const insertAt = beforeRecord ? beforeRecord.parentIndex : children.length;
      if (children[start = insertAt] === recordsToInsert[0] || children[start = insertAt - 1] === recordsToInsert[0]) {
        for (isNoop = true, i = 0; isNoop && i < recordsToInsert.length; i++) {
          if (recordsToInsert[i] !== children[start + i]) {
            isNoop = false;
          }
        }
      }
    }
    if (isNoop) {
      return recordsToInsert;
    }
    for (i = 0; i < recordsToInsert.length; i++) {
      const newRecord = recordsToInsert[i], oldParent = newRecord.parent;
      if (rootStore && !root.isLoading) {
        newRecord.traverse((r) => {
          if (r.root === root) {
            isMove[r.id] = true;
          }
        });
      }
      if ((oldParent == null ? void 0 : oldParent.removeChild(newRecord, isMove == null ? void 0 : isMove[newRecord.id], silent, { isInserting: true, ...options })) === false) {
        if (!newRecordsCloned) {
          recordsToInsert = recordsToInsert.slice();
          newRecordsCloned = true;
        }
        recordsToInsert.splice(i--, 1);
      } else {
        newRecord.parent = me;
        newRecord.data[parentIdField] = parentId;
        const { meta } = newRecord;
        if (meta.modified[parentIdField] === parentId && !oldParent) {
          meta.oldParentId = parentId;
        }
        if (oldParent) {
          meta.oldParentId = oldParent.id;
        }
      }
    }
    if (recordsToInsert.length) {
      if (!Array.isArray(children)) {
        me.children = [];
      }
      if (!Array.isArray(me.orderedChildren)) {
        me.orderedChildren = [];
      }
      const insertAt = me.addToChildren(beforeRecord, recordsToInsert, options);
      stores.forEach((store) => {
        if (!store.isChained) {
          recordsToInsert.forEach((record) => {
            record.joinStore(store);
          });
          store.onNodeAddChild(me, recordsToInsert, insertAt, isMove, silent);
          recordsToInsert.forEach((record, i2) => {
            if (record.meta.oldParentId != null && !(me.inProcessChildren || me.isLoading)) {
              const toSet = {
                [parentIdField]: parentId,
                [me.getDataSource("parentIndex")]: record.parentIndex
              }, wasSet = {}, { modified, oldParentId } = record.meta, oldParentIndex = oldParentIndices[i2];
              delete record.meta.oldParentId;
              if (me.id !== oldParentId) {
                wasSet[parentIdField] = {
                  value: parentId,
                  oldValue: oldParentId
                };
              }
              if (record.parentIndex !== oldParentIndex) {
                wasSet.parentIndex = {
                  value: record.parentIndex,
                  oldValue: oldParentIndex
                };
              }
              if (modified[parentIdField] === me.id) {
                Reflect.deleteProperty(modified, parentIdField);
              } else if (!(parentIdField in modified)) {
                modified[parentIdField] = oldParentId;
              }
              if (isMove[record.id]) {
                const oldParent = store.getById(oldParentId);
                if (oldParent.isLeaf && !silent) {
                  oldParent.signalNodeChanged({
                    isLeaf: {
                      value: true,
                      oldValue: false
                    }
                  }, [store]);
                }
              }
              record.afterChange(toSet, wasSet);
            }
            record.traverse((node) => {
              if (!node.ignoreBag && !node.isLinked) {
                store.updateModifiedBagForRecord(node);
              }
            });
          });
        }
      });
    }
    return recordsToInsert;
  }
  /**
   * Remove a child record. Only direct children of this node can be removed, others are ignored.
   * @param {Core.data.Model|Core.data.Model[]} childRecords The record(s) to remove.
   * @param {Boolean} [isMove] Pass `true` if the record is being moved within the same store.
   * @param {Boolean} [silent] Pass `true` to not trigger events during remove.
   * @privateparam {Object} [options]
   * @privateparam {Object} [options.isInserting] `true` is passed when removal is part of record inserting (acted on by
   * ModelLink)
   * @returns {Core.data.Model[]} All records (including nested children) removed
   * @category Parent & children
   */
  removeChild(childRecords, isMove = false, silent = false, options = {}) {
    var _a2, _b;
    const me = this, allRemovedRecords = [], wasLeaf = me.isLeaf, {
      children,
      stores
    } = me;
    childRecords = ArrayHelper.asArray(childRecords);
    childRecords = childRecords.filter((r) => r.parent === me);
    if (!silent) {
      for (const store of stores) {
        if (!store.isChained && store.trigger("beforeRemove", {
          parent: me,
          records: childRecords,
          isMove
        }) === false) {
          return false;
        }
      }
    }
    const preResult = (_a2 = me.beforeRemoveChild) == null ? void 0 : _a2.call(me, childRecords, isMove);
    for (const childRecord of childRecords) {
      const { parentIdField } = childRecord.constructor, { modified } = childRecord.meta, oldParentId = childRecord.parent ? childRecord.parent.id : null;
      if (!(parentIdField in modified) && !childRecord.isLinked) {
        modified[parentIdField] = oldParentId;
      }
      const index = me.removeFromChildren(childRecord, options);
      stores.forEach((store) => {
        if (!store.isChained) {
          const { isRemoving } = store;
          store.isRemoving = true;
          allRemovedRecords.push(...store.onNodeRemoveChild(me, [childRecord], index, { isMove, silent }));
          store.isRemoving = isRemoving;
        }
      });
      if (!isMove) {
        childRecord.parent = childRecord.parentIndex = childRecord.unfilteredIndex = childRecord.nextSibling = childRecord.previousSibling = null;
        childRecord.data[parentIdField] = null;
      }
    }
    if ((me.unfilteredChildren || children).length === 0 && me.constructor.convertEmptyParentToLeaf.onRemove && !me.isRoot) {
      me.meta.isLeaf = true;
    }
    if (me.isLeaf !== wasLeaf && !silent && !isMove) {
      me.signalNodeChanged({
        isLeaf: {
          value: true,
          oldValue: false
        }
      });
    }
    (_b = me.afterRemoveChild) == null ? void 0 : _b.call(me, childRecords, preResult, isMove);
    return allRemovedRecords;
  }
  clearParentId() {
    const me = this;
    Reflect.deleteProperty(me.data, me.parentIdField);
    Reflect.deleteProperty(me.originalData, me.parentIdField);
    if (me.meta.modified) {
      Reflect.deleteProperty(me.meta.modified, me.parentIdField);
    }
  }
  /**
   * Replaces all child nodes with the new node set.
   * @param {Core.data.Model|Core.data.Model[]} childRecords The new child record set.
   * @returns {Core.data.Model[]}
   * @category Parent & children
   */
  replaceChildren(newChildren) {
    this.clearChildren();
    this.data[this.constructor.childrenField] = newChildren;
    this.processChildren();
    return this.children;
  }
  /**
   * Removes all child nodes from this node.
   * @param {Boolean} [silent=false] Pass `true` to not fire Store events during the remove.
   * @returns {Core.data.Model[]}
   * @category Parent & children
   */
  clearChildren(silent = false) {
    const me = this, { stores } = me, children = me.unfilteredChildren || me.children;
    me.children = [];
    me.orderedChildren = [];
    if (children && children !== true) {
      stores.forEach((store) => {
        if (!store.isChained) {
          store.onNodeRemoveChild(me, children, 0, { unfiltered: true, silent });
        }
      });
      if (me.unfilteredChildren) {
        me.unfilteredChildren = [];
      }
    }
  }
  /**
   * Removes all records from the rootNode
   * @private
   */
  clear() {
    var _a2;
    const me = this, { stores } = me, children = (_a2 = me.children) == null ? void 0 : _a2.slice();
    if (!me.isRoot || !children) {
      return;
    }
    for (const store of stores) {
      if (!store.isChained) {
        if (store.trigger("beforeRemove", {
          parent: me,
          records: children,
          isMove: false,
          removingAll: true
        }) === false) {
          return false;
        }
      }
    }
    me.children.length = 0;
    if (me.unfilteredChildren) {
      me.unfilteredChildren.length = 0;
    }
    stores.forEach((store) => {
      children.forEach((child) => {
        if (child.stores.includes(store)) {
          child.unjoinStore(store);
        }
        child.parent = child.parentIndex = child.nextSibling = child.previousSibling = null;
      });
      store.storage.suspendEvents();
      store.storage.clear();
      store.storage.resumeEvents();
      store.added.clear();
      store.modified.clear();
      store.trigger("removeAll");
      store.trigger("change", { action: "removeall" });
    });
  }
  updateChildrenIndices(children, indexName, silent = false) {
    let previousSibling = null;
    for (let i = 0; i < children.length; i++) {
      const child = children[i], oldValue = child[indexName];
      if (indexName === "parentIndex" || indexName === "orderedParentIndex") {
        if (oldValue === void 0 || silent) {
          child.setData(indexName, i);
        } else if (oldValue !== i) {
          child.set(indexName, i, true);
        }
      } else {
        child[indexName] = i;
      }
      if (indexName === "parentIndex") {
        child.previousSibling = previousSibling;
        if (previousSibling) {
          previousSibling.nextSibling = child;
        }
        if (i === children.length - 1) {
          child.nextSibling = null;
        }
        previousSibling = child;
      }
    }
  }
  addToChildren(beforeRecord, newRecords, options = {}) {
    var _a2, _b;
    const me = this, configs = [
      [me.children, "parentIndex", beforeRecord],
      [me.unfilteredChildren, "unfilteredIndex", beforeRecord],
      [
        me.orderedChildren,
        "orderedParentIndex",
        (_a2 = options == null ? void 0 : options.orderedBeforeNode) != null ? _a2 : (options == null ? void 0 : options.orderedParentIndex) !== void 0 ? me.orderedChildren[options == null ? void 0 : options.orderedParentIndex] : beforeRecord
      ]
    ];
    for (const config of configs) {
      const [children, indexName, beforeRecord2] = config;
      if (children) {
        const index = beforeRecord2 ? indexName === "orderedParentIndex" ? children.indexOf(beforeRecord2) : beforeRecord2[indexName] : children.length;
        config.push(index);
        children.splice(index, 0, ...newRecords);
        if (!((_b = options == null ? void 0 : options[indexName]) == null ? void 0 : _b.skip)) {
          me.updateChildrenIndices(children, indexName);
        }
      }
    }
    return configs[0][3];
  }
  removeFromChildren(childRecord, options) {
    var _a2;
    const configs = [
      [this.children, "parentIndex"],
      [this.unfilteredChildren, "unfilteredIndex"],
      [this.orderedChildren, "orderedParentIndex"]
    ];
    for (const config of configs) {
      const [children, indexName] = config;
      if (children) {
        const index = children.indexOf(childRecord);
        config.push(index);
        if (index > -1) {
          children.splice(index, 1);
          if (!((_a2 = options == null ? void 0 : options[indexName]) == null ? void 0 : _a2.skip)) {
            this.updateChildrenIndices(children, indexName);
          }
        }
      }
    }
    return configs[0][2];
  }
  /**
   * Iterates orderedChildren array to apply sorting order according to `orderedParentIndex`.
   * Normally sorting is not required because order is maintained on append/insert. But is useful
   * when pasting number of records to restore their original order.
   * @param {Boolean} [deep=true] True to dive into children. False to sort own children.
   * @param {Boolean} [usePreviousOrder=false] Enable to use previous value of `orderedParentIndex`.
   * @returns {Set} Returns Set of moved nodes which require WBS update
   * @private
   */
  sortOrderedChildren(deep = true, usePreviousOrder = false) {
    const movedNodes = [];
    if (!this.isLeaf) {
      this.orderedChildren.sort((a, b) => {
        var _a2, _b;
        if (usePreviousOrder) {
          const aPrevIndex = (_a2 = a.meta.modified.orderedParentIndex) != null ? _a2 : a.orderedParentIndex, bPrevIndex = (_b = b.meta.modified.orderedParentIndex) != null ? _b : b.orderedParentIndex, result = aPrevIndex - bPrevIndex;
          if (result !== 0) {
            movedNodes.push(a);
            movedNodes.push(b);
          }
          return result;
        } else {
          return a.orderedParentIndex - b.orderedParentIndex;
        }
      });
      if (deep) {
        this.orderedChildren.forEach((child) => {
          movedNodes.push(...child.sortOrderedChildren(deep, usePreviousOrder));
        });
      }
      this.updateChildrenIndices(this.orderedChildren, "orderedParentIndex", true);
    }
    return new Set(movedNodes);
  }
  unjoinStore(store, isReplacing = false) {
    var _a2;
    const me = this;
    if (me.unfilteredChildren) {
      me.children = me.unfilteredChildren.slice();
      me.unfilteredChildren = null;
    }
    (_a2 = super.unjoinStore) == null ? void 0 : _a2.call(this, store, isReplacing);
  }
};

// ../Core/lib/Core/data/mixin/ModelLink.js
var propertyOverrides = {
  id: 1,
  stores: 1,
  parentIndex: 1,
  parent: 1,
  previousSibling: 1,
  nextSibling: 1,
  unfilteredIndex: 1
};
var proxyConfig = {
  get(target, prop) {
    if (prop === "proxyMeta") {
      return this.proxyMeta;
    }
    if (prop === "constructor") {
      return target.constructor;
    }
    if (prop === "setData") {
      return this.setDataOverride;
    }
    if (prop === "set") {
      return this.setOverride;
    }
    if (propertyOverrides[prop]) {
      return this.proxyMeta.data[prop];
    }
    return Reflect.get(target, prop, this.proxyRecord);
  },
  set(target, prop, value) {
    if (propertyOverrides[prop]) {
      this.proxyMeta.data[prop] = value;
    } else {
      target[prop] = value;
    }
    return true;
  },
  // Override setData & set to reroute parentIndex updates
  setDataOverride(toSet, value) {
    if (toSet === "parentIndex") {
      this.proxyMeta.data.parentIndex = value;
    } else {
      this.proxyMeta.originalRecord.setData(toSet, value);
    }
  },
  setOverride(field2, value, ...args) {
    if (field2 === "parentIndex") {
      this.proxyMeta.data.parentIndex = value;
    } else {
      this.proxyMeta.originalRecord.set(field2, value, ...args);
    }
  }
};
var ModelLink_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base2) {
    /**
     * Creates a proxy record (using native Proxy) linked to this record (the original). The proxy records shares most
     * data with the original, except for its `id` (which is always generated), and ordering fields such as
     * `parentIndex` and `parentId` etc.
     *
     * Any change to the proxy record will be reflected on the original, and vice versa. A proxy record is not meant to
     * be persisted, only the original record should be persisted. Thus, proxy records are not added to stores change
     * tracking (added, modified and removed records).
     *
     * Removing the original record removes all proxies.
     *
     * Creating a proxy record allows a Store to seemingly contain the record multiple times, something that is
     * otherwise not possible. It also allows a record to be used in both a tree store and in a flat store.
     *
     * <div class="note">Note that not all UI features support linked records</div>
     *
     * @returns {Proxy} Proxy record linked to the original record
     * @category Misc
     */
    link() {
      if (this.isLinked) {
        return this.$original.link();
      }
      const me = this, useConfig = {
        ...proxyConfig,
        // Data not shared with the original record
        proxyMeta: {
          originalRecord: me,
          data: {
            id: `${me.id}_link_${StringHelper.generateUUID()}`,
            stores: []
          }
        }
      }, proxyRecord = new Proxy(me, useConfig);
      useConfig.proxyRecord = proxyRecord;
      (me.meta.linkedRecords || (me.meta.linkedRecords = [])).push(proxyRecord);
      return proxyRecord;
    }
    /**
     * Is this record linked to another record?
     * @member {Boolean}
     * @readonly
     * @category Misc
     */
    get isLinked() {
      var _a3;
      return Boolean((_a3 = this.proxyMeta) == null ? void 0 : _a3.originalRecord);
    }
    /**
     * Are other records linked to this record?
     * @member {Boolean}
     * @readonly
     * @category Misc
     */
    get hasLinks() {
      return Boolean(!this.proxyMeta && this.$links.length);
    }
    // Logic to remove a link shared between removing in a flat store and a tree store
    removeLink(link, records = null, silent = false) {
      if (link.hasLinks) {
        for (const linked of link.$links.slice()) {
          if (records) {
            ArrayHelper.include(records, linked);
          } else {
            linked.remove(silent);
          }
        }
      } else if (link.isLinked) {
        ArrayHelper.remove(link.$original.$links, link);
      }
    }
    // Overrides beforeRemove in Model, to remove all linked records when original record is removed.
    beforeRemove(records) {
      this.removeLink(this, records);
    }
    // Overrides removeChild in TreeNode, to remove the original node and all linked nodes when either a linked or
    // original node is removed.
    removeChild(childRecords, isMove, silent, options) {
      if (!(options == null ? void 0 : options.isInserting)) {
        childRecords = ArrayHelper.asArray(childRecords);
        for (const child of childRecords) {
          this.removeLink(child, null, silent);
        }
      }
      return super.removeChild(childRecords, isMove, silent, options);
    }
    // Convenience getter for code keying by id that needs to work with both link and original
    get $originalId() {
      return this.$original.id;
    }
    // Convenience getter to retrieve linked records
    get $links() {
      var _a3;
      return (_a3 = this.meta.linkedRecords) != null ? _a3 : [];
    }
  }, __publicField(_a2, "$name", "ModelLink"), _a2;
};

// ../Core/lib/Core/mixin/Factoryable.js
var { defineProperty: defineProperty4 } = Reflect;
var ownerSymbol = Symbol("owner");
var typeSplitRe = /[\s,]+/;
var Factoryable_default = (Target) => class Factoryable extends (Target || Base2) {
  static get $name() {
    return "Factoryable";
  }
  static get declarable() {
    return [
      /**
       * This property getter returns options that control the factory process. This property getter must be
       * defined by the class that mixes in `Factoryable` in order to initialize the factory properly.
       * ```
       *  static get factoryable() {
       *      return {
       *          defaultType : 'default'
       *      };
       *  }
       * ```
       * If there are no special options to provide, this method can return nothing (`undefined`):
       * ```
       *  static get factoryable() {
       *      // initialize the factory with all default options
       *  }
       * ```
       * @static
       * @member {Object} factoryable
       * @property {Boolean} [factoryable.caseless=true] Specify `false` to use case-sensitive type names. The
       * default is to ignore case.
       * @property {String} [factoryable.defaultType=null] The default type to create when a config object has
       * no `typeKey` property.
       * @property {Function|Function[]} [factoryable.extends] One or more classes that mix in `Factoryable` to
       * use for resolving type names when a type name is not found in this factory.
       * @property {String} [factoryable.typeKey='type'] The name of the property in a config object that holds
       * the type name.
       * @internal
       */
      "factoryable",
      /**
       * One or more additional type name aliases for this class. This can be useful for renaming and maintaining
       * a previous type name.
       * ```
       *  class Fit extends Layout {
       *      static get type() {
       *          return 'fit';
       *      }
       *
       *      static get alias() {
       *          return 'fill';  // deprecated type name (now known as 'fit')
       *      }
       *  }
       * ```
       * @static
       * @member {String|String[]} alias
       * @internal
       */
      "alias",
      /**
       * The (canonical) type name for this class by which instances can be created using the static
       * {@link #function-create-static create()} method.
       * @static
       * @member {String} type
       */
      "type"
    ];
  }
  /**
   * Registers a class (`cls`) associated with the given `type`.
   * @param {String|String[]} type A string, array of strings or a comma-separated string containing the type names
   * for the specified `cls` class.
   * @param {Function} cls The class (constructor function)
   * @param {Boolean} [replace] Pass `true` to overwrite existing registered types. Otherwise, this method will throw
   * an exception if the `type` is already registered with this factory.
   * @internal
   */
  static register(type, cls, replace = globalThis.__BRYNTUM_EXAMPLE) {
    const { factoryable } = this.initClass(), { caseless, registry: registry2 } = factoryable, types = StringHelper.split(type, typeSplitRe);
    for (let lower, name, i = 0; i < types.length; ++i) {
      name = types[i];
      lower = caseless ? name.toLowerCase() : name;
      if (!replace && lower in registry2) {
        throw new Error(`Type "${name}" already registered with ${factoryable.class.name} factory`);
      }
      registry2[name] = registry2[lower] = cls.initClass();
    }
  }
  /**
   * Returns `true` if the passed instance is of the passed type or of a derived class.
   * @param {Object} instance The object to test.
   * @param {String} type The type to test against
   */
  static isA(instance, type) {
    return this.isType(instance, type, true);
  }
  /**
   * Returns `true` if the passed instance is of the passed type.
   * @param {Object} instance The object to test.
   * @param {String} type The type to test against
   * @param {Boolean} [deep] Pass `true` to return `true` if the class is a subclass of the passed type.
   */
  static isType(instance, type, deep) {
    const { factoryable } = this, { caseless, registry: registry2 } = factoryable, typeCls = registry2[caseless ? type.toLowerCase() : type];
    if (typeCls) {
      if (deep) {
        return instance instanceof typeCls;
      }
      return instance.constructor === typeCls;
    }
    return false;
  }
  static setupAlias(cls) {
    cls.register(cls.alias, cls);
  }
  static setupFactoryable(cls, meta) {
    const superClass = meta.super.class;
    let { factoryable } = cls;
    factoryable = {
      caseless: true,
      defaultType: null,
      extends: superClass.factoryable ? [superClass] : null,
      typeKey: "type",
      ...factoryable
    };
    factoryable.class = cls;
    factoryable.registry = /* @__PURE__ */ Object.create(null);
    if (factoryable.extends && !Array.isArray(factoryable.extends)) {
      factoryable.extends = [factoryable.extends];
    }
    defineProperty4(cls, "factoryable", {
      get() {
        return factoryable;
      }
    });
  }
  static setupType(cls, meta) {
    const { type } = cls;
    cls.register(type, cls, meta.replaceType);
    defineProperty4(cls.prototype, "type", {
      value: type
    });
  }
  /**
   * Creates an instance from this factory, given the type name or a config object.
   * @param {String|Object} config The type name string or config object.
   * @param {String|Function|Object} [options] Creation options (for details see {@link #function-reconfigure-static}).
   * @returns {Object}
   */
  static create(config, options) {
    return this.reconfigure(null, config, options);
  }
  /**
   * Reconfigures an optional existing instance based on the provided config and returns the correctly configured
   * instance. This will be the `existingInstance` if the `config` does not specify a different type.
   *
   * If `config` is `null` (or simply falsy), this method will destroy the `existingInstance` (if any) and return
   * `null`.
   *
   * If there is no `existingInstance`, the config must specify a type. That is, it must be a string (the type name)
   * or an object containing a `type` property, the `defaultType` must be provided or the factory itself must have
   * a `defaultType` specified (see {@link #property-factoryable-static}).
   *
   * When an `existingInstance` is provided and a type is specified, the instance will be reconfigured via `setConfig`
   * if it is of that type. Otherwise, the `existingInstance` is destroyed (if it is owned by the `options.owner`)
   * and a new instance of the correct type is created.
   *
   * @param {Object} existingInstance The instance to reconfigure. This can be `null`.
   *
   * @param {String|Object} config The type name string or config object.
   *
   * @param {String|Function|Object} [options] Additional options to control the reconfiguration process. If this
   * value is a string or a class constructor, it treated as `options.type`. If this value is a class instance, it
   * is used as the `options.owner`. If this is a function, it is treated as `options.setup`. NOTE: functions declared
   * using the `function` keyword are equivalent to class constructors. Use an arrow function or a class method to
   * avoid this when a `setup` function is intended.
   *
   * @param {String|Function} [options.type] The default type to use if the `config` object does not specify a type.
   *
   * @param {Object} [options.owner] The owner of any created instances. If the `existingInstance` is being replaced,
   * this value determines if the instance will be destroyed.
   *
   * @param {Object} [options.defaults] A config object of default values to use when creating a new instance.
   *
   * @param {Function|String} [options.setup] A function or the name of a method (on the `options.owner`) to call
   * prior to creating a new instance. It is passed the config object that will be used to create the instance. If a
   * truthy value is returned, that value is passed to the constructor instead of the provided config object.
   *
   * @param {Function|String} [options.transform] A function or the name of a method (on the `options.owner`) to call
   * with the raw config object prior to processing and the value it returns replaces the raw value. This function is
   * used to transform strings or arrays (for example) into proper config objects.
   *
   * @param {Function|String} [options.cleanup] A function or the name of a method (on the `options.owner`) to call
   * prior to destroying the `existingInstance`. The `existingInstance` is passed as the sole argument.
   *
   * @returns {Object} The reconfigured instance (either `existingInstance` or a new instance of the desired type)
   */
  static reconfigure(existingInstance, config, options) {
    const me = this, { factoryable } = me, { typeKey } = factoryable;
    let defaultType = options, cleanup, defaults, mergeType, owner, prepared, setup, t, transform, type;
    if (options && !ObjectHelper.isClass(options)) {
      defaultType = null;
      t = typeof options;
      if (t === "function") {
        setup = options;
      } else if (t === "string") {
        defaultType = options;
      } else if (ObjectHelper.isObject(options)) {
        cleanup = options.cleanup;
        defaults = options.defaults;
        owner = options.owner;
        setup = options.setup;
        defaultType = options.type;
        transform = options.transform;
      } else {
        owner = options;
      }
    }
    if (transform) {
      config = typeof transform === "string" ? owner[transform](config) : transform(config);
    }
    type = config;
    if (typeof type === "string") {
      config = {};
    } else if (config) {
      if (config === true) {
        config = {};
      }
      if (!ObjectHelper.isObject(config)) {
        if (owner && config !== existingInstance && (existingInstance == null ? void 0 : existingInstance[ownerSymbol]) === owner) {
          typeof cleanup === "string" ? owner[cleanup](existingInstance) : cleanup == null ? void 0 : cleanup(existingInstance);
          existingInstance.destroy();
        }
        return config;
      }
      type = config[typeKey];
    }
    type = type && me.resolveType(type);
    if (existingInstance) {
      if (config && (!type || existingInstance.constructor === type)) {
        if (typeKey in config) {
          config = ObjectHelper.assign({}, config);
          delete config[typeKey];
        }
        existingInstance.setConfig(config);
        return existingInstance;
      }
      if (owner && existingInstance[ownerSymbol] === owner) {
        typeof cleanup === "string" ? owner[cleanup](existingInstance) : cleanup == null ? void 0 : cleanup(existingInstance);
        existingInstance.destroy();
      }
    }
    if (config) {
      if (defaults) {
        if (!(mergeType = type)) {
          if (!(mergeType = defaults[typeKey] || defaultType || factoryable.defaultType)) {
            throw new Error(`No default mergeType defined for ${factoryable.class.name} factory`);
          }
          mergeType = me.resolveType(mergeType);
        }
        if (mergeType) {
          config = mergeType.mergeConfigs(defaults, config);
        }
      }
      if (setup) {
        prepared = typeof setup === "string" ? owner[setup](config, type, defaults) : setup(config, type, defaults);
        if (prepared === null) {
          return prepared;
        }
        config = prepared || config;
      }
      if (!type) {
        if (!(type = config[typeKey] || defaultType || factoryable.defaultType)) {
          throw new Error(`No default type defined for ${factoryable.class.name} factory`);
        }
        type = me.resolveType(type);
      }
      if (defaults && !mergeType) {
        config = type.mergeConfigs(defaults, config);
      }
      if (typeKey in config) {
        config = ObjectHelper.assign({}, config);
        delete config[typeKey];
      }
      config = new type(config);
      if (owner) {
        config[ownerSymbol] = owner;
      }
    }
    return config || null;
  }
  /**
   * This method returns the constructor of the class registered for the given type name.
   * @param {String} type The type name to look up.
   * @param {Boolean} [optional] Pass `true` to return `null` if `type` is not found instead of throwing an exception.
   * @returns {Function}
   */
  static resolveType(type, optional) {
    if (typeof type !== "string") {
      return type;
    }
    const { factoryable } = this, bases = factoryable.extends;
    let result = factoryable.registry[factoryable.caseless ? type.toLowerCase() : type], i;
    for (i = 0; !result && bases && i < bases.length; ++i) {
      result = bases[i].resolveType(
        type,
        /* optional = */
        true
      );
    }
    if (!result && !optional) {
      throw new Error(`Invalid type name "${type}" passed to ${factoryable.class.name} factory`);
    }
    return result;
  }
};

// ../Core/lib/Core/data/field/DataField.js
var { getOwnPropertyDescriptor: getOwnPropertyDescriptor2 } = Reflect;
var DataField = class extends Base2.mixin(Factoryable_default) {
  static get $name() {
    return "DataField";
  }
  static get type() {
    return "auto";
  }
  static get factoryable() {
    return {
      defaultType: "auto"
    };
  }
  static get prototypeProperties() {
    return {
      /**
       * The name of the field.
       * @config {String} name
       */
      /**
       * The label text for a form item generated for this field. This is also used to create
       * a column header for a {@link #config-column} for this field.
       * @config {String} label
       */
      /**
       * A column config object for a column to display this field in a grid. For simple, atomic
       * data types, such as `date`, `string`, `boolean`, `number` and `integer`, this is optional
       * and the appropriate column type can be inferred.
       *
       * This also provides default values for column configuration if a configured column definition
       * for a grid lacks a property.
       *
       * For complex fields, such as identifiers which link to other records, a more capable
       * column type may be specified, for example a `type : `number'` field may be configured
       * with
       *
       * ```javascript
       * column : 'percent'
       * ```
       * or
       * ```javascript
       * column : {
       *     type : 'percent',
       *     width : 100
       * }
       * ```
       * if it represents a percentage vaue and needs appropriate rendering and editing.
       * @config {String|Object} column
       */
      /**
       * A config object for a widget to edit this field in a form. For simple, atomic
       * data types, such as `date`, `string`, `boolean`, `number` and `integer`, this is optional
       * and the appropriate input widget type can be inferred.
       *
       * For complex fields, such as identifiers which link to other records, a more capable
       * widget may be specified.
       * @config {String|InputFieldConfig} editor
       * @private
       */
      /**
       * A function that compares two values and returns a value < 0 if the first is less than the second, or 0
       * if the values are equal, or a value > 0 if the first is greater than the second.
       * @config {Function}
       * @default
       */
      compare: null,
      /**
       * A function that compares two objects or records using the `compare` function on the properties of each
       * objects based on the `name` of this field.
       * @config {Function}
       * @default
       * @internal
       */
      compareItems: null,
      /**
       * The property in a record's data object that contains the field's value.
       * Defaults to the field's `name`.
       * @config {String}
       */
      dataSource: null,
      /**
       * The default value to assign to this field in a record if no value is provided.
       * @config {*} defaultValue
       */
      /**
       * Setting to `true` will ensure this field is included in any update/insert request payload
       * when a Store / Project / CrudManager performs a request.
       * @config {Boolean}
       * @default
       */
      alwaysWrite: false,
      /**
       * Setting to `false` indicates that `null` is not a valid value.
       * @config {Boolean}
       * @default
       */
      nullable: true,
      /**
       * The value to return from {@link #function-print} for a `null` or `undefined` value.
       * @config {String}
       * @default
       */
      nullText: null,
      /**
       * The value to replace `null` when the field is not `nullable`.
       * @config {*}
       * @default
       */
      nullValue: void 0,
      /**
       * Set to `false` to exclude this field when saving records to a server.
       * @config {Boolean}
       * @default
       */
      persist: true,
      /**
       * Set to `true` for the field's set accessor to ignore attempts to set this field.
       * @config {Boolean}
       * @default
       */
      readOnly: false,
      /**
       * By default, defined {@link Core.data.Model} fields may be used to create a grid column
       * suitable for diplaying that field in a grid cell. Some fields may not be suitable for
       * features which automatically generate columns for view. These fields are created using
       * `internal : true`. Some examples are the `expanded` and `rowHeight` fields which are used
       * internally.
       * @config {Boolean}
       * @default
       */
      internal: false,
      useProp: null
    };
  }
  /**
   * The class that first defined this field. Derived classes that override a field do not change this property.
   * @member {Core.data.Model} definedBy
   * @private
   * @readonly
   */
  /**
   * The class that most specifically defined this field. Derived classes that override a field set this property to
   * themselves.
   * @member {Core.data.Model} owner
   * @private
   * @readonly
   */
  // NOTE: Since we create lots of instances, they have no life cycle (they are not destroyed) and are readonly after
  // creation, this class does not use configurable.
  construct(config) {
    const me = this;
    if (config) {
      me.name = config.name;
      Object.assign(me, config);
    }
    if (me.compare) {
      me.compareItems = (itemA, itemB) => me.compare(itemA == null ? void 0 : itemA[me.name], itemB == null ? void 0 : itemB[me.name]);
    }
  }
  /**
   * This method transforms a data value into the desired form for storage in the record's data object.
   *
   * ```javascript
   * export default class Task extends TaskModel {
   *    static get fields() {
   *        return [
   *            {
   *                name    : 'status',
   *                convert : (value, data) => {
   *                    if (value >= 100) {
   *                        return 'done';
   *                    }
   *                    else if (value > 0) {
   *                        return 'started';
   *                    }
   *                }
   *            }
   *        ];
   *    }
   * }
   * ```
   *
   * @method convert
   * @param {*} value The value to convert for storage in a record.
   * @param {Object} data The raw record data object
   * @returns {*} The converted value.
   */
  /**
   * This method transforms a data value into the desired form for transmitting to a server.
   * @method serialize
   * @param {*} value The value to serialize
   * @param {Core.data.Model} record The record that contains the value being serialized.
   * @returns {*} The serialized value.
   */
  /**
   * This optional method is called when setting a data value on a record.
   * @method set
   * @param {*} value The value to set
   * @param {Object} data The records future or current data object to set value to
   * @param {Core.data.Model} record The record that owns or will own the data object
   * @internal
   */
  /**
   * This optional method is called when a record using this field is created.
   * @method init
   * @param {Core.data.Model} record The record being created
   * @internal
   */
  /**
   * Create getter and setter functions for the specified field name under the specified key.
   * @internal
   */
  defineAccessor(target, force) {
    const { name, dataSource } = this;
    if (!force && name in target && target.$meta.hierarchy.some((current) => {
      var _a2;
      return ((_a2 = getOwnPropertyDescriptor2(current.prototype, name)) == null ? void 0 : _a2.enumerable) === false;
    })) {
      return;
    }
    Reflect.defineProperty(target, name, {
      configurable: true,
      // To allow removing it later
      enumerable: true,
      // no arrow functions here, need `this` to change to instance
      get: this.complexMapping ? function() {
        return this.complexGet(name, dataSource);
      } : function() {
        if (this.batching && name in this.meta.batchChanges) {
          return this.meta.batchChanges[name];
        }
        return dataSource in this.data ? this.data[dataSource] : this.data[name];
      },
      // no arrow functions here, need `this` to change to instance
      set(value) {
        const field2 = this.$meta.fields.map[name];
        if (!(field2 && field2.readOnly)) {
          this.set(name, value);
        }
      }
    });
  }
  /**
   * Compares two values for this field and returns `true` if they are equal, and `false` if not.
   * @param {*} first The first value to compare for equality.
   * @param {*} second The second value to compare for equality.
   * @returns {Boolean} `true` if `first` and `second` are equal.
   */
  isEqual(first, second) {
    return ObjectHelper.isEqual(first, second);
  }
  /**
   * Returns the given field value as a `String`. If `value` is `null` or `undefined`, the value specified by
   * {@link #config-nullText} is returned.
   * @param {*} value The value to convert to a string.
   * @returns {String}
   */
  print(value) {
    return value == null ? this.nullText : this.printValue(value);
  }
  /**
   * Returns the given, non-null field value as a `String`.
   * @param {*} value The value to convert to a string (will not be `null` or `undefined`).
   * @returns {String}
   * @protected
   */
  printValue(value) {
    return String(value);
  }
};
DataField._$name = "DataField";

// ../Core/lib/Core/data/field/ArrayDataField.js
var ArrayDataField = class extends DataField {
  isEqual(a, b) {
    return a === b;
  }
  getAt(record, index) {
    return record.get(this.name)[index];
  }
};
__publicField(ArrayDataField, "$name", "ArrayDataField");
__publicField(ArrayDataField, "type", "array");
ArrayDataField.initClass();
ArrayDataField._$name = "ArrayDataField";

// ../Core/lib/Core/data/field/BooleanDataField.js
var BooleanDataField = class extends DataField {
  static get $name() {
    return "BooleanDataField";
  }
  static get type() {
    return "boolean";
  }
  static get alias() {
    return "bool";
  }
  static get prototypeProperties() {
    return {
      /**
       * The value to replace `null` when the field is not `nullable`.
       * @config {Boolean}
       * @default
       */
      nullValue: false
    };
  }
  isEqual(first, second) {
    if (first == null && second == null) {
      return true;
    }
    return super.isEqual(first, second);
  }
  convert(value) {
    var _a2;
    if (value == null) {
      return this.nullable ? value : this.nullValue;
    }
    if (((_a2 = value.toLowerCase) == null ? void 0 : _a2.call(value)) === "false") {
      return false;
    }
    return Boolean(value);
  }
};
BooleanDataField.initClass();
BooleanDataField._$name = "BooleanDataField";

// ../Core/lib/Core/data/field/DateDataField.js
var DateDataField = class extends DataField {
  static get $name() {
    return "DateDataField";
  }
  static get type() {
    return "date";
  }
  static get prototypeProperties() {
    return {
      /**
       * The format of the date field.
       *
       * See {@link Core.helper.DateHelper DateHelper} for details.
       * @config {String} format
       * @default DateHelper.defaultFormat
       */
      format: null
    };
  }
  convert(value) {
    if (value == null) {
      if (!this.nullable) {
        value = this.nullValue;
      }
    } else if (value === "now") {
      value = /* @__PURE__ */ new Date();
    } else if (!(value instanceof Date)) {
      value = DateHelper.parse(value, this.format || DateHelper.defaultParseFormat);
      if (!value || isNaN(value)) {
        value = void 0;
      }
    }
    return value;
  }
  serialize(value) {
    if (value instanceof Date) {
      value = DateHelper.format(value, this.format || DateHelper.defaultFormat);
    }
    return value;
  }
  printValue(value) {
    return DateHelper.format(value, this.format || DateHelper.defaultFormat);
  }
};
DateDataField.initClass();
DateDataField._$name = "DateDataField";

// ../Core/lib/Core/data/field/StringDataField.js
var StringDataField = class extends DataField {
  static get $name() {
    return "StringDataField";
  }
  static get type() {
    return "string";
  }
  static get prototypeProperties() {
    return {
      /**
       * The value to replace `null` when the field is not `nullable`.
       * @config {String}
       * @default
       */
      nullValue: ""
    };
  }
  convert(value) {
    return value == null ? this.nullable ? value : this.nullValue : String(value);
  }
};
StringDataField.initClass();
StringDataField._$name = "StringDataField";

// ../Core/lib/Core/data/field/DurationUnitDataField.js
var DurationUnitDataField = class extends StringDataField {
  static get $name() {
    return "DurationUnitDataField";
  }
  static get type() {
    return "durationunit";
  }
  isEqual(first, second) {
    return DateHelper.compareUnits(first, second) === 0;
  }
};
DurationUnitDataField.initClass();
DurationUnitDataField._$name = "DurationUnitDataField";

// ../Core/lib/Core/data/field/IntegerDataField.js
var IntegerDataField = class extends DataField {
  static get $name() {
    return "IntegerDataField";
  }
  static get type() {
    return "integer";
  }
  static get alias() {
    return "int";
  }
  static get prototypeProperties() {
    return {
      /**
       * The value to replace `null` when the field is not `nullable`.
       * @config {Number}
       * @default
       */
      nullValue: 0,
      /**
       * The `Math` method to use to ensure fractional component is removed.
       * @config {'round'|'floor'|'ceil'}
       * @default
       */
      rounding: "round"
    };
  }
  convert(value) {
    return value == null ? this.nullable ? value : this.nullValue : Math[this.rounding](Number(value));
  }
};
IntegerDataField.initClass();
IntegerDataField._$name = "IntegerDataField";

// ../Core/lib/Core/data/field/ModelDataField.js
var ModelDataField = class extends DataField {
  static get $name() {
    return "ModelDataField";
  }
  static get type() {
    return "model";
  }
  static get prototypeProperties() {
    return {
      complexMapping: true
    };
  }
  isEqual(first, second) {
    return first && second && second instanceof first.constructor && second.id == first.id;
  }
};
ModelDataField.initClass();
ModelDataField._$name = "ModelDataField";

// ../Core/lib/Core/data/field/NumberDataField.js
var NumberDataField = class extends DataField {
  static get $name() {
    return "NumberDataField";
  }
  static get type() {
    return "number";
  }
  static get alias() {
    return "float";
  }
  static get prototypeProperties() {
    return {
      /**
       * The value to replace `null` when the field is not `nullable`.
       * @config {Number}
       * @default
       */
      nullValue: 0,
      /**
       * The numeric precision of this field. Values are rounded to the specified number of digits. If `null`,
       * the default, no rounding is performed.
       * @config {Number}
       * @default
       */
      precision: null
    };
  }
  isEqual(first, second) {
    return isNaN(Number(first)) && isNaN(Number(second)) || super.isEqual(first, second);
  }
  convert(value) {
    if (value == null) {
      return this.nullable ? value : this.nullValue;
    }
    value = Number(value);
    if (isNaN(value)) {
      return;
    }
    let scale = this.precision;
    if (scale) {
      scale = 10 ** scale;
      value = Math.round(value * scale) / scale;
    } else if (scale === 0) {
      value = Math.round(value);
    }
    return value;
  }
};
NumberDataField.initClass();
NumberDataField._$name = "NumberDataField";

// ../Core/lib/Core/data/field/ObjectDataField.js
var ObjectDataField = class extends DataField {
  static get $name() {
    return "ObjectDataField";
  }
  static get type() {
    return "object";
  }
  static get prototypeProperties() {
    return {
      complexMapping: true
    };
  }
};
ObjectDataField.initClass();
ObjectDataField._$name = "ObjectDataField";

// ../Core/lib/Core/data/field/StoreDataField.js
var StoreDataField = class extends DataField {
  /**
   * Store class to use when creating the store.
   *
   * ```javascript
   * class TodoStore extends Store {
   *     ...
   * }
   *
   * const task = new Store({
   *     static fields = [
   *         { type : 'store', name: 'todoItems', storeClass : TodoStore }
   *     ]
   * });
   * ```
   *
   * @config {Class} storeClass
   * @typings {typeof Store}
   */
  /**
   * Model class to use for the store (can also be configured as usual on the store class, this config is for
   * convenience).
   *
   * ```javascript
   * class TodoItem extends Model {
   *   ...
   * }
   *
   * const task = new Store({
   *     static fields = [
   *         { type : 'store', name: 'todoItems', storeClass : Store, modelClass : TodoItem }
   *     ]
   * });
   * ```
   *
   * @config {Class} modelClass
   * @typings {typeof Model}
   */
  /**
   * Optional store configuration object to apply when creating the store.
   *
   * ```javascript
   * const task = new Store({
   *     static fields = [
   *         {
   *             type       : 'store',
   *             name       : 'todoItems',
   *             storeClass : Store
   *             store      : {
   *                  syncDataOnLoad : false
   *             }
   *         }
   *     ]
   * });
   * ```
   *
   * @config {StoreConfig} store
   */
  // Initializer, called when creating a record. Sets up the store and populates it with any initial data
  init(data, record) {
    var _a2;
    const me = this, storeName = `${me.name}Store`, config = { skipStack: true, syncDataOnLoad: true };
    if (me.store) {
      ObjectHelper.assign(config, me.store);
    }
    if (me.modelClass) {
      config.modelClass = me.modelClass;
    }
    (_a2 = record[`init${StringHelper.capitalize(storeName)}`]) == null ? void 0 : _a2.call(record, config);
    if (!config.storeClass && !me.storeClass) {
      throw new Error(`Field '${me.name}' with type 'store' must have a storeClass configured`);
    }
    const store = record.meta[storeName] = new (config.storeClass || me.storeClass)(config);
    if (me.complexMapping) {
      ObjectHelper.setPath(data, me.dataSource, store);
    } else {
      data[me.dataSource] = store;
    }
    store.verifyNoGeneratedIds = false;
    store.usesId = !store.count || !store.every((record2) => record2.hasGeneratedId);
    store.$currentValue = me.getValue(store);
    store.ion({
      change: ({ action }) => {
        const value = me.getValue(store);
        if (!store.$isSettingStoreFieldData) {
          const oldPreserveCurrentDataset = store.$preserveCurrentDataset;
          store.$preserveCurrentDataset = me.subStore && (action === "update" || action === "remove" || action === "add");
          me.$isUpdatingRecord = true;
          record.set(me.name, value);
          me.$isUpdatingRecord = false;
          store.$preserveCurrentDataset = oldPreserveCurrentDataset;
        }
        store.$currentValue = value;
      }
    });
  }
  // Called when setting a new value to the field on a record
  set(value, data, record) {
    var _a2, _b;
    const me = this, storeName = `${me.name}Store`, { [storeName]: store } = record.meta;
    if (!store) {
      record.meta.initableValues.set(me, value);
      return false;
    }
    if (store.$isSettingStoreFieldData) {
      return;
    }
    store.$isSettingStoreFieldData = true;
    value = (_b = (_a2 = record[`process${StringHelper.capitalize(storeName)}Data`]) == null ? void 0 : _a2.call(record, value, record)) != null ? _b : value;
    if (!store.$preserveCurrentDataset) {
      store.data = value;
    }
    store.$isSettingStoreFieldData = false;
    store.usesId = !store.count || !store.every((record2) => record2.hasGeneratedId);
  }
  serialize(value, record) {
    const store = record.meta[`${this.name}Store`];
    return this.$isUpdatingRecord ? this.getValue(store) : store.$currentValue;
  }
  // Extract persistable values, optionally including id depending on if ids are used
  getValue(store) {
    return store.allRecords.map((r) => {
      const data = r.persistableData;
      if (!store.usesId) {
        delete data.id;
      }
      return data;
    });
  }
  isEqual(a, b) {
    if (a == null ? void 0 : a.isStore) {
      a = a.$currentValue;
    }
    if (b == null ? void 0 : b.isStore) {
      b = b.$currentValue;
    }
    return ObjectHelper.isDeeplyEqual(a, b);
  }
  // Cloned value to be able to restore it later using STM
  getOldValue(record) {
    const store = record.meta[`${this.name}Store`];
    return store ? ObjectHelper.clone(store.$currentValue) : null;
  }
  getAt(record, index) {
    const store = record.meta[`${this.name}Store`];
    return store == null ? void 0 : store.getAt(index);
  }
};
__publicField(StoreDataField, "$name", "StoreDataField");
__publicField(StoreDataField, "type", "store");
StoreDataField.initClass();
StoreDataField._$name = "StoreDataField";

// ../Core/lib/Core/data/Model.js
var nestedRe = new RegExp(/^(.*?)\.(.*)/);
var arrayRe = /(.*)\[(.*)]\.?(.*)/;
var { defineProperty: defineProperty5 } = Reflect;
var { hasOwn: hasOwn3 } = ObjectHelper;
var _undefined = void 0;
var internalProps = {
  children: 1,
  data: 1,
  meta: 1
};
var abbreviationFields = [
  "name",
  "title",
  "text",
  "label",
  "description"
];
var fieldDataTypes = {
  boolean: 1,
  number: 1,
  date: 1,
  object: 1
};
var fieldsOrder = {
  parentId: 1,
  $PhantomId: 2,
  id: 3
};
var _Model = class extends Base2.mixin(ModelStm_default, TreeNode_default, ModelLink_default) {
  static get $name() {
    return "Model";
  }
  static get declarable() {
    return [
      /**
       * Array of defined fields for this model class. Subclasses add new fields by implementing this static
       * getter:
       *
       * ```javascript
       * // Model defining two fields
       * class Person extends Model {
       *     static get fields() {
       *         return [
       *             { name : 'username', defaultValue : 'New person' },
       *             { name : 'birthdate', type : 'date' }
       *         ];
       *     }
       * }
       *
       * // Subclass overriding one of the fields
       * class Bot extends Person {
       *     static get fields() {
       *         return [
       *             // Default value of 'username' field is overridden, any other setting from the parents
       *             // definition is preserved
       *             { name : 'username', defaultValue : 'Bot' }
       *         ];
       *     }
       * }
       * ```
       *
       * Fields in a subclass are merged with those from the parent class, making it easy to override mappings,
       * formats etc.
       *
       * @member {Array<String|ModelFieldConfig|Core.data.field.DataField>} fields
       * @readonly
       * @static
       * @category Fields
       */
      "fields"
    ];
  }
  static get fields() {
    return [
      // The index of this item in its parent (respects filtering)
      {
        name: "parentIndex",
        type: "number",
        persist: false,
        internal: true
      },
      // The index of this item in its parent ghost (non-sortable) children array
      {
        name: "orderedParentIndex",
        type: "number",
        persist: false,
        internal: true
      },
      /**
       * Flag the record as read-only on the UI level, preventing the end user from manipulating it using editing
       * features such as cell editing and event dragging.
       *
       * Does not prevent altering the record programmatically, it can still be manipulated by application code.
       *
       * For more info, see the "Read-only records" section above.
       *
       * @field {Boolean} readOnly
       * @category Common
       */
      {
        name: "readOnly",
        type: "boolean"
      },
      /**
       * Start expanded or not (only valid for tree data)
       * @readonly
       * @field {Boolean} expanded
       * @category Tree
       */
      {
        name: "expanded",
        internal: true
      }
    ];
  }
  /**
   * Template static getter which is supposed to be overridden to define default field values for the Model class.
   * Overrides `defaultValue` config specified by the {@link #property-fields-static} getter.
   * Returns a named object where key is a field name and value is a default value for the field.
   *
   * NOTE: This is a legacy way of defining default values, we recommend using {@link #property-fields-static} moving
   * forward.
   *
   * ```javascript
   * class Person extends Model {
   *     static get fields() {
   *         return [
   *             { name : 'username', defaultValue : 'New person' }
   *         ];
   *     }
   * }
   *
   * class Bot extends Person {
   *     static get defaults() {
   *         return {
   *             username : 'Bot' // default value of 'username' field is overridden
   *         };
   *     }
   * }
   * ```
   *
   * @member {Object} defaults
   * @static
   * @category Fields
   */
  /**
   * The data source for the id field which provides the ID of instances of this Model.
   * @property {String}
   * @category Fields
   */
  static set idField(idField) {
    this._assignedIdField = true;
    this._idField = idField;
  }
  static get idField() {
    return this._idField;
  }
  /**
   * The name of the data field which holds children of this Model when used in a tree structure
   * ```javascript
   * MyModel.childrenField = 'kids';
   * const parent = new MyModel({
   *     name : 'Dad',
   *     kids : [
   *         { name : 'Daughter' },
   *         { name : 'Son' }
   *     ]
   * });
   * ```
   * @property {String}
   * @category Fields
   */
  static set childrenField(childrenField) {
    this._childrenField = childrenField;
  }
  static get childrenField() {
    if (!this._childrenField) {
      const dataField = this.fieldMap.children;
      this._childrenField = (dataField == null ? void 0 : dataField.dataSource) || "children";
    }
    return this._childrenField;
  }
  /**
   * Returns index path to this node. This is the index of each node in the node path
   * starting from the topmost parent. (only relevant when its part of a tree store).
   * @returns {Number[]} The index of each node in the path from the topmost parent to this node.
   * @category Parent & children
   * @private
   */
  get indexPath() {
    const indices = [];
    let node = this, depth = node.childLevel;
    for (node = this; node && !node.isRoot; node = node.parent) {
      indices[depth--] = node.parentIndex + 1;
    }
    return indices;
  }
  /**
   * Unique identifier for the record. Might be mapped to another dataSource using idField, but always exposed as
   * record.id. Will get a generated value if none is specified in records data.
   *
   * {@note}Note that generated ids are meant to be temporary (phantom ids), they should not be serialized
   * but instead replaced by the backend on commit{/@note}
   *
   * @field {String|Number} id
   * @category Common
   */
  //region Init
  /**
   * Constructs a new record from the supplied data config.
   * @param {Object} [config] Raw model config
   * @param {Core.data.Store} [store] Data store
   * @param {Object} [meta] Meta data
   * @privateparam {Boolean} [skipExpose] Skip exposing properties from data
   * @privateparam {Boolean} [forceUseRaw] Force using raw data, used by copy to not clone data twice
   * @function constructor
   * @category Lifecycle
   */
  construct(config = {}, store = null, meta = null, skipExpose = false, forceUseRaw = false, rawData = false) {
    var _a2, _b;
    const me = this, stores = (_a2 = ArrayHelper.asArray(store)) != null ? _a2 : [], { constructor, fieldMap } = me;
    let configs = null;
    store = stores[0];
    me.meta = {
      modified: {},
      ...constructor.metaConfig,
      ...meta
    };
    if (constructor.applyConfigs) {
      for (const key in me.getDefaultConfiguration()) {
        if (!configs) {
          configs = {};
          if (!me.useRawData || !me.useRawData.enabled) {
            config = { ...config };
          }
        }
        if (key in config) {
          if (config[key] !== void 0) {
            configs[key] = config[key];
          }
          delete config[key];
        }
      }
    }
    super.construct(configs);
    if (!skipExpose) {
      constructor.exposeProperties(config, rawData);
    }
    if (!hasOwn3(constructor, "idFieldProcessed")) {
      let overriddenIdField = me.meta.idField;
      if (!overriddenIdField) {
        if (constructor._assignedIdField) {
          overriddenIdField = constructor.idField;
        } else if (store) {
          overriddenIdField = store.idField;
        }
      }
      if (overriddenIdField && overriddenIdField !== fieldMap.id.dataSource) {
        constructor.addField({
          name: "id",
          dataSource: overriddenIdField,
          internal: true
        });
      }
      constructor._idField = fieldMap.id.dataSource;
      constructor.idFieldProcessed = true;
    }
    me._internalId = _Model._internalIdCounter++;
    me.stores = [];
    me.unjoinedStores = [];
    if (!me.originalData) {
      me.originalData = config;
    }
    me.data = constructor.processData(config, false, store, me, forceUseRaw);
    ((_b = me.meta.initableValues) == null ? void 0 : _b.size) && me.assignInitables();
    if (me.id == null) {
      me.setData("id", me.generateId(store));
    }
    if (me.data[constructor.childrenField]) {
      me.processChildren(stores);
    }
    me.generation = 0;
  }
  /**
   * Set this property to `true` when adding a record on a conditional basis, that is, it is yet
   * to be confirmed as an addition.
   *
   * When this is set, the {@link #property-isPersistable} value of the record is **false**, and upon being
   * added to a Store it will *not* be eligible to be synced with the server as an added record.
   *
   * Subsequently, *clearing* this property means this record will become persistable and eligible
   * for syncing as an added record.
   * @property {Boolean}
   * @category Editing
   */
  set isCreating(isCreating) {
    const me = this;
    if (Boolean(me.meta.isCreating) !== isCreating) {
      me.meta.isCreating = isCreating;
      me.stores.forEach((s) => {
        s.onIsCreatingToggle(me, isCreating);
      });
    }
  }
  get isCreating() {
    return Boolean(this.meta.isCreating);
  }
  /**
   * Compares this Model instance to the passed instance. If they are of the same type, and all fields
   * (except, obviously, `id`) are equal, this returns `true`.
   * @param {Core.data.Model} other The record to compare this record with.
   * @returns {Boolean} `true` if the other is of the same class and has all fields equal.
   * @category Misc
   */
  equals(other) {
    if (other instanceof this.constructor) {
      for (let fields = this.$meta.fields.defs, i = 0, { length } = fields; i < length; i++) {
        const field2 = fields[i], { name } = field2;
        if (name !== "id" && !field2.isEqual(this.getValue(name), other.getValue(name))) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  get subclass() {
    return new this.constructor(Object.setPrototypeOf({
      id: _undefined
    }, this.data), this.stores[0], null, true);
  }
  /**
   * Processes raw data, converting values and setting defaults.
   * @private
   * @param {Object} data Raw data
   * @param {Boolean} [ignoreDefaults] Ignore setting default values, used when updating
   * @returns {Object} Processed data
   * @category Fields
   */
  static processData(data, ignoreDefaults = false, store, record, forceUseRaw) {
    const { fieldMap, defaultValues } = this, { useRawData = { enabled: false } } = store || {}, processed = forceUseRaw || useRawData.enabled ? data : ObjectHelper.clone(data);
    let fieldName;
    ignoreDefaults = ignoreDefaults || useRawData.disableDefaultValue || forceUseRaw;
    if (!ignoreDefaults) {
      for (fieldName in defaultValues) {
        if (processed[fieldName] === _undefined) {
          let defaultValue2 = defaultValues[fieldName];
          if (Array.isArray(defaultValue2)) {
            defaultValue2 = defaultValue2.slice();
          }
          processed[fieldName] = defaultValue2;
        }
      }
    }
    if (!useRawData.disableTypeConversion && !forceUseRaw) {
      for (fieldName in fieldMap) {
        const field2 = fieldMap[fieldName], { name, dataSource } = field2, hasSource = dataSource !== name, complex = field2.complexMapping, sourceExists = hasSource && (complex ? ObjectHelper.pathExists(data, dataSource) : dataSource in data), useNameForValue = name in data && (!hasSource || !sourceExists), convert = !useRawData.disableTypeConversion && field2.convert;
        if (useNameForValue || convert) {
          if (!ignoreDefaults || useNameForValue || sourceExists) {
            const value = useNameForValue ? processed[name] : complex ? ObjectHelper.getPath(processed, dataSource) : processed[dataSource], converted = convert ? field2.convert(value, data, record) : value;
            if (complex) {
              ObjectHelper.setPath(processed, dataSource, converted);
            } else {
              processed[dataSource] = converted;
            }
            if (hasSource) {
              delete processed[name];
            }
          }
        }
      }
    }
    this.$meta.fields.initable.length && this.initInitables(record, processed);
    return processed;
  }
  static setupClass(meta) {
    super.setupClass(meta);
    if (!meta.fields) {
      this.setupFields(this, meta);
    }
  }
  static setupFields(cls, meta) {
    var _a2, _b, _c, _d, _e;
    const classFields = hasOwn3(cls, "fields") && cls.fields, base = meta.super.fields, fieldsInfo = meta.fields = {
      defs: (_a2 = base == null ? void 0 : base.defs.slice()) != null ? _a2 : [],
      // Set to true when an instance's data object is run through exposeProperties
      exposedData: false,
      // These objects are all keyed by field name:
      defaults: base ? { ...base.defaults } : {},
      // value=field.defaultValue
      exposed: Object.create((_b = base == null ? void 0 : base.exposed) != null ? _b : null),
      // value=true if we've done defineProperty
      ordinals: Object.create((_c = base == null ? void 0 : base.ordinals) != null ? _c : null),
      // value=index in the defs array
      map: Object.create((_d = base == null ? void 0 : base.map) != null ? _d : null),
      // value=definition object
      sources: Object.create((_e = base == null ? void 0 : base.sources) != null ? _e : null)
      // value=source definition object
    };
    if (hasOwn3(cls, "defaults")) {
      Object.assign(fieldsInfo.defaults, cls.defaults);
    }
    if (hasOwn3(cls, "idField")) {
      cls.addField({
        name: "id",
        dataSource: cls.idField,
        internal: true
      });
      fieldsInfo.exposed[cls.idField] = true;
    }
    if (classFields == null ? void 0 : classFields.length) {
      classFields.map(cls.addField, cls);
    }
    fieldsInfo.initable = fieldsInfo.defs.filter((field2) => field2.init);
    cls.exposeRelations();
  }
  static get defaultValues() {
    return this.$meta.fields.defaults;
  }
  /**
   * An array containing all the _defined_ fields for this Model class. This will include all superclass's
   * defined fields.
   * @property {Core.data.field.DataField[]}
   * @static
   * @readonly
   * @category Fields
   */
  static get allFields() {
    return this.$meta.fields.defs;
  }
  /**
   * Same as {@link #property-allFields-static}.
   * @property {Core.data.field.DataField[]}
   * @readonly
   * @category Fields
   */
  get allFields() {
    return this.$meta.fields.defs;
  }
  /**
   * An object containing all the _defined_ fields for this Model class. This will include all superclass's
   * defined fields through its prototype chain. So be aware that `Object.keys` and `Object.entries` will only
   * access this class's defined fields.
   * @property {Object<String,Core.data.field.DataField>}
   * @static
   * @readonly
   * @category Fields
   */
  static get fieldMap() {
    return this.$meta.fields.map;
  }
  /**
   * Same as {@link #property-fieldMap-static}.
   * @property {Object<String,Core.data.field.DataField>}
   * @readonly
   * @category Fields
   */
  get fieldMap() {
    return this.$meta.fields.map;
  }
  static get fieldDataSourceMap() {
    return this.$meta.fields.sources;
  }
  /**
   * Makes getters and setters for fields (from definitions and data). Called once when class is defined and once when
   * data is loaded first time.
   * @internal
   * @param {Object} [data] Raw data
   * @param {Boolean} [raw=true] True if data is raw (contains data sources), False if data contains field names
   * @category Fields
   */
  static exposeProperties(data, raw = true) {
    const me = this, fieldsInfo = me.$meta.fields, fieldMapProperty = raw ? "exposed" : "map";
    if (data && me.autoExposeFields && !fieldsInfo.exposedData) {
      let dataProperty, fieldDef, type;
      for (dataProperty in data) {
        if (!fieldsInfo[fieldMapProperty][dataProperty] && dataProperty !== me.childrenField) {
          type = ObjectHelper.typeOf(data[dataProperty]);
          fieldDef = {
            name: dataProperty,
            dataSource: dataProperty,
            fromData: true
          };
          if (fieldDataTypes[type]) {
            fieldDef.type = type;
          }
          me.addField(fieldDef);
        }
      }
      fieldsInfo.exposedData = true;
    }
    me.exposeRelations();
  }
  /**
   * Add a field definition in addition to those predefined in `fields`.
   * @param {String|ModelFieldConfig} fieldDef A field name or definition
   * @category Fields
   */
  static addField(fieldDef) {
    if (fieldDef == null) {
      return;
    }
    if (typeof fieldDef === "string") {
      fieldDef = {
        name: fieldDef
      };
    }
    const me = this.initClass(), fieldsInfo = me.$meta.fields, { ordinals } = fieldsInfo, propertiesExposed = fieldsInfo.exposed, { name } = fieldDef, existing = fieldsInfo.map[name], dataSource = fieldDef.dataSource || (fieldDef.dataSource = name);
    let field2, key;
    if (!existing || fieldDef.type && fieldDef.type !== existing.type) {
      field2 = DataField.create(fieldDef);
      field2.definedBy = existing ? existing.definedBy : me;
      field2.ordinal = existing ? existing.ordinal : ordinals[name] = fieldsInfo.defs.length;
    } else {
      field2 = Object.create(existing);
      for (key in fieldDef) {
        if (key !== "type") {
          field2[key] = fieldDef[key];
        }
      }
    }
    field2.owner = me;
    fieldsInfo.defs[field2.ordinal] = field2;
    fieldsInfo.map[name] = field2;
    if (!fieldsInfo.sources[dataSource]) {
      fieldsInfo.sources[dataSource] = field2;
    }
    if (dataSource.includes(".")) {
      field2.complexMapping = true;
    }
    if (field2.complexMapping) {
      propertiesExposed[dataSource.split(".")[0]] = true;
    } else {
      propertiesExposed[dataSource] = true;
    }
    if ("defaultValue" in field2) {
      fieldsInfo.defaults[dataSource] = field2.defaultValue;
    }
    if (!internalProps[name]) {
      field2.defineAccessor(me.prototype);
    }
    me._nonPersistableFields = null;
    me._alwaysWriteFields = null;
    return field2;
  }
  /**
   * Remove a field definition by name.
   * @param {String} fieldName Field name
   * @category Fields
   */
  static removeField(fieldName) {
    const me = this.initClass(), fieldsInfo = me.$meta.fields, definition = fieldsInfo.map[fieldName], { ordinals } = fieldsInfo, index = ordinals[fieldName];
    if (definition) {
      fieldsInfo.defs.splice(index, 1);
      delete ordinals[fieldName];
      delete fieldsInfo.defaults[fieldName];
      delete fieldsInfo.exposed[fieldName];
      delete fieldsInfo.map[fieldName];
      delete fieldsInfo.sources[definition.dataSource];
      for (const name in ordinals) {
        if (ordinals[name] > index) {
          --ordinals[name];
        }
      }
      delete me.prototype[fieldName];
    }
  }
  /**
   * Makes getters and setters for related records. Populates a Model#relation array with the relations, to allow it
   * to be modified later when assigning stores.
   * @internal
   * @category Relations
   */
  static exposeRelations() {
    const me = this;
    if (hasOwn3(me, "exposedRelations")) {
      return;
    }
    if (me.relations) {
      me.exposedRelations = [];
      for (const relationName in me.relations) {
        const relation = me.relations[relationName];
        relation.relationName = relationName;
        me.exposedRelations.push(relation);
        if (!Reflect.ownKeys(me.prototype).includes(relationName)) {
          defineProperty5(me.prototype, relationName, {
            enumerable: true,
            get: function() {
              return this.getForeign(relationName);
            },
            set: function(value) {
              this.setForeign(relationName, value, relation);
            }
          });
        }
      }
    }
  }
  //endregion
  //region Initable fields
  // Initializes any fields using a data type that has an init method, and caches the value to assign to that field to
  // be able to assign it after all others. That allows the initter to reference the records other data if needed
  // (baselines use that to reference the task to get default values)
  static initInitables(record, processedData) {
    const laterValues = record.meta.initableValues = /* @__PURE__ */ new Map();
    for (const field2 of this.$meta.fields.initable) {
      const value = ObjectHelper.getPath(processedData, field2.dataSource);
      value !== void 0 && laterValues.set(field2, value);
      !field2.lazy && field2.init(processedData, record);
    }
  }
  // Assigns values to the fields that were initialized earlier (see initInitables above)
  assignInitables() {
    const { initableValues } = this.meta;
    for (const [field2, value] of initableValues) {
      if (field2.set(value, this.data, this) !== false) {
        initableValues.delete(field2);
      }
    }
  }
  //endregion
  //region Fields
  /**
   * Flag checked from Store when loading data that determines if fields found in first records should be exposed in
   * same way as predefined fields.
   *
   * {@note}Note that we for all but the most basic use cases recommend explicitly defining the fields.
   * Having them auto exposed can lead to unexpected behavior, if the first record is not complete (fields missing,
   * null etc).
   * {/@note}
   *
   * @property {Boolean}
   * @category Fields
   */
  static get autoExposeFields() {
    return true;
  }
  /**
   * This function forces correct field order. Correct order is parentId before id. If we process id field before
   * parentId, idMap won't be updated and changing parent node will lead to duplicated records in storage
   * @param {String} a
   * @param {String} b
   * @returns {number}
   * @private
   */
  static fieldSorter(a, b) {
    return (fieldsOrder[a] || 100) - (fieldsOrder[b] || 100);
  }
  /**
   * Convenience getter to get field definitions from class.
   * @property {Core.data.field.DataField[]}
   * @readonly
   * @category Fields
   */
  get fields() {
    return this.$meta.fields.defs;
  }
  /**
   * Convenience function to get the definition for a field from class.
   * @param {String} fieldName Field name
   * @returns {Core.data.field.DataField}
   * @category Fields
   */
  getFieldDefinition(fieldName) {
    return this.$meta.fields.map[fieldName];
  }
  getFieldDefinitionFromDataSource(dataSource) {
    return this.$meta.fields.sources[dataSource];
  }
  /**
   * Get the names of all fields in data.
   * @property {String[]}
   * @readonly
   * @category Fields
   */
  get fieldNames() {
    return Object.keys(this.data);
  }
  /**
   * Get the definition for a field by name. Caches results.
   * @param {String} fieldName Field name
   * @returns {Core.data.field.DataField} Field definition or null if none found
   * @category Fields
   */
  static getFieldDefinition(fieldName) {
    return this.$meta.fields.map[fieldName];
  }
  /**
   * Returns dataSource configuration for a given field name
   * @param {String} fieldName
   * @returns {String} Field `dataSource` mapping
   * @internal
   */
  static getFieldDataSource(fieldName) {
    var _a2;
    return ((_a2 = this.getFieldDefinition(fieldName)) == null ? void 0 : _a2.dataSource) || fieldName;
  }
  /**
   * Get the data source used by specified field. Returns the fieldName if no data source specified.
   * @param {String} fieldName Field name
   * @returns {String}
   * @category Fields
   */
  getDataSource(fieldName) {
    const def = this.constructor.getFieldDefinition(fieldName);
    return (def == null ? void 0 : def.dataSource) || (def == null ? void 0 : def.name);
  }
  /**
   * Processes input to a field, converting to expected type.
   * @param {String} fieldName Field name
   * @param {*} value Value to process
   * @returns {*} Converted value
   * @category Fields
   */
  static processField(fieldName, value, record) {
    const field2 = this.fieldMap[fieldName];
    return (field2 == null ? void 0 : field2.convert) ? field2.convert(value, this.data, record) : value;
  }
  //endregion
  //region Relations
  /**
   * Initializes model relations. Called from store when adding a record.
   * @private
   * @category Relations
   */
  initRelations() {
    const me = this, relations = me.constructor.exposedRelations;
    if (!relations) {
      return;
    }
    me.stores.forEach((store) => {
      var _a2;
      if (!store.modelRelations) {
        store.initRelations();
      }
      const relatedRecords = [];
      (_a2 = store.modelRelations) == null ? void 0 : _a2.forEach((config) => {
        relatedRecords.push({ related: me.initRelation(config), config });
      });
      store.updateRecordRelationCache(me, relatedRecords);
    });
  }
  /**
   * Initializes/updates a single relation.
   * @param config Relation config
   * @returns {Core.data.Model} Related record
   * @private
   * @category Relations
   */
  initRelation(config) {
    const me = this, foreignId = me.get(config.foreignKey), foreign = foreignId !== _undefined && typeof config.foreignStore !== "string" && config.foreignStore.getById(foreignId), relationCache = me.meta.relationCache || (me.meta.relationCache = {});
    relationCache[config.relationName] = foreign || (foreignId != null ? { id: foreignId, placeHolder: true } : null);
    return foreign;
  }
  removeRelation(config) {
    const { relationName, foreignKey, nullFieldOnRemove } = config;
    if (this.meta.relationCache[relationName]) {
      delete this.meta.relationCache[relationName];
      if (nullFieldOnRemove) {
        this.setData(foreignKey, null);
      }
    }
  }
  getForeign(name) {
    var _a2;
    return (_a2 = this.meta.relationCache) == null ? void 0 : _a2[name];
  }
  setForeign(name, value, config) {
    const id = _Model.asId(value);
    return this.set(config.foreignKey, id);
  }
  /**
   * Get a relation config by name, from the first store.
   * @param {String} name
   * @returns {Object}
   * @private
   * @category Relations
   */
  getRelationConfig(name) {
    var _a2, _b;
    return (_b = (_a2 = this.firstStore) == null ? void 0 : _a2.modelRelations) == null ? void 0 : _b.find((r) => r.foreignKey === name);
  }
  //endregion
  //region Get/set values, data handling
  flatGet(fieldName, dataSource) {
    if (this.batching && fieldName in this.meta.batchChanges) {
      return this.meta.batchChanges[fieldName];
    }
    return dataSource in this.data ? this.data[dataSource] : this.data[fieldName];
  }
  complexGet(fieldName, dataSource) {
    if (this.batching && fieldName in this.meta.batchChanges) {
      return this.meta.batchChanges[fieldName];
    }
    return ObjectHelper.getPath(this.data, dataSource);
  }
  /**
   * Get value for specified field name. You can also use the generated getters if loading through a Store.
   * If model is currently in batch operation this will return updated batch values which are not applied to Model
   * until endBatch() is called.
   * @param {String} fieldName Field name to get value from
   * @returns {*} Fields value
   * @category Fields
   */
  get(fieldName) {
    if (!fieldName) {
      return;
    }
    const me = this, field2 = me.fieldMap[fieldName];
    if (!field2) {
      if (fieldName.includes("[")) {
        const [, arrayFieldName, index, path] = fieldName.match(arrayRe);
        const arrayField = me.fieldMap[arrayFieldName];
        if (arrayField == null ? void 0 : arrayField.getAt) {
          me._thisIsAUsedExpression(me[arrayFieldName]);
          const subRecord = arrayField.getAt(me, index);
          if (subRecord && path) {
            if (subRecord.isModel) {
              return subRecord.getValue(path);
            }
            return subRecord[path];
          }
          return subRecord;
        }
        return null;
      }
      if (fieldName.includes(".")) {
        if (!ObjectHelper.hasPath(me.data, fieldName)) {
          return ObjectHelper.getPath(me, fieldName);
        }
        return me.complexGet(fieldName, fieldName);
      }
    }
    if (field2 == null ? void 0 : field2.complexMapping) {
      return me.complexGet(fieldName, field2.dataSource);
    }
    return me.flatGet(fieldName, (field2 == null ? void 0 : field2.dataSource) || fieldName);
  }
  // Used to get field values, replaces `record[fieldName]` in internal code to allow relations etc.
  getValue(fieldName) {
    if (!fieldName) {
      return;
    }
    if (fieldName in this) {
      return this[fieldName];
    }
    return this.get(fieldName);
  }
  // Used to set field values, replacing `record[fieldName] = value` to handle dot notation
  setValue(fieldName, value) {
    if (fieldName in this) {
      this[fieldName] = value;
    } else {
      this.set(fieldName, value);
    }
  }
  /**
   * Internal function used to update a records underlying data block (record.data) while still respecting field
   * mappings. Needed in cases where a field needs setting without triggering any associated behaviour and it has a
   * dataSource with a different name.
   *
   * For example:
   * ```javascript
   * // startDate mapped to data.beginDate
   * { name : 'startDate', dataSource : 'beginDate' }
   *
   * // Some parts of our code needs to update the data block without triggering any of the behaviour associated with
   * // calling set. This would then not update "beginDate":
   * record.data.startDate = xx;
   *
   * // But this would
   * record.setData('startDate', xx);
   * ```
   * @internal
   * @category Editing
   */
  setData(toSet, value) {
    var _a2, _b;
    const { data, fieldMap } = this;
    if (typeof toSet === "string") {
      const field2 = fieldMap[toSet], dataSource = (_a2 = field2 == null ? void 0 : field2.dataSource) != null ? _a2 : toSet;
      if (field2 == null ? void 0 : field2.set) {
        field2.set(value, this.data, this);
      } else if (field2 == null ? void 0 : field2.complexMapping) {
        ObjectHelper.setPath(data, dataSource, value);
      } else {
        data[dataSource] = value;
      }
    } else {
      const keys = Object.keys(toSet);
      for (let i = 0; i < keys.length; i++) {
        const fieldName = keys[i], field2 = fieldMap[fieldName], dataSource = (_b = field2 == null ? void 0 : field2.dataSource) != null ? _b : fieldName;
        if (field2 == null ? void 0 : field2.set) {
          field2.set(value, this.data, this);
        } else if (dataSource) {
          if (field2 == null ? void 0 : field2.complexMapping) {
            ObjectHelper.setPath(data, dataSource, toSet[fieldName]);
          } else {
            data[dataSource] = toSet[fieldName];
          }
        }
      }
    }
  }
  /**
   * Returns raw data from the encapsulated data object for the passed field name
   * @param {String} fieldName The field to get data for.
   * @returns {*} The raw data value for the field.
   * @category Editing
   */
  getData(fieldName) {
    var _a2;
    const field2 = this.fieldMap[fieldName], dataSource = (_a2 = field2 == null ? void 0 : field2.dataSource) != null ? _a2 : fieldName;
    if (dataSource) {
      if (field2 == null ? void 0 : field2.complexMapping) {
        return ObjectHelper.getPath(this.data, dataSource);
      }
      return this.data[dataSource];
    }
  }
  /**
   * Silently updates record's id with no flagging the property as modified.
   * Triggers onModelChange event for changed id.
   * @param {String|Number} value id value
   * @private
   */
  syncId(value) {
    const oldValue = this.id;
    if (oldValue !== value) {
      this.setData("id", value);
      const data = { id: { value, oldValue } };
      this.afterChange(data, data);
    }
  }
  /**
   * Set value for the specified field. You can also use the generated setters if loading through a Store.
   *
   * Setting a single field, supplying name and value:
   *
   * ```javascript
   * record.set('name', 'Clark');
   * ```
   *
   * Setting multiple fields, supplying an object:
   *
   * ```javascript
   * record.set({
   *     name : 'Clark',
   *     city : 'Metropolis'
   * });
   * ```
   *
   * @param {String|Object} field The field to set value for, or an object with multiple values to set in one call
   * @param {*} [value] Value to set
   * @param {Boolean} [silent] Set to true to not trigger events. If event is recurring, occurrences won't be updated automatically.
   * @privateparam {Boolean} [validOnly] If set to `true` it will ignore setting a `undefined` value, allowing conversion functions to invalidate a data input
   * @privateparam {Boolean} [triggerBeforeUpdate]
   * @fires Store#idChange
   * @fires Store#update
   * @fires Store#change
   * @category Editing
   */
  set(field2, value, silent = false, fromRelationUpdate = false, skipAccessors = false, validOnly = false, triggerBeforeUpdate = true) {
    var _a2;
    const me = this;
    if (me.isBatchUpdating) {
      me.inBatchSet(field2, value, silent || me.$silenceBatch);
      return null;
    } else {
      const wasSet = me.inSet(field2, value, silent, fromRelationUpdate, skipAccessors, validOnly, triggerBeforeUpdate);
      (_a2 = me.afterSet) == null ? void 0 : _a2.call(me, field2, value, silent, fromRelationUpdate, wasSet);
      return wasSet;
    }
  }
  fieldToKeys(field2, value) {
    if (typeof field2 !== "string") {
      return ObjectHelper.assign({}, field2);
    }
    return {
      [field2]: value
    };
  }
  inBatchSet(field2, value, silent) {
    const me = this, {
      meta,
      constructor,
      fieldMap
    } = me, wasSet = {};
    let cmp, changed = false;
    if (typeof field2 !== "string") {
      Object.keys(me.fieldToKeys(field2, value)).forEach((key) => {
        cmp = fieldMap[key] || ObjectHelper;
        value = constructor.processField(key, field2[key], me);
        if (!cmp.isEqual(meta.batchChanges[key], value)) {
          wasSet[key] = {
            value,
            oldValue: me.get(key)
          };
          meta.batchChanges[key] = value;
          changed = true;
        }
      });
    } else {
      cmp = fieldMap[field2] || ObjectHelper;
      if (!cmp.isEqual(meta.batchChanges[field2], value)) {
        wasSet[field2] = {
          value,
          oldValue: me.get(field2)
        };
        meta.batchChanges[field2] = value;
        changed = true;
      }
    }
    if (changed) {
      me.generation++;
      if (!silent) {
        const event = {
          action: "update",
          record: me,
          records: [me],
          changes: wasSet
        };
        me.stores.forEach((store) => {
          store.trigger("batchedUpdate", { ...event });
        });
        me.forEachLinked(
          (store, record) => store.trigger("batchedUpdate", { ...event, record, records: [record] })
        );
      }
    }
  }
  inSet(fieldNameOrObject, value, silent, fromRelationUpdate, skipAccessors = false, validOnly = false, triggerBeforeUpdate = true) {
    var _a2, _b, _c;
    const me = this, {
      data,
      meta,
      fieldMap,
      constructor
    } = me, {
      prototype: myProto,
      childrenField,
      relations
    } = constructor, wasSet = {}, toSet = me.fieldToKeys(fieldNameOrObject, value), keys = Object.keys(toSet).sort(constructor.fieldSorter);
    let changed = false;
    if (!silent && !me.triggerBeforeUpdate(toSet)) {
      return null;
    }
    me.inSetting = true;
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (key === childrenField) {
        continue;
      }
      if (key.includes("[")) {
        const [, arrayFieldName, index, path] = key.match(arrayRe), field3 = me.fieldMap[arrayFieldName];
        if (field3 == null ? void 0 : field3.getAt) {
          const subRecord = field3.getAt(me, index);
          if (subRecord.isModel) {
            subRecord.set(path, toSet[key]);
          } else {
            ObjectHelper.setPath(subRecord, path, toSet[key]);
          }
          continue;
        }
      }
      const complexKey = key.includes(".");
      if (relations && complexKey) {
        const [, relationName, prop] = key.match(nestedRe);
        if (relations[relationName]) {
          me[relationName].set(prop, toSet[key]);
          continue;
        }
      }
      const field2 = fieldMap[key], cmp = field2 || ObjectHelper, readOnly = field2 == null ? void 0 : field2.readOnly, mapping = (_a2 = field2 == null ? void 0 : field2.dataSource) != null ? _a2 : key, useProp = !skipAccessors && !field2 && key in myProto || (field2 == null ? void 0 : field2.useProp), oldValue = useProp ? me[mapping] : (field2 == null ? void 0 : field2.complexMapping) || complexKey ? ObjectHelper.getPath(data, mapping) : data[mapping], value2 = constructor.processField(key, toSet[key], me), val = toSet[key] = { value: value2 }, relation = me.getRelationConfig(key);
      if (!readOnly && !cmp.isEqual(oldValue, value2) && (!validOnly || value2 !== void 0)) {
        me.generation++;
        val.oldValue = (_c = (_b = field2 == null ? void 0 : field2.getOldValue) == null ? void 0 : _b.call(field2, me)) != null ? _c : oldValue;
        changed = true;
        if (key in meta.modified && cmp.isEqual(meta.modified[key], value2)) {
          Reflect.deleteProperty(meta.modified, key);
          if (me.isReverting) {
            me.data[mapping] = value2;
          }
        } else if (!me.ignoreBag) {
          if (!(key in meta.modified)) {
            me.storeFieldChange(key, oldValue);
          }
          if (val.oldValue === _undefined) {
            Reflect.deleteProperty(val, "oldValue");
          }
        }
        wasSet[key] = val;
        me.applyValue(useProp, mapping, value2, skipAccessors, field2);
        if (relation && !fromRelationUpdate) {
          me.initRelation(relation);
          me.stores.forEach((store) => store.cacheRelatedRecord(me, value2, relation.relationName, val.oldValue));
        }
      }
    }
    if (changed) {
      me.afterChange(toSet, wasSet, silent, fromRelationUpdate, skipAccessors);
    }
    me.inSetting = false;
    return changed ? wasSet : null;
  }
  // Provided as a hook for Engine to do what needs to be done which ever way a field value is changed
  applyValue(useProp, key, value, skipAccessors, field2) {
    var _a2;
    const me = this;
    if (((field2 == null ? void 0 : field2.name) || key) === me.constructor.parentIdField) {
      if (!(((_a2 = me.parent) == null ? void 0 : _a2.isRoot) && (value == null || !me.firstStore.getById(value)))) {
        (me.firstStore.getById(value) || me.firstStore.rootNode).insertChild(me, null, false, {
          orderedParentIndex: { skip: true }
        });
      }
    } else if (useProp) {
      me[(field2 == null ? void 0 : field2.name) || key] = value;
    } else if (field2 == null ? void 0 : field2.set) {
      field2.set(value, me.data, me);
    } else {
      let complexMapping = field2 == null ? void 0 : field2.complexMapping;
      if (!field2 && key.includes(".")) {
        const nestedName = key.split(".")[0];
        field2 = me.constructor.fieldMap[nestedName];
        complexMapping = (field2 == null ? void 0 : field2.complexMapping) || (field2 == null ? void 0 : field2.type) === "object";
      }
      if (complexMapping) {
        ObjectHelper.setPath(me.data, key, value);
      } else {
        me.data[key] = value;
      }
    }
  }
  // skipAccessors argument is used in the engine override
  afterChange(toSet, wasSet, silent, fromRelationUpdate, skipAccessors) {
    for (const store of this.stores) {
      store.onModelChange(this, toSet, wasSet, silent, fromRelationUpdate, skipAccessors);
    }
    this.forEachLinked(
      (store, record) => store.onModelChange(record, toSet, wasSet, silent, fromRelationUpdate, skipAccessors)
    );
  }
  // Run fn for each store on each linked record
  forEachLinked(fn2) {
    for (const linked of this.$links) {
      for (const store of linked.stores) {
        fn2(store, linked);
      }
    }
  }
  /**
   * This yields `true` if this record is eligible for syncing with the server.
   * It can yield `false` if the record is in the middle of a {@link #property-isBatchUpdating batched update},
   * or if it is a {@link #property-isCreating tentative record} yet to be confirmed as a new addition.
   * @property {Boolean}
   * @readonly
   */
  get isPersistable() {
    return !this.isBatchUpdating && !this.isCreating;
  }
  /**
   * True if this model has any uncommitted changes.
   * @property {Boolean}
   * @readonly
   * @category Editing
   */
  get isModified() {
    return Boolean(this.meta.modified && Object.keys(this.meta.modified).length > 0);
  }
  get hasPersistableChanges() {
    return this.isPersistable && !ObjectHelper.isEmpty(this.rawModificationData);
  }
  /**
   * Returns true if this model has uncommitted changes for the provided field.
   * @param {String} fieldName Field name
   * @returns {Boolean} True if the field is changed
   * @category Editing
   */
  isFieldModified(fieldName) {
    return this.isModified && fieldName in this.meta.modified;
  }
  /**
   * Returns field value that should be persisted, or `undefined` if field is configured with `persist: false`.
   * @param {String|Core.data.field.DataField} nameOrField Name of the field to get value for, or its field definition
   * @private
   * @category Fields
   */
  getFieldPersistentValue(nameOrField) {
    const field2 = typeof nameOrField === "string" ? this.getFieldDefinition(nameOrField) : nameOrField, name = (field2 == null ? void 0 : field2.name) || nameOrField;
    let result;
    if (!field2 || field2.persist) {
      result = this.getValue(name);
      if (field2 == null ? void 0 : field2.serialize) {
        result = field2.serialize(result, this);
      }
    }
    return result;
  }
  /**
   * Get a map of the modified fields in form of an object. The field *names* are used as the property names
   * in the returned object.
   * @property {Object}
   * @readonly
   * @category Editing
   */
  get modifications() {
    const data = this.rawModifications;
    if (data && Object.keys(data).length) {
      data[this.constructor.idField] = this.id;
    }
    return data;
  }
  get rawModifications() {
    const me = this, data = {};
    if (!me.isModified) {
      return null;
    }
    let keySet = false;
    Object.keys(me.meta.modified).forEach((key) => {
      const value = me.getFieldPersistentValue(key);
      if (value !== _undefined) {
        data[key] = value;
        keySet = true;
      }
    });
    return keySet ? data : null;
  }
  /**
   * Get a map of the modified fields in form of an object. The fields {@link Core.data.field.DataField#config-dataSource}
   * is used as the property name in the returned object. The records id is always included.
   * @property {Object}
   * @readonly
   * @category Editing
   */
  get modificationData() {
    const data = this.rawModificationData;
    if (data && Object.keys(data).length) {
      ObjectHelper.setPath(data, this.constructor.idField, this.id);
    }
    return data;
  }
  /**
   * Returns a map of the modified persistable fields
   * @internal
   * @property {Object}
   * @category Editing
   */
  get rawModificationData() {
    const me = this, { fieldMap } = me.constructor, data = {};
    if (!me.isModified) {
      return null;
    }
    let keySet = false;
    Object.keys(me.meta.modified).forEach((fieldName) => {
      let field2 = fieldMap[fieldName], dataSource = field2 == null ? void 0 : field2.dataSource;
      if (fieldName.includes(".")) {
        const topLevelFieldName = fieldName.match(nestedRe)[1];
        field2 = fieldMap[topLevelFieldName];
        dataSource = fieldName;
      }
      if (field2 == null ? void 0 : field2.persist) {
        const value = me.getFieldPersistentValue(fieldName);
        if (value !== _undefined) {
          ObjectHelper.setPath(data, dataSource, value);
          keySet = true;
        }
      }
    });
    return keySet ? data : null;
  }
  /**
   * Get a map of the modified data fields along with any {@link Core/data/field/DataField#config-alwaysWrite} fields,
   * in form of an object. The fields *dataSource* is used as the property name in the returned object.
   * Used internally by AjaxStore / CrudManager when sending updates.
   * @property {Object}
   * @readonly
   * @category Editing
   */
  get modificationDataToWrite() {
    const alwaysWriteFields = this.constructor.alwaysWriteFields, recordData = this.modificationData;
    alwaysWriteFields.forEach((fieldName) => {
      recordData[this.getFieldDefinition(fieldName).dataSource] = this.getFieldPersistentValue(fieldName);
    });
    return recordData;
  }
  /**
   * Returns data for **all** {@link Core.data.field.DataField#config-persist persistable} fields in form of an
   * object, using dataSource if present.
   * @property {Object}
   * @internal
   * @readonly
   * @category Editing
   */
  get persistableData() {
    const me = this, data = {};
    me.fields.forEach((field2) => {
      const value = me.getFieldPersistentValue(field2);
      if (value !== _undefined) {
        if (field2 == null ? void 0 : field2.complexMapping) {
          ObjectHelper.setPath(data, field2.dataSource, value);
        } else {
          data[field2.dataSource] = value;
        }
      }
    });
    return data;
  }
  get dataByFieldName() {
    const { data } = this;
    return this.fields.reduce((result, field2) => {
      if (ObjectHelper.hasPath(data, field2.dataSource)) {
        result[field2.name] = data[field2.dataSource];
      }
      return result;
    }, {});
  }
  /**
   * True if this models changes are currently being committed.
   * @property {Boolean}
   * @category Editing
   */
  get isCommitting() {
    return Boolean(this.meta.committing);
  }
  /**
   * Clear stored changes, used on commit. Does not revert changes.
   * @param {Boolean} [includeDescendants] Supply `false` to not clear node descendants
   * @privateparam {Boolean} [removeFromStoreChanges] Update related stores modified collection or not
   * @privateparam {Object|null} [changes] Set of changes to clear on the record
   * @category Editing
   */
  clearChanges(includeDescendants = true, removeFromStoreChanges = true, changes = null) {
    const me = this, { meta } = me;
    if (changes) {
      for (const key in changes) {
        delete meta.modified[key];
      }
    } else {
      meta.modified = {};
    }
    const noChanges = ObjectHelper.isEmpty(meta.modified);
    meta.committing = false;
    if (removeFromStoreChanges) {
      me.stores.forEach((store) => {
        noChanges && store.modified.remove(me);
        store.added.remove(me);
        if (includeDescendants) {
          const descendants = store.collectDescendants(me).all;
          store.added.remove(descendants);
          noChanges && store.modified.remove(descendants);
        }
      });
    }
  }
  storeFieldChange(key, oldValue) {
    this.meta.modified[key] = oldValue;
  }
  /**
   * Reverts changes in this back to their original values.
   * @privateparam {Boolean} [silent] Specify `true` to not trigger events.
   * @category Editing
   */
  revertChanges(silent = false) {
    this.isReverting = true;
    this.set(this.meta.modified, _undefined, silent);
    this.isReverting = false;
  }
  applyChangeset(rawChanges, phantomIdField = "$PhantomId", remote = true) {
    var _a2;
    const me = this, modelClass = me.constructor, {
      idField,
      fieldDataSourceMap
    } = modelClass, rawChangesSimplePaths = ObjectHelper.pathifyKeys(rawChanges, fieldDataSourceMap), ownChangesSimplePaths = ObjectHelper.pathifyKeys(me.modificationData), changes = {}, idChanged = phantomIdField in rawChanges;
    for (const dataSource in rawChangesSimplePaths) {
      const field2 = fieldDataSourceMap[dataSource], propName = (_a2 = field2 == null ? void 0 : field2.name) != null ? _a2 : dataSource;
      if (remote || ((field2 == null ? void 0 : field2.name) === idField ? idChanged : rawChangesSimplePaths[dataSource] === ownChangesSimplePaths[dataSource])) {
        changes[propName] = rawChangesSimplePaths[dataSource];
      }
    }
    const wasSet = me.set(changes);
    me.clearChanges(false, true, remote ? null : changes);
    return wasSet ? Object.entries(wasSet).reduce((result, [field2, change]) => {
      result[field2] = change.value;
      return result;
    }, {}) : {};
  }
  //endregion
  //region Id
  /**
   * Gets the records internalId. It is assigned during creation, guaranteed to be globally unique among models.
   * @property {Number}
   * @category Identification
   */
  get internalId() {
    return this._internalId;
  }
  /**
   * Returns true if the record is new and has not been persisted (and received a proper id).
   * @property {Boolean}
   * @readonly
   * @category Identification
   */
  get isPhantom() {
    return this.id === "" || this.id == null || this.hasGeneratedId;
  }
  get isModel() {
    return true;
  }
  /**
   * Checks if record has a generated id.
   *
   * New records are assigned a generated id based on a UUID (starting with `_generated`), which is intended to be
   * temporary and should be replaced by the backend on commit.
   *
   * @property {Boolean}
   * @category Identification
   */
  get hasGeneratedId() {
    return typeof this.id === "string" && this.id.startsWith("_generated");
  }
  static generateId(text = this.$$name) {
    return `_generated${text}_${StringHelper.generateUUID()}`;
  }
  /**
   * Generates an id for a new record (a phantom id), based on a UUID (starting with `_generated`).
   *
   * Generated ids are intended to be temporary and should be replaced by the backend on commit.
   *
   * @category Identification
   * @returns {String}
   */
  generateId() {
    return this.constructor.generateId();
  }
  /**
   * Gets the id of specified model or model data object, or the value if passed string/number.
   * @param {Core.data.Model|String|Number} model
   * @returns {String|Number} id
   * @category Identification
   */
  static asId(model) {
    return (model == null ? void 0 : model.isModel) ? model.id : ObjectHelper.isObject(model) ? model[this.fieldMap.id.dataSource] : model;
  }
  //endregion
  //region JSON
  /**
   * Get the records data as a json string.
   *
   * ```javascript
   * const record = new Model({
   *     title    : 'Hello',
   *     children : [
   *         ...
   *     ]
   * });
   *
   * const jsonString = record.json;
   *
   * //jsonString:
   * '{"title":"Hello","children":[...]}'
   * ```
   *
   * @member {String}
   * @category JSON
   */
  get json() {
    return StringHelper.safeJsonStringify(this);
  }
  /**
   * Used by `JSON.stringify()` to correctly convert this record to json.
   *
   * In most cases no point in calling it directly.
   *
   * ```
   * // This will call `toJSON()`
   * const json = JSON.stringify(record);
   * ```
   *
   * If called manually, the resulting object is a clone of `record.data` + the data of any children:
   *
   * ```
   * const record = new Model({
   *     title    : 'Hello',
   *     children : [
   *         ...
   *     ]
   * });
   *
   * const jsonObject = record.toJSON();
   *
   * // jsonObject:
   * {
   *     title : 'Hello',
   *     children : [
   *         ...
   *     ]
   * }
   * ```
   *
   * @returns {Object}
   * @category JSON
   */
  toJSON() {
    const { children, unfilteredChildren } = this, jsonData = this.persistableData;
    if (unfilteredChildren || children) {
      jsonData[this.constructor.childrenField] = (unfilteredChildren || children).map((c) => c.toJSON());
    }
    return jsonData;
  }
  /**
   * Represent the record as a string, by default as a JSON string. Tries to use an abbreviated version of the
   * object's data, using id + name/title/text/label/description. If no such field exists, the full data is used.
   *
   * ```javascript
   * const record = new Model({ id : 1, name : 'Steve Rogers', alias : 'Captain America' });
   * console.log(record.toString()); // logs { "id" : 1, "name" : "Steve Rogers" }
   * ```
   *
   * @returns {String}
   * @category JSON
   */
  toString() {
    const me = this, nameField = abbreviationFields.find((field2) => field2 in me.constructor.fieldMap), data = nameField ? { [me.constructor.idField]: me.id, [nameField]: me[nameField] } : me.data;
    return StringHelper.safeJsonStringify(data);
  }
  //endregion
  //region Batch
  /**
   * True if this Model is currently batching its changes.
   * @property {Boolean}
   * @readonly
   * @category Editing
   */
  get isBatchUpdating() {
    return Boolean(this.batching);
  }
  /**
   * Returns `true` if this Model currently has outstanding batched changes for the specified field name.
   * @param {String} fieldName The field name to check for batched updates on.
   * @returns {Boolean}
   * @category Editing
   */
  hasBatchedChange(fieldName) {
    var _a2, _b;
    return (_b = (_a2 = this.meta) == null ? void 0 : _a2.batchChanges) == null ? void 0 : _b[fieldName];
  }
  /**
   * Begin a batch, which stores changes and commits them when the batch ends.
   * Prevents events from being fired during batch.
   *
   * ```javascript
   * record.beginBatch();
   * record.name = 'Mr Smith';
   * record.team = 'Golden Knights';
   * record.endBatch();
   * ```
   *
   * Please note that you can also set multiple fields in a single call using {@link #function-set}, which in many
   * cases can replace using a batch:
   *
   * ```javascript
   * record.set({
   *   name : 'Mr Smith',
   *   team : 'Golden Knights'
   * });
   * ```
   * @category Editing
   * @privateparam {Boolean} silentUpdates Suppress firing the `batchUpdatedEvent`
   */
  beginBatch(silentUpdates = false) {
    const me = this;
    if (!me.batching) {
      me.batching = 0;
      me.meta.batchChanges = {};
    }
    if (silentUpdates) {
      me.$silenceBatch = (me.$silenceBatch || 0) + 1;
    }
    me.batching++;
  }
  /**
   * End a batch, triggering events if data has changed.
   * @param {Boolean} [silent] Specify `true` to not trigger events. If event is recurring, occurrences won't be updated automatically.
   * @privateparam {Boolean} [silent=false] Specify `true` to not trigger events. If event is recurring, occurrences won't be updated automatically.
   * @privateparam {Boolean} [triggerBeforeUpdate=true]
   * @category Editing
  */
  endBatch(silent = false, skipAccessors = false, triggerBeforeUpdate = true) {
    const me = this, { parentIdField } = me.constructor;
    if (!me.batching) {
      return;
    }
    me.batching--;
    me.$silenceBatch && me.$silenceBatch--;
    if (me.batching > 0) {
      return;
    }
    if (!ObjectHelper.isEmpty(me.meta.batchChanges)) {
      let { batchChanges } = me.meta;
      me.meta.batchChanges = null;
      if (batchChanges[parentIdField]) {
        batchChanges = { ...batchChanges };
        me.parentId = batchChanges[parentIdField];
        delete batchChanges[parentIdField];
      }
      me.set(batchChanges, _undefined, silent, false, skipAccessors, void 0, triggerBeforeUpdate);
    }
  }
  /**
   * Cancels current batch operation. Any changes during the batch are discarded.
   * @category Editing
   */
  cancelBatch() {
    if (this.batching) {
      const me = this, { batchChanges } = me.meta, wasSet = {};
      me.batching = null;
      me.meta.batchChanges = null;
      me.generation++;
      if (!me.$silenceBatch) {
        Object.entries(batchChanges).forEach(([key, oldValue]) => {
          wasSet[key] = {
            oldValue,
            value: me[key]
          };
        });
        const event = {
          action: "update",
          record: me,
          records: [me],
          changes: wasSet
        };
        me.stores.forEach((store) => {
          store.trigger("batchedUpdate", { ...event });
        });
        me.forEachLinked((store, record) => {
          store.trigger("batchedUpdate", { ...event, record, records: [record] });
        });
      }
      me.$silenceBatch && me.$silenceBatch--;
    }
  }
  //endregion
  //region Events
  /**
   * Triggers beforeUpdate event for each store and checks if changes can be made from event return value.
   * @param {Object} changes Data changes
   * @returns {Boolean} returns true if data changes are accepted
   * @private
   */
  triggerBeforeUpdate(changes) {
    var _a2;
    return !((_a2 = this.stores) == null ? void 0 : _a2.some((s) => s.trigger("beforeUpdate", { record: this, changes }) === false));
  }
  //endregion
  //region Additional functionality
  /**
   * Makes a copy of this model, assigning the specified id or a generated id and also allowing you to pass field values to
   * the created copy.
   *
   * ```
   * const record = new Model({ name : 'Super model', hairColor : 'Brown' });
   * const clone = record.copy({ name : 'Super model clone' });
   * ```
   * @param {Number|String|Object} [newId] The id for the copied instance, or any field values to apply
   * (overriding the values from the source record). If no id provided, one will be auto-generated
   * @param {Boolean} [deep] True to also clone children
   * @returns {Core.data.Model} Copy of this model
   * @category Editing
   */
  copy(newId = null, deep) {
    const me = this, data = ObjectHelper.clone(me.data), idField = me.constructor.idField, useDeep = ObjectHelper.isObject(deep) ? deep.deep : deep;
    let id;
    if (newId && typeof newId === "object") {
      id = newId[idField];
      Object.assign(data, newId);
    } else {
      id = newId;
    }
    if (useDeep && me.children) {
      data.children = me.children.map((child) => child.copy(void 0, deep));
    } else {
      delete data.children;
      delete data.expanded;
    }
    if (me.$meta.fields.initable.length > 0) {
      const json = me.toJSON();
      for (const field2 of me.$meta.fields.initable) {
        data[field2.name] = json[field2.name];
      }
    }
    if (newId !== false) {
      data[idField] = id || me.generateId(me.firstStore);
    }
    const copy = new me.constructor(data, null, null, false, true);
    copy.originalInternalId = me.internalId;
    return copy;
  }
  // Copies data using the real field names to trigger setters
  copyData(fromRecord, raw, silent) {
    const propertiesAndValues = {};
    fromRecord.allFields.forEach(({ name: fieldName }) => {
      if (fieldName !== fromRecord.constructor.idField) {
        propertiesAndValues[fieldName] = raw ? fromRecord.get(fieldName) : fromRecord.getValue(fieldName);
      }
    });
    this.set(propertiesAndValues, null, silent);
  }
  /**
   * Removes this record from all stores (and in a tree structure, also from its parent if it has one).
   * @param {Boolean} [silent] Specify `true` to not trigger events. If event is recurring, occurrences won't be updated automatically.
   * @category Editing
   */
  remove(silent = false) {
    const me = this, { parent } = this;
    if (parent) {
      parent.removeChild(me);
    } else if (me.stores.length && !me.isSpecialRow) {
      me.stores.forEach((s) => s.remove(me, silent, false, true));
    }
  }
  // Called by stores before removing the record from the store. Returning false prevents the removal (overridden in
  // ModelLink.js)
  beforeRemove(stores, records) {
    return super.beforeRemove(stores, records);
  }
  //endregion
  //region Validation
  /**
   * Check if record has valid data. Default implementation returns true, override in your model to do actual validation.
   * @property {Boolean}
   * @category Editing
   */
  get isValid() {
    return true;
  }
  //endregion
  //region Store
  /**
   * Get the first store that this model is assigned to.
   * @property {Core.data.Store}
   * @readonly
   * @category Misc
   */
  get firstStore() {
    return this.stores.length > 0 && this.stores[0];
  }
  /**
   * Joins this record and any children to specified store, if not already joined.
   * @internal
   * @param {Core.data.Store} store Store to join
   * @category Misc
   */
  joinStore(store) {
    var _a2;
    const me = this, { stores } = me;
    if (!stores.includes(store)) {
      const { unjoinedStores } = me;
      super.joinStore(store);
      store.register(me);
      stores.push(store);
      if (unjoinedStores.includes(store)) {
        unjoinedStores.splice(unjoinedStores.indexOf(store), 1);
      }
      me.isLoaded && me.children.forEach((child) => child.joinStore(store));
      me.initRelations();
      if (store.tree && !me.isRoot && !((_a2 = store.stm) == null ? void 0 : _a2.isRestoring)) {
        me.instanceMeta(store.id).collapsed = !me.expanded;
      }
    }
  }
  /**
   * Unjoins this record and any children from specified store, if already joined.
   * @internal
   * @param {Core.data.Store} store Store to join
   * @param {Boolean} [isReplacing] `true` if this record is being replaced
   * @category Misc
   */
  unjoinStore(store, isReplacing = false) {
    var _a2, _b, _c;
    const me = this, { stores, unjoinedStores } = me;
    if (stores.includes(store)) {
      if (!store.isDestroying) {
        store.unregister(me);
        unjoinedStores.push(store);
      }
      (_b = (_a2 = me.unfilteredChildren || me.children) == null ? void 0 : _a2.forEach) == null ? void 0 : _b.call(_a2, (child) => child.unjoinStore(store, isReplacing));
      stores.splice(stores.indexOf(store), 1);
      (_c = super.unjoinStore) == null ? void 0 : _c.call(this, store, isReplacing);
      store.uncacheRelatedRecord(me);
    }
  }
  /**
   * Returns true if this record is contained in the specified store, or in any store if store param is omitted.
   * @internal
   * @param {Core.data.Store} store Store to join
   * @returns {Boolean}
   * @category Misc
   */
  isPartOfStore(store) {
    if (store) {
      return store.includes(this);
    }
    return this.stores.length > 0;
  }
  /**
   * Returns true if this record is not part of any store.
   * @property {Boolean}
   * @readonly
   * @internal
   */
  get isRemoved() {
    return !this.isPartOfStore();
  }
  //endregion
  //region Per instance meta
  /**
   * Used to set per external instance meta data. For example useful when using a record in multiple grids to store some state
   * per grid.
   * @param {String|Object} instanceOrId External instance id or the instance itself, if it has id property
   * @private
   * @category Misc
   */
  instanceMeta(instanceOrId) {
    const { meta } = this, id = instanceOrId.id || instanceOrId;
    if (!meta.map) {
      meta.map = {};
    }
    return meta.map[id] || (meta.map[id] = {});
  }
  /**
   * When called on a group header row returns list of records in that group. Returns `undefined` otherwise.
   * @member {Core.data.Model[]|undefined} groupChildren
   * @category Grouping
   * @readonly
   */
  /**
   * Returns true for a group header record
   * @member {Boolean}
   * @category Grouping
   * @readonly
   */
  get isGroupHeader() {
    return "groupRowFor" in this.meta;
  }
  get isGroupFooter() {
    return "groupFooterFor" in this.meta;
  }
  get isSpecialRow() {
    var _a2;
    return Boolean((_a2 = this.meta) == null ? void 0 : _a2.specialRow);
  }
  get $original() {
    return this.isLinked ? this.proxyMeta.originalRecord : this;
  }
  //endregion
  static get nonPersistableFields() {
    const me = this;
    if (!me._nonPersistableFields) {
      me._nonPersistableFields = {};
      me.allFields.forEach((field2) => {
        if (!field2.persist || field2.calculated) {
          me._nonPersistableFields[field2.name] = 1;
        }
      });
    }
    return me._nonPersistableFields;
  }
  static get alwaysWriteFields() {
    const me = this;
    if (!me._alwaysWriteFields) {
      me._alwaysWriteFields = [];
      me.allFields.forEach((field2) => {
        if (field2.alwaysWrite) {
          me._alwaysWriteFields.push(field2.name);
        }
      });
    }
    return me._alwaysWriteFields;
  }
  // Id with spaces and dots replaced by -, for safe usage as an id in DOM
  get domId() {
    return typeof this.id === "string" ? this.id.replace(/[ .]/g, "-") : this.id;
  }
  //region Extract config
  // These functions are not meant to be called by any code other than Base#getCurrentConfig()
  // Convert custom modelClass to string, keeping custom fields
  static toJavaScriptValue(options) {
    const { names } = this.$meta, className = names[names.length - 2], superName = names[names.length - 3];
    return `class ${className} extends ${superName} { static fields = ${StringHelper.toJavaScriptValue(this.fields, options)}; }`;
  }
  // Get fields current values
  getCurrentConfig(options) {
    const { data, children } = this, { defaultValues, applyConfigs } = this.constructor, result = applyConfigs ? super.getCurrentConfig(options) : {};
    if (result) {
      for (const field2 of this.fields) {
        if (field2.persist) {
          const value = ObjectHelper.getPath(data, field2.dataSource);
          if (!field2.isEqual(value, defaultValues[field2.name])) {
            ObjectHelper.setPath(result, field2.dataSource, Base2.processConfigValue(value, options));
          }
        }
      }
      if (children) {
        if (Array.isArray(children)) {
          result.children = [];
          for (const child of children) {
            result.children.push(child.getCurrentConfig(options));
          }
        } else {
          result.children = children;
        }
      }
      if (this.hasGeneratedId) {
        delete result.id;
      }
      delete result.parentId;
      delete result.parentIndex;
    }
    return result;
  }
  //endregion
};
var Model = _Model;
/**
 * Override in a subclass of Model to define relations to records in other stores.
 *
 * Always defined on the "one" side, not the "many" side.
 *
 * Expects an object where keys are relation names and values are {@link #typedef-RelationConfig relation configs}.
 *
 * This snippet will define a relation called `team`, allowing access to the foreign record via `player.team`. It
 * will point to a record in the `teamStore` (must be available as `record.firstStore.teamStore)` with an id
 * matching the players `teamId` field. The team record in turn, will have a field called `players` which is a
 * collection of all players in the team.
 *
 * ```javascript
 * class Player extends Model {
 *     static relations = {
 *         // Define a relation between a player and a team
 *         team : {
 *             foreignKey            : 'teamId',
 *             foreignStore          : 'teamStore',
 *             relatedCollectionName : 'players'
 *         }
 *     }
 * }
 *
 * const teamStore = new Store({
 *     data : [
 *         { id : 1, name : 'Brynas' },
 *         { id : 2, name : 'Leksand' }
 *     ]
 * });
 *
 * const playerStore = new Store({
 *     modelClass : Player,
 *     // Matches foreignStore, allowing records of playerStore to find the related store
 *     teamStore,
 *     data       : [
 *         // teamId is specified as foreignKey, will be used to match the team
 *         { id : 1, name : 'Nicklas Backstrom', teamId : 1  },
 *         { id : 2, name : 'Elias Lindholm',   teamId : 1  },
 *         { id : 3, name : 'Filip Forsberg',  teamId : 2  }
 *     ],
 * }
 *
 * playerStore.first.team.name // > Brynas
 * playerStore.last.team.name // > Leksand
 * teamStore.first.players // > [nick, elias]
 * teamStore.last.players // > [filip]
 * ```
 *
 * To access the related record from the many side, use dot notation for the field name. For example in a Grid
 * column:
 *
 * ```javascript
 * const grid = new Grid({
 *    store : playerStore,
 *    columns : [
 *        { field : 'name', text : 'Name' },
 *        { field : 'team.name', text : 'Team' }
 *    ]
 * });
 * ```
 *
 * @member {Object<String,RelationConfig>} relations
 * @static
 */
__publicField(Model, "relations", null);
Model._idField = "id";
Model._internalIdCounter = 1;
Model._assignedIdField = false;
Model.exposeProperties();
Model._$name = "Model";

// ../Engine/lib/Engine/chrono/ChronoModelMixin.js
var ChronoModelMixin = class extends Mixin([Entity, Model], (base) => {
  const superProto = base.prototype;
  class ChronoModelMixin2 extends base {
    // This is a marker for Models which have the Engine API available.
    get isEntity() {
      return true;
    }
    construct(config, ...args) {
      this.constructor.exposeProperties();
      this.originalData = config = config || {};
      superProto.construct.call(this, config, ...args);
      for (const fieldName in this.originalData) {
        if (this.$[fieldName] && !this.getFieldDefinition(fieldName)) {
          this[fieldName] = config[fieldName];
        }
      }
    }
    /**
     * Calculation function that simply returns current ([[ProposedOrPrevious|proposed or previous]]) value of
     * an identifier.
     */
    *userProvidedValue() {
      return yield ProposedOrPrevious;
    }
    copy(newId = null, deep = null) {
      const copy = superProto.copy.call(this, newId, deep);
      const { creatingOccurrence } = deep != null ? deep : {};
      if (ObjectHelper.isObject(deep) && !deep.skipFieldIdentifiers || !ObjectHelper.isObject(deep)) {
        this.forEachFieldIdentifier((identifier, fieldName, field2) => {
          var _a2;
          if (!field2.lazy && // @ts-ignore
          ((_a2 = this.getFieldDefinition(fieldName)) == null ? void 0 : _a2.type) !== "store" && (!creatingOccurrence || identifier instanceof ChronoModelReferenceBucketFieldIdentifier || identifier instanceof ChronoModelReferenceFieldIdentifier)) {
            copy[fieldName] = this[fieldName];
          }
        });
      }
      return copy;
    }
    applyValue(useProp, key, value, skipAccessors, field2) {
      var _a2;
      const chronoField = this.$entity.getField((field2 == null ? void 0 : field2.name) || key);
      if (chronoField)
        useProp = true;
      if (skipAccessors)
        useProp = false;
      superProto.applyValue.call(this, useProp, useProp ? (_a2 = field2 == null ? void 0 : field2.name) != null ? _a2 : key : key, value, skipAccessors, field2);
    }
    get isInActiveTransaction() {
      var _a2;
      const activeTransaction = (_a2 = this.graph) == null ? void 0 : _a2.activeTransaction;
      return Boolean(activeTransaction == null ? void 0 : activeTransaction.getLatestEntryFor(this.$$));
    }
    get data() {
      return this._data;
    }
    set data(data) {
      this._data = data;
      const { fields, $, graph, generation } = this;
      for (let i = 0; i < fields.length; i++) {
        const { name, dataSource, complexMapping } = fields[i];
        const identifier = $[name];
        if (identifier) {
          const value = complexMapping ? ObjectHelper.getPath(data, dataSource) : data[dataSource];
          if ((complexMapping || dataSource in data) && (generation != null || value !== void 0)) {
            identifier.writeToGraph(graph, value);
          }
        }
      }
    }
    get $entityName() {
      const className = this.constructor.name || this.$entity.name;
      const id = this.id;
      return `${className}${id != null ? "-" + String(id) : ""}`;
    }
  }
  return ChronoModelMixin2;
}) {
};

// ../Engine/lib/Engine/quark/AbstractPartOfProjectGenericMixin.js
var AbstractPartOfProjectGenericMixin = class extends Mixin([], (base) => {
  const superProto = base.prototype;
  class AbstractPartOfProjectGenericMixin2 extends base {
    async commitAsync() {
      return this.project.commitAsync();
    }
    set project(project) {
      this.$project = project;
    }
    get project() {
      return this.$project;
    }
    calculateProject() {
      throw new Error("Implement me");
    }
    /**
     * The method to set the [[AbstractProjectMixin|project]] instance, this entity belongs to.
     */
    setProject(project) {
      return this.project = project;
    }
    /**
     * The method to get the [[AbstractProjectMixin|project]] instance, this entity belongs to.
     */
    getProject() {
      if (this.project)
        return this.project;
      return this.setProject(this.calculateProject());
    }
    /**
     * Convenience method to get the instance of the assignment store in the [[AbstractProjectMixin|project]] instance, this entity belongs to.
     */
    getAssignmentStore() {
      const project = this.getProject();
      return project == null ? void 0 : project.assignmentStore;
    }
    /**
     * Convenience method to get the instance of the dependency store in the [[AbstractProjectMixin|project]] instance, this entity belongs to.
     */
    getDependencyStore() {
      const project = this.getProject();
      return project == null ? void 0 : project.dependencyStore;
    }
    /**
     * Convenience method to get the instance of the event store in the [[AbstractProjectMixin|project]] instance, this entity belongs to.
     */
    getEventStore() {
      const project = this.getProject();
      return project == null ? void 0 : project.eventStore;
    }
    /**
     * Convenience method to get the instance of the resource store in the [[AbstractProjectMixin|project]] instance, this entity belongs to.
     */
    getResourceStore() {
      const project = this.getProject();
      return project == null ? void 0 : project.resourceStore;
    }
    /**
     * Convenience method to get the instance of the calendar manager store in the [[AbstractProjectMixin|project]] instance, this entity belongs to.
     */
    getCalendarManagerStore() {
      const project = this.getProject();
      return project == null ? void 0 : project.calendarManagerStore;
    }
  }
  return AbstractPartOfProjectGenericMixin2;
}) {
};

// ../Engine/lib/Engine/quark/ChronoPartOfProjectGenericMixin.js
var ChronoPartOfProjectGenericMixin = class extends Mixin([AbstractPartOfProjectGenericMixin], (base) => {
  const superProto = base.prototype;
  class ChronoPartOfProjectGenericMixin2 extends base {
    /**
     * The method to get the `ChronoGraph` instance, this entity belongs to.
     */
    getGraph() {
      const project = this.getProject();
      return project == null ? void 0 : project.getGraph();
    }
    //region Entity getters
    /**
     * Convenience method to get the instance of event by its id.
     */
    getEventById(id) {
      var _a2;
      return (_a2 = this.getEventStore()) == null ? void 0 : _a2.getById(id);
    }
    /**
     * Convenience method to get the instance of dependency by its id.
     */
    getDependencyById(id) {
      var _a2;
      return (_a2 = this.getDependencyStore()) == null ? void 0 : _a2.getById(id);
    }
    /**
     * Convenience method to get the instance of resource by its id.
     */
    getResourceById(id) {
      var _a2;
      return (_a2 = this.getResourceStore()) == null ? void 0 : _a2.getById(id);
    }
    /**
     * Convenience method to get the instance of assignment by its id.
     */
    getAssignmentById(id) {
      var _a2;
      return (_a2 = this.getAssignmentStore()) == null ? void 0 : _a2.getById(id);
    }
    /**
     * Convenience method to get the instance of calendar by its id.
     */
    getCalendarById(id) {
      var _a2;
      return (_a2 = this.getCalendarManagerStore()) == null ? void 0 : _a2.getById(id);
    }
  }
  return ChronoPartOfProjectGenericMixin2;
}) {
};

// ../Core/lib/Core/mixin/InstancePlugin.js
function getDescriptor(me, fnName) {
  const property = ObjectHelper.getPropertyDescriptor(me, fnName);
  return property && (property.get || property.set) ? property : null;
}
var InstancePlugin = class extends Base2.mixin(Events_default, Localizable_default) {
  //region Config
  static get configurable() {
    return {
      clientListeners: null,
      /**
       * The plugin/feature `disabled` state.
       *
       * For a feature that is **off** by default that you want to enable later during runtime,
       * configure it with `disabled : true`.
       * ```javascript
       * const grid = new Grid({
       *      features : {
       *          featureName : {
       *              disabled : true // on and disabled, can be enabled later
       *          }
       *      }
       * });
       *
       * // enable the feature
       * grid.features.featureName.disabled = false;
       * ```
       *
       * If the feature is **off** by default, and you want to include and enable the feature, configure it as `true`:
       * ```javascript
       * const grid = new Grid({
       *      features : {
       *          featureName : true // on and enabled, can be disabled later
       *      }
       * });
       *
       * // disable the feature
       * grid.features.featureName.disabled = true;
       * ```
       *
       * If the feature is **on** by default, but you want to turn it **off**, configure it as `false`:
       * ```javascript
       * const grid = new Grid({
       *      features : {
       *          featureName : false // turned off, not included at all
       *      }
       * });
       * ```
       *
       * If the feature is **enabled** by default and you have no need of reconfiguring it,
       * you can omit the feature configuration.
       *
       * @prp {Boolean}
       * @default
       * @category Common
       */
      disabled: false,
      /**
       * The Widget which was passed into the constructor,
       * which is the Widget we are providing extra services for.
       * @member {Core.widget.Widget} client
       * @readonly
       * @category Misc
       * @advanced
       */
      /**
       * The widget which this plugin is to attach to.
       * @config {Core.widget.Widget}
       * @category Misc
       * @advanced
       */
      client: null,
      /**
       * @hideconfigs bubbleEvents, callOnFunctions
       */
      /**
       * @hidefunctions downloadTestCase, destroy
       */
      /**
       * @hideproperties isDestroyed
       */
      /**
       * @hideevents destroy, beforeDestroy
       */
      // The plugins can define their own keyMap which will then be merged with their client's keyMap.
      keyMap: null
    };
  }
  //endregion
  updateClient(client) {
    if (!this.owner) {
      this.owner = client;
    }
  }
  /**
   * This will merge a feature's (subclass of InstancePlugin) keyMap with it's client's keyMap.
   * @private
   */
  updateKeyMap(keyMap) {
    const { client } = this;
    client.keyMap = client.mergeKeyMaps(client.keyMap, keyMap, StringHelper.uncapitalize(this.constructor.$name));
  }
  //region Init
  /**
   * Call from another instance to add plugins to it.
   * @example
   * InstancePlugin.initPlugins(this, Search, Stripe);
   * @param plugInto Instance to mix into (usually this)
   * @param plugins Classes to plug in
   * @internal
   */
  static initPlugins(plugInto, ...plugins) {
    const property = plugInto.plugins || (plugInto.plugins = {});
    for (const PluginClass of plugins) {
      property[PluginClass.$$name] = new PluginClass(plugInto);
    }
  }
  /**
   * Simple wrapper for {@link #property-disabled} to make optional chaining simple:
   *
   * ```javascript
   * grid.features.myFeature?.enabled // returns true when feature exists and is enabled
   * ```
   * @returns {Boolean}
   * @internal
   */
  get enabled() {
    return !this.disabled;
  }
  // We can act as an owner of a widget, so must be able to participate in focus reversion
  getFocusRevertTarget() {
    var _a2;
    return (_a2 = this.client) == null ? void 0 : _a2.getFocusRevertTarget();
  }
  construct(...args) {
    const me = this;
    let [plugInto, config] = args, listeners;
    if (args.length === 1) {
      if (ObjectHelper.isObject(plugInto)) {
        config = plugInto;
        plugInto = config.client;
      }
    } else {
      config = ObjectHelper.assign({}, config);
      delete config.client;
    }
    me.client = plugInto;
    super.construct(config);
    me.applyPluginConfig(plugInto);
    listeners = me.clientListeners;
    if (listeners) {
      listeners = ObjectHelper.assign({}, listeners);
      listeners.thisObj = me;
      plugInto.ion(listeners);
    }
  }
  /**
   * Applies config as found in plugInto.pluginConfig, or published all if no config found.
   * @private
   * @param plugInto Target instance to plug into
   */
  applyPluginConfig(plugInto) {
    const me = this, config = me.pluginConfig || me.constructor.pluginConfig;
    if (config) {
      const { assign, chain, after, before, override } = config;
      assign && me.applyAssign(plugInto, assign);
      (chain || after) && me.applyChain(plugInto, chain || after);
      before && me.applyChain(plugInto, before, false);
      override && me.applyOverride(plugInto, override);
    }
  }
  /**
   * Applies assigning for specified functions.
   * @private
   * @param plugInto
   * @param fnNames
   */
  applyAssign(plugInto, fnNames) {
    fnNames.forEach((fnName) => this.assign(plugInto, fnName));
  }
  /**
   * Applies chaining for specified functions.
   * @private
   * @param plugInto
   * @param functions
   * @param after
   */
  applyChain(plugInto, functions, after = true) {
    if (Array.isArray(functions)) {
      for (const fnName of functions) {
        this.chain(plugInto, fnName, fnName, after);
      }
    } else {
      for (const intoName in functions) {
        this.chain(plugInto, intoName, functions[intoName], after);
      }
    }
  }
  /**
   * Applies override for specified functions.
   * @private
   * @param plugInto
   * @param fnNames
   */
  applyOverride(plugInto, fnNames) {
    const me = this;
    if (!me.overridden) {
      me.overridden = {};
    }
    fnNames.forEach((fnName) => {
      if (!me[fnName]) {
        throw new Error(`Trying to chain fn ${plugInto.$$name}#${fnName}, but plugin fn ${me.$$name}#${fnName} does not exist`);
      }
      if (typeof plugInto[fnName] === "function") {
        me.overridden[fnName] = plugInto[fnName].bind(plugInto);
      }
      plugInto[fnName] = me[fnName].bind(me);
    });
  }
  /**
   * Assigns specified functions.
   * @private
   * @param plugInto
   * @param fnName
   */
  assign(plugInto, fnName) {
    const me = this, property = getDescriptor(me, fnName);
    if (property) {
      Object.defineProperty(plugInto, fnName, {
        configurable: true,
        enumerable: true,
        get: property.get && property.get.bind(me),
        set: property.set && property.set.bind(me)
      });
    } else {
      plugInto[fnName] = me[fnName].bind(me);
    }
  }
  //endregion
  //region Chaining
  /**
   * Chains functions. When the function is called on the target class all functions in the chain will be called in
   * the order they where added.
   * @private
   * @param plugInto
   * @param intoName
   * @param hookName
   * @param after
   */
  chain(plugInto, intoName, hookName, after = true) {
    let prio = 0;
    if (typeof intoName === "object") {
      intoName = intoName.fn;
    }
    if (typeof hookName === "object") {
      prio = hookName.prio || 0;
      hookName = hookName.fn;
    }
    const me = this, chains = plugInto.pluginFunctionChain || (plugInto.pluginFunctionChain = {}), hookFn = me[hookName] && me[hookName].bind(me), functionChainRunner = me.functionChainRunner;
    if (!hookFn) {
      throw new Error(`Trying to chain fn ${plugInto.$$name}#${hookName}, but plugin fn ${me.$$name}#${hookName} does not exist`);
    }
    if (!chains[intoName]) {
      let intoFn = plugInto[intoName];
      if (intoFn) {
        intoFn = intoFn.bind(plugInto);
        intoFn.$this = plugInto;
        intoFn.$prio = 0;
      }
      chains[intoName] = intoFn ? [intoFn] : [];
      plugInto[intoName] = (...params) => functionChainRunner(chains[intoName], params);
    }
    hookFn.$this = me;
    hookFn.$prio = prio;
    chains[intoName][after ? "push" : "unshift"](hookFn);
    chains[intoName].$sorted = false;
  }
  /**
   * Used to run multiple plugged in functions with the same name, see chain above. Returning false from a
   * function will abort chain.
   * @private
   * @param {Array} chain
   * @param {Array} params
   * @returns {*} value returned from last function in chain (or false if any returns false)
   */
  functionChainRunner(chain, params) {
    let fn2, i, returnValue;
    if (!chain.$sorted) {
      chain.sort((a, b) => b.$prio - a.$prio);
      chain.$sorted = true;
    }
    for (i = 0; i < chain.length; i++) {
      fn2 = chain[i];
      if (!fn2.$this.isDestroyed) {
        returnValue = fn2(...params);
        if (returnValue === false) {
          break;
        }
      }
    }
    return returnValue;
  }
  //endregion
  /**
   * Called when disabling/enabling the plugin/feature, not intended to be called directly. To enable or disable a
   * plugin/feature, see {@link #property-disabled}.
   *
   * By default removes the cls of the plugin from its client. Override in subclasses to take any other actions necessary.
   * @category Misc
   * @advanced
   */
  doDisable(disable) {
    var _a2, _b, _c, _d;
    const me = this, { constructor } = me, cls = "featureClass" in constructor ? constructor.featureClass : `b-${constructor.$$name.toLowerCase()}`, key = StringHelper.uncapitalize(constructor.$$name);
    if (cls) {
      (_b = (_a2 = me.client) == null ? void 0 : _a2._element) == null ? void 0 : _b.classList[disable ? "remove" : "add"](cls);
    }
    if (!me.isConfiguring) {
      if (disable) {
        me.trigger("disable");
      } else {
        me.trigger("enable");
      }
      (_d = (_c = me.client).syncSplits) == null ? void 0 : _d.call(_c, (other) => {
        const otherFeature = other.features[key];
        if (otherFeature) {
          otherFeature.disabled = disable;
        }
      });
    }
  }
  updateDisabled(disabled) {
    this.doDisable(disabled);
  }
  throwOverrideIsMissing(data) {
    throw new Error(`Trying to override fn ${data.plugIntoName}#${data.fnName}, but plugin fn ${data.pluginName}#${data.fnName} does not exist`);
  }
  // Convenience method to read the rootElement from the owner widget
  get rootElement() {
    return this.client.rootElement;
  }
};
__publicField(InstancePlugin, "$name", "InstancePlugin");
InstancePlugin._$name = "InstancePlugin";

// ../Core/lib/Core/mixin/Pluggable.js
var Pluggable_default = (Target) => class Pluggable extends (Target || Base2) {
  static get $name() {
    return "Pluggable";
  }
  /**
   * Specify plugins (an array of classes) in config
   * @config {Function[]} plugins
   * @category Misc
   * @advanced
   */
  /**
   * Map of applied plugins
   * @property {Object<String,Core.mixin.InstancePlugin>}
   * @readonly
   * @category Misc
   * @advanced
   */
  get plugins() {
    if (!this._plugins) {
      this._plugins = {};
    }
    return this._plugins;
  }
  set plugins(plugins) {
    if (plugins) {
      if (!Array.isArray(plugins))
        plugins = [plugins];
      InstancePlugin.initPlugins(this, ...plugins);
    }
    this.initPlugins();
  }
  /**
   * Template method which may be implemented in subclasses to initialize any plugins.
   * This method is empty in the `Pluggable` base class.
   * @internal
   */
  initPlugins() {
  }
  /**
   * Adds plugins to an instance.
   * @param {Function[]} plugins The plugins to add
   * @category Misc
   * @advanced
   */
  addPlugins(...plugins) {
    InstancePlugin.initPlugins(this, ...plugins);
  }
  /**
   * Checks if instance has plugin.
   * @param {String|Function} pluginClassOrName Plugin or name to check for
   * @returns {Boolean}
   * @category Misc
   * @advanced
   */
  hasPlugin(pluginClassOrName) {
    return this.getPlugin(pluginClassOrName) != null;
  }
  /**
   * Get a plugin instance.
   * @param {String|Function} pluginClassOrName
   * @returns {Core.mixin.InstancePlugin}
   * @category Misc
   * @advanced
   */
  getPlugin(pluginClassOrName) {
    var _a2;
    if (typeof pluginClassOrName === "function") {
      pluginClassOrName = pluginClassOrName.$$name;
    }
    return (_a2 = this.plugins) == null ? void 0 : _a2[pluginClassOrName];
  }
  // This does not need a className on Widgets.
  // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
  // to the Widget it's mixed in to should implement thus.
  get widgetClass() {
  }
};

// ../Core/lib/Core/mixin/Delayable.js
var { defineProperty: defineProperty6 } = Reflect;
var performance2;
if (BrowserHelper.isBrowserEnv) {
  performance2 = globalThis.performance;
} else {
  performance2 = {
    now() {
      return (/* @__PURE__ */ new Date()).getTime();
    }
  };
}
var globalDelays = null;
if (VersionHelper.isTestEnv) {
  const bryntum = globalThis.bryntum || (globalThis.bryntum = {});
  globalDelays = bryntum.globalDelays = {
    timeouts: /* @__PURE__ */ new Map(),
    intervals: /* @__PURE__ */ new Map(),
    animationFrames: /* @__PURE__ */ new Map(),
    idleCallbacks: /* @__PURE__ */ new Map(),
    isEmpty(includeIntervals = false) {
      return globalDelays.timeouts.size + globalDelays.animationFrames.size + globalDelays.idleCallbacks.size + (includeIntervals ? globalDelays.intervals.size : 0) === 0;
    },
    /**
     * Returns filtered delays array
     * @param {Object} options
     * @param {String[]} [options.ignoreTimeouts] array of delays names to ignore
     * @param {Number} [options.maxDelay] maximum delay in milliseconds. Timeouts with bigger delay will be filtered out
     * @param {Boolean} [options.includeIntervals] include intervals
     * @returns {Object[]} array of filtered delays
     * @internal
     */
    getFiltered({ ignoreTimeouts = [], maxDelay = 5e3, includeIntervals = false }) {
      const result = [], scopes = ["timeouts", "animationFrames", "idleCallbacks"];
      if (includeIntervals) {
        scopes.push("intervals");
      }
      for (const scope of scopes) {
        const map2 = globalDelays[scope];
        for (const [, entry] of map2.entries()) {
          if (!ignoreTimeouts.includes(entry.name) && (!Number.isInteger(entry.delay) || entry.delay < maxDelay)) {
            result.push(entry);
          }
        }
      }
      return result;
    }
  };
}
var makeInvoker = (me, fn2, wrapFn, options) => {
  const named = typeof fn2 === "string", appendArgs = (options == null ? void 0 : options.appendArgs) || [], invoker = () => {
    wrapFn.timerId = null;
    wrapFn.lastCallTime = performance2.now();
    const args = wrapFn.args;
    wrapFn.args = null;
    if (named) {
      me[fn2](...args, ...appendArgs);
    } else {
      fn2.call(me, ...args, ...appendArgs);
    }
    wrapFn.called = true;
    ++wrapFn.calls;
  };
  if (options) {
    me = options.thisObj || me;
  }
  wrapFn.lastCallTime = -9e9;
  wrapFn.calls = 0;
  wrapFn.invoker = invoker;
  invoker.wrapFn = wrapFn;
  return invoker;
};
var decorateWrapFn = (me, wrapFn, cancelFn = "clearTimeout") => {
  wrapFn.cancel = () => {
    if (wrapFn.isPending) {
      me[cancelFn](wrapFn.timerId);
      wrapFn.args = wrapFn.timerId = null;
    }
  };
  wrapFn.flush = () => {
    if (wrapFn.isPending) {
      me[cancelFn](wrapFn.timerId);
      wrapFn.timerId = null;
      wrapFn.invoker();
    }
  };
  wrapFn.now = (...args) => {
    wrapFn.cancel();
    wrapFn.args = args;
    wrapFn.invoker();
  };
  wrapFn.resume = (all) => {
    const n = wrapFn.suspended;
    wrapFn.suspended = all || n < 1 ? 0 : n - 1;
  };
  wrapFn.suspend = () => {
    ++wrapFn.suspended;
  };
  wrapFn.immediate = false;
  wrapFn.suspended = 0;
  wrapFn.timerId = null;
  defineProperty6(wrapFn, "isPending", {
    get() {
      return wrapFn.timerId !== null;
    }
  });
  return wrapFn;
};
var Delayable_default = (Target) => class Delayable extends (Target || Base2) {
  static get $name() {
    return "Delayable";
  }
  static get declarable() {
    return [
      /**
       * This class property returns an object that specifies methods to wrap with configurable timer behaviors.
       *
       * It is used like so:
       * ```javascript
       *  class Foo extends Base.mixin(Delayable) {
       *      static get delayable() {
       *          return {
       *              expensiveMethod : 500
       *          };
       *      }
       *
       *      expensiveMethod() {
       *          this.things();
       *          this.moreThings();
       *          this.evenMoreThings();
       *      }
       *  }
       * ```
       * With the above in place, consider:
       * ```javascript
       *  let instance = new Foo();
       *
       *  instance.expensiveMethod();
       * ```
       * Instead of the above code immediately calling the `expensiveMethod()`, it will start a timer that will
       * invoke the method 500ms later. Because `expensiveMethod()` is an instance method, each instance of `Foo`
       * will have its own timer.
       *
       * NOTE: Only instance methods are currently supported (i.e., only non-`static` methods).
       *
       * #### Options
       * The value of each key configures how the method will be scheduled. If the value is a number, it is
       * promoted to a config object of `type='buffer'` as in the following:
       * ```javascript
       *  class Foo extends Base.mixin(Delayable) {
       *      static get delayable() {
       *          return {
       *              expensiveMethod : {
       *                  type  : 'buffer',
       *                  delay : 500
       *              }
       *          };
       *      }
       *  }
       * ```
       * The `type` property of the config object must be one of three values. Other options can be provided
       * depending on the `type`:
       *
       *  - `buffer`<br>
       *    Other options:
       *     - `delay` (Number) : The number of milliseconds to wait before calling the underlying method. A
       *       value of 0 is equivalent to setting `immediate: true`.
       *     - `immediate` (Boolean) : Set to `true` to call immediately (effectively disabling the buffer).
       *  - `raf` (short for "request animation frame")<br>
       *  - `idle` (short for "request idle callback") __Not available on Safari__ <br>
       *    Other options:
       *     - `cancelOutstanding` (Boolean) : Set to `true` to cancel any pending animation frame requests and
       *       schedule a new one on each call.
       *     - `immediate` (Boolean) : Set to `true` to call immediately.
       *  - `throttle`<br>
       *    Other options:
       *     - `delay` (Number) : The number of milliseconds to wait after each execution before another
       *       execution takes place. A value of 0 is equivalent to setting `immediate: true`.
       *     - `immediate` (Boolean) : Set to `true` to call immediately (effectively disabling the throttle).
       *
       * While `immediate: true` can be specified at the class level, it is more typical to set it on the
       * instance's method as described below.
       *
       * #### Delayable Method API
       * Delayable methods have a consistent API to manage their scheduling. This API is added to the methods
       * themselves.
       *
       * For example:
       * ```javascript
       *  let instance = new Foo();
       *
       *  instance.expensiveMethod();         // schedule a call in 500ms
       *  instance.expensiveMethod.isPending; // true
       *  instance.expensiveMethod.cancel();
       *  instance.expensiveMethod.flush();
       *  instance.expensiveMethod.now();
       *
       *  instance.expensiveMethod.delay = 10;
       *  instance.expensiveMethod();         // schedule a call in 10ms
       * ```
       *
       * ##### `isPending` (Boolean, readonly)
       * This boolean property will be `true` if a call has been scheduled, and false otherwise.
       *
       * ##### `cancel()`
       * Cancels a pending call if one has been scheduled. Otherwise this method does nothing.
       *
       * ##### `flush()`
       * Cancels the timer and causes the pending call to execute immediately. If there is no pending call, this
       * method does nothing.
       *
       * ##### `now()`
       * Cancels the timer (if one is pending) and executes the method immediately. If there is no pending call,
       * this method will still call the underlying method.
       *
       * @static
       * @member {Object<String,'raf'|Number|DelayableConfig>} delayable
       * @internal
       */
      "delayable"
    ];
  }
  doDestroy() {
    const me = this;
    super.doDestroy();
    if (me.timeoutIds) {
      me.timeoutIds.forEach((fn2, id) => {
        if (typeof fn2 === "function") {
          fn2();
        }
        clearTimeout(id);
        globalDelays == null ? void 0 : globalDelays.timeouts.delete(id);
      });
      me.timeoutIds = null;
    }
    if (me.timeoutMap) {
      me.timeoutMap.forEach((name, id) => clearTimeout(id));
      me.timeoutMap = null;
    }
    if (me.intervalIds) {
      me.intervalIds.forEach((id) => {
        clearInterval(id);
        globalDelays == null ? void 0 : globalDelays.intervals.delete(id);
      });
      me.intervalIds = null;
    }
    if (me.animationFrameIds) {
      me.animationFrameIds.forEach((id) => {
        cancelAnimationFrame(id);
        globalDelays == null ? void 0 : globalDelays.animationFrames.delete(id);
      });
      me.animationFrameIds = null;
    }
    if (me.idleCallbackIds) {
      me.idleCallbackIds.forEach((id) => {
        cancelIdleCallback(id);
        globalDelays == null ? void 0 : globalDelays.idleCallbacks.delete(id);
      });
      me.idleCallbackIds = null;
    }
  }
  /**
   * Check if a named timeout is active
   * @param name
   * @internal
   */
  hasTimeout(name) {
    var _a2;
    return Boolean((_a2 = this.timeoutMap) == null ? void 0 : _a2.has(name));
  }
  /**
   * Same as native setTimeout, but will be cleared automatically on destroy. If a propertyName is supplied it will
   * be used to store the timeout id.
   * @param {Object} timeoutSpec An object containing the details about that function, and the time delay.
   * @param {Function|String} timeoutSpec.fn The function to call, or name of function in this object to call. Used as the `name` parameter if a string.
   * @param {Number} timeoutSpec.delay The milliseconds to delay the call by.
   * @param {Object[]} timeoutSpec.args The arguments to pass.
   * @param {String} [timeoutSpec.name] The name under which to register the timer. Defaults to `fn.name`.
   * @param {Boolean} [timeoutSpec.runOnDestroy] Pass `true` if this function should be executed if the Delayable instance is destroyed while function is scheduled.
   * @param {Boolean} [timeoutSpec.cancelOutstanding] Pass `true` to cancel any outstanding invocation of the passed function.
   * @returns {Number}
   * @internal
   */
  setTimeout({ fn: fn2, delay: delay3, name, runOnDestroy, cancelOutstanding, args }) {
    if (arguments.length > 1 || typeof arguments[0] === "function") {
      [fn2, delay3, name, runOnDestroy] = arguments;
    }
    if (typeof fn2 === "string") {
      name = fn2;
    } else if (!name) {
      name = fn2.name || fn2;
    }
    if (cancelOutstanding) {
      this.clearTimeout(name);
    }
    const me = this, timeoutIds = me.timeoutIds || (me.timeoutIds = /* @__PURE__ */ new Map()), timeoutMap = me.timeoutMap || (me.timeoutMap = /* @__PURE__ */ new Map()), timeoutId = setTimeout(() => {
      if (typeof fn2 === "string") {
        fn2 = me[name];
      }
      timeoutIds == null ? void 0 : timeoutIds.delete(timeoutId);
      timeoutMap == null ? void 0 : timeoutMap.delete(name);
      globalDelays == null ? void 0 : globalDelays.timeouts.delete(timeoutId);
      fn2.apply(me, args);
    }, delay3);
    timeoutIds.set(timeoutId, runOnDestroy ? fn2 : true);
    globalDelays == null ? void 0 : globalDelays.timeouts.set(timeoutId, {
      fn: fn2,
      delay: delay3,
      name
      /*, stack : new Error().stack*/
    });
    if (name) {
      timeoutMap.set(name, timeoutId);
    }
    return timeoutId;
  }
  /**
   * clearTimeout wrapper, either call with timeout id as normal clearTimeout or with timeout name (if you specified
   * a name to setTimeout())
   * property to null.
   * @param {Number|String} idOrName timeout id or name
   * @internal
   */
  clearTimeout(idOrName) {
    var _a2;
    let id = idOrName;
    if (typeof id === "string") {
      if (this.timeoutMap) {
        id = this.timeoutMap.get(idOrName);
        this.timeoutMap.delete(idOrName);
      } else {
        return;
      }
    }
    clearTimeout(id);
    (_a2 = this.timeoutIds) == null ? void 0 : _a2.delete(id);
    globalDelays == null ? void 0 : globalDelays.timeouts.delete(id);
  }
  /**
   * clearInterval wrapper
   * @param {Number} id
   * @internal
   */
  clearInterval(id) {
    var _a2;
    clearInterval(id);
    (_a2 = this.intervalIds) == null ? void 0 : _a2.delete(id);
    globalDelays == null ? void 0 : globalDelays.intervals.delete(id);
  }
  /**
   * Same as native setInterval, but will be cleared automatically on destroy
   * @param {Function} fn callback method
   * @param {Number} delay delay in milliseconds
   * @param {String} name delay name for debugging
   * @returns {Number}
   * @internal
   */
  setInterval(fn2, delay3, name) {
    const intervalId = setInterval(fn2, delay3);
    (this.intervalIds || (this.intervalIds = /* @__PURE__ */ new Set())).add(intervalId);
    globalDelays == null ? void 0 : globalDelays.intervals.set(intervalId, { fn: fn2, delay: delay3, name });
    return intervalId;
  }
  /**
   * Relays to native requestAnimationFrame and adds to tracking to have call automatically canceled on destroy.
   * @param {Function} fn
   * @param {Object[]} [extraArgs] The argument list to append to those passed to the function.
   * @param {Object} [thisObj] `this` reference for the function.
   * @returns {Number}
   * @internal
   */
  requestAnimationFrame(fn2, extraArgs = [], thisObj = this) {
    const animationFrameIds = this.animationFrameIds || (this.animationFrameIds = /* @__PURE__ */ new Set()), frameId = requestAnimationFrame(() => {
      globalDelays == null ? void 0 : globalDelays.animationFrames.delete(frameId);
      animationFrameIds.delete(frameId) && fn2.apply(thisObj, extraArgs);
    });
    animationFrameIds.add(frameId);
    globalDelays == null ? void 0 : globalDelays.animationFrames.set(frameId, { fn: fn2, extraArgs, thisObj });
    return frameId;
  }
  /**
   * Relays to native requestIdleCallback and adds to tracking to have call automatically canceled on destroy.
   * @param {Function} fn
   * @param {Object[]} [extraArgs] The argument list to append to those passed to the function.
   * @param {Object} [thisObj] `this` reference for the function.
   * @returns {Number}
   * @internal
   */
  requestIdleCallback(fn2, extraArgs = [], thisObj = this) {
    const idleCallbackIds = this.idleCallbackIds || (this.idleCallbackIds = /* @__PURE__ */ new Set()), frameId = requestIdleCallback(() => {
      globalDelays == null ? void 0 : globalDelays.idleCallbacks.delete(frameId);
      idleCallbackIds.delete(frameId) && fn2.apply(thisObj, extraArgs);
    });
    idleCallbackIds.add(frameId);
    globalDelays == null ? void 0 : globalDelays.idleCallbacks.set(frameId, { fn: fn2, extraArgs, thisObj });
    return frameId;
  }
  /**
   * Creates a function which will execute once, on the next animation frame. However many time it is
   * called in one event run, it will only be scheduled to run once.
   * @param {Function|String} fn The function to call, or name of function in this object to call.
   * @param {Object[]} [args] The argument list to append to those passed to the function.
   * @param {Object} [thisObj] `this` reference for the function.
   * @param {Boolean} [cancelOutstanding] Cancel any outstanding queued invocation upon call.
   * @internal
   */
  createOnFrame(fn2, args = [], thisObj = this, cancelOutstanding) {
    let rafId;
    const result = (...callArgs) => {
      if (rafId != null && cancelOutstanding) {
        this.cancelAnimationFrame(rafId);
        rafId = null;
      }
      if (rafId == null) {
        rafId = this.requestAnimationFrame(() => {
          if (typeof fn2 === "string") {
            fn2 = thisObj[fn2];
          }
          rafId = null;
          callArgs.push(...args);
          fn2.apply(thisObj, callArgs);
        });
      }
    };
    result.cancel = () => this.cancelAnimationFrame(rafId);
    return result;
  }
  /**
   * Relays to native cancelAnimationFrame and removes from tracking.
   * @param {Number} handle
   * @internal
   */
  cancelAnimationFrame(handle) {
    var _a2;
    cancelAnimationFrame(handle);
    (_a2 = this.animationFrameIds) == null ? void 0 : _a2.delete(handle);
    globalDelays == null ? void 0 : globalDelays.animationFrames.delete(handle);
  }
  /**
   * Relays to native cancelIdleCallback and removes from tracking.
   * @param {Number} handle
   * @internal
   */
  cancelIdleCallback(handle) {
    var _a2;
    cancelIdleCallback(handle);
    (_a2 = this.idleCallbackIds) == null ? void 0 : _a2.delete(handle);
    globalDelays == null ? void 0 : globalDelays.idleCallbacks.delete(handle);
  }
  async nextAnimationFrame() {
    return new Promise((resolve) => this.requestAnimationFrame(resolve));
  }
  /**
   * Wraps a function with another function that delays it specified amount of time, repeated calls to the wrapper
   * resets delay.
   * @param {Function|String} fn The function to call. If this is a string, it is looked up as a method on `this`
   * instance (or `options.thisObj` instead, if provided).
   * @param {Object|Number} options The delay in milliseconds or an options object.
   * @param {Number} options.delay The delay in milliseconds.
   * @param {Array} [options.appendArgs] The argument list to append to those passed to the function.
   * @param {Object} [options.thisObj] The `this` reference for the function.
   * @returns {Function} Wrapped function to call.
   * @internal
   */
  buffer(fn2, options) {
    let delay3 = options;
    if (options && typeof options !== "number") {
      delay3 = options.delay;
    } else {
      options = null;
    }
    const bufferWrapFn = (...params) => {
      if (bufferWrapFn.suspended) {
        return;
      }
      const { delay: delay4 } = bufferWrapFn;
      bufferWrapFn.cancel();
      bufferWrapFn.called = false;
      bufferWrapFn.args = params;
      if (bufferWrapFn.immediate || !delay4) {
        invoker();
      } else {
        bufferWrapFn.timerId = this.setTimeout(invoker, delay4);
      }
    }, invoker = makeInvoker(this, fn2, bufferWrapFn, options);
    bufferWrapFn.delay = delay3;
    return decorateWrapFn(this, bufferWrapFn);
  }
  /**
   * Returns a function that when called will schedule a call to `fn` on the next animation frame.
   *
   * @param {Function|String} fn The function to call. If this is a string, it is looked up as a method on `this`
   * instance (or `options.thisObj` instead, if provided).
   * @param {Boolean|Object} [options] An options object or the `cancelOutstanding` boolean property of it.
   * @param {Boolean} [options.cancelOutstanding] Pass `true` to cancel any pending animation frame requests and
   * schedule a new one on each call to the returned function.
   * @param {Array} [options.appendArgs] The argument list to append to those passed to the function.
   * @param {Object} [options.thisObj] The `this` reference for the function.
   * @returns {Function}
   * @internal
   */
  raf(fn2, options) {
    let cancelOutstanding = options;
    if (options && typeof options !== "boolean") {
      cancelOutstanding = options.cancelOutstanding;
    } else {
      options = null;
    }
    const rafWrapFn = (...params) => {
      if (rafWrapFn.suspended) {
        return;
      }
      if (rafWrapFn.cancelOutstanding) {
        rafWrapFn.cancel();
      }
      rafWrapFn.called = false;
      rafWrapFn.args = params;
      if (rafWrapFn.immediate) {
        invoker();
      } else if (!rafWrapFn.isPending) {
        rafWrapFn.timerId = this.requestAnimationFrame(invoker);
      }
    }, invoker = makeInvoker(this, fn2, rafWrapFn, options);
    rafWrapFn.cancelOutstanding = cancelOutstanding;
    return decorateWrapFn(this, rafWrapFn, "cancelAnimationFrame");
  }
  idle(fn2, options) {
    let cancelOutstanding = options;
    if (options && typeof options !== "boolean") {
      cancelOutstanding = options.cancelOutstanding;
    } else {
      options = null;
    }
    const idleWrapFn = (...params) => {
      if (idleWrapFn.suspended) {
        return;
      }
      if (idleWrapFn.cancelOutstanding) {
        idleWrapFn.cancel();
      }
      idleWrapFn.called = false;
      idleWrapFn.args = params;
      if (idleWrapFn.immediate) {
        invoker();
      } else if (!idleWrapFn.isPending) {
        idleWrapFn.timerId = this.requestIdleCallback(invoker);
      }
    }, invoker = makeInvoker(this, fn2, idleWrapFn, options);
    idleWrapFn.cancelOutstanding = cancelOutstanding;
    this.setTimeout(() => this.idleCallbackIds.delete(idleWrapFn.timerId) && idleWrapFn.now(), 100);
    return decorateWrapFn(this, idleWrapFn, "cancelIdleCallback");
  }
  /**
   * Create a "debounced" function which will call on the "leading edge" of a timer period.
   * When first invoked will call immediately, but invocations after that inside its buffer
   * period will be rejected, and *one* invocation will be made after the buffer period has expired.
   *
   * This is useful for responding immediately to a first mousemove, but from then on, only
   * calling the action function on a regular timer while the mouse continues to move.
   *
   * @param {Function|String} fn The function to call. If this is a string, it is looked up as a method on `this`
   * instance (or `options.thisObj` instead, if provided).
   * @param {Number|Object} options The milliseconds to wait after each execution before another execution takes place
   * or a object containing options.
   * @param {Object} [options.thisObj] `this` reference for the function.
   * @param {Array} [options.appendArgs] The argument list to append to those passed to the function.
   * @param {Function|String} [options.throttled] A function to call when the invocation is delayed due to buffer
   * time not having expired. If this is a string, it is looked up as a method on `this` instance (or `options.thisObj`
   * instead, if provided). When called, the same arguments are passed as would have been passed to `fn`, including
   * any `options.appendArgs`.
   * @internal
   */
  throttle(fn2, options) {
    let delay3 = options, throttled;
    if (options && typeof options !== "number") {
      delay3 = options.delay;
      throttled = options.throttled;
    } else {
      options = null;
    }
    const me = this, throttleWrapFn = (...args) => {
      if (throttleWrapFn.suspended) {
        return;
      }
      const { delay: delay4 } = throttleWrapFn, elapsed = performance2.now() - throttleWrapFn.lastCallTime;
      throttleWrapFn.args = args;
      if (throttleWrapFn.immediate || elapsed >= delay4) {
        me.clearTimeout(throttleWrapFn.timerId);
        invoker();
      } else {
        if (!throttleWrapFn.isPending) {
          throttleWrapFn.timerId = me.setTimeout(invoker, delay4 - elapsed);
          throttleWrapFn.called = false;
        }
        if (throttled) {
          throttled.wrapFn.args = args;
          throttled();
        }
      }
    }, invoker = makeInvoker(me, fn2, throttleWrapFn, options);
    throttleWrapFn.delay = delay3;
    if (throttled) {
      throttled = makeInvoker(me, throttled, () => {
      }, options);
    }
    return decorateWrapFn(me, throttleWrapFn);
  }
  static setupDelayable(cls) {
    cls.setupDelayableMethods(cls.delayable);
  }
  /**
   * This method initializes the `delayable` methods on this class.
   * @param {Object} delayable The `delayable` property.
   * @param {Function} [cls] This parameter will be used internally to process static methods.
   * @private
   */
  static setupDelayableMethods(delayable, cls = null) {
    const me = this, statics = delayable.static, target = cls || me.prototype;
    if (statics) {
      delete delayable.static;
    }
    for (const name in delayable) {
      let options = delayable[name];
      const implName = name + "Now", type = typeof options;
      if (!target[implName]) {
        target[implName] = target[name];
      }
      if (type === "number") {
        options = {
          type: "buffer",
          delay: options
        };
      } else if (type === "string") {
        options = {
          type: options
        };
      }
      defineProperty6(target, name, {
        get() {
          const value = this[options.type]((...params) => {
            this[implName](...params);
          }, options);
          defineProperty6(this, name, { value });
          return value;
        }
      });
    }
  }
  // This does not need a className on Widgets.
  // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
  // to the Widget it's mixed in to should implement thus.
  get widgetClass() {
  }
};

// ../Core/lib/Core/state/StateStorage.js
var StateStorage = class {
  /**
   * Returns an object with all stored keys and their values as its properties
   * @member {Object}
   */
  get data() {
    return /* @__PURE__ */ Object.create(null);
  }
  /**
   * Returns the stored keys as set by {@link #function-setItem}
   * @member {String[]}
   */
  get keys() {
    return [];
  }
  /**
   * Remove all stored keys
   */
  clear() {
  }
  /**
   * Returns key value as set by {@link #function-setItem}
   * @param {String} key
   * @returns {*}
   */
  getItem(key) {
    return null;
  }
  /**
   * Removes the specified key
   * @param {String} key
   */
  removeItem(key) {
  }
  /**
   * Sets the specified key to the given value
   * @param {String} key
   * @param {*} value The item value
   */
  setItem(key, value) {
  }
};
StateStorage._$name = "StateStorage";

// ../Core/lib/Core/state/StateProvider.js
var Local = class extends StateStorage {
  constructor(stateProvider) {
    super();
    this.prefix = stateProvider.prefix || "";
  }
  get isLocal() {
    return true;
  }
  get data() {
    const data = empty(), keys = this.keys;
    for (const key of keys) {
      data[key] = this.getItem(key);
    }
    return data;
  }
  get keys() {
    return getKeys(this.prefix, this.prefix.length);
  }
  clear() {
    const keys = getKeys(this.prefix);
    for (const key of keys) {
      localStorage.removeItem(key);
    }
  }
  getItem(key) {
    const value = localStorage.getItem(this.prefix + key);
    return value === null ? value : JSON.parse(value);
  }
  removeItem(key) {
    return localStorage.removeItem(this.prefix + key);
  }
  setItem(key, value) {
    return localStorage.setItem(this.prefix + key, JSON.stringify(value));
  }
};
var Memory = class extends StateStorage {
  constructor() {
    super();
    this.clear();
  }
  get isMemory() {
    return true;
  }
  get data() {
    return ObjectHelper.clone(this._data);
  }
  get keys() {
    return Object.keys(this._data);
  }
  clear() {
    this._data = empty();
  }
  getItem(key) {
    return key in this._data ? this._data[key] : null;
  }
  removeItem(key) {
    delete this._data[key];
  }
  setItem(key, value) {
    this._data[key] = value;
  }
};
var empty = () => /* @__PURE__ */ Object.create(null);
var getKeys = (prefix, pos = 0) => {
  const keys = [], count = localStorage.length;
  for (let key, i = 0; i < count; ++i) {
    key = localStorage.key(i);
    key.startsWith(prefix) && keys.push(key.slice(pos));
  }
  return keys;
};
var nullStorage = new StateStorage();
var storageTypes = {
  local: Local,
  memory: Memory
};
var StateProvider = class extends Base2.mixin(Delayable_default, Events_default) {
  static get $name() {
    return "StateProvider";
  }
  static get configurable() {
    return {
      /**
       * The key prefix applied when using the `'local'` {@link #config-storage} type.
       * @config {String}
       * @default
       */
      prefix: "bryntum-state:",
      /**
       * Storage instance
       * @member {Core.state.StateStorage} storage
       */
      /**
       * One of the following storage types:
       *  - `local` : Stores data in the browser's `localStorage` using the {@link #config-prefix}.
       *  - `memory` : Stores data in the provider's memory.
       *
       * @config {'local'|'memory'|Core.state.StateStorage}
       * @default
       */
      storage: "local"
    };
  }
  static get delayable() {
    return {
      writeStatefuls: 50
    };
  }
  /**
   * The default {@link Core.mixin.State#config-stateProvider} for stateful objects.
   * @property {Core.state.StateProvider}
   */
  static get instance() {
    return this._instance;
  }
  static set instance(inst) {
    if (inst == null) {
      inst = nullProvider;
    } else {
      if (typeof inst === "string" || ObjectHelper.isClass(inst) || inst instanceof StateStorage) {
        inst = {
          storage: inst
        };
      }
      if (ObjectHelper.isObject(inst)) {
        inst = new StateProvider(inst);
      }
    }
    this._instance = inst;
  }
  /**
   * Initializes the default `StateProvider` instance for the page. This method can be passed an instance or one of
   * the following type aliases:
   *
   *  - `'local'` : use `localStorage` to store application state (most common)
   *  - `'memory'` : holds application state in the `StateProvider` instance (used when state is saved to a server)
   *
   * Once the `StateProvider` is initialized, components that use {@link Core.mixin.State} and assign components a
   * {@link Core.mixin.State#config-stateId} will use this default provider to automatically save and restore their
   * state.
   *
   * @param {'local'|'memory'|Core.state.StateProvider} inst The state provider storage type ('local' or 'memory') or
   * the `StateProvider` instance.
   * @returns {Core.state.StateProvider}
   */
  static setup(inst) {
    this.instance = inst;
    return this.instance;
  }
  doDestroy() {
    self.writeStatefuls.flush();
    super.doDestroy();
  }
  /**
   * On read, this property returns all state data stored in the provider. On write, this property _adds_ all the
   * given values to the state provider's data. To replace the data, call {@link #function-clear} before assigning
   * this property. This is used to bulk populate this `StateProvider` with data for stateful components.
   * @member {Object}
   */
  get data() {
    return this.storage.data;
  }
  set data(data) {
    if (!data) {
      this.clear();
    } else {
      for (const key in data) {
        this.setValue(key, data[key]);
      }
    }
  }
  /**
   * Clears all state date
   * @returns {Core.state.StateProvider} this instance
   */
  clear() {
    this.storage.clear();
    return this;
  }
  changeStorage(storage) {
    if (storage == null) {
      storage = nullStorage;
    } else {
      if (typeof storage === "string") {
        if (!storageTypes[storage]) {
          throw new Error(`Invalid storage type "${storage}" (expected one of: "${Object.keys(storageTypes).join('", "')}")`);
        }
        storage = storageTypes[storage];
      }
      if (ObjectHelper.isClass(storage)) {
        storage = new storage(this);
      }
    }
    return storage;
  }
  /**
   * This method is called to schedule saving the given `stateful` object.
   * @param {Core.mixin.State} stateful The stateful object to save.
   * @param {Object} [options] An object of options that affect the state saving process.
   * @param {String} [options.id] The key for the saved state.
   * @param {Boolean} [options.immediate] Pass `true` to save the data synchronously instead of on a delay.
   * @internal
   */
  saveStateful(stateful, options) {
    (this.pendingSaves || (this.pendingSaves = [])).push([stateful, options]);
    this.writeStatefuls();
  }
  /**
   * A delayable method that flushes pending stateful objects.
   * @private
   */
  writeStatefuls() {
    const me = this, { pendingSaves } = me, n = pendingSaves == null ? void 0 : pendingSaves.length, stateIds = [], saved = [];
    me.pendingSaves = null;
    if (n) {
      for (let options, stateful, stateId, i = 0; i < n; ++i) {
        [stateful, options] = pendingSaves[i];
        if (!stateful.isDestroying && stateful.isSaveStatePending) {
          stateId = stateful.saveState({
            ...options,
            immediate: true
          });
          if (stateId) {
            stateIds.push(stateId);
            saved.push(stateful);
          }
        }
      }
      if (stateIds.length) {
        me.trigger("save", {
          stateIds,
          saved
        });
      }
    }
  }
  /**
   * Returns the stored state given its `key`.
   * @param {String} key The identifier of the state to return.
   * @returns {Object}
   */
  getValue(key) {
    this.writeStatefuls.flush();
    return this.storage.getItem(key);
  }
  /**
   * Stores the given state `value` under the specified `key`.
   * @param {String} key The identifier of the state value.
   * @param {Object} value The state value to set.
   * @returns {Core.state.StateProvider} this instance
   */
  setValue(key, value) {
    const me = this, { storage } = me, was = me.getValue(key);
    if (value != null) {
      storage.setItem(key, value);
      me.trigger("set", { key, value, was });
    } else if (was !== null) {
      storage.removeItem(key);
      me.trigger("remove", { key, was });
    }
    return me;
  }
};
var nullProvider = new StateProvider({
  storage: nullStorage
});
StateProvider._instance = nullProvider;
StateProvider._$name = "StateProvider";

// ../Core/lib/Core/mixin/State.js
var primitiveRe = /boolean|number|string/;
var State_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base2) {
    afterConstruct() {
      super.afterConstruct();
      this.loadState();
    }
    finalizeInit() {
      this.loadState();
      super.finalizeInit();
    }
    /**
     * Returns `true` if this instance implements the {@link Core.mixin.State} interface.
     * @property {Boolean}
     * @readonly
     * @advanced
     */
    get isStateful() {
      return true;
    }
    /**
     * Returns `true` if this instance is ready to participate in state activities.
     * @property {Boolean}
     * @readonly
     * @internal
     */
    get isStatefulActive() {
      return !this.statefulSuspended && !this.isResponsivePending && !this.isResponsiveUpdating;
    }
    // state
    /**
     * Gets or sets a component's state
     * @property {Object}
     * @category State
     */
    get state() {
      return this._state = this.getState();
    }
    set state(state) {
      this._state = state;
      if (state) {
        this.applyState(state);
      }
    }
    // statefulEvents
    updateStatefulEvents(events) {
      var _a3;
      const me = this, listeners = {
        name: "statefulEvents",
        thisObj: me
      };
      me.detachListeners(listeners.name);
      if (events) {
        if (typeof events === "string") {
          events = StringHelper.split(events);
        } else if (!Array.isArray(events)) {
          events = ObjectHelper.getTruthyKeys(events);
        }
        if (events.length) {
          for (const event of events) {
            listeners[event] = "onStatefulEvent";
          }
          (_a3 = me.ion) == null ? void 0 : _a3.call(me, listeners);
        }
      }
    }
    // statefulId
    /**
     * Returns the state key to use for this instance. This will be either the {@link #config-stateId} or the
     * {@link Core.widget.Widget#config-id} (if explicitly specified and {@link #config-stateful} is not `false`).
     * @property {String}
     * @category State
     * @internal
     */
    get statefulId() {
      const me = this, { responsiveState } = me;
      let statefulId = me.stateId;
      if (statefulId == null && me.hasGeneratedId === false && me.stateful !== false) {
        statefulId = me.id;
      }
      if (statefulId && responsiveState) {
        statefulId = `${statefulId}[${responsiveState}]`;
      }
      return statefulId;
    }
    // statefulness
    /**
     * Returns an object whose truthy keys are the config properties to include in this object's {@link #property-state}.
     * @property {Object}
     * @category State
     * @readonly
     * @private
     */
    get statefulness() {
      const { stateful } = this;
      return Array.isArray(stateful) ? ObjectHelper.createTruthyKeys(stateful) : stateful;
    }
    // stateProvider
    get stateProvider() {
      return this._stateProvider || StateProvider.instance;
    }
    //---------------------------------------------------------------------------------------------------------------
    // Methods
    /**
     * Applies the given `state` to this instance.
     *
     * This method is not called directly, but is called when the {@link #property-state} property is assigned a value.
     *
     * This method is implemented by derived classes that have complex state which exceeds the simple list of config
     * properties provided by {@link #config-stateful}. In these cases, the `super` method can be called to handle any
     * config properties that are part of the complex state. The default implementation of this method will only assign
     * those config properties listed in {@link #config-stateful} from the provided `state` object.
     *
     * @param {Object} state The state object to apply to this instance.
     * @category State
     * @advanced
     */
    applyState(state) {
      state = this.pruneState(state);
      if (state) {
        this.setConfig(state);
      }
    }
    /**
     * Returns this object's state information.
     *
     * This method is not called directly, but is called to return the value of the {@link #property-state} property.
     *
     * This method is implemented by derived classes that have complex state which exceeds the simple list of config
     * properties provided by {@link #config-stateful}. In these cases, the `super` method can be called to gather the
     * config properties that are part of the complex state. The default implementation of this method will only copy
     * those config properties listed in {@link #config-stateful} to the returned `state` object.
     *
     * @returns {Object}
     * @category State
     * @advanced
     */
    getState() {
      const me = this, {
        initialConfig,
        statefulness,
        isConstructing: defaultState
      } = me, { configs } = me.$meta, source = defaultState ? Object.setPrototypeOf(initialConfig, me.$meta.config) : me;
      let state = null, key, value;
      if (statefulness) {
        state = {};
        for (key in statefulness) {
          if (statefulness[key]) {
            value = source[key];
            if (value == null ? void 0 : value.isStateful) {
              value = value.state;
            } else if (!defaultState) {
              if (ObjectHelper.isDate(value)) {
                value = DateHelper.format(value, "YYYY-MM-DDTHH:mm:ssZ");
              }
              if (configs[key].equal(value, initialConfig == null ? void 0 : initialConfig[key]) || !primitiveRe.test(typeof value)) {
                continue;
              }
            }
            state[key] = value;
          }
        }
      }
      return state;
    }
    /**
     * Loads this object's state from its {@link #config-stateProvider} and applies it to its {@link #property-state}.
     *
     * This method only acts upon its first invocation for a given instance (unless `true` is passed for the `reload`
     * parameter). This allows for flexibility in the timing of that call during the early stages of the instances'
     * lifecycle. To reload the state after this time, manually assign the desired value to the {@link #property-state}
     * property or call this method and pass `reload` as `true`.
     *
     * This method is called automatically during construction when a {@link #config-stateId} or (in some cases) an
     * explicit {@link Core.widget.Widget#config-id} is provided.
     *
     * @param {String} [stateId] An overriding key to use instead of this object's {@link #config-stateId}.
     * @param {Boolean} [reload=false] Pass `true` to load the state even if previously loaded.
     * @category State
     */
    loadState(stateId, reload) {
      if (typeof stateId === "boolean") {
        reload = stateId;
        stateId = null;
      }
      const me = this, { statefulLoaded } = me;
      if (me.isStatefulActive && (reload || !statefulLoaded)) {
        const state = me.loadStatefulData(stateId || (stateId = me.statefulId));
        if (!statefulLoaded && stateId) {
          me.defaultState = me.state;
          me.statefulLoaded = true;
        }
        if (state) {
          me.state = state;
        }
      }
    }
    loadStatefulData(stateId) {
      var _a3;
      stateId = this.isStatefulActive ? stateId || this.statefulId : null;
      return stateId && ((_a3 = this.stateProvider) == null ? void 0 : _a3.getValue(stateId));
    }
    resetDefaultState() {
      if (this.defaultState) {
        this.state = this.defaultState;
      }
    }
    resumeStateful(full = false) {
      this.statefulSuspended = full ? 0 : Math.max(this.statefulSuspended - 1, 0);
    }
    /**
     * Saves this object's state to its {@link #config-stateProvider}.
     *
     * When a {@link #config-stateId} or (in some cases) an explicit {@link Core.widget.Widget#config-id} is provided,
     * this method will be called automatically any time a config property listed in {@link #config-stateful} changes or
     * when a {@link #config-statefulEvents stateful event} is fired.
     *
     * Derived classes are responsible for calling this method whenever the persistent {@link #property-state} of the
     * object changes.
     *
     * @param {Object|String} [options] Options that affect the state saving process or, if a string, the state `id`.
     * @param {String} [options.id] The state id for the saved state (overrides {@link #config-stateId}).
     * @param {Boolean} [options.immediate] Pass `true` to save the data synchronously instead of on a delay.
     * @category State
     */
    saveState(options) {
      if (typeof options === "string") {
        options = {
          id: options
        };
      } else {
        options = options || {};
      }
      const me = this, { stateProvider } = me, statefulId = options.id || me.isStatefulActive && me.statefulId;
      if (statefulId && stateProvider) {
        if (options.immediate) {
          me.isSaveStatePending = false;
          stateProvider.setValue(statefulId, me.state);
        } else if (!me.isSaveStatePending) {
          me.isSaveStatePending = true;
          stateProvider.saveStateful(me, options);
        }
        return statefulId;
      }
    }
    suspendStateful() {
      ++this.statefulSuspended;
    }
    //---------------------------------------------------------------------------------------------------------------
    // Private / Internal
    onConfigChange({ name, value, was, config }) {
      super.onConfigChange({ name, value, was, config });
      if (!this.isConstructing && this.isStatefulActive && this.statefulId) {
        const { stateful } = this;
        if (Array.isArray(stateful) ? stateful.includes(name) : stateful == null ? void 0 : stateful[name]) {
          this.saveState();
        }
      }
    }
    onStatefulEvent() {
      if (!this.isConstructing) {
        this.saveState();
      }
    }
    /**
     * Returns an object that copies the {@link #config-stateful} config properties from the provided `state` object.
     *
     * @param {Object} state A state object from which to copy stateful configs.
     * @returns {Object}
     * @category State
     * @private
     */
    pruneState(state) {
      const { statefulness } = this;
      if (statefulness) {
        const pruned = {};
        for (const key in state) {
          if (statefulness[key]) {
            pruned[key] = state[key];
          }
        }
        state = pruned;
      }
      return state;
    }
    //---------------------------------------------------------------------------------------------------------------
    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {
    }
  }, __publicField(_a2, "$name", "State"), __publicField(_a2, "configurable", {
    /**
     * This value can be one of the following:
     *
     * - `false` to not use an explicitly assigned {@link Core.widget.Widget#config-id} as the component's
     * {@link #config-stateId} (this is only necessary when there is a {@link #config-stateProvider}).
     * - An array of strings naming the config properties to save in the component's {@link #property-state}
     * object.
     * - An object whose truthy keys are the config properties to save in the component's {@link #property-state}
     * object.
     *
     * These last two uses of the `stateful` config property do not apply to components that have a complex
     * state, as described in the {@link Core.mixin.State State mixin documentation}.
     *
     * This config property is typically set by derived classes to a value including any config property that
     * the user can affect via the user interface. For example, the {@link Core.widget.Panel#config-collapsed}
     * config property is listed for a {@link Core.widget.Panel} since the user can toggle this config property
     * using the {@link Core.widget.panel.PanelCollapser#config-tool collapse tool}.
     *
     * @config {Boolean|Object|String[]}
     * @category State
     */
    stateful: {
      value: null,
      $config: {
        merge: "classList"
      }
    },
    /**
     * The events that, when fired by this component, should trigger it to save its state by calling
     * {@link #function-saveState}.
     *
     * ```javascript
     *  class MyStatefulComponent extends Base.mixin(State) {
     *      static get configurable() {
     *          return {
     *              statefulEvents : [ 'change', 'resize' ]
     *          };
     *      }
     *  }
     * ```
     * In the above example, {@link #function-saveState} will be called any time an instance of this class
     * fires the `change` or `resize` event.
     *
     * This config is typically set by derived classes as a way to ensure {@link #function-saveState} is called
     * whenever their persistent state changes.
     *
     * @config {Object|String[]}
     * @category State
     * @default
     */
    statefulEvents: {
      $config: {
        merge: "classList"
      },
      value: ["stateChange"]
    },
    /**
     * The key to use when saving this object's state in the {@link #config-stateProvider}. If this config is
     * not assigned, and {@link #config-stateful} is not set to `false`, the {@link Core.widget.Widget#config-id}
     * (if explicitly specified) will be used as the `stateId`.
     *
     * If neither of these is given, the {@link #function-loadState} and {@link #function-saveState} methods
     * will need to be called directly to make use of the `stateProvider`.
     *
     * For single page applications (SPA's), or multi-page applications (MPA's) that have common, stateful
     * components on multiple pages, the `stateId` should be unique across all stateful components (similar to DOM
     * element id's). MPA's that want each page to be isolated can more easily achieve that isolation using the
     * {@link Core.state.StateProvider#config-prefix}.
     *
     * @config {String}
     * @category State
     */
    stateId: null,
    /**
     * The `StateProvider` to use to save and restore this object's {@link #property-state}. By default, `state`
     * will be saved using the {@link Core.state.StateProvider#property-instance-static default state provider}.
     *
     * This config is useful for multi-page applications that have a set of common components that want to share
     * state across pages, as well as other components that want their state to be isolated. One of these groups
     * of stateful components could be assigned an explicit `stateProvider` while the other group could use the
     * default state provider.
     *
     * @config {Core.state.StateProvider}
     * @category State
     */
    stateProvider: null
  }), __publicField(_a2, "prototypeProperties", {
    statefulLoaded: false,
    statefulSuspended: 0
  }), _a2;
};

// ../Core/lib/Core/mixin/Identifiable.js
var idCounts = ObjectHelper.getPathDefault(globalThis, "bryntum.idCounts", /* @__PURE__ */ Object.create(null));
var idTypes = {
  string: 1,
  number: 1
};
var Identifiable_default = (Target) => class Identifiable extends (Target || Base2) {
  static get $name() {
    return "Identifiable";
  }
  static get declarable() {
    return [
      "identifiable"
    ];
  }
  static get configurable() {
    return {
      /**
       * The id of this object.  If not specified one will be generated. Also used for lookups through the
       * static `getById` of the class which mixes this in. An example being {@link Core.widget.Widget}.
       *
       * For a {@link Core.widget.Widget Widget}, this is assigned as the `id` of the DOM
       * {@link Core.widget.Widget#config-element element} and must be unique across all elements
       * in the page's `document`.
       * @config {String}
       * @category Common
       */
      id: ""
    };
  }
  static setupIdentifiable(cls, meta) {
    const { identifiable } = cls;
    identifiable.idMap = /* @__PURE__ */ Object.create(null);
    Reflect.defineProperty(cls, "identifiable", {
      get() {
        return identifiable;
      }
    });
  }
  doDestroy() {
    this.constructor.unregisterInstance(this);
    super.doDestroy();
  }
  changeId(id) {
    return (this.hasGeneratedId = !id) ? this.generateAutoId() : id;
  }
  updateId(id, oldId) {
    const me = this, C = me.constructor;
    oldId && C.unregisterInstance(me, oldId);
    if (!me.hasGeneratedId || C.identifiable.registerGeneratedId !== false) {
      C.registerInstance(me, id);
    }
  }
  /**
   * This method generates an id for this instance.
   * @returns {String}
   * @internal
   */
  generateAutoId() {
    return this.constructor.generateId(`b-${this.$$name.toLowerCase()}-`);
  }
  static get all() {
    return Object.values(this.identifiable.idMap);
  }
  /**
   * Generate a new id, using an internal counter and a prefix.
   * @param {String} prefix Id prefix
   * @returns {String} Generated id
   */
  static generateId(prefix = "generatedId") {
    return prefix + (idCounts[prefix] = (idCounts[prefix] || 0) + 1);
  }
  static registerInstance(instance, instanceId = instance.id) {
    const { idMap } = this.identifiable;
    if (instanceId in idMap && !this.disableThrow) {
      throw new Error("Id " + instanceId + " already in use");
    }
    idMap[instanceId] = instance;
  }
  /**
   * Unregister Identifiable instance, normally done on destruction
   * @param {Object} instance Object to unregister
   * @param {String} id The id of the instance to unregister.
   */
  static unregisterInstance(instance, id = instance.id) {
    const { idMap } = this.identifiable;
    if (idTypes[typeof instance]) {
      delete idMap[instance];
    } else if (idMap[id] === instance) {
      delete idMap[id];
    }
  }
  static getById(id) {
    const idMap = this.identifiable.idMap;
    if (idMap) {
      return idMap[id];
    }
  }
  static get registeredInstances() {
    const idMap = this.identifiable.idMap;
    return idMap ? Object.values(idMap) : [];
  }
};

// ../Core/lib/Core/data/Duration.js
var Duration = class {
  /**
   * Duration constructor.
   * @param {Number|String} magnitude Duration magnitude value or a duration + magnitude string ('2h', '4d')
   * @param {String} [unit] Duration unit value
   */
  constructor(magnitude, unit) {
    if (typeof magnitude === "number" || magnitude === null) {
      this._magnitude = magnitude;
      this._unit = unit;
    } else {
      if (typeof magnitude === "string") {
        Object.assign(this, DateHelper.parseDuration(magnitude));
      }
      if (typeof magnitude === "object") {
        Object.assign(this, magnitude);
      }
    }
  }
  /**
   * Get/Set numeric magnitude `value`.
   * @property {Number}
   */
  get magnitude() {
    return this._magnitude;
  }
  set magnitude(value) {
    this._magnitude = typeof value === "number" && value;
  }
  /**
   * Get/Set duration unit to use with the current magnitude value.
   * Valid values are:
   * - "millisecond" - Milliseconds
   * - "second" - Seconds
   * - "minute" - Minutes
   * - "hour" - Hours
   * - "day" - Days
   * - "week" - Weeks
   * - "month" - Months
   * - "quarter" - Quarters
   * - "year"- Years
   *
   * @member {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'}
   */
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = DateHelper.parseTimeUnit(value);
  }
  get isValid() {
    return this._magnitude != null && Boolean(DateHelper.normalizeUnit(this._unit));
  }
  /**
   * The `milliseconds` property is a read only property which returns the number of milliseconds in this Duration
   * @property {Number}
   * @readonly
   */
  get milliseconds() {
    return this.isValid ? Math.round(DateHelper.asMilliseconds(this._magnitude, this._unit)) : 0;
  }
  /**
   * Returns truthy value if this Duration equals the passed value.
   * @param {Core.data.Duration} value
   * @returns {Boolean}
   */
  isEqual(value) {
    return Boolean(value) && this._magnitude != null && value._magnitude != null && this.milliseconds === value.milliseconds;
  }
  toString(useAbbreviation) {
    const me = this, abbreviationFn = useAbbreviation ? "getShortNameOfUnit" : "getLocalizedNameOfUnit";
    return me.isValid ? `${me._magnitude} ${DateHelper[abbreviationFn](me._unit, me._magnitude !== 1)}` : "";
  }
  toJSON() {
    return this.toString();
  }
  valueOf() {
    return this.milliseconds;
  }
  diff(otherDuration) {
    return new Duration({
      unit: this.unit,
      magnitude: DateHelper.as(this.unit, this.milliseconds - otherDuration.milliseconds)
    });
  }
};
Duration._$name = "Duration";

// ../Core/lib/Core/util/CollectionFilter.js
var nestedValueReducer = (object, path) => object == null ? void 0 : object[path];
var relativeDateUnitRegExp = /^is(this|next|last)(week|month|year)$/i;
var relativeDateOperators = [
  "isToday",
  "isTomorrow",
  "isYesterday",
  "isThisWeek",
  "isNextWeek",
  "isLastWeek",
  "isThisMonth",
  "isNextMonth",
  "isLastMonth",
  "isThisYear",
  "isNextYear",
  "isLastYear",
  "isYearToDate"
];
var _CollectionFilter = class extends Base2.mixin(Identifiable_default) {
  static get defaultConfig() {
    return {
      /**
       * The value against which to compare the {@link #config-property} of candidate objects.
       * @config {*}
       */
      value: null,
      /**
       * The operator to use when comparing a candidate object's {@link #config-property} with this CollectionFilter's {@link #config-value}.
       * May be:
       * `'='`, `'!='`, `'>'`, `'>='`, `'<'`, `'<='`, `'*'`,
       * `'startsWith'`, `'endsWith'`, `'isIncludedIn'`, `'includes'`, `'doesNotInclude'`,
       * `'empty'`, `'notEmpty'`, `'between'`, `'notBetween'`, `'sameDay'`,
       * `'isToday'`, `'isTomorrow'`, `'isYesterday'`, `'isThisWeek'`, `'isLastWeek'`, `'isNextWeek'`, `'isThisMonth'`,
       * `'isLastMonth'`, `'isNextMonth'`, `'isThisYear'`, `'isLastYear'`, `'isNextYear'`, `'isYearToDate`',
       * `'isTrue'`, `'isFalse'`
       * @config {'='|'!='|'>'|'>='|'<'|'<='|'*'|'startsWith'|'endsWith'|'isIncludedIn'|'isNotIncludedIn'|'includes'|'doesNotInclude'|'empty'|'notEmpty'|'between'|'notBetween'|'sameDay'|'isToday'|'isTomorrow'|'isYesterday'|'isThisWeek'|'isLastWeek'|'isNextWeek'|'isThisMonth'|'isLastMonth'|'isNextMonth'|'isThisYear'|'isLastYear'|'isNextYear'|'isYearToDate'|'isTrue'|'isFalse'}
       */
      operator: null,
      /**
       * May be used in place of the {@link #config-property}, {@link #config-value} and {@link #config-property} configs. A function which
       * accepts a candidate object and returns `true` or `false`
       * @config {Function}
       */
      filterBy: null,
      /**
       * A function which accepts a value extracted from a candidate object using the {@link #config-property} name, and
       * returns the value which the filter should use to compare against its {@link #config-value}.
       * @config {Function}
       */
      convert: null,
      /**
       * Configure as `false` to have string comparisons case insensitive.
       * @config {Boolean}
       * @default
       */
      caseSensitive: true,
      /**
       * The `id` of this Filter for when used by a {@link Core.util.Collection} Collection.
       * By default the `id` is the {@link #config-property} value.
       * @config {String}
       */
      id: null,
      // Type is required to process the Date value in State API. Store doesn't always know about field type to
      // process filter value, when it applies it from the state, e.g. when you don't declare model field as `date`
      // type but provide a Date instance there. When DateColumn is used to shows this field, it could add date
      // filters to the store. When store is applying state it cannot just infer type, because model doesn't
      // declare it. Only column knows. So to properly process the Date instance for the filter State API would
      // have to process the field additionally, checking model field type and column type. So it is simpler to
      // make Filter to put this information. That way when filter is instantiated by the store, it can gracefully
      // handle value processing, converting date string to the Date instance.
      // Date is the only known value type so far which requires this processing.
      type: null,
      /**
       * Setting the `internal` config on a filter means that it is a fixed part of your store's operation.
       *
       * {@link Core.data.Store#function-clearFilters} does not remove `internal` filters. If you add an
       * `internal` filter, you must explicitly remove it if it is no longer required.
       *
       * Grid features which offer column-based filtering do *not* ingest existing store filters on
       * their data field if the filter is `internal`
       * @config {Boolean}
       * @default false
       */
      internal: null,
      /**
       * When `true`, the filter will not be applied.
       * @config {Boolean}
       * @default
       */
      disabled: false
    };
  }
  static get configurable() {
    return {
      /**
       * The name of a property of candidate objects which yields the value to compare against this CollectionFilter's {@link #config-value}.
       * @member {String} property
       */
      /**
       * The name of a property of candidate objects which yields the value to compare against this CollectionFilter's {@link #config-value}.
       * @config {String}
       */
      property: null
    };
  }
  construct(config) {
    if (typeof config === "function") {
      config = {
        filterBy: config
      };
    }
    if (!config.type) {
      if (DateHelper.isDate(config.value) || Array.isArray(config.value) && config.value.every(DateHelper.isDate)) {
        config.type = "date";
      } else if (config.value instanceof Duration) {
        config.type = "duration";
      }
    } else {
      if (config.type === "date" && config.value != null && !Array.isArray(config.value)) {
        config.value = new Date(config.value);
      } else if (config.type === "duration" && config.value != null && !Array.isArray(config.value)) {
        config.value = new Duration(config.value);
      }
    }
    super.construct(config);
  }
  /**
   * When in a Collection (A Collection holds its Filters in a Collection), we need an id.
   * @property {String}
   * @private
   */
  get id() {
    if (!this._id) {
      if (this.internal) {
        this._id = _CollectionFilter.generateId(`b-internal-${this.property}-filter-`);
      } else {
        this._id = this.property || _CollectionFilter.generateId("b-filter-");
      }
    }
    return this._id;
  }
  set id(id) {
    this._id = id;
  }
  onChange(propertyChanged) {
    var _a2;
    const me = this;
    if (!me.isConfiguring && ((_a2 = me.owner) == null ? void 0 : _a2.onFilterChanged) && !me.owner.isConfiguring) {
      me.owner.onFilterChanged(me, propertyChanged);
    }
  }
  get filterBy() {
    return this._filterBy || this.defaultFilterBy;
  }
  /**
   * May be used in place of the {@link #config-property}, {@link #config-value} and {@link #config-property} configs. A function which
   * accepts a candidate object and returns `true` or `false`
   * @type {Function}
   */
  set filterBy(filterBy) {
    this._filterBy = filterBy;
  }
  defaultFilterBy(candidate) {
    const me = this;
    let candidateValue;
    if (candidate.isModel) {
      candidateValue = candidate.getValue(me.property);
    } else if (me._propertyItems.length > 1) {
      candidateValue = me._propertyItems.reduce(nestedValueReducer, candidate);
    } else {
      candidateValue = candidate[me.property];
    }
    return me[me.operator](me.convert(candidateValue));
  }
  updateProperty(property) {
    this._propertyItems = property.split(".");
    this.onChange("property");
  }
  /**
   * The value against which to compare the {@link #config-property} of candidate objects.
   * @type {*}
   */
  set value(value) {
    const me = this;
    me._value = value;
    if (Array.isArray(value) && ({ date: 1, duration: 1 }[me.type] || value.length > 0 && typeof value[0] === "string")) {
      me._filterValue = value.map((v) => me.convert(v));
    } else if (!me.caseSensitive && Array.isArray(value) && value.length > 0 && typeof value[0] === "string") {
      me._filterValue = value.map((s) => s == null ? void 0 : s.toLowerCase());
    } else if (!me.caseSensitive && typeof value === "string") {
      me._filterValue = value.toLowerCase();
    } else {
      me._filterValue = me.convert(value);
    }
    me.onChange("value");
  }
  get value() {
    return this._value;
  }
  get filterValue() {
    return this._filterValue;
  }
  /**
   * The operator to use when comparing a candidate object's {@link #config-property} with this CollectionFilter's {@link #config-value}.
   * May be:
   * `'='`, `'!='`, `'>'`, `'>='`, `'<'`, `'<='`, `'*'`,
   * `'startsWith'`, `'endsWith'`, `'isIncludedIn'`, `'includes'`, `'doesNotInclude'`,
   * `'empty'`, `'notEmpty'`, `'between'`, `'notBetween'`,
   * `'isToday'`, `'isTomorrow'`, `'isYesterday'`, `'isThisWeek'`, `'isLastWeek'`, `'isNextWeek'`, `'isThisMonth'`,
   * `'isLastMonth'`, `'isNextMonth'`, `'isThisYear'`, `'isLastYear'`, `'isNextYear'`, `'isYearToDate`',
   * `'isTrue'`, `'isFalse'`
   * @type {'='|'!='|'>'|'>='|'<'|'<='|'*'|'startsWith'|'endsWith'|'isIncludedIn'|'isNotIncludedIn'|'includes'|'doesNotInclude'|'empty'|'notEmpty'|'between'|'notBetween'|'isToday'|'isTomorrow'|'isYesterday'|'isThisWeek'|'isLastWeek'|'isNextWeek'|'isThisMonth'|'isLastMonth'|'isNextMonth'|'isThisYear'|'isLastYear'|'isNextYear'|'isYearToDate'|'isTrue'|'isFalse'}
   */
  set operator(operator) {
    this._operator = operator;
    this.onChange("operator");
  }
  get operator() {
    const me = this;
    if (me._operator) {
      return me._operator;
    }
    if (Array.isArray(me.filterValue)) {
      return "isIncludedIn";
    }
    return typeof me.filterValue === "string" ? "*" : "=";
  }
  convert(value) {
    var _a2;
    if (this.operator !== "sameTime" && !(typeof this.filterValue === "string" && value instanceof Date)) {
      if (this.operator === "sameDay") {
        value = DateHelper.clearTime(value);
      }
      value = (_a2 = value == null ? void 0 : value.valueOf()) != null ? _a2 : value;
    }
    value = !this.caseSensitive && typeof value === "string" ? value.toLowerCase() : value;
    return value;
  }
  filter(candidate) {
    return this.filterBy(candidate);
  }
  startsWith(v) {
    return String(v).startsWith(this.filterValue);
  }
  endsWith(v) {
    return String(v).endsWith(this.filterValue);
  }
  isIncludedIn(v) {
    return this.filterValue.length === 0 || this.filterValue.includes(v);
  }
  isNotIncludedIn(v) {
    return !this.isIncludedIn(v);
  }
  includes(v) {
    return this.filterValue.length === 0 || String(v).includes(this.filterValue);
  }
  doesNotInclude(v) {
    return !this.includes(v);
  }
  sameTime(v) {
    return DateHelper.isSameTime(v, this.filterValue);
  }
  sameDay(v) {
    return v === this.filterValue;
  }
  "="(v) {
    return ObjectHelper.isEqual(v, this.filterValue);
  }
  "!="(v) {
    return !ObjectHelper.isEqual(v, this.filterValue);
  }
  ">"(v) {
    return ObjectHelper.isMoreThan(v, this.filterValue);
  }
  ">="(v) {
    return ObjectHelper.isMoreThan(v, this.filterValue) || ObjectHelper.isEqual(v, this.filterValue);
  }
  "<"(v) {
    return ObjectHelper.isLessThan(v, this.filterValue);
  }
  "<="(v) {
    return ObjectHelper.isLessThan(v, this.filterValue) || ObjectHelper.isEqual(v, this.filterValue);
  }
  "*"(v) {
    return ObjectHelper.isPartial(v, this.filterValue);
  }
  between(v) {
    const [start, end] = this._filterValue;
    return (ObjectHelper.isMoreThan(v, start) || ObjectHelper.isEqual(v, start)) && (ObjectHelper.isLessThan(v, end) || ObjectHelper.isEqual(v, end));
  }
  notBetween(v) {
    return !this.between(v);
  }
  empty(v) {
    return v === void 0 || v === null || String(v).length === 0;
  }
  notEmpty(v) {
    return !this.empty(v);
  }
  isToday(v) {
    return this.between(v);
  }
  isTomorrow(v) {
    return this.between(v);
  }
  isYesterday(v) {
    return this.between(v);
  }
  isThisWeek(v) {
    return this.between(v);
  }
  isNextWeek(v) {
    return this.between(v);
  }
  isLastWeek(v) {
    return this.between(v);
  }
  isThisMonth(v) {
    return this.between(v);
  }
  isNextMonth(v) {
    return this.between(v);
  }
  isLastMonth(v) {
    return this.between(v);
  }
  isThisYear(v) {
    return this.between(v);
  }
  isNextYear(v) {
    return this.between(v);
  }
  isLastYear(v) {
    return this.between(v);
  }
  isYearToDate(v) {
    return this.between(v);
  }
  isTrue(v) {
    return v === true;
  }
  isFalse(v) {
    return v === false;
  }
  // Fill in actual dates relative to now
  setRelativeDateValues() {
    this._filterValue = _CollectionFilter.getRelativeDateRange(this._operator).map((date) => date.valueOf());
  }
  static getRelativeDateRange(relativeExpr, now = /* @__PURE__ */ new Date()) {
    let todayStart, tomorrowStart, parts, oneTimeUnit, unitStart, which, timeUnit;
    switch (relativeExpr) {
      case "isYearToDate":
        return [DateHelper.floor(now, "1 year"), now];
      case "isToday":
        todayStart = DateHelper.floor(now, "1 day");
        return [todayStart, DateHelper.add(todayStart, 1, "day")];
      case "isYesterday":
        todayStart = DateHelper.floor(now, "1 day");
        return [DateHelper.add(todayStart, -1, "day"), todayStart];
      case "isTomorrow":
        tomorrowStart = DateHelper.getStartOfNextDay(now);
        return [tomorrowStart, DateHelper.add(tomorrowStart, 1, "day")];
      case "isThisWeek":
      case "isNextWeek":
      case "isLastWeek":
      case "isThisMonth":
      case "isNextMonth":
      case "isLastMonth":
      case "isThisYear":
      case "isNextYear":
      case "isLastYear":
        parts = relativeExpr.toLowerCase().match(relativeDateUnitRegExp);
        if (!parts) {
          throw new Error(`Unrecognized relative date expression: ${relativeExpr}`);
        }
        [, which, timeUnit] = parts;
        oneTimeUnit = `1 ${timeUnit}`;
        unitStart = DateHelper.floor(now, oneTimeUnit);
        if (which === "next") {
          unitStart = DateHelper.add(unitStart, 1, timeUnit);
        } else if (which === "last") {
          unitStart = DateHelper.add(unitStart, -1, timeUnit);
        }
        return [unitStart, DateHelper.add(unitStart, 1, timeUnit)];
    }
  }
  // Accepts an array or a Collection
  static generateFiltersFunction(filters) {
    if (!filters || !filters.length && !filters.count) {
      return FunctionHelper.returnTrue;
    }
    for (const filter2 of filters) {
      if (filter2.type === "date" && relativeDateOperators.includes(filter2._operator)) {
        filter2.setRelativeDateValues();
      }
    }
    return function(candidate) {
      let match = true;
      for (const filter2 of filters) {
        if (!filter2.disabled) {
          match = filter2.filter(candidate);
        }
        if (!match) {
          break;
        }
      }
      return match;
    };
  }
};
var CollectionFilter = _CollectionFilter;
__publicField(CollectionFilter, "$name", "CollectionFilter");
CollectionFilter._$name = "CollectionFilter";

// ../Core/lib/Core/helper/IdHelper.js
var idCounts2 = ObjectHelper.getPathDefault(globalThis, "bryntum.idCounts", /* @__PURE__ */ Object.create(null));
var IdHelper = class {
  /**
   * Generate a new id, using IdHelpers internal counter and a prefix
   * @param {String} prefix Id prefix
   * @returns {String} Generated id
   */
  static generateId(prefix = "generatedId") {
    return prefix + (idCounts2[prefix] = (idCounts2[prefix] || 0) + 1);
  }
};
IdHelper._$name = "IdHelper";

// ../Core/lib/Core/util/CollectionSorter.js
var CollectionSorter = class extends Base2 {
  static get defaultConfig() {
    return {
      /**
       * The name of a property of collection objects which yields the value to sort by.
       * @config {String}
       */
      property: null,
      /**
       * The direction to sort in, `'ASC'` or `'DESC'`
       * @config {'ASC'|'DESC'}
       * @default
       */
      direction: "ASC",
      /**
       * A function which takes the place of using {@link #config-property} and {@link #config-direction}.
       * The function is passed two objects from the collection to compare and must return the comparison result.
       * @config {Function}
       */
      sortFn: null,
      /**
       * When using {@link #config-property}, this may be specified as a function which takes the raw
       * property value and returns the value to actually sort by.
       * @config {Function}
       */
      convert: null,
      /**
       * The `id` of this Sorter for when used by a {@link Core.util.Collection} Collection.
       * By default the `id` is the {@link #config-property} value.
       * @config {String}
       */
      id: null,
      /**
       * Use `localeCompare()` when sorting, which lets the browser sort in a locale specific order. Set to `true`,
       * a locale string or a locale config to enable.
       *
       * Enabling this has big negative impact on sorting performance. For more info on `localeCompare()`, see
       * [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare).
       *
       * ```javascript
       * collection.addSorter({ field: 'name', useLocaleSort : 'sv-SE' });
       * ```
       *
       * @config {Boolean|String|Object}
       * @default false
       */
      useLocaleSort: null
    };
  }
  construct(config) {
    if (typeof config === "function") {
      config = {
        sortFn: config
      };
    }
    super.construct(config);
  }
  /**
   * When in a Collection (A Collection holds its Sorters in a Collection), we need an id.
   * @property {String}
   * @private
   */
  get id() {
    return this._id || (this._id = this.property || IdHelper.generateId("b-sorter"));
  }
  set id(id) {
    this._id = id;
  }
  set sortFn(sortFn) {
    this._sortFn = sortFn;
  }
  get sortFn() {
    if (this._sortFn) {
      return this._sortFn;
    }
    return this.defaultSortFn;
  }
  /**
   * Default sortFn used when no sortFn specified. Uses the {@link #config-property},
   * {@link #config-direction}, and {@link #config-convert}.
   * @private
  */
  defaultSortFn(lhs, rhs) {
    const me = this, { convert, property, useLocaleSort } = me, multiplier = me.direction.toLowerCase() === "desc" ? -1 : 1;
    lhs = lhs[property];
    rhs = rhs[property];
    if (convert) {
      lhs = convert(lhs);
      rhs = convert(rhs);
    }
    if (useLocaleSort && lhs != null && rhs != null && typeof lhs === "string") {
      if (useLocaleSort === true) {
        return String(lhs).localeCompare(rhs);
      }
      if (typeof useLocaleSort === "string") {
        return String(lhs).localeCompare(rhs, useLocaleSort);
      }
      if (typeof useLocaleSort === "object") {
        return String(lhs).localeCompare(rhs, useLocaleSort.locale, useLocaleSort);
      }
    }
    return (lhs > rhs ? 1 : lhs < rhs ? -1 : 0) * multiplier;
  }
  static generateSortFunction(sorters, tieBreaker) {
    const items = sorters.isCollection ? sorters.values : sorters, n = items.length;
    return (lhs, rhs) => {
      let comp, i;
      for (i = 0; i < n; ++i) {
        comp = items[i].sortFn(lhs, rhs);
        if (comp) {
          return comp;
        }
      }
      return tieBreaker ? tieBreaker(lhs, rhs) : 0;
    };
  }
};
CollectionSorter._$name = "CollectionSorter";

// ../Core/lib/Core/util/Collection.js
var return0 = () => 0;
var reverseNumericSortFn = (a, b) => b - a;
var filteredIndicesProperty = Symbol("filteredIndicesProperty");
var emptyArray2 = Object.freeze([]);
var sortEvent = Object.freeze({
  action: "sort",
  added: emptyArray2,
  removed: emptyArray2,
  replaced: emptyArray2
});
var filterEvent = Object.freeze({
  action: "filter",
  added: emptyArray2,
  removed: emptyArray2,
  replaced: emptyArray2
});
var keyTypes = {
  string: 1,
  number: 1
};
function addItemToIndex(item, index, key) {
  if (index.unique !== false) {
    index.set(key, item);
  } else {
    let set = index.get(key);
    if (!set) {
      set = /* @__PURE__ */ new Set();
      index.set(key, set);
    }
    set.add(item);
  }
}
function removeItemFromIndex(item, index, key) {
  if (index.unique !== false) {
    index.delete(key);
  } else if (index.has(key)) {
    index.get(key).delete(item);
    if (!index.get(key).size) {
      index.delete(key);
    }
  }
}
function doRebuildIndices(values, indices, keyProps, indexCount) {
  for (let i = 0; i < values.length; i++) {
    const item = values[i];
    for (let j = 0; j < indexCount; j++) {
      const keyProp = keyProps[j], key = item[keyProp], index = indices[keyProp];
      addItemToIndex(item, index, key);
    }
  }
}
var Collection = class extends Base2.mixin(Events_default) {
  constructor() {
    super(...arguments);
    __publicField(this, "_sortFunction", null);
    __publicField(this, "_addedValues", null);
  }
  //region Config
  static get configurable() {
    return {
      /**
       * Specify the name of the property of added objects which provides the lookup key
       * @config {String}
       * @default
       */
      idProperty: "id",
      /**
       * Specify the names or index configs of properties which are to be indexed for fast lookup.
       *
       * Index configs use the format `{ property : string, unique : boolean }`. Unique indices stores one index
       * per entry, non-unique stores a `Set`. If left out, `unique` defaults to `true`
       *
       * @config {String[]|Object[]}
       * @property {String} property Property to index by
       * @property {Boolean} [unique=true] `true` for unique keys (~primary keys), `false` for non-unique keys
       * (~foreign keys)
       */
      extraKeys: null,
      /**
       * Automatically apply filters on item add.
       * @config {Boolean}
       * @default
       */
      autoFilter: true,
      /**
       * Automatically apply sorters on item add.
       * @config {Boolean}
       * @default
       */
      autoSort: true,
      /**
       * A {@link Core.util.CollectionSorter Sorter}, or Sorter config object, or
       * an array of these, to use to sort this Collection.
       * @config {CollectionSorterConfig[]}
       * @default
       */
      sorters: {
        $config: ["lazy"],
        value: []
      }
    };
  }
  get isCollection() {
    return true;
  }
  //endregion
  //region Init & destroy
  construct(config) {
    this.generation = 0;
    this._values = [];
    super.construct(config);
  }
  doDestroy() {
    var _a2;
    super.doDestroy();
    const me = this;
    me._values.length = 0;
    if (me.isFiltered) {
      me._filteredValues.length = 0;
      me.filters.destroy();
    }
    (_a2 = me._sorters) == null ? void 0 : _a2.destroy();
  }
  //endregion
  //region "CRUD"
  /**
   * Clears this collection.
   */
  clear() {
    const me = this, removed = me._values.slice();
    if (me.totalCount) {
      me._values.length = 0;
      if (me._filteredValues) {
        me._filteredValues.length = 0;
      }
      me._indicesInvalid = true;
      me.generation++;
      me.trigger("change", {
        action: "clear",
        removed
      });
    }
  }
  /**
   * Compares the content of this Collection with the content of the passed Collection or
   * with the passed array. Order insensitive. This returns `true` if the two objects passed
   * contain the same set of items.
   * @param {Core.util.Collection|Array} other The Collection or array to compare with.
   * @param {Function} [map] Optionally a function to convert the items into a comparable object
   * to compare. For example `item => item.id` could be used to compare the ids of the
   * constituent items.
   * @returns {Boolean} `true` if the two objects passed have the same content.
   */
  equals(other, map2) {
    if (other.isCollection) {
      other = other.values;
    }
    if (other.length === this.count) {
      let { values } = this;
      if (map2) {
        other = other.map(map2);
        values = values.map(map2);
      }
      return ArrayHelper.delta(other, values).inBoth.length === this.count;
    }
    return false;
  }
  /**
   * Replaces the internal `values` array with the passed `values`, or `filteredValues` array with the passed `filteredValues`.
   * If `filteredValues` are not passed explicitly, but storage is filtered, decides internally `values` or `filteredValues` should
   * be replaced by passed `values`.
   *
   * Note that this takes ownership of the array, and the array must not be mutated by outside code.
   *
   * This is an internal utility method, not designed for use by application code.
   *
   * @param {Object} params Values and parameters to replace
   * @param {Object[]} params.values The new `values` array
   * @param {Object[]} [params.filteredValues] The new `filteredValues` array. Applicable only when storage is filtered.
   * @param {Boolean} [params.silent=false] If true, `change` event will not be fired
   * @param {Boolean} [params.isNewDataset=false] If true, `values` is a new dataset
   * @fires change
   * @internal
   */
  replaceValues({ values, filteredValues, silent = false, isNewDataset = false }) {
    const me = this;
    let replacedValues, replacedFilteredValues;
    if (me.isFiltered && !isNewDataset) {
      const filteredPassed = Boolean(filteredValues);
      if (!filteredPassed) {
        filteredValues = values.slice();
        values = null;
      } else if (values) {
        replacedValues = me._values;
        me._values = values.slice();
      }
      replacedFilteredValues = me._filteredValues;
      me._filteredValues = filteredValues.slice();
    } else {
      replacedValues = me._values;
      me._values = values.slice();
      filteredValues = null;
      if (me.isFiltered && isNewDataset && me.autoFilter) {
        me._filterFunction = null;
        me._filteredValues = me._values.filter(me.filterFunction);
      } else if (me._filteredValues) {
        me._filteredValues.length = 0;
      }
    }
    me._indicesInvalid = true;
    me._addedValues = void 0;
    me.generation++;
    if (!silent) {
      me.trigger("change", {
        action: "replaceValues",
        replacedValues,
        replacedFilteredValues,
        values,
        filteredValues
      });
    }
  }
  set values(values) {
    this.invalidateIndices();
    this.splice(0, this._values.length, values);
  }
  /**
   * The set of values of this Collection. If this Collection {@link #property-isFiltered},
   * this yields the filtered data set.
   *
   * Setting this property replaces the data set.
   * @property {Object[]}
   */
  get values() {
    return this.isFiltered ? this._filteredValues : this._values;
  }
  /**
   * The set of filtered values of this Collection (those matching the current filters).
   * @property {Object[]}
   * @private
   */
  get filteredValues() {
    return this._filteredValues;
  }
  /**
   * Iterator that allows you to do `for (const item of collection)`
   */
  [Symbol.iterator]() {
    return this.values[Symbol.iterator]();
  }
  /**
   * Executes the passed function for each item in this Collection, passing in the item,
   * ths index, and the full item array.
   * @param {Function} fn The function to execute.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to include all items, bypassing filters.
   */
  forEach(fn2, ignoreFilters = false) {
    (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).forEach(fn2);
  }
  /**
   * Extracts ths content of this Collection into an array based upon the passed
   * value extraction function.
   * @param {Function} fn A function, which, when passed an item, returns a value to place into the resulting array.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to process an item even if it is filtered out.
   * @returns {Object[]} An array of values extracted from this Collection.
   */
  map(fn2, ignoreFilters = false) {
    return (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).map(fn2);
  }
  /**
   * Returns the first item in this Collection which elicits a *truthy* return value from the passed function.
   * @param {Function} fn A function, which, when passed an item, returns `true` to select it as the item to return.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to include filtered out items.
   * @returns {Object} The matched item, or `undefined`.
   */
  find(fn2, ignoreFilters = false) {
    return (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).find(fn2);
  }
  get first() {
    return this.values[0];
  }
  get last() {
    return this.values[this.count - 1];
  }
  /**
   * The set of all values of this Collection regardless of filters applied.
   * @readonly
   * @property {Object[]}
   */
  get allValues() {
    return this._values;
  }
  /**
   * The set of values added to this Collection since the last sort or replaceValues operation.
   * @private
   * @readonly
   * @property {Object[]}
   */
  get addedValues() {
    return this._addedValues;
  }
  /**
   * This method ensures that every item in this Collection is replaced by the matched by
   * `id` item in the other Collection.
   *
   * By default, any items in this Collection which are __not__ in the other Collection are removed.
   *
   * If the second parameter is passed as `false`, then items which are not in the other
   * Collection are not removed.
   *
   * This can be used for example when updating a selected record Collection when a new
   * Store or new store dataset arrives. The selected Collection must reference the latest
   * versions of the selected record `id`s
   * @param {Core.util.Collection} other The Collection whose items to match.
   */
  match(other, allowRemove = true) {
    const me = this, { _values } = me, toRemove = [];
    me.forEach((item) => {
      const newInstance = other.get(item.id, true);
      if (newInstance) {
        const index = me.indexOf(item, true), oldInstance = _values[index];
        _values[index] = newInstance;
        me.removeFromIndices(oldInstance);
        me.addToIndices(newInstance);
      } else if (allowRemove) {
        toRemove.push(item);
      }
    });
    if (toRemove.length) {
      me.remove(toRemove);
    }
    if (me.isFiltered) {
      me._filteredValues = me._values.filter(me.filterFunction);
    }
    return toRemove;
  }
  /**
   * Adds items to this Collection. Multiple new items may be passed.
   *
   * By default, new items are appended to the existing values.
   *
   * Any {@link #property-sorters} {@link #property-sorters} present are re-run.
   *
   * Any {@link #property-filters} {@link #property-filters} present are re-run.
   *
   * *Note that if application functionality requires add and remove, the
   * {@link #function-splice} operation is preferred as it performs both
   * operations in an atomic manner*
   * @param  {...Object} items The item(s) to add.
   */
  add(...items) {
    if (items.length === 1) {
      this.splice(this._values.length, null, ...items);
    } else {
      this.splice(this._values.length, null, items);
    }
  }
  /**
   * Removes items from this Collection. Multiple items may be passed.
   *
   * Any {@link #property-sorters} {@link #property-sorters} present are re-run.
   *
   * Any {@link #property-filters} {@link #property-filters} present are re-run.
   *
   * *Note that if application functionality requires add and remove, the
   * {@link #function-splice} operation is preferred as it performs both
   * operations in an atomic manner*
   * @param  {...Object} items The item(s) to remove.
   */
  remove(...items) {
    if (items.length === 1) {
      this.splice(0, ...items);
    } else {
      this.splice(0, items);
    }
  }
  /**
   * Moves an individual item, or a block of items to another location.
   * @param {Object|Object[]} items The item/items to move.
   * @param {Object} [beforeItem] the item to insert the first item before. If omitted, the `item`
   * is moved to the end of the Collection.
   * @returns {Number} The new index of the `item`.
   */
  move(items, beforeItem) {
    items = ArrayHelper.asArray(items);
    while (items.length && items[0] === beforeItem) {
      items.shift();
    }
    if (!items.length) {
      return;
    }
    const me = this, { _values } = me, itemIndex = me.indexOf(items[0], true);
    if (items.length === 1 && _values[itemIndex + 1] === beforeItem) {
      return;
    }
    me.suspendEvents();
    me.remove(items);
    me.resumeEvents();
    const beforeIndex = beforeItem ? me.indexOf(beforeItem, true) : _values.length;
    if (beforeIndex === -1) {
      throw new Error("Collection move beforeItem parameter must be present in Collection");
    }
    _values.splice(beforeIndex, 0, ...items);
    me._indicesInvalid = 1;
    me.trigger("change", {
      action: "move",
      items,
      from: itemIndex,
      to: beforeIndex
    });
    return beforeIndex;
  }
  /**
   * The core data set mutation method. Removes and adds at the same time. Analogous
   * to the `Array` `splice` method.
   *
   * Note that if items that are specified for removal are also in the `toAdd` array,
   * then those items are *not* removed then appended. They remain in the same position
   * relative to all remaining items.
   *
   * @param {Number} index Index at which to remove a block of items. Only valid if the
   * second, `toRemove` argument is a number.
   * @param {Object[]|Number} [toRemove] Either the number of items to remove starting
   * at the passed `index`, or an array of items to remove (If an array is passed, the `index` is ignored).
   * @param  {Object[]|Object} [toAdd] An item, or an array of items to add.
   */
  splice(index = 0, toRemove, ...toAdd) {
    const me = this, idProperty = me.idProperty, values = me._values, newIds = {}, removed = [], replaced = [], oldCount = me.totalCount;
    let added, mutated;
    if (me.trigger("beforeSplice", { index, toRemove, toAdd }) === false) {
      return;
    }
    if (toAdd) {
      if (toAdd.length === 1 && Array.isArray(toAdd[0])) {
        toAdd = toAdd[0];
      }
      if (oldCount && toAdd.length) {
        const idIndex = me.indices[idProperty];
        added = [];
        for (let i = 0; i < toAdd.length; i++) {
          const newItem = toAdd[i], id = newItem[idProperty], existingItem = idIndex.get(id), existingIndex = existingItem ? values.indexOf(existingItem) : -1;
          newIds[id] = true;
          if (existingIndex !== -1) {
            if (values[existingIndex] !== newItem) {
              replaced.push([values[existingIndex], newItem]);
              values[existingIndex] = newItem;
            }
          } else {
            added.push(newItem);
          }
        }
      } else {
        added = toAdd;
      }
    }
    if (toRemove) {
      if (typeof toRemove === "number") {
        toRemove = Math.min(toRemove, values.length - index);
        for (let removeIndex = index; toRemove; --toRemove) {
          const id = values[removeIndex][idProperty];
          if (newIds[id]) {
            index++;
            removeIndex++;
          } else {
            removed.push(values[removeIndex]);
            values.splice(removeIndex, 1);
            mutated = true;
          }
        }
      } else {
        let contiguous = added.length === 0, lastIdx;
        toRemove = ArrayHelper.asArray(toRemove);
        const removeIndices = toRemove.reduce((result, item) => {
          const isNumeric = typeof item === "number", idx = isNumeric ? item : me.indexOf(item, true);
          if (contiguous && (lastIdx != null && idx !== lastIdx + 1 || isNumeric)) {
            contiguous = false;
          }
          if (idx >= 0 && idx < oldCount) {
            result.push(idx);
          }
          lastIdx = idx;
          return result;
        }, []).sort(reverseNumericSortFn);
        if (contiguous) {
          if (removeIndices.length) {
            removed.push.apply(removed, toRemove);
            values.splice(removeIndices[removeIndices.length - 1], removeIndices.length);
            mutated = true;
          }
        } else {
          for (let i = 0; i < removeIndices.length; i++) {
            const removeIndex = removeIndices[i];
            if (removeIndex !== -1) {
              const id = values[removeIndex][idProperty];
              if (!newIds[id]) {
                removed.unshift(values[removeIndex]);
                values.splice(removeIndex, 1);
                mutated = true;
              }
            }
          }
        }
      }
      if (removed.length && !me._indicesInvalid) {
        removed.forEach(me.removeFromIndices, me);
      }
    }
    if (added.length) {
      values.splice(Math.min(index, values.length), 0, ...added);
      mutated = true;
      if (!me._indicesInvalid) {
        added.forEach(me.addToIndices, me);
      }
      if (!me._addedValues) {
        me._addedValues = /* @__PURE__ */ new Set();
      }
      for (const value of added) {
        me._addedValues.add(value);
      }
    }
    if (removed.length && me._addedValues) {
      for (const value of removed) {
        me._addedValues.delete(value);
      }
    }
    if (replaced.length && !me._indicesInvalid) {
      replaced.forEach((rep) => {
        me.removeFromIndices(rep[0]);
        me.addToIndices(rep[1]);
      });
    }
    if (mutated || replaced.length) {
      if (me.isSorted) {
        me.onSortersChanged();
      } else if (me.isFiltered) {
        if (me.autoFilter) {
          me.onFiltersChanged({ action: "splice", oldCount: 1 });
        } else {
          me._filteredValues.splice(Math.min(index, me._filteredValues.length), 0, ...added);
        }
      }
      me.generation++;
      me.trigger("change", {
        action: "splice",
        removed,
        added,
        replaced,
        oldCount
      });
    } else {
      me.trigger("noChange", {
        index,
        toRemove,
        toAdd
      });
    }
  }
  /**
   * Change the id of an existing member by mutating its {@link #config-idProperty}.
   * @param {String|Number|Object} item The item or id of the item to change.
   * @param {String|Number} newId The id to set in the existing member.
   */
  changeId(item, newId) {
    const me = this, { idProperty } = me, oldId = keyTypes[typeof item] ? item : item[idProperty], member = me.get(oldId);
    if (member) {
      const existingMember = me.get(newId);
      if (existingMember && member !== existingMember) {
        throw new Error(`Attempt to set item ${oldId} to already existing member's id ${newId}`);
      }
      me.removeIndexEntry(item, idProperty, oldId);
      me.addIndexEntry(item, idProperty, newId);
      member[idProperty] = newId;
    }
  }
  /**
   * Returns the item with the passed `id`. By default, filtered are honoured, and
   * if the item with the requested `id` is filtered out, nothing will be returned.
   *
   * To return the item even if it has been filtered out, pass the second parameter as `true`.
   * @param {*} id The `id` to find.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to return an item even if it is filtered out.
   * @returns {Object} The found item, or `undefined`.
   */
  get(id, ignoreFilters = false) {
    return this.getBy(this.idProperty, id, ignoreFilters);
  }
  getAt(index, ignoreFilters = false) {
    if (this.isFiltered && !ignoreFilters) {
      return this._filteredValues[index];
    } else {
      return this._values[index];
    }
  }
  /**
   * Returns the item with passed property name equal to the passed value. By default,
   * filtered are honoured, and if the item with the requested `id` is filtered out,
   * nothing will be returned.
   *
   * To return the item even if it has been filtered out, pass the third parameter as `true`.
   * @param {String} propertyName The property to test.
   * @param {*} value The value to find.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to return an item even if it is filtered out.
   * @returns {Object} The found item, or `undefined`.
   */
  getBy(propertyName, value, ignoreFilters = false) {
    return this.findItem(propertyName, value, this.isFiltered && ignoreFilters);
  }
  /**
   * The number of items in this collection. Note that this honours filtering.
   * See {@link #property-totalCount};
   * @property {Number}
   * @readonly
   */
  get count() {
    return this.values.length;
  }
  /**
   * The number of items in this collection regardless of filtering.
   * @property {Number}
   * @readonly
   */
  get totalCount() {
    return this._values.length;
  }
  /**
   * The property name used to extract item `id`s from added objects.
   * @member {String} idProperty
   */
  updateIdProperty(idProperty) {
    this.addIndex({ property: idProperty, unique: true });
  }
  //endregion
  //region Sorting
  /**
   * The Collection of {@link Core.util.CollectionSorter Sorters} for this Collection.
   * @member {Core.util.Collection} sorters
   */
  changeSorters(sorters) {
    return new Collection({
      values: ArrayHelper.asArray(sorters),
      internalListeners: {
        change: "onSortersChanged",
        thisObj: this
      }
    });
  }
  /**
   * Adds a Sorter to the Collection of Sorters which are operating on this Collection.
   *
   * A Sorter may be specified as an instantiated {@link Core.util.CollectionSorter}, or a config object for a
   * CollectionSorter of the form
   *
   *     {
   *         property  : 'age',
   *         direction : 'desc'
   *     }
   *
   * Note that by default, a Sorter *replaces* a Sorter with the same `property` to make
   * it easy to change existing Sorters. A Sorter's `id` is its `property` by default. You
   * can avoid this and add multiple Sorters for one property by configuring Sorters with `id`s.
   *
   * A Sorter may also be specified as a function which compares two objects eg:
   *
   *     (lhs, rhs) => lhs.customerDetails.age - rhs.customerDetails.age
   *
   * @param {CollectionSorterConfig} sorter A Sorter configuration object to add to the Collection
   * of Sorters operating on this Collection.
   * @returns {Core.util.CollectionSorter} The resulting Sorter to make it easy to remove Sorters.
   */
  addSorter(sorter) {
    const result = sorter instanceof CollectionSorter ? sorter : new CollectionSorter(sorter);
    this.sorters.add(result);
    return result;
  }
  /**
   * A flag which is `true` if this Collection has active {@link #property-sorters}.
   * @property {Boolean}
   * @readonly
   */
  get isSorted() {
    var _a2;
    return Boolean((_a2 = this._sorters) == null ? void 0 : _a2.count);
  }
  onSortersChanged() {
    const me = this;
    me._sortFunction = null;
    me._addedValues = null;
    me._values.sort(me.sortFunction);
    me.trigger("change", sortEvent);
  }
  /**
   * A sorter function which encapsulates the {@link Core.util.CollectionSorter Sorters}
   * for this Collection.
   * @property {Function}
   * @readonly
   */
  get sortFunction() {
    if (!this._sortFunction) {
      if (this.isSorted) {
        this._sortFunction = CollectionSorter.generateSortFunction(this.sorters.values);
      } else {
        this._sortFunction = return0;
      }
    }
    return this._sortFunction;
  }
  //endregion
  //region Filtering
  /**
   * The Collection of {@link Core.util.CollectionFilter Filters} for this Collection.
   * @property {Core.util.Collection}
   * @readonly
   */
  get filters() {
    if (!this._filters) {
      this._filters = new Collection({
        internalListeners: {
          change: "onFiltersChanged",
          thisObj: this
        }
      });
    }
    return this._filters;
  }
  /**
   * Adds a Filter to the Collection of Filters which are operating on this Collection.
   *
   * A Filter may be an specified as an instantiated {@link Core.util.CollectionFilter
   * CollectionFilter}, or a config object for a CollectionFilter of the form
   *
   *     {
   *         property : 'age',
   *         operator : '>=',
   *         value    : 21
   *     }
   *
   * Note that by default, a Filter *replaces* a Filter with the same `property` to make
   * it easy to change existing Filters. A Filter's `id` is its `property` by default. You
   * can avoid this and add multiple Filters for one property by configuring Filters with `id`s.
   *
   * A Filter may also be specified as a function which filters candidate objects eg:
   *
   *     candidate => candidate.customerDetails.age >= 21
   *
   * @param {CollectionFilterConfig|Core.util.CollectionFilter} filter A Filter or Filter configuration object to add
   * to the Collection of Filters operating on this Collection.
   * @returns {Core.util.CollectionFilter} The resulting Filter to make it easy to remove Filters.
   */
  addFilter(filter2) {
    const result = filter2 instanceof CollectionFilter ? filter2 : new CollectionFilter(filter2);
    this.filters.add(result);
    return result;
  }
  removeFilter(filter2) {
    const { filters } = this;
    if (!filter2.isCollectionFilter) {
      filter2 = filters.get(filter2);
    }
    filters.remove(filter2);
  }
  clearFilters() {
    this.filters.clear();
  }
  /**
   * A flag which is `true` if this Collection has active {@link #property-filters}.
   * @property {Boolean}
   * @readonly
   */
  get isFiltered() {
    return Boolean(this._filters && this._filters.count);
  }
  onFiltersChanged({ action, removed: gone, oldCount }) {
    const me = this, oldDataset = oldCount || action === "clear" && gone.length ? me._filteredValues : me._values;
    me._filterFunction = null;
    me._filteredValues = me._values.filter(me.filterFunction);
    me._indicesInvalid = true;
    const {
      toAdd: added,
      toRemove: removed
    } = ArrayHelper.delta(me._filteredValues, oldDataset, true);
    me.trigger("change", { ...filterEvent, added, removed });
  }
  /**
   * A filter function which encapsulates the {@link Core.util.CollectionFilter Filters}
   * for this Collection.
   * @property {Function}
   * @readonly
   */
  get filterFunction() {
    if (!this._filterFunction) {
      if (this.isFiltered) {
        this._filterFunction = CollectionFilter.generateFiltersFunction(this.filters.values);
      } else {
        this._filterFunction = FunctionHelper.returnTrue;
      }
    }
    return this._filterFunction;
  }
  //endregion
  //region Indexing
  changeExtraKeys(extraKeys) {
    const keys = ArrayHelper.asArray(extraKeys);
    return keys.map((config) => {
      if (typeof config === "string") {
        return { property: config, unique: true };
      }
      return config;
    });
  }
  updateExtraKeys(extraKeys) {
    for (let i = 0; i < extraKeys.length; i++) {
      this.addIndex(extraKeys[i]);
    }
  }
  /**
   * Adds a lookup index for the passed property name or index config. The index is built lazily when an index is
   * searched
   * @internal
   * @param {Object} indexConfig An index config
   * @param {String} indexConfig.property The property name to add an index for
   * @param {Boolean} [indexConfig.unique] Specify `false` to allow multiple entries of the same index, turning
   *   entries into sets
   * @param {Object} [indexConfig.dependentOn] The properties that make the key
   */
  addIndex(indexConfig) {
    const me = this;
    if (indexConfig) {
      (me._indices || (me._indices = {}))[indexConfig.property] = /* @__PURE__ */ new Map();
      Object.assign(me._indices[indexConfig.property], indexConfig);
      me.invalidateIndices();
      if (indexConfig.dependentOn) {
        me.hasCompositeIndex = true;
      }
    }
  }
  /**
   * Return the index of the item with the specified key having the specified value.
   *
   * By default, filtering is taken into account and this returns the index in the filtered dataset if present. To
   * bypass this, pass the third parameter as `true`.
   *
   * Only useful for indices configured with `unique: true`.
   *
   * @param {String} propertyName The name of the property to test.
   * @param {*} value The value to test for.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to return the index in
   * the original data set if the item is filtered out.
   * @returns {Number} The index of the item or `-1` if not found for unique indices
   */
  findIndex(propertyName, value, ignoreFilters = false) {
    const item = this.findItem(propertyName, value, ignoreFilters);
    if (!item) {
      return -1;
    }
    const values = this.isFiltered && !ignoreFilters ? this._filteredValues : this._values;
    return values.indexOf(item);
  }
  /**
   * Return the item with the specified key having the specified value.
   *
   * By default, filtering is taken into account. To bypass this, pass the third parameter as `true`.
   *
   * For indices configured with `unique: false`, a Set of items will be returned.
   *
   * @param {String} propertyName The name of the property to test.
   * @param {*} value The value to test for.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to return the index in
   * the original data set if the item is filtered out.
   * @returns {Object|Set} The found item or Set of items or null
   */
  findItem(propertyName, value, ignoreFilters = false) {
    var _a2;
    const me = this, { isFiltered } = me, index = isFiltered && !ignoreFilters ? me.indices[filteredIndicesProperty][propertyName] : me.indices[propertyName];
    if (index) {
      const item = (_a2 = index.get(value)) != null ? _a2 : typeof value === "string" && value.length && !isNaN(value) && index.get(Number(value)) || null;
      if (item != null) {
        return item;
      }
    } else {
      const values = isFiltered && !ignoreFilters ? me._filteredValues : me._values, count = values.length;
      for (let i = 0; i < count; i++) {
        const item = values[i];
        if (item[propertyName] == value) {
          return item;
        }
      }
    }
    return null;
  }
  removeIndex(propertyName) {
    delete this._indices[propertyName];
    this.hasCompositeIndex = Object.values(this.indices).some((index) => index.dependentOn);
  }
  /**
   * Returns the index of the item with the same `id` as the passed item.
   *
   * By default, filtering is honoured, so if the item in question has been added, but is currently filtered out of
   * visibility, `-1` will be returned.
   *
   * To find the index in the master, unfiltered dataset, pass the second parameter as `true`;
   * @param {Object|String|Number} item The item to find, or an `id` to find.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to find the index in the master, unfiltered data set.
   * @returns {Number} The index of the item, or `-1` if not found.
   */
  indexOf(item, ignoreFilters = false) {
    return this.findIndex(this.idProperty, keyTypes[typeof item] ? item : item[this.idProperty], ignoreFilters);
  }
  /**
   * Returns `true` if this Collection includes an item with the same `id` as the passed item.
   *
   * By default, filtering is honoured, so if the item in question has been added,
   * but is currently filtered out of visibility, `false` will be returned.
   *
   * To query inclusion in the master, unfiltered dataset, pass the second parameter as `true`;
   * @param {Object|String|Number} item The item to find, or an `id` to find.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to find the index in the master, unfiltered data set.
   * @returns {Boolean} True if the passed item is found.
   */
  includes(item, ignoreFilters = false) {
    if (Array.isArray(item)) {
      return item.some((item2) => this.includes(item2));
    }
    return Boolean(this.findItem(this.idProperty, keyTypes[typeof item] ? item : item[this.idProperty], ignoreFilters));
  }
  get indices() {
    if (this._indicesInvalid) {
      this.rebuildIndices();
    }
    return this._indices;
  }
  invalidateIndices() {
    this._indicesInvalid = true;
  }
  /**
   * Called when the Collection is mutated and the indices have been flagged as invalid.
   *
   * Rebuilds the indices object to allow lookup by keys.
   * @internal
   */
  rebuildIndices() {
    const me = this, isFiltered = me.isFiltered, indices = me._indices || (me._indices = {}), keyProps = Object.keys(indices), indexCount = keyProps.length, values = me._values;
    let filteredIndices;
    if (isFiltered) {
      filteredIndices = indices[filteredIndicesProperty] = {};
    }
    for (let i = 0; i < indexCount; i++) {
      const index = indices[keyProps[i]];
      index.clear();
      if (isFiltered) {
        let filteredIndex = filteredIndices[keyProps[i]];
        if (filteredIndex) {
          filteredIndex.clear();
        } else {
          filteredIndex = filteredIndices[keyProps[i]] = /* @__PURE__ */ new Map();
          filteredIndex.unique = index.unique;
        }
      }
    }
    doRebuildIndices(values, indices, keyProps, indexCount);
    if (isFiltered) {
      doRebuildIndices(me._filteredValues, filteredIndices, keyProps, indexCount);
    }
    me._indicesInvalid = false;
  }
  // Returns an array with [indices] or [indices, filteredIndices] if filtering is used
  getIndices(propertyName) {
    const indices = [this.indices[propertyName]];
    if (this.isFiltered) {
      indices.push(this.indices[filteredIndicesProperty][propertyName]);
    }
    return indices;
  }
  /**
   * Add an item to all indices
   * @param {*} item Item already available in the Collection
   * @private
   */
  addToIndices(item) {
    Object.keys(this.indices).forEach((propertyName) => {
      this.addIndexEntry(item, propertyName, item[propertyName]);
    });
  }
  /**
   * Remove an item from all indices
   * @param {*} item Item already available in the Collection
   * @private
   */
  removeFromIndices(item) {
    Object.keys(this.indices).forEach((propertyName) => {
      this.removeIndexEntry(item, propertyName, item[propertyName]);
    });
  }
  /**
   * Remove an entry from an index, and if filtering is used also from the filtered index.
   * @param {*} item Item already available in the Collection
   * @param {String} propertyName Property of the item, will be matched with configured indices
   * @param {*} oldValue Value to remove
   * @private
   */
  removeIndexEntry(item, propertyName, oldValue) {
    this.getIndices(propertyName).forEach((index) => removeItemFromIndex(item, index, oldValue));
  }
  /**
   * Add a new entry to an index, and if filtering is used also to the filtered index.
   * @param {*} item Item already available in the Collection
   * @param {String} propertyName Property of the item, will be matched with configured indices
   * @param {*} value Value to store
   * @private
   */
  addIndexEntry(item, propertyName, value) {
    this.getIndices(propertyName).forEach((index) => addItemToIndex(item, index, value));
  }
  /**
   * Call externally to update indices on item mutation (from Store)
   * @param {*} item Item already available in the Collection
   * @param {Object} wasSet Uses the `wasSet` format from Store, `{ field : { oldValue, newValue } }`
   * @internal
   */
  onItemMutation(item, wasSet) {
    const me = this;
    if (!me._indicesInvalid && Object.keys(me.indices).length > 1) {
      Object.keys(wasSet).forEach((propertyName) => {
        var _a2;
        const indexConfig = me.indices[propertyName];
        if (indexConfig) {
          const { value, oldValue } = wasSet[propertyName];
          me.removeIndexEntry(item, propertyName, oldValue);
          me.addIndexEntry(item, propertyName, value);
        }
        if (me.hasCompositeIndex) {
          const dependentIndex = Object.values(me.indices).find((index) => {
            var _a3;
            return (_a3 = index.dependentOn) == null ? void 0 : _a3[propertyName];
          });
          if (dependentIndex) {
            const keysAndOldValues = {};
            for (const o in dependentIndex.dependentOn) {
              keysAndOldValues[o] = ((_a2 = wasSet[o]) == null ? void 0 : _a2.oldValue) || item[o];
            }
            const oldIndex = item.buildIndexKey(keysAndOldValues);
            me.removeIndexEntry(item, dependentIndex.property, oldIndex);
            me.addIndexEntry(item, dependentIndex.property, item[dependentIndex.property]);
          }
        }
      });
    }
  }
  //endregion
};
Collection._$name = "Collection";

// ../Core/lib/Core/util/Bag.js
var nonPrimitives = /* @__PURE__ */ new WeakMap();
var safeIndexKey = (value) => {
  if (value && typeof value === "object") {
    let substitute = nonPrimitives.get(value);
    if (substitute === void 0) {
      substitute = Symbol("bscik");
      nonPrimitives.set(value, substitute);
    }
    value = substitute;
  }
  return value;
};
var Bag = class {
  constructor(config) {
    const me = this;
    me.generation = 0;
    me.items = /* @__PURE__ */ new Set();
    me.idMap = {};
    me.idProperty = "id";
    if (config) {
      if (config.idProperty) {
        me.idProperty = config.idProperty;
      }
      if (config.values) {
        me.values = config.values;
      }
    }
  }
  /**
   * Returns the item with the passed `id`.
   *
   * @param {*} id The `id` to find.
   * @returns {Object} The found item, or `undefined`.
   */
  get(key) {
    return this.idMap[safeIndexKey(key)];
  }
  /**
   * The number of items in this Bag.
   * @property {Number}
   * @readonly
   */
  get count() {
    return this.items.size;
  }
  /**
   * Adds the passed item(s) to this Bag. Existing items with the same ID
   * will be replaced.
   * @param {Object|Object[]} toAdd Item(s) to add.
   */
  add(...toAdd) {
    if (toAdd.length === 1 && Array.isArray(toAdd[0])) {
      toAdd = toAdd[0];
    }
    const me = this, {
      items,
      idMap,
      idProperty
    } = me, len = toAdd.length;
    for (let i = 0; i < len; i++) {
      const item = toAdd[i], key = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]), existingItem = idMap[key];
      if (existingItem == null) {
        idMap[key] = item;
        items.add(item);
        me.generation++;
      } else if (existingItem !== item) {
        idMap[key] = item;
        items.delete(existingItem);
        items.add(item);
      }
    }
  }
  /**
   * Returns `nth` item in this Bag.
   * @param {Number} nth The index of the matching item. Negative numbers index for the last item. For example, -1
   * returns the last item, -2 the 2nd to last item etc.
   * @returns {Object} The matched item, or `undefined`.
   */
  at(nth) {
    let item, ret;
    if (nth < 0) {
      nth += this.count;
    }
    for (item of this.items) {
      if (!nth--) {
        ret = item;
        break;
      }
    }
    return ret;
  }
  /**
   * Removes the passed item(s) from this Bag.
   * @param {Object|Object[]} toRemove Item(s) to remove.
   */
  remove(toRemove) {
    toRemove = ArrayHelper.asArray(toRemove);
    const { items, idMap, idProperty } = this, len = toRemove.length;
    for (let i = 0; i < len; i++) {
      const item = toRemove[i], key = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]), existingItem = idMap[key];
      if (existingItem != null) {
        items.delete(existingItem);
        delete idMap[key];
        this.generation++;
      }
    }
  }
  clear() {
    this.items.clear();
    this.idMap = {};
    this.generation++;
  }
  /**
   * Returns the number of items in this Bag which elicits a truthy return value from the passed function.
   * @param {Function} fn A function, which, when passed an item, returns `true` to select it as the item to return.
   * @returns {Number} The number of matched items.
   */
  countOf(fn2) {
    let ret = 0, item;
    for (item of this.items) {
      if (fn2(item)) {
        ++ret;
      }
    }
    return ret;
  }
  /**
   * Change the id of an existing member by mutating its idProperty.
   * @param {String|Number|Object} item The item or id of the item to change.
   * @param {String|Number} newId The id to set in the existing member.
   */
  changeId(item, newId) {
    const me = this, { idMap, idProperty } = me, oldId = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]), member = me.get(oldId);
    if (member) {
      const existingMember = me.get(newId);
      if (existingMember && member !== existingMember) {
        throw new Error(`Attempt to set item ${oldId} to already existing member's id ${newId}`);
      }
      member[idProperty] = newId;
      delete idMap[oldId];
      idMap[newId] = member;
    }
  }
  /**
   * Extracts the matching items from this Bag into an array based upon the passed value filter function.
   * @param {Function} fn A function, which, when passed an item, returns a `true` to place into the resulting array.
   * @param {Object} [thisObj] The `this` reference when the function is called.
   * @returns {Object[]} An array of values extracted from this Bag.
   */
  filter(fn2, thisObj) {
    const { items } = this, result = [];
    let i = 0;
    items.forEach((item) => {
      if (fn2.call(thisObj, item, i++, items)) {
        result.push(item);
      }
    });
    return result;
  }
  /**
   * Returns `true` if this Collection includes an item with the same `id` as the passed item.
   *
   * @param {Object|String|Number} item The item to find, or an `id` to find.
   * @returns {Boolean} True if the passed item is found.
   */
  includes(item) {
    const key = keyTypes[typeof item] ? item : safeIndexKey(item[this.idProperty]);
    return Boolean(this.idMap[key]);
  }
  /**
   * Extracts the content of this Bag into an array based upon the passed
   * value extraction function.
   * @param {Function} fn A function, which, when passed an item, returns a value to place into the resulting array.
   * @param {Object} [thisObj] The `this` reference when the function is called.
   * @returns {Object[]} An array of values extracted from this Bag.
   */
  map(fn2, thisObj) {
    const { items } = this, result = new Array(items.size);
    let i = 0;
    items.forEach((item) => {
      result[i] = fn2.call(thisObj, item, i++, items);
    });
    return result;
  }
  /**
   * Executes the passed function for each item in this Bag, passing in the item.
   * @param {Function} fn The function to execute.
   * @param {Object} [thisObj] The `this` reference when the function is called.
   */
  forEach(fn2, thisObj) {
    return this.items.forEach(fn2, thisObj);
  }
  /**
   * Returns `nth` item in this Bag which elicits a truthy return value from the provided matcher function `fn`.
   * @param {Function} fn A function which, when passed an item, returns `true` to select the item as a match.
   * @param {Number} [nth=0] The index of the matching item. By default, 0 returns the first item that matches
   * according to `fn`. Negative numbers index for the last item. For example, -1 returns the last matching item,
   * -2 the 2nd to last matching item etc..
   * @returns {Object} The matched item, or `undefined`.
   */
  find(fn2, nth = 0) {
    let item, ret;
    if (nth < 0) {
      nth += this.countOf(fn2);
    }
    for (item of this.items) {
      if (fn2(item) && !nth--) {
        ret = item;
        break;
      }
    }
    return ret;
  }
  /**
   * Iterator that allows you to do for (let item of bag)
   */
  [Symbol.iterator]() {
    return this.items[Symbol.iterator]();
  }
  indexOf(item, matchFn) {
    let index = -1, it;
    for (it of this.items) {
      if (!matchFn || matchFn(it)) {
        ++index;
        if (it === item) {
          return index;
        }
      }
    }
    return -1;
  }
  /**
   * The set of values of this Bag.
   *
   * Setting this property replaces the data set.
   * @property {Object[]}
   */
  get values() {
    return [...this.items];
  }
  set values(values) {
    values = ArrayHelper.asArray(values);
    this.clear();
    this.add.apply(this, values);
    this.generation++;
  }
  /**
   * Sort the values of this Bag using the passed comparison function.
   *
   * Setting this property replaces the data set.
   * @param {Function} fn Comparison function which returns -ve, 0, or +ve
   */
  sort(fn2) {
    this.values = this.values.sort(fn2);
  }
  some(fn2, thisObj) {
    return this.values.some(fn2, thisObj);
  }
};
Bag._$name = "Bag";

// ../Core/lib/Core/data/StoreBag.js
var StoreBag = class extends Bag {
  add(...toAdd) {
    if (toAdd.length === 1 && Array.isArray(toAdd[0])) {
      toAdd = toAdd[0];
    }
    return super.add(...toAdd.filter((record) => record.isPersistable));
  }
};
StoreBag._$name = "StoreBag";

// ../Core/lib/Core/data/mixin/StoreCRUD.js
var StoreCRUD_default = (Target) => class StoreCRUD extends (Target || Base2) {
  static get $name() {
    return "StoreCRUD";
  }
  //region Config
  static get defaultConfig() {
    return {
      /**
       * Commit changes automatically
       * @config {Boolean}
       * @default
       * @category Common
       */
      autoCommit: false
    };
  }
  static get properties() {
    return {
      isRemoving: false,
      suspendCount: 0
    };
  }
  //endregion
  //region Events
  /**
   * Fired after removing all records
   * @event removeAll
   * @param {Core.data.Store} source This Store
   */
  /**
   * Fired before committing changes. Return false from handler to abort commit
   * @event beforeCommit
   * @param {Core.data.Store} source This Store
   * @param {Object} changes Modification data
   */
  /**
   * Fired after committing changes
   * @event commit
   * @param {Core.data.Store} source This Store
   * @param {Object} changes Modification data
   */
  /**
   * Fired before records are removed from this store by the {@link #function-remove} or {@link #function-removeAll}.
   * Also fired when removing a child record in a tree store using {@link Core.data.mixin.TreeNode#function-removeChild}.
   * The remove may be vetoed by returning `false` from a handler.
   * @event beforeRemove
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model[]} records The records which are to be removed.
   * @param {Core.data.Model} parent The record from which children are being removed when using a tree store. Only
   * provided when removing a single node.
   * @param {Boolean} isMove This flag is `true` if the child node is being removed by
   * {@link Core.data.mixin.TreeNode#function-appendChild appendChild} to be moved
   * _within the same tree_.
   * @param {Boolean} removingAll This flag is `true` if the operation is removing the store's entire data set.
   * @preventable
   */
  /**
   * Fired before records are added to this store by the {@link #function-add} or {@link #function-insert}. In a tree
   * store, also fired by {@link Core.data.mixin.TreeNode#function-appendChild} and
   * {@link Core.data.mixin.TreeNode#function-insertChild}. The add or insert may be vetoed by returning `false`
   * from a handler.
   * @event beforeAdd
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model[]} records The records which are to be added
   * @param {Core.data.Model} parent The parent node when using a tree store
   * @preventable
   */
  /**
   * Fired after adding/inserting record(s). If the record was added to a parent, the `isChild` flag is set on the
   * event. If it was inserted, event contains `index`
   * @event add
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model[]} records Added records. In case of tree store, if branch is added, only branch root
   * is returned
   * @param {Core.data.Model[]} [allRecords] Flat list of all added records. In case of tree store, if branch is
   * added, all new records are returned, not only branch root
   * @param {Core.data.Model} [parent] If due to an {@link Core/data/mixin/TreeNode#function-appendChild}
   * call, this is the parent node added to.
   * @param {Number} [index] Insertion point in the store's {@link Core.data.Store#config-storage Collection}.
   * @param {Number} [oldIndex] Not used for tree stores. The index of the first record moved.
   * @param {Boolean} [isChild] Flag which is set to true if the records are added to a parent record
   * @param {Boolean} [isExpand] Flag which is set to true if records are added to the store by expanding parent
   * @param {Object} [isMove] An object keyed by the ids of the records which were moved from another
   * position in the store, or from another parent node in the store. The ids of moved records will be
   * property names with a value `true`.
   */
  /**
   * Fired when one or more records are removed
   * @event remove
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model[]} records Array of removed records. In case of tree store, if branch is removed, only branch root
   * is returned
   * @param {Core.data.Model[]} [allRecords] Flat array of all removed records. In case of tree store, if branch is
   * removed, all removed records are returned, not only branch root
   * @param {Core.data.Model} [parent] If due to a {@link Core.data.mixin.TreeNode#function-removeChild removeChild}
   * call, this is the parent node removed from. Only applicable when removing a single tree node.
   * @param {Number} [index] Visible index at which record was removed. In case the record was removed from a collapsed
   * branch, -1 is returned. For tree store, this is only provided when removing a single node.
   * @param {Boolean} [isChild] Flag which is set to true if the record was removed from a parent record
   * @param {Boolean} [isCollapse] Flag which is set to true if records were removed from the store by collapsing parent
   * @param {Boolean} [isMove] Passed as `true` if the remove was part of a move operation within this Store.
   */
  //endregion
  //region Add, insert & remove
  /**
   * Removes a record from this store. Fires a single {@link #event-remove} event passing the removed records.
   * @param {String|String[]|Number|Number[]|Core.data.Model|Core.data.Model[]} records Record/array of records (or record ids) to remove
   * @param {Boolean} [silent] Specify `true` to suppress events/autoCommit
   * @returns {Core.data.Model[]} Removed records
   * @fires beforeRemove
   * @fires remove
   * @fires change
   * @category CRUD
   */
  remove(records, silent = false) {
    const me = this, { storage } = me;
    records = ArrayHelper.asArray(records).reduce((result, r) => {
      r = me.getById(r);
      if (r) {
        result.push(r);
      }
      return result;
    }, []);
    if (records.length === 0) {
      return records;
    }
    if (!me.tree && !silent && me.trigger("beforeRemove", { records }) === false) {
      return [];
    }
    me.isRemoving = true;
    if (me.isGrouped) {
      const oldCount = storage.count, recordsInCollapsedGroups = [], changedGroupParents = /* @__PURE__ */ new Set();
      for (const rec of records) {
        const { groupParent } = rec.instanceMeta(me);
        if (groupParent.meta.collapsed) {
          recordsInCollapsedGroups.push(rec);
        }
        ArrayHelper.remove(groupParent.groupChildren, rec);
        ArrayHelper.remove(groupParent.unfilteredGroupChildren, rec);
        groupParent.meta.childCount--;
        changedGroupParents.add(groupParent);
      }
      for (const groupParent of changedGroupParents) {
        if (groupParent.groupChildren.length > 0) {
          me.onModelChange(groupParent, {}, {});
        }
      }
      if (recordsInCollapsedGroups.length) {
        storage.trigger("change", {
          action: "splice",
          removed: recordsInCollapsedGroups,
          added: [],
          replaced: [],
          oldCount
        });
      }
    } else if (me.tree) {
      const allRemovedRecords = [], removingMultiple = records.length > 1, firstRemoved = records[0], index = removingMultiple ? void 0 : storage.indexOf(firstRemoved), removeChildArgs = records.reduce((result, child) => {
        const { parent } = child;
        if (parent) {
          if (!result[parent.id]) {
            result[parent.id] = [parent, []];
          }
          result[parent.id][1].push(child);
        }
        return result;
      }, {}), removals = Array.from(Object.values(removeChildArgs));
      if (!silent && me.trigger("beforeRemove", { records, isMove: false, parent: removingMultiple ? void 0 : firstRemoved.parent }) === false) {
        me.isRemoving = false;
        return [];
      }
      removals.sort((a, b) => b[0].childLevel - a[0].childLevel);
      for (const [parent, children] of removals) {
        allRemovedRecords.push(...parent.removeChild(children, false, true));
      }
      if (!silent) {
        me.trigger("remove", {
          // parent is only relevant when removing single node
          parent: removingMultiple ? void 0 : firstRemoved.parent,
          index,
          isChild: true,
          allRecords: allRemovedRecords,
          isMove: false,
          records
        });
        me.trigger("change", {
          action: "remove",
          records
        });
      }
      me.isRemoving = false;
      return records;
    }
    if (records.length === 0) {
      me.isRemoving = false;
      return records;
    }
    for (const record of records) {
      record.beforeRemove(records);
    }
    if (silent) {
      me.suspendEvents();
    }
    storage.remove(records);
    if (silent) {
      me.resumeEvents();
    }
    if (me.autoCommit) {
      me.doAutoCommit();
    }
    me.isRemoving = false;
    return records;
  }
  /**
   * Clears store data. Used by removeAll, separate function for using with chained stores.
   * @private
   * @category CRUD
   */
  clear(isLoading = false) {
    var _a2, _b;
    const me = this, { storage } = me;
    if (me.storage.totalCount || ((_b = (_a2 = me.rootNode) == null ? void 0 : _a2.unfilteredChildren) == null ? void 0 : _b.length)) {
      if (!isLoading && me.trigger("beforeRemove", { records: storage.allValues, removingAll: true }) === false) {
        return null;
      }
      if (me.rootNode) {
        if (!me.isChained) {
          me.rootNode.clearChildren(isLoading);
        }
      } else if (isLoading) {
        const allRecords = me.registeredRecords;
        for (let i = allRecords.length - 1, rec; i >= 0; i--) {
          rec = allRecords[i];
          if (rec && !rec.isDestroyed) {
            rec.unjoinStore(me);
          }
        }
      }
      if (isLoading) {
        me.removed.clear();
        storage.suspendEvents();
      }
      storage.clear();
      if (isLoading) {
        storage.resumeEvents();
      }
      me.added.clear();
      me.modified.clear();
    }
  }
  /**
   * Removes all records from the store.
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Boolean} `true` unless the action was prevented, in which case it returns `false`
   * @fires beforeRemove
   * @fires removeAll
   * @fires change
   * @category CRUD
   */
  removeAll(silent = false) {
    const me = this, storage = me.storage;
    let result;
    me.isRemoving = true;
    if (silent) {
      storage.suspendEvents();
      const allRecords = me.registeredRecords;
      for (let i = allRecords.length - 1, rec; i >= 0; i--) {
        rec = allRecords[i];
        if (rec && !rec.isDestroyed && !rec.isRoot) {
          rec.unjoinStore(me);
        }
      }
    }
    if (me.tree) {
      result = me.rootNode.clear() !== false;
    } else {
      result = me.clear() !== null;
    }
    if (silent) {
      storage.resumeEvents();
    }
    me.isRemoving = false;
    return result;
  }
  /**
   * Add records to store.
   * @param {Core.data.Model|Core.data.Model[]|Object|Object[]} records Array of records/data or a single record/data to add to store
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Core.data.Model[]} Added records
   * @fires add
   * @fires change
   * @category CRUD
   */
  add(records, silent = false, options = {}) {
    const me = this, { storage } = me;
    records = ArrayHelper.asArray(records);
    if (!(records == null ? void 0 : records.length)) {
      return;
    }
    me.tree = me.tree || Boolean(me.autoTree && records[0].children);
    if (me.tree) {
      const parentIdMap = /* @__PURE__ */ new Map(), parentIndexField = me.modelClass.getFieldDataSource("parentIndex"), { parentIdField } = me.modelClass, added2 = [];
      records.forEach((node) => {
        const parentId = node[parentIdField];
        if (!parentIdMap.has(parentId)) {
          parentIdMap.set(parentId, { append: [], insert: [] });
        }
        const entry = parentIdMap.get(parentId);
        if (!node.isModel && parentIndexField in node) {
          entry.insert.push(node);
        } else {
          entry.append.push(node);
        }
      });
      parentIdMap.forEach(({ append, insert }, parentId) => {
        const parentNode = parentId == null ? me.rootNode : me.getById(parentId);
        if (!parentNode) {
          throw new Error(`Parent node with id ${parentId} not found, cannot add children.`);
        }
        if (append.length) {
          added2.push(...parentNode.appendChild(append, silent));
        }
        if (insert.length) {
          for (const toInsert of insert) {
            added2.push(parentNode.insertChild(toInsert, toInsert[parentIndexField], silent, options));
          }
        }
      });
      if (me.isFiltered && me.reapplyFilterOnAdd) {
        me.filter({
          silent: true
        });
      }
      if (me.reapplySortersOnAdd && !me.isSyncingDataOnLoad) {
        me.sort();
      }
      return added2;
    }
    if (!silent && me.trigger("beforeAdd", { records }) === false) {
      return null;
    }
    me.tree = me.tree || Boolean(me.autoTree && records[0].children);
    if (me.tree) {
      return me.rootNode.appendChild(records);
    }
    const added = me.processRecords(records);
    if (silent) {
      me.suspendEvents();
    }
    storage.add(added);
    if (silent) {
      me.resumeEvents();
    }
    if (me.autoCommit) {
      me.doAutoCommit();
    }
    return added;
  }
  processRecords(records, onRecordCreated) {
    return records.map((data) => {
      const record = this.processRecord(data.isModel ? data : this.createRecord(data));
      onRecordCreated == null ? void 0 : onRecordCreated.call(this, record);
      return record;
    });
  }
  /**
   * Insert records into the store.
   * @param {Number} index Index to insert at
   * @param {Core.data.Model|Core.data.Model[]|Object|Object[]} records Array of records/data or a single record/data to insert to store
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Core.data.Model[]} Inserted records
   * @fires add
   * @fires change
   * @category CRUD
   */
  insert(index, records, silent = false) {
    var _a2;
    const me = this, storage = me.storage, insertBefore = me.getAt(index), _records = storage.values, removeIndices = [];
    records = ArrayHelper.asArray(records);
    if (me.tree) {
      const root = me.rootNode;
      return root.insertChild(records, (_a2 = root.children) == null ? void 0 : _a2[index], silent);
    }
    if (!silent && me.trigger("beforeAdd", { records }) === false) {
      return null;
    }
    let isNoop, start, i;
    if (_records[start = index] === records[0] || _records[start = index - 1] === records[0]) {
      for (isNoop = true, i = 0; isNoop && i < records.length; i++) {
        if (records[i] !== _records[start + i]) {
          isNoop = false;
        }
      }
    }
    if (isNoop) {
      return null;
    }
    const added = me.processRecords(records, (record) => {
      const removedAtIndex = storage.indexOf(record);
      if (record.children && record.children.length && me.autoTree) {
        me.tree = true;
      }
      if (removedAtIndex > -1) {
        if (removedAtIndex < index && insertBefore)
          index--;
        removeIndices.push(removedAtIndex);
      }
      record.meta.previousIndex = removedAtIndex;
    });
    me.suspendEvents();
    me.storage.remove(removeIndices);
    me.resumeEvents();
    if (silent) {
      me.suspendEvents();
    }
    storage.splice(index, 0, ...added);
    if (silent) {
      me.resumeEvents();
    }
    if (me.autoCommit) {
      me.doAutoCommit();
    }
    return added;
  }
  /**
   * Moves a record, or block of records to another location.
   * @param {Core.data.Model|Core.data.Model[]} records The record(s) to move.
   * @param {Core.data.Model} beforeRecord the record to insert the first record(s) before.
   * @fires change
   * @category CRUD
   */
  move(records, beforeRecord) {
    if (this.isTree) {
      beforeRecord.parent.insertChild(records, beforeRecord);
    } else {
      this.storage.move(records, beforeRecord);
    }
  }
  //endregion
  //region Update multiple
  setMultiple(filterFn, field2, value) {
    const me = this, records = [], changes = [];
    me.forEach((r) => {
      if (filterFn(r)) {
        changes.push(r.set(field2, value, true));
        records.push(r);
      }
    });
    me.trigger("updateMultiple", { records, all: me.records.length === records.length });
    me.trigger("change", { action: "updatemultiple", records, all: me.records.length === records.length });
    if (me.reapplyFilterOnUpdate && me.isFiltered)
      me.filter();
  }
  setAll(field2, value) {
    const me = this, changes = [];
    me.forEach((r) => {
      changes.push(r.set(field2, value, true));
    });
    me.trigger("updateMultiple", { records: me.records, all: true });
    me.trigger("change", { action: "updatemultiple", records: me.records, all: true });
    if (me.reapplyFilterOnUpdate && me.isFiltered)
      me.filter();
  }
  //endregion
  //region Commit
  /**
   * Accepts all changes, resets the modification tracking:
   * * Clears change tracking for all records
   * * Clears added
   * * Clears modified
   * * Clears removed
   * Leaves the store in an "unmodified" state.
   * @internal
   */
  acceptChanges() {
    const me = this;
    me.added.forEach((r) => r.clearChanges(true, false));
    me.modified.forEach((r) => r.clearChanges(true, false));
    me.added.clear();
    me.modified.clear();
    me.removed.clear();
  }
  /**
   * Commits changes, per default only returns changes and resets tracking.
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Object} Changes, see {@link #property-changes}
   * @fires beforeCommit
   * @fires commit
   * @category CRUD
   */
  commit(silent = false) {
    const { changes } = this;
    if (!silent && this.trigger("beforeCommit", { changes }) === false) {
      return false;
    }
    this.acceptChanges();
    if (!silent) {
      this.trigger("commit", { changes });
    }
    return changes;
  }
  /**
   * Reverts all changes in the store (adds removed records back, and removes newly added records).
   * @fires change
   * @fires refresh
   * @category CRUD
   */
  revertChanges() {
    const me = this, { changes } = me;
    if (changes) {
      const event = { action: "clearchanges", changes };
      me.add(me.removed.values, true);
      me.remove(me.added.values, true);
      me.modified.forEach((r) => r.revertChanges(true));
      me.added.clear();
      me.modified.clear();
      me.removed.clear();
      me.trigger("change", event);
      me.trigger("refresh", event);
    }
  }
  /**
   * Get uncommitted changes as an object of added/modified/removed arrays of records.
   *
   * ```javascript
   * // Format:
   * {
   *      added: [], // array of Core.data.Model
   *      modified: [], // array of Core.data.Model
   *      removed: [] // array of Core.data.Model
   * }
   * ```
   *
   * @member {Object} changes
   * @property {Core.data.Model[]} changes.added Records that have been added
   * @property {Core.data.Model[]} changes.modified Records that have changes to persistable fields
   * @property {Core.data.Model[]} changes.removed Records that have been removed
   * @readonly
   * @category Records
   */
  get changes() {
    const me = this, modified = me.modified.values.filter((r) => r.rawModifications);
    return me.added.count || modified.length || me.removed.count ? {
      // Slicing to have changes intact when triggering commit
      added: me.added.values.slice(),
      modified,
      removed: me.removed.values.slice()
    } : null;
  }
  /**
   * Setting autoCommit to true automatically commits changes to records.
   * @property {Boolean}
   * @category Records
   */
  get autoCommit() {
    return this._autoCommit;
  }
  set autoCommit(auto) {
    this._autoCommit = auto;
    if (auto && this.changes) {
      this.commit();
    }
  }
  /**
   * Suspends automatic commits upon store changes. Can be called multiple times (it uses an internal counter).
   * @category Records
   */
  suspendAutoCommit() {
    this.suspendCount++;
  }
  /**
   * Resumes automatic commits upon store changes. Will trigger commit if the internal counter is 0.
   * @category Records
   */
  resumeAutoCommit(doCommit = true) {
    this.suspendCount--;
    if (this.autoCommit && doCommit) {
      this.doAutoCommit();
    }
  }
  doAutoCommit() {
    if (this.suspendCount <= 0) {
      this.commit();
    }
  }
  //endregion
};

// ../Core/lib/Core/data/mixin/StoreChanges.js
var StoreChanges_default = (Target) => class StoreChanges extends (Target || Base2) {
  static get $name() {
    return "StoreChanges";
  }
  static get configurable() {
    return {
      /**
       * Specifies target to filter and sort after applying changeset:
       * * `'changes'` - apply sort and filter to changeset only (see more below)
       * * `'none'` - do not apply sort and filter
       *
       * ### `changes` behavior
       * If the store has filters in effect when the changeset is applied, the following rules will determine how the
       * filtered values are affected:
       * - Among added records, only those that match the filter will be included in the filtered set
       * - Among updated records, those that did not previously match the filter but now do will be added to the filtered set,
       *   and those that did match but no longer do will also remain in the filtered set. This means that new records may
       *   appear in the filtered set as a result of `applyChanges`, but records will not disappear until filters are
       *   re-applied.
       *
       * @default
       * @prp {'changes'|'none'}
       * @category Advanced
       */
      applyChangesetFilterSortTarget: "changes"
    };
  }
  /**
   * Applies changes from another store to this store. Useful if cloning records in one store to display in a
   * grid in a popup etc. to reflect back changes.
   * @param {Core.data.Store} otherStore
   * @category CRUD
   */
  applyChangesFromStore(otherStore) {
    const me = this, { changes } = otherStore;
    if (!changes) {
      return;
    }
    if (changes.added) {
      me.add(changes.added);
    }
    if (changes.removed) {
      me.remove(changes.removed.map((r) => r.id));
    }
    if (changes.modified) {
      changes.modified.forEach((record) => {
        const localRecord = me.getById(record.id);
        localRecord == null ? void 0 : localRecord.set(record.modifications);
      });
    }
  }
  /**
   * Applies a set of changes (presumable from a backend) expressed as an object matching the format outputted by the
   * {@link Core/data/Store#property-changes} property: `{ added : [], modified/updated : [], removed : [] }`
   *
   * `added` is expected to be an array of raw data objects consumable by the stores model class for records to add to
   * the store (see example snippet below).
   *
   * `modified` (or `updated` for compatibility with Schedulers CrudManager) is expected to have the same format as
   * `added`, but should always include the `id` of the record to update.
   *
   * Records that have been created locally and gets assigned a proper id by the backend are expected to also pass a
   * `phantomId` field (name of the field is configurable using the `phantomIdField` arg, more info on phantom ids
   * below), to match it with the current id of a local record (`id` will contain the new id).
   *
   * Note that it is also possible to pass this `phantomId` -> `id` mapping in the `added` array. When encountering a
   * record in that array that already exists in the local store, it will be treated the same was as a record in the
   * `modified` array.
   *
   * `removed` is expected to be an array of objects with the `{ id : xx }` shape. Any matches on an id in the store
   * will be removed, those and any non matches will also be cleared from the change tracking of the store.
   *
   * If the store has filters in effect when the changeset is applied, the following rules will determine how the
   * filtered values are affected:
   * - Among added records, only those that match the filter will be included in the filtered set
   * - Among updated records, those that did not previously match the filter but now do will be added to the filtered set,
   *   and those that did match but no longer do will also remain in the filtered set. This means that new records may
   *   appear in the filtered set as a result of `applyChanges`, but records will not disappear until filters are
   *   re-applied.
   *
   * As an example, consider a store with the following initial state and some operations performed on it:
   *
   * ```javascript
   * // Load some data into the store
   * store.data = [
   *     { id : 1, name : 'Minerva' },
   *     { id : 2, name : 'Mars' },
   *     { id : 3, name : 'Jupiter' }
   * ];
   * // Add a new record. It gets assigned a generated id,
   * // for example 'generated56'
   * store.add({ name : 'Artemis' });
   * // Remove Jupiter
   * store.remove(3);
   * ```
   *
   * After syncing those operations to a custom backend (however you chose to solve it in your application) we might
   * get the following response (see "Transforming a response to the correct format" below if your backend responds
   * in another format):
   *
   * ```javascript
   * const serverResponse = {
   *     added : [
   *         // Added by the backend, will be added locally
   *         { id : 5, name : 'Demeter' }
   *     ],
   *
   *     updated : [
   *         // Will change the name of Minerva -> Athena
   *         { id : 1, name : 'Athena' },
   *         // Will set proper id 4 for Artemis
   *         { $PhantomId : 'generated56', id : 4 }
   *     ],
   *
   *     removed : [
   *         // Confirmed remove of Jupiter
   *         { id : 3 },
   *         // Removed by the backend, Mars will be removed locally
   *         { id : 2 }
   *     ]
   * };
   * ```
   *
   * If that response is then passed to this function:
   *
   * ```javascript
   * store.applyChangeSet(serverResponse);
   * ```
   *
   * The end result will be the following data in the store:
   *
   * ```javascript
   * [
   *     { id : 1, name : 'Athena' }, // Changed name
   *     { id : 4, name : 'Artemis' }, // Got a proper id
   *     { id : 5, name : 'Demeter' } // Added by the backend
   * ]
   * ```
   *
   * ### Phantom ids
   *
   * When a record is created locally, it is always assigned a generated id. That id is called a phantom id (note that
   * it is assigned to the normal id field). When passing the new record to the backend, the id is sent with it. When
   * the backend inserts the record into the database, it (normally) gets a proper id assigned. That id then needs to
   * be passed back in the response, to update the local record with the correct id. Making sure that future updates
   * match the correct row in the database.
   *
   * For example a newly created record should be passed similar to this to the backend (pseudo format, up to the
   * application/backend to decide):
   *
   * ```json
   * {
   *     "added" : {
   *         "id" : "generated79",
   *         "name" : "Hercules",
   *         ...
   *     }
   * }
   * ```
   *
   * For the backend response to be applicable for this function, it should then respond with:
   *
   * ```json
   * {
   *     "updated" : {
   *         {
   *             "$PhantomId" : "generated79",
   *             "id" : 465
   *         }
   *     }
   * }
   * ```
   *
   * (Or, as stated above, it can also be passed in the "added" array. Which ever suits your backend best).
   *
   * This function will then change the id of the local record using the phantom id `generated79` to `465`.
   *
   * ### Transforming a response to the correct format
   *
   * This function optionally accepts a `transformFn`, a function that will be called with the `changes`. It is
   * expected to return a changeset in the format described above (`{ added : [], updated : [], removed : [] }`),
   * which then will be used to apply the changes.
   *
   * Consider the following "non standard" (made up) changeset:
   *
   * ```javascript
   * const changes = {
   *     // Database ids for records previously added locally
   *     assignedIds : {
   *         'phantom1' : 10,
   *         'phantom2' : 15
   *     },
   *     // Ids records removed by the backend
   *     removed : [11, 27],
   *     // Modified records, keyed by id
   *     altered : {
   *         12 : { name : 'Changed' }
   *     },
   *     // New records, keyed by id
   *     inserted : {
   *         20  : { name : 'New' }
   *     }
   * }
   * ```
   *
   * Since it does not match the expected format it has to be transformed:
   *
   * ```javascript
   * store.applyChangeset(changes, ({ assignedIds, inserted, altered, removed }) => ({
   *    // Convert inserted to [{ id : 20, name : 'New' }]
   *    added : Object.entries(inserted).map(([id, data] => ({ id, ...data }),
   *    updated : [
   *        // Convert assignedIds to [{ $PhantomId : 'phantom1', id : 10 }, ...]
   *       ...Object.entries(assignedIds).map(([phantomId, id])) => ({ $PhantomId : phantomId, id }),
   *       // Convert altered to [{ id : 12, name : 'Changed' }]
   *       ...Object.entries(modified).map(([id, data] => ({ id, ...data })
   *    ],
   *    // Convert removed to [{ id : 11 }, ...]
   *    removed : removed.map(id => ({ id }))
   * }));
   * ```
   *
   * The transform function above would output:
   *
   * ```javascript
   * {
   *     added : [
   *         {  id : 20, name : 'New' }
   *     ],
   *     updated : [
   *         { $PhantomId : 'phantom1', id : 10 },
   *         { $PhantomId : 'phantom2', id : 15 },
   *         {  id : 12, name : 'Changed' }
   *     ],
   *     removed : [
   *        { id : 11 },
   *        { id : 12 }
   *     ]
   * }
   * ```
   *
   * And that format can then be applied.
   *
   * @param {Object} changes Changeset to apply to the store, see specification above
   * @param {Function} [transformFn] Optional function used to preprocess a changeset in a different format,
   * should return an object with the format expected by this function (see above)
   * @param {String} [phantomIdField] Field used by the backend when communicating a record being assigned a proper id
   * instead of a phantom id (see above)
   * @privateparam {Boolean} [remote] Set to true to indicate changes are from the remote source. Remote changes have
   * precedence over local.
   * @privateparam {Boolean} [logChanges] Used by CrudManager to be able to revert specific changes later
   * @category CRUD
   */
  applyChangeset(changes, transformFn = null, phantomIdField = "$PhantomId", remote = true, logChanges = false) {
    var _a2, _b, _c, _d;
    const me = this, { added, updated, modified, removed } = (_a2 = transformFn == null ? void 0 : transformFn(changes, me)) != null ? _a2 : changes, altered = (_b = updated != null ? updated : modified) != null ? _b : [], idDataSource = me.modelClass.getFieldDataSource("id"), log = logChanges ? /* @__PURE__ */ new Map() : null, allAdded = [], allAltered = [];
    let rootUpdated = false, modifiedParents = [];
    me._groupVisibleRecordIds = [];
    me.isGrouped && me.forEach((record) => {
      me._groupVisibleRecordIds.push(record.id);
    });
    if ((added == null ? void 0 : added.length) > 0) {
      const toUpdate = [], toAdd = [];
      for (const data of added) {
        if (me.getById((_c = data[phantomIdField]) != null ? _c : ObjectHelper.getPath(data, idDataSource))) {
          toUpdate.push(data);
        } else {
          toAdd.push(data);
        }
      }
      altered.unshift.apply(altered, toUpdate);
      const addedRecords = (_d = me.add(toAdd, false, { orderedParentIndex: { skip: true } })) != null ? _d : [];
      allAdded.push(...addedRecords);
      if (me.tree) {
        for (const record of addedRecords) {
          const { parent } = record;
          if (parent.isRoot) {
            rootUpdated = true;
            modifiedParents = [parent];
            break;
          }
          if (!parent.isRoot && modifiedParents.every((r) => !r.contains(parent))) {
            modifiedParents.push(parent);
          }
        }
      }
      for (const record of addedRecords) {
        log == null ? void 0 : log.set(record.id, record.data);
        record.clearChanges();
      }
    }
    if ((altered == null ? void 0 : altered.length) > 0) {
      for (const data of altered) {
        const phantomId = data[phantomIdField], id = ObjectHelper.getPath(data, idDataSource), record = me.getById(phantomId != null ? phantomId : id);
        if (record) {
          const changes2 = record.applyChangeset(data, phantomIdField, remote);
          if (me.tree && !rootUpdated && modifiedParents.every((r) => !r.contains(record))) {
            if (record.parent.isRoot) {
              rootUpdated = true;
              modifiedParents = [record.parent];
            } else {
              modifiedParents.push(record.parent);
            }
          }
          log == null ? void 0 : log.set(id, changes2);
          allAltered.push(record);
        }
      }
    }
    if ((removed == null ? void 0 : removed.length) > 0) {
      me.applyRemovals(removed);
    }
    if (me.applyChangesetFilterSortTarget === "changes") {
      const parentsModifiedByFilter = me.filterChangeset(allAdded, allAltered);
      modifiedParents.push(...parentsModifiedByFilter);
    }
    me.afterChangesetApplied(modifiedParents);
    me._groupVisibleRecordIds = null;
    return log;
  }
  afterChangesetApplied(modifiedParents) {
    modifiedParents.forEach((parent) => {
      parent.traverse((record) => {
        record.sortOrderedChildren(false, false);
        if (record.children) {
          record.updateChildrenIndices(record.children, "parentIndex", true);
        }
        if (record.unfilteredChildren) {
          record.updateChildrenIndices(record.unfilteredChildren, "unfilteredIndex", true);
        }
      });
    });
  }
  // Apply removals, removing records and updating the `removed` bag to match.
  //
  // Accepts an array of objects containing an `id` property. Records in the store matching an entry in the array
  // will be removed from the store and the `removed` bag. Unmatched entries will be removed from the `removed` bag.
  applyRemovals(removals) {
    const me = this, { removed: removedStash } = me, idDataSource = me.modelClass.idField, toRemove = [];
    for (const removedEntry of removals) {
      const id = ObjectHelper.getPath(removedEntry, idDataSource);
      if (removedStash.includes(id)) {
        removedStash.remove(id);
      } else {
        toRemove.push(id);
      }
    }
    me.remove(toRemove);
    for (const record of toRemove) {
      removedStash.remove(record);
    }
  }
  /**
   * Filters records that have been added/updated as part of a changeset. The `added` and `updated` parameters
   * are arrays of values that have already been added/updated in the Collection's values. This method brings
   * the Collection's `_filteredValues` in sync without performing a full sort or filter, using the following rules:
   *
   * - Added records that do not match the filter are removed from _filteredValues
   *
   * - Updated records that now match the filter are inserted at the correct position in _filteredValues
   *   if they were not formerly included
   *
   * - Updated records that formerly matched the filter, but now do not, are NOT removed from _filteredValues
   *
   * If the collection is sorted, either on its own or via a sort applied at the store level, that sort order is
   * respected when adding items to _filteredValues. If not, items are inserted in the same order they occur in
   * _values.
   *
   * @param {Object[]} added An array of unique values that were added as part of the changeset.
   * @param {Object[]} updated An array of unique values that were updated as part of the changeset.
   * @returns {Object[]} Any records that were added or removed from view, or whose children were modified.
   * @private
   */
  filterChangeset(added, updated) {
    const me = this, {
      isFiltered,
      tree,
      isGrouped,
      filtersFunction
    } = me, storeSortFunction = me.isSorted ? me.createSorterFn(me.sorters) : void 0, {
      allValues,
      addedValues,
      isSorted
    } = me.storage, sorter = storeSortFunction != null || isSorted ? storeSortFunction != null ? storeSortFunction : me.storage.sortFunction : null, modifiedParents = /* @__PURE__ */ new Set();
    if (!isFiltered) {
      return [];
    }
    let trigger = false, groupers;
    if (isGrouped) {
      groupers = me.groupers;
      me.clearGroupers(true);
    }
    if (tree) {
      const nodesToInclude = new Set(updated.filter(filtersFunction));
      for (const matchingAdd of added.filter(filtersFunction)) {
        nodesToInclude.add(matchingAdd);
      }
      nodesToInclude.forEach((node) => node.bubble((ancestor) => nodesToInclude.add(ancestor)));
      nodesToInclude.delete(me.rootNode);
      const nodesToIncludeByParent = ArrayHelper.groupBy(Array.from(nodesToInclude), "parentId");
      for (const siblingsToInclude of Object.values(nodesToIncludeByParent)) {
        const { parent } = siblingsToInclude[0];
        if (parent.unfilteredChildren) {
          parent.children.push(...siblingsToInclude.filter((child) => !parent.children.includes(child)));
          modifiedParents.add(parent);
        }
      }
    } else if (sorter && !isGrouped) {
      const { filteredValues } = me.storage, sortedLength = addedValues ? filteredValues.findLastIndex((value) => !addedValues.has(value)) + 1 : filteredValues.length, sorted = filteredValues.slice(0, sortedLength), updatedMatches = new Set(updated.filter(filtersFunction));
      for (const value of filteredValues) {
        if (updatedMatches.has(value)) {
          updatedMatches.delete(value);
        }
      }
      for (const newMatch of updatedMatches) {
        sorted.push(newMatch);
      }
      sorted.sort(sorter);
      filteredValues.splice(0, sortedLength, ...sorted);
      trigger = true;
    } else {
      const updatedMatches = updated.filter((item) => filtersFunction(item) && !me.storage.includes(item));
      if (updatedMatches.length > 0) {
        me.includeInSubset(allValues, me.storage.filteredValues, updatedMatches);
        trigger = true;
      }
    }
    const nonMatchingAdds = new Set(added.filter((value) => !filtersFunction(value)));
    if (nonMatchingAdds.size > 0) {
      if (tree) {
        for (const addedChild of nonMatchingAdds) {
          ArrayHelper.remove(addedChild.parent.children, addedChild);
          modifiedParents.add(addedChild.parent);
        }
      } else {
        ArrayHelper.remove(me.storage.filteredValues, nonMatchingAdds);
      }
      trigger = true;
    }
    if (groupers) {
      me.group(groupers[0], null, false, true, true);
      trigger = true;
    }
    if (tree && modifiedParents.size > 0) {
      me.storage.replaceValues({
        values: me.collectDescendants(me.rootNode).visible,
        silent: true
      });
    } else if (trigger) {
      me._idMap = null;
      me.trigger("refresh");
    }
    return [...modifiedParents];
  }
  /**
   * Given an array `all`, an array `subset` that is a subset of `all` in the same order, and another array
   * `toInclude` that is a different subset of `all` disjoint with `subset`, add each item from `toInclude`
   * to `subset`, in an order matching the order in `all`. The order of `subset` must match the order of `all`.
   * The order of `toInclude` is unimportant.
   *
   * Modifies `subset` in-place.
   *
   * @param {Array} all An array of unique items (e.g. records)
   * @param {Array} subset An array containing a subset of the items in `all` (same order as `all`)
   * @param {Array} toInclude An array or items from `all` that should be included in `subset` (unordered)
   * @returns {Array} The subset modified in-place.
   * @private
   */
  includeInSubset(all, subset, toInclude) {
    const toIncludeSet = new Set(toInclude);
    let subsetIndex = 0, allIndex = 0, done = toIncludeSet.size === 0;
    while (allIndex < all.length && !done) {
      const subsetItem = subset[subsetIndex];
      let allItem = all[allIndex];
      while (subsetItem !== allItem) {
        if (toIncludeSet.has(allItem)) {
          subset.splice(subsetIndex, 0, allItem);
          subsetIndex++;
          toIncludeSet.delete(allItem);
          done = toIncludeSet.size === 0;
        }
        allItem = all[++allIndex];
      }
      if (toIncludeSet.has(subsetItem)) {
        toIncludeSet.delete(subsetItem);
      }
      if (subsetIndex < subset.length) {
        subsetIndex++;
      }
    }
    return subset;
  }
};

// ../Core/lib/Core/data/mixin/StoreFilter.js
var StoreFilter_default = (Target) => class StoreFilter extends (Target || Base2) {
  static get $name() {
    return "StoreFilter";
  }
  //region Config
  static get defaultConfig() {
    return {
      /**
       * Specify one or more {@link Core/util/CollectionFilter} config objects to apply initially.
       *
       * For example:
       *
       * ```javascript
       *  // Configure the store to filter in clients over the age of 30
       *  new Store({
       *      ...,
       *      filters : [{
       *          property : 'age',
       *          value    : 30,
       *          operator : '>'
       *      }],
       *      ...
       *  })
       * ```
       *
       * or:
       *
       * ```javascript
       *  // Configure the store to filter based on a complex operation
       *  new Store({
       *      ...,
       *      filters : [{
       *          filterBy(record) {
       *              // Return true or false for filtering in or out
       *              return shouldClientBeVisible(record);
       *          }
       *      }],
       *      ...
       *  })
       * ```
       *
       * @config {CollectionFilterConfig|CollectionFilterConfig[]}
       * @category Filtering
       */
      filters: null,
      /**
       * Specify true to reapply filters when a record is added to the store.
       * @config {Boolean}
       * @default
       * @category Filtering
       */
      reapplyFilterOnAdd: false,
      /**
       * Specify true to reapply filters when a record is updated in the store.
       * @config {Boolean}
       * @default
       * @category Filtering
       */
      reapplyFilterOnUpdate: false
    };
  }
  //endregion
  //region Events
  /**
   * Fired after applying filters to the store
   * @event filter
   * @param {Core.data.Store} source This Store
   * @param {Core.util.Collection} filters Filters used by this Store
   * @param {Core.data.Model[]} removed The records which were filtered out by the action.
   * @param {Core.data.Model[]} added The records which were filtered back in by the action.
   * @param {Core.data.Model[]} records Filtered records
   */
  //endregion
  //region Properties
  set reapplyFilterOnAdd(enable) {
    this.storage.autoFilter = enable;
  }
  get reapplyFilterOnAdd() {
    return this.storage.autoFilter;
  }
  /**
   * Currently applied filters. A collection of {@link Core.util.CollectionFilter} instances.
   * @type {Core.util.Collection}
   * @readonly
   * @category Sort, group & filter
   */
  set filters(filters) {
    const me = this, collection = me.filters;
    collection.clear();
    me._filtersFunction = null;
    if (filters) {
      if (filters.constructor.name === "Object") {
        for (const f of Object.entries(filters)) {
          if (f[0] === "filterBy" && typeof f[1] === "function") {
            collection.add(new CollectionFilter({
              filterBy: f[1]
            }));
          } else {
            collection.add(new CollectionFilter(f[1].constructor.name === "Object" ? Object.assign({
              property: f[0]
            }, f[1]) : {
              property: f[0],
              value: f[1]
            }));
          }
        }
      } else if (Array.isArray(filters)) {
        collection.add(...filters.map((filterConfig) => {
          if (filterConfig instanceof CollectionFilter) {
            return filterConfig;
          }
          return new CollectionFilter(filterConfig);
        }));
      } else if (filters.isCollection) {
        collection.add(...filters.values);
      } else {
        collection.add(new CollectionFilter({
          filterBy: filters
        }));
      }
      collection.forEach((item) => item.owner = me);
    }
  }
  get filters() {
    return this._filters || (this._filters = new Collection({ extraKeys: ["property"] }));
  }
  set filtersFunction(filtersFunction) {
    this._filtersFunction = filtersFunction;
  }
  get filtersFunction() {
    const me = this, { filters, isGrouped } = me;
    if (!me._filtersFunction) {
      if (filters.count) {
        const generatedFilterFunction = CollectionFilter.generateFiltersFunction(filters);
        me._filtersFunction = (candidate) => {
          if (isGrouped && candidate.isSpecialRow) {
            return candidate.groupChildren.some(generatedFilterFunction);
          }
          return generatedFilterFunction(candidate);
        };
      } else {
        me._filtersFunction = FunctionHelper.returnTrue;
      }
    }
    return me._filtersFunction;
  }
  /**
   * Check if store is filtered
   * @property {Boolean}
   * @readonly
   * @category Sort, group & filter
   */
  get isFiltered() {
    return this.filters.values.some((filter2) => !filter2.disabled);
  }
  //endregion
  traverseFilter(record) {
    const me = this, hitsCurrent = !record.isRoot && me.filtersFunction(record), children = record.unfilteredChildren || record.children;
    if (!children || !children.length) {
      return hitsCurrent;
    }
    if (!record.unfilteredChildren) {
      record.unfilteredChildren = record.children.slice();
    }
    record.children = record.unfilteredChildren.filter((r) => {
      return me.traverseFilter(r);
    });
    record.updateChildrenIndices(record.unfilteredChildren, "unfilteredIndex", true);
    record.updateChildrenIndices(record.children, "parentIndex", true);
    return hitsCurrent || Boolean(record.children.length);
  }
  traverseClearFilter(record) {
    const me = this;
    if (record.unfilteredChildren) {
      record.children = record.orderedChildren.slice();
      record.unfilteredChildren = null;
    }
    if (record.children) {
      record.children.forEach((r) => me.traverseClearFilter(r));
      record.updateChildrenIndices(record.children, "parentIndex", true);
    }
  }
  get latestFilterField() {
    return this.filters.last ? this.filters.last.property : null;
  }
  /**
   * Adds a single filter to the {@link #config-filters} collection. By default, filters are reevaluated
   * and a Store change event fired.
   *
   * If the `silent` parameter is passed as `true`, multiple filters can be added without causing data changes.
   *
   * When the filters are as required, call {@link #function-filter} with no parameters
   * to apply the filters to the store.
   *
   * @param {CollectionFilterConfig|Function} newFilter A {@link Core.util.CollectionFilter filter} config,
   * or a function to use for filtering.
   * @param {Boolean} [silent] Pass `true` to *not* refilter the store immediately. Such as when
   * adding multiple filters.
   * @returns {Core.util.CollectionFilter} The Filter instance that was added.
   * @returns {Promise|Core.util.CollectionFilter} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method
   * returns Collection filter inside a `Promise` which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  addFilter(filter2, silent = false) {
    const me = this;
    filter2 = filter2 instanceof CollectionFilter ? filter2 : new CollectionFilter(filter2);
    filter2.owner = me;
    me.filters.add(filter2);
    if (!silent) {
      if (me.remoteFilter) {
        return me.filter().then(() => filter2);
      } else {
        me.filter();
      }
    }
    return filter2;
  }
  /**
   * Filters the store by **adding** the specified filter(s) to the existing filters collection applied to this Store.
   * If a filter has an {@link Core.util.CollectionFilter#config-id id} specified,
   * or a {@link Core.util.CollectionFilter#config-property property} specified,
   * it will search for corresponding filter(s) in the existing filters first and replace it with a new filter.
   * **It will not remove other filters applied to the store!**
   *
   * To **add** a new filter:
   * ```
   * // Filter using simple object
   * store.filter({
   *     property : 'age',
   *     operator : '>',
   *     value    : 90
   * });
   *
   * // Filter using function
   * store.filter(r => r.age < 90);
   *
   * // Filter using a named filter as a function
   * store.filter({
   *     id : 'my-filter',
   *     filterBy : record => record.score > 10
   * });
   * ```
   *
   * To **remove** a specific filter, but keep other filters applied
   * ```
   * // Remove by filter `id` or `property`. Filter `id` defaults to the `property` name.
   * store.removeFilter('age');
   * store.removeFilter('my-filter');
   * ```
   *
   * To **replace** all existing filters with a new filter
   * ```
   * // Remove all filters and filter using simple object
   * store.filter({
   *     filters : {
   *         property : 'age',
   *         operator : '<',
   *         value    : 90
   *     },
   *     replace : true
   * });
   *
   * // Remove all filters and filter using function
   * store.filter({
   *     filters : r => r.age > 90,
   *     replace : true
   * });
   *
   * // Remove all filters and filter using a named filter as a function
   * store.filter({
   *     filters : {
   *         id : 'my-filter',
   *         filterBy : record => record.score > 10
   *     },
   *     replace : true
   * });
   * ```
   *
   * Basically filters replacing is an equivalent of having two sequenced calls:
   * {@link #function-clearFilters clearFilters} and {@link #function-filter filter}.
   *
   * Call without arguments to reapply filters.
   * ```
   * // Re-filter the store
   * store.filter();
   * ```
   *
   * @param {Object|CollectionFilterConfig|CollectionFilterConfig[]|Function} newFilters
   *        A {@link Core.util.CollectionFilter filter} config,
   *        or an array of {@link Core.util.CollectionFilter filter} configs,
   *        or a function to use for filtering,
   *        or a special object like: ```{ replace : true, filters : newFilters }```
   * @param {Boolean} [newFilters.replace]
   *        A flag, indicating whether or not the previous filters should be removed.
   * @param {Boolean} [newFilters.silent]
   *        Set as true to not fire events. UI will not be informed about the changes.
   * @param {CollectionFilterConfig|CollectionFilterConfig[]|Function} [newFilters.filters]
   *        If `newFilters` is an object and `replace` property is defined in the `newFilters`,
   *        it means that special object is used and real filter configuration must be nested down to this `filters` property.
   *        It can be:
   *        A {@link Core.util.CollectionFilter filter} config,
   *        or an array of {@link Core.util.CollectionFilter filter} configs,
   *        or a function to use for filtering.
   * @fires filter
   * @fires change
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method returns Promise
   * which is resolved after data is loaded from remote server, otherwise it returns null value
   * @async
   * @category Sort, group & filter
   */
  filter(newFilters) {
    const me = this;
    let silent = false, internal;
    if (newFilters) {
      let fieldType = typeof newFilters;
      if (fieldType === "object") {
        if ("silent" in newFilters || "replace" in newFilters || newFilters.filters) {
          silent = newFilters.silent;
          if (newFilters.replace) {
            me.clearFilters(newFilters.filters.length === 0);
          }
          internal = newFilters.internal;
          newFilters = newFilters.filters;
          fieldType = typeof newFilters;
        }
      }
      if (newFilters) {
        const wasFiltered = me.isFiltered;
        me.isConfiguring = true;
        if (Array.isArray(newFilters)) {
          newFilters.forEach((f) => me.addFilter(f, true), me);
        } else if (fieldType === "function") {
          const filter2 = new CollectionFilter(newFilters);
          filter2.internal = internal;
          me.addFilter(filter2, true);
        } else if (fieldType === "string") {
          me.addFilter({
            property: newFilters,
            value: arguments[1]
          }, true);
        } else {
          me.addFilter(newFilters, true);
        }
        me.isConfiguring = false;
        if (!me.isFiltered && !wasFiltered) {
          return null;
        }
      }
    }
    me.filtersFunction = null;
    const result = me.performFilter(silent);
    me._idMap = null;
    return result;
  }
  /**
   * Perform filtering according to the {@link #property-filters} Collection.
   * This is the internal implementation which is overridden in {@link Core.data.AjaxStore} and
   * must not be overridden.
   * @private
   */
  performFilter(silent) {
    const me = this, { storage, filters, rootNode } = me, oldCount = me.count;
    me.trigger("beforeFilter", { filters });
    let added, removed;
    if (me.tree) {
      const oldDataset = storage.values;
      if (me.isFiltered) {
        me.traverseFilter(rootNode);
      } else {
        me.traverseClearFilter(rootNode);
      }
      const newDataset = me.collectDescendants(rootNode).visible;
      storage.replaceValues({
        values: newDataset,
        silent: true
      });
      const delta = ArrayHelper.delta(newDataset, oldDataset, true);
      added = delta.toAdd;
      removed = delta.toRemove;
    } else {
      storage.ion({
        change({ removed: r, added: a }) {
          removed = r;
          added = a;
        },
        once: true
      });
      if (me.isFiltered) {
        me.isGrouped && me.includeCollapsed();
        storage.addFilter({
          id: "primary-filter",
          filterBy: me.filtersFunction
        });
        me.isGrouped && me.excludeCollapsed();
      } else {
        storage.filters.clear();
      }
    }
    me.afterPerformFilter(silent || me.isRemoteDataLoading ? null : {
      action: "filter",
      filters,
      oldCount,
      added,
      removed,
      records: me.storage.values
    });
  }
  afterPerformFilter(event) {
    this.resetRelationCache();
    if (event) {
      this.triggerFilterEvent(event);
    }
  }
  // Used from filter() and StoreCRUD when reapplying filters
  triggerFilterEvent(event) {
    this.trigger("filter", event);
    if (!this.remoteFilter) {
      this.trigger("refresh", event);
      this.trigger("change", event);
    }
  }
  /**
   * *Adds* a function used to filter the store. Alias for calling `filter(fn)`. Return `true` from the function to
   * include record in filtered set
   *
   * ```javascript
   * store.filterBy(record => record.age > 25 && record.name.startsWith('A'));
   * ```
   *
   * @param {Function} fn Function used to test records
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  filterBy(fn2) {
    return this.filter(fn2);
  }
  /**
   * Removes the passed filter, or the filter by the passed ID from the {@link #config-filters} collection.
   * By default, filters are reevaluated and a Store change event fired.
   *
   * If the `silent` parameter is passed as `true`, multiple filters can be removed without causing data changes.
   *
   * When the filters are as required, call {@link #function-filter} with no parameters
   * to apply the filters to the store.
   *
   * ```javascript
   * // Only view top priority events
   * myEventStore.filter({
   *     id       : 'priorityFilter',
   *     property : 'priority',
   *     value    : 1,
   *     operator : '='
   * });
   *
   * // That individual filter can be removed like this
   * myEventStore.removeFilter('priorityFilter');
   *
   * // Add named filter as a function
   * store.filter({
   *     id : 'my filter',
   *     filterBy : record => record.score > 10
   * });
   *
   * // Remove named filter function
   * store.removeFilter('my filter');
   * ```
   *
   * @param {String|Core.util.CollectionFilter} idOrInstance Filter to remove, or ID of the filter to remove. By default,
   * filters are reevaluated and a change event fired.
   * @param {Boolean} [silent] Pass `true` to *not* refilter the store immediately. Such as when
   * removing multiple filters.
   * @returns {Promise|Core.util.CollectionFilter} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method
   * returns Collection filter inside a `Promise` which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  removeFilter(idOrInstance, silent = false) {
    const me = this, filter2 = idOrInstance instanceof CollectionFilter ? idOrInstance : me.filters.get(idOrInstance);
    if (filter2) {
      me.filters.remove(filter2);
      me._filtersFunction = null;
      if (!silent) {
        if (me.remoteFilter) {
          return me.filter().then(() => filter2);
        } else {
          me.filter();
        }
      }
      return filter2;
    }
  }
  /**
   * Removes all filters from the store.
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  clearFilters(apply = true) {
    this.filters.remove(this.filters.values.filter((f) => !f.internal));
    if (apply) {
      return this.filter();
    }
  }
  convertFilterToString(field2) {
    const filter2 = this.filters.getBy("property", field2);
    return filter2 && !filter2.filterBy ? String(filter2) : "";
  }
  doDestroy() {
    var _a2;
    (_a2 = this._filters) == null ? void 0 : _a2.destroy();
    super.doDestroy();
  }
};

// ../Core/lib/Core/data/mixin/StoreGroup.js
var resortActions = {
  add: 1,
  replace: 1
};
var StoreGroup_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base2) {
    static get properties() {
      return {
        collapsedGroups: /* @__PURE__ */ new Set()
      };
    }
    //endregion
    //region Init
    construct(config) {
      super.construct(config);
      this.ion({ change: "onDataChanged", thisObj: this });
    }
    updateGroupers(groupers) {
      this.setGroupers(groupers);
    }
    /**
     * Set groupers.
     * @param {Grouper[]} groupers Array of groupers to apply to store
     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns
     * `Promise` which is resolved after data is loaded from remote server, otherwise it returns `null`
     * @async
     * @category Sort, group & filter
     */
    setGroupers(groupers, options = null) {
      const me = this, { storage } = me;
      let result;
      if (groupers == null ? void 0 : groupers.length) {
        me._groupers = groupers;
      } else if (me.groupers) {
        delete me._groupers;
        me.includeCollapsed();
        storage.replaceValues({
          values: me.removeHeadersAndFooters(storage._values),
          filteredValues: storage.isFiltered ? me.removeHeadersAndFooters(storage._filteredValues) : null,
          silent: true
        });
        result = me.group(null, null, null, false, options == null ? void 0 : options.silent);
      }
      me._idMap = null;
      return result;
    }
    // Collects group headers/footers on the fly. Not used in any performance sensitive code, but if that need arises
    // it should be cached and invalidated on record remove, add, update, grouping changes, filter and sorting...
    get groupRecords() {
      const groupRecords = [];
      if (this.isGrouped) {
        for (const record of this) {
          if (record.isSpecialRow) {
            groupRecords.push(record);
          }
        }
      }
      return groupRecords;
    }
    get unfilteredGroupRecords() {
      var _a3;
      const me = this;
      if (me.isGrouped) {
        const { generation } = me.storage;
        if (((_a3 = me._unfilteredGroupRecords) == null ? void 0 : _a3.generation) !== generation) {
          me._unfilteredGroupRecords = me.storage.allValues.filter((r) => r.isSpecialRow);
          me._unfilteredGroupRecords.generation = generation;
        }
      }
      return me._unfilteredGroupRecords || [];
    }
    /**
     * Returns group header record for the passed record or last group header in the store
     * @param {Core.data.Model} [targetRecord]
     * @param {Boolean} [ignoreFilter] Pass true to search in the complete collection
     * @returns {Core.data.Model}
     * @internal
     */
    getGroupHeaderForRecord(targetRecord, ignoreFilter = false) {
      if (this.isGrouped) {
        let result;
        const collection = ignoreFilter ? this.storage._values : this.storage.values;
        for (const record of collection) {
          if (record.isGroupHeader) {
            if (!targetRecord) {
              result = record;
            } else if (record === targetRecord || record.unfilteredGroupChildren.includes(targetRecord)) {
              result = record;
              break;
            }
          }
        }
        return result;
      }
    }
    // Temporarily include records from collapsed groups, for example prior to filtering
    includeCollapsed() {
      for (const groupId of this.collapsedGroups) {
        this.expand(this.getById(groupId), false);
      }
    }
    // Exclude records in collapsed groups, intended to be used after a call to includeCollapsed()
    excludeCollapsed() {
      for (const groupId of this.collapsedGroups) {
        this.collapse(this.getById(groupId));
      }
    }
    onDataChange({ source: storage, action, removed }) {
      var _a3;
      const me = this, { groupers } = me;
      if (groupers) {
        if (groupers.length) {
          if (action === "splice" && (removed == null ? void 0 : removed.length) || action === "move") {
            storage.replaceValues({
              ...me.prepareGroupRecords(),
              silent: true
            });
          }
        } else {
          storage.replaceValues({
            values: me.removeHeadersAndFooters(storage._values),
            filteredValues: storage.isFiltered ? me.removeHeadersAndFooters(storage._filteredValues) : null,
            silent: true
          });
        }
      }
      (_a3 = super.onDataChange) == null ? void 0 : _a3.call(this, ...arguments);
    }
    move(records, beforeRecord) {
      const me = this;
      if (me.isGrouped && !me.tree) {
        let prevRecord = beforeRecord;
        if (beforeRecord == null ? void 0 : beforeRecord.isSpecialRow) {
          prevRecord = me.getPrev(beforeRecord, false, false);
          if (!prevRecord) {
            return;
          }
        }
        const targetGroupHeader = me.getGroupHeaderForRecord(prevRecord), groupField = me.groupers[0].field, newGroupValue = targetGroupHeader.meta.groupRowFor, { reapplyFilterOnUpdate } = me;
        me.reapplyFilterOnUpdate = false;
        me.beginBatch();
        records.forEach((record) => record.setValue(groupField, newGroupValue));
        me.endBatch();
        me.reapplyFilterOnUpdate = reapplyFilterOnUpdate;
        if (me.isFiltered && (beforeRecord == null ? void 0 : beforeRecord.isSpecialRow)) {
          const { unfilteredGroupRecords } = me, index = unfilteredGroupRecords.indexOf(targetGroupHeader);
          beforeRecord = unfilteredGroupRecords[index + 1];
        }
      }
      super.move(records, beforeRecord);
    }
    // private function that collapses on the data level
    collapse(groupRecord) {
      if (groupRecord && !groupRecord.meta.collapsed) {
        this.excludeGroupRecords(groupRecord);
        groupRecord.meta.collapsed = true;
        this.collapsedGroups.add(groupRecord.id);
        this.trigger("toggleGroup", { groupRecord, collapse: true });
        return true;
      }
      return false;
    }
    // private function that expands on the data level
    expand(groupRecord, updateMap = true) {
      if (groupRecord == null ? void 0 : groupRecord.meta.collapsed) {
        this.includeGroupRecords(groupRecord);
        groupRecord.meta.collapsed = false;
        updateMap && this.collapsedGroups.delete(groupRecord.id);
        updateMap && this.trigger("toggleGroup", { groupRecord, collapse: false });
        return true;
      }
      return false;
    }
    removeHeadersAndFooters(records) {
      return records.filter((r) => {
        if (r.isSpecialRow) {
          this.unregister(r);
          return false;
        } else {
          return true;
        }
      });
    }
    prepareGroupRecords(sorter) {
      const me = this, {
        isFiltered,
        reapplyFilterOnUpdate,
        startGroupsCollapsed
      } = me, toCollapse = me.collapsedGroups, { allValues } = me.storage, toExpand = [], visibleRecordsIds = me._groupVisibleRecordIds || [], isVisible = (record) => {
        const matchesFilter = !isFiltered || me.filtersFunction(record);
        return reapplyFilterOnUpdate ? matchesFilter : matchesFilter || visibleRecordsIds.includes(record.id);
      };
      for (const record of allValues) {
        if (record.isGroupHeader && (record.meta.collapsed || toCollapse.has(record.id))) {
          toCollapse.add(record.id);
          toExpand.push(record);
        }
      }
      for (const record of toExpand) {
        me.includeGroupRecords(record);
      }
      const records = me.removeHeadersAndFooters(me.storage._values);
      if (sorter) {
        records.sort(sorter);
      }
      if (isFiltered) {
        me.filtersFunction = null;
      }
      const groupedRecords = [], field2 = me.groupers[0].field;
      let curGroup = null, curGroupRecord = null, childCount = 0;
      function addFooter() {
        const val = curGroupRecord.meta.groupRowFor, id = `group-footer-${typeof val === "number" ? val : StringHelper.createId(val)}`, footer = me.getById(id) || new me.modelClass({ id }, me, {
          specialRow: true,
          groupFooterFor: val,
          groupRecord: curGroupRecord
        });
        footer.stores = [me];
        me.register(footer);
        footer.groupChildren = curGroupRecord.groupChildren;
        if (!curGroupRecord.meta.collapsed) {
          groupedRecords.push(footer);
        }
        me.allRecords.push(footer);
        curGroupRecord.groupChildren.push(footer);
        curGroupRecord.unfilteredGroupChildren.push(footer);
        childCount++;
        return footer;
      }
      records.forEach((record) => {
        var _a3;
        const fieldValue = record.getValue(field2), val = fieldValue == void 0 ? "__novalue__" : fieldValue, id = `group-header-${typeof val === "number" ? val : StringHelper.createId(val)}`;
        if (((_a3 = record.unfilteredGroupChildren) == null ? void 0 : _a3.length) === 0) {
          me.unregister(record);
          return;
        }
        if (!ObjectHelper.isEqual(val, curGroup)) {
          if (curGroupRecord) {
            if (me.useGroupFooters) {
              addFooter(curGroupRecord);
            }
            curGroupRecord.meta.childCount = childCount;
          }
          curGroupRecord = me.getById(id);
          if (!curGroupRecord) {
            curGroupRecord = new me.modelClass({ id }, me, {
              specialRow: true,
              groupRowFor: val,
              groupField: field2
            });
            if (startGroupsCollapsed) {
              toCollapse.add(id);
              me.startGroupsCollapsed = false;
            }
          }
          curGroupRecord.meta.collapsed = toCollapse.has(id);
          curGroupRecord.stores = [me];
          me.register(curGroupRecord);
          curGroupRecord.groupChildren = [];
          curGroupRecord.unfilteredGroupChildren = [];
          groupedRecords.push(curGroupRecord);
          me.allRecords.push(curGroupRecord);
          curGroup = val;
          childCount = 0;
        }
        record.instanceMeta(me.id).groupParent = curGroupRecord;
        if (!toCollapse.has(id)) {
          groupedRecords.push(record);
        }
        if (isVisible(record)) {
          curGroupRecord.groupChildren.push(record);
          childCount++;
        }
        curGroupRecord.unfilteredGroupChildren.push(record);
      });
      if (curGroupRecord) {
        if (me.useGroupFooters) {
          addFooter();
        }
        curGroupRecord.meta.childCount = childCount;
      }
      me._idMap = null;
      const result = {
        values: groupedRecords
      };
      if (isFiltered) {
        result.filteredValues = groupedRecords.filter(isVisible);
      }
      return result;
    }
    //endregion
    //region Group and ungroup
    /**
     * Is store currently grouped?
     * @property {Boolean}
     * @readonly
     * @category Sort, group & filter
     */
    get isGrouped() {
      var _a3;
      return Boolean((_a3 = this.groupers) == null ? void 0 : _a3.length);
    }
    /**
     * Group records, either by replacing current sorters or by adding to them.
     * A grouper can specify a **_custom sorting function_** which will be called with arguments (recordA, recordB).
     * Works in the same way as a standard array sorter, except that returning `null` triggers the stores
     * normal sorting routine. Grouped store **must** always be sorted by the same field.
     *
     * ```javascript
     * // simple grouper
     * store.group('city');
     *
     * // grouper as object, descending order
     * store.group({ field : 'city', ascending : false });
     *
     * // using custom sorting function
     * store.group({
     *     field : 'city',
     *     fn : (recordA, recordB) => {
     *         // apply custom logic, for example:
     *         return recordA.city.length < recordB.city.length ? -1 : 1;
     *     }
     * });
     * ```
     *
     * @param {String|Object} field Field to group by.
     * Can also be a config containing a field to group by and a custom sorting function called `fn`.
     * @param {Boolean} [ascending] Sort order of the group titles
     * @param {Boolean} [add] Add a grouper (true) or use only this grouper (false)
     * @param {Boolean} [performSort] Trigger sort directly, which does the actual grouping
     * @param {Boolean} [silent] Set as true to not fire events
     * @category Sort, group & filter
     * @fires group
     * @fires refresh
     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
     * which is resolved after data is loaded from remote server, otherwise it returns `null`
     * @async
     */
    group(field2, ascending, add = false, performSort = true, silent = false) {
      var _a3, _b;
      const me = this;
      let newGrouper, fn2;
      if (field2 && typeof field2 === "object") {
        ascending = field2.ascending;
        fn2 = field2.fn;
        field2 = field2.field;
      }
      if (add) {
        me.groupers.push(newGrouper = {
          field: field2,
          ascending,
          complexMapping: field2.includes(".")
        });
      } else if (field2) {
        if (ascending == null) {
          ascending = ((_a3 = me.groupInfo) == null ? void 0 : _a3.field) === field2 && ((_b = me.groupInfo) == null ? void 0 : _b.fn) === fn2 ? !me.groupInfo.ascending : true;
        }
        me.groupInfo = newGrouper = {
          field: field2,
          ascending,
          fn: fn2,
          complexMapping: field2.includes(".")
        };
        me.groupers = [me.groupInfo];
      }
      if (newGrouper) {
        const { prototype: prototype2 } = me.modelClass;
        if (newGrouper.complexMapping && !Object.prototype.hasOwnProperty.call(prototype2, field2)) {
          Object.defineProperty(prototype2, field2, {
            get() {
              return ObjectHelper.getPath(this, field2);
            }
          });
        }
      }
      if (performSort !== false) {
        if (me.remoteSort && !me.isRemoteDataLoading) {
          return me.sort(null, null, false, true).then(() => me.onAfterGrouping(silent));
        } else {
          me.sort(null, null, false, true);
        }
      }
      me.onAfterGrouping(silent);
    }
    onAfterGrouping(silent) {
      if (silent) {
        return;
      }
      const me = this, groupers = me.groupers || [];
      me.trigger("group", { isGrouped: me.isGrouped, groupers, records: me.storage.values });
      me.trigger("refresh", { action: "group", isGrouped: me.isGrouped, groupers, records: me.storage.values });
    }
    // Internal since UI does not support multi grouping yet
    /**
     * Add a grouping level (a grouper).
     * @param {String} field Field to group by
     * @param {Boolean} ascending Group direction
     * @category Sort, group & filter
     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
     * which is resolved after data is loaded from remote server, otherwise it returns `null`
     * @async
     * @internal
     */
    addGrouper(field2, ascending = true) {
      return this.group(field2, ascending, true);
    }
    // Internal since UI does not support multi grouping yet
    /**
     * Removes a grouping level (a grouper)
     * @param {String} field Grouper to remove
     * @category Sort, group & filter
     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
     * which is resolved after data is loaded from remote server, otherwise it returns `null`
     * @async
     * @internal
     */
    removeGrouper(field2) {
      const me = this, { groupers } = me;
      if (!groupers) {
        return;
      }
      const index = groupers.findIndex((grouper) => grouper.field === field2);
      if (index > -1) {
        groupers.splice(index, 1);
        if (!groupers.length) {
          return me.clearGroupers();
        } else {
          return me.group();
        }
      }
    }
    /**
     * Removes all groupers, turning store grouping off.
     * @privateparam {Boolean} [silent=false] Pass true to suppress events.
     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
     * which is resolved after data is loaded from remote server, otherwise it returns `null`
     * @async
     * @category Sort, group & filter
     */
    clearGroupers(silent = false) {
      return this.setGroupers(null, { silent });
    }
    //endregion
    //region Get and check
    /**
     * Check if a record belongs to a certain group (only for the first grouping level)
     * @param {Core.data.Model} record The Record
     * @param {*} groupValue The group value
     * @returns {Boolean} True if the record belongs to the group, otherwise false
     * @category Sort, group & filter
     */
    isRecordInGroup(record, groupValue) {
      var _a3;
      if (!this.isGrouped) {
        return null;
      }
      const groupField = (_a3 = this.groupers[0]) == null ? void 0 : _a3.field;
      return record.getValue(groupField) === groupValue && !record.isSpecialRow;
    }
    isInCollapsedGroup(record) {
      const parentGroupRec = record.instanceMeta(this).groupParent;
      return parentGroupRec == null ? void 0 : parentGroupRec.meta.collapsed;
    }
    /**
     * Returns all records in the group with specified groupValue.
     * @param {*} groupValue
     * @returns {Core.data.Model[]} Records in specified group or null if store not grouped
     * @category Sort, group & filter
     */
    getGroupRecords(groupValue) {
      if (!this.isGrouped) {
        return null;
      }
      return this.storage.values.filter((record) => this.isRecordInGroup(record, groupValue));
    }
    /**
     * Get all group titles.
     * @returns {String[]} Group titles
     * @category Sort, group & filter
     */
    getGroupTitles() {
      if (!this.isGrouped) {
        return null;
      }
      return this.getDistinctValues(this.groupers[0].field);
    }
    //endregion
    onDataChanged({ changes, action }) {
      if (this.isGrouped && // If an action flagged as requiring resort is performed...
      (!changes && resortActions[action] || // ...or if the group field has changes...
      changes && this.groupers.some((grouper) => grouper.field in changes))) {
        this.sort();
      }
    }
    /**
     * Adds or removes records in a group from storage. Used when expanding/collapsing groups.
     * @private
     * @param {Core.data.Model} groupRecord Group which records should be added or removed
     * @param {Boolean} include Include (true) or exclude (false) records
     * @category Grouping
     */
    internalIncludeExcludeGroupRecords(groupRecord, include) {
      const me = this, index = me.indexOf(groupRecord), allIndex = me.allIndexOf(groupRecord), { id: mapId, storage } = me, {
        _filteredValues,
        _values
      } = storage, {
        meta,
        groupChildren,
        unfilteredGroupChildren
      } = groupRecord;
      if (allIndex === -1 || meta.collapsed && !include || !meta.collapsed && include) {
        return;
      }
      unfilteredGroupChildren.forEach(
        (child) => child.instanceMeta(mapId).hiddenByCollapse = !include
      );
      if (include) {
        if (_filteredValues) {
          _filteredValues.splice(index + 1, 0, ...groupChildren.filter((r) => !me.isAvailable(r)));
        }
        storage._values.splice(allIndex + 1, 0, ...unfilteredGroupChildren.filter((r) => !me.isAvailable(r)));
      } else {
        if (_filteredValues) {
          _filteredValues.splice(index + 1, groupChildren.length);
        }
        _values.splice(allIndex + 1, unfilteredGroupChildren.length);
      }
      storage._indicesInvalid = true;
      me._idMap = null;
    }
    /**
     * Removes records in a group from storage. Used when collapsing a group.
     * @private
     * @param groupRecord Group which records should be removed
     * @category Grouping
     */
    excludeGroupRecords(groupRecord) {
      this.internalIncludeExcludeGroupRecords(groupRecord, false);
    }
    /**
     * Adds records in a group to storage. Used when expanding a group.
     * @private
     * @param groupRecord Group which records should be added
     * @category Grouping
     */
    includeGroupRecords(groupRecord) {
      this.internalIncludeExcludeGroupRecords(groupRecord, true);
    }
    /**
     * Collects all group headers + children, whether expanded or not
     * @private
     * @param {Boolean} allRecords True to include filtered out records
     * @param {Boolean} includeHeaders True to also include group headers
     * @returns {Core.data.Model[]}
     */
    collectGroupRecords(allRecords, includeHeaders = true) {
      const records = allRecords ? this.storage.allValues : this.storage.values;
      return records.reduce((records2, record) => {
        if (record.isSpecialRow) {
          if (includeHeaders && !record.isGroupFooter) {
            records2.push(record);
          }
          if (record.isGroupHeader) {
            records2.push.apply(records2, record.groupChildren);
          }
        }
        return records2;
      }, []);
    }
  }, __publicField(_a2, "$name", "StoreGroup"), //region Config
  __publicField(_a2, "configurable", {
    /**
     * Currently used groupers.
     * To set groupers when remote sorting is enabled by {@link Core/data/AjaxStore#config-sortParamName} you should
     * use {@link #function-setGroupers} instead to be able to wait for the operation to finish.
     * @member {Grouper[]} groupers
     * @category Sort, group & filter
     */
    /**
     * Initial groupers, specify to have store grouped automatically after initially setting data
     * @config {Grouper[]}
     * @category Common
     */
    groupers: null,
    useGroupFooters: false,
    /**
     * To have all groups __initially loaded__ start collapsed, configure this as `true`.
     *
     * Note that this only affects the initial load of the store. Subsequent reloads maintain
     * current group state where possible.
     * @config {Boolean}
     * @default false
     * @category Advanced
     */
    startGroupsCollapsed: null
  }), _a2;
};

// ../Core/lib/Core/data/mixin/StoreProxy.js
var StoreProxy_default = (Target) => class StoreProxy extends (Target || Base2) {
  static get configurable() {
    return {
      /**
       * Allow object like interaction with the Store. For example:
       *
       * ```javascript
       * const store = new Store({
       *    objectify : true,
       *    data      : [
       *        { id : 'batman', name : 'Bruce' }
       *    ]
       * });
       *
       * // retrieve using id as property
       * const record = store.batman;
       *
       * // add as property
       * store.superman = { name : 'Clark' };
       *
       * // delete to remove
       * delete store.batman;
       * ``
       *
       * @config {Boolean}
       * @default false
       */
      objectify: null
    };
  }
  initProxy() {
    if (!globalThis.Proxy) {
      throw new Error("Proxy not supported");
    }
    const proxy = new Proxy(this, {
      // Support getting records using `store[id/index]
      get(target, property) {
        if (property in target) {
          return target[property];
        }
        if (property === "$store") {
          return target;
        }
        let record = target.getById(property);
        if (!record && !isNaN(parseInt(property))) {
          record = target.getAt(parseInt(property));
        }
        return record;
      },
      // Support adding/replacing records using `store.id = { ...data }`
      set(target, property, value) {
        if (property in target || target.isDestroying) {
          target[property] = value;
        } else {
          target.add({ [target.modelClass.idField]: property, ...value });
        }
        return true;
      },
      // Support deleting records using `delete store.id`
      deleteProperty(target, property) {
        if (target.isDestroying) {
          delete target[property];
          return true;
        }
        return Boolean(target.remove(property).length);
      },
      // Support `id in store`
      has(target, property) {
        if (property in target) {
          return true;
        }
        if (property.startsWith("{") && property.endsWith("}")) {
          const data = StringHelper.safeJsonParse(property);
          property = data == null ? void 0 : data.id;
        }
        return target.includes(property);
      }
    });
    return proxy;
  }
};

// ../Core/lib/Core/data/mixin/StoreRelation.js
var StoreRelation_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base2) {
    //region Init
    /**
     * Initialized relations, called from constructor
     * @private
     */
    initRelations(reset) {
      const me = this, relations = me.modelClass.exposedRelations;
      if (reset && me.modelRelations) {
        me.modelRelations.forEach((relation) => {
          var _a3;
          return (_a3 = relation.storeDetacher) == null ? void 0 : _a3.call(relation);
        });
      }
      if ((!me.modelRelations || me.modelRelations.length === 0 || reset) && relations) {
        me.modelRelations = [];
        relations == null ? void 0 : relations.forEach((modelRelationConfig) => {
          const config = { ...modelRelationConfig }, {
            foreignStore,
            relationName,
            relatedCollectionName
          } = config, relatedStore = typeof foreignStore === "string" ? me[foreignStore] : foreignStore;
          config.dependentStore = me;
          me.modelRelations.push(config);
          if (relatedStore) {
            config.foreignStoreProperty = config.foreignStore;
            config.foreignStore = relatedStore;
            const dependentStoreConfigs = relatedStore.dependentStoreConfigs;
            if (dependentStoreConfigs.has(me)) {
              const dependentConfigs = dependentStoreConfigs.get(me);
              if (reset) {
                const existingConfig = dependentConfigs.find((c) => c.relationName === relationName);
                if (existingConfig) {
                  ArrayHelper.remove(dependentConfigs, existingConfig);
                }
              }
              dependentConfigs.push(config);
            } else {
              dependentStoreConfigs.set(me, [config]);
            }
            if (relatedCollectionName) {
              relatedStore.initRelationCollection(config, me);
            }
            if (relatedStore.count > 0) {
              relatedStore.updateDependentStores("dataset", relatedStore.records);
            }
          }
        });
      }
    }
    /**
     * Called from other end of an relation when this store should hold a collection of related records.
     * @private
     * @param config
     * @param collectionStore
     */
    initRelationCollection(config, collectionStore) {
      const me = this, name = config.relatedCollectionName, collectionStores = me.collectionStores || (me.collectionStores = {});
      collectionStores[name] = {
        store: collectionStore,
        config
      };
      if (!me[name + "Store"]) {
        me[name + "Store"] = collectionStore;
      }
      if (me.count > 0) {
        me.initModelRelationCollection(name, me.records);
      }
    }
    initModelRelationCollection(name, records) {
      const me = this;
      records.forEach((record) => {
        record.traverse((node) => {
          const useName = name in node ? `$related${StringHelper.capitalize(name)}` : name;
          Object.defineProperty(node, useName, {
            enumerable: true,
            configurable: true,
            get: function() {
              return me.getCollection(this, name);
            },
            set: function(value) {
              return me.setCollection(this, name, value);
            }
          });
        });
      });
    }
    /**
     * Updates relationCache for all records.
     * @private
     */
    resetRelationCache() {
      this.relationCache = {};
      this.forEach((record) => record.initRelations());
    }
    /**
     * Caches related records from related store on the local store.
     * @private
     * @param record Local record
     * @param relations Relations to related store
     */
    updateRecordRelationCache(record, relations) {
      relations == null ? void 0 : relations.forEach((relation) => {
        const { config } = relation, foreignId = relation.related ? relation.related.id : record.getValue(config.foreignKey);
        foreignId !== void 0 && this.cacheRelatedRecord(record, foreignId, config.relationName, foreignId);
      });
    }
    //endregion
    //region Getters
    /**
     * Returns records the relation cache. Same result as if retrieving the collection on the dependent store, but
     * without the need of accessing that store.
     * @internal
     * @param {String} name
     * @param {Core.data.Model|String|Number} recordOrId
     * @returns {Array}
     */
    getRelationCollection(name, recordOrId) {
      var _a3;
      const id = Model.asId(recordOrId);
      return ((_a3 = this.relationCache[name]) == null ? void 0 : _a3[id]) || [];
    }
    /**
     * Returns records from a collection of related records. Not to be called directly, called from Model getter.
     * @private
     * @param {Core.data.Model} record
     * @param {String} name
     * @returns {Array}
     */
    getCollection(record, name) {
      var _a3;
      const { config, store } = this.collectionStores[name];
      return ((_a3 = store.relationCache[config.relationName]) == null ? void 0 : _a3[record.id]) || [];
    }
    /**
     * Sets a collection of related records. Will updated the related store and trigger events from it. Not to be called
     * directly, called from Model setter.
     * @private
     */
    setCollection(model, name, records) {
      const { config, store } = this.collectionStores[name], relationCache = store.relationCache[config.relationName] || (store.relationCache[config.relationName] = {}), old = (relationCache[model.id] || []).slice(), added = [], removed = [];
      store.suspendEvents();
      old.forEach((record) => {
        if (!records.includes(record)) {
          record[config.foreignKey] = null;
          store.remove(record);
          removed.push(record);
        }
      });
      records.forEach((record) => {
        if (record.isModel instanceof Model) {
          if (!record.stores.includes(store)) {
            store.add(record);
            added.push(record);
          }
        } else {
          [record] = store.add(record);
          added.push(record);
        }
        record[config.foreignKey] = model.id;
      });
      store.resumeEvents();
      if (removed.length) {
        store.trigger("remove", { records: removed });
        store.trigger("change", { action: "remove", records: removed });
      }
      if (added.length) {
        store.trigger("add", { records: added });
        store.trigger("change", { action: "add", records: added });
      }
    }
    //endregion
    //region Caching
    /**
     * Adds a record to relation cache, optionally removing it if already there.
     * @private
     * @param record
     * @param id
     * @param name
     * @param uncacheId
     */
    cacheRelatedRecord(record, id, name, uncacheId = null) {
      const me = this, cache = me.relationCache[name] || (me.relationCache[name] = {});
      if (uncacheId !== null) {
        me.uncacheRelatedRecord(record, name, uncacheId);
      }
      if (id != null) {
        ArrayHelper.include(cache[id] || (cache[id] = []), record);
      }
    }
    /**
     * Removes a record from relation cache, for a specific relation (specify relation name and id) or for all relations
     * @private
     * @param record Record to remove from cache
     * @param name Optional, relation name
     * @param id Optional, id
     */
    uncacheRelatedRecord(record, name = null, id = null) {
      const me = this;
      function remove(relationName, relatedId) {
        const cache = me.relationCache[relationName], oldCache = cache == null ? void 0 : cache[relatedId];
        if (oldCache) {
          const uncacheIndex = oldCache.indexOf(record);
          uncacheIndex >= 0 && oldCache.splice(uncacheIndex, 1);
          if (oldCache.length === 0) {
            delete cache[relatedId];
          }
        }
      }
      if (id != null) {
        remove(name, id);
      } else {
        if (record.meta.relationCache) {
          Object.entries(record.meta.relationCache).forEach(
            ([relationName, relatedRecord]) => remove(relationName, relatedRecord == null ? void 0 : relatedRecord.id)
          );
        }
      }
    }
    /**
     * Updates related stores when store is cleared, a record is removed or added.
     * @private
     * @param {String} action
     * @param {Core.data.Model[]} records
     */
    updateDependentStores(action, records) {
      this.dependentStoreConfigs.forEach((configs) => {
        configs.forEach((config) => {
          const {
            dependentStore,
            relatedCollectionName,
            relationName,
            foreignKey
          } = config, cache = dependentStore.relationCache[relationName];
          if (action === "dataset") {
            relatedCollectionName && this.initModelRelationCollection(relatedCollectionName, records);
            dependentStore.forEach((record) => {
              const foreign = record.initRelation(config);
              foreign && dependentStore.cacheRelatedRecord(record, foreign.id, relationName, foreign.id);
            });
            return;
          }
          if (action === "removeall") {
            dependentStore.forEach((record) => record.removeRelation(config));
            delete dependentStore.relationCache[relationName];
            return;
          }
          if (action === "add") {
            relatedCollectionName && this.initModelRelationCollection(relatedCollectionName, records);
          }
          if (action === "add" || action === "remove") {
            records.forEach((record) => {
              const dependentRecords = cache == null ? void 0 : cache[record.id];
              switch (action) {
                case "remove":
                  if (dependentRecords) {
                    dependentRecords.forEach((dependentRecord) => dependentRecord.removeRelation(config));
                  }
                  break;
                case "add":
                  dependentStore.forEach((dependentRecord) => {
                    if (dependentRecord.getValue(foreignKey) == record.id) {
                      dependentRecord.initRelation(config);
                      dependentStore.cacheRelatedRecord(dependentRecord, record.id, relationName);
                    }
                  });
                  break;
              }
            });
          }
        });
      });
    }
    /**
     * Updates relation cache and foreign key value when a related objects id is changed.
     * @private
     */
    updateDependentRecordIds(oldValue, value) {
      var _a3;
      (_a3 = this.dependentStoreConfigs) == null ? void 0 : _a3.forEach((configs) => {
        configs.forEach((config) => {
          var _a4;
          const {
            dependentStore,
            relationName,
            foreignKey
          } = config, cache = dependentStore.relationCache[relationName], localRecords = (_a4 = cache == null ? void 0 : cache[oldValue]) == null ? void 0 : _a4.slice();
          localRecords == null ? void 0 : localRecords.forEach((localRecord) => {
            dependentStore.cacheRelatedRecord(localRecord, value, relationName, oldValue);
            localRecord.set(foreignKey, value, false, true);
          });
        });
      });
    }
    //endregion
  }, __publicField(_a2, "$name", "StoreRelation"), _a2;
};

// ../Core/lib/Core/data/mixin/StoreSum.js
var StoreSum_default = (Target) => class StoreSum extends (Target || Base2) {
  static get $name() {
    return "StoreSum";
  }
  /**
   * Returns sum calculated by adding value of specified field for specified records. Defaults to using all records
   * in store
   * @param {String} field Field to summarize by
   * @param {Core.data.Model[]} records Records to summarize, uses all records if unspecified.
   * @returns {Number}
   * @category Sum
   */
  sum(field2, records = this.storage.values) {
    if (!records) {
      return 0;
    }
    return records.reduce((sum, record) => {
      if (record.isSpecialRow) {
        return sum;
      }
      const v = Number(record.getValue(field2));
      return isNaN(v) ? sum : sum + v;
    }, 0);
  }
  /**
   * Returns min value for the specified field, can be used with Date or Number values. Defaults to look through all records in store
   * @param {String} field Field to find min value for
   * @param {Core.data.Model[]} records Records to process, uses all records if unspecified
   * @returns {Number|Date}
   * @category Sum
   */
  min(field2, records = this.storage.values) {
    if (!(records == null ? void 0 : records.length)) {
      return 0;
    }
    return records.reduce((min2, record) => {
      const fieldValue = record.getValue(field2), type = typeof (fieldValue == null ? void 0 : fieldValue.valueOf());
      if (type === "number" && fieldValue < min2) {
        min2 = fieldValue;
      }
      return min2;
    }, records[0].getValue(field2));
  }
  /**
   * Returns max value for the specified field, can be used with Date or Number values. Defaults to look through all records in store
   * @param {String} field Field to find max value for
   * @param {Core.data.Model[]} records Records to process, uses all records if unspecified
   * @returns {Number|Date}
   * @category Sum
   */
  max(field2, records = this.storage.values) {
    if (!(records == null ? void 0 : records.length)) {
      return 0;
    }
    return records.reduce((max, record) => {
      const fieldValue = record.getValue(field2), type = typeof (fieldValue == null ? void 0 : fieldValue.valueOf());
      if (type === "number" && fieldValue > max) {
        max = fieldValue;
      }
      return max;
    }, records[0].getValue(field2));
  }
  /**
   * Returns the average value for the specified field. Defaults to look through all records in store
   * @param {String} field Field to calculate average value for
   * @param {Core.data.Model[]} records Records to process, uses all records if unspecified
   * @returns {Number}
   * @category Sum
   */
  average(field2, records = this.storage.values) {
    if (!(records == null ? void 0 : records.length)) {
      return 0;
    }
    let count = 0;
    const sum = records.reduce((sum2, record) => {
      if (record.isSpecialRow) {
        return sum2;
      }
      const v = parseFloat(record.getValue(field2));
      if (!isNaN(v)) {
        count++;
        return sum2 + v;
      } else {
        return sum2;
      }
    }, 0);
    return count > 0 ? sum / count : 0;
  }
  /**
   * Returns sum by adding value of specified field for records in the group with the specified groupValue.
   * @param {*} groupValue The group to summarize
   * @param {String} field Field to summarize by
   * @returns {Number} Sum or null if store not grouped
   * @category Sum
   */
  groupSum(groupValue, field2) {
    return this.sum(field2, this.getGroupRecords(groupValue));
  }
};

// ../Core/lib/Core/data/mixin/StoreSearch.js
var findInString = (value, text) => String(value).toLowerCase().includes(text);
var matchFns = {
  string: findInString,
  number: findInString,
  boolean: findInString,
  date: (value, text) => {
    if (value instanceof Date && text instanceof Date) {
      return value - text === 0;
    }
    return String(value.getMonth() + 1).includes(text) || String(value.getDate()).includes(text) || String(value.getFullYear()).includes(text);
  },
  object: (value, text) => value === text,
  // typeof null === object
  undefined: (value, text) => value === text
};
var StoreSearch_default = (Target) => class StoreSearch extends (Target || Base2) {
  static get $name() {
    return "StoreSearch";
  }
  //region Search (multiple hits)
  /**
   * Find all hits matching the specified input
   * @param {String} text Value to search for
   * @param {String[]} fields Fields to search value in
   * @param {Function[]} [formatters] An array of field formatting functions to format the found value
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {StoreSearchResult[]} Array of hits, in the format { index: x, data: record }
   * @category Search
   */
  search(text, fields = null, formatters, searchAllRecords) {
    const records = this.isTree && !searchAllRecords ? this.rootNode.allChildren : this.getAllDataRecords(searchAllRecords), len = records.length, found = [];
    if (text == null) {
      return [];
    }
    if (typeof text === "string") {
      text = text.toLowerCase();
    }
    let i, j, record, value, valueType, comparison;
    for (i = 0; i < len; i++) {
      record = records[i];
      j = 0;
      for (const key of fields || record.fieldNames) {
        value = record.getValue(key);
        valueType = value instanceof Date ? "date" : typeof value;
        const formatter = formatters == null ? void 0 : formatters[j];
        if (formatter) {
          value = formatter(value);
          valueType = "string";
        }
        comparison = matchFns[valueType];
        if (value && (comparison == null ? void 0 : comparison(value, text))) {
          found.push({
            index: i,
            data: record,
            field: key,
            id: record.id
          });
        }
        j++;
      }
    }
    return found;
  }
  /**
   * Find occurrences of the specified `value` in the specified `field` on all records in the store
   * @param {String} field The record field to search in
   * @param {*} value Value to search for
   * @param {Boolean} distinct True to only return distinct matches, no duplicates
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {StoreSearchResult[]} Array of hits, in the format { index: x, data: record }
   * @category Search
   */
  findByField(field2, value, distinct = false, searchAllRecords = false) {
    const records = this.getAllDataRecords(searchAllRecords), len = records.length, usedValues = /* @__PURE__ */ new Set(), found = [];
    let i, record, fieldValue;
    if (value != null) {
      value = String(value).toLowerCase();
    }
    for (i = 0; i < len; i++) {
      record = records[i];
      fieldValue = record.getValue(field2);
      if (!distinct || !usedValues.has(fieldValue)) {
        const type = fieldValue instanceof Date ? "date" : typeof fieldValue, matchFn = matchFns[type];
        if (value == null && fieldValue === value || value && matchFn(fieldValue, value)) {
          found.push({
            id: record.id,
            index: i,
            data: record
          });
          if (distinct) {
            usedValues.add(fieldValue);
          }
        }
      }
    }
    return found;
  }
  //endregion
  //region Find (single hit)
  /**
   * Finds the first record for which the specified function returns true
   * @param {Function} fn Comparison function, called with record as parameter
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {Core.data.Model} Record or undefined if none found
   *
   * @example
   * store.find(record => record.color === 'blue');
   * @category Search
   */
  find(fn2, searchAllRecords = false) {
    return this.getAllDataRecords(searchAllRecords).find(fn2);
  }
  /**
   * Finds the first record for which the specified field has the specified value
   * @param {String} fieldName Field name
   * @param {*} value Value to find
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {Core.data.Model} Record or undefined if none found
   * @category Search
   */
  findRecord(fieldName, value, searchAllRecords = false) {
    const matchFn = (r) => ObjectHelper.isEqual(r[fieldName], value);
    if (this.isTree) {
      return this.query(matchFn, searchAllRecords)[0];
    }
    return this.getAllDataRecords(searchAllRecords).find(matchFn);
  }
  /**
   * Searches the Store records using the passed function.
   * @param {Function} fn A function that is called for each record. Return true to indicate a match
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {Core.data.Model[]} An array of the matching Records
   * @category Search
   */
  query(fn2, searchAllRecords = false) {
    if (this.isTree) {
      const matches = [];
      this.traverse((node) => {
        if (fn2(node)) {
          matches.push(node);
        }
      }, void 0, void 0, searchAllRecords);
      return matches;
    }
    return this.getAllDataRecords(searchAllRecords).filter(fn2);
  }
  //endregion
  //region Others
  /**
   * Returns true if the supplied function returns true for any record in the store
   * @param {Function} fn A function that should return true to indicate a match
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {Boolean}
   *
   * @example
   * store.some(record => record.age > 95); // true if any record has age > 95
   * @category Search
   */
  some(fn2, searchAllRecords = false) {
    return this.getAllDataRecords(searchAllRecords).some(fn2);
  }
  //endregion
};

// ../Core/lib/Core/data/mixin/StoreSort.js
var StoreSort_default = (Target) => class StoreSort extends (Target || Base2) {
  static get $name() {
    return "StoreSort";
  }
  //region Config
  static get defaultConfig() {
    return {
      /**
       * Use `localeCompare()` when sorting, which lets the browser sort in a locale specific order. Set to `true`,
       * a locale string or a locale config to enable.
       *
       * Enabling this has big negative impact on sorting
       * performance. For more info on `localeCompare()`, see [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare).
       *
       * Examples:
       *
       * ```javascript
       * const store = new Store({
       *     // Swedish sorting
       *     useLocaleSort : 'sv-SE'
       * });
       *
       * const store = new Store({
       *     // Swedish sorting with custom casing order
       *     useLocaleSort : {
       *         locale    : 'sv-SE',
       *         caseFirst : 'upper'
       *     }
       * });
       * ```
       *
       * Can also be configured on a per-sorter basis:
       *
       * ```javascript
       * store.sort({ field: 'name', useLocaleSort : 'sv-SE' });
       * ```
       *
       * @config {Boolean|String|Object}
       * @default false
       * @category Advanced
       */
      useLocaleSort: null
    };
  }
  static get configurable() {
    return {
      /**
       * Initial sorters, format is [{ field: 'name', ascending: false }, ...]
       * @config {Sorter[]|String[]}
       * @category Common
       */
      sorters: [],
      /**
       * Specify true to sort this store after records are added.
       * @config {Boolean}
       * @default
       * @category Sorting
       */
      reapplySortersOnAdd: false
    };
  }
  //endregion
  //region Events
  /**
   * Fired before sorting
   * @event beforeSort
   * @param {Core.data.Store} source This Store
   * @param {Sorter[]} sorters Sorter configs
   * @param {Core.data.Model[]} records Records to sort
   */
  /**
   * Fired after sorting
   * @event sort
   * @param {Core.data.Store} source This Store
   * @param {Sorter[]} sorters Sorter configs
   * @param {Core.data.Model[]} records Sorted records
   */
  //endregion
  //region Properties
  /**
   * Currently applied sorters
   * @member {Sorter[]} sorters
   * @readonly
   * @category Sort, group & filter
   */
  /**
   * Is store sorted?
   * @property {Boolean}
   * @readonly
   * @category Sort, group & filter
   */
  get isSorted() {
    return Boolean(this.sorters.length) || this.isGrouped;
  }
  changeSorters(sorters) {
    return sorters.map((sorter) => this.normalizeSorterConfig(sorter, true));
  }
  updateReapplySortersOnAdd(enable) {
    this.storage.autoSort = enable;
  }
  //endregion
  //region Add & remove sorters
  /**
   * Sort records, either by replacing current sorters or by adding to them.
   * A sorter can specify a **_custom sorting function_** which will be called with arguments (recordA, recordB).
   * Works in the same way as a standard array sorter, except that returning `null` triggers the stores
   * normal sorting routine.
   *
   * ```javascript
   * // single sorter
   * store.sort('age');
   *
   * // single sorter as object, descending order
   * store.sort({ field : 'age', ascending : false });
   *
   * // multiple sorters
   * store.sort(['age', 'name']);
   *
   * // using custom sorting function
   * store.sort((recordA, recordB) => {
   *     // apply custom logic, for example:
   *     return recordA.name.length < recordB.name.length ? -1 : 1;
   * });
   *
   * // using locale specific sort (slow)
   * store.sort({ field : 'name', useLocaleSort : 'sv-SE' });
   * ```
   *
   * @param {String|Sorter[]|Sorter|Function} field Field to sort by.
   * Can also be an array of {@link Core.util.CollectionSorter sorter} config objects, or a sorting function, or a
   * {@link Core.util.CollectionSorter sorter} config.
   * @param {Boolean} [ascending] Sort order.
   * Applicable when the `field` is a string (if not specified and already sorted by the field, reverts direction),
   * or an object and `ascending` property is not specified for the object. `true` by default.
   * Not applicable when `field` is a function. `ascending` is always `true` in this case.
   * @param {Boolean} [add] If `true`, adds a sorter to the sorters collection.
   * Not applicable when `field` is an array. In this case always replaces active sorters.
   * @param {Boolean} [silent] Set as true to not fire events. UI will not be informed about the changes.
   * @category Sort, group & filter
   * @fires beforeSort
   * @fires sort
   * @fires refresh
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   */
  sort(field2, ascending, add = false, silent = false) {
    const me = this, records = me.allRecords, currentSorters = me.sorters ? me.sorters.slice() : [];
    let currentDir = null, curSort;
    if (field2) {
      if (Array.isArray(field2)) {
        me.sorters = field2.map((sorter) => me.normalizeSorterConfig(sorter, typeof sorter === "string" ? true : ascending));
      } else {
        const sorter = me.normalizeSorterConfig(field2, ascending);
        if (add) {
          curSort = me.getCurrentSorterByField(sorter.field);
          if (curSort) {
            currentDir = curSort.ascending;
            curSort.ascending = sorter.ascending;
          } else {
            me.sorters.push(sorter);
          }
        } else {
          me.sorters = [sorter];
        }
      }
    }
    if (!silent && me.trigger("beforeSort", { sorters: me.sorters, records, currentSorters }) === false) {
      me.sorters = currentSorters;
      if (currentDir !== null) {
        curSort.ascending = currentDir;
      }
      return null;
    }
    return me.performSort(silent);
  }
  normalizeSorterConfig(field2, ascending) {
    var _a2, _b, _c;
    const me = this, sorter = { ascending };
    if (typeof field2 === "object") {
      ObjectHelper.assign(sorter, field2);
      if (field2.fn) {
        delete sorter.fn;
        sorter.sortFn = field2.fn;
      }
      sorter.ascending = (_a2 = field2.ascending) != null ? _a2 : ascending;
    } else if (typeof field2 === "function") {
      sorter.sortFn = field2;
    } else {
      sorter.field = field2;
    }
    if (sorter.ascending == null) {
      const curSort = me.getCurrentSorterByField(sorter.field);
      sorter.ascending = curSort ? !curSort.ascending : true;
    }
    if (sorter.sortFn == null) {
      const compareItems = (_c = (_b = me.modelClass) == null ? void 0 : _b.$meta.fields.map[sorter.field]) == null ? void 0 : _c.compareItems;
      if (compareItems) {
        sorter.sortFn = compareItems;
      }
    }
    return sorter;
  }
  getCurrentSorterByField(field2) {
    return typeof field2 === "string" && this.sorters.find((s) => s.field === field2) || null;
  }
  /**
   * Add a sorting level (a sorter).
   * @param {String|Sorter[]|Sorter|Function} field Field to sort by. Can also be an array of sorters, or a sorting
   * function, or a {@link Core.util.CollectionSorter sorter} config.
   * @param {Boolean} [ascending] Sort order (used only if field specified as string)
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  addSorter(field2, ascending = true) {
    return this.sort(field2, ascending, true);
  }
  /**
   * Remove a sorting level (a sorter)
   * @param {String|Function} field Stop sorting by this field (or sorter function)
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  removeSorter(field2) {
    const sorterIndex = this.sorters.findIndex((sorter) => sorter.field === field2 || sorter.sortFn === field2);
    if (sorterIndex > -1) {
      this.sorters.splice(sorterIndex, 1);
      return this.sort();
    }
  }
  /**
   * Removes all sorters, turning store sorting off.
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  clearSorters(silent = false) {
    if (this.sorters.length) {
      this.sorters.length = 0;
      return this.sort(void 0, void 0, void 0, silent);
    }
  }
  //region
  //region Sorting logic
  /**
   * Creates a function used with Array#sort when sorting the store. Override to use your own custom sorting logic.
   * @param {Sorter[]} sorters An array of sorter config objects
   * @returns {Function}
   * @category Sort, group & filter
   */
  createSorterFn(sorters) {
    const storeLocaleSort = this.useLocaleSort;
    return (lhs, rhs) => {
      for (let i = 0; i < sorters.length; i++) {
        const sorter = sorters[i], { field: field2, ascending = true, useLocaleSort = storeLocaleSort } = sorter, fn2 = sorter.fn || sorter.sortFn, direction = ascending ? 1 : -1;
        if (fn2) {
          const val = fn2.call(sorter, lhs, rhs);
          if (val === 0) {
            continue;
          }
          if (val !== null) {
            return val * direction;
          }
        }
        const lhsValue = lhs.isModel ? lhs.getValue(field2) : lhs[field2], rhsValue = rhs.isModel ? rhs.getValue(field2) : rhs[field2];
        if (lhsValue === rhsValue) {
          continue;
        }
        if (lhsValue == null) {
          return -direction;
        }
        if (rhsValue == null) {
          return direction;
        }
        if (useLocaleSort && typeof lhsValue === "string") {
          if (useLocaleSort === true) {
            return String(lhsValue).localeCompare(rhsValue) * direction;
          }
          if (typeof useLocaleSort === "string") {
            return String(lhsValue).localeCompare(rhsValue, useLocaleSort) * direction;
          }
          if (typeof useLocaleSort === "object") {
            return String(lhsValue).localeCompare(rhsValue, useLocaleSort.locale, useLocaleSort) * direction;
          }
        }
        if (lhsValue > rhsValue) {
          return direction;
        }
        if (lhsValue < rhsValue) {
          return -direction;
        }
      }
      return 0;
    };
  }
  /**
   * The sorter function for sorting records in the store.
   * @member {Function}
   * @internal
   * @readonly
   */
  get sorterFn() {
    const me = this, { sorters } = me;
    return me.createSorterFn(me.remoteSort ? [{ field: "_remoteSortIndex" }] : me.isGrouped ? me.groupers.concat(sorters) : sorters);
  }
  /**
   * Perform sorting according to the {@link #config-sorters} configured.
   * This is the internal implementation which is overridden in {@link Core.data.AjaxStore} and
   * must not be overridden.
   * @async
   * @private
   * @category Sort, group & filter
   */
  performSort(silent) {
    const me = this, { rootNode, storage, sorterFn: sorter } = me;
    if (me.tree) {
      !me.isChained && rootNode.traverse((node) => {
        if (node.isLoaded && node.isParent) {
          node.children.sort(sorter);
          node.updateChildrenIndices(node.children, "parentIndex", true);
        }
      });
      storage.replaceValues({
        values: me.collectDescendants(rootNode).visible,
        silent: true
      });
    } else if (me.isGrouped) {
      storage.replaceValues({
        ...me.prepareGroupRecords(sorter),
        silent: true
      });
    } else {
      storage.replaceValues({
        values: storage.values.sort(sorter),
        silent: true
      });
    }
    me.afterPerformSort(silent || me.isRemoteDataLoading);
  }
  afterPerformSort(silent) {
    if (silent) {
      return;
    }
    const me = this;
    me._idMap = null;
    const event = {
      action: "sort",
      sorters: me.sorters,
      records: me.allRecords
    };
    me.trigger("sort", event);
    me.trigger("refresh", event);
  }
  //endregion
};

// ../Core/lib/Core/data/mixin/StoreChained.js
var returnTrue = () => true;
var StoreChained_default = (Target) => class StoreChained extends (Target || Base2) {
  static get $name() {
    return "StoreChained";
  }
  //region Config
  static get defaultConfig() {
    return {
      /**
       * Function used to filter records in the masterStore into a chained store. If not provided,
       * all records from the masterStore will be included in the chained store.
       * @config {Function}
       * @category Chained store
       */
      chainedFilterFn: null,
      /**
       * Array of field names that should trigger filtering of chained store when the fields are updated.
       * @config {String[]}
       * @category Chained store
       */
      chainedFields: null,
      /**
       * Master store that a chained store gets its records from.
       * @config {Core.data.Store}
       * @category Chained store
       */
      masterStore: null,
      /**
       * Method names calls to which should be relayed to master store.
       * @config {String[]}
       * @category Chained store
       */
      doRelayToMaster: ["add", "remove", "insert"],
      /**
       * Method names calls to which shouldn't be relayed to master store.
       * @config {String}
       * @category Chained store
       */
      dontRelayToMaster: [],
      /**
       * If true, collapsed records in original tree will be excluded from the chained store.
       * @config {Boolean}
       * @category Chained store
       */
      excludeCollapsedRecords: true,
      chainSuspended: 0
    };
  }
  // All props should be predefined to work properly with objectified stores
  static get properties() {
    return {
      chainedStores: null
    };
  }
  //endregion
  construct(config) {
    super.construct(config);
    const me = this, { masterStore } = me, sort = me.syncOrder ? "sort" : "";
    if (masterStore) {
      me.methodNamesToRelay.forEach((fnName) => me[fnName] = (...params) => me.relayToMaster(fnName, params));
      me.removeAll = (...params) => {
        masterStore.remove(me.getRange(), ...params);
      };
      masterStore.ion({
        // HACK to have chained stores react early in a async events scenario (with engine). Could be turned
        // into a config, but this way one does not have to think about it
        changePreCommit: me.onMasterDataChangedPreCommit,
        change: me.onMasterDataChanged,
        [sort]: me.onMasterDataChanged,
        prio: 1,
        thisObj: me
      });
      if (!masterStore.chainedStores) {
        masterStore.chainedStores = [];
      }
      masterStore.chainedStores.push(me);
      me.fillFromMaster();
    }
  }
  //region Properties
  // For accessing the full set of records, whether chained or not
  get $master() {
    return this.masterStore || this;
  }
  /**
   * Is this a chained store?
   * @property {Boolean}
   * @readonly
   * @category Advanced
   */
  get isChained() {
    return Boolean(this.masterStore);
  }
  set chainedFilterFn(chainedFilterFn) {
    this._chainedFilterFn = this.thisObj ? chainedFilterFn.bind(this.thisObj) : chainedFilterFn;
  }
  get chainedFilterFn() {
    return this._chainedFilterFn || returnTrue;
  }
  get methodNamesToRelay() {
    const doIsArray = Array.isArray(this.doRelayToMaster), dontIsArray = Array.isArray(this.dontRelayToMaster);
    return doIsArray && this.doRelayToMaster.filter((name) => !dontIsArray || !this.dontRelayToMaster.includes(name)) || [];
  }
  //endregion
  //region Internal
  updateChainedStores() {
    if (this.chainedStores) {
      this.chainedStores.forEach((store) => store.fillFromMaster());
    }
  }
  /**
   * Updates records available in a chained store by filtering the master store records using
   * {@link #config-chainedFilterFn}
   * @category Chained store
   */
  fillFromMaster() {
    const me = this, { masterStore, isTree } = me;
    let records = [];
    if (!me.isChained) {
      throw new Error("fillFromMaster only allowed on chained store");
    }
    if (me.isChainSuspended) {
      return;
    }
    if (masterStore.isGrouped && masterStore.isFiltered) {
      masterStore.forEach((r) => records.push(r), masterStore, { includeFilteredOutRecords: true, includeCollapsedGroupRecords: true });
    } else {
      records = masterStore.allRecords.filter((r) => !r.isSpecialRow && me.chainedFilterFn(r));
    }
    if (isTree) {
      me.idRegister = {};
      me.internalIdRegister = {};
      records.forEach((r) => {
        if (r.stores.includes(me)) {
          me.register(r);
        } else {
          r.joinStore(me);
        }
      });
      if (me.excludeCollapsedRecords) {
        const children = me.getChildren(me.rootNode);
        records = me.doIncludeExclude(children, true);
      }
    }
    me.isFillingFromMaster = true;
    me.data = records;
    me.isFillingFromMaster = false;
  }
  /**
   * Commits changes back to master.
   * - the records deleted from chained store and present in master will be deleted from master
   * - the records added to chained store and missing in master will added to master
   * Internally calls {Store#function-commit commit()}.
   * @returns {Object} Changes, see Store#changes
   * @internal
   */
  commitToMaster() {
    const me = this, master = me.masterStore;
    if (!me.isChained) {
      throw new Error("commitToMaster only allowed on chained store");
    }
    master.beginBatch();
    master.remove(me.removed.values);
    master.add(me.added.values);
    master.endBatch();
    return me.commit();
  }
  /**
   * Relays some function calls to the master store
   * @private
   */
  relayToMaster(fnName, params) {
    return this.masterStore[fnName](...params);
  }
  // HACK, when used with engine the chained store will catch events early (sync) and prevent late (async) listeners
  onMasterDataChangedPreCommit(event) {
    this.onMasterDataChanged(event);
    this.$masterEventhandled = true;
  }
  /**
   * Handles changes in master stores data. Updates the chained store accordingly
   * @private
   */
  onMasterDataChanged({ action, changes, $handled, isMove }) {
    var _a2;
    if (this.$masterEventhandled) {
      this.$masterEventhandled = false;
      return;
    }
    if (isMove && action === "remove") {
      return;
    }
    if (action !== "update" || ((_a2 = this.chainedFields) == null ? void 0 : _a2.some((field2) => field2 in changes))) {
      this.fillFromMaster();
    }
  }
  //endregion
  //region public API
  /**
   * Creates a chained store, a new Store instance that contains a subset of the records from current store.
   * Which records is determined by a filtering function, which is reapplied when data in the base store changes.
   *
   * ```javascript
   * const oldies = store.makeChained(record => record.age > 50);
   * // or use a simple query
   * const ages = store.makeChained(() => store.allRecords.distinct('age')));
   * ```
   *
   * If this store is a {@link Core.data.mixin.StoreTree#property-isTree tree} store, then the resulting chained store
   * will be a tree store sharing the same root node, but only child nodes which pass the `chainedFilterFn` will be
   * considered when iterating the tree through the methods such as
   * {@link Core.data.Store#function-traverse} or {@link Core.data.Store#function-forEach}.
   *
   * @param {Function} [chainedFilterFn] Either a filter function called for every record to determine if it should be
   * included (return true / false), or a query function called with no arguments (see example below). Defaults to
   * including all records (fn always returning true)
   * @param {String[]} [chainedFields] Array of fields that trigger filtering when they are updated
   * @param {StoreConfig} [config] Additional chained store configuration. See {@link Core.data.Store#configs}
   * @param {Class} [config.storeClass] The Store class to use if this Store type is not required.
   * @returns {Core.data.Store}
   * @category Chained store
   */
  makeChained(chainedFilterFn = returnTrue, chainedFields, config) {
    return new ((config == null ? void 0 : config.storeClass) || this.constructor)({
      ...config || {},
      tree: false,
      autoTree: false,
      // If someone ever chains a chained store, chain master instead
      masterStore: this.$master,
      modelClass: this.modelClass,
      // Chained store should never use syncDataOnLoad, that will create an infinite loop when they determine
      // that a record is added and then add it to master, repopulating this store and round we go
      syncDataOnLoad: false,
      chainedFilterFn,
      chainedFields
    });
  }
  /**
   * Alias for {@link Core.data.Store#function-makeChained}
   *
   * @param {Function} [chainedFilterFn] Either a filter function called for every record to determine if it should be
   * included (return true / false), or a query function called with no arguments (see example below). Defaults to
   * including all records (fn always returning true)
   * @param {String[]} [chainedFields] Array of fields that trigger filtering when they are updated
   * @param {StoreConfig} [config] Additional chained store configuration. See {@link Core.data.Store#configs}
   * @param {Class} [config.storeClass] The Store class to use if this Store type is not required.
   * @returns {Core.data.Store}
   * @category Chained store
   */
  chain() {
    return this.makeChained(...arguments);
  }
  //endregion
  doDestroy() {
    var _a2;
    (_a2 = this.chainedStores) == null ? void 0 : _a2.forEach((chainedStore) => chainedStore.destroy());
    super.doDestroy();
  }
  suspendChain() {
    this.chainSuspended++;
  }
  resumeChain(refill = false) {
    if (this.chainSuspended && !--this.chainSuspended && refill) {
      this.fillFromMaster();
    }
  }
  get isChainSuspended() {
    return this.chainSuspended > 0;
  }
};

// ../Core/lib/Core/data/mixin/StoreState.js
var StoreState_default = (Target) => class StoreState extends (Target || Base2) {
  static get $name() {
    return "StoreState";
  }
  /**
   * Get store state. Used by State-plugin to serialize state
   * @private
   * @returns {{ sorters, groupers }}
   */
  getState() {
    const { sorters, groupers, filters } = this, state = {};
    if (sorters == null ? void 0 : sorters.length) {
      state.sorters = sorters.map((sorter) => {
        const clone = ObjectHelper.cleanupProperties(ObjectHelper.clone(sorter));
        delete clone.fn;
        delete clone.sortFn;
        return clone;
      });
    }
    if (groupers == null ? void 0 : groupers.length) {
      state.groupers = groupers.map((grouper) => {
        const clone = ObjectHelper.cleanupProperties(ObjectHelper.clone(grouper));
        delete clone.fn;
        return clone;
      });
    }
    if (filters == null ? void 0 : filters.values.length) {
      state.filters = filters.values.map((filter2) => {
        const clone = ObjectHelper.cleanupProperties(ObjectHelper.clone(filter2.config));
        clone.value = filter2.value;
        if (clone.caseSensitive) {
          delete clone.caseSensitive;
        }
        return clone;
      });
    }
    return state;
  }
  /**
   * Apply store state. Used by State-plugin to restore a previously serialized state
   * @private
   * @param {{ sorters, groupers }} state
   */
  applyState(state) {
    const me = this, {
      sorters = [],
      groupers = [],
      filters = []
    } = state, {
      sortParamName,
      filterParamName
    } = me;
    me.sorters = sorters.filter((sorter) => sorter.field || sorter.sortFn && !sortParamName);
    me.groupers = groupers.slice();
    me.sort();
    me.filters = filters.filter((filter2) => filter2.property || filter2.filterBy && !filterParamName);
    me.filter();
  }
};

// ../Core/lib/Core/data/Wbs.js
var zeroPad = (v) => String(v).padStart(6, "0");
var Wbs = class {
  /**
   * Wbs constructor.
   * @param {String|Number} value The value of WBS
   */
  constructor(value) {
    this.value = value;
    this._padded = null;
  }
  /**
   * The WBS value
   * @readonly
   * @member {String} value
   */
  set value(value) {
    this._value = String(value != null ? value : "");
  }
  get value() {
    return this._value;
  }
  /**
   * Returns a `Wbs` instance given a `value`. If the `value` is already a `Wbs` object, it is returned. Otherwise,
   * a new `Wbs` is created. If `value` is `null` or `undefined`, that value is returned.
   * @param {String|Number|Core.data.Wbs} value
   * @returns {Core.data.Wbs}
   */
  static from(value) {
    return value == null ? value : value instanceof Wbs ? value : new Wbs(value);
  }
  /**
   * Returns a WBS code where each component is 0-padded on the left to 6 digits. That is "1.2" is padded to be
   * "000001.000002". These values can be compared for proper semantic order (e.g., Wbs.pad('1.2') < Wbs.pad('1.10')).
   * @param {String|Number|Core.data.Wbs} value
   * @returns {String}
   * @private
   */
  static pad(value) {
    return value instanceof Wbs ? value.valueOf() : Wbs.split(value).map(zeroPad).join(".");
  }
  /**
   * Returns an array of digits from a given WBS code `value`. If the value cannot be converted, an empty array is
   * returned.
   * @param {String|Number|Core.data.Wbs} value
   * @returns {Number[]}
   * @private
   */
  static split(value) {
    let i, ret;
    if (value || value === 0) {
      switch (typeof value) {
        case "object":
          value = String(value);
        case "string":
          ret = value.split(".");
          for (i = ret.length; i-- > 0; ) {
            ret[i] = parseInt(ret[i], 10);
          }
          break;
        case "number":
          ret = [value];
          break;
      }
    }
    return ret || [];
  }
  /**
   * Compares two WBS values, returning 0 if equal, -1 if `lhs` is less than `rhs, or 1 if `lhs` is greater than `rhs`.
   * @param {String|Core.data.Wbs} lhs
   * @param {String|Core.data.Wbs} rhs
   * @returns {Number}
   */
  static compare(lhs, rhs) {
    if (lhs === rhs) {
      return 0;
    }
    if (!lhs || !rhs) {
      return lhs ? 1 : rhs ? -1 : 0;
    }
    lhs = Wbs.pad(lhs);
    rhs = Wbs.pad(rhs);
    return lhs < rhs ? -1 : rhs < lhs ? 1 : 0;
  }
  /**
   * Appends a sub-level WBS value to this WBS code and returns a `Wbs` instance for it.
   * @param {String|Number} value
   * @returns {Core.data.Wbs}
   */
  append(value) {
    const s = this.value;
    return Wbs.from(s ? `${s}.${value}` : value);
  }
  /**
   * Returns truthy value if this Wbs equals the passed value.
   * @param {String|Core.data.Wbs} value
   * @returns {Boolean}
   */
  isEqual(value) {
    return !Wbs.compare(this, value);
  }
  /**
   * Compares this WBS value with a specified pattern, returning `true` if they match. If the `pattern` is simply a
   * sequence of digits and decimal points (e.g., "1.2"), it is a match if it is a substring of this WBS code (e.g.,
   * "3.1.2.4"). If the `pattern` starts with `*` (e.g., "*.1.2"), it is a match if this WBS code ends with the text
   * following the `*` (e.g., "4.3.1.2"). If the `pattern` ends with `*`, it is a match if this WBS code starts with
   * the text up to the `*`.
   *
   * Some examples:
   * ```
   *  console.log(Wbs.from('1.2.3.4').match('2.3'));
   *  > true
   *  console.log(Wbs.from('1.2.3.4').match('*.4'));
   *  > true
   *  console.log(Wbs.from('1.2.3.4').match('1.2.*'));
   *  > true
   *
   *  console.log(Wbs.from('1.2.3.4').match('2.4'));
   *  > false
   *  console.log(Wbs.from('1.2.3.4').match('*.3'));
   *  > false
   *  console.log(Wbs.from('1.2.3.4').match('2.*'));
   *  > false
   * ```
   * @param {String} pattern A partial WBS code (e.g., "1.2"), optionally starting or ending with `*`.
   * @returns {Boolean}
   */
  match(pattern) {
    let ret = false;
    if (pattern) {
      const wbs = this.value, globLeft = pattern[0] === "*", globRight = pattern.endsWith("*"), n = pattern.length;
      if (globLeft === globRight) {
        ret = wbs.indexOf(globLeft ? pattern.substr(1, n - 2) : pattern) > -1;
      } else if (globLeft) {
        ret = wbs.endsWith(pattern.substr(1));
      } else {
        ret = wbs.startsWith(pattern.substr(0, n - 1));
      }
    }
    return ret;
  }
  toString() {
    return this.value;
  }
  toJSON() {
    return this.toString();
  }
  valueOf() {
    var _a2;
    return (_a2 = this._padded) != null ? _a2 : this._padded = Wbs.pad(this.value);
  }
};
Wbs._$name = "Wbs";

// ../Core/lib/Core/data/mixin/StoreTree.js
var emptyArray3 = Object.freeze([]);
var StopBranch = Symbol("StopBranch");
var StoreTree_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base2) {
    get StopBranch() {
      return StopBranch;
    }
    //region Getters
    /**
     * True if this Store is configured to handle tree data (with `tree : true`) or if this is a
     * {@link Core.data.Store#function-makeChained chained store} and the master store is a tree store.
     * @property {Boolean}
     * @readonly
     * @category Tree
     */
    get isTree() {
      return this.tree || this.masterStore && this.masterStore.tree;
    }
    /**
     * Returns all leaf records in a tree store
     * @property {Core.data.Model[]}
     * @category Tree
     */
    get leaves() {
      const me = this, result = [];
      if (me.isTree) {
        me.traverse((record) => {
          if (record.isLeaf) {
            result.push(record);
          }
        });
        return result;
      } else {
        me.allRecords.forEach((r) => {
          if (r.isLeaf) {
            result.push(r);
          }
          r.traverse((record) => {
            if (record.isLeaf) {
              result.push(record);
            }
          }, true);
        });
      }
      return result;
    }
    //endregion
    //region Children
    /**
     * Loads children for a parent node that uses load on demand (when expanding it). Base implementation does nothing,
     * either use AjaxStore which implements it, create your own subclass with an implementation or listen for
     * `toggleNode` and insert records when you have them available.
     * @param {Core.data.Model} parentRecord
     * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is
     * vetoed by a {@link Core.data.AjaxStore#event-beforeLoadChildren} handler, or if an {@link Core.data.AjaxStore#event-exception} is detected.
     * The resolved function is passed the event object passed to any event handlers.
     * The rejected function is passed the {@link Core.data.AjaxStore#event-exception} event if an exception occurred,
     * or `false` if the load was vetoed by a {@link Core.data.AjaxStore#event-beforeLoadChildren} handler.
     * @category Tree
     */
    async loadChildren(parentRecord) {
    }
    /**
     * Called from Model when adding children. Not to be called directly, use Model#appendChild() instead.
     * @internal
     * @param {Core.data.mixin.TreeNode} parent
     * @param {Core.data.mixin.TreeNode[]} children
     * @param {Number} index
     * @param {Object} isMove
     * @param {Boolean} [silent]
     * @fires add
     * @fires change
     * @category Tree
     */
    onNodeAddChild(parent, children, index, isMove, silent = false) {
      var _a3;
      const me = this, isRootLoad = parent === me.rootNode && parent.isLoading, { storage } = me, { previousSibling } = children[0];
      let storeInsertionPoint;
      const { visible: toAddToUI, all: toAdd } = me.collectDescendants(children, void 0, void 0, {
        inCollapsedBranch: !(parent.isExpanded(me) && parent.ancestorsExpanded(me)),
        applyFilter: me.isFiltered && me.reapplyFilterOnAdd
      });
      if (!isRootLoad && toAdd.length) {
        for (const record of toAdd) {
          if (!me.modified.includes(record) && !isMove[record.id]) {
            if (me.removed.includes(record)) {
              me.removed.remove(record);
            } else if (!record.isLinked) {
              me.added.add(record);
            }
          }
        }
      }
      if (isRootLoad && me.rootVisible) {
        toAddToUI.unshift(parent);
        toAdd.unshift(parent);
      }
      if (toAddToUI.length) {
        if (index === 0 || !previousSibling) {
          storeInsertionPoint = storage.indexOf(parent);
        } else {
          storeInsertionPoint = storage.indexOf(previousSibling) + previousSibling.getDescendantCount(true, me);
        }
        storage.suspendEvents();
        me.storage.splice(++storeInsertionPoint, 0, toAddToUI);
        storage.resumeEvents();
        me._idMap = null;
      } else {
        me._allRecords = null;
      }
      me.updateDependentStores("add", children);
      if (isRootLoad && toAddToUI.length) {
        if (me.sorters.length) {
          me.sort(null, null, false, true);
        }
        (_a3 = me.afterLoadData) == null ? void 0 : _a3.call(me);
        if (!silent) {
          const event = { action: "dataset", data: me._data, records: toAddToUI };
          me.trigger("refresh", event);
          me.trigger("change", event);
        }
      } else if (!silent) {
        const event = { action: "add", parent, isChild: true, isMove, records: children, allRecords: toAdd, index: storeInsertionPoint };
        me.trigger("add", event);
        me.trigger("change", event);
        if (Object.values(isMove).some((wasMoved) => wasMoved)) {
          const event2 = {
            newParent: parent,
            records: children.filter((record) => isMove[record.id]),
            oldParents: children.map((child) => {
              return me.getById(child.meta.oldParentId);
            })
          };
          me.trigger("move", event2);
        }
      }
    }
    onNodeRemoveChild(parent, children, index, flags = { isMove: false, silent: false, unfiltered: false }) {
      const me = this, { storage } = me, toRemoveFromUI = [], toRemove = [], { isMove, silent, unfiltered } = flags, removeUnfiltered = unfiltered && me.isFiltered, childrenToRemove = removeUnfiltered && parent.unfilteredChildren ? parent.unfilteredChildren : children;
      me.collectDescendants(childrenToRemove, toRemoveFromUI, toRemove, { inCollapsedBranch: !(parent.isExpanded(me) && parent.ancestorsExpanded(me)), unfiltered: removeUnfiltered });
      if (!isMove) {
        for (const record of children) {
          record.unjoinStore(me);
        }
        for (const record of toRemove) {
          if (record.stores.includes(me)) {
            record.unjoinStore(me);
          }
          if (me.added.includes(record)) {
            me.added.remove(record);
          } else if (!record.isLinked) {
            me.removed.add(record);
          }
        }
        me.modified.remove(toRemove);
      }
      if (toRemoveFromUI.length) {
        index = storage.indexOf(toRemoveFromUI[0]);
        if (index > -1) {
          storage.suspendEvents();
          storage.splice(index, toRemoveFromUI.length);
          storage.resumeEvents();
          me._idMap = null;
        }
      } else {
        index = -1;
        me._allRecords = null;
      }
      if (!silent && (me.fireRemoveEventForMoveAction || !isMove)) {
        const event = {
          action: "remove",
          parent,
          isChild: true,
          isMove,
          records: children,
          allRecords: toRemove,
          index
        };
        me.trigger("remove", event);
        me.trigger("change", event);
      }
      return toRemove;
    }
    // IMPORTANT when using `applyFilter` option, should use the return value of this function
    // instead of relying on arguments mutation
    collectDescendants(node, visible = [], all = [], flags = {}) {
      var _a3;
      const me = this, { inCollapsedBranch = false, unfiltered = false, applyFilter = false } = flags, children = Array.isArray(node) ? node : (_a3 = me.getChildren(node, unfiltered)) != null ? _a3 : [];
      if (applyFilter) {
        return {
          visible: children.flatMap((child) => this.collectVisibleNodeDescendantsFiltered(child)),
          all: children.flatMap((child) => child.allChildren)
        };
      } else {
        for (let i = 0, len = children.length, child; i < len; i++) {
          child = children[i];
          if (!inCollapsedBranch) {
            visible.push(child);
          }
          all.push(child);
          me.collectDescendants(child, visible, all, {
            inCollapsedBranch: inCollapsedBranch || !child.isExpanded(me),
            unfiltered
          });
        }
        return { visible, all };
      }
    }
    collectVisibleNodeDescendantsFiltered(node) {
      const children = node.unfilteredChildren || node.children;
      if (!children || children.length === 0 || !node.isLeaf && !node.isExpanded(this)) {
        return this.filtersFunction(node) ? [node] : [];
      }
      const filteredChildren = children.flatMap((child) => this.collectVisibleNodeDescendantsFiltered(child));
      return filteredChildren.length || this.filtersFunction(node) ? [node, ...filteredChildren] : [];
    }
    /**
     * Returns the children of the passed branch node which this store owns. By default, this
     * is the entire `children` array.
     *
     * **If this store {@link Core.data.mixin.StoreChained#property-isChained isChained}**, then
     * this returns only the subset of children which are filtered into this store by the
     * {@link Core.data.mixin.StoreChained#config-chainedFilterFn chainedFilterFn}.
     * @param {Core.data.Model} parent The node to return the children of.
     * @returns {Core.data.Model[]}
     * @category Tree
     */
    getChildren(parent, unfiltered = false) {
      const me = this, children = (unfiltered || me.isChained) && parent.unfilteredChildren || parent.children;
      return !(children == null ? void 0 : children.length) ? emptyArray3 : me.isChained ? children.filter(me.chainedFilterFn).sort(me.sorterFn) : children;
    }
    /**
     * Includes or excludes all records beneath parentRecord in storage. Used when expanding or collapsing
     * nodes.
     * @private
     * @param parentRecord Parent record
     * @param include Include (true) or exclude (false)
     * @category Tree
     */
    internalToggleTreeSubRecords(parentRecord, include) {
      const me = this, { storage } = me, index = storage.indexOf(parentRecord), children = me.doIncludeExclude(me.getChildren(parentRecord), include);
      if (me.isFiltered && include && parentRecord.unfilteredChildren) {
        me.updateChildrenHiddenState(parentRecord);
      }
      if (children.length && index !== false) {
        storage.suspendEvents();
        if (include) {
          storage.splice(index + 1, 0, ...children);
          const event = { action: "add", isExpand: true, records: children, index: index + 1 };
          me.trigger("add", event);
          me.trigger("change", event);
        } else {
          storage.splice(index + 1, children.length);
          const event = { action: "remove", isCollapse: true, records: children, index: index + 1 };
          me.trigger("remove", event);
          me.trigger("change", event);
        }
        storage.resumeEvents();
        me._idMap = null;
      }
    }
    // Updates the hidden flag of its children while store is filtered
    updateChildrenHiddenState(parentRecord) {
      var _a3;
      (_a3 = parentRecord.unfilteredChildren) == null ? void 0 : _a3.forEach((child) => {
        child.instanceMeta(this.id).hidden = false;
        if (!child.isLeaf) {
          this.updateChildrenHiddenState(child);
        }
      });
    }
    doIncludeExclude(children, include, result = []) {
      const me = this, childCount = (children == null ? void 0 : children.length) || 0;
      for (let i = 0; i < childCount; i++) {
        const child = children[i];
        if (!me.isChained || me.chainedFilterFn(child)) {
          const mapMeta = child.instanceMeta(me.id);
          if (include || !mapMeta.hidden) {
            result.push(child);
          }
          mapMeta.hidden = !include;
          if (child.isExpanded(me)) {
            me.doIncludeExclude(me.getChildren(child), include, result);
          }
        }
      }
      return result;
    }
    /**
     * Collapse an expanded record or expand a collapsed. Optionally forcing a certain state.
     * @param {String|Number|Core.data.Model} idOrRecord Record (the record itself) or id of a record to toggle
     * @param {Boolean} [collapse] Force collapse (true) or expand (false)
     * @category Tree
     */
    async toggleCollapse(idOrRecord, collapse) {
      const me = this, record = me.getById(idOrRecord), meta = record.instanceMeta(me);
      if (collapse === void 0) {
        collapse = !meta.collapsed;
      }
      if (!meta.isLoadingChildren && !record.isLeaf && record.isExpanded(me) === collapse) {
        me.trigger("beforeToggleNode", { record, collapse });
        meta.collapsed = collapse;
        if (meta.collapsed) {
          me.onNodeCollapse(record);
          return true;
        } else {
          me.onNodeExpand(record);
          let success = true;
          if (!record.isLoaded) {
            meta.isLoadingChildren = true;
            try {
              await me.loadChildren(record);
            } catch (exception) {
              meta.collapsed = true;
              success = false;
              me.trigger("loadChildrenException", { record, exception });
            } finally {
              meta.isLoadingChildren = false;
            }
          }
          return success;
        }
      }
    }
    /**
     * Remove all records beneath parentRecord from storage.
     * @private
     * @param parentRecord Parent record
     * @category Tree
     */
    onNodeCollapse(parentRecord) {
      if (parentRecord.ancestorsExpanded(this)) {
        return this.internalToggleTreeSubRecords(parentRecord, false);
      }
    }
    /**
     * Add all records beneath parentRecord from storage.
     * @private
     * @param parentRecord Parent record
     * @category Tree
     */
    onNodeExpand(parentRecord) {
      if (parentRecord.ancestorsExpanded(this)) {
        return this.internalToggleTreeSubRecords(parentRecord, true);
      }
    }
    //endregion
    //region Transform flat data
    /**
     * Transforms flat data containing parent ids into tree data
     * @param {Object[]} data Flat raw data
     * @returns {Object[]} Tree data
     * @private
     */
    transformToTree(data) {
      const { parentIdField, idField, childrenField } = this.modelClass, indexById = /* @__PURE__ */ new Map(), parentIds = /* @__PURE__ */ new Set(), transformed = [];
      for (const node of data) {
        const id = node[idField];
        if (id != null) {
          indexById.set(id, node);
        }
        if (node[parentIdField] != null) {
          parentIds.add(node[parentIdField]);
        }
      }
      const cloneParent = (node) => {
        const clone = Object.assign({}, node);
        clone[childrenField] = [];
        indexById.set(clone.id, clone);
        return clone;
      };
      for (let node of data) {
        if (parentIds.has(node.id) && !node[childrenField]) {
          node = cloneParent(node);
        }
        const parentId = node[parentIdField];
        if (parentId != null) {
          let parent = indexById.get(parentId);
          if (parent) {
            if (!parent[childrenField]) {
              parent = cloneParent(parent);
            }
            parent[childrenField].push(node);
          }
        } else {
          if (node[childrenField]) {
            transformed.push(node);
          } else if (node[idField] != null) {
            transformed.push(cloneParent(node));
          } else {
            transformed.push(node);
          }
        }
      }
      return transformed;
    }
    /**
     * Transforms data into a tree with parent levels based on supplied fields.
     *
     * ```javascript
     * const newRoot = store.treeify(['name', r => r.age % 10]);
     * ```
     *
     * Generated parent records are indicated with `generatedParent` and `key` properties. The first one is set to
     * `true` and the latter one has a value for the group the parent represents.
     *
     * @param {Array<String|Function>} fields The field names, or a function to call to extract a value to create parent
     * nodes for records with the same value.
     * @param {Function} [parentTransform] A function which is called to allow the caller to transform the raw data
     * object of any newly created parent nodes.
     * @param {Boolean} [convertParents] Pass `true` to convert raw new parent data objects to this Store's
     * {@link Core.data.Store#config-modelClass}.
     * @returns {Core.data.Model} New root node
     * @internal
     */
    treeify(fields, parentTransform, convertParents = false) {
      const { length } = fields, parents = [], orphans = [], newRoot = {};
      let i, lastParent;
      for (i = 0; i < length; i++) {
        let field2 = fields[i];
        field2 = field2.field || field2;
        if (!fields[i].call) {
          fields[i] = (n) => n[field2];
          fields[i].fieldName = field2;
        }
        parents[i] = /* @__PURE__ */ new Map();
      }
      this.rootNode.traverse((n) => {
        lastParent = null;
        if (n.isLeaf) {
          for (i = 0; i < length; i++) {
            const lastParentPath = (lastParent == null ? void 0 : lastParent.path) || "", nodeMap = parents[i], key = fields[i](n);
            if (key === StopBranch) {
              break;
            }
            const path = `${lastParentPath + ((key == null ? void 0 : key.isModel) ? key.id : key)}/`, id = StringHelper.makeValidDomId(`generated_${path}`, "_"), field2 = fields[i].fieldName, parent = nodeMap.get(id) || nodeMap.set(id, {
              id,
              key,
              path,
              expanded: true,
              readOnly: true,
              children: [],
              generatedParent: true,
              field: field2,
              firstGroupChild: n
            }).get(id);
            if (lastParent && !lastParent.children.includes(parent)) {
              lastParent.children.push(parent);
            }
            lastParent = parent;
          }
          if (lastParent) {
            lastParent.children.push(n);
          } else {
            orphans.push(n);
          }
        }
      }, true);
      if (parentTransform || convertParents) {
        parents.forEach((p) => p.forEach((p2, id, map2) => {
          parentTransform == null ? void 0 : parentTransform(p2);
          if (convertParents) {
            p2 = this.createRecord(p2);
            map2.set(id, p2);
          }
        }));
      }
      newRoot.children = [...parents[0].values(), ...orphans];
      const sort = (n) => {
        if (n.children) {
          n.children.sort((lhs, rhs) => {
            if (lhs.isLeaf === rhs.isLeaf) {
              if (lhs.isLeaf) {
                let result;
                for (let i2 = 0; !result && i2 < length; i2++) {
                  const lv = fields[i2](lhs), rv = fields[i2](rhs);
                  if (lv === StopBranch || rv === StopBranch) {
                    return lhs.isLeaf < rhs.isLeaf ? -1 : lhs.isLeaf > rhs.isLeaf ? 1 : 0;
                  }
                  result = lv < rv ? -1 : rv > lv ? 1 : 0;
                }
                return result;
              } else if (typeof lhs.key === "string" && typeof rhs.key === "string") {
                return lhs.key.localeCompare(rhs.key, void 0, { numeric: true });
              } else {
                return lhs.key < rhs.key ? -1 : lhs.key > rhs.key ? 1 : 0;
              }
            } else {
              return lhs.isLeaf < rhs.isLeaf ? -1 : lhs.isLeaf > rhs.isLeaf ? 1 : 0;
            }
          });
          n.children.forEach(sort);
        }
      };
      sort(newRoot);
      return newRoot;
    }
    //endregion
    treeifyFlatData(data) {
      const { childrenField, parentIdField } = this.modelClass;
      let hasParentId = false, shouldTransform = true;
      for (const node of data) {
        if (node.isModel || Array.isArray(node[childrenField])) {
          shouldTransform = false;
          break;
        }
        if (node[parentIdField] != null) {
          hasParentId = true;
        }
      }
      if (shouldTransform && hasParentId) {
        data = this.transformToTree(data);
      }
      return data;
    }
    /**
     * Increase the indentation level of one or more nodes in the tree
     * @param {Core.data.Model|Core.data.Model[]} nodes The nodes to indent.
     * @fires indent
     * @fires change
     * @category Tree
     */
    async indent(nodes) {
      const me = this;
      nodes = Array.isArray(nodes) ? nodes : [nodes];
      nodes = nodes.filter((node) => {
        let result = Boolean(node.previousSibling);
        while (result && !node.isRoot) {
          result = !nodes.includes(node.parent);
          node = node.parent;
        }
        return result;
      });
      if (nodes.length && me.trigger("beforeIndent", { records: nodes }) !== false) {
        nodes.sort((lhs, rhs) => Wbs.compare(lhs.wbsCode, rhs.wbsCode));
        me.beginBatch();
        for (const node of nodes) {
          const newParent = node.previousSibling;
          newParent.appendChild(node);
          me.toggleCollapse(newParent, false);
        }
        me.endBatch();
        me.trigger("indent", { records: nodes });
        me.trigger("change", {
          action: "indent",
          records: nodes
        });
      }
    }
    /**
     * Decrease the indentation level of one or more nodes in the tree
     * @param {Core.data.Model|Core.data.Model[]} nodes The nodes to outdent.
     * @fires outdent
     * @fires change
     * @category Tree
     */
    async outdent(nodes) {
      const me = this;
      nodes = Array.isArray(nodes) ? nodes : [nodes];
      nodes = nodes.filter((node) => {
        const { parent } = node;
        let result = parent && !parent.isRoot;
        while (result && !node.isRoot) {
          result = !nodes.includes(parent);
          node = node.parent;
        }
        return result;
      });
      if (nodes.length && me.trigger("beforeOutdent", { records: nodes }) !== false) {
        nodes.sort((lhs, rhs) => Wbs.compare(lhs.wbsCode, rhs.wbsCode));
        me.beginBatch();
        for (const node of nodes) {
          const { parent } = node, newChildren = parent.children.slice(parent.children.indexOf(node) + 1);
          parent.parent.insertChild(node, parent.nextSibling);
          node.appendChild(newChildren);
          me.toggleCollapse(node, false);
        }
        me.endBatch();
        me.trigger("outdent", { records: nodes });
        me.trigger("change", {
          action: "outdent",
          records: nodes
        });
      }
    }
  }, __publicField(_a2, "$name", "StoreTree"), /**
   * A special `Symbol` signalizing treeify method that the current record grouping should be stopped.
   *
   * ```javascript
   * const newRoot = workerStore.treeify([
   *     // group workers by company
   *     worker => {
   *         // if the worker is unemployed we don't put it in a group
   *         // we just show such record on the root level
   *         if (!worker.company) {
   *             return Store.StopBranch
   *         }
   *
   *         return worker.company;
   *     ]
   * ]);
   * ```
   * @member {Symbol} StopBranch
   * @static
   * @category Advanced
   */
  __publicField(_a2, "StopBranch", StopBranch), __publicField(_a2, "configurable", {
    /**
     * Set to `true` to on load transform a flat dataset with raw objects containing `parentId` into the format
     * expected for tree data.
     *
     * Example input format:
     *
     * ```javascript
     * [
     *   { id : 1, name : 'Parent' },
     *   { id : 2, name : 'Child', parentId : 1 }
     * ]
     * ```
     *
     * Will be transformed into:
     *
     * ```javascript
     * [
     *   {
     *     id       : 1,
     *     name     : 'Parent',
     *     children : [
     *       { id : 2, name : 'Child', parentId : 1 }
     *     ]
     *   }
     * ]
     * ```
     *
     * @config {Boolean}
     * @category Tree
     */
    transformFlatData: null,
    /**
     * This flag prevents firing of 'remove' event when moving a node in the tree. In 6.0 this will be the default
     * behavior and this flag will be removed.
     * @config {Boolean}
     * @category Tree
     */
    fireRemoveEventForMoveAction: VersionHelper.checkVersion("core", "6.0", "<")
  }), _a2;
};

// ../Core/lib/Core/helper/WalkHelper.js
var WalkHelper = class {
  /**
   * Pre-walks any hierarchical data structure
   *
   * @param {Object} data Walking starting point
   * @param {Function} childrenFn Function to return `data` children entries in an array
   *                   or null if no children exists for the entry
   * @param {Function} fn Function to call on each entry
   */
  static preWalk(data, childrenFn, fn2) {
    const walkStack = [data];
    let node, children;
    while (walkStack.length) {
      node = walkStack.pop();
      fn2(node);
      children = childrenFn(node);
      if (children) {
        walkStack.push.apply(walkStack, children.slice().reverse());
      }
    }
  }
  /**
   * Pre-walks any hierarchical data structure, passing along a link to the parent node
   *
   * @param {Object} data Walking starting point
   * @param {Function} childrenFn Function to return `data` children entries in an array
   *                   or null if no children exists for the entry
   * @param {Function} fn Function to call on each entry, called with `parent` and `node`
   */
  static preWalkWithParent(data, childrenFn, fn2) {
    const walkStack = [{ node: data, parent: null }];
    while (walkStack.length) {
      const { parent, node } = walkStack.pop();
      fn2(parent, node);
      const children = childrenFn(node);
      if (Array.isArray(children)) {
        walkStack.push(...children.slice().reverse().map((child) => ({ node: child, parent: node })));
      }
    }
  }
  /**
   * Pre-walk unordered.
   *
   * Like {@link #function-preWalk-static} but doesn't reverse children before walk,
   * thus children will be walked last child first - first child last
   *
   * @param {Object} data Walking starting point
   * @param {Function} childrenFn Function to return `data` children entries in an array
   *                   or null if no children exists for the entry
   * @param {Function} fn Function to call on each entry
   */
  static preWalkUnordered(data, childrenFn, fn2) {
    const walkStack = [data];
    let node, children;
    while (walkStack.length) {
      node = walkStack[walkStack.length - 1];
      fn2(node);
      children = childrenFn(node);
      if (children) {
        walkStack.splice(walkStack.length - 1, 1, ...children);
      } else {
        walkStack.length = walkStack.length - 1;
      }
    }
  }
  /**
   * Post-walks any hierarchical data structure
   *
   * @param {Object} data Walking starting point
   * @param {Function} childrenFn Function to return `data` children entries in an array
   *                   or null if no children exists for the entry
   * @param {Function} fn Function to call on each entry
   */
  static postWalk(data, childrenFn, fn2) {
    const visited = /* @__PURE__ */ new Map(), walkStack = [data];
    let node, children;
    while (walkStack.length) {
      node = walkStack[walkStack.length - 1];
      if (visited.has(node)) {
        fn2(node);
        walkStack.pop();
      } else {
        children = childrenFn(node);
        if (children) {
          walkStack.push(...children.slice().reverse());
        }
        visited.set(node, node);
      }
    }
  }
  /**
   * Pre-/Post-walks any hierarchical data structure calling inFn each node when it walks in,
   * and outFn when it walks out.
   *
   * @param {Object} data Walking starting point
   * @param {Function} childrenFn Function to return `data` children entries in an array
   *                   or null if no children exists for the entry
   * @param {Function} inFn  Function to call on each entry upon enter
   * @param {Function} outFn Function to call on each entry upon exit
   */
  static prePostWalk(data, childrenFn, inFn, outFn) {
    const visited = /* @__PURE__ */ new Map(), walkStack = [data];
    let node, children;
    while (walkStack.length) {
      node = walkStack[walkStack.length - 1];
      if (visited.has(node)) {
        outFn(node);
        walkStack.pop();
      } else {
        inFn(node);
        children = childrenFn(node);
        if (children) {
          walkStack.push(...children.slice().reverse());
        }
        visited.set(node, node);
      }
    }
  }
};
WalkHelper._$name = "WalkHelper";

// ../Core/lib/Core/data/mixin/StoreSync.js
var StoreSync_default = (Target) => class StoreSync extends (Target || Base2) {
  static get $name() {
    return "StoreSync";
  }
  static get configurable() {
    return {
      /**
       * Configure with `true` to sync loaded data instead of replacing existing with a new dataset.
       *
       * By default (or when configured with `false`) assigning to `store.data` replaces the entire dataset
       * with a new one, creating all new records:
       *
       * ```javascript
       * store.data = [ { id : 1, name : 'Saitama' } ];
       *
       * const first = store.first;
       *
       * store.data = [ { id : 1, name : 'One-Punch man' } ];
       *
       * // store.first !== first;
       * ```
       *
       * When configured with `true` the new dataset is instead synced against the old, figuring out what was
       * added, removed and updated:
       *
       * ```javascript
       * store.data = [ { id : 1, name : 'Saitama' } ];
       *
       * const first = store.first;
       *
       * store.data = [ { id : 1, name : 'One-Punch man' } ];
       *
       * // store.first === first;
       * ```
       *
       * After the sync, any configured sorters, groupers and filters will be reapplied.
       *
       * #### Threshold
       *
       * The sync operation has a configurable threshold, above which the operation will be treated as a
       * batch/refresh and only trigger a single `refresh` event. If threshold is not reached, individual events
       * will be triggered (single `add`, `remove` and possible multiple `update`). To enable the threshold,
       * supply a config object with a `threshold` property instead of `true`:
       *
       * ```javascript
       * const store = new Store({
       *     syncDataOnLoad : {
       *         threshold : '20%'
       *     }
       * });
       * ```
       *
       * `threshold` accepts numbers or strings. A numeric threshold means number of affected records, while a
       * string is used as a percentage of the whole dataset (appending `%` is optional). By default no threshold
       * is used.
       *
       * #### Missing fields
       *
       * The value of any field not supplied in the new dataset is by default kept as is (if record is not removed
       * by the sync). This behaviour is configurable, by setting `keepMissingValues : false` in a config object
       * it will reset any unspecified field back to their default values:
       *
       * ```javascript
       * const store = new Store({
       *     syncDataOnLoad : {
       *         keepMissingValues : false
       *     }
       * });
       * ```
       *
       * Considering the following sync operation:
       *
       * ```javascript
       * // Existing data
       * { id : 1, name : 'Saitama', powerLevel : 100 }
       * // Sync data
       * { id : 1, name : 'One-Punch Man' }
       * ```
       *
       * The result would by default (or when explicitly configured with `true`)  be:
       *
       * ```javascript
       * { id : 1, name : 'One-Punch Man', powerLevel : 100 }
       * ```
       *
       * If configured with `keepMissingValues : false` it would instead be:
       *
       * ```javascript
       * { id : 1, name : 'One-Punch Man' }
       * ```
       *
       * <div class="note">Never enable `syncDataOnLoad` on a chained store, it will create an infinite loop when
       * it is populated from the main store (the main store can use the setting)</div>
       *
       * @config {Boolean|SyncDataOnLoadOptions} syncDataOnLoad
       * @default false
       * @category Common
       */
      syncDataOnLoad: null,
      shouldSyncDataset: null,
      shouldSyncRecord: null
    };
  }
  /**
   * Syncs a new dataset against the already loaded one, only applying changes.
   * Not intended to be called directly, please configure store with `syncDataOnLoad: true` and assign to
   * `store.data` as usual instead.
   *
   * ```
   * const store = new Store({
   *    syncDataOnLoad : true,
   *    data : [
   *        // initial data
   *    ]
   * });
   *
   * store.data = [ // new data ]; //  Difference between initial data and new data will be applied
   * ```
   *
   * @param {Object[]|Core.data.Model[]} data New dataset, an array of records or data objects
   * @private
   */
  syncDataset(data) {
    var _a2;
    const me = this, { storage } = me, idsToCheck = (_a2 = me.shouldSyncDataset) == null ? void 0 : _a2.call(me, { data });
    if (idsToCheck === false) {
      return;
    }
    me.isSyncingDataOnLoad = true;
    const { toAdd, toRemove, toMove, updated, ids } = me.tree ? me.syncTreeDataset(data, idsToCheck) : me.syncFlatDataset(data, idsToCheck);
    let { threshold } = me.syncDataOnLoad, surpassed = false;
    if (threshold) {
      if (typeof threshold === "string") {
        threshold = parseInt(threshold, 10) / 100 * me.count;
      }
      surpassed = toAdd.length + toRemove.length + toMove.length + updated.length > threshold;
    }
    if (me.tree) {
      if (toAdd.length) {
        const added = me.add(toAdd, surpassed);
        added.forEach((node) => node.clearParentId());
      }
      if (toMove.length) {
        for (const { parent, node, index } of toMove) {
          const newParent = me.getById(parent.id);
          newParent.insertChild(node, index);
        }
      }
      me.remove(toRemove, surpassed);
    } else {
      if (surpassed) {
        me.suspendEvents();
      }
      me.remove(toRemove);
      me.add(toAdd);
      if (surpassed) {
        me.resumeEvents();
      }
    }
    if (threshold && !surpassed) {
      updated.forEach(({ record, toSet, wasSet }) => me.onModelChange(record, toSet, wasSet));
    }
    me.acceptChanges();
    const event = { added: toAdd, removed: toRemove, updated, thresholdSurpassed: surpassed };
    if (me.isFiltered && !me.remoteFilter) {
      me.filter({
        silent: me.isRemoteDataLoading
      });
    }
    if (me.isGrouped) {
      me.group(null, null, false, true, me.isRemoteDataLoading);
    } else if (me.isSorted) {
      if (me.remoteSort) {
        storage.replaceValues({
          values: storage.values.sort(me.createSorterFn(me.sorters)),
          silent: true
        });
      } else {
        me.sort();
      }
    } else if (!me.tree) {
      if (storage.values.some((record, index) => record.id !== ids[index])) {
        storage.replaceValues({
          values: storage.values.sort((a, b) => ids.indexOf(a.id) - ids.indexOf(b.id)),
          silent: true
        });
        !surpassed && me.afterPerformSort();
      }
    } else {
      let unsorted = false, i = 0;
      WalkHelper.preWalk(
        me.rootNode,
        (n) => Array.isArray(n.children) && !unsorted ? n.children : null,
        (node) => {
          if (node.id !== ids[i++]) {
            unsorted = true;
          }
        }
      );
      if (unsorted) {
        me.sort((a, b) => ids.indexOf(a.id) - ids.indexOf(b.id), void 0, void 0, true);
        me.clearSorters(true);
        !surpassed && me.afterPerformSort();
      }
    }
    if (surpassed) {
      me.trigger("refresh", {
        action: "batch",
        data,
        records: storage.values,
        syncInfo: event
      });
    }
    me.isSyncingDataOnLoad = false;
    me.trigger("loadSync", event);
  }
  // Used by syncDataset()
  syncFlatDataset(data, idsToCheck) {
    if (!data) {
      return {
        toRemove: this.records
      };
    }
    const me = this, { idField, allFields } = me.modelClass, toRemove = [], toAdd = [], updated = [], usedIds = {}, ids = [], limitedSet = Array.isArray(idsToCheck);
    const { threshold, keepMissingValues } = me.syncDataOnLoad;
    let hitCount = 0;
    data.forEach((rawData) => {
      var _a2;
      rawData = rawData.isModel ? rawData.data : rawData;
      const id = rawData[idField], record = me.getById(id);
      if (!limitedSet || idsToCheck.includes(id)) {
        if (record) {
          if (((_a2 = me.shouldSyncRecord) == null ? void 0 : _a2.call(me, { record, data: rawData })) !== false) {
            if (keepMissingValues === false) {
              for (const field2 of allFields) {
                if (!(field2.dataSource in rawData) && field2.dataSource in record.data) {
                  rawData[field2.dataSource] = field2.defaultValue;
                }
              }
            }
            const wasSet = record.set(rawData, null, Boolean(threshold));
            if (wasSet) {
              updated.push({
                record,
                wasSet,
                toSet: rawData
              });
            }
          }
        } else {
          toAdd.push(me.processRecord(me.createRecord(rawData)));
        }
      }
      if (record) {
        hitCount++;
      }
      usedIds[id] = 1;
      ids.push(id);
    });
    if (hitCount < me.storage.totalCount) {
      if (idsToCheck) {
        for (const id of idsToCheck) {
          if (!usedIds[id]) {
            toRemove.push(me.getById(id));
          }
        }
      } else {
        me.forEach((record) => {
          if (!usedIds[record.id]) {
            toRemove.push(record);
          }
        });
      }
    }
    return { toAdd, toRemove, toMove: [], updated, ids };
  }
  // Used by syncDataset()
  syncTreeDataset(data) {
    if (!data) {
      return {
        toRemove: this.records
      };
    }
    const me = this, {
      idField,
      parentIdField,
      childrenField,
      allFields
    } = me.modelClass, {
      keepMissingValues,
      threshold
    } = me.syncDataOnLoad, toRemove = [], toAdd = [], toMove = [], updated = [], matchedNodes = /* @__PURE__ */ new Set(), ids = [];
    if (me.transformFlatData) {
      data = me.treeifyFlatData(data);
    }
    WalkHelper.preWalkWithParent({ isRoot: true, id: me.rootNode.id, children: data }, (n) => n.children, (parent, rawData) => {
      var _a2;
      if (parent) {
        const { id, node } = me.resolveSyncNode(rawData);
        if (node) {
          if (((_a2 = me.shouldSyncRecord) == null ? void 0 : _a2.call(me, { record: node, data: rawData })) !== false) {
            let childrenUpdated;
            const oldChildrenValue = node.children;
            if (oldChildrenValue !== true && rawData[childrenField] === true) {
              node.clearChildren();
              node.data[childrenField] = node.children = true;
              delete rawData[childrenField];
              me.toggleCollapse(node, true);
              childrenUpdated = true;
            }
            if (node.parent.id !== parent[idField]) {
              toMove.push({
                node,
                parent,
                index: parent[childrenField].indexOf(rawData)
              });
            }
            if (keepMissingValues === false) {
              for (const field2 of allFields) {
                if (field2.name !== "parentId" && !(field2.dataSource in rawData) && field2.dataSource in node.data) {
                  rawData[field2.dataSource] = field2.defaultValue;
                }
              }
            }
            const wasSet = node.set(rawData, null, Boolean(threshold));
            if (wasSet) {
              updated.push({
                record: node,
                wasSet,
                toSet: rawData
              });
            } else if (childrenUpdated) {
              node.signalNodeChanged({
                [childrenField]: {
                  value: true,
                  oldValue: oldChildrenValue
                }
              });
            }
          }
        } else {
          rawData[parentIdField] = parent[idField];
          toAdd.push({ ...rawData, ...Array.isArray(rawData[childrenField]) ? { children: [] } : void 0 });
        }
        matchedNodes.add(node);
        ids.push(id);
      }
    });
    if (matchedNodes.length !== data.length) {
      me.traverse((node) => {
        if (!matchedNodes.has(node)) {
          toRemove.push(node);
        }
      });
    }
    return { toAdd, toRemove, toMove, updated, ids };
  }
  // ColumnStore overrides this fn to allow syncing by field & type
  resolveSyncNode(rawData) {
    const id = rawData[this.modelClass.idField], node = this.getById(id);
    return { id, node };
  }
};

// ../Core/lib/Core/data/stm/mixin/StoreStm.js
var STM_PROP2 = Symbol("STM_PROP");
var StoreStm_default = (Target) => class StoreStm extends (Target || Base2) {
  static get $name() {
    return "StoreStm";
  }
  static get defaultConfig() {
    return {
      /**
       * Reference to STM manager
       *
       * @config {Core.data.stm.StateTrackingManager}
       * @default
       * @category Advanced
       */
      stm: null,
      /**
       * Set to `false` to not record transaction during `applyChangeset` call
       *
       * @prp {Boolean}
       * @default
       * @category Advanced
       */
      ignoreRemoteChangesInSTM: false
    };
  }
  get stm() {
    return this[STM_PROP2];
  }
  set stm(stm) {
    var _a2;
    const me = this;
    if (me.stm !== stm) {
      if ((_a2 = me.stm) == null ? void 0 : _a2.hasStore(me)) {
        me.stm.removeStore(me);
      }
      me[STM_PROP2] = stm;
      if (me.stm && !me.stm.hasStore(me)) {
        me.stm.addStore(me);
      }
    }
  }
  // Overridden to notify STM about flat add action
  add(records, silent = false, options = {}) {
    let result;
    const { stm } = this;
    if (!this.tree && (stm == null ? void 0 : stm.enabled)) {
      result = super.add(records, silent);
      if (result == null ? void 0 : result.length) {
        stm.onStoreModelAdd(this, result, silent);
      }
    } else {
      result = super.add(records, silent, options);
    }
    return result;
  }
  // Overridden to notify STM about flat insert action
  insert(index, records, silent = false) {
    let result;
    const { stm } = this;
    if (!this.tree && (stm == null ? void 0 : stm.enabled)) {
      const context = (Array.isArray(records) ? records : [records]).reduce(
        (context2, r) => {
          const index2 = r instanceof Model ? this.indexOf(r) : void 0;
          if (index2 !== void 0 && index2 !== -1) {
            context2.set(r, index2);
          }
          return context2;
        },
        /* @__PURE__ */ new Map()
      );
      result = super.insert(index, records);
      if (result == null ? void 0 : result.length) {
        index = this.indexOf(result[0]);
        stm.onStoreModelInsert(this, index, result, context, silent);
      }
    } else {
      result = super.insert(index, records, silent);
    }
    return result;
  }
  // Overridden to notify STM about flat removing action
  remove(recordsOrIds, silent = false, fromRemoveChild) {
    let result;
    const { stm } = this;
    if (!this.tree && (stm == null ? void 0 : stm.enabled)) {
      const recordsOrIdsNormalized = (Array.isArray(recordsOrIds) ? recordsOrIds : [recordsOrIds]).map((r) => this.getById(r)).filter((r) => !!r);
      const context = recordsOrIdsNormalized.reduce(
        (context2, r) => {
          const index = this.indexOf(r);
          if (index !== void 0 && index !== -1) {
            context2.set(r, index);
          }
          return context2;
        },
        /* @__PURE__ */ new Map()
      );
      result = super.remove(recordsOrIds, silent, fromRemoveChild);
      if (result == null ? void 0 : result.length) {
        stm.onStoreModelRemove(this, result, context, silent);
      }
    } else {
      result = super.remove(recordsOrIds, silent, fromRemoveChild);
    }
    return result;
  }
  // Overridden to notify STM about flat clear action
  removeAll(silent) {
    const { stm } = this;
    let result;
    if (stm == null ? void 0 : stm.enabled) {
      const { tree, rootNode, allRecords } = this, wasNotEmpty = allRecords.length, records = tree ? rootNode.children.slice() : allRecords.slice();
      result = super.removeAll(silent);
      if (wasNotEmpty && this.count === 0) {
        stm.onStoreRemoveAll(this, records, silent);
      }
    } else {
      result = super.removeAll(silent);
    }
    return result;
  }
  beforeApplyChangeset() {
    const { stm, crudManager } = this;
    let shouldResume = false, transactionId = null;
    if (!(crudManager == null ? void 0 : crudManager.applyingChangeset) && (stm == null ? void 0 : stm.enabled)) {
      shouldResume = true;
      if (stm.isRecording) {
        transactionId = stm.stash();
      }
      if (this.ignoreRemoteChangesInSTM) {
        stm.disable();
      } else {
        stm.startTransaction();
      }
    }
    return { shouldResume, transactionId };
  }
  // When applying changes while STM is in the recording state, first we need to discard local changes, then apply
  // changes from remote, then try to apply local changes. This would emulate starting transaction as if data was
  // already in the correct state
  applyChangeset(changes, transformFn, phantomIdField, remote, logChanges) {
    const {
      shouldResume,
      transactionId
    } = this.beforeApplyChangeset(), log = super.applyChangeset(changes, transformFn, phantomIdField, remote, logChanges);
    this.afterApplyChangeset(shouldResume, transactionId);
    return log;
  }
  afterApplyChangeset(shouldResume, transactionId) {
    if (shouldResume) {
      const { stm } = this;
      if (this.ignoreRemoteChangesInSTM) {
        stm.enable();
      } else {
        stm.stopTransaction();
      }
      stm.applyStash(transactionId);
    }
  }
};

// ../Core/lib/Core/data/Store.js
var dataAddRemoveActions = {
  splice: 1,
  clear: 1
};
var defaultTraverseOptions2 = {
  includeFilteredOutRecords: false,
  includeCollapsedGroupRecords: false
};
var fixTraverseOptions2 = (store, options) => {
  options = options || false;
  if (typeof options === "boolean") {
    options = {
      includeFilteredOutRecords: options,
      includeCollapsedGroupRecords: false
    };
  }
  return options || defaultTraverseOptions2;
};
var Store = class extends Base2.mixin(
  Delayable_default,
  Identifiable_default,
  Events_default,
  Pluggable_default,
  State_default,
  StoreFilter_default,
  StoreChanges_default,
  StoreCRUD_default,
  StoreRelation_default,
  // Private
  StoreSum_default,
  StoreSearch_default,
  StoreSort_default,
  StoreGroup_default,
  StoreChained_default,
  StoreState_default,
  StoreTree_default,
  StoreStm_default,
  StoreSync_default,
  StoreProxy_default
  // Private for now, thus not mentioned in @mixes block above
) {
  //region Config & properties
  static get $name() {
    return "Store";
  }
  static get properties() {
    return {
      relationCache: {},
      dependentStoreConfigs: /* @__PURE__ */ new Map()
    };
  }
  static get configurable() {
    return {
      /**
       * Store's unique identifier.
       *
       * @member {String|Number} id
       * @readonly
       * @category Common
       */
      /**
       * Store's unique identifier. When set the store is added to a store map accessible through
       * `Store.getStore(id)`.
       *
       * @config {String|Number}
       * @category Common
       */
      id: true,
      /**
       * Class used to represent records in the store, should be a subclass of {@link Core.data.Model}. Only
       * applies when supplying data to the store (load, add), any supplied record instances are kept as is.
       *
       * ```javascript
       * class MyModel extends Model {
       *     static get fields() {
       *         return [
       *             'name',
       *             'city',
       *             'company'
       *         ]
       *     }
       * }
       *
       * const store = new Store({
       *     modelClass : MyModel,
       *     data : [
       *         { id : 1, name : 'Mark', city : 'London', company : 'Cool inc' },
       *         ...
       *     ]
       * });
       * ```
       *
       * @config {Core.data.Model}
       * @default
       * @typings {typeof Model}
       * @category Common
       */
      modelClass: Model,
      /**
       * Verify that loaded data does not contain any generated ids. If it does, a warning is logged on console.
       *
       * Set this to `false` to disable the check and give a very minor performance boost.
       *
       * @prp {Boolean}
       * @default
       */
      verifyNoGeneratedIds: true
    };
  }
  static get defaultConfig() {
    return {
      /**
       * An array of field definitions used to create a {@link Core.data.Model} (modelClass) subclass. Optional.
       * If the Model already has fields defined, these fields will extend those.
       *
       * ```javascript
       * const store = new Store({
       *     fields : ['name', 'city', 'company'],
       *     data   : [
       *         { id : 1, name : 'Mark', city : 'London', company : 'Cool inc' },
       *         ...
       *     ]
       * });
       * ```
       *
       * See {@link Core.data.Model} for more info on defining fields, changing data source and mapping fields to
       * nested objects.
       *
       * Note that pre-created record instances supplied to the store are kept as is and thus these fields will
       * not apply to them.
       *
       * @config {Array<String|ModelFieldConfig|Core.data.field.DataField>}
       * @category Common
       */
      fields: null,
      /**
       * Automatically detect from set data if used as tree store or flat store
       * @config {Boolean}
       * @default
       * @category Tree
       */
      autoTree: true,
      /**
       * Raw data to load initially.
       *
       * Expects an array of JavaScript objects, with properties matching store's fields (defined on its
       * {@link #config-modelClass model} or in the {@link #config-fields} config).
       *
       * ```javascript
       * const store = new Store({
       *     data : [
       *         { id : 1, name : 'Linda', city : 'NY' },
       *         { id : 2, name : 'Olivia', city : 'Paris' },
       *         ...
       *     ]
       * });
       * ```
       *
       * @config {Object[]|Core.data.Model[]}
       * @category Common
       */
      data: null,
      /**
       * `true` to act as a tree store.
       * @config {Boolean}
       * @category Tree
       */
      tree: false,
      callOnFunctions: true,
      /**
       * A {@link Core/util/Collection}, or Collection config object
       * to use to contain this Store's constituent records.
       * @config {Core.util.Collection|CollectionConfig}
       * @category Advanced
       */
      storage: null,
      /**
       * Retools the loaded data objects instead of making shallow copies of them. This increases performance but
       * pollutes the incoming data and does not allow remapping of fields (dataSource).
       *
       * Also allows disabling certain steps in data loading, to further improve performance. Either accepts an
       * object with the params described below or `true` which equals `disableDuplicateIdCheck` and
       * `disableTypeConversion`.
       *
       * ```javascript
       * // No duplicate id checking, no type conversions
       * new Store({ useRawData : true });
       *
       * new Store({
       *   // No type conversions only
       *   useRawData : {
       *     disableTypeConversion : true
       *   }
       * });
       * ```
       *
       * @config {Boolean|Object}
       * @param {Boolean} [disableDuplicateIdCheck] Data must not contain duplicate ids, check is bypassed.
       * @param {Boolean} [disableDefaultValue] Default values will not be applied to record fields.
       * @param {Boolean} [disableTypeConversion] No type conversions will be performed on record data.
       * @category Advanced
       */
      useRawData: false,
      /**
       * Specify `false` to prevent loading records without ids, a good practise to enforce when syncing with a
       * backend.
       *
       * By default Store allows loading records without ids, in which case a generated id will be assigned.
       *
       * @config {Boolean}
       * @default true
       * @category Advanced
       */
      allowNoId: true,
      /**
       * Prevent dynamically subclassing the modelClass. It does so by default to not pollute it when exposing
       * properties. Should rarely need to be used.
       * @config {Boolean}
       * @default false
       * @private
       * @category Advanced
       */
      preventSubClassingModel: null
    };
  }
  static get identifiable() {
    return {
      registerGeneratedId: false
    };
  }
  /**
   * Class used to represent records. Defaults to class Model.
   * @member {Core.data.Model} modelClass
   * @typings {typeof Model}
   * @category Records
   */
  //endregion
  //region Events
  /**
   * Fired when the id of a record has changed
   * @event idChange
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model} record Modified record
   * @param {String|Number} oldValue Old id
   * @param {String|Number} value New id
   */
  /**
   * Fired before record is modified in this store.
   * Modification may be vetoed by returning `false` from a handler.
   * @event beforeUpdate
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model} record Modified record
   * @param {Object} changes Modification data
   */
  /**
   * Fired when a record is modified
   * @event update
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model} record Modified record
   * @param {Object} changes Modification data
   */
  /**
   * Fired when one of this Store's constituent records is modified while in
   * {@link Core.data.Model#function-beginBatch batched} state. This may be used to keep
   * UIs up to date while "tentative" changes are made to a record which must not be synced with a server.
   * @event batchedUpdate
   * @private
   */
  /**
   * Fired when the root node is set
   * @event rootChange
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model} oldRoot The old root node.
   * @param {Core.data.Model} rootNode The new root node.
   */
  /**
   * Data in the store was changed. This is a catch-all event which is fired for all changes
   * which take place to the store's data.
   *
   * This includes mutation of individual records, adding and removal of records, as well as
   * setting a new data payload using the {@link #property-data} property, sorting, filtering,
   * and calling {@link Core.data.mixin.StoreCRUD#function-removeAll}.
   *
   * Simple databound widgets may use to the `change` event to refresh their UI without having to add multiple
   * listeners to the {@link #event-update}, {@link Core.data.mixin.StoreCRUD#event-add},
   * {@link Core.data.mixin.StoreCRUD#event-remove}, {@link #event-refresh} and
   * {@link Core.data.mixin.StoreCRUD#event-removeAll} events.
   *
   * A more complex databound widget such as a grid may use the more granular events to perform less
   * destructive updates more appropriate to each type of change. The properties will depend upon the value of the
   * `action` property.
   *
   * @event change
   * @param {Core.data.Store} source This Store.
   * @param {'remove'|'removeAll'|'add'|'updatemultiple'|'clearchanges'|'filter'|'update'|'dataset'|'replace'} action
   * Name of action which triggered the change. May be one of the options listed above
   * @param {Core.data.Model} record Changed record, for actions that affects exactly one record (`'update'`)
   * @param {Core.data.Model[]} records Changed records, passed for all actions except `'removeAll'`
   * @param {Object} changes Passed for the `'update'` action, info on which record fields changed
   */
  // NOTE: When updating params above, also update change event in ProjectModelMixin and dataChange in ProjectConsumer
  /**
   * Data in the store has completely changed, such as by a filter, or sort or load operation.
   * @event refresh
   * @param {Core.data.Store} source This Store.
   * @param {Boolean} batch Flag set to `true` when the refresh is triggered by ending a batch
   * @param {'dataset'|'sort'|'clearchanges'|'filter'|'create'|'update'|'delete'|'group'} action Name of
   * action which triggered the change. May be one of the options listed above.
   */
  //endregion
  /* break doc comment from next method */
  //region Init
  constructor(...args) {
    super(...args);
    if (this.objectify) {
      return this.initProxy();
    }
  }
  construct(config = {}) {
    const me = this;
    Object.assign(me, {
      added: new StoreBag(),
      removed: new StoreBag(),
      modified: new StoreBag(),
      idRegister: {},
      internalIdRegister: {},
      oldIdMap: {}
    });
    if (config.storeId) {
      config = ObjectHelper.assign({ id: config.storeId }, config);
    }
    super.construct(config);
    me.initRelations();
  }
  /**
   * Retrieves/creates a store based on the passed config.
   *
   * | Type              | Result                                                                 |
   * |-------------------|------------------------------------------------------------------------|
   * | Core.data.Store   | Returns supplied store as is                                           |
   * | String            | Retrieves an existing store by id                                      |
   * | Object            | Creates a new store using supplied config object                       |
   * | Object[]          | Creates a new store, populated with records created from supplied data |
   * | Core.data.Model[] | Creates a new store, populated with supplied records                   |
   *
   *
   * @param {Core.data.Store|StoreConfig|String|StoreConfig[]|Core.data.Model[]} config
   * @param {Object} [defaults] Config object to apply when creating a new store for passed data
   * @param {Function} [converterFn] Function called for each data object prior to creating a record from it. The
   * return value is used to create a record.
   * @private
   */
  static from(config, defaults = {}, converterFn = null) {
    if (config && !config.isStore) {
      if (typeof config === "string") {
        config = Store.getStore(config);
      } else {
        if (Array.isArray(config)) {
          if (converterFn) {
            config = config.map((data) => data.isModel ? data : converterFn(data));
          }
          config = ObjectHelper.assign({}, defaults, { data: config });
        }
        config = new Store(config);
      }
    }
    return config;
  }
  doDestroy() {
    var _a2, _b, _c, _d;
    const me = this, allRecords = me.registeredRecords;
    (_b = (_a2 = me.stm) == null ? void 0 : _a2.removeStore) == null ? void 0 : _b.call(_a2, me);
    for (let i = allRecords.length - 1, rec; i >= 0; i--) {
      rec = allRecords[i];
      if (!(rec == null ? void 0 : rec.isDestroyed)) {
        rec.unjoinStore(me);
      }
    }
    (_c = me._storage) == null ? void 0 : _c.destroy();
    if (!me.isChained) {
      (_d = me.rootNode) == null ? void 0 : _d.destroy();
    }
    super.doDestroy();
  }
  /**
   * Stops this store from firing events until {@link #function-endBatch} is called. Multiple calls to `beginBatch`
   * stack up, and will require an equal number of `endBatch` calls to resume events.
   *
   * Upon call of {@link #function-endBatch}, a {@link #event-refresh} event is triggered to allow UIs to
   * update themselves based upon the new state of the store.
   *
   * This is extremely useful when making a large number of changes to a store. It is important not to trigger
   * too many UI updates for performance reasons. Batching the changes ensures that UIs attached to this
   * store are only updated once at the end of the updates.
   */
  beginBatch() {
    this.suspendEvents();
  }
  /**
   * Ends event suspension started by {@link #function-beginBatch}. Multiple calls to {@link #function-beginBatch}
   * stack up, and will require an equal number of `endBatch` calls to resume events.
   *
   * Upon call of `endBatch`, a {@link #event-refresh} event with `action: batch` is triggered to allow UIs to update
   * themselves based upon the new state of the store.
   *
   * This is extremely useful when making a large number of changes to a store. It is important not to trigger
   * too many UI updates for performance reasons. Batching the changes ensures that UIs attached to this
   * store are only updated once at the end of the updates.
   */
  endBatch() {
    if (this.resumeEvents()) {
      this.trigger("refresh", {
        action: "batch",
        data: this.storage.values,
        records: this.storage.values
      });
    }
  }
  set storage(storage) {
    const me = this;
    if (storage == null ? void 0 : storage.isCollection) {
      me._storage = storage;
    } else {
      me._storage = new Collection(storage);
    }
    me._storage.autoFilter = me.reapplyFilterOnAdd;
    me._storage.autoSort = me.reapplySortersOnAdd;
    for (const r of me._storage) {
      r.joinStore(me);
    }
    me._storage.ion({
      change: "onDataChange",
      thisObj: me
    });
  }
  get storage() {
    if (!this._storage) {
      this.storage = {};
    }
    return this._storage;
  }
  /**
   * Returns all records (ignoring any filters) from the store.
   * @property {Core.data.Model[]}
   * @readonly
   * @category Records
   */
  get allRecords() {
    var _a2;
    const me = this;
    if (((_a2 = me._allRecords) == null ? void 0 : _a2.generation) !== me.storage.generation) {
      if (me.isTree) {
        const result = me.collectDescendants(me.rootNode, void 0, void 0, { unfiltered: true }).all;
        if (me.rootVisible) {
          result.unshift(me.rootNode);
        }
        me._allRecords = result;
      } else {
        me._allRecords = me.isGrouped ? me.collectGroupRecords() : me.storage.allValues;
      }
      me._allRecords.generation = me.storage.generation;
    }
    return me._allRecords;
  }
  // All records except special rows such group headers etc
  getAllDataRecords(searchAllRecords) {
    const me = this;
    if (me.tree) {
      return searchAllRecords ? me.allRecords : me.rootNode.allChildren;
    }
    return me.isGrouped ? me.collectGroupRecords(searchAllRecords, false) : searchAllRecords ? me.storage.allValues : me.storage.values;
  }
  /**
   * Called by owned record when the record has its {@link Core.data.Model#property-isCreating}
   * property toggled.
   * @param {Core.data.Model} record The record that is being changed.
   * @param {Boolean} isCreating The new value of the {@link Core.data.Model#property-isCreating} property.
   * @internal
   */
  onIsCreatingToggle(record, isCreating) {
    const me = this, newlyPersistable = record.isPersistable && !isCreating;
    me.added[newlyPersistable ? "add" : "remove"](record);
    if (newlyPersistable) {
      me.trigger("addConfirmed", { record });
      if (me.autoCommit) {
        me.doAutoCommit();
      }
    }
  }
  // Join added records to store, not called when loading
  joinRecordsToStore(records) {
    const { allCount } = this;
    for (let i = 0; i < records.length; i++) {
      const record = records[i];
      record.setData("parentIndex", allCount + i - records.length);
      record.joinStore(this);
    }
  }
  /**
   * Responds to mutations of the underlying storage Collection
   * @param {Object} event
   * @protected
   */
  onDataChange({ source: storage, action, added, removed, replaced, oldCount, items, from, to }) {
    const me = this, isAddRemove = dataAddRemoveActions[action], addedCount = isAddRemove && (added == null ? void 0 : added.length), removedCount = isAddRemove && (removed == null ? void 0 : removed.length);
    let filtersWereReapplied, sortersWereReapplied;
    me._idMap = null;
    if (addedCount) {
      me.joinRecordsToStore(added);
    }
    replaced == null ? void 0 : replaced.forEach(([oldRecord, newRecord]) => {
      oldRecord.unjoinStore(me, true);
      newRecord.joinStore(me);
    });
    super.onDataChange(...arguments);
    if (!me.isTree) {
      if (addedCount) {
        for (const record of added) {
          if (me.removed.includes(record)) {
            me.removed.remove(record);
          } else if (!record.isLinked) {
            me.added.add(record);
          }
        }
        filtersWereReapplied = !me.remoteFilter && me.isFiltered && me.reapplyFilterOnAdd;
        if (filtersWereReapplied) {
          me.filter({
            silent: true
          });
        }
        sortersWereReapplied = !me.remoteSort && me.isSorted && me.reapplySortersOnAdd;
        if (sortersWereReapplied) {
          me.sort(null, null, false, true);
        }
      }
      if (removedCount) {
        for (const record of removed) {
          record.cancelBatch();
          record.unjoinStore(me);
          if (me.added.includes(record)) {
            me.added.remove(record);
          } else if (!record._undoingInsertion && !record.isCreating && !record.isLinked) {
            me.removed.add(record);
          }
        }
        me.modified.remove(removed);
        filtersWereReapplied = !me.remoteFilter && me.isFiltered;
        if (filtersWereReapplied) {
          me.filter({
            silent: true
          });
        }
      }
    }
    switch (action) {
      case "clear":
        me.relationCache = {};
        me.updateDependentStores("removeall");
        me.trigger("removeAll");
        me.trigger("change", {
          action: "removeall"
        });
        break;
      case "splice":
        if (addedCount) {
          me.updateDependentStores("add", added);
          const oldIndex = added.reduce((lowest, record) => {
            const { previousIndex } = record.meta;
            if (previousIndex > -1 && previousIndex < lowest)
              lowest = previousIndex;
            return lowest;
          }, added[0].meta.previousIndex), index = storage.indexOf(added[0], !storage.autoFilter), params = {
            records: added,
            index
          };
          if (oldIndex > -1) {
            params.oldIndex = oldIndex;
          }
          me.trigger("add", params);
          me.trigger("change", Object.assign({ action: "add" }, params));
          if (filtersWereReapplied) {
            me.triggerFilterEvent({
              action: "filter",
              filters: me.filters,
              oldCount,
              records: me.storage.allValues
            });
          }
          if (sortersWereReapplied) {
            me.trigger("sort", { action: "sort", sorters: me.sorters, records: me.storage.allValues });
          }
        }
        if (removed.length) {
          me.updateDependentStores("remove", removed);
          me.trigger("remove", {
            records: removed
          });
          me.trigger("change", {
            action: "remove",
            records: removed
          });
        }
        if (replaced.length) {
          me.trigger("replace", {
            records: replaced,
            all: me.records.length === replaced.length
          });
          me.trigger("change", {
            action: "replace",
            replaced,
            all: me.records.length === replaced.length
          });
        }
        break;
      case "filter":
        if (me.isGrouped || me.isSorted) {
          me.performSort(true);
        }
        break;
      case "move": {
        const start = Math.min(from, to), end = Math.min(me.storage.allValues.length - 1, Math.max(from, to));
        for (let allRecords = me.storage.allValues, i = start; i <= end; i++) {
          allRecords[i].setData("parentIndex", i);
        }
        me.trigger("move", {
          record: items[0],
          records: items,
          from,
          to
        });
        if (me.isFiltered) {
          me.performFilter();
        }
        me.trigger("change", {
          action,
          record: items[0],
          records: items,
          from,
          to
        });
        break;
      }
    }
  }
  onDataReplaced(action, data) {
    var _a2;
    const me = this, { storage } = me, all = storage.allValues, sorted = Boolean(me.sorters.length > 0);
    for (let i = 0; i < all.length; i++) {
      all[i].joinStore(me);
    }
    if (!me.remoteFilter && me.isFiltered) {
      me.filter({
        silent: true
      });
    }
    if (me.remoteSort) {
      if (me.isGrouped) {
        storage.replaceValues({
          // Need to update group records info (headers and footers)
          ...me.prepareGroupRecords(),
          silent: true
        });
      }
    } else {
      if (me.isGrouped) {
        me.group(null, null, false, !sorted, true);
      }
      if (sorted) {
        me.sort(null, null, false, true);
      }
    }
    if (!me.useRawData.disableDuplicateIdCheck) {
      const { idMap } = me;
      if (Object.keys(idMap).length < storage.values.length) {
        const collisions = [];
        storage.values.forEach((r) => idMap[r.id] ? delete idMap[r.id] : collisions.push(r));
        throw new Error(`Id collision on ${collisions.map((r) => r.id)}`);
      }
    }
    const event = { action, data, records: storage.values };
    me.updateDependentStores(action, event.records);
    (_a2 = me.afterLoadData) == null ? void 0 : _a2.call(me);
    if (!me.isRemoteDataLoading) {
      me.trigger("refresh", event);
    }
    me.trigger("change", event);
  }
  /**
   * This is called from Model after mutating any fields so that Stores can take any actions necessary at that point,
   * and distribute mutation event information through events.
   * @param {Core.data.Model} record The record which has just changed
   * @param {Object} toSet A map of the field names and values that were passed to be set
   * @param {Object} wasSet A map of the fields that were set. Each property is a field name, and
   * the property value is an object containing two properties: `oldValue` and `value` eg:
   * ```javascript
   *     {
   *         name {
   *             oldValue : 'Rigel',
   *             value : 'Nigel'
   *         }
   *     }
   *
   * @param {Boolean} silent Do not trigger events
   * @param {Boolean} fromRelationUpdate Update caused by a change in related model
   * @private
   */
  onModelChange(record, toSet, wasSet, silent, fromRelationUpdate) {
    const me = this, event = {
      record,
      records: [record],
      changes: wasSet,
      // Cannot use isBatching, since change is triggered when batching has reached 0
      // (but before it is set to null)
      batch: record.batching != null,
      fromRelationUpdate
    }, committable = record.ignoreBag || record.isLinked ? false : me.updateModifiedBagForRecord(record);
    me.storage.onItemMutation(record, wasSet);
    if ("id" in wasSet) {
      const { oldValue, value } = toSet.id;
      me.updateDependentRecordIds(oldValue, value);
      me.onRecordIdChange({ record, oldValue, value });
    }
    if (!silent) {
      if ("id" in wasSet) {
        const { oldValue, value } = toSet.id;
        me.trigger("idChange", {
          store: me,
          record,
          oldValue,
          value
        });
      }
      me.onUpdateRecord(record, wasSet);
      me.trigger("update", event);
      me.trigger("change", Object.assign({ action: "update" }, event));
    }
    if (me.autoCommit && committable) {
      me.doAutoCommit();
    }
  }
  updateModifiedBagForRecord(record) {
    const me = this;
    let addedToBag = false;
    if (record.isModified) {
      if (!me.modified.includes(record) && !me.added.includes(record) && record.isPartOfStore(me) && !record.isAutoRoot) {
        if (record.isPhantom) {
          me.added.add(record);
        } else {
          me.modified.add(record);
        }
        addedToBag = true;
      }
    } else {
      me.modified.remove(record);
    }
    return addedToBag;
  }
  get idMap() {
    const me = this, needsRebuild = !me._idMap, idMap = me._idMap || (me._idMap = {});
    if (needsRebuild) {
      const processedRecords = me.storage.values;
      for (let record, index = 0, visibleIndex = 0; index < processedRecords.length; index++) {
        record = processedRecords[index];
        idMap[record.id] = { index, visibleIndex, record };
        if (!record.isSpecialRow) {
          visibleIndex++;
        }
      }
      if (me.isFiltered) {
        for (let index = 0, l = me.storage._values.length; index < l; index++) {
          const record = me.storage._values[index];
          if (record.id in idMap) {
            idMap[record.id].unfilteredIndex = index;
          } else {
            idMap[record.id] = { index: -1, unfilteredIndex: index, record };
          }
        }
      }
    }
    return idMap;
  }
  changeModelClass(ClassDef) {
    const { fields } = this;
    this.originalModelClass = ClassDef;
    let ClassDefEx = ClassDef;
    if (fields == null ? void 0 : fields.length) {
      class ModelClass extends ClassDef {
        static get fields() {
          return fields;
        }
      }
      ClassDefEx = ModelClass;
    } else if (!this.preventSubClassingModel) {
      class ModelClass extends ClassDef {
      }
      ClassDefEx = ModelClass;
    }
    ClassDefEx.initClass();
    return ClassDefEx;
  }
  //endregion
  //region Store id & map
  set storeId(storeId) {
    this.id = storeId;
  }
  get storeId() {
    return this.id;
  }
  changeId(id, oldId) {
    return super.changeId(id !== true && id, oldId);
  }
  updateId(id, oldId) {
    const duplicate = Store.getById(id);
    duplicate && Store.unregisterInstance(duplicate);
    super.updateId(id, oldId);
  }
  generateAutoId() {
    return Store.generateId(`store-`);
  }
  get tree() {
    return this._tree;
  }
  set tree(tree) {
    this._tree = tree;
    if (tree && !this.rootNode) {
      this.rootNode = this.buildRootNode();
      this.rootNode.isAutoRoot = true;
    }
  }
  // a hook to build a customized root node
  buildRootNode() {
    return {};
  }
  /**
   * Get a store from the store map by id.
   * @param {String|Number|Object[]} id The id of the store to retrieve, or an array of objects
   * from which to create the contents of a new Store.
   * @returns {Core.data.Store} The store with the specified id
   */
  static getStore(id, storeClass) {
    if (id instanceof Store) {
      return id;
    }
    if (this.getById(id)) {
      return this.getById(id);
    }
    if (Array.isArray(id)) {
      let storeModel;
      const storeData = id.map((item) => {
        if (item instanceof Model) {
          storeModel = item.constructor;
        } else if (typeof item === "string") {
          item = {
            text: item
          };
        } else {
        }
        return item;
      });
      if (!storeModel) {
        class ModelClass extends Model {
        }
        storeModel = ModelClass;
      }
      id = {
        autoCreated: true,
        data: storeData,
        modelClass: storeModel,
        allowNoId: true
        // String items have no id and are not guaranteed to be unique
      };
      if (!storeClass) {
        storeClass = Store;
      }
    }
    if (storeClass) {
      return new storeClass(id);
    }
  }
  /**
   * Get all registered stores
   * @property {Core.data.Store[]}
   */
  static get stores() {
    return Store.registeredInstances;
  }
  //endregion
  //region Data
  /**
   * The invisible root node of this tree.
   * @property {Core.data.Model}
   * @readonly
   * @category Tree
   */
  get rootNode() {
    return this.masterStore ? this.masterStore.rootNode : this._rootNode;
  }
  set rootNode(rootNode) {
    var _a2;
    const me = this, oldRoot = me._rootNode;
    if (rootNode === oldRoot) {
      return;
    }
    if (oldRoot) {
      me.clear(true);
    }
    if (rootNode instanceof Model) {
      rootNode.instanceMeta(me).collapsed = false;
      me._rootNode = rootNode;
    } else {
      me._rootNode = rootNode = new me.modelClass(Object.assign({
        expanded: true,
        [me.modelClass.idField]: `${me.id}-rootNode`
      }, rootNode), me, null, true);
    }
    me._tree = true;
    rootNode.isRoot = true;
    rootNode.joinStore(me);
    if (((_a2 = rootNode.children) == null ? void 0 : _a2.length) || me.rootVisible) {
      rootNode.isLoading = true;
      me.onNodeAddChild(rootNode, rootNode.children || [], 0);
      rootNode.isLoading = false;
    }
    me.trigger("rootChange", { oldRoot, rootNode });
  }
  /**
   * Sets data in the store.
   *
   * Expects an array of JavaScript objects, with properties matching store's fields (defined on its
   * {@link #config-modelClass model} or in the {@link #config-fields} config).
   *
   * Called on initialization if data is in config otherwise call it yourself after ajax call etc. Can also be used to
   * get the raw original data.
   *
   * ```javascript
   * store.data = [
   *     { id : 1, name : 'Linda', city : 'NY' },
   *     { id : 2, name : 'Olivia', city : 'Paris' },
   *     ...
   * ];
   * ```
   *
   * @property {Object[]}
   * @fires refresh
   * @fires change
   * @category Records
   */
  set data(data) {
    this.setStoreData(data);
  }
  // For overridability in engine
  setStoreData(data) {
    const me = this, { idField, childrenField } = me.modelClass;
    if (me.transformFlatData && (data == null ? void 0 : data.length) > 0 && !Object.isExtensible(data[0])) {
      me.useRawData = me.useRawData || {
        disableDuplicateIdCheck: false,
        disableDefaultValue: false,
        disableTypeConversion: false
      };
      data = ObjectHelper.clone(data);
    }
    me.getConfig("plugins");
    me.processConfiguredListeners();
    if (data && !Array.isArray(data)) {
      data = ObjectHelper.transformNamedObjectToArray(data, idField);
    }
    me.tree = !me.isChained && (me.tree || Boolean(me.autoTree && (data == null ? void 0 : data.some((r) => r[childrenField]))));
    if (data && (me.remoteSort || me.remoteFilter)) {
      for (let i = 0; i < data.length; i++) {
        data[i]._remoteSortIndex = i;
      }
    }
    if (!me.syncDataOnLoad || !me._data) {
      me._data = data;
      if (me.tree) {
        if (me.transformFlatData) {
          data = me.treeifyFlatData(data);
        }
        const root = me.rootNode;
        root.isLoading = true;
        me.clear(true);
        root.appendChild(data);
        me.updateDependentStores("dataset", [root]);
        root.isLoading = false;
        if (data.length === 0) {
          const event = { action: "dataset", data: [], records: [] };
          me.trigger("refresh", event);
          me.trigger("change", event);
        } else if (me.isFiltered) {
          me.filter();
        }
      } else {
        me.loadData(data);
      }
      me.added.clear();
      me.removed.clear();
      me.modified.clear();
    } else {
      me.syncDataset(data);
    }
  }
  loadData(data, action = "dataset") {
    var _a2, _b;
    const me = this, { storage, allowNoId } = me, idField = me.modelClass.fieldMap.id.dataSource, creatingRecord = me.find((rec) => rec.isCreating);
    if (creatingRecord) {
      storage.values.splice(me.records.indexOf(creatingRecord), 1);
    }
    let warnGenerated = me.verifyNoGeneratedIds;
    me.removeHeadersAndFooters(me.storage.values);
    me._idMap = null;
    me.oldIdMap = {};
    if (data) {
      const isRaw = !(data[0] instanceof Model);
      if (isRaw) {
        me.modelClass.exposeProperties(data[0]);
        const count = data.length, records = new Array(count);
        for (let i = 0; i < count; i++) {
          const recordData = data[i];
          if (!allowNoId && recordData[idField] == null) {
            throw new Error(`Id required but not found on row ${i}`);
          }
          if (warnGenerated && ((_b = (_a2 = recordData[idField]) == null ? void 0 : _a2.startsWith) == null ? void 0 : _b.call(_a2, "_generated"))) {
            console.warn(`Generated id found in data: ${recordData[idField]}. Generated ids are temporary and should be replaced with real ids by the backend`);
            warnGenerated = false;
          }
          records[i] = me.processRecord(me.createRecord(recordData, true), true);
          records[i].setData("parentIndex", i);
        }
        me.clear(true);
        storage.replaceValues({
          values: records,
          isNewDataset: true,
          silent: true
        });
      } else {
        me.clear(true);
        storage.replaceValues({
          values: data.slice(),
          isNewDataset: true,
          silent: true
        });
      }
      if (creatingRecord && !storage.values.includes(creatingRecord)) {
        storage.values.push(creatingRecord);
      }
      me._data = data;
      me.onDataReplaced(action, data);
    } else {
      me.clear(true);
      me._data = null;
    }
    me.isSyncingDataOnLoad = false;
  }
  get data() {
    return this._data;
  }
  /**
   * Creates an array of records from this store from the `start` to the `end' - 1
   * @param {Number} [start] The index of the first record to return
   * @param {Number} [end] The index *after* the last record to return `(start + length)`
   * @returns {Core.data.Model[]} The requested records.
   * @category Records
   */
  getRange(start, end, all = true) {
    return (all ? this.storage.allValues : this.storage.values).slice(start, end);
  }
  /**
   * Creates a model instance, used internally when data is set/added. Override this in a subclass to do your own custom
   * conversion from data to record.
   * @param {Object} data Json data
   * @param {Boolean} [skipExpose=false] Supply true when batch setting to not expose properties multiple times
   * @category Records
   */
  createRecord(data, skipExpose = false, rawData = false) {
    return new this.modelClass(data, this, null, skipExpose, false, rawData);
  }
  processRecord(record, isDataset = false) {
    return record;
  }
  refreshData() {
    this.filter();
    this.sort();
  }
  onRecordIdChange({ record, oldValue, value }) {
    const me = this, idMap = me._idMap, { idRegister, oldIdMap } = me;
    me.storage._indicesInvalid = true;
    oldIdMap[oldValue] = record;
    if (idMap && !idMap[value]) {
      const entry = idMap[oldValue];
      delete idMap[oldValue];
      idMap[value] = entry;
    }
    me.added.changeId(oldValue, value);
    me.removed.changeId(oldValue, value);
    me.modified.changeId(oldValue, value);
    delete idRegister[oldValue];
    idRegister[value] = record;
    record.index = me.storage.indexOf(record);
  }
  onUpdateRecord(record, changes) {
    const me = this, { internalId } = changes, { internalIdRegister } = me;
    if (internalId) {
      this.storage._indicesInvalid = true;
      delete internalIdRegister[internalId.oldValue];
      internalIdRegister[internalId.value] = record;
    }
    if (me.reapplyFilterOnUpdate && me.isFiltered) {
      me.filter();
    }
  }
  get useRawData() {
    return this._useRawData;
  }
  set useRawData(options) {
    if (options === true) {
      this._useRawData = {
        enabled: true,
        disableDuplicateIdCheck: true,
        disableTypeConversion: true,
        disableDefaultValue: false
      };
    } else {
      this._useRawData = options ? Object.assign(options, { enabled: true }) : { enabled: false };
    }
  }
  //endregion
  //region Count
  /**
   * Number of records in the store
   * @param {Boolean} [countProcessed] Count processed (true) or real records (false)
   * @returns {Number} Record count
   * @category Records
   */
  getCount(countProcessed = true) {
    return countProcessed ? this.count : this.originalCount;
  }
  /**
   * Record count, for data records. Not including records added for group headers etc.
   * @property {Number}
   * @readonly
   * @category Records
   */
  get originalCount() {
    var _a2;
    return this.storage.totalCount - (((_a2 = this.groupRecords) == null ? void 0 : _a2.length) || 0);
  }
  /**
   * Record count, including records added for group headers etc.
   * @property {Number}
   * @readonly
   * @category Records
   */
  get count() {
    return this.storage.count;
  }
  /**
   * Returns the complete dataset size regardless of tree node collapsing or filtering
   * @property {Number}
   * @readonly
   * @category Records
   */
  get allCount() {
    return this.isTree ? this.rootNode.descendantCount : this.storage.totalCount;
  }
  //endregion
  //region Get record(s)
  /**
   * Returns all "visible" records.
   * **Note:** The returned value **may not** be mutated!
   * @property {Core.data.Model[]}
   * @readonly
   * @immutable
   * @category Records
   */
  get records() {
    return this.storage.values;
  }
  /**
   * Get the first record in the store.
   * @property {Core.data.Model}
   * @readonly
   * @category Records
   */
  get first() {
    return this.storage.values[0];
  }
  /**
   * Get the last record in the store.
   * @property {Core.data.Model}
   * @readonly
   * @category Records
   */
  get last() {
    return this.storage.values[this.storage.values.length - 1];
  }
  /**
   * Get the record at the specified index
   * @param {Number} index Index for the record
   * @returns {Core.data.Model} Record at the specified index
   * @category Records
   */
  getAt(index, all = false) {
    return this.storage.getAt(index, all);
  }
  // These are called by Model#join and Model#unjoin
  // register a record as a findable member keyed by id and internalId
  register(record) {
    const me = this;
    if (!me.useRawData.disableDuplicateIdCheck) {
      const existingRec = me.isTree && me.idRegister[record.id];
      if (existingRec && existingRec !== record) {
        throw new Error(`Id collision on ${record.id}`);
      }
    }
    me.idRegister[record.id] = record;
    me.internalIdRegister[record.internalId] = record;
  }
  unregister(record) {
    delete this.idRegister[record.id];
    delete this.internalIdRegister[record.internalId];
  }
  get registeredRecords() {
    return Object.values(this.idRegister);
  }
  /**
   * Get a record by id. Find the record even if filtered out, part of collapsed group or collapsed node
   * @param {Core.data.Model|String|Number} id Id of record to return.
   * @returns {Core.data.Model} A record with the specified id
   * @category Records
   */
  getById(id) {
    if (id == null ? void 0 : id.isModel) {
      const record = id;
      if (record.hasLinks && !this.storage.allValues.includes(record)) {
        return record.$links.find((r) => this.storage.allValues.includes(r));
      }
      return record;
    }
    return this.idRegister[id];
  }
  /**
   * Checks if a record is available, in the sense that it is not filtered out,
   * hidden in a collapsed group or in a collapsed node.
   * @param {Core.data.Model|String|Number} recordOrId Record to check
   * @returns {Boolean}
   * @category Records
   */
  isAvailable(recordOrId) {
    const record = this.getById(recordOrId);
    return record && this.storage.includes(record) || false;
  }
  /**
   * Get a record by internalId.
   * @param {Number} internalId The internalId of the record to return
   * @returns {Core.data.Model} A record with the specified internalId
   * @category Records
   */
  getByInternalId(internalId) {
    return this.internalIdRegister[internalId];
  }
  /**
   * Checks if the specified record is contained in the store
   * @param {Core.data.Model|String|Number} recordOrId Record, or `id` of record
   * @returns {Boolean}
   * @category Records
   */
  includes(recordOrId) {
    if (this.isTree) {
      return this.idRegister[Model.asId(recordOrId)] != null;
    }
    return this.indexOf(recordOrId) > -1;
  }
  //endregion
  //region Get index
  /**
   * Returns the index of the specified record/id, or `-1` if not found.
   * @param {Core.data.Model|String|Number} recordOrId Record, or `id` of record to return the index of.
   * @param {Boolean} [visibleRecords] Pass `true` to find the visible index.
   * as opposed to the dataset index. This omits group header records.
   * @param {Boolean} [allExceptFilteredOutRecords] For trees, when true this searches all except filtered out records
   * in the flattened tree, similar to a flat store.
   * @returns {Number} Index for the record/id, or `-1` if not found.
   * @category Records
   */
  indexOf(recordOrId, visibleRecords = false, allExceptFilteredOutRecords = false) {
    if ((recordOrId == null ? void 0 : recordOrId.isModel) && !recordOrId.stores.includes(this.$store || this)) {
      const linkedRecord = recordOrId.$links.find((r) => this.storage.allValues.includes(r));
      if (linkedRecord) {
        return this.indexOf(linkedRecord, visibleRecords);
      }
      return -1;
    }
    if (this.isTree) {
      return (allExceptFilteredOutRecords ? this.rootNode.allChildren : this.storage.values).indexOf(this.getById(recordOrId));
    }
    const id = Model.asId(recordOrId);
    if (id == null) {
      return -1;
    }
    const found = this.idMap[id];
    return found ? found[visibleRecords ? "visibleIndex" : "index"] : -1;
  }
  allIndexOf(recordOrId) {
    if (this.isTree) {
      return this.allRecords.indexOf(this.getById(recordOrId));
    } else {
      return this.storage.indexOf(recordOrId, true);
    }
  }
  //endregion
  //region Get values
  /**
   * Returns an array of distinct values for the specified field.
   *
   * ```javascript
   * store.getDistinctValues('age'); // Returns an array of the unique age values
   * ```
   *
   * @param {String} field Field to extract values for
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters
   * @returns {Array} Array of values
   * @category Values
   */
  getDistinctValues(field2, searchAllRecords = false) {
    const me = this, values = [], keys = {};
    let value;
    me.forEach((r) => {
      if (!r.isSpecialRow && !r.isRoot) {
        value = r.getValue(field2);
        const primitiveValue = value instanceof Date ? value.getTime() : value;
        if (!keys[primitiveValue]) {
          values.push(value);
          keys[primitiveValue] = 1;
        }
      }
    }, me, searchAllRecords);
    return values;
  }
  /**
   * Counts how many times the specified value appears in the store
   * @param {String} field Field to look in
   * @param {*} value Value to look for
   * @returns {Number} Found count
   * @category Values
   */
  getValueCount(field2, value) {
    let count = 0;
    this.forEach((r) => {
      if (ObjectHelper.isEqual(r.getValue(field2), value))
        count++;
    });
    return count;
  }
  //endregion
  //region JSON & console
  /**
   * Retrieve or set the data of all records as a JSON string
   *
   * ```javascript
   * const store = new Store({
   *     data : [
   *         { id : 1, name : 'Superman' },
   *         { id : 2, name : 'Batman' }
   *     ]
   * });
   *
   * const jsonString = store.json;
   *
   * //jsonString:
   * '[{"id":1,"name":"Superman"},{"id":2,"name":"Batman"}]
   * ```
   *
   * @property {String}
   */
  set json(json) {
    if (typeof json === "string") {
      json = StringHelper.safeJsonParse(json);
    }
    this.data = json;
  }
  get json() {
    return StringHelper.safeJsonStringify(this);
  }
  /**
   * Pretty printed version of {@link #property-json}
   * @readonly
   * @property {String}
   */
  get formattedJSON() {
    return StringHelper.safeJsonStringify(this, null, 4);
  }
  /**
   * Retrieve the data of all (unfiltered) records as an array of JSON objects.
   *
   * ```javascript
   * const store = new Store({
   *     data : [
   *         { id : 1, name : 'Superman' },
   *         { id : 2, name : 'Batman' }
   *     ]
   * });
   *
   * const jsonArray = store.toJSON();
   *
   * //jsonArray:
   * [{id:1,name:"Superman"},{id:2,name:"Batman"}]
   * ```
   *
   * @returns {Object[]}
   */
  toJSON() {
    return (this.isTree ? this.rootNode.unfilteredChildren || this.rootNode.children || [] : this.allRecords).map((record) => record.toJSON());
  }
  //endregion
  //region Extract config
  // These functions are not meant to be called by any code other than Base#getCurrentConfig()
  preProcessCurrentConfigs(configs) {
    super.preProcessCurrentConfigs(configs);
    delete configs.project;
  }
  // Extract current data for all accessible records
  getInlineData(options) {
    var _a2;
    const data = [];
    if (this.tree) {
      (_a2 = this.rootNode.children) == null ? void 0 : _a2.forEach((r) => data.push(r.getCurrentConfig(options)));
    } else {
      this.forEach((r) => data.push(r.getCurrentConfig(options)));
    }
    return data;
  }
  // Extract current configs and data
  getCurrentConfig(options) {
    var _a2;
    const result = super.getCurrentConfig(options), { state } = this;
    if (result) {
      if (result.data) {
        result.data = this.getInlineData(options);
      }
      delete result.project;
      delete result.stm;
      delete result.asyncEvents;
      if (((_a2 = result.modelClass) == null ? void 0 : _a2.$meta.hierarchy[result.modelClass.$meta.hierarchy.length - 2]) === this.constructor.defaultConfig.modelClass) {
        delete result.modelClass;
      }
      if (!this.tree) {
        delete result.tree;
      }
      if (state) {
        Object.assign(result, state);
      }
    }
    return result;
  }
  //endregion
  //region Iteration & traversing
  /**
   * Iterates over all normal records in store. Omits group header and footer records if this store is grouped.
   * @param {Function} fn A function that is called for each record. Returning `false` from that function cancels
   * iteration. It is called with the following arguments:
   * @param {Core.data.Model} fn.record Current record
   * @param {Number} fn.index Current index
   * @param {Object} [thisObj] `this` reference for the function
   * @param {Object|Boolean} [options] A boolean for `includeFilteredOutRecords`, or detailed options for
   * exclude/include records
   * @param {Boolean} [options.includeFilteredOutRecords] `true` to also include filtered out records
   * @param {Boolean} [options.includeCollapsedGroupRecords] `true` to also include records from collapsed groups of
   * grouped store
   * @category Iteration
   */
  forEach(fn2, thisObj = this, options) {
    const me = this, callback = (r, i) => {
      if (!r.isRoot && !r.isSpecialRow) {
        return fn2.call(thisObj, r, i);
      }
    };
    options = fixTraverseOptions2(me, options);
    if (me.isTree) {
      if (me.isChained) {
        options = {
          ...options,
          sorterFn: me.sorterFn
        };
      }
      me.rootNode.traverseWhile(callback, false, options);
    } else {
      const records = options.includeFilteredOutRecords ? me.storage.allValues : me.storage.values;
      if (me.isGrouped && options.includeCollapsedGroupRecords) {
        for (let i = 0; i < records.length; i++) {
          const record = records[i], groupChildren = options.includeFilteredOutRecords ? record.unfilteredGroupChildren : record.groupChildren;
          if (groupChildren && record.meta.collapsed === true) {
            for (let j = 0; j < groupChildren.length; j++) {
              const rec = groupChildren[j];
              if (callback(rec, j) === false) {
                return;
              }
            }
          } else if (callback(record, i) === false) {
            return;
          }
        }
      } else {
        for (let i = 0; i < records.length; i++) {
          if (callback(records[i], i) === false) {
            return;
          }
        }
      }
    }
  }
  /**
   * Equivalent to Array.map(). Creates a new array with the results of calling a provided function on every record
   * @param {Function} fn
   * @param {Object} [thisObj] The `this` reference to call the function with. Defaults to this Store
   * @returns {Array}
   * @category Iteration
   */
  map(fn2, thisObj = this) {
    return this.storage.values.map(fn2, thisObj);
  }
  /**
   * Equivalent to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap Array.flatMap()}.
   * Creates a new array by spreading the results of calling a provided function on every record
   * @param {Function} fn A function returning an array of items to be spread into the new array, or a single item to include in it
   * @param {Object} [thisObj] The `this` reference to call the function with. Defaults to this Store
   * @returns {Array} The new array
   * @category Iteration
   */
  flatMap(fn2, thisObj = this) {
    return this.storage.values.flatMap(fn2, thisObj);
  }
  /**
   * Equivalent to Array.every(). Returns `true` if every call of the provided function
   * on each record yields a truthy value.
   * @param {Function} fn
   * @param {Function} fn.record The record to test.
   * @param {Object} [thisObj] The `this` reference to call the function with. Defaults to this Store.
   * @param {Boolean} [ignoreFilters] Pass `true` to iterate all records including filtered out ones.
   * @returns {Array}
   * @category Iteration
   */
  every(fn2, thisObj = this, ignoreFilters) {
    return this.storage[ignoreFilters ? "allValues" : "values"].every(fn2, thisObj);
  }
  /**
   * Equivalent to Array.reduce(). Applies a function against an accumulator and each record (from left to right) to
   * reduce it to a single value.
   * @param {Function} fn
   * @param {*} initialValue
   * @param {Object} [thisObj] The `this` reference to call the function with. Defaults to this Store
   * @returns {*}
   * @category Iteration
   */
  reduce(fn2, initialValue = [], thisObj = this) {
    if (thisObj !== this) {
      fn2 = fn2.bind(thisObj);
    }
    return this.storage.values.reduce(fn2, initialValue, thisObj);
  }
  /**
   * Iterator that allows you to do for (let record of store)
   * @category Iteration
   */
  [Symbol.iterator]() {
    return this.storage.values[Symbol.iterator]();
  }
  /**
   * Traverse all tree nodes (only applicable for Tree Store)
   * @param {Function} fn The function to call on visiting each node.
   * @param {Core.data.Model} [topNode=this.rootNode] The top node to start the traverse at.
   * @param {Boolean} [skipTopNode] Pass true to not call `fn` on the top node, but proceed directly to its children.
   * @param {Object|Boolean} [options] A boolean for includeFilteredOutRecords, or detailed options for exclude/include records
   * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records
   * @param {Boolean} [options.includeCollapsedGroupRecords] True to also include records from collapsed groups of grouped store
   * @param {Boolean} [options.useOrderedTree] True to traverse unsorted/unfiltered tree
   * @category Traverse
   */
  traverse(fn2, topNode = this.rootNode, skipTopNode = topNode === this.rootNode, options) {
    const me = this;
    options = fixTraverseOptions2(me, options);
    if (me.isTree) {
      if (typeof topNode === "boolean") {
        skipTopNode = topNode;
        topNode = me.rootNode;
      }
      if (me.isChained) {
        const passedFn = fn2;
        fn2 = (node) => {
          if (me.chainedFilterFn(node)) {
            passedFn(node);
          }
        };
      }
      topNode.traverse(fn2, skipTopNode, options);
    } else {
      me.forEach((rec) => rec.traverse(fn2, false, options), me, options);
    }
  }
  /**
   * Traverse all tree nodes while the passed `fn` returns true
   * @param {Function} fn The function to call on visiting each node. Returning `false` from it stops the traverse.
   * @param {Core.data.Model} [topNode=this.rootNode] The top node to start the traverse at.
   * @param {Boolean} [skipTopNode] Pass true to not call `fn` on the top node, but proceed directly to its children.
   * @param {Object} [options] An options object to exclude/include records
   * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records
   * @param {Boolean} [options.includeCollapsedGroupRecords] True to also include records from collapsed groups of grouped store
   * @category Traverse
   */
  traverseWhile(fn2, topNode = this.rootNode, skipTopNode = topNode === this.rootNode, options) {
    const me = this;
    options = fixTraverseOptions2(me, options);
    if (me.isTree) {
      if (typeof topNode === "boolean") {
        skipTopNode = topNode;
        topNode = me.rootNode;
      }
      if (me.isChained) {
        const passedFn = fn2;
        fn2 = (node) => {
          if (me.chainedFilterFn(node)) {
            passedFn(node);
          }
        };
      }
      topNode.traverseWhile(fn2, skipTopNode, options);
    } else {
      for (const record of me.storage) {
        if (record.traverse(fn2, false, options) === false) {
          break;
        }
      }
    }
  }
  /**
   * Finds the next record.
   * @param {Core.data.Model|String|Number} recordOrId Current record or its id
   * @param {Boolean} [wrap=false] Wrap at start/end or stop there
   * @param {Boolean} [skipSpecialRows=false] True to not return specialRows like group headers
   * @returns {Core.data.Model} Next record or null if current is the last one
   * @category Traverse
   */
  getNext(recordOrId, wrap = false, skipSpecialRows = false) {
    const me = this, records = me.storage.values;
    let idx = me.indexOf(recordOrId);
    if (idx >= records.length - 1) {
      if (wrap) {
        idx = -1;
      } else {
        return null;
      }
    }
    const record = records[idx + 1];
    if (skipSpecialRows && record && record.isSpecialRow) {
      return me.getNext(records[idx + 1], wrap, true);
    }
    return record;
  }
  /**
   * Finds the previous record.
   * @param {Core.data.Model|String|Number} recordOrId Current record or its id
   * @param {Boolean} [wrap=false] Wrap at start/end or stop there
   * @param {Boolean} [skipSpecialRows=false] True to not return specialRows like group headers
   * @returns {Core.data.Model} Previous record or null if current is the last one
   * @category Traverse
   */
  getPrev(recordOrId, wrap = false, skipSpecialRows = false) {
    const me = this, records = me.storage.values;
    let idx = me.indexOf(recordOrId);
    if (idx === 0) {
      if (wrap) {
        idx = records.length;
      } else {
        return null;
      }
    }
    const record = records[idx - 1];
    if (skipSpecialRows && record && record.isSpecialRow && idx > 0) {
      return me.getPrev(records[idx - 1], wrap, true);
    }
    return record;
  }
  /**
   * Gets the next or the previous record. Optionally wraps from first -> last and vice versa
   * @param {String|Core.data.Model} recordOrId Record or records id
   * @param {Boolean} next Next (true) or previous (false)
   * @param {Boolean} wrap Wrap at start/end or stop there
   * @param {Boolean} [skipSpecialRows=false] True to not return specialRows like group headers
   * @returns {Core.data.Model}
   * @category Traverse
   * @internal
   */
  getAdjacent(recordOrId, next = true, wrap = false, skipSpecialRows = false) {
    return next ? this.getNext(recordOrId, wrap, skipSpecialRows) : this.getPrev(recordOrId, wrap, skipSpecialRows);
  }
  /**
   * Finds the next record among leaves (in a tree structure)
   * @param {Core.data.Model|String|Number} recordOrId Current record or its id
   * @param {Boolean} [wrap] Wrap at start/end or stop there
   * @returns {Core.data.Model} Next record or null if current is the last one
   * @category Traverse
   * @internal
   */
  getNextLeaf(recordOrId, wrap = false) {
    const me = this, records = me.leaves, record = me.getById(recordOrId);
    let idx = records.indexOf(record);
    if (idx >= records.length - 1) {
      if (wrap) {
        idx = -1;
      } else {
        return null;
      }
    }
    return records[idx + 1];
  }
  /**
   * Finds the previous record among leaves (in a tree structure)
   * @param {Core.data.Model|String|Number} recordOrId Current record or its id
   * @param {Boolean} [wrap] Wrap at start/end or stop there
   * @returns {Core.data.Model} Previous record or null if current is the last one
   * @category Traverse
   * @internal
   */
  getPrevLeaf(recordOrId, wrap = false) {
    const me = this, records = me.leaves, record = me.getById(recordOrId);
    let idx = records.indexOf(record);
    if (idx === 0) {
      if (wrap) {
        idx = records.length;
      } else {
        return null;
      }
    }
    return records[idx - 1];
  }
  /**
   * Gets the next or the previous record among leaves (in a tree structure). Optionally wraps from first -> last and
   * vice versa
   * @param {String|Core.data.Model} recordOrId Record or record id
   * @param {Boolean} [next] Next (true) or previous (false)
   * @param {Boolean} [wrap] Wrap at start/end or stop there
   * @returns {Core.data.Model}
   * @category Traverse
   * @internal
   */
  getAdjacentLeaf(recordOrId, next = true, wrap = false) {
    return next ? this.getNextLeaf(recordOrId, wrap) : this.getPrevLeaf(recordOrId, wrap);
  }
  //endregion
};
Store.initClass();
Store._$name = "Store";

// ../Engine/lib/Engine/quark/store/mixin/ChronoStoreMixin.js
var ChronoStoreMixin = class extends Mixin([Store], (base) => class ChronoStoreMixin extends base {
}) {
};

// ../Engine/lib/Engine/quark/store/mixin/AbstractPartOfProjectStoreMixin.js
var AbstractPartOfProjectStoreMixin = class extends Mixin([
  AbstractPartOfProjectGenericMixin,
  Store
], (base) => {
  const superProto = base.prototype;
  class AbstractPartOfProjectStoreMixin2 extends base {
    constructor() {
      super(...arguments);
      this.isLoadingData = false;
      this.disableHasLoadedDataToCommitFlag = false;
    }
    static get $name() {
      return "AbstractPartOfProjectStoreMixin";
    }
    //region Async event triggering
    // NOTE: Tested in Scheduler (EventStore.t.js)
    construct(config = {}) {
      config.asyncEvents = {
        add: true,
        remove: true,
        removeAll: true,
        change: true,
        refresh: true,
        replace: true,
        move: true,
        update: true
      };
      return superProto.construct.call(this, config);
    }
    // Override for event triggering, to allow triggering events before and after some async operation.
    // The "before" events are prefix, the "after" are not.
    trigger(eventName, param) {
      const me = this, { asyncEvents, project } = me, asyncEvent = asyncEvents == null ? void 0 : asyncEvents[eventName], asyncAction = asyncEvent && (asyncEvent === true || asyncEvent[param.action]);
      if (!asyncAction) {
        return superProto.trigger.call(me, eventName, param);
      }
      superProto.trigger.call(me, `${eventName}PreCommit`, { ...param });
      if (!project || project.isEngineReady() && !project.isWritingData) {
        superProto.trigger.call(me, eventName, param);
      } else if (!me.eventsSuspended && project) {
        if (!project.dataReadyDetacher) {
          project.queuedDataReadyEvents = [];
          project.dataReadyDetacher = project.ion({
            dataReady() {
              this.queuedDataReadyEvents.forEach(([superProto2, scope, eventName2, param2]) => {
                superProto2.trigger.call(scope, eventName2, param2);
              });
              project.queuedDataReadyEvents = null;
              project.dataReadyDetacher();
              project.dataReadyDetacher = null;
            },
            once: true
          });
        }
        project.queuedDataReadyEvents.push([superProto, me, eventName, param]);
      }
      return true;
    }
    //endregion
    calculateProject() {
      return this.project;
    }
    setStoreData(data) {
      var _a2;
      if (this.project && !(this.syncDataOnLoad || this.disableHasLoadedDataToCommitFlag)) {
        this.project.hasLoadedDataToCommit = true;
      }
      this.isLoadingData = true;
      superProto.setStoreData.call(this, data);
      this.isLoadingData = false;
      (_a2 = this.project) == null ? void 0 : _a2.trigger("storeRefresh", { store: this });
    }
    // Override to postpone auto commits to after project commit, makes sure records are unmodified after commit
    async doAutoCommit() {
      if (this.suspendCount <= 0 && this.project && !this.project.isEngineReady()) {
        await this.project.commitAsync();
      }
      superProto.doAutoCommit.call(this);
    }
    async addAsync(records, silent) {
      const result = this.add(records, silent);
      await this.project.commitAsync();
      return result;
    }
    async insertAsync(index, records, silent) {
      const result = this.insert(index, records, silent);
      await this.project.commitAsync();
      return result;
    }
    async loadDataAsync(data) {
      this.data = data;
      await this.project.commitAsync();
    }
    performFilter() {
      var _a2;
      if (this.project && (this.isLoadingData || ((_a2 = this.rootNode) == null ? void 0 : _a2.isLoading))) {
        this.project.commitAsync().then(() => this.filter());
      }
      return super.performFilter(...arguments);
    }
  }
  return AbstractPartOfProjectStoreMixin2;
}) {
};

// ../Engine/lib/Engine/quark/store/mixin/ChronoPartOfProjectStoreMixin.js
var ChronoPartOfProjectStoreMixin = class extends Mixin([
  AbstractPartOfProjectStoreMixin,
  ChronoPartOfProjectGenericMixin,
  ChronoStoreMixin
], (base) => {
  const superProto = base.prototype;
  class ChronoPartOfProjectStoreMixin2 extends base {
    constructor() {
      super(...arguments);
      this.removalOrder = 0;
    }
    setStoreData(data) {
      var _a2;
      (_a2 = this.project) == null ? void 0 : _a2.repopulateStore(this);
      superProto.setStoreData.call(this, data);
    }
    register(record) {
      var _a2, _b;
      superProto.register.call(this, record);
      !record.isRoot && !((_a2 = this.project) == null ? void 0 : _a2.graph) && ((_b = this.project) == null ? void 0 : _b.scheduleDelayedCalculation());
    }
    onModelChange(record, toSet, wasSet, silent, fromRelationUpdate, skipAccessors) {
      var _a2;
      if (!skipAccessors && !(this.syncDataOnLoad && this.isLoadingData) && Object.keys(wasSet).some((key) => key !== "intervals" && record.$entity.getField(key)) && !((_a2 = this.project) == null ? void 0 : _a2.applyingSyncResponse)) {
        silent = true;
      }
      super.onModelChange(record, toSet, wasSet, silent, fromRelationUpdate, skipAccessors);
    }
  }
  return ChronoPartOfProjectStoreMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/mixin/AbstractPartOfProjectModelMixin.js
var AbstractPartOfProjectModelMixin = class extends Mixin([AbstractPartOfProjectGenericMixin, Model], (base) => {
  const superProto = base.prototype;
  class AbstractPartOfProjectModelMixin2 extends base {
    joinStore(store) {
      let joinedProject = null;
      if (isInstanceOf(store, AbstractPartOfProjectStoreMixin)) {
        const project = store.getProject();
        if (project && !this.getProject()) {
          this.setProject(project);
          joinedProject = project;
        }
      }
      superProto.joinStore.call(this, store);
      if (joinedProject && !joinedProject.isRepopulatingStores)
        this.joinProject();
    }
    unjoinStore(store, isReplacing = false) {
      superProto.unjoinStore.call(this, store, isReplacing);
      const { project } = this;
      const isLeavingProjectStore = isInstanceOf(store, AbstractPartOfProjectStoreMixin) && !store.isFillingFromMaster && project === (store.isChained && store.project ? store.masterStore.project : store.project);
      if (project && !project.isDestroying && !project.isRepopulatingStores && isLeavingProjectStore) {
        this.leaveProject(isReplacing);
        this.setProject(null);
      }
      if (isLeavingProjectStore)
        this.graph = null;
    }
    /**
     * Template method, which is called when model is joining the project (through joining some store that
     * has already joined the project)
     */
    joinProject() {
    }
    /**
     * Template method, which is called when model is leaving the project (through leaving some store usually)
     */
    leaveProject(isReplacing = false) {
    }
    calculateProject() {
      const store = this.stores.find((s) => isInstanceOf(s, AbstractPartOfProjectStoreMixin) && !!s.getProject());
      return store == null ? void 0 : store.getProject();
    }
    async setAsync(fieldName, value, silent) {
      var _a2;
      const result = this.set(fieldName, value, silent);
      await ((_a2 = this.project) == null ? void 0 : _a2.commitAsync());
      return result;
    }
    async getAsync(fieldName) {
      var _a2;
      await ((_a2 = this.project) == null ? void 0 : _a2.commitAsync());
      return this.get(fieldName);
    }
    get isStmRestoring() {
      const project = this.getProject();
      return (project == null ? void 0 : project.isRestoringData) || (project == null ? void 0 : project.stm.isRestoring) || false;
    }
  }
  return AbstractPartOfProjectModelMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/mixin/ChronoPartOfProjectModelMixin.js
var ChronoPartOfProjectModelMixin = class extends Mixin([
  AbstractPartOfProjectModelMixin,
  ChronoPartOfProjectGenericMixin,
  ChronoModelMixin
], (base) => {
  const superProto = base.prototype;
  class ChronoPartOfProjectModelMixin2 extends base {
    /**
     * Template method, which is called when model is joining the project (through joining some store that
     * has already joined the project)
     */
    joinProject() {
      var _a2;
      if (!((_a2 = this.project) == null ? void 0 : _a2.delayEnteringReplica)) {
        if (this.graph && this.graph != this.getGraph()) {
          this.graph = null;
        }
        this.getGraph().addEntity(this);
      }
    }
    /**
     * Template method, which is called when model is leaving the project (through leaving some store usually)
     */
    leaveProject(isReplacing = false) {
      superProto.leaveProject.call(this, isReplacing);
      const replica = this.getGraph();
      replica == null ? void 0 : replica.removeEntity(this);
      this.graph = null;
    }
    /**
     * Returns a [[SchedulerBasicProjectMixin|project]] instance
     */
    getProject() {
      return superProto.getProject.call(this);
    }
    calculateProject() {
      const store = this.stores.find((s) => isInstanceOf(s, ChronoPartOfProjectStoreMixin) && !!s.getProject());
      return store == null ? void 0 : store.getProject();
    }
    // Report that there is no graph when delaying calculations, to not let anything enter it on reloads
    get graph() {
      var _a2;
      return ((_a2 = this.project) == null ? void 0 : _a2.delayEnteringReplica) ? null : this._graph;
    }
    set graph(graph) {
      this._graph = graph;
    }
  }
  return ChronoPartOfProjectModelMixin2;
}) {
};

// ../Engine/lib/Engine/vendor/later/later.js
var diffSecond = (date, diff) => {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    date.getHours(),
    date.getMinutes(),
    date.getSeconds() + diff,
    date.getMilliseconds()
  );
};
var later = function() {
  "use strict";
  var later2 = {
    version: "1.2.0"
  };
  if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function(searchElement) {
      "use strict";
      if (this == null) {
        throw new TypeError();
      }
      var t = Object(this);
      var len = t.length >>> 0;
      if (len === 0) {
        return -1;
      }
      var n = 0;
      if (arguments.length > 1) {
        n = Number(arguments[1]);
        if (n != n) {
          n = 0;
        } else if (n != 0 && n != Infinity && n != -Infinity) {
          n = (n > 0 || -1) * Math.floor(Math.abs(n));
        }
      }
      if (n >= len) {
        return -1;
      }
      var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
      for (; k < len; k++) {
        if (k in t && t[k] === searchElement) {
          return k;
        }
      }
      return -1;
    };
  }
  if (!String.prototype.trim) {
    String.prototype.trim = function() {
      return this.replace(/^\s+|\s+$/g, "");
    };
  }
  later2.array = {};
  later2.array.sort = function(arr, zeroIsLast) {
    arr.sort(function(a, b) {
      return +a - +b;
    });
    if (zeroIsLast && arr[0] === 0) {
      arr.push(arr.shift());
    }
  };
  later2.array.next = function(val, values, extent) {
    var cur, zeroIsLargest = extent[0] !== 0, nextIdx = 0;
    for (var i = values.length - 1; i > -1; --i) {
      cur = values[i];
      if (cur === val) {
        return cur;
      }
      if (cur > val || cur === 0 && zeroIsLargest && extent[1] > val) {
        nextIdx = i;
        continue;
      }
      break;
    }
    return values[nextIdx];
  };
  later2.array.nextInvalid = function(val, values, extent) {
    var min2 = extent[0], max = extent[1], len = values.length, zeroVal = values[len - 1] === 0 && min2 !== 0 ? max : 0, next = val, i = values.indexOf(val), start = next;
    while (next === (values[i] || zeroVal)) {
      next++;
      if (next > max) {
        next = min2;
      }
      i++;
      if (i === len) {
        i = 0;
      }
      if (next === start) {
        return void 0;
      }
    }
    return next;
  };
  later2.array.prev = function(val, values, extent) {
    var cur, len = values.length, zeroIsLargest = extent[0] !== 0, prevIdx = len - 1;
    for (var i = 0; i < len; i++) {
      cur = values[i];
      if (cur === val) {
        return cur;
      }
      if (cur < val || cur === 0 && zeroIsLargest && extent[1] < val) {
        prevIdx = i;
        continue;
      }
      break;
    }
    return values[prevIdx];
  };
  later2.array.prevInvalid = function(val, values, extent) {
    var min2 = extent[0], max = extent[1], len = values.length, zeroVal = values[len - 1] === 0 && min2 !== 0 ? max : 0, next = val, i = values.indexOf(val), start = next;
    while (next === (values[i] || zeroVal)) {
      next--;
      if (next < min2) {
        next = max;
      }
      i--;
      if (i === -1) {
        i = len - 1;
      }
      if (next === start) {
        return void 0;
      }
    }
    return next;
  };
  later2.day = later2.D = {
    name: "day",
    range: 86400,
    val: function(d) {
      return d.D || (d.D = later2.date.getDate.call(d));
    },
    isValid: function(d, val) {
      return later2.D.val(d) === (val || later2.D.extent(d)[1]);
    },
    extent: function(d) {
      if (d.DExtent)
        return d.DExtent;
      var month2 = later2.M.val(d), max = later2.DAYS_IN_MONTH[month2 - 1];
      if (month2 === 2 && later2.dy.extent(d)[1] === 366) {
        max = max + 1;
      }
      return d.DExtent = [1, max];
    },
    start: function(d) {
      return d.DStart || (d.DStart = later2.date.next(later2.Y.val(d), later2.M.val(d), later2.D.val(d)));
    },
    end: function(d) {
      return d.DEnd || (d.DEnd = later2.date.prev(later2.Y.val(d), later2.M.val(d), later2.D.val(d)));
    },
    next: function(d, val) {
      val = val > later2.D.extent(d)[1] ? 1 : val;
      var month2 = later2.date.nextRollover(d, val, later2.D, later2.M), DMax = later2.D.extent(month2)[1];
      val = val > DMax ? 1 : val || DMax;
      return later2.date.next(later2.Y.val(month2), later2.M.val(month2), val);
    },
    prev: function(d, val) {
      var month2 = later2.date.prevRollover(d, val, later2.D, later2.M), DMax = later2.D.extent(month2)[1];
      return later2.date.prev(later2.Y.val(month2), later2.M.val(month2), val > DMax ? DMax : val || DMax);
    }
  };
  later2.dayOfWeekCount = later2.dc = {
    name: "day of week count",
    range: 604800,
    val: function(d) {
      return d.dc || (d.dc = Math.floor((later2.D.val(d) - 1) / 7) + 1);
    },
    isValid: function(d, val) {
      return later2.dc.val(d) === val || val === 0 && later2.D.val(d) > later2.D.extent(d)[1] - 7;
    },
    extent: function(d) {
      return d.dcExtent || (d.dcExtent = [1, Math.ceil(later2.D.extent(d)[1] / 7)]);
    },
    start: function(d) {
      return d.dcStart || (d.dcStart = later2.date.next(later2.Y.val(d), later2.M.val(d), Math.max(1, (later2.dc.val(d) - 1) * 7 + 1 || 1)));
    },
    end: function(d) {
      return d.dcEnd || (d.dcEnd = later2.date.prev(later2.Y.val(d), later2.M.val(d), Math.min(later2.dc.val(d) * 7, later2.D.extent(d)[1])));
    },
    next: function(d, val) {
      val = val > later2.dc.extent(d)[1] ? 1 : val;
      var month2 = later2.date.nextRollover(d, val, later2.dc, later2.M), dcMax = later2.dc.extent(month2)[1];
      val = val > dcMax ? 1 : val;
      var next = later2.date.next(later2.Y.val(month2), later2.M.val(month2), val === 0 ? later2.D.extent(month2)[1] - 6 : 1 + 7 * (val - 1));
      if (next.getTime() <= d.getTime()) {
        month2 = later2.M.next(d, later2.M.val(d) + 1);
        return later2.date.next(later2.Y.val(month2), later2.M.val(month2), val === 0 ? later2.D.extent(month2)[1] - 6 : 1 + 7 * (val - 1));
      }
      return next;
    },
    prev: function(d, val) {
      var month2 = later2.date.prevRollover(d, val, later2.dc, later2.M), dcMax = later2.dc.extent(month2)[1];
      val = val > dcMax ? dcMax : val || dcMax;
      return later2.dc.end(later2.date.prev(later2.Y.val(month2), later2.M.val(month2), 1 + 7 * (val - 1)));
    }
  };
  later2.dayOfWeek = later2.dw = later2.d = {
    name: "day of week",
    range: 86400,
    val: function(d) {
      return d.dw || (d.dw = later2.date.getDay.call(d) + 1);
    },
    isValid: function(d, val) {
      return later2.dw.val(d) === (val || 7);
    },
    extent: function() {
      return [1, 7];
    },
    start: function(d) {
      return later2.D.start(d);
    },
    end: function(d) {
      return later2.D.end(d);
    },
    next: function(d, val) {
      val = val > 7 ? 1 : val || 7;
      return later2.date.next(later2.Y.val(d), later2.M.val(d), later2.D.val(d) + (val - later2.dw.val(d)) + (val <= later2.dw.val(d) ? 7 : 0));
    },
    prev: function(d, val) {
      val = val > 7 ? 7 : val || 7;
      return later2.date.prev(later2.Y.val(d), later2.M.val(d), later2.D.val(d) + (val - later2.dw.val(d)) + (val >= later2.dw.val(d) ? -7 : 0));
    }
  };
  later2.dayOfYear = later2.dy = {
    name: "day of year",
    range: 86400,
    val: function(d) {
      return d.dy || (d.dy = Math.ceil(1 + (later2.D.start(d).getTime() - later2.Y.start(d).getTime()) / later2.DAY));
    },
    isValid: function(d, val) {
      return later2.dy.val(d) === (val || later2.dy.extent(d)[1]);
    },
    extent: function(d) {
      var year = later2.Y.val(d);
      return d.dyExtent || (d.dyExtent = [1, year % 4 ? 365 : 366]);
    },
    start: function(d) {
      return later2.D.start(d);
    },
    end: function(d) {
      return later2.D.end(d);
    },
    next: function(d, val) {
      val = val > later2.dy.extent(d)[1] ? 1 : val;
      var year = later2.date.nextRollover(d, val, later2.dy, later2.Y), dyMax = later2.dy.extent(year)[1];
      val = val > dyMax ? 1 : val || dyMax;
      return later2.date.next(later2.Y.val(year), later2.M.val(year), val);
    },
    prev: function(d, val) {
      var year = later2.date.prevRollover(d, val, later2.dy, later2.Y), dyMax = later2.dy.extent(year)[1];
      val = val > dyMax ? dyMax : val || dyMax;
      return later2.date.prev(later2.Y.val(year), later2.M.val(year), val);
    }
  };
  later2.hour = later2.h = {
    name: "hour",
    range: 3600,
    val: function(d) {
      return d.h || (d.h = later2.date.getHour.call(d));
    },
    isValid: function(d, val) {
      return later2.h.val(d) === val;
    },
    extent: function() {
      return [0, 23];
    },
    start: function(d) {
      return d.hStart || (d.hStart = later2.date.next(later2.Y.val(d), later2.M.val(d), later2.D.val(d), later2.h.val(d)));
    },
    end: function(d) {
      return d.hEnd || (d.hEnd = later2.date.prev(later2.Y.val(d), later2.M.val(d), later2.D.val(d), later2.h.val(d)));
    },
    next: function(d, val) {
      val = val > 23 ? 0 : val;
      var next = later2.date.next(later2.Y.val(d), later2.M.val(d), later2.D.val(d) + (val <= later2.h.val(d) ? 1 : 0), val);
      if (!later2.date.isUTC && next.getTime() <= d.getTime()) {
        next = later2.date.next(later2.Y.val(next), later2.M.val(next), later2.D.val(next), val + 1);
      }
      return next;
    },
    prev: function(d, val) {
      val = val > 23 ? 23 : val;
      return later2.date.prev(later2.Y.val(d), later2.M.val(d), later2.D.val(d) + (val >= later2.h.val(d) ? -1 : 0), val);
    }
  };
  later2.minute = later2.m = {
    name: "minute",
    range: 60,
    val: function(d) {
      return d.m || (d.m = later2.date.getMin.call(d));
    },
    isValid: function(d, val) {
      return later2.m.val(d) === val;
    },
    extent: function(d) {
      return [0, 59];
    },
    start: function(d) {
      return d.mStart || (d.mStart = later2.date.next(later2.Y.val(d), later2.M.val(d), later2.D.val(d), later2.h.val(d), later2.m.val(d)));
    },
    end: function(d) {
      return d.mEnd || (d.mEnd = later2.date.prev(later2.Y.val(d), later2.M.val(d), later2.D.val(d), later2.h.val(d), later2.m.val(d)));
    },
    next: function(d, val) {
      var m = later2.m.val(d), s = later2.s.val(d), inc = val > 59 ? 60 - m : val <= m ? 60 - m + val : val - m, next = new Date(d.getTime() + inc * later2.MIN - s * later2.SEC);
      if (!later2.date.isUTC && next.getTime() <= d.getTime()) {
        next = new Date(d.getTime() + (inc + 120) * later2.MIN - s * later2.SEC);
      }
      return next;
    },
    prev: function(d, val) {
      val = val > 59 ? 59 : val;
      return later2.date.prev(later2.Y.val(d), later2.M.val(d), later2.D.val(d), later2.h.val(d) + (val >= later2.m.val(d) ? -1 : 0), val);
    }
  };
  later2.month = later2.M = {
    name: "month",
    range: 2629740,
    val: function(d) {
      return d.M || (d.M = later2.date.getMonth.call(d) + 1);
    },
    isValid: function(d, val) {
      return later2.M.val(d) === (val || 12);
    },
    extent: function() {
      return [1, 12];
    },
    start: function(d) {
      return d.MStart || (d.MStart = later2.date.next(later2.Y.val(d), later2.M.val(d)));
    },
    end: function(d) {
      return d.MEnd || (d.MEnd = later2.date.prev(later2.Y.val(d), later2.M.val(d)));
    },
    next: function(d, val) {
      val = val > 12 ? 1 : val || 12;
      return later2.date.next(later2.Y.val(d) + (val > later2.M.val(d) ? 0 : 1), val);
    },
    prev: function(d, val) {
      val = val > 12 ? 12 : val || 12;
      return later2.date.prev(later2.Y.val(d) - (val >= later2.M.val(d) ? 1 : 0), val);
    }
  };
  later2.second = later2.s = {
    name: "second",
    range: 1,
    val: function(d) {
      return d.s || (d.s = later2.date.getSec.call(d));
    },
    isValid: function(d, val) {
      return later2.s.val(d) === val;
    },
    extent: function() {
      return [0, 59];
    },
    start: function(d) {
      return d;
    },
    end: function(d) {
      return d;
    },
    next: function(d, val) {
      var s = later2.s.val(d), inc = val > 59 ? 60 - s : val <= s ? 60 - s + val : val - s, next = new Date(d.getTime() + inc * later2.SEC);
      if (!later2.date.isUTC && next.getTime() <= d.getTime()) {
        next = new Date(d.getTime() + (inc + 7200) * later2.SEC);
      }
      return next;
    },
    prev: function(d, val, cache) {
      val = val > 59 ? 59 : val;
      return later2.date.prev(later2.Y.val(d), later2.M.val(d), later2.D.val(d), later2.h.val(d), later2.m.val(d) + (val >= later2.s.val(d) ? -1 : 0), val);
    }
  };
  later2.time = later2.t = {
    name: "time",
    range: 1,
    val: function(d) {
      return d.t || (d.t = later2.h.val(d) * 3600 + later2.m.val(d) * 60 + later2.s.val(d));
    },
    isValid: function(d, val) {
      return later2.t.val(d) === val;
    },
    extent: function() {
      return [0, 86399];
    },
    start: function(d) {
      return d;
    },
    end: function(d) {
      return d;
    },
    next: function(d, val) {
      val = val > 86399 ? 0 : val;
      var next = later2.date.next(later2.Y.val(d), later2.M.val(d), later2.D.val(d) + (val <= later2.t.val(d) ? 1 : 0), 0, 0, val);
      if (!later2.date.isUTC && next.getTime() < d.getTime()) {
        next = later2.date.next(later2.Y.val(next), later2.M.val(next), later2.D.val(next), later2.h.val(next), later2.m.val(next), val + 7200);
      }
      return next;
    },
    prev: function(d, val) {
      val = val > 86399 ? 86399 : val;
      return later2.date.next(later2.Y.val(d), later2.M.val(d), later2.D.val(d) + (val >= later2.t.val(d) ? -1 : 0), 0, 0, val);
    }
  };
  later2.weekOfMonth = later2.wm = {
    name: "week of month",
    range: 604800,
    val: function(d) {
      return d.wm || (d.wm = (later2.D.val(d) + (later2.dw.val(later2.M.start(d)) - 1) + (7 - later2.dw.val(d))) / 7);
    },
    isValid: function(d, val) {
      return later2.wm.val(d) === (val || later2.wm.extent(d)[1]);
    },
    extent: function(d) {
      return d.wmExtent || (d.wmExtent = [1, (later2.D.extent(d)[1] + (later2.dw.val(later2.M.start(d)) - 1) + (7 - later2.dw.val(later2.M.end(d)))) / 7]);
    },
    start: function(d) {
      return d.wmStart || (d.wmStart = later2.date.next(later2.Y.val(d), later2.M.val(d), Math.max(later2.D.val(d) - later2.dw.val(d) + 1, 1)));
    },
    end: function(d) {
      return d.wmEnd || (d.wmEnd = later2.date.prev(later2.Y.val(d), later2.M.val(d), Math.min(later2.D.val(d) + (7 - later2.dw.val(d)), later2.D.extent(d)[1])));
    },
    next: function(d, val) {
      val = val > later2.wm.extent(d)[1] ? 1 : val;
      var month2 = later2.date.nextRollover(d, val, later2.wm, later2.M), wmMax = later2.wm.extent(month2)[1];
      val = val > wmMax ? 1 : val || wmMax;
      return later2.date.next(later2.Y.val(month2), later2.M.val(month2), Math.max(1, (val - 1) * 7 - (later2.dw.val(month2) - 2)));
    },
    prev: function(d, val) {
      var month2 = later2.date.prevRollover(d, val, later2.wm, later2.M), wmMax = later2.wm.extent(month2)[1];
      val = val > wmMax ? wmMax : val || wmMax;
      return later2.wm.end(later2.date.next(later2.Y.val(month2), later2.M.val(month2), Math.max(1, (val - 1) * 7 - (later2.dw.val(month2) - 2))));
    }
  };
  later2.weekOfYear = later2.wy = {
    name: "week of year (ISO)",
    range: 604800,
    val: function(d) {
      if (d.wy)
        return d.wy;
      var wThur = later2.dw.next(later2.wy.start(d), 5), YThur = later2.dw.next(later2.Y.prev(wThur, later2.Y.val(wThur) - 1), 5);
      return d.wy = 1 + Math.ceil((wThur.getTime() - YThur.getTime()) / later2.WEEK);
    },
    isValid: function(d, val) {
      return later2.wy.val(d) === (val || later2.wy.extent(d)[1]);
    },
    extent: function(d) {
      if (d.wyExtent)
        return d.wyExtent;
      var year = later2.dw.next(later2.wy.start(d), 5), dwFirst = later2.dw.val(later2.Y.start(year)), dwLast = later2.dw.val(later2.Y.end(year));
      return d.wyExtent = [1, dwFirst === 5 || dwLast === 5 ? 53 : 52];
    },
    start: function(d) {
      return d.wyStart || (d.wyStart = later2.date.next(later2.Y.val(d), later2.M.val(d), later2.D.val(d) - (later2.dw.val(d) > 1 ? later2.dw.val(d) - 2 : 6)));
    },
    end: function(d) {
      return d.wyEnd || (d.wyEnd = later2.date.prev(later2.Y.val(d), later2.M.val(d), later2.D.val(d) + (later2.dw.val(d) > 1 ? 8 - later2.dw.val(d) : 0)));
    },
    next: function(d, val) {
      val = val > later2.wy.extent(d)[1] ? 1 : val;
      var wyThur = later2.dw.next(later2.wy.start(d), 5), year = later2.date.nextRollover(wyThur, val, later2.wy, later2.Y);
      if (later2.wy.val(year) !== 1) {
        year = later2.dw.next(year, 2);
      }
      var wyMax = later2.wy.extent(year)[1], wyStart = later2.wy.start(year);
      val = val > wyMax ? 1 : val || wyMax;
      return later2.date.next(later2.Y.val(wyStart), later2.M.val(wyStart), later2.D.val(wyStart) + 7 * (val - 1));
    },
    prev: function(d, val) {
      var wyThur = later2.dw.next(later2.wy.start(d), 5), year = later2.date.prevRollover(wyThur, val, later2.wy, later2.Y);
      if (later2.wy.val(year) !== 1) {
        year = later2.dw.next(year, 2);
      }
      var wyMax = later2.wy.extent(year)[1], wyEnd = later2.wy.end(year);
      val = val > wyMax ? wyMax : val || wyMax;
      return later2.wy.end(later2.date.next(later2.Y.val(wyEnd), later2.M.val(wyEnd), later2.D.val(wyEnd) + 7 * (val - 1)));
    }
  };
  later2.year = later2.Y = {
    name: "year",
    range: 31556900,
    val: function(d) {
      return d.Y || (d.Y = later2.date.getYear.call(d));
    },
    isValid: function(d, val) {
      return later2.Y.val(d) === val;
    },
    extent: function() {
      return [1970, 2099];
    },
    start: function(d) {
      return d.YStart || (d.YStart = later2.date.next(later2.Y.val(d)));
    },
    end: function(d) {
      return d.YEnd || (d.YEnd = later2.date.prev(later2.Y.val(d)));
    },
    next: function(d, val) {
      return val > later2.Y.val(d) && val <= later2.Y.extent()[1] ? later2.date.next(val) : later2.NEVER;
    },
    prev: function(d, val) {
      return val < later2.Y.val(d) && val >= later2.Y.extent()[0] ? later2.date.prev(val) : later2.NEVER;
    }
  };
  later2.fullDate = later2.fd = {
    name: "full date",
    range: 1,
    val: function(d) {
      return d.fd || (d.fd = d.getTime());
    },
    isValid: function(d, val) {
      return later2.fd.val(d) === val;
    },
    extent: function() {
      return [0, 3250368e7];
    },
    start: function(d) {
      return d;
    },
    end: function(d) {
      return d;
    },
    next: function(d, val) {
      return later2.fd.val(d) < val ? new Date(val) : later2.NEVER;
    },
    prev: function(d, val) {
      return later2.fd.val(d) > val ? new Date(val) : later2.NEVER;
    }
  };
  later2.modifier = {};
  later2.modifier.after = later2.modifier.a = function(constraint, values) {
    var value = values[0];
    return {
      name: "after " + constraint.name,
      range: (constraint.extent(/* @__PURE__ */ new Date())[1] - value) * constraint.range,
      val: constraint.val,
      isValid: function(d, val) {
        return this.val(d) >= value;
      },
      extent: constraint.extent,
      start: constraint.start,
      end: constraint.end,
      next: function(startDate, val) {
        if (val != value)
          val = constraint.extent(startDate)[0];
        return constraint.next(startDate, val);
      },
      prev: function(startDate, val) {
        val = val === value ? constraint.extent(startDate)[1] : value - 1;
        return constraint.prev(startDate, val);
      }
    };
  };
  later2.modifier.before = later2.modifier.b = function(constraint, values) {
    var value = values[values.length - 1];
    return {
      name: "before " + constraint.name,
      range: constraint.range * (value - 1),
      val: constraint.val,
      isValid: function(d, val) {
        return this.val(d) < value;
      },
      extent: constraint.extent,
      start: constraint.start,
      end: constraint.end,
      next: function(startDate, val) {
        val = val === value ? constraint.extent(startDate)[0] : value;
        return constraint.next(startDate, val);
      },
      prev: function(startDate, val) {
        val = val === value ? value - 1 : constraint.extent(startDate)[1];
        return constraint.prev(startDate, val);
      }
    };
  };
  later2.compile = function(schedDef) {
    var constraints = [], constraintsLen = 0, tickConstraint;
    for (var key in schedDef) {
      var nameParts = key.split("_"), name = nameParts[0], mod = nameParts[1], vals = schedDef[key], constraint = mod ? later2.modifier[mod](later2[name], vals) : later2[name];
      constraints.push({
        constraint,
        vals
      });
      constraintsLen++;
    }
    constraints.sort(function(a, b) {
      var ra = a.constraint.range, rb = b.constraint.range;
      return rb < ra ? -1 : rb > ra ? 1 : 0;
    });
    tickConstraint = constraints[constraintsLen - 1].constraint;
    function compareFn(dir) {
      return dir === "next" ? function(a, b) {
        return a.getTime() > b.getTime();
      } : function(a, b) {
        return b.getTime() > a.getTime();
      };
    }
    return {
      start: function(dir, startDate) {
        var next = startDate, nextVal = later2.array[dir], maxAttempts = 1e3, done;
        while (maxAttempts-- && !done && next) {
          done = true;
          for (var i = 0; i < constraintsLen; i++) {
            var constraint2 = constraints[i].constraint, curVal = constraint2.val(next), extent = constraint2.extent(next), newVal = nextVal(curVal, constraints[i].vals, extent);
            if (!constraint2.isValid(next, newVal)) {
              next = constraint2[dir](next, newVal);
              done = false;
              break;
            }
          }
        }
        if (next !== later2.NEVER) {
          next = dir === "next" ? tickConstraint.start(next) : tickConstraint.end(next);
        }
        return next;
      },
      end: function(dir, startDate) {
        var result, nextVal = later2.array[dir + "Invalid"], compare = compareFn(dir);
        for (var i = constraintsLen - 1; i >= 0; i--) {
          var constraint2 = constraints[i].constraint, curVal = constraint2.val(startDate), extent = constraint2.extent(startDate), newVal = nextVal(curVal, constraints[i].vals, extent), next;
          if (newVal !== void 0) {
            next = constraint2[dir](startDate, newVal);
            if (next && (!result || compare(result, next))) {
              result = next;
            }
          }
        }
        return result;
      },
      tick: function(dir, date) {
        return new Date(dir === "next" ? tickConstraint.end(date).getTime() + later2.SEC : tickConstraint.start(date).getTime() - later2.SEC);
      },
      // PATCH
      tickSafe: function(dir, date) {
        return dir === "next" ? diffSecond(tickConstraint.end(date), 1) : diffSecond(tickConstraint.start(date), -1);
      },
      // EOF PATCH
      tickStart: function(date) {
        return tickConstraint.start(date);
      }
    };
  };
  later2.schedule = function(sched) {
    if (!sched)
      throw new Error("Missing schedule definition.");
    if (!sched.schedules)
      throw new Error("Definition must include at least one schedule.");
    var schedules = [], schedulesLen = sched.schedules.length, exceptions = [], exceptionsLen = sched.exceptions ? sched.exceptions.length : 0;
    for (var i = 0; i < schedulesLen; i++) {
      schedules.push(later2.compile(sched.schedules[i]));
    }
    for (var j = 0; j < exceptionsLen; j++) {
      exceptions.push(later2.compile(sched.exceptions[j]));
    }
    function getInstances(dir, count, startDate, endDate, isRange) {
      var compare = compareFn(dir), loopCount = count, maxAttempts = 1e6, schedStarts = [], exceptStarts = [], next, end, results = [], isForward = dir === "next", lastResult, rStart = isForward ? 0 : 1, rEnd = isForward ? 1 : 0;
      startDate = startDate ? new Date(startDate) : /* @__PURE__ */ new Date();
      if (!startDate || !startDate.getTime())
        throw new Error("Invalid start date.");
      setNextStarts(dir, schedules, schedStarts, startDate);
      setRangeStarts(dir, exceptions, exceptStarts, startDate);
      while (maxAttempts-- && loopCount && (next = findNext(schedStarts, compare))) {
        if (endDate && compare(next, endDate)) {
          break;
        }
        if (exceptionsLen) {
          updateRangeStarts(dir, exceptions, exceptStarts, next);
          if (end = calcRangeOverlap(dir, exceptStarts, next)) {
            updateNextStarts(dir, schedules, schedStarts, end);
            continue;
          }
        }
        if (isRange) {
          var maxEndDate = calcMaxEndDate(exceptStarts, compare);
          end = calcEnd(dir, schedules, schedStarts, next, maxEndDate);
          var r = isForward ? [new Date(Math.max(startDate, next)), end ? new Date(endDate ? Math.min(end, endDate) : end) : void 0] : [end ? new Date(endDate ? Math.max(endDate, end.getTime() + later2.SEC) : end.getTime() + later2.SEC) : void 0, new Date(Math.min(startDate, next.getTime() + later2.SEC))];
          if (lastResult && r[rStart].getTime() === lastResult[rEnd].getTime()) {
            lastResult[rEnd] = r[rEnd];
            loopCount++;
          } else {
            lastResult = r;
            results.push(lastResult);
          }
          if (!end)
            break;
          updateNextStarts(dir, schedules, schedStarts, end);
        } else {
          results.push(isForward ? new Date(Math.max(startDate, next)) : getStart(schedules, schedStarts, next, endDate));
          tickStarts(dir, schedules, schedStarts, next);
        }
        loopCount--;
      }
      for (var i2 = 0, len = results.length; i2 < len; i2++) {
        var result = results[i2];
        results[i2] = Object.prototype.toString.call(result) === "[object Array]" ? [cleanDate(result[0]), cleanDate(result[1])] : cleanDate(result);
      }
      return results.length === 0 ? later2.NEVER : count === 1 ? results[0] : results;
    }
    function cleanDate(d) {
      if (d instanceof Date && !isNaN(d.valueOf())) {
        return new Date(d);
      }
      return void 0;
    }
    function setNextStarts(dir, schedArr, startsArr, startDate) {
      for (var i2 = 0, len = schedArr.length; i2 < len; i2++) {
        startsArr[i2] = schedArr[i2].start(dir, startDate);
      }
    }
    function updateNextStarts(dir, schedArr, startsArr, startDate) {
      var compare = compareFn(dir);
      for (var i2 = 0, len = schedArr.length; i2 < len; i2++) {
        if (startsArr[i2] && !compare(startsArr[i2], startDate)) {
          startsArr[i2] = schedArr[i2].start(dir, startDate);
        }
      }
    }
    function setRangeStarts(dir, schedArr, rangesArr, startDate) {
      var compare = compareFn(dir);
      for (var i2 = 0, len = schedArr.length; i2 < len; i2++) {
        var nextStart = schedArr[i2].start(dir, startDate);
        if (!nextStart) {
          rangesArr[i2] = later2.NEVER;
        } else {
          rangesArr[i2] = [nextStart, schedArr[i2].end(dir, nextStart)];
        }
      }
    }
    function updateRangeStarts(dir, schedArr, rangesArr, startDate) {
      var compare = compareFn(dir);
      for (var i2 = 0, len = schedArr.length; i2 < len; i2++) {
        if (rangesArr[i2] && !compare(rangesArr[i2][0], startDate)) {
          var nextStart = schedArr[i2].start(dir, startDate);
          if (!nextStart) {
            rangesArr[i2] = later2.NEVER;
          } else {
            rangesArr[i2] = [nextStart, schedArr[i2].end(dir, nextStart)];
          }
        }
      }
    }
    function tickStarts(dir, schedArr, startsArr, startDate) {
      for (var i2 = 0, len = schedArr.length; i2 < len; i2++) {
        if (startsArr[i2] && startsArr[i2].getTime() === startDate.getTime()) {
          const newStart = schedArr[i2].start(dir, schedArr[i2].tick(dir, startDate));
          if (newStart !== later2.NEVER && newStart.getTime() === startsArr[i2].getTime()) {
            startsArr[i2] = schedArr[i2].start(dir, schedArr[i2].tickSafe(dir, startDate));
          } else {
            startsArr[i2] = newStart;
          }
        }
      }
    }
    function getStart(schedArr, startsArr, startDate, minEndDate) {
      var result;
      for (var i2 = 0, len = startsArr.length; i2 < len; i2++) {
        if (startsArr[i2] && startsArr[i2].getTime() === startDate.getTime()) {
          var start = schedArr[i2].tickStart(startDate);
          if (minEndDate && start < minEndDate) {
            return minEndDate;
          }
          if (!result || start > result) {
            result = start;
          }
        }
      }
      return result;
    }
    function calcRangeOverlap(dir, rangesArr, startDate) {
      var compare = compareFn(dir), result;
      for (var i2 = 0, len = rangesArr.length; i2 < len; i2++) {
        var range = rangesArr[i2];
        if (range && !compare(range[0], startDate) && (!range[1] || compare(range[1], startDate))) {
          if (!result || compare(range[1], result)) {
            result = range[1];
          }
        }
      }
      return result;
    }
    function calcMaxEndDate(exceptsArr, compare) {
      var result;
      for (var i2 = 0, len = exceptsArr.length; i2 < len; i2++) {
        if (exceptsArr[i2] && (!result || compare(result, exceptsArr[i2][0]))) {
          result = exceptsArr[i2][0];
        }
      }
      return result;
    }
    function calcEnd(dir, schedArr, startsArr, startDate, maxEndDate) {
      var compare = compareFn(dir), result;
      for (var i2 = 0, len = schedArr.length; i2 < len; i2++) {
        var start = startsArr[i2];
        if (start && start.getTime() === startDate.getTime()) {
          var end = schedArr[i2].end(dir, start);
          if (maxEndDate && (!end || compare(end, maxEndDate))) {
            return maxEndDate;
          }
          if (!result || compare(end, result)) {
            result = end;
          }
        }
      }
      return result;
    }
    function compareFn(dir) {
      return dir === "next" ? function(a, b) {
        return !b || a.getTime() > b.getTime();
      } : function(a, b) {
        return !a || b.getTime() > a.getTime();
      };
    }
    function findNext(arr, compare) {
      var next = arr[0];
      for (var i2 = 1, len = arr.length; i2 < len; i2++) {
        if (arr[i2] && compare(next, arr[i2])) {
          next = arr[i2];
        }
      }
      return next;
    }
    return {
      isValid: function(d) {
        return getInstances("next", 1, d, d) !== later2.NEVER;
      },
      next: function(count, startDate, endDate) {
        return getInstances("next", count || 1, startDate, endDate);
      },
      prev: function(count, startDate, endDate) {
        return getInstances("prev", count || 1, startDate, endDate);
      },
      nextRange: function(count, startDate, endDate) {
        return getInstances("next", count || 1, startDate, endDate, true);
      },
      prevRange: function(count, startDate, endDate) {
        return getInstances("prev", count || 1, startDate, endDate, true);
      }
    };
  };
  later2.setTimeout = function(fn2, sched) {
    var s = later2.schedule(sched), t;
    if (fn2) {
      scheduleTimeout();
    }
    function scheduleTimeout() {
      var now = Date.now(), next = s.next(2, now);
      if (!next[0]) {
        t = void 0;
        return;
      }
      var diff = next[0].getTime() - now;
      if (diff < 1e3) {
        diff = next[1] ? next[1].getTime() - now : 1e3;
      }
      if (diff < 2147483647) {
        t = setTimeout(fn2, diff);
      } else {
        t = setTimeout(scheduleTimeout, 2147483647);
      }
    }
    return {
      isDone: function() {
        return !t;
      },
      clear: function() {
        clearTimeout(t);
      }
    };
  };
  later2.setInterval = function(fn2, sched) {
    if (!fn2) {
      return;
    }
    var t = later2.setTimeout(scheduleTimeout, sched), done = t.isDone();
    function scheduleTimeout() {
      if (!done) {
        fn2();
        t = later2.setTimeout(scheduleTimeout, sched);
      }
    }
    return {
      isDone: function() {
        return t.isDone();
      },
      clear: function() {
        done = true;
        t.clear();
      }
    };
  };
  later2.date = {};
  later2.date.timezone = function(useLocalTime) {
    later2.date.build = useLocalTime ? function(Y, M, D, h, m, s) {
      return new Date(Y, M, D, h, m, s);
    } : function(Y, M, D, h, m, s) {
      return new Date(Date.UTC(Y, M, D, h, m, s));
    };
    var get = useLocalTime ? "get" : "getUTC", d = Date.prototype;
    later2.date.getYear = d[get + "FullYear"];
    later2.date.getMonth = d[get + "Month"];
    later2.date.getDate = d[get + "Date"];
    later2.date.getDay = d[get + "Day"];
    later2.date.getHour = d[get + "Hours"];
    later2.date.getMin = d[get + "Minutes"];
    later2.date.getSec = d[get + "Seconds"];
    later2.date.isUTC = !useLocalTime;
  };
  later2.date.UTC = function() {
    later2.date.timezone(false);
  };
  later2.date.localTime = function() {
    later2.date.timezone(true);
  };
  later2.date.UTC();
  later2.SEC = 1e3;
  later2.MIN = later2.SEC * 60;
  later2.HOUR = later2.MIN * 60;
  later2.DAY = later2.HOUR * 24;
  later2.WEEK = later2.DAY * 7;
  later2.DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  later2.NEVER = 0;
  later2.date.next = function(Y, M, D, h, m, s) {
    return later2.date.build(Y, M !== void 0 ? M - 1 : 0, D !== void 0 ? D : 1, h || 0, m || 0, s || 0);
  };
  later2.date.nextRollover = function(d, val, constraint, period) {
    var cur = constraint.val(d), max = constraint.extent(d)[1];
    return (val || max) <= cur || val > max ? new Date(period.end(d).getTime() + later2.SEC) : period.start(d);
  };
  later2.date.prev = function(Y, M, D, h, m, s) {
    var len = arguments.length;
    M = len < 2 ? 11 : M - 1;
    D = len < 3 ? later2.D.extent(later2.date.next(Y, M + 1))[1] : D;
    h = len < 4 ? 23 : h;
    m = len < 5 ? 59 : m;
    s = len < 6 ? 59 : s;
    return later2.date.build(Y, M, D, h, m, s);
  };
  later2.date.prevRollover = function(d, val, constraint, period) {
    var cur = constraint.val(d);
    return val >= cur || !val ? period.start(period.prev(d, period.val(d) - 1)) : period.start(d);
  };
  later2.parse = {};
  later2.parse.cron = function(expr, hasSeconds) {
    var NAMES = {
      JAN: 1,
      FEB: 2,
      MAR: 3,
      APR: 4,
      MAY: 5,
      JUN: 6,
      JUL: 7,
      AUG: 8,
      SEP: 9,
      OCT: 10,
      NOV: 11,
      DEC: 12,
      SUN: 1,
      MON: 2,
      TUE: 3,
      WED: 4,
      THU: 5,
      FRI: 6,
      SAT: 7
    };
    var REPLACEMENTS = {
      "* * * * * *": "0/1 * * * * *",
      "@YEARLY": "0 0 1 1 *",
      "@ANNUALLY": "0 0 1 1 *",
      "@MONTHLY": "0 0 1 * *",
      "@WEEKLY": "0 0 * * 0",
      "@DAILY": "0 0 * * *",
      "@HOURLY": "0 * * * *"
    };
    var FIELDS = {
      s: [0, 0, 59],
      m: [1, 0, 59],
      h: [2, 0, 23],
      D: [3, 1, 31],
      M: [4, 1, 12],
      Y: [6, 1970, 2099],
      d: [5, 1, 7, 1]
    };
    function getValue(value, offset, max) {
      return isNaN(value) ? NAMES[value] || null : Math.min(+value + (offset || 0), max || 9999);
    }
    function cloneSchedule(sched) {
      var clone = {}, field2;
      for (field2 in sched) {
        if (field2 !== "dc" && field2 !== "d") {
          clone[field2] = sched[field2].slice(0);
        }
      }
      return clone;
    }
    function add(sched, name, min2, max, inc) {
      var i = min2;
      if (!sched[name]) {
        sched[name] = [];
      }
      while (i <= max) {
        if (sched[name].indexOf(i) < 0) {
          sched[name].push(i);
        }
        i += inc || 1;
      }
      sched[name].sort(function(a, b) {
        return a - b;
      });
    }
    function addHash(schedules, curSched, value, hash) {
      if (curSched.d && !curSched.dc || curSched.dc && curSched.dc.indexOf(hash) < 0) {
        schedules.push(cloneSchedule(curSched));
        curSched = schedules[schedules.length - 1];
      }
      add(curSched, "d", value, value);
      add(curSched, "dc", hash, hash);
    }
    function addWeekday(s, curSched, value) {
      var except1 = {}, except2 = {};
      if (value === 1) {
        add(curSched, "D", 1, 3);
        add(curSched, "d", NAMES.MON, NAMES.FRI);
        add(except1, "D", 2, 2);
        add(except1, "d", NAMES.TUE, NAMES.FRI);
        add(except2, "D", 3, 3);
        add(except2, "d", NAMES.TUE, NAMES.FRI);
      } else {
        add(curSched, "D", value - 1, value + 1);
        add(curSched, "d", NAMES.MON, NAMES.FRI);
        add(except1, "D", value - 1, value - 1);
        add(except1, "d", NAMES.MON, NAMES.THU);
        add(except2, "D", value + 1, value + 1);
        add(except2, "d", NAMES.TUE, NAMES.FRI);
      }
      s.exceptions.push(except1);
      s.exceptions.push(except2);
    }
    function addRange(item, curSched, name, min2, max, offset) {
      var incSplit = item.split("/"), inc = +incSplit[1], range = incSplit[0];
      if (range !== "*" && range !== "0") {
        var rangeSplit = range.split("-");
        min2 = getValue(rangeSplit[0], offset, max);
        max = getValue(rangeSplit[1], offset, max) || max;
      }
      add(curSched, name, min2, max, inc);
    }
    function parse(item, s, name, min2, max, offset) {
      var value, split2, schedules = s.schedules, curSched = schedules[schedules.length - 1];
      if (item === "L") {
        item = min2 - 1;
      }
      if ((value = getValue(item, offset, max)) !== null) {
        add(curSched, name, value, value);
      } else if ((value = getValue(item.replace("W", ""), offset, max)) !== null) {
        addWeekday(s, curSched, value);
      } else if ((value = getValue(item.replace("L", ""), offset, max)) !== null) {
        addHash(schedules, curSched, value, min2 - 1);
      } else if ((split2 = item.split("#")).length === 2) {
        value = getValue(split2[0], offset, max);
        addHash(schedules, curSched, value, getValue(split2[1]));
      } else {
        addRange(item, curSched, name, min2, max, offset);
      }
    }
    function isHash(item) {
      return item.indexOf("#") > -1 || item.indexOf("L") > 0;
    }
    function itemSorter(a, b) {
      return isHash(a) && !isHash(b) ? 1 : a - b;
    }
    function parseExpr(expr2) {
      var schedule = {
        schedules: [{}],
        exceptions: []
      }, components = expr2.replace(/(\s)+/g, " ").split(" "), field2, f, component, items;
      for (field2 in FIELDS) {
        f = FIELDS[field2];
        component = components[f[0]];
        if (component && component !== "*" && component !== "?") {
          items = component.split(",").sort(itemSorter);
          var i, length = items.length;
          for (i = 0; i < length; i++) {
            parse(items[i], schedule, field2, f[1], f[2], f[3]);
          }
        }
      }
      return schedule;
    }
    function prepareExpr(expr2) {
      var prepared = expr2.toUpperCase();
      return REPLACEMENTS[prepared] || prepared;
    }
    var e = prepareExpr(expr);
    return parseExpr(hasSeconds ? e : "0 " + e);
  };
  later2.parse.recur = function() {
    var schedules = [], exceptions = [], cur, curArr = schedules, curName, values, every2, modifier, applyMin, applyMax, i, last;
    function add(name, min2, max) {
      name = modifier ? name + "_" + modifier : name;
      if (!cur) {
        curArr.push({});
        cur = curArr[0];
      }
      if (!cur[name]) {
        cur[name] = [];
      }
      curName = cur[name];
      if (every2) {
        values = [];
        for (i = min2; i <= max; i += every2) {
          values.push(i);
        }
        last = {
          n: name,
          x: every2,
          c: curName.length,
          m: max
        };
      }
      values = applyMin ? [min2] : applyMax ? [max] : values;
      var length = values.length;
      for (i = 0; i < length; i += 1) {
        var val = values[i];
        if (curName.indexOf(val) < 0) {
          curName.push(val);
        }
      }
      values = every2 = modifier = applyMin = applyMax = 0;
    }
    return {
      schedules,
      exceptions,
      on: function() {
        values = arguments[0] instanceof Array ? arguments[0] : arguments;
        return this;
      },
      every: function(x) {
        every2 = x || 1;
        return this;
      },
      after: function(x) {
        modifier = "a";
        values = [x];
        return this;
      },
      before: function(x) {
        modifier = "b";
        values = [x];
        return this;
      },
      first: function() {
        applyMin = 1;
        return this;
      },
      last: function() {
        applyMax = 1;
        return this;
      },
      time: function() {
        for (var i2 = 0, len = values.length; i2 < len; i2++) {
          var split2 = values[i2].split(":");
          if (split2.length < 3)
            split2.push(0);
          values[i2] = +split2[0] * 3600 + +split2[1] * 60 + +split2[2];
        }
        add("t");
        return this;
      },
      second: function() {
        add("s", 0, 59);
        return this;
      },
      minute: function() {
        add("m", 0, 59);
        return this;
      },
      hour: function() {
        add("h", 0, 23);
        return this;
      },
      dayOfMonth: function() {
        add("D", 1, applyMax ? 0 : 31);
        return this;
      },
      dayOfWeek: function() {
        add("d", 1, 7);
        return this;
      },
      onWeekend: function() {
        values = [1, 7];
        return this.dayOfWeek();
      },
      onWeekday: function() {
        values = [2, 3, 4, 5, 6];
        return this.dayOfWeek();
      },
      dayOfWeekCount: function() {
        add("dc", 1, applyMax ? 0 : 5);
        return this;
      },
      dayOfYear: function() {
        add("dy", 1, applyMax ? 0 : 366);
        return this;
      },
      weekOfMonth: function() {
        add("wm", 1, applyMax ? 0 : 5);
        return this;
      },
      weekOfYear: function() {
        add("wy", 1, applyMax ? 0 : 53);
        return this;
      },
      month: function() {
        add("M", 1, 12);
        return this;
      },
      year: function() {
        add("Y", 1970, 2450);
        return this;
      },
      fullDate: function() {
        for (var i2 = 0, len = values.length; i2 < len; i2++) {
          values[i2] = values[i2].getTime();
        }
        add("fd");
        return this;
      },
      customModifier: function(id, vals) {
        var custom = later2.modifier[id];
        if (!custom)
          throw new Error("Custom modifier " + id + " not recognized!");
        modifier = id;
        values = arguments[1] instanceof Array ? arguments[1] : [arguments[1]];
        return this;
      },
      customPeriod: function(id) {
        var custom = later2[id];
        if (!custom)
          throw new Error("Custom time period " + id + " not recognized!");
        add(id, custom.extent(/* @__PURE__ */ new Date())[0], custom.extent(/* @__PURE__ */ new Date())[1]);
        return this;
      },
      startingOn: function(start) {
        return this.between(start, last.m);
      },
      between: function(start, end) {
        cur[last.n] = cur[last.n].splice(0, last.c);
        every2 = last.x;
        add(last.n, start, end);
        return this;
      },
      and: function() {
        cur = curArr[curArr.push({}) - 1];
        return this;
      },
      except: function() {
        curArr = exceptions;
        cur = null;
        return this;
      }
    };
  };
  later2.parse.text = function(str) {
    var recur = later2.parse.recur, pos = 0, input = "", error;
    var TOKENTYPES = {
      eof: /^$/,
      fullDate: /^(\d\d\d\d-\d\d-\d\dt\d\d:\d\d:\d\d)\b/,
      rank: /^((\d\d\d\d)|([2-5]?1(st)?|[2-5]?2(nd)?|[2-5]?3(rd)?|(0|[1-5]?[4-9]|[1-5]0|1[1-3])(th)?))\b/,
      time: /^((([0]?[1-9]|1[0-2]):[0-5]\d(\s)?(am|pm))|(([0]?\d|1\d|2[0-3]):[0-5]\d))\b/,
      dayName: /^((sun|mon|tue(s)?|wed(nes)?|thu(r(s)?)?|fri|sat(ur)?)(day)?)\b/,
      monthName: /^(jan(uary)?|feb(ruary)?|ma((r(ch)?)?|y)|apr(il)?|ju(ly|ne)|aug(ust)?|oct(ober)?|(sept|nov|dec)(ember)?)\b/,
      yearIndex: /^(\d\d\d\d)\b/,
      every: /^every\b/,
      after: /^after\b/,
      before: /^before\b/,
      second: /^(s|sec(ond)?(s)?)\b/,
      minute: /^(m|min(ute)?(s)?)\b/,
      hour: /^(h|hour(s)?)\b/,
      day: /^(day(s)?( of the month)?)\b/,
      dayInstance: /^day instance\b/,
      dayOfWeek: /^day(s)? of the week\b/,
      dayOfYear: /^day(s)? of the year\b/,
      weekOfYear: /^week(s)?( of the year)?\b/,
      weekOfMonth: /^week(s)? of the month\b/,
      weekday: /^weekday\b/,
      weekend: /^weekend\b/,
      month: /^month(s)?\b/,
      year: /^year(s)?\b/,
      between: /^between (the)?\b/,
      start: /^(start(ing)? (at|on( the)?)?)\b/,
      at: /^(at|@)\b/,
      and: /^(,|and\b)/,
      except: /^(except\b)/,
      also: /(also)\b/,
      first: /^(first)\b/,
      last: /^last\b/,
      "in": /^in\b/,
      of: /^of\b/,
      onthe: /^on the\b/,
      on: /^on\b/,
      through: /(-|^(to|through)\b)/
    };
    var NAMES = {
      jan: 1,
      feb: 2,
      mar: 3,
      apr: 4,
      may: 5,
      jun: 6,
      jul: 7,
      aug: 8,
      sep: 9,
      oct: 10,
      nov: 11,
      dec: 12,
      sun: 1,
      mon: 2,
      tue: 3,
      wed: 4,
      thu: 5,
      fri: 6,
      sat: 7,
      "1st": 1,
      fir: 1,
      "2nd": 2,
      sec: 2,
      "3rd": 3,
      thi: 3,
      "4th": 4,
      "for": 4
    };
    function t(start, end, text, type) {
      return {
        startPos: start,
        endPos: end,
        text,
        type
      };
    }
    function peek(expected) {
      var scanTokens = expected instanceof Array ? expected : [expected], whiteSpace = /\s+/, token, curInput, m, scanToken, start, len;
      scanTokens.push(whiteSpace);
      start = pos;
      while (!token || token.type === whiteSpace) {
        len = -1;
        curInput = input.substring(start);
        token = t(start, start, input.split(whiteSpace)[0]);
        var i, length = scanTokens.length;
        for (i = 0; i < length; i++) {
          scanToken = scanTokens[i];
          m = scanToken.exec(curInput);
          if (m && m.index === 0 && m[0].length > len) {
            len = m[0].length;
            token = t(start, start + len, curInput.substring(0, len), scanToken);
          }
        }
        if (token.type === whiteSpace) {
          start = token.endPos;
        }
      }
      return token;
    }
    function scan(expectedToken) {
      var token = peek(expectedToken);
      pos = token.endPos;
      return token;
    }
    function parseThroughExpr(tokenType) {
      var start = +parseTokenValue(tokenType), end = checkAndParse(TOKENTYPES.through) ? +parseTokenValue(tokenType) : start, nums = [];
      for (var i = start; i <= end; i++) {
        nums.push(i);
      }
      return nums;
    }
    function parseRanges(tokenType) {
      var nums = parseThroughExpr(tokenType);
      while (checkAndParse(TOKENTYPES.and)) {
        nums = nums.concat(parseThroughExpr(tokenType));
      }
      return nums;
    }
    function parseEvery(r) {
      var num, period, start, end;
      if (checkAndParse(TOKENTYPES.weekend)) {
        r.on(NAMES.sun, NAMES.sat).dayOfWeek();
      } else if (checkAndParse(TOKENTYPES.weekday)) {
        r.on(NAMES.mon, NAMES.tue, NAMES.wed, NAMES.thu, NAMES.fri).dayOfWeek();
      } else {
        num = parseTokenValue(TOKENTYPES.rank);
        r.every(num);
        period = parseTimePeriod(r);
        if (checkAndParse(TOKENTYPES.start)) {
          num = parseTokenValue(TOKENTYPES.rank);
          r.startingOn(num);
          parseToken(period.type);
        } else if (checkAndParse(TOKENTYPES.between)) {
          start = parseTokenValue(TOKENTYPES.rank);
          if (checkAndParse(TOKENTYPES.and)) {
            end = parseTokenValue(TOKENTYPES.rank);
            r.between(start, end);
          }
        }
      }
    }
    function parseOnThe(r) {
      if (checkAndParse(TOKENTYPES.first)) {
        r.first();
      } else if (checkAndParse(TOKENTYPES.last)) {
        r.last();
      } else {
        r.on(parseRanges(TOKENTYPES.rank));
      }
      parseTimePeriod(r);
    }
    function parseScheduleExpr(str2) {
      pos = 0;
      input = str2;
      error = -1;
      var r = recur();
      while (pos < input.length && error < 0) {
        var token = parseToken([TOKENTYPES.every, TOKENTYPES.after, TOKENTYPES.before, TOKENTYPES.onthe, TOKENTYPES.on, TOKENTYPES.of, TOKENTYPES["in"], TOKENTYPES.at, TOKENTYPES.and, TOKENTYPES.except, TOKENTYPES.also]);
        switch (token.type) {
          case TOKENTYPES.every:
            parseEvery(r);
            break;
          case TOKENTYPES.after:
            if (peek(TOKENTYPES.time).type !== void 0) {
              r.after(parseTokenValue(TOKENTYPES.time));
              r.time();
            } else if (peek(TOKENTYPES.fullDate).type !== void 0) {
              r.after(parseTokenValue(TOKENTYPES.fullDate));
              r.fullDate();
            } else {
              r.after(parseTokenValue(TOKENTYPES.rank));
              parseTimePeriod(r);
            }
            break;
          case TOKENTYPES.before:
            if (peek(TOKENTYPES.time).type !== void 0) {
              r.before(parseTokenValue(TOKENTYPES.time));
              r.time();
            } else if (peek(TOKENTYPES.fullDate).type !== void 0) {
              r.before(parseTokenValue(TOKENTYPES.fullDate));
              r.fullDate();
            } else {
              r.before(parseTokenValue(TOKENTYPES.rank));
              parseTimePeriod(r);
            }
            break;
          case TOKENTYPES.onthe:
            parseOnThe(r);
            break;
          case TOKENTYPES.on:
            r.on(parseRanges(TOKENTYPES.dayName)).dayOfWeek();
            break;
          case TOKENTYPES.of:
            r.on(parseRanges(TOKENTYPES.monthName)).month();
            break;
          case TOKENTYPES["in"]:
            r.on(parseRanges(TOKENTYPES.yearIndex)).year();
            break;
          case TOKENTYPES.at:
            r.on(parseTokenValue(TOKENTYPES.time)).time();
            while (checkAndParse(TOKENTYPES.and)) {
              r.on(parseTokenValue(TOKENTYPES.time)).time();
            }
            break;
          case TOKENTYPES.and:
            break;
          case TOKENTYPES.also:
            r.and();
            break;
          case TOKENTYPES.except:
            r.except();
            break;
          default:
            error = pos;
        }
      }
      return {
        schedules: r.schedules,
        exceptions: r.exceptions,
        error
      };
    }
    function parseTimePeriod(r) {
      var timePeriod = parseToken([TOKENTYPES.second, TOKENTYPES.minute, TOKENTYPES.hour, TOKENTYPES.dayOfYear, TOKENTYPES.dayOfWeek, TOKENTYPES.dayInstance, TOKENTYPES.day, TOKENTYPES.month, TOKENTYPES.year, TOKENTYPES.weekOfMonth, TOKENTYPES.weekOfYear]);
      switch (timePeriod.type) {
        case TOKENTYPES.second:
          r.second();
          break;
        case TOKENTYPES.minute:
          r.minute();
          break;
        case TOKENTYPES.hour:
          r.hour();
          break;
        case TOKENTYPES.dayOfYear:
          r.dayOfYear();
          break;
        case TOKENTYPES.dayOfWeek:
          r.dayOfWeek();
          break;
        case TOKENTYPES.dayInstance:
          r.dayOfWeekCount();
          break;
        case TOKENTYPES.day:
          r.dayOfMonth();
          break;
        case TOKENTYPES.weekOfMonth:
          r.weekOfMonth();
          break;
        case TOKENTYPES.weekOfYear:
          r.weekOfYear();
          break;
        case TOKENTYPES.month:
          r.month();
          break;
        case TOKENTYPES.year:
          r.year();
          break;
        default:
          error = pos;
      }
      return timePeriod;
    }
    function checkAndParse(tokenType) {
      var found = peek(tokenType).type === tokenType;
      if (found) {
        scan(tokenType);
      }
      return found;
    }
    function parseToken(tokenType) {
      var t2 = scan(tokenType);
      if (t2.type) {
        t2.text = convertString(t2.text, tokenType);
      } else {
        error = pos;
      }
      return t2;
    }
    function parseTokenValue(tokenType) {
      return parseToken(tokenType).text;
    }
    function convertString(str2, tokenType) {
      var output = str2;
      switch (tokenType) {
        case TOKENTYPES.time:
          var parts = str2.split(/(:|am|pm)/), hour2 = parts[3] === "pm" && parts[0] < 12 ? parseInt(parts[0], 10) + 12 : parts[0], min2 = parts[2].trim();
          output = (hour2.length === 1 ? "0" : "") + hour2 + ":" + min2;
          break;
        case TOKENTYPES.rank:
          output = parseInt(/^\d+/.exec(str2)[0], 10);
          break;
        case TOKENTYPES.monthName:
        case TOKENTYPES.dayName:
          output = NAMES[str2.substring(0, 3)];
          break;
        case TOKENTYPES.fullDate:
          output = new Date(str2.toUpperCase());
          break;
      }
      return output;
    }
    return parseScheduleExpr(str.toLowerCase());
  };
  return later2;
}();
later.date.localTime();
var later_default = later;

// ../Engine/lib/Engine/calendar/CalendarIntervalMixin.js
var CalendarIntervalMixin = class extends Mixin([AbstractPartOfProjectModelMixin], (base) => {
  const superProto = base.prototype;
  class CalendarIntervalMixin2 extends base {
    static get fields() {
      return [
        "name",
        { name: "startDate", type: "date" },
        { name: "endDate", type: "date" },
        "recurrentStartDate",
        "recurrentEndDate",
        "cls",
        "iconCls",
        { name: "isWorking", type: "boolean", defaultValue: false },
        { name: "priority", type: "number" }
      ];
    }
    getCalendar() {
      return this.stores[0].calendar;
    }
    resetPriority() {
      this.priorityField = null;
      this.getCalendar().getDepth();
    }
    // not just `getPriority` to avoid clash with auto-generated getter in the subclasses
    getPriorityField() {
      if (this.priorityField != null)
        return this.priorityField;
      let base2 = 1e4 + this.getCalendar().getDepth() * 100;
      let priority = this.priority;
      if (priority == null) {
        priority = this.isRecurrent() ? 20 : 30;
      }
      return this.priorityField = base2 + priority;
    }
    /**
     * Whether this interval is recurrent (both [[recurrentStartDate]] and [[recurrentEndDate]] are present and parsed correctly
     * by the `later` library)
     */
    isRecurrent() {
      return Boolean(this.recurrentStartDate && this.recurrentEndDate && this.getStartDateSchedule() && this.getEndDateSchedule());
    }
    /**
     * Whether this interval is static - both [[startDate]] and [[endDate]] are present.
     */
    isStatic() {
      return Boolean(this.startDate && this.endDate);
    }
    /**
     * Helper method to parse [[recurrentStartDate]] and [[recurrentEndDate]] field values.
     * @param {Object|String} schedule Recurrence schedule
     * @returns {Object} Processed schedule ready to be used by later.schedule() method.
     * @private
     */
    parseDateSchedule(value) {
      let schedule = value;
      if (value && value !== Object(value)) {
        schedule = later_default.parse.text(value);
        if (schedule !== Object(schedule) || schedule.error >= 0) {
          try {
            schedule = JSON.parse(value);
          } catch (e) {
            return null;
          }
        }
      }
      return schedule;
    }
    getStartDateSchedule() {
      if (this.startDateSchedule)
        return this.startDateSchedule;
      const schedule = this.parseDateSchedule(this.recurrentStartDate);
      return this.startDateSchedule = later_default.schedule(schedule);
    }
    getEndDateSchedule() {
      if (this.endDateSchedule)
        return this.endDateSchedule;
      if (this.recurrentEndDate === "EOD")
        return "EOD";
      const schedule = this.parseDateSchedule(this.recurrentEndDate);
      return this.endDateSchedule = later_default.schedule(schedule);
    }
  }
  return CalendarIntervalMixin2;
}) {
};

// ../Engine/lib/Engine/calendar/CalendarIntervalStore.js
var CalendarIntervalStore = class extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class CalendarIntervalStore2 extends base {
    constructor() {
      super(...arguments);
      this.disableHasLoadedDataToCommitFlag = true;
    }
    static get defaultConfig() {
      return {
        modelClass: CalendarIntervalMixin
      };
    }
  }
  return CalendarIntervalStore2;
}) {
};

// ../Engine/lib/Engine/util/Types.js
var EdgeInclusion;
(function(EdgeInclusion2) {
  EdgeInclusion2[EdgeInclusion2["Left"] = 0] = "Left";
  EdgeInclusion2[EdgeInclusion2["Right"] = 1] = "Right";
})(EdgeInclusion || (EdgeInclusion = {}));

// ../Engine/lib/Engine/calendar/CalendarCache.js
var CalendarIteratorResult;
(function(CalendarIteratorResult2) {
  CalendarIteratorResult2[CalendarIteratorResult2["FullRangeIterated"] = 0] = "FullRangeIterated";
  CalendarIteratorResult2[CalendarIteratorResult2["StoppedByIterator"] = 1] = "StoppedByIterator";
  CalendarIteratorResult2[CalendarIteratorResult2["MaxCacheExtendCyclesReached"] = 2] = "MaxCacheExtendCyclesReached";
  CalendarIteratorResult2[CalendarIteratorResult2["MaxRangeReached"] = 3] = "MaxRangeReached";
})(CalendarIteratorResult || (CalendarIteratorResult = {}));
var CalendarCache = class {
  constructor(config) {
    this.cacheFilledStartDate = MAX_DATE;
    this.cacheFilledEndDate = MIN_DATE;
    this.intervalsCachingChunkDuration = 30;
    this.intervalsCachingChunkUnit = TimeUnit.Day;
    this.maxCacheExtendCycles = 1e3;
    this.maxRange = 5 * 365 * 24 * 60 * 60 * 1e3;
    config && Object.assign(this, config);
  }
  includeWrappingRangeFrom(cache, startDate, endDate) {
    cache.ensureCacheFilledForInterval(startDate, endDate);
    this.intervalCache.includeWrappingRange(cache.intervalCache, startDate, endDate);
  }
  // after this method, we guarantee, that for every point between `startDate` and `endDate` (_inclusive_)
  // we'll have a final representation of the cache, that is, we'll be able to get an interval to which this point belongs
  // _both_ for forward and backward directions
  ensureCacheFilledForInterval(startDate, endDate) {
    const cacheFilledStartDateN = this.cacheFilledStartDate.getTime();
    const cacheFilledEndDateN = this.cacheFilledEndDate.getTime();
    if (cacheFilledStartDateN !== MAX_DATE.getTime()) {
      const startDateN = startDate.getTime();
      const endDateN = endDate.getTime();
      if (cacheFilledStartDateN <= startDateN && endDateN <= cacheFilledEndDateN)
        return;
      if (endDateN <= cacheFilledStartDateN) {
        endDate = new Date(cacheFilledStartDateN - 1);
      } else if (startDateN >= cacheFilledEndDateN) {
        startDate = new Date(cacheFilledEndDateN);
      } else if (cacheFilledStartDateN <= startDateN && startDateN <= cacheFilledEndDateN) {
        startDate = new Date(cacheFilledEndDateN + 1);
      } else if (cacheFilledStartDateN <= endDateN && endDateN <= cacheFilledEndDateN) {
        endDate = new Date(cacheFilledStartDateN - 1);
      } else {
        this.ensureCacheFilledForInterval(startDate, new Date(cacheFilledStartDateN - 1));
        this.ensureCacheFilledForInterval(new Date(cacheFilledEndDateN + 1), endDate);
        return;
      }
    }
    if (cacheFilledStartDateN === MAX_DATE.getTime() || startDate.getTime() < cacheFilledEndDateN) {
      this.cacheFilledStartDate = startDate;
    }
    if (cacheFilledEndDateN === MIN_DATE.getTime() || cacheFilledEndDateN < endDate.getTime()) {
      this.cacheFilledEndDate = endDate;
    }
    this.fillCache(startDate, endDate);
  }
  fillCache(_1, _2) {
    throw new Error("Abstract method");
  }
  clear() {
    this.cacheFilledStartDate = MAX_DATE;
    this.cacheFilledEndDate = MIN_DATE;
    this.intervalCache.clear();
  }
  /**
   * The core iterator method of the calendar cache.
   *
   * @param options The options for iterator. Should contain at least one of the `startDate`/`endDate` properties
   * which indicates what timespan to examine for availability intervals. If one of boundaries is not provided
   * iterator function should return `false` at some point, to avoid infinite loops.
   *
   * Another recognized option is `isForward`, which indicates the direction in which to iterate through the timespan.
   *
   * Another recognized option is `maxRange`, which indicates the maximum timespan for this iterator (in milliseconds). When iterator
   * exceeds this timespan, the iteration is stopped and [[CalendarIteratorResult.MaxRangeReached]] value is returned.
   * Default value is 5 years.
   *
   * @param func The iterator function to call. It will be called for every distinct set of availability intervals, found
   * in the given timespan. All the intervals, which are "active" for current interval are collected in the 3rd argument
   * for this function. If iterator returns `false` (checked with `===`) the iteration stops.
   *
   * @param scope The scope (`this` value) to execute the iterator in.
   */
  forEachAvailabilityInterval(options, func, scope) {
    var _a2;
    scope = scope || this;
    const startDate = options.startDate;
    const endDate = options.endDate;
    const startDateN = startDate && startDate.getTime();
    const endDateN = endDate && endDate.getTime();
    const maxRange = (_a2 = options.maxRange) != null ? _a2 : this.maxRange;
    const isForward = options.isForward !== false;
    if (isForward ? !startDate : !endDate) {
      throw new Error("At least `startDate` or `endDate` is required, depending from the `isForward` option");
    }
    const intervalCache = this.intervalCache;
    let cacheCursorDate = isForward ? startDate : endDate;
    let cursorDate = isForward ? startDate : endDate;
    const rangeStart = cursorDate.getTime();
    for (let cycle = 1; cycle < this.maxCacheExtendCycles; cycle++) {
      if (isForward) {
        this.ensureCacheFilledForInterval(cacheCursorDate, endDate || DateHelper.add(cacheCursorDate, this.intervalsCachingChunkDuration, this.intervalsCachingChunkUnit));
      } else {
        this.ensureCacheFilledForInterval(startDate || DateHelper.add(cacheCursorDate, -this.intervalsCachingChunkDuration, this.intervalsCachingChunkUnit), cacheCursorDate);
      }
      let interval = intervalCache.getIntervalOf(cursorDate, isForward ? EdgeInclusion.Left : EdgeInclusion.Right);
      while (interval) {
        const intervalStartDate = interval.startDate;
        const intervalEndDate = interval.endDate;
        if (isForward && endDateN && intervalStartDate.getTime() >= endDateN || !isForward && startDateN && intervalEndDate.getTime() <= startDateN) {
          return CalendarIteratorResult.FullRangeIterated;
        }
        if (isForward && intervalStartDate.getTime() - rangeStart >= maxRange || !isForward && rangeStart - intervalEndDate.getTime() >= maxRange) {
          return CalendarIteratorResult.MaxRangeReached;
        }
        if (isForward && intervalStartDate.getTime() >= this.cacheFilledEndDate.getTime() || !isForward && intervalEndDate.getTime() <= this.cacheFilledStartDate.getTime()) {
          break;
        }
        cursorDate = isForward ? intervalEndDate : intervalStartDate;
        const countFrom = startDateN && intervalStartDate.getTime() < startDateN ? startDate : intervalStartDate;
        const countTill = endDateN && intervalEndDate.getTime() > endDateN ? endDate : intervalEndDate;
        if (func.call(scope, countFrom, countTill, interval.cacheInterval) === false) {
          return CalendarIteratorResult.StoppedByIterator;
        }
        interval = isForward ? intervalCache.getNextInterval(interval) : intervalCache.getPrevInterval(interval);
      }
      if (isForward && cursorDate.getTime() === MAX_DATE.getTime() || !isForward && cursorDate.getTime() === MIN_DATE.getTime()) {
        return CalendarIteratorResult.FullRangeIterated;
      }
      cacheCursorDate = isForward ? this.cacheFilledEndDate : this.cacheFilledStartDate;
    }
    return CalendarIteratorResult.MaxCacheExtendCyclesReached;
  }
};

// ../Engine/lib/Engine/util/StripDuplicates.js
var stripDuplicates = (array) => Array.from(new Set(array));

// ../Engine/lib/Engine/calendar/CalendarCacheInterval.js
var CalendarCacheInterval = class {
  constructor(config) {
    this.intervals = [];
    config && Object.assign(this, config);
    if (!this.calendar)
      throw new Error("Required attribute `calendar` is missing");
  }
  includeInterval(interval) {
    if (this.intervals.indexOf(interval) == -1) {
      const copy = this.intervals.slice();
      copy.push(interval);
      return new CalendarCacheInterval({ intervals: copy, calendar: this.calendar });
    } else
      return this;
  }
  combineWith(interval) {
    return new CalendarCacheInterval({ intervals: this.intervals.concat(interval.intervals), calendar: this.calendar });
  }
  /**
   * Returns the working status of this intervals set. It is determined as a working status
   * of the most prioritized interval (intervals are prioritized from child to parent)
   */
  getIsWorking() {
    if (this.isWorking != null)
      return this.isWorking;
    const intervals = this.intervals = this.normalizeIntervals(this.intervals);
    return this.isWorking = intervals[0].isWorking;
  }
  normalizeIntervals(intervals) {
    const filtered = stripDuplicates(intervals);
    filtered.sort((interval1, interval2) => interval2.getPriorityField() - interval1.getPriorityField());
    return filtered;
  }
};

// ../Engine/lib/Engine/util/BinarySearch.js
var binarySearch = (value, array, comparator = (a, b) => a - b) => {
  let left = 0;
  let right = array.length;
  while (left < right) {
    const mid = (left + right) / 2 | 0;
    const compare = comparator(value, array[mid]);
    if (compare === 0)
      return { found: true, index: mid };
    else if (compare < 0)
      right = mid;
    else
      left = mid + 1;
  }
  return { found: false, index: right };
};

// ../Engine/lib/Engine/calendar/SortedMap.js
var IndexPosition;
(function(IndexPosition2) {
  IndexPosition2[IndexPosition2["Exact"] = 0] = "Exact";
  IndexPosition2[IndexPosition2["Next"] = 1] = "Next";
})(IndexPosition || (IndexPosition = {}));
var SortedMap = class {
  constructor(comparator) {
    this.keys = [];
    this.values = [];
    this.comparator = comparator || ((a, b) => a - b);
  }
  set(key, value) {
    const search = binarySearch(key, this.keys, this.comparator);
    if (search.found) {
      this.values[search.index] = value;
    } else {
      this.keys.splice(search.index, 0, key);
      this.values.splice(search.index, 0, value);
    }
    return search.index;
  }
  // you need to know what you are doing when using this method
  insertAt(index, key, value) {
    this.keys.splice(index, 0, key);
    this.values.splice(index, 0, value);
  }
  setValueAt(index, value) {
    this.values[index] = value;
  }
  get(key) {
    const search = binarySearch(key, this.keys, this.comparator);
    return search.found ? this.values[search.index] : void 0;
  }
  getEntryAt(index) {
    return index < this.keys.length ? { key: this.keys[index], value: this.values[index] } : void 0;
  }
  getKeyAt(index) {
    return this.keys[index];
  }
  getValueAt(index) {
    return this.values[index];
  }
  delete(key) {
    const search = binarySearch(key, this.keys, this.comparator);
    if (search.found)
      this.deleteAt(search.index);
  }
  size() {
    return this.keys.length;
  }
  deleteAt(index) {
    this.keys.splice(index, 1);
    this.values.splice(index, 1);
  }
  indexOfKey(key) {
    const search = binarySearch(key, this.keys, this.comparator);
    return {
      found: search.found ? IndexPosition.Exact : IndexPosition.Next,
      index: search.index
    };
  }
  map(func) {
    const keys = this.keys;
    const values = this.values;
    const result = [];
    for (let i = 0; i < keys.length; i++)
      result.push(func(values[i], keys[i], i));
    return result;
  }
  getAllEntries() {
    return this.map((value, key) => {
      return { value, key };
    });
  }
  clear() {
    this.keys.length = 0;
    this.values.length = 0;
  }
};

// ../Engine/lib/Engine/calendar/IntervalCache.js
var IntervalCache = class {
  constructor(config) {
    this.points = new SortedMap((a, b) => a.getTime() - b.getTime());
    this.leftInfinityKey = MIN_DATE;
    this.rightInfinityKey = MAX_DATE;
    Object.assign(this, config);
    if (this.emptyInterval === void 0 || !this.combineIntervalsFn)
      throw new Error("All of `emptyPoint`, `combineIntervalsFn` are required");
    this.points.set(this.leftInfinityKey, this.emptyInterval);
  }
  size() {
    return this.points.size();
  }
  indexOf(date) {
    return this.points.indexOfKey(date);
  }
  getDateAt(index) {
    return this.points.getKeyAt(index);
  }
  getPointAt(index) {
    return this.points.getValueAt(index);
  }
  getIntervalOf(date, edgeInclusion = EdgeInclusion.Left) {
    let { found, index } = this.indexOf(date);
    let startDateIndex;
    if (edgeInclusion === EdgeInclusion.Left) {
      startDateIndex = found === IndexPosition.Exact ? index : index - 1;
    } else {
      startDateIndex = index - 1;
    }
    return this.getIntervalWithStartDateIndex(startDateIndex);
  }
  getPrevInterval(interval) {
    if (interval.startDateIndex === 0)
      return null;
    return this.getIntervalWithStartDateIndex(interval.startDateIndex - 1);
  }
  getNextInterval(interval) {
    if (interval.startDateIndex >= this.size() - 1)
      return null;
    return this.getIntervalWithStartDateIndex(interval.startDateIndex + 1);
  }
  getIntervalWithStartDateIndex(startDateIndex) {
    return {
      startDateIndex,
      startDate: this.getDateAt(startDateIndex),
      endDate: startDateIndex + 1 < this.size() ? this.getDateAt(startDateIndex + 1) : this.rightInfinityKey,
      cacheInterval: this.getPointAt(startDateIndex)
    };
  }
  addInterval(startDate, endDate, extendInterval) {
    const points = this.points;
    const { found, index } = points.indexOfKey(startDate);
    let curIndex;
    let lastUpdatedPoint;
    if (found == IndexPosition.Exact) {
      const inclusion = extendInterval(lastUpdatedPoint = points.getValueAt(index));
      points.setValueAt(index, inclusion);
      curIndex = index + 1;
    } else {
      const inclusion = extendInterval(lastUpdatedPoint = points.getValueAt(index - 1));
      points.insertAt(index, startDate, inclusion);
      curIndex = index + 1;
    }
    while (curIndex < points.size()) {
      const curDate = points.getKeyAt(curIndex);
      if (curDate.getTime() >= endDate.getTime())
        break;
      const inclusion = extendInterval(lastUpdatedPoint = points.getValueAt(curIndex));
      points.setValueAt(curIndex, inclusion);
      curIndex++;
    }
    if (curIndex === points.size()) {
      points.insertAt(points.size(), endDate, this.emptyInterval);
    } else {
      const curDate = points.getKeyAt(curIndex);
      if (curDate.getTime() === endDate.getTime()) {
      } else {
        points.insertAt(curIndex, endDate, lastUpdatedPoint);
      }
    }
  }
  includeWrappingRange(intervalCache, startDate, endDate) {
    let interval = intervalCache.getIntervalOf(startDate);
    while (interval) {
      this.addInterval(interval.startDate, interval.endDate, (existingInterval) => this.combineIntervalsFn(existingInterval, interval.cacheInterval));
      if (interval.endDate.getTime() > endDate.getTime())
        break;
      interval = intervalCache.getNextInterval(interval);
    }
  }
  getSummary() {
    return this.points.map((label, date) => {
      return { label, date };
    });
  }
  clear() {
    this.points.clear();
    this.points.set(this.leftInfinityKey, this.emptyInterval);
  }
};

// ../Core/lib/Core/helper/TimeZoneHelper.js
var TimeZoneOffsetInfo = class extends Array {
  constructor(timeZone, year) {
    super();
    this.timeZone = timeZone;
    this.year = year;
  }
};
var TimeZoneDate = class {
  constructor(asString, timeZone) {
    this.asString = asString;
    this.timeZone = timeZone;
    this.asArray = parseStringDate(asString);
  }
  // Lazy, used in TZH.toTimeZone
  get asLocalDate() {
    if (!this._asLocalDate) {
      this._asLocalDate = new Date(...this.asArray);
    }
    return this._asLocalDate;
  }
  // Lazy, used when finding offsets
  get asTicksUtc() {
    if (!this._asTicksUtc) {
      this._asTicksUtc = new Date(Date.UTC(...this.asArray)).getTime();
    }
    return this._asTicksUtc;
  }
};
var toTimeZoneInternal = (date, timeZone) => {
  const tzDateString = date.toLocaleString("sv-SE", { timeZone });
  return new TimeZoneDate(tzDateString, timeZone);
};
var getOffsetUtc = (ticks, timeZone) => {
  const { asTicksUtc, asString } = toTimeZoneInternal(new Date(ticks), timeZone);
  return { offset: (ticks - asTicksUtc) / 6e4, tzTicksUtc: asTicksUtc, tzString: asString };
};
var parseStringDate = (stringDate) => {
  const parsed = stringDate.split(/[\s-:]/).map((i) => i * 1);
  parsed[1] -= 1;
  return parsed;
};
var min = -6e4;
var hour = 36e5;
var day = -864e5;
var month = 2592e6;
var findOffsetDates = (timeZone, year) => {
  const cached = offsetDateCache.get(timeZone, year);
  if (cached) {
    return cached;
  }
  const offsets = new TimeZoneOffsetInfo(timeZone, year), startUtcTicks = new Date(Date.UTC(year, 0, 1)).getTime();
  let ticks = startUtcTicks, incr = month, monthIndex = 0, previousOffset = [], currentOffset = null, tzTicksUtc, tzString, offset, done;
  while (!done) {
    ({ offset, tzTicksUtc, tzString } = getOffsetUtc(ticks, timeZone));
    if (currentOffset == null) {
      currentOffset = offset;
      offsets.push({ offset });
    } else if (incr > 0 && offset !== currentOffset) {
      incr = incr === month ? day : min;
    } else if (incr < 0 && offset === currentOffset) {
      if (incr === day) {
        incr = hour;
      } else {
        if (offsets.length === 1) {
          offsets.push(previousOffset);
          currentOffset = previousOffset.offset;
        } else {
          offsets[0].startTicks = previousOffset.startTicks;
          offsets[0].startDateString = previousOffset.startDateString;
          done = true;
        }
        incr = month;
      }
    }
    previousOffset = { offset, startDateString: tzString, startTicks: tzTicksUtc };
    if (incr === month) {
      ticks = startUtcTicks;
      ticks += monthIndex * month;
      monthIndex += 1;
    }
    ticks += incr;
    if (monthIndex > 11) {
      done = true;
    }
  }
  offsetDateCache.set(offsets);
  return offsets;
};
var offsetDateCache = {
  _cache: {},
  get(timeZone, year) {
    var _a2;
    return (_a2 = this._cache[timeZone]) == null ? void 0 : _a2[year];
  },
  set(offsetInfo) {
    const { timeZone } = offsetInfo, { _cache } = this;
    if (!_cache[timeZone]) {
      _cache[timeZone] = {};
    }
    _cache[timeZone][offsetInfo.year] = offsetInfo;
  }
};
var TimeZoneHelper = class {
  static get $name() {
    return "TimeZoneHelper";
  }
  /**
   * Adjusts the time of the specified date to match the specified time zone. i.e. "what time is it now in this
   * timezone?"
   *
   * JavaScript dates are always in the local time zone. This function adjusts the time to match the time in the
   * specified time zone, without altering the time zone. Thus, it won't hold the same time as the original date.
   *
   * Note that this time zone calculation relies on the browsers built-in functionality to convert a local date to a
   * string in a given time zone and then converting the string back into a date. If browsers time zone information
   * or interpretation is inaccurate or lacks data, the conversion will probably be inaccurate as well.
   *
   * ```javascript
   * const localDate = new Date(2020, 7, 31, 7); // UTC+2 ('Europe/Stockholm')
   * const cstDate   = TimeZoneHelper.toTimezone(localDate, 'America/Chicago'); // 2020, 7, 31, 0 (still UTC+2, but
   * // appear as UTC-6)
   * ```
   *
   * @static
   * @param {Date} date
   * @param {String|Number} timeZone Timezone supported by `Intl.DateFormat` or a UTC offset in minutes
   * @returns {Date}
   */
  static toTimeZone(date, timeZone) {
    if (typeof timeZone === "number") {
      return this.toUtcOffset(date, timeZone);
    }
    const tzDate = toTimeZoneInternal(date, timeZone);
    if (tzDate.asArray[3] !== tzDate.asLocalDate.getHours()) {
      console.warn("Incorrect time zone conversion due to local DST-switch detected");
    }
    return tzDate.asLocalDate;
  }
  /**
   * Adjusts the time of the specified date to match local system time zone in the specified time zone. i.e. "what
   * time in my timezone would match time in this timezone?"
   *
   * JavaScript dates are always in the local time zone. This function adjusts the time to match the time in the
   * specified time zone, without altering the time zone. Thus, it won't hold the same time as the original date.
   *
   * Note that this time zone calculation relies on the browsers built-in functionality to convert a date from a given
   * timezone into a local date by calculating specified time zone UTC offsets and using those to perform the date
   * conversion. If browsers time zone information or interpretation is inaccurate or lacks data, the conversion will
   * probably be inaccurate as well.
   *
   * ```javascript
   * const cstDate   = new Date(2022, 8, 27, 4); // CST 'America/Chicago'
   * const localDate = TimeZoneHelper.fromTimeZone(cstDate, 'America/Chicago'); // 2022, 8, 27, 11 (UTC+2 Europe/Stockholm)
   * ```
   *
   * @static
   * @param {Date} date
   * @param {String|Number} timeZone Timezone supported by Intl.DateFormat or a UTC offset in minutes
   * @returns {Date}
   */
  static fromTimeZone(date, timeZone) {
    if (typeof timeZone === "number") {
      return this.fromUtcOffset(date, timeZone);
    }
    const dateArr = this.dateAsArray(date), offsetDates = findOffsetDates(timeZone, date.getUTCFullYear());
    let useOffset = offsetDates[0].offset;
    if (offsetDates.length === 2) {
      const utcTicks = Date.UTC(...dateArr);
      if (utcTicks >= offsetDates[1].startTicks && utcTicks < offsetDates[0].startTicks) {
        useOffset = offsetDates[1].offset;
      }
    }
    dateArr[4] += useOffset;
    return new Date(Date.UTC(...dateArr));
  }
  /**
   * Adjusts the time of the specified date with provided UTC offset in minutes
   *
   * JavaScript dates are always in the local time zone. This function adjusts the time to match the time in the
   * specified time zone, without altering the time zone. Thus, it won't hold the same time as the original date.
   *
   * ```javascript
   * const localDate = new Date(2020, 7, 31, 7); // UTC+2
   * const utcDate   = TimeZoneHelper.toUtcOffset(localDate, 0); // 2020, 7, 31, 5 (still UTC+2, but appear as UTC+0)
   * ```
   *
   * @static
   * @private
   * @param {Date} date
   * @param {Number} utcOffset in minutes
   * @returns {Date}
   */
  static toUtcOffset(date, utcOffset) {
    const offset = date.getTimezoneOffset() + utcOffset;
    return new Date(date.getTime() + offset * 60 * 1e3);
  }
  /**
   * Adjusts the time of the specified date by removing the provided UTC offset in minutes.
   *
   * JavaScript dates are always in the local time zone. This function adjusts the time to match the time in the
   * specified time zone, without altering the time zone. Thus, it won't hold the same time as the original date.
   *
   * ```javascript
   * const utcDate = new Date(2020, 7, 31, 7); // UTC
   * const utcDate = TimeZoneHelper.fromUtcOffset(localDate, 0); // 2020, 7, 31, 9 (matches 2020-08-31 07:00+00:00)
   * ```
   *
   * @static
   * @private
   * @param {Date} date
   * @param {Number} utcOffset in minutes
   * @returns {Date}
   */
  static fromUtcOffset(date, utcOffset) {
    const offset = -date.getTimezoneOffset() - utcOffset;
    return new Date(date.getTime() + offset * 60 * 1e3);
  }
  // Converts a date into an array of its parts ([year, month, day, etc.]).
  // Convenient as a date info bearer which is not affected by local time zone
  static dateAsArray(date) {
    return [date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()];
  }
};
TimeZoneHelper.findOffsetDates = findOffsetDates;
TimeZoneHelper._$name = "TimeZoneHelper";

// ../Engine/lib/Engine/calendar/CalendarCacheSingle.js
var CalendarCacheSingle = class extends CalendarCache {
  constructor(config) {
    super(config);
    this.staticIntervalsCached = false;
    if (!this.unspecifiedTimeInterval)
      throw new Error("Required attribute `unspecifiedTimeInterval` is missing");
    this.intervalCache = new IntervalCache({
      emptyInterval: new CalendarCacheInterval({
        intervals: [this.unspecifiedTimeInterval],
        calendar: this.calendar
      }),
      combineIntervalsFn: (interval1, interval2) => {
        return interval1.combineWith(interval2);
      }
    });
  }
  fillCache(startDate, endDate) {
    var _a2;
    if (!this.staticIntervalsCached) {
      this.cacheStaticIntervals();
      this.staticIntervalsCached = true;
    }
    if (this.parentCache)
      this.includeWrappingRangeFrom(this.parentCache, startDate, endDate);
    const startDateN = startDate.getTime();
    const endDateN = endDate.getTime();
    const timeZone = this.calendar.ignoreTimeZone ? null : (_a2 = this.calendar.project) == null ? void 0 : _a2.timeZone;
    if (startDateN > endDateN)
      throw new Error("Invalid cache fill interval");
    this.forEachRecurrentInterval((interval) => {
      const startSchedule = interval.getStartDateSchedule();
      const endSchedule = interval.getEndDateSchedule();
      let wrappingStartDate = startSchedule.prev(1, startDate);
      let wrappingEndDate;
      if (endSchedule === "EOD") {
        const nextEndDate = startSchedule.next(1, endDate);
        if (nextEndDate !== later_default.NEVER) {
          wrappingEndDate = DateHelper.getStartOfNextDay(nextEndDate, true);
        } else {
          wrappingEndDate = later_default.NEVER;
        }
      } else {
        wrappingEndDate = endSchedule.next(1, endDate);
      }
      if (wrappingStartDate !== later_default.NEVER && wrappingStartDate.getTime() === startDateN) {
        const wrappingStartDates = startSchedule.prev(2, startDate);
        if (wrappingStartDates !== later_default.NEVER && wrappingStartDates.length === 2)
          wrappingStartDate = wrappingStartDates[1];
      }
      if (wrappingEndDate !== later_default.NEVER && wrappingEndDate.getTime() === endDateN) {
        const wrappingEndDates = endSchedule.next(2, endDate);
        if (wrappingEndDates !== later_default.NEVER && wrappingEndDates.length === 2)
          wrappingEndDate = wrappingEndDates[1];
      }
      const startDates = startSchedule.next(Infinity, wrappingStartDate !== later_default.NEVER ? wrappingStartDate : startDate, wrappingEndDate !== later_default.NEVER ? new Date(wrappingEndDate.getTime() - 1) : endDate);
      if (startDates === later_default.NEVER)
        return;
      const endDates = endSchedule === "EOD" ? startDates.map((date) => DateHelper.getStartOfNextDay(date, true)) : endSchedule.next(Infinity, new Date(startDates[0].getTime() + 1), wrappingEndDate !== later_default.NEVER ? wrappingEndDate : endDate);
      if (endDates === later_default.NEVER)
        return;
      if (endDates.length > startDates.length) {
        endDates.length = startDates.length;
      } else if (endDates.length < startDates.length) {
        startDates.length = endDates.length;
      }
      startDates.forEach((startDate2, index) => {
        let recStartDate = startDate2;
        let recEndDate = endDates[index];
        if (timeZone != null) {
          recStartDate = TimeZoneHelper.toTimeZone(recStartDate, timeZone);
          recEndDate = TimeZoneHelper.toTimeZone(recEndDate, timeZone);
        }
        this.intervalCache.addInterval(recStartDate, recEndDate, (existingCacheInterval) => existingCacheInterval.includeInterval(interval));
      });
    });
  }
  clear() {
    this.staticIntervalsCached = false;
    super.clear();
  }
  cacheStaticIntervals() {
    this.forEachStaticInterval((interval) => {
      var _a2;
      const timeZone = (_a2 = this.calendar.project) == null ? void 0 : _a2.timeZone;
      let { startDate, endDate } = interval;
      if (timeZone != null) {
        startDate = TimeZoneHelper.toTimeZone(startDate, timeZone);
        endDate = TimeZoneHelper.toTimeZone(endDate, timeZone);
      }
      this.intervalCache.addInterval(startDate, endDate, (existingCacheInterval) => existingCacheInterval.includeInterval(interval));
    });
  }
  forEachStaticInterval(func) {
    this.intervalStore.forEach((interval) => {
      if (interval.isStatic())
        func(interval);
    });
  }
  forEachRecurrentInterval(func) {
    this.intervalStore.forEach((interval) => {
      if (interval.isRecurrent())
        func(interval);
    });
  }
};

// ../Engine/lib/Engine/calendar/UnspecifiedTimeIntervalModel.js
var UnspecifiedTimeIntervalModel = class extends Mixin([CalendarIntervalMixin], (base) => {
  const superProto = base.prototype;
  class UnspecifiedTimeIntervalModel2 extends base {
    getCalendar() {
      return this.calendar;
    }
    // NOTE: See parent class implementation for further comments
    getPriorityField() {
      if (this.priorityField != null)
        return this.priorityField;
      return this.priorityField = this.getCalendar().getDepth();
    }
  }
  return UnspecifiedTimeIntervalModel2;
}) {
};

// ../Engine/lib/Engine/quark/model/AbstractCalendarMixin.js
var AbstractCalendarMixin = class extends Mixin([AbstractPartOfProjectModelMixin], (base) => {
  const superProto = base.prototype;
  class CalendarMixin extends base {
    constructor() {
      super(...arguments);
      this.version = 1;
    }
    // intervalStore            : CalendarIntervalStore
    static get fields() {
      return [
        { name: "version", type: "number" },
        "name",
        { name: "unspecifiedTimeIsWorking", type: "boolean", defaultValue: true },
        { name: "intervals", type: "store", subStore: true },
        "cls",
        "iconCls"
      ];
    }
    get intervalStoreClass() {
      return CalendarIntervalStore;
    }
    get intervalStore() {
      return this.meta.intervalsStore;
    }
    // Not a typo, name is generated from the fields name = intervals
    initIntervalsStore(config) {
      config.storeClass = this.intervalStoreClass;
      config.modelClass = this.getDefaultConfiguration().calendarIntervalModelClass || this.intervalStoreClass.defaultConfig.modelClass;
      config.calendar = this;
    }
    // this method is called when the new value for the `intervals` field of this model is assigned
    // the type of the `intervals` field is "store" that's why this magic
    processIntervalsStoreData(intervals) {
      this.bumpVersion();
    }
    isDefault() {
      const project = this.getProject();
      if (project) {
        return this === project.defaultCalendar;
      }
      return false;
    }
    getDepth() {
      return this.childLevel + 1;
    }
    /**
     * The core iterator method of the calendar.
     *
     * @param options The options for iterator. Should contain at least one of the `startDate`/`endDate` properties
     * which indicates what timespan to examine for availability intervals. If one of boundaries is not provided
     * iterator function should return `false` at some point, to avoid infinite loops.
     *
     * Another recognized option is `isForward`, which indicates the direction in which to iterate through the timespan.
     *
     * @param func The iterator function to call. It will be called for every distinct set of availability intervals, found
     * in the given timespan. All the intervals, which are "active" for current interval are collected in the 3rd argument
     * for this function - [[CalendarCacheInterval|calendarCacheInterval]]. If iterator returns `false` (checked with `===`)
     * the iteration stops.
     *
     * @param scope The scope (`this` value) to execute the iterator in.
     */
    forEachAvailabilityInterval(options, func, scope) {
      var _a2;
      const maxRange = (_a2 = this.getProject()) == null ? void 0 : _a2.maxCalendarRange;
      if (maxRange) {
        options = Object.assign({ maxRange }, options);
      }
      return this.calendarCache.forEachAvailabilityInterval(options, func, scope);
    }
    /**
     * This method starts at the given `date` and moves forward or backward in time, depending on `isForward`.
     * It stops moving as soon as it accumulates the `durationMs` milliseconds of working time and returns the date
     * at which it has stopped and remaining duration - the [[AccumulateWorkingTimeResult]] object.
     *
     * Normally, the remaining duration will be 0, indicating the full `durationMs` has been accumulated.
     * However, sometimes, calendar might not be able to accumulate enough working time due to various reasons,
     * like if it does not contain enough working time - this case will be indicated with remaining duration bigger than 0.
     *
     * @param date
     * @param durationMs
     * @param isForward
     */
    accumulateWorkingTime(date, durationMs, isForward) {
      var _a2, _b;
      if (durationMs === 0)
        return { finalDate: new Date(date), remainingDurationInMs: 0 };
      if (isNaN(durationMs))
        throw new Error("Invalid duration");
      let finalDate = date;
      const adjustDurationToDST = (_b = (_a2 = this.getProject()) == null ? void 0 : _a2.adjustDurationToDST) != null ? _b : false;
      this.forEachAvailabilityInterval(isForward ? { startDate: date, isForward: true } : { endDate: date, isForward: false }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {
        let result = true;
        if (calendarCacheInterval.getIsWorking()) {
          let diff = intervalEndDate.getTime() - intervalStartDate.getTime();
          if (durationMs <= diff) {
            if (adjustDurationToDST) {
              const dstDiff = isForward ? intervalStartDate.getTimezoneOffset() - new Date(intervalStartDate.getTime() + durationMs).getTimezoneOffset() : new Date(intervalEndDate.getTime() - durationMs).getTimezoneOffset() - intervalEndDate.getTimezoneOffset();
              durationMs -= dstDiff * 60 * 1e3;
            }
            finalDate = isForward ? new Date(intervalStartDate.getTime() + durationMs) : new Date(intervalEndDate.getTime() - durationMs);
            durationMs = 0;
            result = false;
          } else {
            if (adjustDurationToDST) {
              const dstDiff = intervalStartDate.getTimezoneOffset() - intervalEndDate.getTimezoneOffset();
              diff += dstDiff * 60 * 1e3;
            }
            finalDate = isForward ? intervalEndDate : intervalStartDate;
            durationMs -= diff;
          }
        }
        return result;
      });
      return { finalDate: new Date(finalDate), remainingDurationInMs: durationMs };
    }
    /**
     * Calculate the working time duration between the 2 dates, in milliseconds.
     *
     * @param {Date} startDate
     * @param {Date} endDate
     * @param {Boolean} [allowNegative] Method ignores negative values by default, returning 0. Set to true to get
     * negative duration.
     */
    calculateDurationMs(startDate, endDate, allowNegative = false) {
      let duration = 0;
      const multiplier = startDate.getTime() <= endDate.getTime() || !allowNegative ? 1 : -1;
      if (multiplier < 0) {
        [startDate, endDate] = [endDate, startDate];
      }
      const adjustDurationToDST = this.getProject().adjustDurationToDST;
      this.forEachAvailabilityInterval({ startDate, endDate }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {
        if (calendarCacheInterval.getIsWorking()) {
          duration += intervalEndDate.getTime() - intervalStartDate.getTime();
          if (adjustDurationToDST) {
            const dstDiff = intervalStartDate.getTimezoneOffset() - intervalEndDate.getTimezoneOffset();
            duration += dstDiff * 60 * 1e3;
          }
        }
      });
      return duration * multiplier;
    }
    /**
     * Calculate the end date of the time interval which starts at `startDate` and has `durationMs` working time duration
     * (in milliseconds).
     *
     * @param startDate
     * @param durationMs
     */
    calculateEndDate(startDate, durationMs) {
      const isForward = durationMs >= 0;
      const res = this.accumulateWorkingTime(startDate, Math.abs(durationMs), isForward);
      return res.remainingDurationInMs === 0 ? res.finalDate : null;
    }
    /**
     * Calculate the start date of the time interval which ends at `endDate` and has `durationMs` working time duration
     * (in milliseconds).
     *
     * @param endDate
     * @param durationMs
     */
    calculateStartDate(endDate, durationMs) {
      const isForward = durationMs <= 0;
      const res = this.accumulateWorkingTime(endDate, Math.abs(durationMs), isForward);
      return res.remainingDurationInMs === 0 ? res.finalDate : null;
    }
    /**
     * Returns the earliest point at which a working period of time starts, following the given date.
     * Can be the date itself, if it comes on the working time.
     *
     * @param date The date after which to skip the non-working time.
     * @param isForward Whether the "following" means forward in time or backward.
     */
    skipNonWorkingTime(date, isForward = true) {
      let workingDate;
      const res = this.forEachAvailabilityInterval(isForward ? { startDate: date, isForward: true } : { endDate: date, isForward: false }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {
        if (calendarCacheInterval.getIsWorking()) {
          workingDate = isForward ? intervalStartDate : intervalEndDate;
          return false;
        }
      });
      if (res === CalendarIteratorResult.MaxRangeReached || res === CalendarIteratorResult.FullRangeIterated)
        return "empty_calendar";
      return workingDate ? new Date(workingDate) : new Date(date);
    }
    /**
     * This method adds a single [[CalendarIntervalMixin]] to the internal collection of the calendar
     */
    addInterval(interval) {
      return this.addIntervals([interval]);
    }
    /**
     * This method adds an array of [[CalendarIntervalMixin]] to the internal collection of the calendar
     */
    addIntervals(intervals) {
      this.bumpVersion();
      return this.intervalStore.add(intervals);
    }
    /**
     * This method removes a single [[CalendarIntervalMixin]] from the internal collection of the calendar
     */
    removeInterval(interval) {
      return this.removeIntervals([interval]);
    }
    /**
     * This method removes an array of [[CalendarIntervalMixin]] from the internal collection of the calendar
     */
    removeIntervals(intervals) {
      this.bumpVersion();
      return this.intervalStore.remove(intervals);
    }
    /**
     * This method removes all intervals from the internal collection of the calendar
     */
    clearIntervals(silent) {
      if (!silent) {
        this.bumpVersion();
      }
      return this.intervalStore.removeAll(silent);
    }
    bumpVersion() {
      this.clearCache();
      this.version++;
    }
    get calendarCache() {
      if (this.$calendarCache !== void 0)
        return this.$calendarCache;
      const unspecifiedTimeInterval = new UnspecifiedTimeIntervalModel({
        isWorking: this.unspecifiedTimeIsWorking
      });
      unspecifiedTimeInterval.calendar = this;
      return this.$calendarCache = new CalendarCacheSingle({
        calendar: this,
        unspecifiedTimeInterval,
        intervalStore: this.intervalStore,
        parentCache: this.parent && !this.parent.isRoot ? this.parent.calendarCache : null
      });
    }
    clearCache() {
      this.$calendarCache && this.$calendarCache.clear();
      this.$calendarCache = void 0;
    }
    resetPriorityOfAllIntervals() {
      this.traverse((calendar) => {
        calendar.intervalStore.forEach((interval) => interval.resetPriority());
      });
    }
    insertChild(child, before, silent) {
      let res = superProto.insertChild.call(this, ...arguments);
      if (!Array.isArray(res)) {
        res = [res];
      }
      res.forEach((r) => {
        r.bumpVersion();
        r.resetPriorityOfAllIntervals();
      });
      return res;
    }
    joinProject() {
      superProto.joinProject.call(this);
      this.intervalStore.setProject(this.getProject());
    }
    leaveProject() {
      superProto.leaveProject.call(this);
      this.intervalStore.setProject(null);
      this.clearCache();
    }
    doDestroy() {
      this.leaveProject();
      this.intervalStore.destroy();
      super.doDestroy();
    }
    isDayHoliday(day2) {
      const startDate = DateHelper.clearTime(day2), endDate = DateHelper.getNext(day2, TimeUnit.Day);
      let hasWorkingTime = false;
      this.forEachAvailabilityInterval({ startDate, endDate, isForward: true }, (_intervalStartDate, _intervalEndDate, calendarCacheInterval) => {
        hasWorkingTime = calendarCacheInterval.getIsWorking();
        return !hasWorkingTime;
      });
      return !hasWorkingTime;
    }
    getDailyHolidaysRanges(startDate, endDate) {
      const result = [];
      startDate = DateHelper.clearTime(startDate);
      while (startDate < endDate) {
        if (this.isDayHoliday(startDate)) {
          result.push({
            startDate,
            endDate: DateHelper.getStartOfNextDay(startDate, true, true)
          });
        }
        startDate = DateHelper.getNext(startDate, TimeUnit.Day);
      }
      return result;
    }
    /**
     * Returns working time ranges between the provided dates.
     * @param startDate Start of the period to get ranges from.
     * @param endDate End of the period to get ranges from.
     *
     * @param {Date} startDate
     * @param {Date} endDate
     */
    getWorkingTimeRanges(startDate, endDate) {
      const result = [];
      this.forEachAvailabilityInterval({ startDate, endDate, isForward: true }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {
        if (calendarCacheInterval.getIsWorking()) {
          const entry = calendarCacheInterval.intervals[0];
          result.push({
            name: entry.name,
            startDate: intervalStartDate,
            endDate: intervalEndDate
          });
        }
      });
      return result;
    }
    /**
     * Returns non-working time ranges between the provided dates.
     * @param startDate Start of the period to get ranges from.
     * @param endDate End of the period to get ranges from.
     *
     * @param {Date} startDate
     * @param {Date} endDate
     */
    getNonWorkingTimeRanges(startDate, endDate) {
      const result = [];
      this.forEachAvailabilityInterval({ startDate, endDate, isForward: true }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {
        if (!calendarCacheInterval.getIsWorking()) {
          const entry = calendarCacheInterval.intervals[0];
          result.push({
            name: entry.name,
            iconCls: entry.iconCls,
            cls: entry.cls,
            startDate: intervalStartDate,
            endDate: intervalEndDate
          });
        }
      });
      return result;
    }
    /**
     * Checks if there is a working time interval in the provided time range (or when just startDate is provided,
     * checks if the date is contained inside a working time interval in this calendar)
     * @param startDate
     * @param [endDate]
     * @param [fullyContained] Pass true to check if the range is fully covered by a single continuous working time block
     */
    isWorkingTime(startDate, endDate, fullyContained) {
      if (fullyContained) {
        let found;
        const res = this.forEachAvailabilityInterval({ startDate, endDate, isForward: true }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {
          if (calendarCacheInterval.getIsWorking() && intervalStartDate <= startDate && intervalEndDate >= endDate) {
            found = true;
            return false;
          }
        });
        if (res === CalendarIteratorResult.MaxRangeReached || res === CalendarIteratorResult.FullRangeIterated)
          return false;
        return found;
      } else {
        const workingTimeStart = this.skipNonWorkingTime(startDate);
        return workingTimeStart && workingTimeStart !== "empty_calendar" ? endDate ? workingTimeStart < endDate : workingTimeStart.getTime() === startDate.getTime() : false;
      }
    }
  }
  return CalendarMixin;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_basic/BaseCalendarMixin.js
var __decorate8 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var EmptyCalendarSymbol = Symbol("EmptyCalendarSymbol");
var BaseCalendarMixin = class extends Mixin([
  AbstractCalendarMixin,
  ChronoPartOfProjectModelMixin
], (base) => {
  class BaseCalendarMixin2 extends base {
    constructor() {
      super(...arguments);
      this.version = 1;
    }
    leaveProject() {
      this.project.clearCombinationsWith(this);
      super.leaveProject();
    }
  }
  __decorate8([
    model_field({}, { persistent: false })
  ], BaseCalendarMixin2.prototype, "version", void 0);
  __decorate8([
    model_field({ type: "boolean", defaultValue: true })
  ], BaseCalendarMixin2.prototype, "unspecifiedTimeIsWorking", void 0);
  __decorate8([
    model_field()
  ], BaseCalendarMixin2.prototype, "intervals", void 0);
  return BaseCalendarMixin2;
}) {
};
var EmptyCalendarEffectDescription = class extends Localizable_default(Base2) {
  static get $name() {
    return "EmptyCalendarEffectDescription";
  }
  static getDescription(effect) {
    const calendar = effect.getCalendar();
    return format(this.L("L{descriptionTpl}"), calendar.name || calendar.id);
  }
};
var EmptyCalendarEffect = class extends SchedulingIssueEffect {
  constructor() {
    super(...arguments);
    this.handler = EmptyCalendarSymbol;
  }
  getResolutions() {
    const calendar = this.getCalendar();
    return this._resolutions || (this._resolutions = [
      Use24hrsEmptyCalendarEffectResolution.new({ calendar }),
      Use8hrsEmptyCalendarEffectResolution.new({ calendar })
    ]);
  }
  /**
   * Returns the calendar that does not have any working periods specified.
   */
  getCalendar() {
    const { calendars } = this;
    if ((calendars == null ? void 0 : calendars.length) > 1) {
      for (const calendar of calendars) {
        const skippingRes = calendar.skipNonWorkingTime(this.date, this.isForward);
        if (!(skippingRes instanceof Date)) {
          return calendar;
        }
      }
    }
    return calendars[0];
  }
};
__decorate8([
  prototypeValue("emptyCalendar")
], EmptyCalendarEffect.prototype, "type", void 0);
__decorate8([
  prototypeValue(EmptyCalendarEffectDescription)
], EmptyCalendarEffect.prototype, "_descriptionBuilderClass", void 0);
var BaseEmptyCalendarEffectResolution = class extends Localizable_default(SchedulingIssueEffectResolution) {
  static get $name() {
    return "BaseEmptyCalendarEffectResolution";
  }
  static get configurable() {
    return {
      /**
       * Correct calendar data.
       * @property calendarData
       */
      calendarData: {
        intervals: [
          { isWorking: true }
        ]
      }
    };
  }
  getDescription() {
    const { calendar } = this;
    return format(this.L("L{descriptionTpl}"), calendar.name || calendar.id);
  }
  /**
   * Fixes the provided calendar data by clearing its intervals
   * amd then applying data specified in `calendarData` config.
   * @param calendar
   */
  fixCalendarData(calendar) {
    var _a2;
    calendar.clearIntervals(true);
    Object.assign(calendar, this.calendarData);
    if ((_a2 = calendar.intervals) == null ? void 0 : _a2.length) {
      calendar.addIntervals(calendar.intervals);
    }
  }
  /**
   * Resolves the [[calendar]] by removing all its intervals and adding new `calendarData`.
   */
  resolve() {
    const { calendar } = this;
    this.fixCalendarData(calendar);
  }
};
var Use24hrsEmptyCalendarEffectResolution = class extends BaseEmptyCalendarEffectResolution {
  static get $name() {
    return "Use24hrsEmptyCalendarEffectResolution";
  }
  static get configurable() {
    return {
      calendarData: {
        unspecifiedTimeIsWorking: false,
        intervals: [
          {
            recurrentStartDate: "on Mon at 0:00",
            recurrentEndDate: "on Sat at 0:00",
            isWorking: true
          }
        ]
      }
    };
  }
};
var Use8hrsEmptyCalendarEffectResolution = class extends BaseEmptyCalendarEffectResolution {
  static get $name() {
    return "Use8hrsEmptyCalendarEffectResolution";
  }
  static get configurable() {
    return {
      calendarData: {
        unspecifiedTimeIsWorking: false,
        intervals: [
          {
            recurrentStartDate: "every weekday at 08:00",
            recurrentEndDate: "every weekday at 12:00",
            isWorking: true
          },
          {
            recurrentStartDate: "every weekday at 13:00",
            recurrentEndDate: "every weekday at 17:00",
            isWorking: true
          }
        ]
      }
    };
  }
};

// ../chronograph/src/chrono/CycleResolver.js
var CycleResolutionInputChrono = class extends CycleResolutionInput {
  /**
   * This method, given an effect handler, identifier and a variable, will add [[CycleResolutionInput.addPreviousValueFlag|previous value]]
   * and [[CycleResolutionInput.addProposedValueFlag|proposed value]] flags for that variable.
   *
   * @param Y An effect handler function, which is given as a 1st argument of every calculation function
   * @param identifier
   * @param symbol
   */
  collectInfo(Y, identifier, symbol) {
    if (Y(PreviousValueOf(identifier)) != null)
      this.addPreviousValueFlag(symbol);
    if (Y(HasProposedNotPreviousValue(identifier)))
      this.addProposedValueFlag(symbol);
  }
};

// ../Engine/lib/Engine/quark/model/scheduler_basic/BaseEventDispatcher.js
var Instruction;
(function(Instruction2) {
  Instruction2["KeepDuration"] = "KeepDuration";
  Instruction2["KeepStartDate"] = "KeepStartDate";
  Instruction2["KeepEndDate"] = "KeepEndDate";
})(Instruction || (Instruction = {}));
var StartDateVar = Symbol("StartDate");
var EndDateVar = Symbol("EndDate");
var DurationVar = Symbol("Duration");
var startDateFormula = Formula.new({
  output: StartDateVar,
  inputs: /* @__PURE__ */ new Set([DurationVar, EndDateVar])
});
var endDateFormula = Formula.new({
  output: EndDateVar,
  inputs: /* @__PURE__ */ new Set([DurationVar, StartDateVar])
});
var durationFormula = Formula.new({
  output: DurationVar,
  inputs: /* @__PURE__ */ new Set([StartDateVar, EndDateVar])
});
var SEDGraphDescription = CycleDescription.new({
  variables: /* @__PURE__ */ new Set([StartDateVar, EndDateVar, DurationVar]),
  formulas: /* @__PURE__ */ new Set([startDateFormula, endDateFormula, durationFormula])
});
var SEDForwardCycleResolutionContext = CycleResolution.new({
  description: SEDGraphDescription,
  defaultResolutionFormulas: /* @__PURE__ */ new Set([endDateFormula])
});
var SEDBackwardCycleResolutionContext = CycleResolution.new({
  description: SEDGraphDescription,
  defaultResolutionFormulas: /* @__PURE__ */ new Set([startDateFormula])
});
var SEDDispatcher = class extends CycleResolutionInputChrono {
  addInstruction(instruction) {
    if (instruction === Instruction.KeepStartDate)
      this.addKeepIfPossibleFlag(StartDateVar);
    if (instruction === Instruction.KeepEndDate)
      this.addKeepIfPossibleFlag(EndDateVar);
    if (instruction === Instruction.KeepDuration)
      this.addKeepIfPossibleFlag(DurationVar);
  }
};
var SEDDispatcherIdentifier = class extends FieldIdentifier.mix(CalculatedValueGen) {
  equality(v1, v2) {
    const resolution1 = v1.resolution;
    const resolution2 = v2.resolution;
    const res = resolution1.get(StartDateVar) === resolution2.get(StartDateVar) && resolution1.get(EndDateVar) === resolution2.get(EndDateVar) && resolution1.get(DurationVar) === resolution2.get(DurationVar) || // https://github.com/bryntum/support/issues/6262
    // for the unscheduled tasks (missing all 3 values), resolution of the `v1` will be "keep all proposed"
    // which is always different from the default resolution
    // this leads to the dispatcher identifiers remaining "self-dependent" and re-calculated at every commit
    // process this case specially
    // note, that this is more a patch, a proper solution would probably be to change this line:
    // chronograph/src/chrono/CycleResolver.ts
    //      if (Y(PreviousValueOf(identifier)) != null) this.addPreviousValueFlag(symbol)
    // to
    //      if (Y(PreviousValueOf(identifier)) !== undefined) this.addPreviousValueFlag(symbol)
    // however this breaks normalization tests
    resolution1.get(StartDateVar) === CalculateProposed && resolution1.get(EndDateVar) === CalculateProposed && resolution1.get(DurationVar) === CalculateProposed;
    return res;
  }
};

// ../Engine/lib/Engine/calendar/CalendarCacheIntervalMultiple.js
var CalendarCacheIntervalMultiple = class {
  constructor(config) {
    this.intervalGroups = [];
    config && Object.assign(this, config);
  }
  combineWith(interval) {
    const copy = this.intervalGroups.slice();
    copy.push([interval.calendar, interval]);
    return new CalendarCacheIntervalMultiple({ intervalGroups: copy });
  }
  getIsWorkingForEvery() {
    if (this.isWorkingForEvery != null)
      return this.isWorkingForEvery;
    for (let [_calendar, intervals] of this.getGroups()) {
      if (!intervals[0].isWorking)
        return this.isWorkingForEvery = false;
    }
    return this.isWorkingForEvery = true;
  }
  getIsWorkingForSome() {
    if (this.isWorkingForSome != null)
      return this.isWorkingForSome;
    for (let [_calendar, intervals] of this.getGroups()) {
      if (intervals[0].isWorking)
        return this.isWorkingForSome = true;
    }
    return this.isWorkingForSome = false;
  }
  getCalendars() {
    this.getGroups();
    return this.calendars;
  }
  isCalendarWorking(calendar) {
    return this.getCalendarsWorkStatus().get(calendar);
  }
  getCalendarsWorkStatus() {
    if (this.calendarsWorkStatus)
      return this.calendarsWorkStatus;
    const res = /* @__PURE__ */ new Map();
    for (let [calendar, intervals] of this.getGroups()) {
      res.set(calendar, intervals[0].isWorking);
    }
    return this.calendarsWorkStatus = res;
  }
  getCalendarsWorking() {
    if (this.calendarsWorking)
      return this.calendarsWorking;
    const calendars = [];
    for (let [calendar, intervals] of this.getGroups()) {
      if (intervals[0].isWorking)
        calendars.push(calendar);
    }
    return this.calendarsWorking = calendars;
  }
  getCalendarsNonWorking() {
    if (this.calendarsNonWorking)
      return this.calendarsNonWorking;
    const calendars = [];
    for (let [calendar, intervals] of this.getGroups()) {
      if (!intervals[0].isWorking)
        calendars.push(calendar);
    }
    return this.calendarsNonWorking = calendars;
  }
  getGroups() {
    if (this.intervalsByCalendar)
      return this.intervalsByCalendar;
    const calendars = this.calendars = [];
    const intervalsByCalendar = /* @__PURE__ */ new Map();
    this.intervalGroups.forEach(([calendar, interval]) => {
      let data = intervalsByCalendar.get(calendar);
      if (!data) {
        calendars.push(calendar);
        data = [];
        intervalsByCalendar.set(calendar, data);
      }
      data.push.apply(data, interval.intervals);
    });
    intervalsByCalendar.forEach((intervals, calendar) => {
      const unique = stripDuplicates(intervals);
      unique.sort(
        // sort in decreasing order
        (interval1, interval2) => interval2.getPriorityField() - interval1.getPriorityField()
      );
      intervalsByCalendar.set(calendar, unique);
    });
    return this.intervalsByCalendar = intervalsByCalendar;
  }
};

// ../Engine/lib/Engine/calendar/CalendarCacheMultiple.js
var CalendarCacheMultiple = class extends CalendarCache {
  constructor(config) {
    super(config);
    this.calendarCaches = stripDuplicates(this.calendarCaches);
    this.intervalCache = new IntervalCache({
      emptyInterval: new CalendarCacheIntervalMultiple(),
      combineIntervalsFn: (interval1, interval2) => {
        return interval1.combineWith(interval2);
      }
    });
  }
  fillCache(startDate, endDate) {
    this.calendarCaches.forEach((calendarCache) => {
      calendarCache.fillCache(startDate, endDate);
      this.includeWrappingRangeFrom(calendarCache, startDate, endDate);
    });
  }
};
var COMBINED_CALENDARS_CACHE = /* @__PURE__ */ new Map();
var combineCalendars = (calendars) => {
  const uniqueOnly2 = stripDuplicates(calendars);
  if (uniqueOnly2.length === 0)
    throw new Error("No calendars to combine");
  uniqueOnly2.sort((calendar1, calendar2) => {
    if (calendar1.internalId < calendar2.internalId)
      return -1;
    else
      return 1;
  });
  const hash = uniqueOnly2.map((calendar) => calendar.internalId + "/").join("");
  const versionsHash = uniqueOnly2.map((calendar) => calendar.version + "/").join("");
  let cached = COMBINED_CALENDARS_CACHE.get(hash);
  let res;
  if (cached && cached.versionsHash === versionsHash)
    res = cached.cache;
  else {
    res = new CalendarCacheMultiple({ calendarCaches: uniqueOnly2.map((calendar) => calendar.calendarCache) });
  }
  return res;
};

// ../Engine/lib/Engine/quark/model/scheduler_basic/HasCalendarMixin.js
var __decorate9 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HasCalendarMixin = class extends Mixin([ChronoPartOfProjectModelMixin], (base) => {
  class HasCalendarMixin2 extends base {
    writeCalendar(me, transaction, quark, calendar) {
      const calendarManagerStore = this.getCalendarManagerStore();
      const cal = calendar;
      if (calendar && calendarManagerStore && calendar instanceof BaseCalendarMixin && !calendarManagerStore.includes(cal)) {
        calendarManagerStore.add(calendar);
      }
      me.constructor.prototype.write.call(this, me, transaction, quark, calendar);
    }
    resolveCalendar(locator) {
      var _a2;
      return (_a2 = this.getCalendarManagerStore()) == null ? void 0 : _a2.getById(locator);
    }
    /**
     * Calculation method of the [[effectiveCalendar]]. Takes the calendar from the project, if not provided to the entity explicitly.
     */
    *calculateEffectiveCalendar() {
      let calendar = yield this.$.calendar;
      if (!calendar) {
        const project = this.getProject();
        calendar = yield project.$.effectiveCalendar;
      }
      yield calendar.$.version;
      return calendar;
    }
    //region STM hooks
    shouldRecordFieldChange(fieldName, oldValue, newValue) {
      if (!super.shouldRecordFieldChange(fieldName, oldValue, newValue)) {
        return false;
      }
      const { project } = this;
      if (fieldName === "calendar" && project) {
        const { calendarManagerStore } = project;
        return calendarManagerStore.oldIdMap[oldValue] !== calendarManagerStore.getById(newValue);
      }
      return true;
    }
  }
  __decorate9([
    field({
      equality: () => false
    })
  ], HasCalendarMixin2.prototype, "effectiveCalendar", void 0);
  __decorate9([
    generic_field({
      modelFieldConfig: {
        persist: true,
        // we don't use calendar?.id here since we need to preserve calendar==null value
        // while optional chaining will result undefined in this case
        serialize: (calendar) => calendar === void 0 ? void 0 : (calendar == null ? void 0 : calendar.id) || null,
        isEqual: isSerializableEqual
      },
      resolver: function(locator) {
        return this.resolveCalendar(locator);
      },
      sync: true
    }, ModelReferenceField)
  ], HasCalendarMixin2.prototype, "calendar", void 0);
  __decorate9([
    write("calendar")
  ], HasCalendarMixin2.prototype, "writeCalendar", null);
  __decorate9([
    calculate("effectiveCalendar")
  ], HasCalendarMixin2.prototype, "calculateEffectiveCalendar", null);
  injectStaticFieldsProperty(HasCalendarMixin2);
  return HasCalendarMixin2;
}) {
};
var CanCombineCalendarsMixin = class extends Mixin([], (base) => {
  class CanCombineCalendars extends base {
    constructor() {
      super(...arguments);
      this.combinedCalendarsCache = /* @__PURE__ */ new Map();
      this.combinationsByCalendar = /* @__PURE__ */ new Map();
    }
    /**
     * Combines an array of calendars into a single [[CalendarCacheMultiple]], which provides an API similar (but not exactly the same) to [[BaseCalendarMixin]]
     *
     * @param calendars
     */
    combineCalendars(calendars) {
      const uniqueOnly2 = stripDuplicates(calendars);
      if (uniqueOnly2.length === 0)
        throw new Error("No calendars to combine");
      uniqueOnly2.sort((calendar1, calendar2) => {
        if (calendar1.internalId < calendar2.internalId)
          return -1;
        else
          return 1;
      });
      const hash = uniqueOnly2.map((calendar) => calendar.internalId + "/").join("");
      const versionsHash = uniqueOnly2.map((calendar) => calendar.version + "/").join("");
      const cached = this.combinedCalendarsCache.get(hash);
      let res;
      if (cached && cached.versionsHash === versionsHash)
        res = cached.cache;
      else {
        res = new CalendarCacheMultiple({ calendarCaches: uniqueOnly2.map((calendar) => calendar.calendarCache) });
        this.combinedCalendarsCache.set(hash, {
          versionsHash,
          cache: res
        });
        uniqueOnly2.forEach((calendar) => {
          let combinationsByCalendar = this.combinationsByCalendar.get(calendar);
          if (!combinationsByCalendar) {
            combinationsByCalendar = /* @__PURE__ */ new Set();
            this.combinationsByCalendar.set(calendar, combinationsByCalendar);
          }
          combinationsByCalendar.add(hash);
        });
      }
      return res;
    }
    clearCombinationsWith(calendar) {
      const combinationsByCalendar = this.combinationsByCalendar.get(calendar);
      if (combinationsByCalendar) {
        combinationsByCalendar.forEach((hash) => this.combinedCalendarsCache.delete(hash));
        this.combinationsByCalendar.delete(calendar);
      }
    }
  }
  return CanCombineCalendars;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_basic/BaseEventMixin.js
var __decorate10 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var BaseEventMixin = class extends Mixin([HasCalendarMixin], (base) => {
  const superProto = base.prototype;
  class BaseEventMixin2 extends base {
    *calculateDispatcher(YIELD) {
      const proposed = yield ProposedOrPrevious;
      const cycleDispatcher = yield* this.prepareDispatcher(YIELD);
      const startDateProposedArgs = yield ProposedArgumentsOf(this.$.startDate);
      const startInstruction = startDateProposedArgs ? startDateProposedArgs[0] ? Instruction.KeepDuration : Instruction.KeepEndDate : void 0;
      if (startInstruction)
        cycleDispatcher.addInstruction(startInstruction);
      const endDateProposedArgs = yield ProposedArgumentsOf(this.$.endDate);
      const endInstruction = endDateProposedArgs ? endDateProposedArgs[0] ? Instruction.KeepDuration : Instruction.KeepStartDate : void 0;
      if (endInstruction)
        cycleDispatcher.addInstruction(endInstruction);
      const directionValue = yield this.$.effectiveDirection;
      const durationProposedArgs = yield ProposedArgumentsOf(this.$.duration);
      let durationInstruction;
      if (durationProposedArgs) {
        switch (durationProposedArgs[0]) {
          case true:
            durationInstruction = Instruction.KeepStartDate;
            break;
          case false:
            durationInstruction = Instruction.KeepEndDate;
            break;
        }
      }
      if (!durationInstruction && cycleDispatcher.hasProposedValue(DurationVar)) {
        durationInstruction = directionValue.direction === Direction.Forward || directionValue.direction === Direction.None ? Instruction.KeepStartDate : Instruction.KeepEndDate;
      }
      if (durationInstruction)
        cycleDispatcher.addInstruction(durationInstruction);
      return cycleDispatcher;
    }
    *prepareDispatcher(Y) {
      const dispatcherClass = this.dispatcherClass(Y);
      const cycleDispatcher = dispatcherClass.new({
        context: this.cycleResolutionContext(Y)
      });
      cycleDispatcher.collectInfo(Y, this.$.startDate, StartDateVar);
      cycleDispatcher.collectInfo(Y, this.$.endDate, EndDateVar);
      cycleDispatcher.collectInfo(Y, this.$.duration, DurationVar);
      return cycleDispatcher;
    }
    cycleResolutionContext(Y) {
      const direction = Y(this.$.effectiveDirection);
      return direction.direction === Direction.Forward || direction.direction === Direction.None ? SEDForwardCycleResolutionContext : SEDBackwardCycleResolutionContext;
    }
    dispatcherClass(Y) {
      return SEDDispatcher;
    }
    buildProposedDispatcher(me, quark, transaction) {
      const dispatcher = this.dispatcherClass(transaction.onEffectSync).new({
        context: this.cycleResolutionContext(transaction.onEffectSync)
      });
      dispatcher.addPreviousValueFlag(StartDateVar);
      dispatcher.addPreviousValueFlag(EndDateVar);
      dispatcher.addPreviousValueFlag(DurationVar);
      return dispatcher;
    }
    /**
     * The method skips the event non working time starting from the provided `date` and
     * going either _forward_ or _backward_ in time.
     * It uses the event [[effectiveCalendar|effective calendar]] to detect which time is not working.
     * @param date Date to start skipping from
     * @param isForward Skip direction (`true` to go forward in time, `false` - backwards)
     */
    *skipNonWorkingTime(date, isForward) {
      const calendar = yield this.$.effectiveCalendar;
      if (!date)
        return null;
      const skippingRes = calendar.skipNonWorkingTime(date, isForward);
      if (skippingRes instanceof Date) {
        return skippingRes;
      } else {
        const effect = EmptyCalendarEffect.new({
          calendars: [calendar],
          event: this,
          date,
          isForward
        });
        if ((yield effect) === EffectResolutionResult.Cancel) {
          yield Reject(effect);
        } else {
          return null;
        }
      }
    }
    /**
     * The method skips the provided amount of the event _working time_
     * starting from the `date` and going either _forward_ or _backward_ in time.
     * It uses the event [[effectiveCalendar|effective calendar]] to detect which time is not working.
     * @param date Date to start skipping from
     * @param isForward Skip direction (`true` to go forward in time, `false` - backwards)
     * @param duration Amount of working time to skip
     * @param unit Units the `duration` value in (if not provided then duration is considered provided in [[durationUnit]])
     */
    *skipWorkingTime(date, isForward, duration, unit) {
      const durationUnit = yield this.$.durationUnit;
      if (unit && unit !== durationUnit) {
        duration = yield* this.getProject().$convertDuration(duration, unit, durationUnit);
      }
      return yield* this.calculateProjectedXDateWithDuration(date, isForward, duration);
    }
    // copied generated method, to avoid compilation error when it is overridden in HasDateConstraintMixin
    /**
     * Sets the event [[startDate|start date]]
     *
     * @param date The new start date to set
     * @param keepDuration Whether the intention is to keep the `duration` field (`keepDuration = true`) or `endDate` (`keepDuration = false`)
     */
    setStartDate(date, keepDuration = true) {
      const { graph, project } = this;
      if (graph) {
        graph.write(this.$.startDate, date, keepDuration);
        return graph.commitAsync();
      } else {
        this.$.startDate.DATA = date;
        return project == null ? void 0 : project.delayedCalculationPromise;
      }
    }
    writeStartDate(me, transaction, quark, date, keepDuration = true) {
      if (!transaction.baseRevision.hasIdentifier(me) && date == null)
        return;
      if (!this.getProject().isStmRestoring) {
        this.$.unscheduled.write(this.$.unscheduled, transaction, void 0, date == null);
      }
      me.constructor.prototype.write.call(this, me, transaction, quark, date, keepDuration);
    }
    /**
     * The main calculation method for the [[startDate]] field. Delegates to either [[calculateStartDateProposed]]
     * or [[calculateStartDatePure]], depending on the information from [[dispatcher]]
     */
    *calculateStartDate() {
      const dispatch = yield this.$.dispatcher;
      const formulaId = dispatch.resolution.get(StartDateVar);
      if (formulaId === CalculateProposed) {
        return yield* this.calculateStartDateProposed();
      } else if (formulaId === startDateFormula.formulaId) {
        return yield* this.calculateStartDatePure();
      } else {
        throw new Error("Unknown formula for `startDate`");
      }
    }
    /**
     * The "pure" calculation function of the [[startDate]] field. It should calculate the [[startDate]] as if
     * there's no user input for it and no previous value - "purely" based on the values of other fields.
     *
     * At this level it delegates to [[calculateProjectedXDateWithDuration]]
     *
     * See also [[calculateStartDateProposed]].
     */
    *calculateStartDatePure() {
      return yield* this.calculateProjectedXDateWithDuration(yield this.$.endDate, false, yield this.$.duration);
    }
    /**
     * The "proposed" calculation function of the [[startDate]] field. It should calculate the [[startDate]] as if
     * there's a user input for it or a previous value. It can also use the values of other fields to "validate"
     * the "proposed" value.
     *
     * See also [[calculateStartDatePure]]
     */
    *calculateStartDateProposed() {
      const project = this.getProject();
      const startDate = yield ProposedOrPrevious;
      const manuallyScheduled = yield this.$.manuallyScheduled;
      return !manuallyScheduled || project.skipNonWorkingTimeWhenSchedulingManually ? yield* this.skipNonWorkingTime(startDate, true) : startDate;
    }
    /**
     * This method calculates the opposite date of the event.
     *
     * @param baseDate The base date of the event (start or end date)
     * @param isForward Boolean flag, indicating whether the given `baseDate` is start date (`true`) or end date (`false`)
     * @param duration Duration of the event, in its [[durationUnit|durationUnits]]
     */
    *calculateProjectedXDateWithDuration(baseDate, isForward, duration) {
      const durationUnit = yield this.$.durationUnit;
      const calendar = yield this.$.effectiveCalendar;
      const project = this.getProject();
      if (!baseDate || isNotNumber(duration))
        return null;
      isForward = isForward === void 0 ? true : isForward;
      if (isForward) {
        return calendar.calculateEndDate(baseDate, yield* project.$convertDuration(duration, durationUnit, TimeUnit.Millisecond));
      } else {
        return calendar.calculateStartDate(baseDate, yield* project.$convertDuration(duration, durationUnit, TimeUnit.Millisecond));
      }
    }
    // copied generated method, to specify the default value for `keepDuration`
    // and to avoid compilation error when it is overridden in HasDateConstraintMixin
    /**
     * Sets the event [[endDate|end date]].
     *
     * @param date The new end date to set
     * @param keepDuration Whether the intention is to keep the `duration` field (`keepDuration = true`) or `startDate` (`keepDuration = false`)
     */
    setEndDate(date, keepDuration = false) {
      const { graph, project } = this;
      if (graph) {
        graph.write(this.$.endDate, date, keepDuration);
        return graph.commitAsync();
      } else {
        this.$.endDate.DATA = date;
        return project == null ? void 0 : project.delayedCalculationPromise;
      }
    }
    writeEndDate(me, transaction, quark, date, keepDuration = false) {
      if (!transaction.baseRevision.hasIdentifier(me) && date == null)
        return;
      if (!this.getProject().isStmRestoring) {
        this.$.unscheduled.write(this.$.unscheduled, transaction, void 0, date == null);
      }
      me.constructor.prototype.write.call(this, me, transaction, quark, date, keepDuration);
    }
    /**
     * The main calculation method for the [[endDate]] field. Delegates to either [[calculateEndDateProposed]]
     * or [[calculateEndDatePure]], depending on the information from [[dispatcher]]
     */
    *calculateEndDate() {
      const dispatch = yield this.$.dispatcher;
      const formulaId = dispatch.resolution.get(EndDateVar);
      if (formulaId === CalculateProposed) {
        return yield* this.calculateEndDateProposed();
      } else if (formulaId === endDateFormula.formulaId) {
        return yield* this.calculateEndDatePure();
      } else {
        throw new Error("Unknown formula for `endDate`");
      }
    }
    /**
     * The "pure" calculation function of the [[endDate]] field. It should calculate the [[endDate]] as if
     * there's no user input for it and no previous value - "purely" based on the values of other fields.
     *
     * At this level it delegates to [[calculateProjectedXDateWithDuration]]
     *
     * See also [[calculateEndDateProposed]].
     */
    *calculateEndDatePure() {
      return yield* this.calculateProjectedXDateWithDuration(yield this.$.startDate, true, yield this.$.duration);
    }
    /**
     * The "proposed" calculation function of the [[endDate]] field. It should calculate the [[endDate]] as if
     * there's a user input for it or a previous value. It can also use the values of other fields to "validate"
     * the "proposed" value.
     *
     * See also [[calculateEndDatePure]]
     */
    *calculateEndDateProposed() {
      const project = this.getProject();
      const endDate = yield ProposedOrPrevious;
      const manuallyScheduled = yield this.$.manuallyScheduled;
      return !manuallyScheduled || project.skipNonWorkingTimeWhenSchedulingManually ? yield* this.skipNonWorkingTime(endDate, false) : endDate;
    }
    //endregion
    //region duration
    /**
     * Duration getter. Returns the duration of the event, in the given unit. If unit is not given, returns duration in [[durationUnit]].
     *
     * @param unit
     */
    getDuration(unit) {
      const duration = this.duration;
      return unit !== void 0 ? this.getProject().convertDuration(duration, this.durationUnit, unit) : duration;
    }
    /**
     * Duration setter.
     *
     * @param duration The new duration to set.
     * @param unit The unit for new duration. Optional, if missing the [[durationUnit]] value will be used.
     * @param keepStart A boolean flag, indicating, whether the intention is to keep the start date (`true`) or end date (`false`)
     */
    setDuration(duration, unit, keepStart) {
      const { graph, project } = this;
      if (graph) {
        if (duration !== void 0) {
          graph.write(this.$.duration, duration, unit, keepStart);
          return graph.commitAsync();
        }
      } else {
        const toSet = { duration };
        this.$.duration.DATA = duration;
        if (unit != null)
          toSet.durationUnit = this.$.durationUnit.DATA = unit;
        this.set(toSet);
        return project == null ? void 0 : project.delayedCalculationPromise;
      }
    }
    setDurationUnit(_value) {
      throw new Error("Use `setDuration` instead");
    }
    writeDuration(me, transaction, quark, duration, unit, keepStart = void 0) {
      if (duration < 0)
        duration = 0;
      if (!transaction.baseRevision.hasIdentifier(me) && duration == null)
        return;
      if (!this.getProject().isStmRestoring) {
        this.$.unscheduled.write(this.$.unscheduled, transaction, void 0, duration == null);
      }
      me.constructor.prototype.write.call(this, me, transaction, quark, duration, keepStart);
      if (unit != null)
        transaction.write(this.$.durationUnit, unit);
    }
    /**
     * The main calculation method for the [[duration]] field. Delegates to either [[calculateDurationProposed]]
     * or [[calculateDurationPure]], depending on the information from [[dispatcher]]
     */
    *calculateDuration() {
      const dispatch = yield this.$.dispatcher;
      const formulaId = dispatch.resolution.get(DurationVar);
      if (formulaId === CalculateProposed) {
        return yield* this.calculateDurationProposed();
      } else if (formulaId === durationFormula.formulaId) {
        return yield* this.calculateDurationPure();
      } else {
        throw new Error("Unknown formula for `duration`");
      }
    }
    /**
     * The "pure" calculation function of the [[duration]] field. It should calculate the [[duration]] as if
     * there's no user input for it and no previous value - "purely" based on the values of other fields.
     *
     * If start date of event is less or equal then end date (normal case) it delegates to [[calculateProjectedDuration]].
     * Otherwise, duration is set to 0.
     *
     * See also [[calculateDurationProposed]].
     */
    *calculateDurationPure() {
      const startDate = yield this.$.startDate;
      const endDate = yield this.$.endDate;
      if (!startDate || !endDate)
        return null;
      if (startDate > endDate) {
        yield Write(this.$.duration, 0, null);
      } else {
        return yield* this.calculateProjectedDuration(startDate, endDate);
      }
    }
    /**
     * The "proposed" calculation function of the [[duration]] field. It should calculate the [[duration]] as if
     * there's a user input for it or a previous value. It can also use the values of other fields to "validate"
     * the "proposed" value.
     *
     * See also [[calculateDurationPure]]
     */
    *calculateDurationProposed() {
      return yield ProposedOrPrevious;
    }
    /**
     * This method calculates the duration of the given time span, in the provided `durationUnit` or in the [[durationUnit]].
     *
     * @param startDate
     * @param endDate
     * @param durationUnit
     */
    *calculateProjectedDuration(startDate, endDate, durationUnit) {
      if (!startDate || !endDate)
        return null;
      if (!durationUnit)
        durationUnit = yield this.$.durationUnit;
      const calendar = yield this.$.effectiveCalendar;
      const project = this.getProject();
      return yield* project.$convertDuration(calendar.calculateDurationMs(startDate, endDate), TimeUnit.Millisecond, durationUnit);
    }
    // effective duration is either a "normal" duration, or, if the duration itself is being calculated
    // (so that yielding it will cause a cycle)
    // an "estimated" duration, calculated based on proposed/previous start/end date values
    *calculateEffectiveDuration() {
      const dispatch = yield this.$.dispatcher;
      let effectiveDurationToUse;
      const durationResolution = dispatch.resolution.get(DurationVar);
      if (durationResolution === CalculateProposed) {
        effectiveDurationToUse = yield this.$.duration;
      } else if (durationResolution === durationFormula.formulaId) {
        effectiveDurationToUse = yield* this.calculateProjectedDuration(yield ProposedOrPreviousValueOf(this.$.startDate), yield ProposedOrPreviousValueOf(this.$.endDate));
      }
      return effectiveDurationToUse;
    }
    *calculateEffectiveDirection() {
      const direction = yield this.$.direction;
      return {
        // our TS version is a bit too old
        kind: "own",
        direction: direction || Direction.Forward
      };
    }
    // for leaf-events it just translates the value of `effectiveDirection`
    // for parent-events there will be more complex logic
    *calculateStartDateDirection() {
      return yield this.$.effectiveDirection;
    }
    *calculateEndDateDirection() {
      return yield this.$.effectiveDirection;
    }
    //endregion
    *calculateEffectiveCalendar() {
      const manuallyScheduled = yield this.$.manuallyScheduled;
      const project = this.getProject();
      return manuallyScheduled && !project.skipNonWorkingTimeInDurationWhenSchedulingManually ? project.defaultCalendar : yield* super.calculateEffectiveCalendar();
    }
  }
  __decorate10([
    model_field({ type: "date" }, { converter: dateConverter })
  ], BaseEventMixin2.prototype, "startDate", void 0);
  __decorate10([
    model_field({ type: "date" }, { converter: dateConverter })
  ], BaseEventMixin2.prototype, "endDate", void 0);
  __decorate10([
    model_field({ type: "number", allowNull: true })
  ], BaseEventMixin2.prototype, "duration", void 0);
  __decorate10([
    model_field({ type: "string", defaultValue: TimeUnit.Day }, { converter: (unit) => DateHelper.normalizeUnit(unit) || TimeUnit.Day })
  ], BaseEventMixin2.prototype, "durationUnit", void 0);
  __decorate10([
    model_field({ type: "string" }, { sync: true })
  ], BaseEventMixin2.prototype, "direction", void 0);
  __decorate10([
    field({ sync: true, equality: isEqualEffectiveDirection })
  ], BaseEventMixin2.prototype, "startDateDirection", void 0);
  __decorate10([
    field({ sync: true, equality: isEqualEffectiveDirection })
  ], BaseEventMixin2.prototype, "endDateDirection", void 0);
  __decorate10([
    model_field({ persist: false, isEqual: isEqualEffectiveDirection }, { sync: true, equality: isEqualEffectiveDirection })
  ], BaseEventMixin2.prototype, "effectiveDirection", void 0);
  __decorate10([
    field({ identifierCls: SEDDispatcherIdentifier })
  ], BaseEventMixin2.prototype, "dispatcher", void 0);
  __decorate10([
    model_field({ type: "boolean", defaultValue: false }, { sync: true })
  ], BaseEventMixin2.prototype, "manuallyScheduled", void 0);
  __decorate10([
    model_field({ type: "boolean", defaultValue: false })
  ], BaseEventMixin2.prototype, "unscheduled", void 0);
  __decorate10([
    calculate("dispatcher")
  ], BaseEventMixin2.prototype, "calculateDispatcher", null);
  __decorate10([
    build_proposed("dispatcher")
  ], BaseEventMixin2.prototype, "buildProposedDispatcher", null);
  __decorate10([
    write("startDate")
  ], BaseEventMixin2.prototype, "writeStartDate", null);
  __decorate10([
    calculate("startDate")
  ], BaseEventMixin2.prototype, "calculateStartDate", null);
  __decorate10([
    write("endDate")
  ], BaseEventMixin2.prototype, "writeEndDate", null);
  __decorate10([
    calculate("endDate")
  ], BaseEventMixin2.prototype, "calculateEndDate", null);
  __decorate10([
    write("duration")
  ], BaseEventMixin2.prototype, "writeDuration", null);
  __decorate10([
    calculate("duration")
  ], BaseEventMixin2.prototype, "calculateDuration", null);
  __decorate10([
    calculate("effectiveDirection")
  ], BaseEventMixin2.prototype, "calculateEffectiveDirection", null);
  __decorate10([
    calculate("startDateDirection")
  ], BaseEventMixin2.prototype, "calculateStartDateDirection", null);
  __decorate10([
    calculate("endDateDirection")
  ], BaseEventMixin2.prototype, "calculateEndDateDirection", null);
  return BaseEventMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/AbstractHasAssignmentsMixin.js
var AbstractHasAssignmentsMixin = class extends Mixin([AbstractPartOfProjectModelMixin], (base) => {
  const superProto = base.prototype;
  class HasAssignmentsMixin extends base {
    /**
     * If a given resource is assigned to this task, returns a [[BaseAssignmentMixin]] instance for it.
     * Otherwise returns `null`
     */
    getAssignmentFor(resource) {
      var _a2;
      for (const assignment of (_a2 = this.assigned) != null ? _a2 : []) {
        if (assignment.resource === resource)
          return assignment;
      }
      return null;
    }
    isAssignedTo(resource) {
      return Boolean(this.getAssignmentFor(resource));
    }
    /**
     * A method which assigns a resource to the current event
     */
    async assign(resource) {
      const assignmentCls = this.project.assignmentStore.modelClass;
      this.addAssignment(new assignmentCls({
        event: this,
        resource
      }));
      return this.commitAsync();
    }
    /**
     * A method which unassigns a resource from the current event
     */
    async unassign(resource) {
      const assignment = this.getAssignmentFor(resource);
      this.removeAssignment(assignment);
      return this.commitAsync();
    }
    leaveProject() {
      if (this.isInActiveTransaction && this.assigned) {
        const eventStore = this.getEventStore();
        this.assigned.forEach((assignment) => eventStore.assignmentsForRemoval.add(assignment));
      }
      superProto.leaveProject.call(this, ...arguments);
    }
    remove() {
      if (this.parent) {
        const eventStore = this.getEventStore();
        superProto.remove.call(this);
        eventStore && eventStore.afterEventRemoval();
      } else {
        return superProto.remove.call(this);
      }
    }
    // template methods, overridden in scheduling modes mixins
    // should probably be named something like "onEventAssignmentAdded"
    // should be a listener for the `add` event of the assignment store instead
    addAssignment(assignment) {
      this.getProject().assignmentStore.add(assignment);
      return assignment;
    }
    // should be a listener for the `remove` event of the assignment store instead
    removeAssignment(assignment) {
      this.getProject().assignmentStore.remove(assignment);
      return assignment;
    }
  }
  return HasAssignmentsMixin;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_basic/BaseHasAssignmentsMixin.js
var __decorate11 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var BaseHasAssignmentsMixin = class extends Mixin([BaseEventMixin, AbstractHasAssignmentsMixin], (base) => {
  const superProto = base.prototype;
  class BaseHasAssignmentsMixin2 extends base {
    get assignments() {
      return this.assigned ? [...this.assigned] : [];
    }
  }
  __decorate11([
    generic_field({}, ModelBucketField)
  ], BaseHasAssignmentsMixin2.prototype, "assigned", void 0);
  return BaseHasAssignmentsMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_basic/HasDependenciesMixin.js
var __decorate12 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HasDependenciesMixin = class extends Mixin([BaseEventMixin], (base) => {
  const superProto = base.prototype;
  class HasDependenciesMixin2 extends base {
    leaveProject() {
      var _a2, _b;
      if (this.isInActiveTransaction) {
        const activeTransaction = this.graph.activeTransaction;
        const dependencyStore = this.getDependencyStore();
        const toRemove = [];
        for (const dep of (_a2 = activeTransaction.readCurrentOrProposedOrPrevious(this.$.outgoingDeps)) != null ? _a2 : [])
          if (dependencyStore.includes(dep))
            toRemove.push(dep);
        for (const dep of (_b = activeTransaction.readCurrentOrProposedOrPrevious(this.$.incomingDeps)) != null ? _b : [])
          if (dependencyStore.includes(dep))
            toRemove.push(dep);
        this.project.dependencyStore.remove(toRemove);
      }
      superProto.leaveProject.call(this);
    }
  }
  __decorate12([
    generic_field({}, ModelBucketField)
  ], HasDependenciesMixin2.prototype, "outgoingDeps", void 0);
  __decorate12([
    generic_field({}, ModelBucketField)
  ], HasDependenciesMixin2.prototype, "incomingDeps", void 0);
  return HasDependenciesMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_basic/SchedulerBasicEvent.js
var SchedulerBasicEvent = class extends Mixin([
  BaseEventMixin,
  BaseHasAssignmentsMixin,
  HasDependenciesMixin
], (base) => {
  const superProto = base.prototype;
  class SchedulerBasicEvent2 extends base {
  }
  return SchedulerBasicEvent2;
}) {
};

// ../Engine/lib/Engine/quark/store/AbstractEventStoreMixin.js
var dataAddRemoveActions2 = {
  splice: 1,
  clear: 1
};
var AbstractEventStoreMixin = class extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class AbstractEventStoreMixin2 extends base {
    constructor() {
      super(...arguments);
      this.assignmentsForRemoval = /* @__PURE__ */ new Set();
      this.dependenciesForRemoval = /* @__PURE__ */ new Set();
    }
    // we need `onDataChange` for `syncDataOnLoad` option to work
    onDataChange(event) {
      var _a2;
      const isAddRemove = dataAddRemoveActions2[event.action];
      super.onDataChange(event);
      if (isAddRemove && ((_a2 = event.removed) == null ? void 0 : _a2.length))
        this.afterEventRemoval();
    }
    // it seems `onDataChange` is not triggered for `remove` with `silent` flag
    remove(records, silent) {
      const res = superProto.remove.call(this, records, silent);
      this.afterEventRemoval();
      return res;
    }
    // it seems `onDataChange` is not triggered for `TreeStore#removeAll()`
    removeAll(silent) {
      const res = superProto.removeAll.call(this, silent);
      this.afterEventRemoval();
      return res;
    }
    onNodeRemoveChild(parent, children, index, flags) {
      const removed = superProto.onNodeRemoveChild.call(this, ...arguments);
      this.afterEventRemoval();
      return removed;
    }
    afterEventRemoval() {
      const { assignmentsForRemoval, dependenciesForRemoval } = this;
      if (!assignmentsForRemoval)
        return;
      const assignmentStore = this.getAssignmentStore();
      if (assignmentStore && !assignmentStore.allAssignmentsForRemoval && assignmentsForRemoval.size) {
        const toRemove = [...assignmentsForRemoval].filter((assignment) => !assignmentStore.assignmentsForRemoval.has(assignment));
        toRemove.length > 0 && assignmentStore.remove(toRemove);
      }
      assignmentsForRemoval.clear();
      const dependencyStore = this.getDependencyStore();
      if (dependencyStore && !dependencyStore.allDependenciesForRemoval && dependenciesForRemoval.size) {
        const toRemove = [...dependenciesForRemoval].filter((dependency) => !dependencyStore.dependenciesForRemoval.has(dependency));
        toRemove.length > 0 && dependencyStore.remove(toRemove);
      }
      dependenciesForRemoval.clear();
    }
    processRecord(eventRecord, isDataset = false) {
      var _a2;
      if (!((_a2 = this.project) == null ? void 0 : _a2.isRepopulatingStores)) {
        const existingRecord = this.getById(eventRecord.id);
        const isReplacing = existingRecord && existingRecord !== eventRecord;
        if (isReplacing && existingRecord.assigned) {
          for (const assignment of existingRecord.assigned) {
            assignment.event = eventRecord;
          }
        }
      }
      return eventRecord;
    }
  }
  return AbstractEventStoreMixin2;
}) {
};

// ../Engine/lib/Engine/quark/store/ChronoEventStoreMixin.js
var ChronoEventStoreMixin = class extends Mixin([AbstractEventStoreMixin, ChronoPartOfProjectStoreMixin], (base) => {
  class ChronoEventStoreMixin2 extends base {
    constructor() {
      super(...arguments);
      this.removalOrder = 400;
    }
    static get defaultConfig() {
      return {
        modelClass: SchedulerBasicEvent
      };
    }
    // this method has to be in the code for the "plain" store, because it might be
    // suddenly upgraded to the "tree", based on the data
    buildRootNode() {
      return this.getProject() || {};
    }
    set data(value) {
      super.data = value;
      this.afterEventRemoval();
    }
  }
  return ChronoEventStoreMixin2;
}) {
};
var ChronoEventTreeStoreMixin = class extends Mixin([ChronoEventStoreMixin], (base) => {
  class ChronoEventTreeStoreMixin2 extends base {
    static get defaultConfig() {
      return {
        tree: true
      };
    }
  }
  return ChronoEventTreeStoreMixin2;
}) {
};

// ../Engine/lib/Engine/localization/En.js
var locale3 = {
  localeName: "En",
  localeDesc: "English (US)",
  localeCode: "en-US",
  RemoveDependencyCycleEffectResolution: {
    descriptionTpl: "Remove dependency"
  },
  DeactivateDependencyCycleEffectResolution: {
    descriptionTpl: "Deactivate dependency"
  },
  CycleEffectDescription: {
    descriptionTpl: "A cycle has been found, formed by: {0}"
  },
  EmptyCalendarEffectDescription: {
    descriptionTpl: '"{0}" calendar does not provide any working time intervals.'
  },
  Use24hrsEmptyCalendarEffectResolution: {
    descriptionTpl: "Use 24 hours calendar with non-working Saturdays and Sundays."
  },
  Use8hrsEmptyCalendarEffectResolution: {
    descriptionTpl: "Use 8 hours calendar (08:00-12:00, 13:00-17:00) with non-working Saturdays and Sundays."
  },
  ConflictEffectDescription: {
    descriptionTpl: "A scheduling conflict has been found: {0} is conflicting with {1}"
  },
  ConstraintIntervalDescription: {
    dateFormat: "LLL"
  },
  ProjectConstraintIntervalDescription: {
    startDateDescriptionTpl: "Project start date {0}",
    endDateDescriptionTpl: "Project end date {0}"
  },
  DependencyType: {
    long: [
      "Start-to-Start",
      "Start-to-Finish",
      "Finish-to-Start",
      "Finish-to-Finish"
    ]
  },
  ManuallyScheduledParentConstraintIntervalDescription: {
    startDescriptionTpl: 'Manually scheduled "{2}" forces its children to start no earlier than {0}',
    endDescriptionTpl: 'Manually scheduled "{2}" forces its children to finish no later than {1}'
  },
  DisableManuallyScheduledConflictResolution: {
    descriptionTpl: 'Disable manual scheduling for "{0}"'
  },
  DependencyConstraintIntervalDescription: {
    descriptionTpl: 'Dependency ({2}) from "{3}" to "{4}"'
  },
  RemoveDependencyResolution: {
    descriptionTpl: 'Remove dependency from "{1}" to "{2}"'
  },
  DeactivateDependencyResolution: {
    descriptionTpl: 'Deactivate dependency from "{1}" to "{2}"'
  },
  DateConstraintIntervalDescription: {
    startDateDescriptionTpl: 'Task "{2}" {3} {0} constraint',
    endDateDescriptionTpl: 'Task "{2}" {3} {1} constraint',
    constraintTypeTpl: {
      startnoearlierthan: "Start-No-Earlier-Than",
      finishnoearlierthan: "Finish-No-Earlier-Than",
      muststarton: "Must-Start-On",
      mustfinishon: "Must-Finish-On",
      startnolaterthan: "Start-No-Later-Than",
      finishnolaterthan: "Finish-No-Later-Than"
    }
  },
  RemoveDateConstraintConflictResolution: {
    descriptionTpl: 'Remove "{1}" constraint of task "{0}"'
  }
};
var En_default2 = LocaleHelper.publishLocale(locale3);

// ../Engine/lib/Engine/scheduling/DateInterval.js
var DateInterval = class extends Base {
  initialize(...args) {
    super.initialize(...args);
    if (!this.startDate)
      this.startDate = MIN_DATE;
    if (!this.endDate)
      this.endDate = MAX_DATE;
  }
  equalTo(another) {
    return this.startDate.getTime() === another.startDate.getTime() && this.endDate.getTime() === another.endDate.getTime();
  }
  isInfinite() {
    return this.startDate.getTime() === MIN_DATE.getTime() && this.endDate.getTime() === MAX_DATE.getTime();
  }
  startDateIsFinite() {
    return !this.isIntervalEmpty() && this.startDate.getTime() !== MIN_DATE.getTime();
  }
  endDateIsFinite() {
    return !this.isIntervalEmpty() && this.endDate.getTime() !== MAX_DATE.getTime();
  }
  /**
   * Test whether the given time point is within this interval. By default interval is considered to be
   * inclusive on the left side and opened on the right (controlled with `edgeInclusion`).
   *
   * @param date
   * @param edgeInclusion
   */
  containsDate(date, edgeInclusion = EdgeInclusion.Left) {
    return edgeInclusion === EdgeInclusion.Left && (date >= this.startDate && date < this.endDate) || edgeInclusion === EdgeInclusion.Right && (date > this.startDate && date <= this.endDate);
  }
  isIntervalEmpty() {
    return this.startDate > this.endDate;
  }
  /**
   * Intersect this interval with another in the immutable way - returns a new interval.
   * @param another
   */
  intersect(another) {
    const anotherStart = another.startDate;
    const anotherEnd = another.endDate;
    const start = this.startDate;
    const end = this.endDate;
    if (end < anotherStart || start > anotherEnd) {
      return EMPTY_INTERVAL;
    }
    const newStart = new Date(Math.max(start.getTime(), anotherStart.getTime()));
    const newEnd = new Date(Math.min(end.getTime(), anotherEnd.getTime()));
    return this.constructor.new({ startDate: newStart, endDate: newEnd });
  }
  /**
   * Intersect this interval with another in the mutable way - updates current interval.
   * @param another
   */
  intersectMut(another, collectIntersectionMeta = false) {
    var _a2;
    const anotherStart = another.startDate;
    const anotherEnd = another.endDate;
    const start = this.startDate;
    const end = this.endDate;
    if (collectIntersectionMeta) {
      if (!this.intersectionOf)
        this.intersectionOf = /* @__PURE__ */ new Set();
      if (((_a2 = another.intersectionOf) == null ? void 0 : _a2.size) > 0) {
        another.intersectionOf.forEach(this.intersectionOf.add, this.intersectionOf);
        this.intersectedAsEmpty = another.intersectedAsEmpty;
      } else {
        this.intersectionOf.add(another);
      }
    }
    if (!this.isIntervalEmpty()) {
      if (end < anotherStart || start > anotherEnd) {
        this.startDate = MAX_DATE;
        this.endDate = MIN_DATE;
        if (collectIntersectionMeta) {
          this.intersectedAsEmpty = another;
        }
        return this;
      }
      this.startDate = new Date(Math.max(start.getTime(), anotherStart.getTime()));
      this.endDate = new Date(Math.min(end.getTime(), anotherEnd.getTime()));
    }
    return this;
  }
  getCopyProperties(data) {
    return data;
  }
  copyWith(data) {
    const copyData = this.getCopyProperties(data);
    return this.constructor.new(copyData);
  }
};
var EMPTY_INTERVAL = DateInterval.new({ startDate: MAX_DATE, endDate: MIN_DATE });
var intersectIntervals = (dateIntervals, collectIntersectionMeta = false) => {
  return dateIntervals.reduce((acc, currentInterval) => acc.intersectMut(currentInterval, collectIntersectionMeta), DateInterval.new());
};

// ../Engine/lib/Engine/chrono/Conflict.js
var __decorate13 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ConflictSymbol = Symbol("ConflictSymbol");
var ConflictEffectDescription = class extends Localizable_default(Base2) {
  static get $name() {
    return "ConflictEffectDescription";
  }
  /**
   * Returns the scheduling conflict localized description.
   * @param conflict Scheduling conflict
   */
  static getDescription(conflict) {
    return format(this.L("L{descriptionTpl}"), conflict.intervals[0].getDescription(), conflict.intervals[1].getDescription());
  }
};
var ConflictEffect = class extends SchedulingIssueEffect {
  constructor() {
    super(...arguments);
    this.handler = ConflictSymbol;
  }
  initialize(props) {
    super.initialize(props);
    this.intervals = this.filterConflictingIntervals(this.intervals);
  }
  /**
   * Returns possible resolutions for the _conflict_.
   */
  getResolutions() {
    if (!this._resolutions) {
      this._resolutions = [].concat(...this.intervals.map((interval) => interval.getResolutions()));
    }
    return this._resolutions;
  }
  filterConflictingIntervals(intervals) {
    const result = [];
    const intervalsArray = [...intervals].filter((interval) => !interval.isInfinite());
    const affectedInterval = intervalsArray.find((interval) => interval.isAffectedByTransaction());
    if (affectedInterval) {
      const sorted = intervalsArray.sort((a, b) => a === affectedInterval ? -1 : 0);
      const intersection = intersectIntervals(sorted, true);
      const conflictingInterval = intersection.intersectedAsEmpty;
      result.push(conflictingInterval, affectedInterval);
    } else {
      result.push(intersectIntervals(intervalsArray, true).intersectedAsEmpty, intersectIntervals(intervalsArray.reverse(), true).intersectedAsEmpty);
    }
    return result;
  }
};
__decorate13([
  prototypeValue("schedulingConflict")
], ConflictEffect.prototype, "type", void 0);
__decorate13([
  prototypeValue(ConflictEffectDescription)
], ConflictEffect.prototype, "_descriptionBuilderClass", void 0);
var ConflictResolution = class extends SchedulingIssueEffectResolution {
  /**
   * Resolves the scheduling conflict.
   */
  resolve() {
    throw new Error("Abstract method");
  }
};
var ConstraintIntervalDescription = class extends Localizable_default(Base2) {
  static get $name() {
    return "ConstraintIntervalDescription";
  }
  /**
   * Returns the provided interval description.
   * @param interval Interval to get description of
   */
  static getDescription(interval) {
    return format(this.L("L{descriptionTpl}"), ...this.getDescriptionParameters(interval));
  }
  /**
   * Returns additional parameters to put into the description.
   * @param interval Interval to get description of
   */
  static getDescriptionParameters(interval) {
    return [
      DateHelper.format(interval.startDate, this.L("L{dateFormat}")),
      DateHelper.format(interval.endDate, this.L("L{dateFormat}"))
    ];
  }
};
var ConstraintInterval = class extends DateInterval {
  constructor() {
    super(...arguments);
    this.owner = void 0;
    this.reflectionOf = void 0;
    this.side = void 0;
    this.resolutions = void 0;
  }
  get isConstraintInterval() {
    return true;
  }
  /**
   * Returns the interval description.
   */
  getDescription() {
    return this.descriptionBuilderClass.getDescription(this);
  }
  /**
   * Returns possible resolution for the interval when it takes part in a _scheduling conflict_.
   */
  getResolutions() {
    return [];
  }
  isAffectedByTransaction(transaction) {
    return false;
  }
  getCopyProperties(data) {
    const { owner, reflectionOf, side } = this;
    return Object.assign({ owner, reflectionOf, side }, data);
  }
};
__decorate13([
  prototypeValue(ConstraintIntervalDescription)
], ConstraintInterval.prototype, "descriptionBuilderClass", void 0);

// ../Engine/lib/Engine/chrono/Replica.js
var __decorate14 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CycleSymbol = Symbol("CycleSymbol");
var EngineRevision = class extends Revision {
  constructor() {
    super(...arguments);
    this.failedResolutionReferences = /* @__PURE__ */ new Map();
  }
};
var EngineTransaction = class extends Transaction {
  constructor() {
    super(...arguments);
    this.candidateClass = EngineRevision;
  }
  initialize(props) {
    var _a2;
    if ((_a2 = props.graph.project) == null ? void 0 : _a2.delayCalculation) {
      props.startProgressNotificationsAfterMs = 0;
      props.emitProgressNotificationsEveryMs = 100;
    }
    super.initialize(props);
    this.candidate.failedResolutionReferences = new Map(this.baseRevision.failedResolutionReferences);
  }
  addIdentifier(identifier, proposedValue, ...args) {
    if (this.candidate.failedResolutionReferences.size) {
      this.candidate.failedResolutionReferences.forEach((failedResolutionValue, identifier2) => {
        this.write(identifier2, failedResolutionValue);
      });
      this.candidate.failedResolutionReferences.clear();
    }
    return super.addIdentifier(identifier, proposedValue, ...args);
  }
};
var EngineReplica = class extends Mixin([Replica], (base) => {
  const superProto = base.prototype;
  class EngineReplica2 extends base {
    constructor() {
      super(...arguments);
      this.baseRevision = EngineRevision.new();
      this.transactionClass = EngineTransaction;
      this.autoCommitMode = "async";
      this.onComputationCycle = "effect";
      this.cycleEffectClass = CycleEffect;
      this.silenceInitialCommit = true;
      this.ignoreInitialCommitComputationCycles = false;
    }
    get dirty() {
      const activeTransaction = this.activeTransaction;
      return activeTransaction.entries.size > 0 && (activeTransaction.hasVariableEntry || activeTransaction.hasEntryWithProposedValue);
    }
    onPropagationProgressNotification(notification) {
      var _a2, _b;
      if (this.enableProgressNotifications && this.project)
        (_b = (_a2 = this.project).trigger) == null ? void 0 : _b.call(_a2, "progress", notification);
    }
    async commitAsync(args) {
      if (!this.project || this.project.isDestroyed)
        return;
      this.project.trigger("beforeCommit");
      if (this.isInitialCommit && this.ignoreInitialCommitComputationCycles) {
        this._onComputationCycle = this._onComputationCycle || this.onComputationCycle;
        this.onComputationCycle = "ignore";
      }
      const replacedReplicaResult = this.project.beforeCommitAsync();
      if (replacedReplicaResult)
        return replacedReplicaResult;
      return superProto.commitAsync.call(this, args);
    }
    get isInitialCommit() {
      return this.project.isInitialCommit || super.isInitialCommit;
    }
    set isInitialCommit(value) {
      super.isInitialCommit = value;
    }
    write(identifier, proposedValue, ...args) {
      var _a2, _b, _c;
      const fieldName = (_a2 = identifier.field) == null ? void 0 : _a2.name;
      const record = identifier.self;
      if (fieldName && record) {
        const beforeHookResult = (_b = record.beforeChronoFieldSet) == null ? void 0 : _b.call(record, fieldName, proposedValue);
        superProto.write.call(this, identifier, proposedValue, ...args);
        (_c = record.afterChronoFieldSet) == null ? void 0 : _c.call(record, fieldName, proposedValue, beforeHookResult);
      } else {
        superProto.write.call(this, identifier, proposedValue, ...args);
      }
    }
    async finalizeCommitAsync(transactionResult) {
      const { project } = this;
      if (!project || project.isDestroyed)
        return;
      const { entries } = transactionResult;
      const autoCommitStores = /* @__PURE__ */ new Set();
      if (globalThis.DEBUG)
        console.timeEnd("Time to visible");
      const { isInitialCommit, silenceInitialCommit } = this;
      const silenceCommit = isInitialCommit && silenceInitialCommit;
      if (isInitialCommit) {
        project.isInitialCommitPerformed = true;
        if (this.ignoreInitialCommitComputationCycles)
          this.onComputationCycle = this._onComputationCycle;
      }
      project.isWritingData = true;
      project.hasLoadedDataToCommit = false;
      if (this.enableProgressNotifications) {
        project.trigger("progress", {
          total: transactionResult.entries.size,
          remaining: 0,
          phase: "finalizing"
        });
      }
      const transaction = transactionResult.transaction;
      if (transaction.rejectedWith) {
        project.trigger("commitRejected", { transactionResult, isInitialCommit, silenceCommit });
      }
      project.trigger("refresh", { isInitialCommit, isCalculated: true });
      await new Promise((resolve) => {
        setTimeout(() => {
          var _a2, _b;
          if (!project.isDestroyed) {
            if (!transactionResult.transaction.rejectedWith) {
              (_a2 = project.suspendChangesTracking) == null ? void 0 : _a2.call(project);
              if (globalThis.DEBUG)
                console.time("Finalize propagation");
              const records = /* @__PURE__ */ new Set();
              for (const quark of entries.values()) {
                const identifier = quark.identifier;
                const quarkValue = quark.getValue();
                const { field: field2 } = identifier;
                if (quark.isShadow() || !identifier[IsChronoModelSymbol] || quarkValue === TombStone || field2 instanceof ModelBucketField)
                  continue;
                const record = identifier.self;
                const store = record.firstStore;
                if (!records.has(record)) {
                  record.beginBatch(true);
                  records.add(record);
                }
                if ((store == null ? void 0 : store.autoCommit) && !autoCommitStores.has(store)) {
                  store.suspendAutoCommit();
                  autoCommitStores.add(store);
                }
                record.meta.batchChanges[field2.name] = quarkValue;
              }
              let prevented = false;
              for (const record of records) {
                if (!record.triggerBeforeUpdate({ ...record.meta.batchChanges })) {
                  prevented = true;
                  break;
                }
              }
              if (prevented) {
                for (const record of records) {
                  record.cancelBatch();
                }
                transactionResult.transaction.reject();
                project.trigger("commitRejected", { transactionResult, isInitialCommit, silenceCommit });
                project.trigger("refresh", { isInitialCommit, isCalculated: true });
              } else {
                for (const record of records) {
                  record.ignoreBag = silenceCommit || project.ignoreRecordChanges;
                  record.generation++;
                  record.endBatch(silenceCommit, true, true);
                  record.ignoreBag = false;
                }
              }
              project.ignoreRecordChanges = false;
              if (globalThis.DEBUG)
                console.timeEnd("Finalize propagation");
              project.isWritingData = false;
              if (!prevented) {
                project.trigger("dataReady", { records, isInitialCommit });
              }
              (_b = project.resumeChangesTracking) == null ? void 0 : _b.call(project, silenceCommit);
              autoCommitStores.forEach((store) => store.resumeAutoCommit());
              if (silenceCommit) {
                project.eventStore.acceptChanges();
                project.dependencyStore.acceptChanges();
                project.resourceStore.acceptChanges();
                project.assignmentStore.acceptChanges();
                project.calendarManagerStore.acceptChanges();
                project.acceptChanges();
              }
            } else {
              project.isWritingData = false;
            }
            project.trigger("commitFinalized", { isInitialCommit, transactionResult });
          }
          resolve();
        }, 0);
      });
    }
    *onComputationCycleHandler(cycle) {
      if (this.onComputationCycle === "effect") {
        const effect = this.project.cycleEffectClass.new({ cycle });
        if ((yield effect) === EffectResolutionResult.Cancel) {
          yield Reject(effect);
        }
      } else {
        return yield* super.onComputationCycleHandler(cycle);
      }
    }
    onComputationCycleHandlerSync(cycle, transaction) {
      if (this.onComputationCycle === "effect") {
        const effect = this.project.cycleEffectClass.new({ cycle });
        throw effect;
      } else {
        return super.onComputationCycleHandlerSync(cycle, transaction);
      }
    }
    async [CycleSymbol](effect, transaction) {
      return this.project.onCycleSchedulingIssue(effect, transaction);
    }
    async [EmptyCalendarSymbol](effect, transaction) {
      transaction.walkContext.startNewEpoch();
      return this.project.onEmptyCalendarSchedulingIssue(effect, transaction);
    }
    async [ConflictSymbol](effect, transaction) {
      transaction.walkContext.startNewEpoch();
      return this.project.onConflictSchedulingIssue(effect, transaction);
    }
    [RejectSymbol](effect, transaction) {
      return super[RejectSymbol](effect, transaction);
    }
  }
  return EngineReplica2;
}) {
};
var RemoveDependencyCycleEffectResolution = class extends Localizable_default(SchedulingIssueEffectResolution) {
  static get $name() {
    return "RemoveDependencyCycleEffectResolution";
  }
  getDescription() {
    return this.L("L{descriptionTpl}");
  }
  resolve(dependency) {
    dependency.remove();
  }
};
var CycleEffectDescription = class extends Localizable_default(Base2) {
  static get $name() {
    return "CycleEffectDescription";
  }
  static getDescription(effect) {
    return format(this.L("L{descriptionTpl}"), this.getShortDescription(effect));
  }
  static getShortDescription(effect) {
    const events = effect.getEvents().slice();
    events.push(events[0]);
    return '"' + events.map((event) => event.name || "#" + event.id).join('" -> "') + '"';
  }
};
var CycleEffect = class extends SchedulingIssueEffect {
  constructor() {
    super(...arguments);
    this.handler = CycleSymbol;
  }
  /**
   * Returns list of events building the cycle.
   */
  getEvents() {
    if (!this._events) {
      const result = /* @__PURE__ */ new Set();
      this.cycle.cycle.forEach(({ context }) => result.add(context));
      this._events = [...result];
    }
    return this._events;
  }
  matchDependencyBySourceAndTargetEvent(dependency, from, to) {
    return dependency.fromEvent === from && dependency.toEvent === to;
  }
  getDependencyForSourceAndTargetEvents(from, to) {
    const events = this.getEvents();
    const project = events[0].project;
    const dependencyStore = project.getDependencyStore();
    return dependencyStore.find((dependency) => this.matchDependencyBySourceAndTargetEvent(dependency, from, to));
  }
  /**
   * Returns list of dependencies building the cycle.
   */
  getDependencies() {
    if (!this._dependencies) {
      const result = /* @__PURE__ */ new Set();
      const events = this.getEvents();
      const numberOfEvents = events.length;
      let prevEvent = events[0], dependency;
      if (numberOfEvents === 1) {
        if (dependency = this.getDependencyForSourceAndTargetEvents(prevEvent, prevEvent)) {
          result.add(dependency);
        }
      } else {
        for (const event1 of events) {
          for (const event2 of events) {
            if (dependency = this.getDependencyForSourceAndTargetEvents(event1, event2)) {
              result.add(dependency);
            }
            if (dependency = this.getDependencyForSourceAndTargetEvents(event2, event1)) {
              result.add(dependency);
            }
          }
        }
      }
      this._dependencies = [...result];
    }
    return this._dependencies;
  }
  /**
   * Returns list of the cycle possible resolutions.
   *
   * The class provides a single parameterized [[RemoveDependencyCycleEffectResolution]] resolution
   * which implement removal of one of the [[getDependencies|dependencies]].
   */
  getResolutions() {
    if (!this._resolutions) {
      this._resolutions = [this.removeDependencyCycleEffectResolutionClass.new()];
    }
    return this._resolutions;
  }
};
__decorate14([
  prototypeValue("cycle")
], CycleEffect.prototype, "type", void 0);
__decorate14([
  prototypeValue(CycleEffectDescription)
], CycleEffect.prototype, "_descriptionBuilderClass", void 0);
__decorate14([
  prototypeValue(RemoveDependencyCycleEffectResolution)
], CycleEffect.prototype, "removeDependencyCycleEffectResolutionClass", void 0);

// ../Engine/lib/Engine/quark/model/scheduler_basic/HasSubEventsMixin.js
var HasSubEventsMixin = class extends Mixin([BaseEventMixin], (base) => {
  const superProto = base.prototype;
  class HasSubEventsMixin2 extends base {
    static get $name() {
      return "HasSubEventsMixin";
    }
    /**
     * The abstract method which should indicate whether this event has sub events
     */
    *hasSubEvents() {
      throw new Error("Abstract method `hasSubEvents` has been called");
    }
    /**
     * The abstract method which should return an Iterable of [[BaseEventMixin]]
     */
    *subEventsIterable() {
      throw new Error("Abstract method `subEventsIterable` has been called");
    }
    *calculateStartDatePure() {
      const manuallyScheduled = yield this.$.manuallyScheduled;
      const hasSubEvents = yield* this.hasSubEvents();
      if (!manuallyScheduled && hasSubEvents) {
        return yield* this.calculateMinChildrenStartDate();
      } else {
        return yield* superProto.calculateStartDatePure.call(this);
      }
    }
    *calculateEndDatePure() {
      const manuallyScheduled = yield this.$.manuallyScheduled;
      const hasSubEvents = yield* this.hasSubEvents();
      if (!manuallyScheduled && hasSubEvents) {
        return yield* this.calculateMaxChildrenEndDate();
      } else {
        return yield* superProto.calculateEndDatePure.call(this);
      }
    }
    *calculateStartDateProposed() {
      const manuallyScheduled = yield this.$.manuallyScheduled;
      const hasSubEvents = yield* this.hasSubEvents();
      if (!manuallyScheduled && hasSubEvents) {
        return yield* this.calculateStartDatePure();
      } else {
        return yield* superProto.calculateStartDateProposed.call(this);
      }
    }
    *calculateEndDateProposed() {
      const manuallyScheduled = yield this.$.manuallyScheduled;
      const hasSubEvents = yield* this.hasSubEvents();
      if (!manuallyScheduled && hasSubEvents) {
        return yield* this.calculateEndDatePure();
      } else {
        return yield* superProto.calculateEndDateProposed.call(this);
      }
    }
    *calculateDurationProposed() {
      const manuallyScheduled = yield this.$.manuallyScheduled;
      const hasSubEvents = yield* this.hasSubEvents();
      if (!manuallyScheduled && hasSubEvents) {
        return yield* this.calculateDurationPure();
      } else {
        return yield* superProto.calculateDurationProposed.call(this);
      }
    }
    /**
     * The method defines wether the provided child event should be
     * taken into account when calculating this summary event [[startDate]].
     * Child events roll up their [[startDate]] values to their summary tasks.
     * So a summary task [[startDate|start]] date gets equal to
     * its minimal child [[startDate|start]].
     *
     * If the method returns `true` the child event is taken into account
     * and if the method returns `false` it's not.
     * By default the method returns `true` to include all child events data.
     * @param childEvent Child event to consider.
     * @returns `true` if the provided event should be taken into account, `false` if not.
     */
    *shouldRollupChildStartDate(child) {
      return true;
    }
    /**
     * Calculates the minimal sub-events [[startDate]].
     * The method is used for calculating the event [[startDate]].
     */
    *calculateMinChildrenStartDate() {
      const children = yield* this.subEventsIterable();
      let timestamp = MAX_DATE.getTime();
      for (const child of children) {
        if (yield* this.shouldRollupChildStartDate(child)) {
          let date = yield child.$.startDate;
          if (!date) {
            date = yield child.$.endDate;
          }
          if ((yield child.$.manuallyScheduled) && (yield* child.hasSubEvents())) {
            const subDate = yield* child.calculateMinChildrenStartDate();
            if (!date || subDate && subDate.getTime() < date.getTime())
              date = subDate;
          }
          if (date && date.getTime() < timestamp) {
            timestamp = date.getTime();
          }
        }
      }
      if (timestamp === MIN_DATE.getTime() || timestamp === MAX_DATE.getTime())
        return null;
      return new Date(timestamp);
    }
    /**
     * The method defines wether the provided child event should be
     * taken into account when calculating this summary event [[endDate]].
     * Child events roll up their [[endDate]] values to their summary tasks.
     * So a summary task [[endDate|end]] gets equal to its maximal child [[endDate|end]].
     *
     * If the method returns `true` the child event is taken into account
     * and if the method returns `false` it's not.
     * By default the method returns `true` to include all child events data.
     * @param childEvent Child event to consider.
     * @returns `true` if the provided event should be taken into account, `false` if not.
     */
    *shouldRollupChildEndDate(child) {
      return true;
    }
    /**
     * Calculates the maximum sub-events [[endDate]].
     * The method is used for calculating the event [[endDate]].
     */
    *calculateMaxChildrenEndDate() {
      const children = yield* this.subEventsIterable();
      let timestamp = MIN_DATE.getTime();
      for (const child of children) {
        if (yield* this.shouldRollupChildEndDate(child)) {
          let date = yield child.$.endDate;
          if (!date) {
            date = yield child.$.startDate;
          }
          if ((yield child.$.manuallyScheduled) && (yield* child.hasSubEvents())) {
            const subDate = yield* child.calculateMaxChildrenEndDate();
            if (!date || subDate && subDate.getTime() > date.getTime())
              date = subDate;
          }
          if (date && date.getTime() > timestamp) {
            timestamp = date.getTime();
          }
        }
      }
      if (timestamp === MIN_DATE.getTime() || timestamp === MAX_DATE.getTime())
        return null;
      return new Date(timestamp);
    }
  }
  return HasSubEventsMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_basic/HasChildrenMixin.js
var __decorate15 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HasChildrenMixin = class extends Mixin([HasSubEventsMixin], (base) => {
  const superProto = base.prototype;
  class HasChildrenMixin2 extends base {
    /**
     * Returns `true` if the event has nested sub-events.
     */
    *hasSubEvents() {
      const childEvents = yield this.$.childEvents;
      return childEvents.size > 0;
    }
    /**
     * Returns iterable object listing the event nested sub-events.
     * ```typescript
     * const subEventsIterator : Iterable<HasChildrenMixin> = yield* event.subEventsIterable()
     *
     * for (let childEvent of subEventsIterator) {
     *     // ..do something..
     * }
     * ```
     */
    *subEventsIterable() {
      return yield this.$.childEvents;
    }
    get parent() {
      return this._parent;
    }
    set parent(value) {
      this._parent = value;
      this.parentEvent = value;
    }
    *calculateEffectiveDirection() {
      const direction = yield this.$.direction;
      if (direction)
        return { kind: "own", direction };
      const parentEvent = yield this.$.parentEvent;
      if (parentEvent) {
        const parentEffectiveDirection = yield parentEvent.$.effectiveDirection;
        return {
          kind: "inherited",
          direction: parentEffectiveDirection.direction,
          inheritedFrom: parentEffectiveDirection.kind === "own" ? parentEvent : parentEffectiveDirection.kind === "inherited" ? parentEffectiveDirection.inheritedFrom : parentEvent
        };
      } else
        return yield* super.calculateEffectiveDirection();
    }
    *calculateStartDateDirection() {
      const projectDirection = yield this.getProject().$.effectiveDirection;
      let direction = null;
      if (!(yield this.$.manuallyScheduled)) {
        const children = yield* this.subEventsIterable();
        for (const child of children) {
          const childStartDateDirection = yield child.$.startDateDirection;
          if (projectDirection.direction !== childStartDateDirection.direction) {
            direction = {
              kind: "enforced",
              direction: childStartDateDirection.direction,
              enforcedBy: childStartDateDirection.kind === "own" ? child : childStartDateDirection.kind === "enforced" ? childStartDateDirection.enforcedBy : childStartDateDirection.inheritedFrom
            };
            break;
          }
        }
      }
      return direction != null ? direction : yield* super.calculateStartDateDirection();
    }
    *calculateEndDateDirection() {
      const projectDirection = yield this.getProject().$.effectiveDirection;
      let direction = null;
      if (!(yield this.$.manuallyScheduled)) {
        const children = yield* this.subEventsIterable();
        for (const child of children) {
          const childEndDateDirection = yield child.$.startDateDirection;
          if (projectDirection.direction !== childEndDateDirection.direction) {
            direction = {
              kind: "enforced",
              direction: childEndDateDirection.direction,
              enforcedBy: childEndDateDirection.kind === "own" ? child : childEndDateDirection.kind === "enforced" ? childEndDateDirection.enforcedBy : childEndDateDirection.inheritedFrom
            };
            break;
          }
        }
      }
      return direction != null ? direction : yield* super.calculateStartDateDirection();
    }
  }
  __decorate15([
    reference({ bucket: "childEvents" })
  ], HasChildrenMixin2.prototype, "parentEvent", void 0);
  __decorate15([
    bucket()
  ], HasChildrenMixin2.prototype, "childEvents", void 0);
  return HasChildrenMixin2;
}) {
};

// ../chronograph/src/schema/Schema.js
var Schema = class extends Base {
  constructor() {
    super(...arguments);
    this.entities = /* @__PURE__ */ new Map();
  }
  /**
   * Checks whether the schema has an entity with the given name.
   *
   * @param name
   */
  hasEntity(name) {
    return this.entities.has(name);
  }
  /**
   * Returns an entity with the given name or `undefined` if there's no such in this schema
   *
   * @param name
   */
  getEntity(name) {
    return this.entities.get(name);
  }
  /**
   * Adds an entity to the schema.
   * @param entity
   */
  addEntity(entity2) {
    const name = entity2.name;
    if (!name)
      throw new Error(`Entity must have a name`);
    if (this.hasEntity(name))
      throw new Error(`Entity with name [${String(name)}] already exists`);
    entity2.schema = this;
    this.entities.set(name, entity2);
    return entity2;
  }
  /**
   * Returns a class decorator which can be used to decorate classes as entities.
   */
  getEntityDecorator() {
    return (target) => {
      const entity2 = entityDecoratorBody(target);
      this.addEntity(entity2);
      return target;
    };
  }
};
var entityDecoratorBody = (target) => {
  const name = target.name;
  if (!name)
    throw new Error(`Can't add entity - the target class has no name`);
  return ensureEntityOnPrototype(target.prototype);
};
var entity = () => {
  return (target) => {
    entityDecoratorBody(target);
    return target;
  };
};

// ../Core/lib/Core/data/stm/state/StateBase.js
var throwAbstractMethodCall = () => {
  throw new Error("Abstract method call!");
};
var throwInvalidMethodCall = () => {
  throw new Error("Method cannot be called at this state!");
};
var StateBase = class extends Base2 {
  canUndo(stm) {
    throwAbstractMethodCall();
  }
  canRedo(stm) {
    throwAbstractMethodCall();
  }
  onUndo(stm) {
    throwAbstractMethodCall();
  }
  onRedo(stm) {
    throwAbstractMethodCall();
  }
  onStartTransaction(stm) {
    throwAbstractMethodCall();
  }
  onStopTransaction(stm) {
    throwAbstractMethodCall();
  }
  onStopTransactionDelayed(stm) {
    throwAbstractMethodCall();
  }
  onRejectTransaction(stm) {
    throwAbstractMethodCall();
  }
  onEnable(stm) {
    throwAbstractMethodCall();
  }
  onDisable(stm) {
    throwAbstractMethodCall();
  }
  onAutoRecordOn(stm) {
    throwAbstractMethodCall();
  }
  onAutoRecordOff(stm) {
    throwAbstractMethodCall();
  }
  onResetQueue(stm) {
    throwAbstractMethodCall();
  }
  onModelUpdate(stm) {
    throwAbstractMethodCall();
  }
  onStoreModelAdd(stm) {
    throwAbstractMethodCall();
  }
  onStoreModelInsert(stm) {
    throwAbstractMethodCall();
  }
  onStoreModelRemove(stm) {
    throwAbstractMethodCall();
  }
  onStoreModelRemoveAll(stm) {
    throwAbstractMethodCall();
  }
  onModelInsertChild(stm) {
    throwAbstractMethodCall();
  }
  onModelRemoveChild(stm) {
    throwAbstractMethodCall();
  }
};
StateBase._$name = "StateBase";

// ../Core/lib/Core/data/stm/Props.js
var STATE_PROP = Symbol("STATE_PROP");
var STORES_PROP = Symbol("STORES_PROP");
var QUEUE_PROP = Symbol("QUEUE_PROP");
var POS_PROP = Symbol("POS_PROP");
var TRANSACTION_PROP = Symbol("TRANSACTION_PROP");
var TRANSACTION_TIMER_PROP = Symbol("TRANSACTION_TIMER_PROP");
var AUTO_RECORD_PROP = Symbol("AUTO_RECORD_PROP");
var IS_APPLYING_STASH = Symbol("IS_APPLYING_STASH");
var PROPS = Object.freeze([
  STATE_PROP,
  STORES_PROP,
  QUEUE_PROP,
  POS_PROP,
  TRANSACTION_PROP,
  TRANSACTION_TIMER_PROP,
  AUTO_RECORD_PROP,
  IS_APPLYING_STASH
]);

// ../Core/lib/Core/data/stm/state/Registry.js
var registry = /* @__PURE__ */ new Map();
var registerStmState = (name, state) => {
  registry.set(name, state);
};
var resolveStmState = (state) => {
  if (typeof state === "string") {
    state = registry.get(state);
  }
  return state;
};
var Registry_default = {
  registerStmState,
  resolveStmState
};

// ../Core/lib/Core/data/stm/Helpers.js
var resetQueue = (stm, options) => {
  const { undo, redo } = options;
  let newProps;
  if (undo && !redo) {
    newProps = {
      [QUEUE_PROP]: stm[QUEUE_PROP].slice(stm.position),
      [POS_PROP]: 0
    };
  } else if (redo && !undo) {
    newProps = {
      [QUEUE_PROP]: stm[QUEUE_PROP].slice(0, stm.position)
    };
  } else {
    newProps = {
      [QUEUE_PROP]: [],
      [POS_PROP]: 0
    };
  }
  ;
  return [
    newProps,
    () => {
      stm.notifyStoresAboutQueueReset(options);
    }
  ];
};

// ../Core/lib/Core/data/stm/state/DisabledState.js
var DisabledStateClass = class extends StateBase {
  canUndo() {
    return false;
  }
  canRedo() {
    return false;
  }
  onUndo() {
    throwInvalidMethodCall();
  }
  onRedo() {
    throwInvalidMethodCall();
  }
  onEnable(stm) {
    return stm.autoRecord ? "autoreadystate" : "readystate";
  }
  onDisable() {
    throwInvalidMethodCall();
  }
  onAutoRecordOn() {
    return {
      [AUTO_RECORD_PROP]: true
    };
  }
  onAutoRecordOff() {
    return {
      [AUTO_RECORD_PROP]: false
    };
  }
  onStartTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransactionDelayed() {
    throwInvalidMethodCall();
  }
  onRejectTransaction() {
    throwInvalidMethodCall();
  }
  onResetQueue(stm, options) {
    return resetQueue(stm, options);
  }
  onModelUpdate() {
  }
  onModelInsertChild() {
  }
  onModelRemoveChild() {
  }
  onStoreModelAdd() {
  }
  onStoreModelInsert() {
  }
  onStoreModelRemove() {
  }
  onStoreRemoveAll() {
  }
};
var DisabledState = new DisabledStateClass();
var DisabledState_default = DisabledState;
Registry_default.registerStmState("disabledstate", DisabledState);

// ../Core/lib/Core/data/stm/Transaction.js
var ACTION_QUEUE_PROP = Symbol("ACTION_QUEUE_PROP");
var Transaction2 = class extends Base2 {
  get defaultConfig() {
    return {
      /**
       * Transaction title
       *
       * @config {String}
       */
      title: null
    };
  }
  construct(...args) {
    this[ACTION_QUEUE_PROP] = [];
    super.construct(...args);
  }
  /**
   * Gets transaction's actions queue
   *
   * @property {Core.data.stm.action.ActionBase[]}
   */
  get queue() {
    return this[ACTION_QUEUE_PROP].slice(0);
  }
  /**
   * Gets transaction's actions queue length
   *
   * @property {Number}
   */
  get length() {
    return this[ACTION_QUEUE_PROP].length;
  }
  /**
   * Adds an action to the transaction.
   *
   * @param {Core.data.stm.action.ActionBase|Object} action
   */
  addAction(action) {
    this[ACTION_QUEUE_PROP].push(action);
  }
  /**
   * Undoes actions held
   */
  undo() {
    const queue = this[ACTION_QUEUE_PROP];
    for (let i = queue.length - 1; i >= 0; --i) {
      queue[i].undo();
    }
  }
  /**
   * Redoes actions held
   */
  redo() {
    const queue = this[ACTION_QUEUE_PROP];
    for (let i = 0, len = queue.length; i < len; ++i) {
      queue[i].redo();
    }
  }
};
Transaction2._$name = "Transaction";

// ../Core/lib/Core/data/stm/state/ReadyState.js
var ReadyStateClass = class extends StateBase {
  canUndo(stm) {
    return 0 < stm.position && stm.position <= stm.length;
  }
  canRedo(stm) {
    return 0 <= stm.position && stm.position < stm.length;
  }
  onUndo(stm, steps) {
    let curPos = stm.position;
    const queue = stm[QUEUE_PROP], newPos = Math.max(0, curPos - steps), next = () => {
      stm.notifyStoresAboutStateRestoringStart();
      const undoneTransactions = [];
      while (curPos !== newPos) {
        const transaction = queue[--curPos];
        transaction.undo();
        undoneTransactions.push(transaction);
      }
      return [stm.autoRecord ? "autoreadystate" : "readystate", () => {
        stm.notifyStoresAboutStateRestoringStop({ cause: "undo", transactions: undoneTransactions });
      }];
    };
    return [{
      [STATE_PROP]: "restoringstate",
      [POS_PROP]: newPos
    }, next];
  }
  onRedo(stm, steps) {
    let curPos = stm.position;
    const queue = stm[QUEUE_PROP], newPos = Math.min(queue.length, curPos + steps);
    const next = () => {
      stm.notifyStoresAboutStateRestoringStart();
      const redoneTransactions = [];
      do {
        const transaction = queue[curPos++];
        transaction.redo();
        redoneTransactions.push(transaction);
      } while (curPos !== newPos);
      return [stm.autoRecord ? "autoreadystate" : "readystate", () => {
        stm.notifyStoresAboutStateRestoringStop({ cause: "redo", transactions: redoneTransactions });
      }];
    };
    return [{
      [STATE_PROP]: "restoringstate",
      [POS_PROP]: newPos
    }, next];
  }
  onEnable() {
    throwInvalidMethodCall();
  }
  onDisable() {
    return "disabledstate";
  }
  onAutoRecordOn() {
    return {
      [STATE_PROP]: "autoreadystate",
      [AUTO_RECORD_PROP]: true
    };
  }
  onAutoRecordOff() {
    throwInvalidMethodCall();
  }
  onStartTransaction(stm, title) {
    const transaction = new Transaction2({ title });
    return [{
      [STATE_PROP]: "recordingstate",
      [TRANSACTION_PROP]: transaction
    }, () => {
      stm.notifyStoresAboutStateRecordingStart(transaction);
    }];
  }
  onStopTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransactionDelayed() {
    throwInvalidMethodCall();
  }
  onRejectTransaction() {
    throwInvalidMethodCall();
  }
  onResetQueue(stm, options) {
    return resetQueue(stm, options);
  }
  onModelUpdate() {
  }
  onModelInsertChild() {
  }
  onModelRemoveChild() {
  }
  onStoreModelAdd() {
  }
  onStoreModelInsert() {
  }
  onStoreModelRemove() {
  }
  onStoreRemoveAll() {
  }
};
var ReadyState = new ReadyStateClass();
var ReadyState_default = ReadyState;
Registry_default.registerStmState("readystate", ReadyState);

// ../Core/lib/Core/data/stm/state/RecordingState.js
var RecordingStateClass = class extends StateBase {
  canUndo() {
    return false;
  }
  canRedo() {
    return false;
  }
  onEnable() {
  }
  onDisable(stm) {
    const transaction = stm[TRANSACTION_PROP];
    stm.notifyStoresAboutStateRecordingStop(transaction, { disabled: true });
    return {
      [STATE_PROP]: "disabledstate",
      [TRANSACTION_PROP]: null
    };
  }
  onAutoRecordOn(stm) {
    return [{
      [STATE_PROP]: "autorecordingstate",
      [AUTO_RECORD_PROP]: true
    }, () => {
      stm.stopTransactionDelayed();
    }];
  }
  onAutoRecordOff() {
    throwInvalidMethodCall();
  }
  onStartTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransaction(stm, title) {
    const transaction = stm[TRANSACTION_PROP], queue = stm[QUEUE_PROP];
    let position = stm[POS_PROP];
    if (transaction.length) {
      if (!transaction.title && !title && stm.getTransactionTitle) {
        transaction.title = stm.getTransactionTitle(transaction);
      } else if (title) {
        transaction.title = title;
      }
      queue[position] = transaction;
      queue.length = ++position;
    }
    return [{
      [STATE_PROP]: "readystate",
      [POS_PROP]: position,
      [TRANSACTION_PROP]: null
    }, () => {
      stm.notifyStoresAboutStateRecordingStop(transaction, { stop: true });
    }];
  }
  onRejectTransaction(stm) {
    const transaction = stm[TRANSACTION_PROP];
    return [{
      [STATE_PROP]: "restoringstate",
      [TRANSACTION_PROP]: null
    }, () => {
      if (transaction.length) {
        transaction.undo();
      }
      return [
        "readystate",
        () => {
          stm.notifyStoresAboutStateRecordingStop(transaction, { rejected: true });
        }
      ];
    }];
  }
  onStopTransactionDelayed() {
    throwInvalidMethodCall();
  }
  onResetQueue(stm, options) {
    return resetQueue(stm, options);
  }
  onModelUpdate(stm, model, newData, oldData, isInitialUserAction) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeModelUpdateAction(model, newData, oldData, isInitialUserAction));
  }
  onModelInsertChild(stm, parentModel, index, childModel, previousParent, previousIndex) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeModelInsertChildAction(parentModel, index, childModel, previousParent, previousIndex));
  }
  onModelRemoveChild(stm, parentModel, childModels, context) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeModelRemoveChildAction(parentModel, childModels, context));
  }
  onStoreModelAdd(stm, store, models, silent) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeStoreModelAddAction(store, models, silent));
  }
  onStoreModelInsert(stm, store, index, models, context, silent) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeStoreModelInsertAction(store, index, models, context, silent));
  }
  onStoreModelRemove(stm, store, models, context, silent) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeStoreModelRemoveAction(store, models, context, silent));
  }
  onStoreRemoveAll(stm, store, allRecords, silent) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeStoreRemoveAllAction(store, allRecords, silent));
  }
};
var RecordingState = new RecordingStateClass();
var RecordingState_default = RecordingState;
Registry_default.registerStmState("recordingstate", RecordingState);

// ../Core/lib/Core/data/stm/state/RestoringState.js
var RestoringStateClass = class extends StateBase {
  static get $name() {
    return "RestoringStateClass";
  }
  canUndo() {
    return false;
  }
  canRedo() {
    return false;
  }
  onUndo() {
    throwInvalidMethodCall();
  }
  onRedo() {
    throwInvalidMethodCall();
  }
  onEnable() {
    throwInvalidMethodCall();
  }
  onDisable() {
    throwInvalidMethodCall();
  }
  onAutoRecordOn() {
    return {
      [AUTO_RECORD_PROP]: true
    };
  }
  onAutoRecordOff() {
    return {
      [AUTO_RECORD_PROP]: false
    };
  }
  onStartTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransactionDelayed() {
    throwInvalidMethodCall();
  }
  onRejectTransaction() {
    throwInvalidMethodCall();
  }
  onQueueReset() {
    throwInvalidMethodCall();
  }
  onModelUpdate() {
  }
  onModelInsertChild() {
  }
  onModelRemoveChild() {
  }
  onStoreModelAdd() {
  }
  onStoreModelInsert() {
  }
  onStoreModelRemove() {
  }
  onStoreRemoveAll() {
  }
};
var RestoringState = new RestoringStateClass();
var RestoringState_default = RestoringState;
Registry_default.registerStmState("restoringstate", RestoringState);

// ../Core/lib/Core/data/stm/state/AutoReadyState.js
var AutoReadyStateClass = class extends ReadyStateClass {
  onAutoRecordOn() {
    throwInvalidMethodCall();
  }
  onAutoRecordOff() {
    return {
      [STATE_PROP]: "readystate",
      [AUTO_RECORD_PROP]: false
    };
  }
  onStartTransaction(stm, title) {
    const transaction = new Transaction2({ title });
    return [{
      [STATE_PROP]: "autorecordingstate",
      [TRANSACTION_PROP]: transaction
    }, () => {
      stm.notifyStoresAboutStateRecordingStart(transaction);
      stm.stopTransactionDelayed();
    }];
  }
  onModelUpdate(stm, model, newData, oldData) {
    stm.startTransaction();
    stm.onModelUpdate(model, newData, oldData);
  }
  onModelInsertChild(stm, parentModel, index, childModels, context) {
    stm.startTransaction();
    stm.onModelInsertChild(parentModel, index, childModels, context);
  }
  onModelRemoveChild(stm, parentModel, childModels, context) {
    stm.startTransaction();
    stm.onModelRemoveChild(parentModel, childModels, context);
  }
  onStoreModelAdd(stm, store, models, silent) {
    stm.startTransaction();
    stm.onStoreModelAdd(store, models, silent);
  }
  onStoreModelInsert(stm, store, index, models, context, silent) {
    stm.startTransaction();
    stm.onStoreModelInsert(store, index, models, context, silent);
  }
  onStoreModelRemove(stm, store, models, context, silent) {
    stm.startTransaction();
    stm.onStoreModelRemove(store, models, context, silent);
  }
  onStoreRemoveAll(stm, store, allRecords, silent) {
    stm.startTransaction();
    stm.onStoreRemoveAll(store, allRecords, silent);
  }
};
var AutoReadyState = new AutoReadyStateClass();
var AutoReadyState_default = AutoReadyState;
Registry_default.registerStmState("autoreadystate", AutoReadyState);

// ../Core/lib/Core/data/stm/state/AutoRecordingState.js
var AutoRecordingStateClass = class extends RecordingStateClass.mixin(Delayable_default) {
  onDisable(stm) {
    const transaction = stm[TRANSACTION_PROP], timer = stm[TRANSACTION_TIMER_PROP];
    if (timer) {
      this.clearTimeout(timer);
    }
    stm.notifyStoresAboutStateRecordingStop(transaction, { disabled: true });
    return {
      [STATE_PROP]: "disabledstate",
      [TRANSACTION_PROP]: null,
      [TRANSACTION_TIMER_PROP]: null
    };
  }
  onAutoRecordOn(stm) {
    throwInvalidMethodCall();
  }
  onAutoRecordOff(stm) {
    const timer = stm[TRANSACTION_TIMER_PROP];
    if (timer) {
      this.clearTimeout(timer);
    }
    return {
      [STATE_PROP]: "recordingstate",
      [AUTO_RECORD_PROP]: false,
      [TRANSACTION_TIMER_PROP]: null
    };
  }
  onStopTransaction(stm, title) {
    const transaction = stm[TRANSACTION_PROP], timer = stm[TRANSACTION_TIMER_PROP], queue = stm[QUEUE_PROP];
    let position = stm[POS_PROP];
    if (timer) {
      this.clearTimeout(timer);
    }
    if (transaction.length) {
      if (!transaction.title && !title && stm.getTransactionTitle) {
        transaction.title = stm.getTransactionTitle(transaction);
      } else if (title) {
        transaction.title = title;
      }
      queue[position] = transaction;
      queue.length = ++position;
    }
    return [{
      [STATE_PROP]: "autoreadystate",
      [POS_PROP]: position,
      [TRANSACTION_PROP]: null,
      [TRANSACTION_TIMER_PROP]: null
    }, () => {
      stm.notifyStoresAboutStateRecordingStop(transaction, { stop: true });
    }];
  }
  onStopTransactionDelayed(stm) {
    let timer = stm[TRANSACTION_TIMER_PROP];
    if (timer) {
      this.clearTimeout(timer);
    }
    timer = this.setTimeout(
      () => {
        stm.stopTransaction();
      },
      stm.autoRecordTransactionStopTimeout
    );
    return {
      [STATE_PROP]: AutoRecordingState,
      [TRANSACTION_TIMER_PROP]: timer
    };
  }
  onResetQueue(stm, options) {
    return resetQueue(stm, options);
  }
  onRejectTransaction(stm) {
    const transaction = stm[TRANSACTION_PROP], timer = stm[TRANSACTION_TIMER_PROP];
    if (timer) {
      this.clearTimeout(timer);
    }
    return [{
      [STATE_PROP]: "restoringstate",
      [TRANSACTION_PROP]: null,
      [TRANSACTION_TIMER_PROP]: null
    }, () => {
      if (transaction.length) {
        transaction.undo();
      }
      return [
        "autoreadystate",
        () => {
          stm.notifyStoresAboutStateRecordingStop(transaction, { rejected: true });
        }
      ];
    }];
  }
  onModelUpdate(stm, ...rest) {
    super.onModelUpdate(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onModelInsertChild(stm, ...rest) {
    super.onModelInsertChild(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onModelRemoveChild(stm, ...rest) {
    super.onModelRemoveChild(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onStoreModelAdd(stm, ...rest) {
    super.onStoreModelAdd(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onStoreModelInsert(stm, ...rest) {
    super.onStoreModelInsert(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onStoreModelRemove(stm, ...rest) {
    super.onStoreModelRemove(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onStoreRemoveAll(stm, ...rest) {
    super.onStoreRemoveAll(stm, ...rest);
    stm.stopTransactionDelayed();
  }
};
var AutoRecordingState = new AutoRecordingStateClass();
var AutoRecordingState_default = AutoRecordingState;
Registry_default.registerStmState("autorecordingstate", AutoRecordingState);

// ../Core/lib/Core/data/stm/action/ActionBase.js
var throwAbstractMethodCall2 = () => {
  throw new Error("Abstract method call!");
};
var ActionBase = class extends Base2 {
  /**
   * Gets the type of the action (stringified class name).
   * @readonly
   * @property {String}
   */
  get type() {
    return this.constructor.name;
  }
  /**
   * Undoes an action
   */
  undo() {
    throwAbstractMethodCall2();
  }
  /**
   * Redoes an action
   */
  redo() {
    throwAbstractMethodCall2();
  }
};
ActionBase._$name = "ActionBase";

// ../Core/lib/Core/data/stm/action/UpdateAction.js
var MODEL_PROP = Symbol("MODEL_PROP");
var NEW_DATA_PROP = Symbol("NEW_DATA_PROP");
var OLD_DATA_PROP = Symbol("OLD_DATA_PROP");
var UpdateAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      /**
       * Reference to a model which has been updated.
       *
       * @config {Core.data.Model}
       * @default
       */
      model: void 0,
      /**
       * Map of updated properties with new values.
       *
       * @config {Object}
       * @default
       */
      newData: void 0,
      /**
       * Map of updated properties with old values.
       *
       * @config {Object}
       * @default
       */
      oldData: void 0,
      isInitialUserAction: false
    };
  }
  get type() {
    return "UpdateAction";
  }
  get model() {
    return this[MODEL_PROP];
  }
  set model(value) {
    this[MODEL_PROP] = value;
  }
  get newData() {
    return this[NEW_DATA_PROP];
  }
  set newData(value) {
    this[NEW_DATA_PROP] = { ...value };
  }
  get oldData() {
    return this[OLD_DATA_PROP];
  }
  set oldData(value) {
    this[OLD_DATA_PROP] = { ...value };
  }
  undo() {
    const { model, oldData } = this;
    if (model.$) {
      Object.assign(model, oldData);
    }
    model.set(oldData, null, null, null, Boolean(model.$));
  }
  redo() {
    const { model, newData } = this;
    if (model.$) {
      Object.assign(model, newData);
    }
    model.set(newData, null, null, null, Boolean(model.$));
  }
};
UpdateAction._$name = "UpdateAction";

// ../Core/lib/Core/data/stm/action/InsertChildAction.js
var PARENT_MODEL_PROP = Symbol("PARENT_MODEL_PROP");
var CHILD_MODELS_PROP = Symbol("CHILD_MODELS_PROP");
var INSERT_INDEX_PROP = Symbol("INSERT_INDEX_PROP");
var CONTEXT_PROP = Symbol("CONTEXT_PROP");
var InsertChildAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      /**
       * Reference to a parent model a child model has been added to.
       *
       * @config {Core.data.Model}
       * @default
       */
      parentModel: void 0,
      /**
       * Children models inserted.
       *
       * @config {Core.data.Model[]}
       * @default
       */
      childModels: void 0,
      /**
       * Index a children models are inserted at
       *
       * @config {Number}
       * @default
       */
      insertIndex: void 0,
      /**
       * Map having children models as keys and values containing previous parent
       * of each model and index at the previous parent.
       *
       * @config {Object}
       * @default
       */
      context: void 0
    };
  }
  get type() {
    return "InsertChildAction";
  }
  get parentModel() {
    return this[PARENT_MODEL_PROP];
  }
  set parentModel(model) {
    this[PARENT_MODEL_PROP] = model;
  }
  get childModels() {
    return this[CHILD_MODELS_PROP];
  }
  set childModels(models) {
    this[CHILD_MODELS_PROP] = models.slice(0);
  }
  get insertIndex() {
    return this[INSERT_INDEX_PROP];
  }
  set insertIndex(index) {
    this[INSERT_INDEX_PROP] = index;
  }
  get context() {
    return this[CONTEXT_PROP];
  }
  set context(ctx) {
    this[CONTEXT_PROP] = ctx;
  }
  undo() {
    const { parentModel, context, childModels } = this, byFromParent = /* @__PURE__ */ new Map(), newlyAdded = /* @__PURE__ */ new Set();
    for (const childModel of childModels) {
      const ctx = context.get(childModel);
      if (!ctx) {
        newlyAdded.add(childModel);
      } else {
        let undoTaskData = byFromParent.get(ctx.parent);
        if (!undoTaskData) {
          undoTaskData = { moveRight: [], moveLeft: [], moveFromAnotherParent: [] };
          byFromParent.set(ctx.parent, undoTaskData);
        }
        if (ctx.parent === parentModel) {
          if (ctx.index > childModel.parentIndex) {
            undoTaskData.moveRight.push({ parent: ctx.parent, model: childModel, index: ctx.index + 1 });
          } else {
            undoTaskData.moveLeft.push({ parent: ctx.parent, model: childModel, index: ctx.index });
          }
        } else {
          undoTaskData.moveFromAnotherParent.push({ parent: ctx.parent, model: childModel, index: ctx.index });
        }
      }
    }
    for (const undoTaskData of byFromParent.values()) {
      const { moveRight, moveLeft } = undoTaskData;
      moveLeft.sort((a, b) => a.index - b.index);
      moveRight.sort((a, b) => b.index - a.index);
    }
    newlyAdded.forEach((model) => model.parent.removeChild(model));
    for (const undoTaskData of byFromParent.values()) {
      const { moveRight, moveLeft, moveFromAnotherParent } = undoTaskData;
      moveLeft.forEach((task) => {
        task.parent.insertChild(task.model, task.index);
      });
      moveRight.forEach((task) => {
        task.parent.insertChild(task.model, task.index);
      });
      moveFromAnotherParent.forEach((task) => {
        task.parent.insertChild(task.model, task.index);
      });
    }
  }
  redo() {
    var _a2;
    const { parentModel, insertIndex, childModels } = this, insertBefore = parentModel.children[insertIndex];
    parentModel.insertChild(childModels, insertBefore, false, {
      orderedBeforeNode: (_a2 = insertBefore == null ? void 0 : insertBefore.previousSibling) == null ? void 0 : _a2.nextOrderedSibling
    });
  }
};
InsertChildAction._$name = "InsertChildAction";

// ../Core/lib/Core/data/stm/action/RemoveChildAction.js
var PARENT_MODEL_PROP2 = Symbol("PARENT_MODEL_PROP");
var CHILD_MODELS_PROP2 = Symbol("CHILD_MODELS_PROP");
var CONTEXT_PROP2 = Symbol("CONTEXT_PROP");
var RemoveChildAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      /**
       * Reference to a parent model a child model has been removed to.
       *
       * @config {Core.data.Model}
       * @default
       */
      parentModel: void 0,
      /**
       * Children models removed.
       *
       * @config {Core.data.Model[]}
       * @default
       */
      childModels: void 0,
      /**
       * Map having children models as keys and values containing previous parent
       * index at the parent.
       *
       * @config {Object}
       * @default
       */
      context: void 0
    };
  }
  get type() {
    return "RemoveChildAction";
  }
  get parentModel() {
    return this[PARENT_MODEL_PROP2];
  }
  set parentModel(model) {
    this[PARENT_MODEL_PROP2] = model;
  }
  get childModels() {
    return this[CHILD_MODELS_PROP2];
  }
  set childModels(models) {
    this[CHILD_MODELS_PROP2] = models.slice(0);
  }
  get context() {
    return this[CONTEXT_PROP2];
  }
  set context(ctx) {
    this[CONTEXT_PROP2] = ctx;
  }
  undo() {
    const { parentModel, context, childModels } = this;
    childModels.sort((lhs, rhs) => {
      const lhsIndex = context.get(lhs), rhsIndex = context.get(rhs);
      return lhsIndex - rhsIndex;
    });
    childModels.forEach((m) => {
      const ctx = context.get(m);
      parentModel.insertChild(m, ctx.parentIndex, void 0, { orderedParentIndex: ctx.orderedParentIndex });
    });
  }
  redo() {
    this.parentModel.removeChild(this.childModels);
  }
};
RemoveChildAction._$name = "RemoveChildAction";

// ../Core/lib/Core/data/stm/action/AddAction.js
var STORE_PROP = Symbol("STORE_PROP");
var MODEL_LIST_PROP = Symbol("MODEL_LIST_PROP");
var AddAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      /**
       * Reference to a store models have been added into.
       *
       * @config {Core.data.Store}
       * @default
       */
      store: void 0,
      /**
       * List of models added into the store.
       *
       * @config {Core.data.Model[]}
       * @default
       */
      modelList: void 0,
      /**
       * Flag showing if undo/redo should be done silently i.e. with events suppressed
       *
       * @config {Boolean}
       * @default
       */
      silent: false
    };
  }
  get type() {
    return "AddAction";
  }
  get store() {
    return this[STORE_PROP];
  }
  set store(store) {
    this[STORE_PROP] = store;
  }
  get modelList() {
    return this[MODEL_LIST_PROP];
  }
  set modelList(list) {
    this[MODEL_LIST_PROP] = list.slice(0);
  }
  undo() {
    this.store.remove(this.modelList, this.silent);
  }
  redo() {
    this.store.add(this.modelList, this.silent);
  }
};
AddAction._$name = "AddAction";

// ../Core/lib/Core/data/stm/action/InsertAction.js
var STORE_PROP2 = Symbol("STORE_PROP");
var MODEL_LIST_PROP2 = Symbol("MODEL_LIST_PROP");
var INSERT_INDEX_PROP2 = Symbol("INSERT_INDEX_PROP");
var CONTEXT_PROP3 = Symbol("CONTEXT_PROP");
var InsertAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      /**
       * Reference to a store models have been inserted into.
       *
       * @config {Core.data.Store}
       * @default
       */
      store: void 0,
      /**
       * List of models inserted into the store.
       *
       * @config {Core.data.Model[]}
       * @default
       */
      modelList: void 0,
      /**
       * Index the models have been inserted at.
       *
       * @config {Number}
       * @default
       */
      insertIndex: void 0,
      /**
       * Models move context (if models has been moved), if any.
       * Map this {@link Core/data/Model} instances as keys and their
       * previous index as values
       *
       * @config {Map}
       * @default
       */
      context: void 0,
      /**
       * Flag showing if undo/redo should be done silently i.e. with events suppressed
       *
       * @config {Boolean}
       * @default
       */
      silent: false
    };
  }
  get type() {
    return "InsertAction";
  }
  get store() {
    return this[STORE_PROP2];
  }
  set store(store) {
    this[STORE_PROP2] = store;
  }
  get modelList() {
    return this[MODEL_LIST_PROP2];
  }
  set modelList(list) {
    this[MODEL_LIST_PROP2] = list.slice(0);
  }
  get insertIndex() {
    return this[INSERT_INDEX_PROP2];
  }
  set insertIndex(index) {
    this[INSERT_INDEX_PROP2] = index;
  }
  get context() {
    return this[CONTEXT_PROP3];
  }
  set context(context) {
    this[CONTEXT_PROP3] = context;
  }
  undo() {
    const { store, modelList, context, silent } = this;
    modelList.sort((lhs, rhs) => {
      const lhsIndex = context.get(lhs), rhsIndex = context.get(rhs);
      return lhsIndex !== void 0 && rhsIndex !== void 0 ? lhsIndex - rhsIndex : 0;
    });
    modelList.forEach((m) => {
      const index = context.get(m);
      m._undoingInsertion = true;
      if (index !== void 0) {
        store.insert(index, m, silent);
      } else {
        store.remove(m, silent);
      }
      m._undoingInsertion = false;
    });
  }
  redo() {
    const me = this;
    me.store.insert(me.insertIndex, me.modelList, me.silent);
  }
};
InsertAction._$name = "InsertAction";

// ../Core/lib/Core/data/stm/action/RemoveAction.js
var STORE_PROP3 = Symbol("STORE_PROP");
var MODEL_LIST_PROP3 = Symbol("MODEL_LIST_PROP");
var CONTEXT_PROP4 = Symbol("CONTEXT_PROP");
var RemoveAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      /**
       * Reference to a store models have been removed from.
       *
       * @config {Core.data.Store}
       * @default
       */
      store: void 0,
      /**
       * List of models removed from the store.
       *
       * @config {Core.data.Model[]}
       * @default
       */
      modelList: void 0,
      /**
       * Models removing context.
       *
       * @config {Object}
       * @default
       */
      context: void 0,
      /**
       * Flag showing if undo/redo should be done silently i.e. with events suppressed
       *
       * @config {Boolean}
       * @default
       */
      silent: false
    };
  }
  get type() {
    return "RemoveAction";
  }
  get store() {
    return this[STORE_PROP3];
  }
  set store(store) {
    this[STORE_PROP3] = store;
  }
  get modelList() {
    return this[MODEL_LIST_PROP3];
  }
  set modelList(list) {
    this[MODEL_LIST_PROP3] = list.slice(0);
  }
  get context() {
    return this[CONTEXT_PROP4];
  }
  set context(context) {
    this[CONTEXT_PROP4] = context;
  }
  undo() {
    const { store, context, modelList, silent } = this;
    modelList.sort((lhs, rhs) => {
      const lhsIndex = context.get(lhs), rhsIndex = context.get(rhs);
      return lhsIndex - rhsIndex;
    });
    modelList.forEach((m) => {
      const index = context.get(m);
      store.insert(index, m, silent);
    });
  }
  redo() {
    this.store.remove(this.modelList, this.silent);
  }
};
RemoveAction._$name = "RemoveAction";

// ../Core/lib/Core/data/stm/action/RemoveAllAction.js
var STORE_PROP4 = Symbol("STORE_PROP");
var ALL_RECORDS_PROP = Symbol("ALL_RECORDS_PROP");
var RemoveAllAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      /**
       * Reference to a store cleared.
       *
       * @config {Core.data.Store}
       * @default
       */
      store: void 0,
      /**
       * All store records removed
       *
       * @config {Core.data.Model[]}
       * @default
       */
      allRecords: void 0,
      /**
       * Flag showing if undo/redo should be done silently i.e. with events suppressed
       *
       * @config {Boolean}
       * @default
       */
      silent: false
    };
  }
  get type() {
    return "RemoveAllAction";
  }
  get store() {
    return this[STORE_PROP4];
  }
  set store(store) {
    this[STORE_PROP4] = store;
  }
  get allRecords() {
    return this[ALL_RECORDS_PROP];
  }
  set allRecords(records) {
    this[ALL_RECORDS_PROP] = records.slice(0);
  }
  undo() {
    const { store, allRecords, silent } = this;
    store.add(allRecords, silent);
  }
  redo() {
    this.store.removeAll(this.silent);
  }
};
RemoveAllAction._$name = "RemoveAllAction";

// ../Core/lib/Core/data/stm/StateTrackingManager.js
var makeModelUpdateAction = (model, newData, oldData, isInitialUserAction) => {
  return new UpdateAction({
    model,
    newData,
    oldData,
    isInitialUserAction
  });
};
var makeModelInsertChildAction = (parentModel, insertIndex, childModels, context) => {
  return new InsertChildAction({
    parentModel,
    childModels,
    insertIndex,
    context
  });
};
var makeModelRemoveChildAction = (parentModel, childModels, context) => {
  return new RemoveChildAction({
    parentModel,
    childModels,
    context
  });
};
var makeStoreModelAddAction = (store, modelList, silent) => {
  return new AddAction({
    store,
    modelList,
    silent
  });
};
var makeStoreModelInsertAction = (store, insertIndex, modelList, context, silent) => {
  return new InsertAction({
    store,
    insertIndex,
    modelList,
    context,
    silent
  });
};
var makeStoreModelRemoveAction = (store, modelList, context, silent) => {
  return new RemoveAction({
    store,
    modelList,
    context,
    silent
  });
};
var makeStoreRemoveAllAction = (store, allRecords, silent) => {
  return new RemoveAllAction({
    store,
    allRecords,
    silent
  });
};
var stateTransition = (stm, event, ...args) => {
  const oldState = stm.state, newState = event.call(stm[STATE_PROP], stm, ...args);
  if (typeof newState === "string") {
    stm[STATE_PROP] = Registry_default.resolveStmState(newState);
  } else if (newState instanceof StateBase) {
    stm[STATE_PROP] = newState;
  } else if (Array.isArray(newState)) {
    const [state, next] = newState;
    if (typeof state === "string") {
      stm[STATE_PROP] = Registry_default.resolveStmState(state);
    } else if (state instanceof StateBase) {
      stm[STATE_PROP] = state;
    } else if (state && typeof state === "object") {
      stm = Object.assign(stm, state);
      stm[STATE_PROP] = Registry_default.resolveStmState(stm[STATE_PROP]);
    }
    if (typeof next === "function") {
      stateTransition(stm, next, ...args);
    }
  } else if (newState && typeof newState === "object") {
    stm = Object.assign(stm, newState);
    stm[STATE_PROP] = Registry_default.resolveStmState(stm[STATE_PROP]);
  }
  if (oldState !== ReadyState_default && oldState !== AutoReadyState_default && (newState !== ReadyState_default && newState !== AutoReadyState_default)) {
    stm.trigger("ready");
  }
};
var StateTrackingManager = class extends Events_default(Base2) {
  static get defaultConfig() {
    return {
      /**
       * Default manager disabled state
       *
       * @config {Boolean}
       * @default
       */
      disabled: true,
      /**
       * Whether to start transaction recording automatically in case the Manager is enabled.
       *
       * In the auto recording mode, the manager waits for the first change in any store being managed and starts a transaction, i.e.
       * records any changes in its monitored stores. The transaction lasts for {@link #config-autoRecordTransactionStopTimeout} and
       * afterwards creates one undo/redo step, including all changes in the stores during that period of time.
       *
       * In non auto recording mode you have to call {@link #function-startTransaction} / {@link #function-stopTransaction} to start and end
       * a transaction.
       *
       * @config {Boolean}
       * @default
       */
      autoRecord: false,
      /**
       * The transaction duration (in ms) for the auto recording mode {@link #config-autoRecord}
       *
       * @config {Number}
       * @default
       */
      autoRecordTransactionStopTimeout: 100,
      /**
       * Store model update action factory
       *
       * @config {Function}
       * @default
       * @private
       */
      makeModelUpdateAction,
      /**
       * Store insert child model action factory.
       *
       * @config {Function}
       * @default
       * @private
       */
      makeModelInsertChildAction,
      /**
       * Store remove child model action factory.
       *
       * @config {Function}
       * @default
       * @private
       */
      makeModelRemoveChildAction,
      /**
       * Store add model action factory.
       *
       * @config {Function}
       * @default
       * @private
       */
      makeStoreModelAddAction,
      /**
       * Store insert model action factory.
       *
       * @config {Function}
       * @default
       * @private
       */
      makeStoreModelInsertAction,
      /**
       * Store remove model action factory.
       *
       * @config {Function}
       * @default
       * @private
       */
      makeStoreModelRemoveAction,
      /**
       * Store remove all models action factory.
       *
       * @config {Function}
       * @default
       * @private
       */
      makeStoreRemoveAllAction,
      /**
       * Function to create a transaction title if none is provided.
       *
       * The function receives a transaction and should return a title.
       *
       * @config {Function}
       * @default
       */
      getTransactionTitle: null
    };
  }
  construct(...args) {
    Object.assign(this, {
      [STATE_PROP]: ReadyState_default,
      [STORES_PROP]: [],
      [QUEUE_PROP]: [],
      [POS_PROP]: 0,
      [TRANSACTION_PROP]: null,
      [TRANSACTION_TIMER_PROP]: null,
      [AUTO_RECORD_PROP]: false,
      [IS_APPLYING_STASH]: false,
      stashedTransactions: {}
    });
    super.construct(...args);
  }
  /**
   * Gets current state of the manager
   *
   * @property {Core.data.stm.state.StateBase}
   */
  get state() {
    return this[STATE_PROP];
  }
  /**
   * Gets current undo/redo queue position
   *
   * @property {Number}
   */
  get position() {
    return this[POS_PROP];
  }
  /**
   * Gets current undo/redo queue length
   *
   * @property {Number}
   */
  get length() {
    return this[QUEUE_PROP].length;
  }
  /**
   * Gets all the stores registered in STM
   *
   * @property {Core.data.Store[]}
   */
  get stores() {
    return Array.from(this[STORES_PROP]);
  }
  /**
   * Checks if a store has been added to the manager
   *
   * @param  {Core.data.Store} store
   * @returns {Boolean}
   */
  hasStore(store) {
    return this[STORES_PROP].includes(store);
  }
  /**
   * Adds a store to the manager
   *
   * @param {Core.data.Store} store
   */
  addStore(store) {
    if (!this.hasStore(store)) {
      this[STORES_PROP].push(store);
      store.stm = this;
      store.forEach((model) => model.stm = this);
    }
  }
  /**
   * Removes a store from the manager
   *
   * @param {Core.data.Store} store
   */
  removeStore(store) {
    if (this.hasStore(store)) {
      this[STORES_PROP] = this[STORES_PROP].filter((s) => s !== store);
      store.stm = null;
      store.forEach((model) => model.stm = null);
    }
  }
  /**
   * Calls `fn` for each store registered in STM.
   *
   * @param {Function} fn (store, id) => ...
   */
  forEachStore(fn2) {
    this[STORES_PROP].forEach((s) => fn2(s, s.id));
  }
  //#region Disabled state
  /**
   * Get/set manager disabled state
   *
   * @property {Boolean}
   */
  get disabled() {
    return this.state === DisabledState_default;
  }
  set disabled(val) {
    const me = this;
    if (me.disabled !== val) {
      if (val) {
        stateTransition(me, me.state.onDisable, me);
      } else {
        stateTransition(me, me.state.onEnable, me);
      }
      me.trigger("stmDisabled", { disabled: val });
      me.trigger("disabled", { disabled: val });
    }
  }
  get enabled() {
    return !this.disabled;
  }
  /**
   * Enables manager
   */
  enable() {
    this.disabled = false;
  }
  /**
   * Disables manager
   */
  disable() {
    this.disabled = true;
  }
  //#endregion
  /**
   * Checks manager ready state
   * @readonly
   * @property {Boolean}
   */
  get isReady() {
    return this.state === ReadyState_default || this.state === AutoReadyState_default;
  }
  waitForReadiness() {
    return this.await("ready", false);
  }
  /**
   * Checks manager recording state
   * @readonly
   * @property {Boolean}
   */
  get isRecording() {
    return this.state === RecordingState_default || this.state === AutoRecordingState_default;
  }
  /**
   * Checks if STM is restoring a stash
   * @readonly
   * @property {Boolean}
   * @internal
   */
  get isApplyingStash() {
    return this[IS_APPLYING_STASH];
  }
  /**
   * Gets/sets manager auto record option
   *
   * @property {Boolean}
   */
  get autoRecord() {
    return this[AUTO_RECORD_PROP];
  }
  set autoRecord(value) {
    const me = this;
    if (me.autoRecord != value) {
      if (value) {
        stateTransition(me, me.state.onAutoRecordOn, me);
      } else {
        stateTransition(me, me.state.onAutoRecordOff, me);
      }
    }
  }
  /**
   * Starts undo/redo recording transaction.
   *
   * @param {String} [title]
   */
  startTransaction(title = null) {
    stateTransition(this, this.state.onStartTransaction, title);
  }
  /**
   * Stops undo/redo recording transaction
   *
   * @param {String} [title]
   */
  stopTransaction(title = null) {
    stateTransition(this, this.state.onStopTransaction, title);
  }
  /**
   * Stops undo/redo recording transaction after {@link #config-autoRecordTransactionStopTimeout} delay.
   *
   * @private
   */
  stopTransactionDelayed() {
    stateTransition(this, this.state.onStopTransactionDelayed);
  }
  /**
   * Rejects currently recorded transaction.
   */
  rejectTransaction() {
    stateTransition(this, this.state.onRejectTransaction);
  }
  /**
   * Gets currently recording STM transaction.
   * @readonly
   * @property {Core.data.stm.Transaction}
   */
  get transaction() {
    return this[TRANSACTION_PROP];
  }
  /**
   * Gets titles of all recorded undo/redo transactions
   * @readonly
   * @property {String[]}
   */
  get queue() {
    return this[QUEUE_PROP].map((t) => t.title);
  }
  get rawQueue() {
    return this[QUEUE_PROP];
  }
  /**
   * Gets manager restoring state.
   * @readonly
   * @property {Boolean}
   */
  get isRestoring() {
    return this.state === RestoringState_default || this.isApplyingStash;
  }
  /**
   * Checks if the manager can undo.
   *
   * @property {Boolean}
   */
  get canUndo() {
    return this.state.canUndo(this);
  }
  /**
   * Checks if the manager can redo.
   *
   * @property {Boolean}
   */
  get canRedo() {
    return this.state.canRedo(this);
  }
  /**
   * Undoes current undo/redo transaction.
   * @param {Number} [steps=1]
   * @returns {Promise} A promise which is resolved when undo action has been performed
   */
  async undo(steps = 1) {
    if (!this.isReady) {
      await this.waitForReadiness();
    }
    stateTransition(this, this.state.onUndo, steps);
  }
  /**
   * Undoes all transactions.
   * @returns {Promise} A promise which is resolved when undo actions has been performed
   */
  async undoAll() {
    if (!this.isReady) {
      await this.waitForReadiness();
    }
    this.undo(this.length);
  }
  /**
   * Redoes current undo/redo transaction.
   *
   * @param {Number} [steps=1]
   * @returns {Promise} A promise which is resolved when redo action has been performed
   */
  async redo(steps = 1) {
    if (!this.isReady) {
      await this.waitForReadiness();
    }
    stateTransition(this, this.state.onRedo, steps);
  }
  /**
   * Redoes all transactions.
   * @returns {Promise} A promise which is resolved when redo actions has been performed
   */
  async redoAll() {
    if (!this.isReady) {
      await this.waitForReadiness();
    }
    this.redo(this.length);
  }
  /**
   * Resets undo/redo queue.
   */
  resetQueue(options = { undo: true, redo: true }) {
    stateTransition(this, this.state.onResetQueue, options);
  }
  /**
   * Resets undo queue.
   */
  resetUndoQueue() {
    this.resetQueue({ undo: true });
  }
  /**
   * Resets redo queue.
   */
  resetRedoQueue() {
    this.resetQueue({ redo: true });
  }
  notifyStoresAboutStateRecordingStart(transaction) {
    this.forEachStore((store) => {
      var _a2;
      return (_a2 = store.onStmRecordingStart) == null ? void 0 : _a2.call(store, this, transaction);
    });
    this.trigger("recordingStart", { stm: this, transaction });
  }
  notifyStoresAboutStateRecordingStop(transaction, reason) {
    this.forEachStore((store) => {
      var _a2;
      return (_a2 = store.onStmRecordingStop) == null ? void 0 : _a2.call(store, this, transaction, reason);
    });
    this.trigger("recordingStop", { stm: this, transaction, reason });
  }
  notifyStoresAboutStateRestoringStart() {
    this.forEachStore((store) => {
      var _a2;
      return (_a2 = store.onStmRestoringStart) == null ? void 0 : _a2.call(store, this);
    });
    this.trigger("restoringStart", { stm: this });
  }
  /**
   * @param {'undo'|'redo'} cause The cause of the restore, if applicable
   * @internal
   */
  notifyStoresAboutStateRestoringStop({ cause, transactions }) {
    this.forEachStore((store) => {
      var _a2;
      return (_a2 = store.onStmRestoringStop) == null ? void 0 : _a2.call(store, this);
    });
    this.trigger("restoringStop", { stm: this, cause, transactions });
  }
  notifyStoresAboutQueueReset(options) {
    this.forEachStore((store) => {
      var _a2;
      return (_a2 = store.onStmQueueReset) == null ? void 0 : _a2.call(store, this, options);
    });
    this.trigger("queueReset", { stm: this, options });
  }
  /**
   * Method to call from model STM mixin upon model update
   *
   * @param {Core.data.Model} model
   * @param {Object} newData
   * @param {Object} oldData
   *
   * @private
   */
  onModelUpdate(model, newData, oldData, isInitialUserAction) {
    stateTransition(this, this.state.onModelUpdate, model, newData, oldData, isInitialUserAction);
  }
  /**
   * Method to call from model STM mixin upon tree model child insertion
   *
   * @param {Core.data.Model} parentModel Parent model
   * @param {Number} index Insertion index
   * @param {Core.data.Model[]} childModels Array of models inserted
   * @param {Map} context Map with inserted models as keys and objects with previous parent,
   *                      and index at previous parent.
   *
   * @private
   */
  onModelInsertChild(parentModel, index, childModels, context) {
    stateTransition(this, this.state.onModelInsertChild, parentModel, index, childModels, context);
  }
  /**
   * Method to call from model STM mixin upon tree model child removal
   *
   * @param {Core.data.Model} parentModel
   * @param {Core.data.Model[]} childModels
   * @param {Map} context
   *
   * @private
   */
  onModelRemoveChild(parentModel, childModels, context) {
    stateTransition(this, this.state.onModelRemoveChild, parentModel, childModels, context);
  }
  /**
   * Method to call from store STM mixin upon store models adding
   *
   * @param {Core.data.Store} store
   * @param {Core.data.Model[]} models
   * @param {Boolean} silent
   *
   * @private
   */
  onStoreModelAdd(store, models, silent) {
    stateTransition(this, this.state.onStoreModelAdd, store, models, silent);
  }
  /**
   * Method to call from store STM mixin upon store models insertion
   *
   * @param {Core.data.Store} store
   * @param {Number} index
   * @param {Core.data.Model[]} models
   * @param {Map} context
   * @param {Boolean} silent
   *
   * @private
   */
  onStoreModelInsert(store, index, models, context, silent) {
    stateTransition(this, this.state.onStoreModelInsert, store, index, models, context, silent);
  }
  /**
   * Method to call from store STM mixin upon store models removal
   *
   * @param {Core.data.Store} store
   * @param {Core.data.Model[]} models
   * @param {Object} context
   * @param {Boolean} silent
   *
   * @private
   */
  onStoreModelRemove(store, models, context, silent) {
    stateTransition(this, this.state.onStoreModelRemove, store, models, context, silent);
  }
  /**
   * Method to call from store STM mixin upon store clear
   *
   * @param {Core.data.Store} store
   * @param {Core.data.Model[]} allRecords
   * @param {Boolean} silent
   *
   * @private
   */
  onStoreRemoveAll(store, allRecords, silent) {
    stateTransition(this, this.state.onStoreRemoveAll, store, allRecords, silent);
  }
  // UI key event handling
  onUndoKeyPress(event) {
    const me = this;
    if (me.enabled) {
      if (event.shiftKey) {
        if (me.canRedo) {
          event.preventDefault();
          me.redo();
        }
      } else if (me.canUndo) {
        event.preventDefault();
        me.undo();
      }
    }
  }
  stash() {
    const me = this;
    if (this.transaction) {
      const id = IdHelper.generateId("_stashedTransactionGeneratedId_");
      me.stashedTransactions[id] = me.transaction;
      me.rejectTransaction();
      return id;
    }
  }
  applyStash(id) {
    const me = this, transaction = me.stashedTransactions[id];
    me[IS_APPLYING_STASH] = true;
    if (transaction) {
      me.startTransaction(transaction.title);
      transaction.redo();
      delete me.stashedTransactions[id];
    }
    me[IS_APPLYING_STASH] = false;
  }
};
StateTrackingManager._$name = "StateTrackingManager";

// ../Engine/lib/Engine/scheduling/DurationConverterMixin.js
var __decorate16 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DurationConverterMixin = class extends Mixin([ChronoModelMixin], (base) => {
  const superProto = base.prototype;
  class DurationConverterMixin2 extends base {
    *calculateUnitsInMs() {
      const hoursPerDay = yield this.$.hoursPerDay;
      const daysPerWeek = yield this.$.daysPerWeek;
      const daysPerMonth = yield this.$.daysPerMonth;
      return {
        millisecond: 1,
        second: 1e3,
        minute: 60 * 1e3,
        hour: 60 * 60 * 1e3,
        day: hoursPerDay * 60 * 60 * 1e3,
        week: daysPerWeek * hoursPerDay * 60 * 60 * 1e3,
        month: daysPerMonth * hoursPerDay * 60 * 60 * 1e3,
        quarter: 3 * daysPerMonth * hoursPerDay * 60 * 60 * 1e3,
        year: 4 * 3 * daysPerMonth * hoursPerDay * 60 * 60 * 1e3
      };
    }
    /**
     * Converts duration value from one time unit to another
     * @param duration Duration value
     * @param fromUnit Duration value time unit
     * @param toUnit   Target time unit to convert the value to
     */
    convertDuration(duration, fromUnit, toUnit) {
      let result = duration;
      if (fromUnit !== toUnit) {
        result = duration * this.unitsInMs[fromUnit] / this.unitsInMs[toUnit];
      }
      return result;
    }
    *$convertDuration(duration, fromUnit, toUnit) {
      if (!fromUnit || !toUnit)
        throw new Error("Conversion unit not provided");
      const unitsInMs = yield this.$.unitsInMs;
      let result = duration;
      if (fromUnit !== toUnit) {
        result = duration * unitsInMs[fromUnit] / unitsInMs[toUnit];
      }
      return result;
    }
  }
  __decorate16([
    field()
  ], DurationConverterMixin2.prototype, "unitsInMs", void 0);
  __decorate16([
    model_field({ type: "number", defaultValue: 24 })
  ], DurationConverterMixin2.prototype, "hoursPerDay", void 0);
  __decorate16([
    model_field({ type: "number", defaultValue: 7 })
  ], DurationConverterMixin2.prototype, "daysPerWeek", void 0);
  __decorate16([
    model_field({ type: "number", defaultValue: 30 })
  ], DurationConverterMixin2.prototype, "daysPerMonth", void 0);
  __decorate16([
    calculate("unitsInMs")
  ], DurationConverterMixin2.prototype, "calculateUnitsInMs", null);
  return DurationConverterMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_basic/BaseAssignmentMixin.js
var __decorate17 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var BaseAssignmentMixin = class extends Mixin([ChronoPartOfProjectModelMixin], (base) => {
  const superProto = base.prototype;
  class BaseAssignmentMixin2 extends base {
  }
  __decorate17([
    generic_field({
      bucket: "assigned",
      resolver: function(id) {
        return this.getEventById(id);
      },
      modelFieldConfig: {
        serialize: (event) => event == null ? void 0 : event.id,
        isEqual: isSerializableEqual,
        persist: false
      }
    }, ModelReferenceField)
  ], BaseAssignmentMixin2.prototype, "event", void 0);
  __decorate17([
    generic_field({
      bucket: "assigned",
      resolver: function(id) {
        return this.getResourceById(id);
      },
      modelFieldConfig: {
        serialize: (resource) => resource == null ? void 0 : resource.id,
        isEqual: isSerializableEqual,
        persist: false
      }
    }, ModelReferenceField)
  ], BaseAssignmentMixin2.prototype, "resource", void 0);
  injectStaticFieldsProperty(BaseAssignmentMixin2);
  return BaseAssignmentMixin2;
}) {
};

// ../Engine/lib/Engine/quark/store/AbstractAssignmentStoreMixin.js
var AbstractAssignmentStoreMixin = class extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class AbstractAssignmentStoreMixin2 extends base {
    constructor() {
      super(...arguments);
      this.assignmentsForRemoval = /* @__PURE__ */ new Set();
      this.allAssignmentsForRemoval = false;
    }
    remove(records, silent) {
      this.assignmentsForRemoval = CIFromSetOrArrayOrValue(records).toSet();
      const res = superProto.remove.call(this, records, silent);
      this.assignmentsForRemoval.clear();
      return res;
    }
    removeAll(silent) {
      this.allAssignmentsForRemoval = true;
      const res = superProto.removeAll.call(this, silent);
      this.allAssignmentsForRemoval = false;
      return res;
    }
  }
  return AbstractAssignmentStoreMixin2;
}) {
};

// ../Engine/lib/Engine/quark/store/ChronoAssignmentStoreMixin.js
var ChronoAssignmentStoreMixin = class extends Mixin([AbstractAssignmentStoreMixin, ChronoPartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class ChronoAssignmentStoreMixin2 extends base {
    constructor() {
      super(...arguments);
      this.removalOrder = 100;
    }
    static get defaultConfig() {
      return {
        modelClass: BaseAssignmentMixin
      };
    }
    set data(value) {
      this.allAssignmentsForRemoval = true;
      super.data = value;
      this.allAssignmentsForRemoval = false;
    }
  }
  return ChronoAssignmentStoreMixin2;
}) {
};

// ../Engine/lib/Engine/quark/store/AbstractCalendarManagerStoreMixin.js
var AbstractCalendarManagerStoreMixin = class extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class AbstractCalendarManagerStoreMixin2 extends base {
    // special handling to destroy calendar models as part of destroying this store
    doDestroy() {
      var _a2;
      const records = [];
      if (!((_a2 = this.rootNode) == null ? void 0 : _a2.isDestroyed)) {
        this.traverse((record) => records.push(record));
      }
      super.doDestroy();
      records.forEach((record) => record.destroy());
    }
  }
  return AbstractCalendarManagerStoreMixin2;
}) {
};

// ../Engine/lib/Engine/quark/store/ChronoCalendarManagerStoreMixin.js
var ChronoCalendarManagerStoreMixin = class extends Mixin([AbstractCalendarManagerStoreMixin, ChronoPartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class ChronoCalendarManagerStoreMixin2 extends base {
    constructor() {
      super(...arguments);
      this.removalOrder = 500;
    }
    static get defaultConfig() {
      return {
        tree: true,
        modelClass: BaseCalendarMixin
      };
    }
  }
  return ChronoCalendarManagerStoreMixin2;
}) {
};

// ../Engine/lib/Engine/quark/store/AbstractDependencyStoreMixin.js
var AbstractDependencyStoreMixin = class extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class AbstractDependencyStoreMixin2 extends base {
    constructor() {
      super(...arguments);
      this.dependenciesForRemoval = /* @__PURE__ */ new Set();
      this.allDependenciesForRemoval = false;
    }
    remove(records, silent) {
      this.dependenciesForRemoval = CIFromSetOrArrayOrValue(records).toSet();
      const res = superProto.remove.call(this, records, silent);
      this.dependenciesForRemoval.clear();
      return res;
    }
    removeAll(silent) {
      this.allDependenciesForRemoval = true;
      const res = superProto.removeAll.call(this, silent);
      this.allDependenciesForRemoval = false;
      return res;
    }
  }
  return AbstractDependencyStoreMixin2;
}) {
};

// ../Engine/lib/Engine/quark/store/ChronoDependencyStoreMixin.js
var ChronoDependencyStoreMixin = class extends Mixin([AbstractDependencyStoreMixin, ChronoPartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class ChronoDependencyStoreMixin2 extends base {
    constructor() {
      super(...arguments);
      this.removalOrder = 200;
    }
    set data(value) {
      this.allDependenciesForRemoval = true;
      super.data = value;
      this.allDependenciesForRemoval = false;
    }
  }
  return ChronoDependencyStoreMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_basic/BaseResourceMixin.js
var __decorate18 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var BaseResourceMixin = class extends Mixin([HasCalendarMixin, ChronoPartOfProjectModelMixin], (base) => {
  const superProto = base.prototype;
  class BaseResourceMixin2 extends base {
    get assignments() {
      return [...this.assigned];
    }
    leaveProject(isReplacing = false) {
      if (!this.isStmRestoring && this.assigned && !isReplacing) {
        const resourceStore = this.getResourceStore();
        this.assigned.forEach((assignment) => resourceStore.assignmentsForRemoval.add(assignment));
      }
      superProto.leaveProject.call(this);
    }
    // resource model should support the "tree mode" in the same way as event model
    static get fields() {
      return [
        { name: "parentId" },
        { name: "children", persist: false }
      ];
    }
  }
  __decorate18([
    generic_field({}, ModelBucketField)
  ], BaseResourceMixin2.prototype, "assigned", void 0);
  return BaseResourceMixin2;
}) {
};

// ../Engine/lib/Engine/quark/store/AbstractResourceStoreMixin.js
var dataAddRemoveActions3 = {
  splice: 1,
  clear: 1
};
var AbstractResourceStoreMixin = class extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class AbstractResourceStoreMixin2 extends base {
    constructor() {
      super(...arguments);
      this.assignmentsForRemoval = /* @__PURE__ */ new Set();
    }
    // we need `onDataChange` for `syncDataOnLoad` option to work
    onDataChange(event) {
      var _a2;
      const isAddRemove = dataAddRemoveActions3[event.action];
      super.onDataChange(event);
      if (isAddRemove && ((_a2 = event.removed) == null ? void 0 : _a2.length))
        this.afterResourceRemoval();
    }
    // it seems `onDataChange` is not triggered for `remove` with `silent` flag
    remove(records, silent) {
      const res = superProto.remove.call(this, records, silent);
      this.afterResourceRemoval();
      return res;
    }
    // it seems `onDataChange` is not triggered for `TreeStore#removeAll()`
    removeAll(silent) {
      const res = superProto.removeAll.call(this, silent);
      this.afterResourceRemoval();
      return res;
    }
    afterResourceRemoval() {
      const assignmentStore = this.getAssignmentStore();
      if (assignmentStore && !assignmentStore.allAssignmentsForRemoval) {
        const assignmentsForRemoval = [...this.assignmentsForRemoval].filter((assignment) => !assignmentStore.assignmentsForRemoval.has(assignment));
        assignmentsForRemoval.length > 0 && assignmentStore.remove(assignmentsForRemoval);
      }
      this.assignmentsForRemoval.clear();
    }
    processRecord(resourceRecord, isDataset = false) {
      const existingRecord = this.getById(resourceRecord.id);
      const isReplacing = existingRecord && existingRecord !== resourceRecord;
      if (isReplacing) {
        for (const assignment of existingRecord.assigned || []) {
          assignment.resource = resourceRecord;
        }
      }
      return resourceRecord;
    }
  }
  return AbstractResourceStoreMixin2;
}) {
};

// ../Engine/lib/Engine/quark/store/ChronoResourceStoreMixin.js
var ChronoResourceStoreMixin = class extends Mixin([AbstractResourceStoreMixin, ChronoPartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class ChronoResourceStoreMixin2 extends base {
    constructor() {
      super(...arguments);
      this.removalOrder = 300;
    }
    static get defaultConfig() {
      return {
        modelClass: BaseResourceMixin
      };
    }
  }
  return ChronoResourceStoreMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/AbstractProjectMixin.js
var EventsWrapper = class extends Mixin([], Events_default) {
};
var DelayableWrapper = class extends Mixin([], Delayable_default) {
};
var AbstractProjectMixin = class extends Mixin([
  EventsWrapper,
  DelayableWrapper,
  Model
], (base) => {
  const superProto = base.prototype;
  class AbstractProjectMixin2 extends base {
    constructor() {
      super(...arguments);
      this.isRestoringData = false;
    }
    get isRepopulatingStores() {
      return false;
    }
    get isInitialCommit() {
      return !this.isInitialCommitPerformed || this.hasLoadedDataToCommit;
    }
    construct(config = {}) {
      this.isInitialCommitPerformed = false;
      this.isLoadingInlineData = false;
      this.isWritingData = false;
      this.hasLoadedDataToCommit = false;
      const silenceInitialCommit = "silenceInitialCommit" in config ? config.silenceInitialCommit : true;
      const adjustDurationToDST = "adjustDurationToDST" in config ? config.adjustDurationToDST : false;
      this.maxCalendarRange = "maxCalendarRange" in config ? config.maxCalendarRange : 15768e7;
      delete config.maxCalendarRange;
      delete config.silenceInitialCommit;
      delete config.adjustDurationToDST;
      superProto.construct.call(this, config);
      this.silenceInitialCommit = silenceInitialCommit;
      this.adjustDurationToDST = adjustDurationToDST;
    }
    // Template method called when a stores dataset is replaced. Implemented in SchedulerBasicProjectMixin
    repopulateStore(store) {
    }
    // Template method called when replica should be repopulated. Implemented in SchedulerBasicProjectMixin
    repopulateReplica() {
    }
    deferUntilRepopulationIfNeeded(deferId, func, args) {
      func(...args);
    }
    // Template method called when a store is attached to the project
    attachStore(store) {
    }
    // Template method called when a store is detached to the project
    detachStore(store) {
    }
    async commitAsync() {
      throw new Error("Abstract method called");
    }
    // Different implementations for Core and Basic engines
    isEngineReady() {
      throw new Error("Abstract method called");
    }
    getStm() {
      throw new Error("Abstract method called");
    }
  }
  return AbstractProjectMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_basic/ChronoAbstractProjectMixin.js
var ChronoAbstractProjectMixin = class extends Mixin([ChronoModelMixin, AbstractProjectMixin], (base) => {
  const superProto = base.prototype;
  class ChronoAbstractProjectMixin2 extends base {
    // External flag, toggled late in finalization when already entered replica
    get isDelayingCalculation() {
      return Boolean(this.delayEnteringReplica || this.delayedCalculationPromise);
    }
    getGraph() {
      return this.replica;
    }
    beforeCommitAsync() {
      return null;
    }
    enterReplica(enterRecords) {
    }
    acceptChanges() {
    }
    // If we are delaying calculations, return its promise which will be resolved when calculations are finished.
    // As part of that process it will commit replica
    async commitAsync() {
      var _a2;
      return this.delayedCalculationPromise || ((_a2 = this.replica) == null ? void 0 : _a2.commitAsync());
    }
    getSchedulingIssueEventArguments(schedulingIssue, transaction, resolve, reject) {
      const result = [
        schedulingIssue.type,
        {
          continueWithResolutionResult: resolve,
          schedulingIssue
        }
      ];
      if (schedulingIssue instanceof ConflictEffect)
        result[1].conflict = schedulingIssue;
      return result;
    }
    async onSchedulingIssueCall(schedulingIssue, transaction) {
      if (schedulingIssue.type && this.hasListener(schedulingIssue.type)) {
        return new Promise((resolve, reject) => {
          this.trigger(...this.getSchedulingIssueEventArguments(schedulingIssue, transaction, resolve, reject));
        });
      }
      return EffectResolutionResult.Cancel;
    }
    async onCycleSchedulingIssue(schedulingIssue, transaction) {
      return this.onSchedulingIssueCall(schedulingIssue, transaction);
    }
    async onEmptyCalendarSchedulingIssue(schedulingIssue, transaction) {
      return this.onSchedulingIssueCall(schedulingIssue, transaction);
    }
    async onConflictSchedulingIssue(schedulingIssue, transaction) {
      return this.onSchedulingIssueCall(schedulingIssue, transaction);
    }
    setModelCalculations(model, calculations) {
      if (!calculations)
        return;
      const oldValues = {};
      for (const field2 in calculations) {
        oldValues[field2] = model.prototype.$calculations[field2];
      }
      Object.assign(model.prototype.$calculations, calculations);
      return oldValues;
    }
    setRecordCalculations(record, calculations) {
      const oldValues = this.setModelCalculations(record.constructor, calculations);
      const skeleton = record.$entity.$skeleton;
      Object.keys(calculations).forEach((field2) => {
        skeleton[field2].prototype.calculation = record[calculations[field2]];
      });
      return oldValues;
    }
    setStoreCalculations(store, calculations) {
      if (!calculations)
        return;
      const record = store.first;
      if (record) {
        return this.setRecordCalculations(record, calculations);
      } else {
        return this.setModelCalculations(store.modelClass, calculations);
      }
    }
    /**
     * Overrides the project owned store identifiers calculation.
     * @param calculations Object providing new identifier calculation function names.
     * The object is grouped by store identifiers. For example below code
     * overrides event `startDate`, `endDate` and `duration` calculation so
     * the fields will always simply return their current values:
     *
     * ```typescript
     * // event startDate, endDate and duration will use their userProvidedValue method
     * // which simply returns their current values as-is
     * const oldCalculations = await project.setCalculations({
     *     events : {
     *         startDate : "userProvidedValue",
     *         endDate   : "userProvidedValue",
     *         duration  : "userProvidedValue"
     *     }
     * })
     * ```
     * @returns Promise that resolves with an object having the overridden calculations.
     * The object can be used to toggle the calculations back in the future:
     * ```typescript
     * // override event duration calculation
     * const oldCalculations = await project.setCalculations({
     *     events : {
     *         duration  : "userProvidedValue"
     *     }
     * })
     * // revert the duration calculation back
     * project.setCalculations(oldCalculations)
     * ```
     */
    async setCalculations(calculations) {
      this.replica && await this.commitAsync();
      const oldCalculations = {};
      const stores = {
        tasks: this.eventStore,
        events: this.eventStore,
        dependencies: this.dependencyStore,
        resources: this.resourceStore,
        assignments: this.assignmentStore,
        calendars: this.calendarManagerStore
      };
      Object.keys(stores).forEach((id) => {
        if (calculations[id]) {
          oldCalculations[id] = this.setStoreCalculations(stores[id], calculations[id]);
        }
      });
      let projectCalculations = calculations.project;
      if (projectCalculations) {
        oldCalculations.project = this.setRecordCalculations(this, projectCalculations);
      }
      this.replica && this.repopulateReplica.now();
      this.replica && await this.commitAsync();
      return oldCalculations;
    }
  }
  return ChronoAbstractProjectMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_basic/BaseDependencyMixin.js
var __decorate19 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var BaseDependencyMixin = class extends Mixin([ChronoPartOfProjectModelMixin], (base) => {
  const superProto = base.prototype;
  class BaseDependencyMixin2 extends base {
    get isValid() {
      const { $, graph } = this;
      if (graph && (!graph.hasIdentifier($.fromEvent) || !graph.hasIdentifier($.toEvent))) {
        return false;
      }
      return super.isValid;
    }
  }
  __decorate19([
    generic_field({
      bucket: "outgoingDeps",
      resolver: function(id) {
        return this.getEventById(id);
      },
      modelFieldConfig: {
        persist: true,
        serialize: (event) => event == null ? void 0 : event.id,
        isEqual: isSerializableEqual
      }
    }, ModelReferenceField)
  ], BaseDependencyMixin2.prototype, "fromEvent", void 0);
  __decorate19([
    generic_field({
      bucket: "incomingDeps",
      resolver: function(id) {
        return this.getEventById(id);
      },
      modelFieldConfig: {
        persist: true,
        serialize: (event) => event == null ? void 0 : event.id,
        isEqual: isSerializableEqual
      }
    }, ModelReferenceField)
  ], BaseDependencyMixin2.prototype, "toEvent", void 0);
  __decorate19([
    model_field({ type: "int", defaultValue: DependencyType.EndToStart })
  ], BaseDependencyMixin2.prototype, "type", void 0);
  __decorate19([
    model_field({ type: "string" })
  ], BaseDependencyMixin2.prototype, "fromSide", void 0);
  __decorate19([
    model_field({ type: "string" })
  ], BaseDependencyMixin2.prototype, "toSide", void 0);
  return BaseDependencyMixin2;
}) {
};

// ../Engine/lib/Engine/util/Queue.js
var Queue = class {
  constructor() {
    this.ongoing = Promise.resolve();
    this.handleReject = () => {
    };
  }
  queue(fn2, handleReject = this.handleReject) {
    const result = this.ongoing.then(fn2);
    this.ongoing = result.catch(handleReject);
    return result;
  }
};
Queue._$name = "Queue";

// ../Engine/lib/Engine/quark/model/scheduler_basic/SchedulerBasicProjectMixin.js
var __decorate20 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SchedulerBasicProjectMixin = class extends MixinAny([
  ChronoAbstractProjectMixin,
  BaseEventMixin,
  HasSubEventsMixin,
  HasCalendarMixin,
  DurationConverterMixin,
  CanCombineCalendarsMixin
], (base) => {
  const superProto = base.prototype;
  class SchedulerBasicProjectMixin2 extends base {
    construct(config = {}) {
      this.delayCalculation = config.delayCalculation !== false;
      this.enableProgressNotifications = config.enableProgressNotifications || config.delayCalculation !== false;
      this._queue = new Queue();
      if (!("expanded" in config)) {
        config.expanded = true;
      }
      if (this.delayCalculation) {
        this.delayEnteringReplica = true;
      }
      if (!("skipNonWorkingTimeWhenSchedulingManually" in config)) {
        config.skipNonWorkingTimeWhenSchedulingManually = false;
      }
      superProto.construct.call(this, config);
      this.repopulateStores = /* @__PURE__ */ new Set();
      this.ignoreInitialCommitComputationCycles = "ignoreInitialCommitComputationCycles" in config ? config.ignoreInitialCommitComputationCycles : false;
      if (this.ignoreInitialCommitComputationCycles) {
        console.warn('Project "ignoreInitialCommitComputationCycles" option is deprecated and will be dropped in the next major release');
      }
      if (!this.eventModelClass)
        this.eventModelClass = this.getDefaultEventModelClass();
      if (!this.eventStoreClass)
        this.eventStoreClass = this.getDefaultEventStoreClass();
      if (!this.dependencyModelClass)
        this.dependencyModelClass = this.getDefaultDependencyModelClass();
      if (!this.dependencyStoreClass)
        this.dependencyStoreClass = this.getDefaultDependencyStoreClass();
      if (!this.resourceModelClass)
        this.resourceModelClass = this.getDefaultResourceModelClass();
      if (!this.resourceStoreClass)
        this.resourceStoreClass = this.getDefaultResourceStoreClass();
      if (!this.assignmentModelClass)
        this.assignmentModelClass = this.getDefaultAssignmentModelClass();
      if (!this.assignmentStoreClass)
        this.assignmentStoreClass = this.getDefaultAssignmentStoreClass();
      if (!this.calendarModelClass)
        this.calendarModelClass = this.getDefaultCalendarModelClass();
      if (!this.calendarManagerStoreClass)
        this.calendarManagerStoreClass = this.getDefaultCalendarManagerStoreClass();
      if (!this.cycleEffectClass)
        this.cycleEffectClass = this.getDefaultCycleEffectClass();
      this.initializeStm();
      this.defaultCalendar = new this.calendarModelClass({
        unspecifiedTimeIsWorking: this.unspecifiedTimeIsWorking
      });
      this.defaultCalendar.project = this;
      if (!this.delayEnteringReplica)
        this.enterReplica(false);
      this.setCalendarManagerStore(this.calendarManagerStore);
      this.setEventStore(this.eventStore);
      this.setDependencyStore(this.dependencyStore);
      this.setResourceStore(this.resourceStore);
      this.setAssignmentStore(this.assignmentStore);
      const hasInlineData = Boolean(this.calendarsData || this.eventsData || this.dependenciesData || this.resourcesData || this.assignmentsData);
      if (hasInlineData) {
        this.loadInlineData({
          calendarsData: this.calendarsData,
          eventsData: this.eventsData,
          dependenciesData: this.dependenciesData,
          resourcesData: this.resourcesData,
          assignmentsData: this.assignmentsData
        });
        delete this.calendarsData;
        delete this.eventsData;
        delete this.dependenciesData;
        delete this.resourcesData;
        delete this.assignmentsData;
      } else {
        if (this.delayCalculation && this.hasDataInStores)
          this.scheduleDelayedCalculation();
      }
    }
    get hasDataInStores() {
      return [
        this.calendarManagerStore,
        this.eventStore,
        this.dependencyStore,
        this.resourceStore,
        this.assignmentStore
      ].some((store) => store.allCount > 0);
    }
    enterReplica(enterRecords) {
      const me = this;
      if (!me.replica) {
        me.replica = me.createReplica();
        me.replica.addEntity(me);
        me.replica.addEntity(me.defaultCalendar);
        me.trigger("graphReady");
      }
      if (enterRecords && !me.isRepopulatingStores) {
        me.calendarManagerStore.forEach((r) => {
          !r.graph && r.joinProject();
        }, void 0, { includeFilteredOutRecords: true });
        me.eventStore.forEach((r) => {
          !r.graph && r.joinProject();
        }, void 0, { includeFilteredOutRecords: true });
        me.resourceStore.forEach((r) => {
          !r.graph && r.joinProject();
        }, void 0, { includeFilteredOutRecords: true });
        me.dependencyStore.forEach((r) => {
          !r.graph && r.joinProject();
        }, void 0, { includeFilteredOutRecords: true });
        me.assignmentStore.forEach((r) => {
          !r.graph && r.joinProject();
        }, void 0, { includeFilteredOutRecords: true });
      }
    }
    resetStmQueue() {
      const wasDisabled = this.stm.disabled;
      this.stm.disable();
      this.stm.resetQueue();
      if (!wasDisabled) {
        this.stm.enable();
      }
    }
    doDestroy() {
      var _a2, _b, _c, _d, _e, _f, _g, _h;
      const me = this;
      (_a2 = me.eventStore) == null ? void 0 : _a2.destroy();
      (_b = me.dependencyStore) == null ? void 0 : _b.destroy();
      (_c = me.assignmentStore) == null ? void 0 : _c.destroy();
      (_d = me.resourceStore) == null ? void 0 : _d.destroy();
      (_e = me.calendarManagerStore) == null ? void 0 : _e.destroy();
      (_f = me.defaultCalendar) == null ? void 0 : _f.destroy();
      (_g = me.replica) == null ? void 0 : _g.clear();
      (_h = me.stm) == null ? void 0 : _h.destroy();
      superProto.doDestroy.call(this);
    }
    getReplicaConfig() {
      return {
        project: this,
        schema: Schema.new(),
        enableProgressNotifications: this.enableProgressNotifications,
        silenceInitialCommit: this.silenceInitialCommit,
        ignoreInitialCommitComputationCycles: this.ignoreInitialCommitComputationCycles,
        cycleEffectClass: this.cycleEffectClass,
        onWriteDuringCommit: "ignore",
        readMode: ReadMode.CurrentOrProposedOrPrevious
      };
    }
    // Creates a new Replica, used during construction and when repopulating
    createReplica() {
      return EngineReplica.mix(Replica).new(this.getReplicaConfig());
    }
    *hasSubEvents() {
      return this.getEventStore().count > 0;
    }
    *subEventsIterable() {
      return this.getEventStore().getRange();
    }
    getType() {
      return ProjectType.SchedulerBasic;
    }
    get enableProgressNotifications() {
      return this._enableProgressNotifications;
    }
    /**
     * Enables/disables the calculation progress notifications.
     */
    set enableProgressNotifications(value) {
      this._enableProgressNotifications = value;
      if (this.replica)
        this.replica.enableProgressNotifications = value;
    }
    getDefaultCycleEffectClass() {
      return CycleEffect;
    }
    /**
     * Returns the default event model class to use
     */
    getDefaultEventModelClass() {
      return SchedulerBasicEvent;
    }
    /**
     * Returns the default event store class to use
     */
    getDefaultEventStoreClass() {
      return ChronoEventStoreMixin;
    }
    /**
     * Returns the default dependency model class to use
     */
    getDefaultDependencyModelClass() {
      return BaseDependencyMixin;
    }
    /**
     * Returns the default dependency store class to use
     */
    getDefaultDependencyStoreClass() {
      return ChronoDependencyStoreMixin;
    }
    /**
     * Returns the default resource model class to use
     */
    getDefaultResourceModelClass() {
      return BaseResourceMixin;
    }
    /**
     * Returns the default resource store class to use
     */
    getDefaultResourceStoreClass() {
      return ChronoResourceStoreMixin;
    }
    /**
     * Returns the default assignment model class to use
     */
    getDefaultAssignmentModelClass() {
      return BaseAssignmentMixin;
    }
    /**
     * Returns the default assignment store class to use
     */
    getDefaultAssignmentStoreClass() {
      return ChronoAssignmentStoreMixin;
    }
    /**
     * Returns the default calendar model class to use
     */
    getDefaultCalendarModelClass() {
      return BaseCalendarMixin;
    }
    /**
     * Returns the default calendar manager store class to use
     */
    getDefaultCalendarManagerStoreClass() {
      return ChronoCalendarManagerStoreMixin;
    }
    usingSyncDataOnLoad() {
      return [this.eventStore, this.resourceStore, this.dependencyStore, this.assignmentStore].some((s) => s.syncDataOnLoad);
    }
    /**
     * This method loads the "raw" data into the project. The loading is basically happening by
     * assigning the individual data entries to the `data` property of the corresponding store.
     *
     * @param data
     */
    async loadInlineData(data) {
      const { calendarManagerStore, eventStore, dependencyStore, assignmentStore, resourceStore, replica } = this;
      if (!this.isInitialCommitPerformed) {
        replica == null ? void 0 : replica.unScheduleAutoCommit();
      } else {
        while (this.replica.isCommitting) {
          await this.commitAsync();
        }
      }
      if ((replica == null ? void 0 : replica.enableProgressNotifications) && !this.delayCalculation) {
        await delay(0);
        await this.commitAsync();
        replica.onPropagationProgressNotification({ total: 0, remaining: 0, phase: "storePopulation" });
        await delay(50);
      }
      this.isInitialCommitPerformed = false;
      this.isLoadingInlineData = true;
      if (globalThis.DEBUG) {
        console.log(`%cInitializing project`, "font-weight:bold;color:darkgreen;text-transform:uppercase;margin-top: 2em");
        console.time("Time to visible");
        console.time("Populating project");
      }
      if (this.delayCalculation && !this.delayedCalculationPromise && !this.usingSyncDataOnLoad()) {
        this.scheduleDelayedCalculation();
      }
      if (data.calendarsData) {
        this.repopulateStore(calendarManagerStore);
        calendarManagerStore.data = data.calendarsData;
      }
      if (data.eventsData || data.tasksData) {
        this.repopulateStore(eventStore);
        eventStore.data = data.eventsData || data.tasksData;
      }
      if (data.dependenciesData) {
        this.repopulateStore(dependencyStore);
        dependencyStore.data = data.dependenciesData;
      }
      if (data.resourcesData) {
        this.repopulateStore(resourceStore);
        resourceStore.data = data.resourcesData;
      }
      if (data.assignmentsData) {
        this.repopulateStore(assignmentStore);
        assignmentStore.data = data.assignmentsData;
      }
      if (data.project) {
        this.applyProjectResponse(data.project);
      }
      if (globalThis.DEBUG)
        console.timeEnd("Populating project");
      const result = await this.commitLoad();
      this.isLoadingInlineData = false;
      return result;
    }
    // Called from scheduleDelayedCalculation() & setAssignmentStore to set up indices used to look events and
    // resources up before calculations has finished
    setupTemporaryIndices() {
      const { storage } = this.assignmentStore || {};
      if (storage) {
        storage.addIndex({ property: "event", unique: false });
        storage.addIndex({ property: "resource", unique: false });
      }
    }
    removeTemporaryIndices() {
      const { storage } = this.assignmentStore;
      storage.removeIndex("event");
      storage.removeIndex("resource");
    }
    async internalDelayCalculation(resolve) {
      const me = this;
      me.delayEnteringReplica = true;
      me.setupTemporaryIndices();
      await delay(0);
      if (me.isDestroyed) {
        resolve();
        return;
      }
      me.trigger("delayCalculationStart");
      me.trigger("refresh", { isCalculated: false });
      await delay(0);
      if (me.isDestroyed) {
        resolve();
        return;
      }
      me.delayEnteringReplica = false;
      if (me.isRepopulatingStores) {
        me.repopulateReplica.now();
      } else {
        me.trigger("recordsUnlinked");
        me.enterReplica(true);
      }
      const result = await me.replica.commitAsync();
      if (me.isDestroyed) {
        resolve();
        return;
      }
      resolve(result);
      me.delayedCalculationPromise = null;
      me.trigger("delayCalculationEnd");
      me.removeTemporaryIndices();
    }
    // NOTE: NEVER AWAIT FOR THIS METHOD inside `queue` method call chain. Or it will create a chain of promises
    // which depends on itself and never resolves
    scheduleDelayedCalculation() {
      if (this.delayedCalculationPromise) {
        return this.delayedCalculationPromise;
      }
      if (this.delayCalculation !== false) {
        return this.delayedCalculationPromise = new Promise((resolve) => (
          // Cannot use async code directly in Promise executor, because it hides errors
          this.internalDelayCalculation(resolve).then()
        ));
      }
    }
    async commitLoad() {
      const result = await this.commitAsync();
      if (!this.isDestroyed)
        this.trigger("load");
      return result;
    }
    initializeStm() {
      const stmClass = this.stmClass || StateTrackingManager;
      if (!(this.stm instanceof StateTrackingManager))
        this.setStm(stmClass.new({ disabled: true }, this.stm));
      if (this.resetUndoRedoQueuesAfterLoad) {
        this.ion({
          load: this.resetStmQueue,
          thisObj: this
        });
      }
      this.ion({
        beforeCommit: this.onCommitInitialization,
        commitFinalized: this.onCommitFinalization,
        commitRejected: this.onCommitRejection,
        thisObj: this
      });
    }
    removeRejectedRecordsAdd({ transactionResult, silenceCommit }) {
      var _a2, _b, _c;
      const recordsToDrop = /* @__PURE__ */ new Map();
      for (const quark of transactionResult.entries.values()) {
        const identifier = quark.identifier;
        const { field: field2 } = identifier;
        if (quark.isShadow() || !identifier[IsChronoModelSymbol] || field2 instanceof ModelBucketField)
          continue;
        const record = identifier.self;
        const store = record.firstStore;
        if (store && !quark.previous && !((_a2 = transactionResult.transaction.getLatestStableEntryFor(record.$$)) == null ? void 0 : _a2.previous)) {
          if (!recordsToDrop.has(store)) {
            recordsToDrop.set(store, /* @__PURE__ */ new Set([record]));
          } else if (!recordsToDrop.get(store).has(record)) {
            recordsToDrop.get(store).add(record);
          }
        }
      }
      (_b = this.suspendChangesTracking) == null ? void 0 : _b.call(this);
      const stores = Array.from(recordsToDrop.keys()).sort((a, b) => a.removalOrder - b.removalOrder);
      stores.forEach((store) => store.remove(recordsToDrop.get(store)));
      (_c = this.resumeChangesTracking) == null ? void 0 : _c.call(this, silenceCommit);
      if (silenceCommit) {
        this.eventStore.acceptChanges();
        this.dependencyStore.acceptChanges();
        this.resourceStore.acceptChanges();
        this.assignmentStore.acceptChanges();
        this.calendarManagerStore.acceptChanges();
      }
    }
    onCommitRejection(event) {
      if (this._stmDisabled) {
        this.replica.isWritingPreviousData = true;
        this.isRestoringData = true;
        this.removeRejectedRecordsAdd(event);
        this.isRestoringData = false;
        this.replica.isWritingPreviousData = false;
      } else {
        this.rejectStmTransaction();
      }
    }
    // https://github.com/bryntum/support/issues/1270
    onCommitInitialization() {
      const { stm } = this;
      this._stmDisabled = stm.disabled;
      if (stm.isRecording && stm.autoRecord) {
        this._stmAutoRecord = true;
        stm.autoRecord = false;
      }
    }
    onCommitFinalization() {
      if (this._stmAutoRecord) {
        this.stm.autoRecord = true;
        this._stmAutoRecord = false;
      }
    }
    onSTMRestoringStart({ source: stm }) {
      if (this.replica)
        this.replica.isWritingPreviousData = true;
    }
    // Propagate on undo/redo
    async onSTMRestoringStop({ source }) {
      if (this.replica)
        this.replica.isWritingPreviousData = false;
      const stm = source;
      stm.disable();
      await this.commitAsync();
      if (!this.isDestroyed) {
        stm.enable();
        this.trigger("stateRestoringDone");
      }
    }
    //region Repopulate
    // defers the call to given function with given arguments until the `repopulateReplica` event
    // (if replica is scheduled for repopulation, otherwise calls immediately)
    // between the multiple defers with the same `deferId`, only the latest one is called
    deferUntilRepopulationIfNeeded(deferId, func, args) {
      if (this.isRepopulatingStores) {
        this.detachListeners(deferId);
        this.ion({
          name: deferId,
          repopulateReplica: {
            fn: async () => {
              await this.commitAsync();
              if (!this.isDestroyed) {
                func(...args);
              }
            },
            once: true
          }
        });
      } else {
        func(...args);
      }
    }
    get isRepopulatingStores() {
      var _a2;
      return Boolean((_a2 = this.repopulateStores) == null ? void 0 : _a2.size);
    }
    // Remember which stores are being repopulated, they don't have to care about un-joining the graph later
    repopulateStore(store) {
      var _a2;
      const me = this;
      if (me.repopulateOnDataset && store.allCount && !store.syncDataOnLoad) {
        (_a2 = me.replica) == null ? void 0 : _a2.activeTransaction.stop();
        if (!me.repopulateStores)
          me.repopulateStores = /* @__PURE__ */ new Set();
        me.repopulateStores.add(store);
        me.repopulateReplica();
      }
    }
    // Creates a new replica, populating it with data from the stores
    repopulateReplica() {
      const me = this;
      if (me.delayEnteringReplica) {
        return;
      }
      const { calendarManagerStore, eventStore, dependencyStore, assignmentStore, resourceStore, replica: oldReplica } = me;
      if (oldReplica) {
        me.unlinkStoreRecords(calendarManagerStore, eventStore, dependencyStore, resourceStore, assignmentStore);
        me.unlinkRecord(me);
        me.unlinkRecord(me.defaultCalendar);
        me.trigger("recordsUnlinked");
        oldReplica.clear();
      } else {
        me.trigger("recordsUnlinked");
      }
      const replica = me.replica = me.createReplica();
      replica.addEntity(me);
      replica.addEntity(me.defaultCalendar);
      me.joinStoreRecords(calendarManagerStore, true);
      me.joinStoreRecords(eventStore, true);
      me.joinStoreRecords(dependencyStore, true);
      me.joinStoreRecords(resourceStore, true);
      me.joinStoreRecords(assignmentStore, true);
      me.repopulateStores.clear();
      me.trigger("repopulateReplica");
    }
    // If there is a commit when we are supposed to replace the replica, we hijack that and commit the new replica
    beforeCommitAsync() {
      if (this.repopulateReplica.isPending && !this.isDelayingCalculation) {
        this.repopulateReplica.now();
        return this.replica.commitAsync();
      }
      return null;
    }
    // Unlinks a single record from the graph, writing back identifiers values from the graph to DATA to allow them
    // to enter another replica
    unlinkRecord(record) {
      var _a2;
      if (record == null ? void 0 : record.graph) {
        const { activeTransaction } = this.replica;
        const { $ } = record;
        const keys = Object.keys($);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const identifier = $[key];
          const entry = activeTransaction.getLatestEntryFor(identifier);
          if (entry) {
            let value = entry.getValue();
            if (value === void 0)
              value = entry.proposedValue;
            if (value !== void 0) {
              identifier.DATA = identifier.field instanceof ModelReferenceField ? (_a2 = value == null ? void 0 : value.id) != null ? _a2 : value : value;
            }
          }
        }
        record.graph = null;
      }
    }
    // Unlinks all records from a store, unless the store has been repopulated
    unlinkStoreRecords(...stores) {
      stores.forEach((store) => {
        if (!this.repopulateStores.has(store) || store.syncDataOnLoad) {
          store.traverse((record) => {
            this.unlinkRecord(record);
          }, false, false, {
            // Must pass includeFilteredOutRecords and includeCollapsedGroupRecords as true
            // so that we work on full, unfiltered dataset
            includeFilteredOutRecords: true,
            includeCollapsedGroupRecords: true
          });
        }
      });
    }
    //endregion
    getGraph() {
      return this.replica;
    }
    // keep this private
    async addEvents(events) {
      this.eventStore.add(events);
      return this.commitAsync();
    }
    // keep this private
    async addEvent(event) {
      this.eventStore.add(event);
      return this.commitAsync();
    }
    // keep this private
    includeEvent(event) {
      this.eventStore.add(event);
    }
    // keep this private
    async removeEvents(events) {
      this.eventStore.remove(events);
      return this.commitAsync();
    }
    // keep this private
    excludeEvent(event) {
      this.eventStore.remove(event);
    }
    // keep this private
    async removeEvent(event) {
      this.eventStore.remove(event);
      return this.commitAsync();
    }
    getStm() {
      return this.stm;
    }
    setStm(stm) {
      this.stm = stm;
      this.stm.ion({
        restoringStart: this.onSTMRestoringStart,
        restoringStop: this.onSTMRestoringStop,
        thisObj: this
      });
    }
    calculateProject() {
      return this;
    }
    *calculateEffectiveCalendar() {
      let calendar = yield this.$.calendar;
      if (calendar) {
        yield calendar.$.version;
      } else {
        calendar = this.defaultCalendar;
      }
      return calendar;
    }
    joinStoreRecords(store, skipRoot = false) {
      const fn2 = (record) => {
        record.setProject(this);
        record.joinProject();
      };
      if (store.rootNode) {
        store.rootNode.traverse(fn2, skipRoot, true);
      } else {
        store.forEach(fn2, null, {
          includeFilteredOutRecords: true,
          includeCollapsedGroupRecords: true
        });
      }
    }
    unjoinStoreRecords(store) {
      const fn2 = (record) => {
        record.leaveProject();
        record.setProject(this);
      };
      if (store.rootNode) {
        store.rootNode.traverse((node) => {
          if (node !== store.rootNode)
            fn2(node);
        }, false, true);
      } else {
        store.forEach(fn2, null, {
          includeFilteredOutRecords: true,
          includeCollapsedGroupRecords: true
        });
      }
    }
    /**
     * This method sets the event store instance for the project.
     * @param store
     */
    setEventStore(store) {
      const oldEventStore = this.eventStore;
      if (oldEventStore && this.stm.hasStore(oldEventStore)) {
        this.stm.removeStore(oldEventStore);
        this.unjoinStoreRecords(oldEventStore);
        this.detachStore(oldEventStore);
        const assignmentsForRemoval = oldEventStore.assignmentsForRemoval;
        assignmentsForRemoval.forEach((assignment) => {
          const oldEvent = assignment.event;
          if (oldEvent) {
            const newEvent = store.getById(oldEvent.id);
            if (newEvent) {
              assignment.event = newEvent;
              assignmentsForRemoval.delete(assignment);
            }
          }
        });
        oldEventStore.afterEventRemoval();
      }
      if (!store || !(store instanceof Store)) {
        const storeClass = (store == null ? void 0 : store.storeClass) || this.eventStoreClass;
        this.eventStore = new storeClass(ObjectHelper.assign({
          modelClass: this.eventModelClass,
          project: this,
          stm: this.stm
        }, store || {}));
      } else {
        this.eventStore = store;
        store.setProject(this);
        this.stm.addStore(store);
        if (store.tree && store.rootNode !== this) {
          this.appendChild(store.rootNode.children || []);
          store.rootNode = this;
        } else {
          this.joinStoreRecords(store);
        }
      }
      this.attachStore(this.eventStore);
      this.trigger("eventStoreChange", { store: this.eventStore });
    }
    /**
     * This method sets the dependency store instance for the project.
     * @param store
     */
    setDependencyStore(store) {
      const oldDependencyStore = this.dependencyStore;
      if (oldDependencyStore && this.stm.hasStore(oldDependencyStore)) {
        this.stm.removeStore(oldDependencyStore);
        this.detachStore(oldDependencyStore);
      }
      if (!store || !(store instanceof Store)) {
        const storeClass = (store == null ? void 0 : store.storeClass) || this.dependencyStoreClass;
        this.dependencyStore = new storeClass(ObjectHelper.assign({
          modelClass: this.dependencyModelClass,
          project: this,
          stm: this.stm
        }, store || {}));
      } else {
        this.dependencyStore = store;
        store.setProject(this);
        this.stm.addStore(store);
        this.joinStoreRecords(store);
      }
      this.attachStore(this.dependencyStore);
      this.trigger("dependencyStoreChange", { store: this.dependencyStore });
    }
    /**
     * This method sets the resource store instance for the project.
     * @param store
     */
    setResourceStore(store) {
      const oldResourceStore = this.resourceStore;
      if (oldResourceStore && this.stm.hasStore(oldResourceStore)) {
        this.stm.removeStore(oldResourceStore);
        this.unjoinStoreRecords(oldResourceStore);
        this.detachStore(oldResourceStore);
        const assignmentsForRemoval = oldResourceStore.assignmentsForRemoval;
        assignmentsForRemoval.forEach((assignment) => {
          const oldResource = assignment.resource;
          if (oldResource) {
            const newResource = store.getById(oldResource.id);
            if (newResource) {
              assignment.resource = newResource;
              assignmentsForRemoval.delete(assignment);
            }
          }
        });
        oldResourceStore.afterResourceRemoval();
      }
      if (!store || !(store instanceof Store)) {
        const storeClass = (store == null ? void 0 : store.storeClass) || this.resourceStoreClass;
        this.resourceStore = new storeClass(ObjectHelper.assign({
          modelClass: this.resourceModelClass,
          project: this,
          stm: this.stm
        }, store || {}));
      } else {
        this.resourceStore = store;
        store.setProject(this);
        this.stm.addStore(store);
        this.joinStoreRecords(store);
      }
      this.attachStore(this.resourceStore);
      this.trigger("resourceStoreChange", { store: this.resourceStore });
    }
    /**
     * This method sets the assignment store instance for the project.
     * @param store
     */
    setAssignmentStore(store) {
      const oldAssignmentStore = this.assignmentStore;
      if (oldAssignmentStore && this.stm.hasStore(oldAssignmentStore)) {
        this.stm.removeStore(oldAssignmentStore);
        this.unjoinStoreRecords(oldAssignmentStore);
        this.detachStore(oldAssignmentStore);
      }
      if (!store || !(store instanceof Store)) {
        const storeClass = (store == null ? void 0 : store.storeClass) || this.assignmentStoreClass;
        this.assignmentStore = new storeClass(ObjectHelper.assign({
          modelClass: this.assignmentModelClass,
          project: this,
          stm: this.stm
        }, store || {}));
      } else {
        this.assignmentStore = store;
        store.setProject(this);
        this.stm.addStore(store);
        this.joinStoreRecords(store);
      }
      this.isDelayingCalculation && this.setupTemporaryIndices();
      this.attachStore(this.assignmentStore);
      this.trigger("assignmentStoreChange", { store: this.assignmentStore });
    }
    /**
     * This method sets the calendar manager store instance for the project.
     * @param store
     */
    setCalendarManagerStore(store) {
      const oldCalendarManagerStore = this.calendarManagerStore;
      if (oldCalendarManagerStore && this.stm.hasStore(oldCalendarManagerStore)) {
        this.stm.removeStore(oldCalendarManagerStore);
        this.detachStore(oldCalendarManagerStore);
      }
      if (!store || !(store instanceof Store)) {
        const storeClass = (store == null ? void 0 : store.storeClass) || this.calendarManagerStoreClass;
        this.calendarManagerStore = new storeClass(ObjectHelper.assign({
          modelClass: this.calendarModelClass,
          project: this,
          stm: this.stm
        }, store || {}));
      } else {
        this.calendarManagerStore = store;
        if (store) {
          store.setProject(this);
          this.stm.addStore(store);
          this.joinStoreRecords(store);
        }
      }
      this.attachStore(this.calendarManagerStore);
      this.trigger("calendarManagerStoreChange", { store: this.calendarManagerStore });
    }
    // this does not account for possible scheduling conflicts
    async isValidDependency(...args) {
      return true;
    }
    rejectStmTransaction(stm) {
      stm = stm || this.stm;
      if (stm.transaction) {
        if (stm.transaction.length) {
          stm.forEachStore((s) => s.beginBatch());
          stm.rejectTransaction();
          stm.forEachStore((s) => s.endBatch());
        } else {
          stm.stopTransaction();
        }
      }
    }
    /**
     * Tries to calculate project with changes. If project does not calculate, changes are reverted.
     * @param changerFn
     * @internal
     * @on-queue
     */
    async tryPropagateWithChanges(changerFn) {
      const stm = this.stm, stmInitiallyDisabled = stm.disabled, stmInitiallyAutoRecord = stm.autoRecord;
      return this.queue(async () => {
        if (stmInitiallyDisabled) {
          stm.enable();
        } else {
          if (stmInitiallyAutoRecord) {
            stm.autoRecord = false;
          }
          if (stm.isRecording) {
            stm.stopTransaction();
          }
        }
        stm.startTransaction();
        changerFn();
        let result = true;
        try {
          const commitResult = await this.commitAsync();
          result = !commitResult.rejectedWith;
        } catch (e) {
          if (!/cycle/i.test(e))
            throw e;
          result = false;
        }
        if (result) {
          stm.stopTransaction();
          if (stmInitiallyDisabled) {
            stm.resetQueue();
          }
        } else {
          this.replica.reject();
          this.rejectStmTransaction(stm);
        }
        stm.disabled = stmInitiallyDisabled;
        stm.autoRecord = stmInitiallyAutoRecord;
        return result;
      });
    }
    /**
     * Use this method to organize project changes into transactions. Every queue call will create a sequential
     * promise which cannot be interrupted by other queued functions. You can use async functions and await for
     * any promises (including commitAsync) with one exception - you cannot await for other queued calls and any
     * other function/promise which awaits queued function. Otherwise, an unresolvable chain of promises may be
     * created.
     *
     * **NOTE**: Functions which call this method inside are marked with `on-queue` tag.
     *
     * Examples:
     * ```javascript
     * // Invalid queue call which hangs promise chain
     * project.queue(async () => {
     *     const event = project.getEventStore().getById(1);
     *     await project.queue(() => {
     *         event.duration = 2;
     *         return project.commitAsync();
     *     })
     * })
     *
     * // Valid queue call
     * project.queue(() => {
     *     const event = project.getEventStore().getById(1);
     *
     *     // Consequent queue call will be chained after the current function in the next microtask.
     *     project.queue(() => {
     *         event.duration = 2;
     *         return project.commitAsync();
     *     })
     *
     *     // Event duration is not yet changed - this condition is true
     *     if (event.duration !== 2) { }
     * })
     * ```
     *
     *
     * @param {Function} fn
     * @param {Function} handleReject
     * @internal
     * @on-queue
     */
    queue(fn2, handleReject) {
      const me = this;
      return me._queue.queue(function runQueueStep() {
        return fn2();
      }, handleReject);
    }
    isEngineReady() {
      const { replica } = this;
      return this.delayEnteringReplica || !this.isRepopulatingStores && (replica ? !(replica.dirty && (replica.hasPendingAutoCommit() || replica.isCommitting)) : true);
    }
    // Needed to separate configs from data, for tests to pass. Normally handled in ProjectModel outside of engine
    static get defaultConfig() {
      return {
        assignmentsData: null,
        calendarsData: null,
        dependenciesData: null,
        eventsData: null,
        resourcesData: null,
        // need to distinguish the stores from fields
        // https://bryntum.com/products/gantt/examples/advanced/
        // bryntum.gantt.ObjectHelper.isEqual({}, new bryntum.gantt.Store()) // true
        eventStore: null,
        resourceStore: null,
        assignmentStore: null,
        dependencyStore: null,
        calendarManagerStore: null,
        eventModelClass: null,
        resourceModelClass: null,
        assignmentModelClass: null,
        dependencyModelClass: null,
        calendarModelClass: null,
        repopulateOnDataset: true
      };
    }
    static get delayable() {
      return {
        repopulateReplica: 10
      };
    }
  }
  SchedulerBasicProjectMixin2.applyConfigs = true;
  __decorate20([
    model_field({ type: "boolean", defaultValue: true })
  ], SchedulerBasicProjectMixin2.prototype, "unspecifiedTimeIsWorking", void 0);
  __decorate20([
    model_field({ type: "boolean", defaultValue: false })
  ], SchedulerBasicProjectMixin2.prototype, "skipNonWorkingTimeWhenSchedulingManually", void 0);
  __decorate20([
    model_field({ type: "boolean", defaultValue: true })
  ], SchedulerBasicProjectMixin2.prototype, "skipNonWorkingTimeInDurationWhenSchedulingManually", void 0);
  __decorate20([
    model_field({ type: "string", defaultValue: Direction.Forward }, { sync: true })
  ], SchedulerBasicProjectMixin2.prototype, "direction", void 0);
  return SchedulerBasicProjectMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_pro/ConstrainedEarlyEventMixin.js
var __decorate21 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var calculateEffectiveStartDateConstraintInterval = function* (event, startDateIntervalIntersection, endDateIntervalIntersection, duration, collectIntersectionMeta) {
  if (endDateIntervalIntersection.isIntervalEmpty())
    return endDateIntervalIntersection;
  if (collectIntersectionMeta && endDateIntervalIntersection.intersectionOf) {
    const reflectedIntervals = /* @__PURE__ */ new Set();
    for (const interval of endDateIntervalIntersection.intersectionOf) {
      if (interval.isInfinite()) {
        reflectedIntervals.add(interval);
      } else {
        const startDate2 = interval.startDateIsFinite() ? yield* event.calculateProjectedXDateWithDuration(interval.startDate, false, duration) : interval.startDate;
        const endDate2 = interval.endDateIsFinite() ? yield* event.calculateProjectedXDateWithDuration(interval.endDate, false, duration) : interval.endDate;
        const originInterval = interval;
        reflectedIntervals.add(originInterval.copyWith({
          reflectionOf: originInterval,
          side: originInterval.side === ConstraintIntervalSide.Start ? ConstraintIntervalSide.End : ConstraintIntervalSide.Start,
          startDate: startDate2,
          endDate: endDate2
        }));
      }
    }
    endDateIntervalIntersection.intersectionOf = reflectedIntervals;
  }
  const startDate = endDateIntervalIntersection.startDateIsFinite() ? yield* event.calculateProjectedXDateWithDuration(endDateIntervalIntersection.startDate, false, duration) : null;
  const endDate = endDateIntervalIntersection.endDateIsFinite() ? yield* event.calculateProjectedXDateWithDuration(endDateIntervalIntersection.endDate, false, duration) : null;
  return intersectIntervals([
    startDateIntervalIntersection,
    ConstraintInterval.new({
      intersectionOf: endDateIntervalIntersection.intersectionOf,
      startDate,
      endDate
    })
  ], collectIntersectionMeta);
};
var calculateEffectiveEndDateConstraintInterval = function* (event, startDateIntervalIntersection, endDateIntervalIntersection, duration, collectIntersectionMeta) {
  if (startDateIntervalIntersection.isIntervalEmpty())
    return startDateIntervalIntersection;
  if (collectIntersectionMeta) {
    const reflectedIntervals = /* @__PURE__ */ new Set();
    for (const interval of startDateIntervalIntersection.intersectionOf) {
      if (interval.isInfinite()) {
        reflectedIntervals.add(interval);
      } else {
        const startDate2 = interval.startDateIsFinite() ? yield* event.calculateProjectedXDateWithDuration(interval.startDate, true, duration) : interval.startDate;
        const endDate2 = interval.endDateIsFinite() ? yield* event.calculateProjectedXDateWithDuration(interval.endDate, true, duration) : interval.endDate;
        const originInterval = interval;
        reflectedIntervals.add(originInterval.copyWith({
          reflectionOf: originInterval,
          side: originInterval.side === ConstraintIntervalSide.Start ? ConstraintIntervalSide.End : ConstraintIntervalSide.Start,
          startDate: startDate2,
          endDate: endDate2
        }));
      }
    }
    startDateIntervalIntersection.intersectionOf = reflectedIntervals;
  }
  const startDate = startDateIntervalIntersection.startDateIsFinite() ? yield* event.calculateProjectedXDateWithDuration(startDateIntervalIntersection.startDate, true, duration) : null;
  const endDate = startDateIntervalIntersection.endDateIsFinite() ? yield* event.calculateProjectedXDateWithDuration(startDateIntervalIntersection.endDate, true, duration) : null;
  return intersectIntervals([
    endDateIntervalIntersection,
    ConstraintInterval.new({
      reflectionOf: startDate || endDate ? startDateIntervalIntersection : void 0,
      intersectionOf: startDate || endDate ? startDateIntervalIntersection.intersectionOf : void 0,
      startDate,
      endDate
    })
  ], collectIntersectionMeta);
};
var EarlyLateLazyness = true;
var ConstrainedEarlyEventMixin = class extends Mixin([HasSubEventsMixin], (base) => {
  const superProto = base.prototype;
  class ConstrainedEarlyEventMixin2 extends base {
    // Skips non-working time if it's needed to the event
    *maybeSkipNonWorkingTime(date, isForward = true) {
      if (yield* this.hasSubEvents())
        return date;
      let duration = yield* this.calculateEffectiveDuration();
      return date && duration > 0 ? yield* this.skipNonWorkingTime(date, isForward) : date;
    }
    *calculateEffectiveConstraintInterval(isStartDate, startDateConstraintIntervals, endDateConstraintIntervals, collectIntersectionMeta = false) {
      const effectiveDurationToUse = yield* this.calculateEffectiveDuration();
      if (effectiveDurationToUse == null) {
        return null;
      }
      const calculateIntervalFn = isStartDate ? calculateEffectiveStartDateConstraintInterval : calculateEffectiveEndDateConstraintInterval;
      const effectiveInterval = yield* calculateIntervalFn(this, intersectIntervals(startDateConstraintIntervals, collectIntersectionMeta), intersectIntervals(endDateConstraintIntervals, collectIntersectionMeta), effectiveDurationToUse, collectIntersectionMeta);
      return effectiveInterval;
    }
    /**
     * Calculation method for the [[startDateConstraintIntervals]]. Returns empty array by default.
     * Override this method to return some extra constraints for the start date.
     */
    *calculateStartDateConstraintIntervals() {
      return [];
    }
    /**
     * Calculation method for the [[endDateConstraintIntervals]]. Returns empty array by default.
     * Override this method to return some extra constraints for the end date.
     */
    *calculateEndDateConstraintIntervals() {
      return [];
    }
    /**
     * Calculation method for the [[earlyStartDateConstraintIntervals]]. Returns empty array by default.
     * Override this method to return some extra constraints for the start date during the ASAP scheduling.
     */
    *calculateEarlyStartDateConstraintIntervals() {
      return [];
    }
    /**
     * Calculation method for the [[earlyEndDateConstraintIntervals]]. Returns empty array by default.
     * Override this method to return some extra constraints for the end date during the ASAP scheduling.
     */
    *calculateEarlyEndDateConstraintIntervals() {
      return [];
    }
    *doCalculateEarlyEffectiveStartDateInterval(collectIntersectionMeta = false) {
      const startDateConstraintIntervals = yield this.$.earlyStartDateConstraintIntervals;
      const endDateConstraintIntervals = yield this.$.earlyEndDateConstraintIntervals;
      return yield* this.calculateEffectiveConstraintInterval(
        true,
        // need to use concat instead of directly mutating the `startDateConstraintIntervals` since that is
        // used as storage for `this.$.earlyStartDateConstraintIntervals`
        startDateConstraintIntervals.concat(yield this.$.startDateConstraintIntervals),
        endDateConstraintIntervals.concat(yield this.$.endDateConstraintIntervals),
        collectIntersectionMeta
      );
    }
    *calculateEarlyEffectiveStartDateInterval() {
      return yield* this.doCalculateEarlyEffectiveStartDateInterval();
    }
    *doCalculateEarlyEffectiveEndDateInterval(collectIntersectionMeta = false) {
      const startDateConstraintIntervals = yield this.$.earlyStartDateConstraintIntervals;
      const endDateConstraintIntervals = yield this.$.earlyEndDateConstraintIntervals;
      return yield* this.calculateEffectiveConstraintInterval(
        false,
        // need to use concat instead of directly mutating the `startDateConstraintIntervals` since that is
        // used as storage for `this.$.earlyStartDateConstraintIntervals`
        startDateConstraintIntervals.concat(yield this.$.startDateConstraintIntervals),
        endDateConstraintIntervals.concat(yield this.$.endDateConstraintIntervals),
        collectIntersectionMeta
      );
    }
    *calculateEarlyEffectiveEndDateInterval() {
      return yield* this.doCalculateEarlyEffectiveEndDateInterval();
    }
    /**
     * The method defines whether the provided child event should be
     * taken into account when calculating this summary event [[earlyStartDate]].
     * Child events roll up their [[earlyStartDate]] values to their summary tasks.
     * So a summary task [[earlyStartDate]] date gets equal to its minimal child [[earlyStartDate]].
     *
     * If the method returns `true` the child event is taken into account
     * and if the method returns `false` it's not.
     * By default, the method returns `true` to include all child events data.
     * @param child Child event to consider.
     * @returns `true` if the provided event should be taken into account, `false` if not.
     */
    *shouldRollupChildEarlyStartDate(child) {
      return true;
    }
    *calculateMinChildrenEarlyStartDate() {
      let result = MAX_DATE;
      const subEventsIterator = yield* this.subEventsIterable();
      for (let childEvent of subEventsIterator) {
        let childDate;
        if (!(yield* this.shouldRollupChildEarlyStartDate(childEvent)))
          continue;
        if ((yield childEvent.$.manuallyScheduled) && (yield* childEvent.hasSubEvents())) {
          childDate = yield childEvent.$.minChildrenEarlyStartDate;
        }
        childDate = childDate || (yield childEvent.$.earlyStartDate);
        if (childDate && childDate < result)
          result = childDate;
      }
      return result.getTime() - MAX_DATE.getTime() ? result : null;
    }
    /**
     * The method defines whether the provided child event should be
     * taken into account when calculating this summary event [[earlyEndDate]].
     * Child events roll up their [[earlyEndDate]] values to their summary tasks.
     * So a summary task [[earlyEndDate]] gets equal to its maximal child [[earlyEndDate]].
     *
     * If the method returns `true` the child event is taken into account
     * and if the method returns `false` it's not.
     * By default, the method returns `true` to include all child events data.
     * @param child Child event to consider.
     * @returns `true` if the provided event should be taken into account, `false` if not.
     */
    *shouldRollupChildEarlyEndDate(child) {
      return true;
    }
    *calculateMaxChildrenEarlyEndDate() {
      let result = MIN_DATE;
      const subEventsIterator = yield* this.subEventsIterable();
      for (let childEvent of subEventsIterator) {
        let childDate;
        if (!(yield* this.shouldRollupChildEarlyEndDate(childEvent)))
          continue;
        if ((yield childEvent.$.manuallyScheduled) && (yield* childEvent.hasSubEvents())) {
          childDate = yield childEvent.$.maxChildrenEarlyEndDate;
        }
        childDate = childDate || (yield childEvent.$.earlyEndDate);
        if (childDate && childDate > result)
          result = childDate;
      }
      return result.getTime() - MIN_DATE.getTime() ? result : null;
    }
    *calculateEarlyStartDateRaw() {
      if ((yield this.$.manuallyScheduled) && (yield this.$.effectiveDirection).direction === Direction.Forward) {
        return yield this.$.startDate;
      }
      if (yield* this.hasSubEvents()) {
        return yield this.$.minChildrenEarlyStartDate;
      }
      if (!(yield* this.isConstrainedEarly())) {
        return yield this.$.startDate;
      }
      let effectiveInterval = yield this.$.earlyEffectiveStartDateInterval;
      if (effectiveInterval === null) {
        return null;
      } else if (effectiveInterval.isIntervalEmpty()) {
        effectiveInterval = yield* this.doCalculateEarlyEffectiveStartDateInterval(true);
        const conflict = ConflictEffect.new({
          intervals: [...effectiveInterval.intersectionOf]
        });
        if ((yield conflict) === EffectResolutionResult.Cancel) {
          yield Reject(conflict);
        } else {
          return null;
        }
      }
      return isDateFinite(effectiveInterval.startDate) ? effectiveInterval.startDate : null;
    }
    *calculateEarlyStartDate() {
      const date = yield this.$.earlyStartDateRaw;
      return yield* this.maybeSkipNonWorkingTime(date, true);
    }
    *calculateEarlyEndDateRaw() {
      if ((yield this.$.manuallyScheduled) && (yield this.$.effectiveDirection).direction === Direction.Forward) {
        return yield this.$.endDate;
      }
      if (yield* this.hasSubEvents()) {
        return yield this.$.maxChildrenEarlyEndDate;
      }
      if (!(yield* this.isConstrainedEarly())) {
        return yield this.$.endDate;
      }
      let effectiveInterval = yield this.$.earlyEffectiveEndDateInterval;
      if (effectiveInterval === null) {
        return null;
      } else if (effectiveInterval.isIntervalEmpty()) {
        effectiveInterval = yield* this.doCalculateEarlyEffectiveEndDateInterval(true);
        const conflict = ConflictEffect.new({
          intervals: [...effectiveInterval.intersectionOf]
        });
        if ((yield conflict) === EffectResolutionResult.Cancel) {
          yield Reject(conflict);
        } else {
          return null;
        }
      }
      return isDateFinite(effectiveInterval.startDate) ? effectiveInterval.startDate : null;
    }
    *calculateEarlyEndDate() {
      return yield this.$.earlyEndDateRaw;
    }
    *isConstrainedEarly() {
      const startDateIntervals = yield this.$.startDateConstraintIntervals;
      const endDateIntervals = yield this.$.endDateConstraintIntervals;
      const earlyStartDateConstraintIntervals = yield this.$.earlyStartDateConstraintIntervals;
      const earlyEndDateConstraintIntervals = yield this.$.earlyEndDateConstraintIntervals;
      return Boolean((startDateIntervals == null ? void 0 : startDateIntervals.length) || (endDateIntervals == null ? void 0 : endDateIntervals.length) || (earlyStartDateConstraintIntervals == null ? void 0 : earlyStartDateConstraintIntervals.length) || (earlyEndDateConstraintIntervals == null ? void 0 : earlyEndDateConstraintIntervals.length));
    }
    *calculateStartDatePure() {
      const direction = yield this.$.effectiveDirection;
      if (direction.direction === Direction.Forward) {
        if (!(yield* this.isConstrainedEarly()) || (yield this.$.manuallyScheduled) || (yield this.$.unscheduled)) {
          return yield* superProto.calculateStartDatePure.call(this);
        }
        if (yield* this.hasSubEvents()) {
          return yield* this.calculateMinChildrenStartDate();
        } else
          return (yield this.$.earlyStartDate) || (yield* superProto.calculateStartDatePure.call(this));
      } else {
        return yield* superProto.calculateStartDatePure.call(this);
      }
    }
    *calculateStartDateProposed() {
      const direction = yield this.$.effectiveDirection;
      switch (direction.direction) {
        case Direction.Forward:
          if (!(yield* this.isConstrainedEarly()) || (yield this.$.manuallyScheduled) || (yield this.$.unscheduled)) {
            return yield* superProto.calculateStartDateProposed.call(this);
          }
          if (yield* this.hasSubEvents()) {
            return yield* this.calculateMinChildrenStartDate();
          }
          const autoStartDate = yield this.$.earlyStartDate;
          if (autoStartDate) {
            if (isDateFinite(autoStartDate))
              return autoStartDate;
            const baseSchedulingStartDate = yield* superProto.calculateStartDateProposed.call(this);
            const earlyEffectiveStartDateInterval = yield this.$.earlyEffectiveStartDateInterval;
            if (earlyEffectiveStartDateInterval.containsDate(baseSchedulingStartDate))
              return baseSchedulingStartDate;
            return isDateFinite(earlyEffectiveStartDateInterval.endDate) ? earlyEffectiveStartDateInterval.endDate : baseSchedulingStartDate;
          } else {
            return yield* superProto.calculateStartDateProposed.call(this);
          }
        default:
          return yield* superProto.calculateStartDateProposed.call(this);
      }
    }
    *calculateEndDatePure() {
      const direction = yield this.$.effectiveDirection;
      if (direction.direction === Direction.Forward) {
        if (!(yield* this.isConstrainedEarly()) || (yield this.$.manuallyScheduled) || (yield this.$.unscheduled)) {
          return yield* superProto.calculateEndDatePure.call(this);
        }
        if (yield* this.hasSubEvents()) {
          return yield* this.calculateMaxChildrenEndDate();
        } else
          return (yield this.$.earlyEndDate) || (yield* superProto.calculateEndDatePure.call(this));
      } else {
        return yield* superProto.calculateEndDatePure.call(this);
      }
    }
    *calculateEndDateProposed() {
      const direction = yield this.$.effectiveDirection;
      switch (direction.direction) {
        case Direction.Forward:
          if (!(yield* this.isConstrainedEarly()) || (yield this.$.manuallyScheduled) || (yield this.$.unscheduled)) {
            return yield* superProto.calculateEndDateProposed.call(this);
          }
          if (yield* this.hasSubEvents()) {
            return yield* this.calculateMaxChildrenEndDate();
          }
          const autoEndDate = yield this.$.earlyEndDate;
          if (autoEndDate) {
            if (isDateFinite(autoEndDate))
              return autoEndDate;
            const baseSchedulingEndDate = yield* superProto.calculateEndDateProposed.call(this);
            const earlyEffectiveEndDateInterval = yield this.$.earlyEffectiveEndDateInterval;
            if (earlyEffectiveEndDateInterval.containsDate(baseSchedulingEndDate))
              return baseSchedulingEndDate;
            return isDateFinite(earlyEffectiveEndDateInterval.endDate) ? earlyEffectiveEndDateInterval.endDate : baseSchedulingEndDate;
          } else {
            return yield* superProto.calculateEndDateProposed.call(this);
          }
        default:
          return yield* superProto.calculateEndDateProposed.call(this);
      }
    }
  }
  __decorate21([
    field({ lazy: EarlyLateLazyness })
  ], ConstrainedEarlyEventMixin2.prototype, "minChildrenEarlyStartDate", void 0);
  __decorate21([
    field({ lazy: EarlyLateLazyness })
  ], ConstrainedEarlyEventMixin2.prototype, "earlyStartDateRaw", void 0);
  __decorate21([
    model_field({ type: "date", persist: false }, { lazy: EarlyLateLazyness, converter: dateConverter, persistent: false })
  ], ConstrainedEarlyEventMixin2.prototype, "earlyStartDate", void 0);
  __decorate21([
    field({ lazy: EarlyLateLazyness })
  ], ConstrainedEarlyEventMixin2.prototype, "maxChildrenEarlyEndDate", void 0);
  __decorate21([
    field({ lazy: EarlyLateLazyness })
  ], ConstrainedEarlyEventMixin2.prototype, "earlyEndDateRaw", void 0);
  __decorate21([
    model_field({ type: "date", persist: false }, { lazy: EarlyLateLazyness, converter: dateConverter, persistent: false })
  ], ConstrainedEarlyEventMixin2.prototype, "earlyEndDate", void 0);
  __decorate21([
    field()
  ], ConstrainedEarlyEventMixin2.prototype, "startDateConstraintIntervals", void 0);
  __decorate21([
    field()
  ], ConstrainedEarlyEventMixin2.prototype, "endDateConstraintIntervals", void 0);
  __decorate21([
    field({ lazy: EarlyLateLazyness })
  ], ConstrainedEarlyEventMixin2.prototype, "earlyStartDateConstraintIntervals", void 0);
  __decorate21([
    field({ lazy: EarlyLateLazyness })
  ], ConstrainedEarlyEventMixin2.prototype, "earlyEndDateConstraintIntervals", void 0);
  __decorate21([
    field()
  ], ConstrainedEarlyEventMixin2.prototype, "earlyEffectiveStartDateInterval", void 0);
  __decorate21([
    field()
  ], ConstrainedEarlyEventMixin2.prototype, "earlyEffectiveEndDateInterval", void 0);
  __decorate21([
    calculate("startDateConstraintIntervals")
  ], ConstrainedEarlyEventMixin2.prototype, "calculateStartDateConstraintIntervals", null);
  __decorate21([
    calculate("endDateConstraintIntervals")
  ], ConstrainedEarlyEventMixin2.prototype, "calculateEndDateConstraintIntervals", null);
  __decorate21([
    calculate("earlyStartDateConstraintIntervals")
  ], ConstrainedEarlyEventMixin2.prototype, "calculateEarlyStartDateConstraintIntervals", null);
  __decorate21([
    calculate("earlyEndDateConstraintIntervals")
  ], ConstrainedEarlyEventMixin2.prototype, "calculateEarlyEndDateConstraintIntervals", null);
  __decorate21([
    calculate("earlyEffectiveStartDateInterval")
  ], ConstrainedEarlyEventMixin2.prototype, "calculateEarlyEffectiveStartDateInterval", null);
  __decorate21([
    calculate("earlyEffectiveEndDateInterval")
  ], ConstrainedEarlyEventMixin2.prototype, "calculateEarlyEffectiveEndDateInterval", null);
  __decorate21([
    calculate("minChildrenEarlyStartDate")
  ], ConstrainedEarlyEventMixin2.prototype, "calculateMinChildrenEarlyStartDate", null);
  __decorate21([
    calculate("maxChildrenEarlyEndDate")
  ], ConstrainedEarlyEventMixin2.prototype, "calculateMaxChildrenEarlyEndDate", null);
  __decorate21([
    calculate("earlyStartDateRaw")
  ], ConstrainedEarlyEventMixin2.prototype, "calculateEarlyStartDateRaw", null);
  __decorate21([
    calculate("earlyStartDate")
  ], ConstrainedEarlyEventMixin2.prototype, "calculateEarlyStartDate", null);
  __decorate21([
    calculate("earlyEndDateRaw")
  ], ConstrainedEarlyEventMixin2.prototype, "calculateEarlyEndDateRaw", null);
  __decorate21([
    calculate("earlyEndDate")
  ], ConstrainedEarlyEventMixin2.prototype, "calculateEarlyEndDate", null);
  return ConstrainedEarlyEventMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_pro/HasDateConstraintMixin.js
var __decorate22 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HasDateConstraintMixin = class extends Mixin([ConstrainedEarlyEventMixin, HasChildrenMixin], (base) => {
  const superProto = base.prototype;
  class HasDateConstraint extends base {
    constructor() {
      super(...arguments);
      this.ignorePinningConstraint = false;
    }
    writeStartDate(me, transaction, quark, date, keepDuration = true) {
      const project = this.getProject();
      if ((project == null ? void 0 : project.addConstraintOnDateSet) && transaction.graph.hasIdentifier(this.$.effectiveDirection) && !(project == null ? void 0 : project.eventStore.isSyncingDataOnLoad) && !this.isReverting && !(project == null ? void 0 : project.getStm().isRestoring)) {
        const constrainType = this.getStartDatePinConstraintType();
        if (constrainType) {
          this.constraintDate = date;
          this.constraintType = constrainType;
        }
      }
      return superProto.writeStartDate.call(this, me, transaction, quark, date, keepDuration);
    }
    writeEndDate(me, transaction, quark, date, keepDuration = false) {
      const project = this.getProject();
      if ((project == null ? void 0 : project.addConstraintOnDateSet) && transaction.graph.hasIdentifier(this.$.direction) && keepDuration && !(project == null ? void 0 : project.eventStore.isSyncingDataOnLoad) && !(project == null ? void 0 : project.getStm().isRestoring)) {
        const constrainType = this.getEndDatePinConstraintType();
        if (constrainType) {
          this.constraintDate = date;
          this.constraintType = constrainType;
        }
      }
      return superProto.writeEndDate.call(this, me, transaction, quark, date, keepDuration);
    }
    writeConstraintType(me, transaction, quark, constraintType, fromWriteDirection = false) {
      const project = this.getProject();
      if (!fromWriteDirection && !me.isWritingUndefined && project.includeAsapAlapAsConstraints) {
        if (constraintType !== ConstraintType.AsSoonAsPossible && constraintType !== ConstraintType.AsLateAsPossible) {
          if (transaction.baseRevision.hasIdentifier(me)) {
            this.$.direction.write.call(this, this.$.direction, transaction, void 0, null, true);
          }
        } else {
          this.$.direction.write.call(this, this.$.direction, transaction, void 0, constraintType === ConstraintType.AsSoonAsPossible ? Direction.Forward : Direction.Backward, true);
          this.$.constraintDate.write.call(this, this.$.constraintDate, transaction, void 0, null);
        }
      }
      me.constructor.prototype.write.call(this, me, transaction, quark, constraintType);
    }
    writeDirection(me, transaction, quark, direction, fromWriteConstraintType = false) {
      const project = this.getProject();
      if (!fromWriteConstraintType && // not undefined value is provided
      !me.isWritingUndefined && project.includeAsapAlapAsConstraints && // not null is provided ..or null but it's not the initial write so must be caused by explicit event.direction=null
      (direction || transaction.baseRevision.hasIdentifier(me))) {
        this.$.constraintType.write.call(this, this.$.constraintType, transaction, void 0, direction === Direction.Forward ? ConstraintType.AsSoonAsPossible : direction === Direction.Backward ? ConstraintType.AsLateAsPossible : null, true);
      }
      me.constructor.prototype.write.call(this, me, transaction, quark, direction);
    }
    *calculateConstraintType() {
      let constraintType = yield ProposedOrPrevious;
      if (!(yield* this.isConstraintTypeApplicable(constraintType))) {
        constraintType = null;
      }
      return constraintType;
    }
    *calculateConstraintDate(Y) {
      let constraintDate = yield ProposedOrPrevious;
      const constraintType = yield this.$.constraintType;
      if (!constraintType) {
        constraintDate = null;
      } else if (!constraintDate) {
        constraintDate = this.getConstraintTypeDefaultDate(Y, constraintType);
      }
      return constraintDate;
    }
    getStartDatePinConstraintType() {
      const { effectiveDirection: direction } = this.project;
      if (!this.isTaskPinnableWithConstraint())
        return null;
      switch (direction.direction) {
        case Direction.Forward:
          return ConstraintType.StartNoEarlierThan;
        case Direction.Backward:
          return ConstraintType.StartNoLaterThan;
      }
    }
    getEndDatePinConstraintType() {
      const { effectiveDirection: direction } = this.project;
      if (!this.isTaskPinnableWithConstraint())
        return null;
      switch (direction.direction) {
        case Direction.Forward:
          return ConstraintType.FinishNoEarlierThan;
        case Direction.Backward:
          return ConstraintType.FinishNoLaterThan;
      }
    }
    /**
     * Indicates if the task can be pinned with a constraint
     * to enforce its start/end date changes.
     * @private
     */
    isTaskPinnableWithConstraint() {
      const { manuallyScheduled, ignorePinningConstraint, constraintType } = this;
      let result = false;
      if (!manuallyScheduled && !ignorePinningConstraint) {
        if (constraintType) {
          switch (constraintType) {
            case ConstraintType.AsSoonAsPossible:
            case ConstraintType.AsLateAsPossible:
            case ConstraintType.StartNoEarlierThan:
            case ConstraintType.StartNoLaterThan:
            case ConstraintType.FinishNoEarlierThan:
            case ConstraintType.FinishNoLaterThan:
              result = true;
          }
        } else {
          result = true;
        }
      }
      return result;
    }
    applyChangeset(rawChanges, phantomIdField, remote) {
      this.ignorePinningConstraint = remote;
      const result = super.applyChangeset(rawChanges, phantomIdField, remote);
      this.ignorePinningConstraint = false;
      return result;
    }
    /**
     * Returns default constraint date value for the constraint type provided
     * (either start or end date of the event).
     */
    getConstraintTypeDefaultDate(Y, constraintType) {
      switch (constraintType) {
        case ConstraintType.StartNoEarlierThan:
        case ConstraintType.StartNoLaterThan:
        case ConstraintType.MustStartOn:
          return Y(ProposedOrPreviousValueOf(this.$.startDate));
        case ConstraintType.FinishNoEarlierThan:
        case ConstraintType.FinishNoLaterThan:
        case ConstraintType.MustFinishOn:
          return Y(ProposedOrPreviousValueOf(this.$.endDate));
      }
      return null;
    }
    /**
     * Returns true if the provided constraint type is applicable to the event.
     *
     * @param {ConstraintType} constraintType Constraint type.
     * @returns `True` if the provided constraint type is applicable (`false` otherwise).
     */
    *isConstraintTypeApplicable(constraintType) {
      const hasSubEvents = yield* this.hasSubEvents();
      switch (constraintType) {
        case ConstraintType.FinishNoEarlierThan:
        case ConstraintType.StartNoLaterThan:
        case ConstraintType.MustFinishOn:
        case ConstraintType.MustStartOn:
          return !hasSubEvents;
      }
      return true;
    }
    /**
     * Sets the constraint type (if applicable) and constraining date to the task.
     * @param {ConstraintType}  constraintType   Constraint type.
     * @param {Date}            [constraintDate] Constraint date.
     * @returns Promise<PropagateResult>
     */
    async setConstraint(constraintType, constraintDate) {
      this.constraintType = constraintType;
      if (constraintDate !== void 0) {
        this.constraintDate = constraintDate;
      }
      return this.commitAsync();
    }
    *calculateEndDateConstraintIntervals() {
      const intervals = yield* superProto.calculateEndDateConstraintIntervals.call(this);
      const manuallyScheduled = yield this.$.manuallyScheduled;
      const constraintType = yield this.$.constraintType;
      const constraintDate = yield this.$.constraintDate;
      const dateConstraintIntervalClass = this.project.dateConstraintIntervalClass;
      if (!manuallyScheduled && constraintType && constraintDate) {
        switch (constraintType) {
          case ConstraintType.MustFinishOn:
            intervals.unshift(dateConstraintIntervalClass.new({
              owner: this,
              side: ConstraintIntervalSide.End,
              startDate: constraintDate,
              endDate: constraintDate
            }));
            break;
          case ConstraintType.FinishNoEarlierThan:
            intervals.unshift(dateConstraintIntervalClass.new({
              owner: this,
              side: ConstraintIntervalSide.End,
              startDate: constraintDate
            }));
            break;
          case ConstraintType.FinishNoLaterThan:
            intervals.unshift(dateConstraintIntervalClass.new({
              owner: this,
              side: ConstraintIntervalSide.End,
              endDate: constraintDate
            }));
            break;
        }
      }
      return intervals;
    }
    *calculateStartDateConstraintIntervals() {
      const intervals = yield* superProto.calculateStartDateConstraintIntervals.call(this);
      const manuallyScheduled = yield this.$.manuallyScheduled;
      const constraintType = yield this.$.constraintType;
      const constraintDate = yield this.$.constraintDate;
      const dateConstraintIntervalClass = this.project.dateConstraintIntervalClass;
      if (!manuallyScheduled && constraintType && constraintDate) {
        switch (constraintType) {
          case ConstraintType.MustStartOn:
            intervals.unshift(dateConstraintIntervalClass.new({
              owner: this,
              side: ConstraintIntervalSide.Start,
              startDate: constraintDate,
              endDate: constraintDate
            }));
            break;
          case ConstraintType.StartNoEarlierThan:
            intervals.unshift(dateConstraintIntervalClass.new({
              owner: this,
              side: ConstraintIntervalSide.Start,
              startDate: constraintDate
            }));
            break;
          case ConstraintType.StartNoLaterThan:
            intervals.unshift(dateConstraintIntervalClass.new({
              owner: this,
              side: ConstraintIntervalSide.Start,
              endDate: constraintDate
            }));
            break;
        }
      }
      return intervals;
    }
  }
  __decorate22([
    model_field({ type: "string" }, { sync: true })
  ], HasDateConstraint.prototype, "constraintType", void 0);
  __decorate22([
    model_field({ type: "date" }, { converter: dateConverter, sync: true })
  ], HasDateConstraint.prototype, "constraintDate", void 0);
  __decorate22([
    write("constraintType")
  ], HasDateConstraint.prototype, "writeConstraintType", null);
  __decorate22([
    write("direction")
  ], HasDateConstraint.prototype, "writeDirection", null);
  __decorate22([
    calculate("constraintType")
  ], HasDateConstraint.prototype, "calculateConstraintType", null);
  __decorate22([
    calculate("constraintDate")
  ], HasDateConstraint.prototype, "calculateConstraintDate", null);
  return HasDateConstraint;
}) {
};
var RemoveDateConstraintConflictResolution = class extends Localizable_default(ConflictResolution) {
  static get $name() {
    return "RemoveDateConstraintConflictResolution";
  }
  construct() {
    super.construct(...arguments);
    this.event = this.interval.owner;
  }
  getDescription() {
    const { event } = this;
    return format(this.L("L{descriptionTpl}"), event.name || event.id, this.interval.getConstraintName(event.constraintType));
  }
  /**
   * Resolves the conflict by removing the event constraint.
   */
  resolve() {
    this.event.constraintType = null;
  }
};
var DateConstraintIntervalDescription = class extends ConstraintIntervalDescription {
  static get $name() {
    return "DateConstraintIntervalDescription";
  }
  /**
   * Returns description for the provided event constraint interval.
   * @param interval Constraint interval
   */
  static getDescription(interval) {
    let tpl;
    switch (interval.owner.constraintType) {
      case ConstraintType.StartNoEarlierThan:
      case ConstraintType.FinishNoEarlierThan:
      case ConstraintType.MustStartOn:
      case ConstraintType.MustFinishOn:
        tpl = this.L("L{startDateDescriptionTpl}");
        break;
      case ConstraintType.StartNoLaterThan:
      case ConstraintType.FinishNoLaterThan:
        tpl = this.L("L{endDateDescriptionTpl}");
        break;
    }
    return format(tpl, ...this.getDescriptionParameters(interval));
  }
  /**
   * Returns localized constraint name.
   * @param constraintType Type of constraint
   */
  static getConstraintName(constraintType) {
    return this.L("L{constraintTypeTpl}")[constraintType];
  }
  static getDescriptionParameters(interval) {
    const event = interval.owner;
    return [
      DateHelper.format(interval.startDate, this.L("L{dateFormat}")),
      DateHelper.format(interval.endDate, this.L("L{dateFormat}")),
      event.name || event.id,
      this.getConstraintName(event.constraintType)
    ];
  }
};
var DateConstraintInterval = class extends ConstraintInterval {
  getConstraintName(constraintType) {
    return this.descriptionBuilderClass.getConstraintName(constraintType || this.owner.constraintType);
  }
  getDescription() {
    return this.descriptionBuilderClass.getDescription(this);
  }
  isAffectedByTransaction(transaction) {
    const event = this.owner;
    transaction = transaction || event.graph.activeTransaction;
    const constraintDateQuark = transaction.entries.get(event.$.constraintDate), constraintTypeQuark = transaction.entries.get(event.$.constraintType);
    return !transaction.baseRevision.hasIdentifier(event.$$) || constraintDateQuark && !constraintDateQuark.isShadow() || constraintTypeQuark && !constraintTypeQuark.isShadow();
  }
  /**
   * Returns possible resolution options for cases when
   * the interval takes part in a conflict.
   *
   * The interval suggests the only resolution option - removing the constraint.
   */
  getResolutions() {
    return this.resolutions || (this.resolutions = [
      this.removeDateConstraintConflictResolutionClass.new({ interval: this })
    ]);
  }
};
__decorate22([
  prototypeValue(RemoveDateConstraintConflictResolution)
], DateConstraintInterval.prototype, "removeDateConstraintConflictResolutionClass", void 0);
__decorate22([
  prototypeValue(DateConstraintIntervalDescription)
], DateConstraintInterval.prototype, "descriptionBuilderClass", void 0);

// ../Engine/lib/Engine/quark/model/scheduler_pro/ScheduledByDependenciesEarlyEventMixin.js
var __decorate23 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ScheduledByDependenciesEarlyEventMixin = class extends Mixin(
  // This mixin's `calculateEffectiveDirection` method should override the one of the `HasChildrenMixin`
  // thus the dependency on it (not strictly needed)
  [ConstrainedEarlyEventMixin, HasDependenciesMixin, HasChildrenMixin, HasDateConstraintMixin],
  (base) => {
    const superProto = base.prototype;
    class ScheduledByDependenciesEarlyEventMixin2 extends base {
      /**
       * The method defines wether the provided dependency should constrain the successor or not.
       * If the method returns `true` the dependency constrains the successor and does not do that when `false` returned.
       * By default the method returns `true` if the dependency is [[SchedulerProDependencyMixin.active|active]]
       * and if this event is [[inactive|active]] (or both this event and the successor are [[inactive]]).
       *
       * This is used when calculating [[earlyStartDateConstraintIntervals]].
       * @param dependency Dependency to consider.
       * @returns `true` if the dependency should constrain successor, `false` if not.
       */
      *shouldPredecessorAffectScheduling(dependency) {
        const fromEvent = yield dependency.$.fromEvent;
        return fromEvent && !isAtomicValue(fromEvent) && (yield dependency.$.active) && (!(yield fromEvent.$.inactive) || (yield this.$.inactive));
      }
      *calculateEarlyStartDateConstraintIntervals() {
        const intervals = yield* superProto.calculateEarlyStartDateConstraintIntervals.call(this);
        const project = this.getProject();
        const dependencyConstraintIntervalClass = project.dependencyConstraintIntervalClass;
        for (const dependency of yield this.$.incomingDeps) {
          if (!(yield* this.shouldPredecessorAffectScheduling(dependency)))
            continue;
          const predecessor = yield dependency.$.fromEvent;
          const manuallyScheduled = yield predecessor.$.manuallyScheduled;
          let predecessorDate;
          switch (yield dependency.$.type) {
            case DependencyType.EndToStart:
              predecessorDate = manuallyScheduled ? yield predecessor.$.endDate : yield predecessor.$.earlyEndDateRaw;
              break;
            case DependencyType.StartToStart:
              predecessorDate = manuallyScheduled ? yield predecessor.$.startDate : yield predecessor.$.earlyStartDateRaw;
              break;
          }
          if (predecessorDate) {
            const lag = yield dependency.$.lag;
            const lagUnit = yield dependency.$.lagUnit;
            const calendar = yield dependency.$.calendar;
            yield calendar.$.version;
            const interval = dependencyConstraintIntervalClass.new({
              owner: dependency,
              startDate: calendar.calculateEndDate(predecessorDate, yield* project.$convertDuration(lag, lagUnit, TimeUnit.Millisecond)),
              endDate: null
            });
            intervals.unshift(interval);
          }
        }
        return intervals;
      }
      *calculateEarlyEndDateConstraintIntervals() {
        const intervals = yield* superProto.calculateEarlyEndDateConstraintIntervals.call(this);
        const project = this.getProject();
        const dependencyConstraintIntervalClass = project.dependencyConstraintIntervalClass;
        for (const dependency of yield this.$.incomingDeps) {
          if (!(yield* this.shouldPredecessorAffectScheduling(dependency)))
            continue;
          const predecessor = yield dependency.$.fromEvent;
          const manuallyScheduled = yield predecessor.$.manuallyScheduled;
          let predecessorDate;
          switch (yield dependency.$.type) {
            case DependencyType.EndToEnd:
              predecessorDate = manuallyScheduled ? yield predecessor.$.endDate : yield predecessor.$.earlyEndDateRaw;
              break;
            case DependencyType.StartToEnd:
              predecessorDate = manuallyScheduled ? yield predecessor.$.startDate : yield predecessor.$.earlyStartDateRaw;
              break;
          }
          if (predecessorDate) {
            const lag = yield dependency.$.lag;
            const lagUnit = yield dependency.$.lagUnit;
            const calendar = yield dependency.$.calendar;
            yield calendar.$.version;
            const interval = dependencyConstraintIntervalClass.new({
              owner: dependency,
              startDate: calendar.calculateEndDate(predecessorDate, yield* project.$convertDuration(lag, lagUnit, TimeUnit.Millisecond)),
              endDate: null
            });
            intervals.unshift(interval);
          }
        }
        return intervals;
      }
      *calculateEffectiveDirection() {
        const projectDirection = yield this.getProject().$.effectiveDirection;
        const ownConstraintType = yield this.$.constraintType;
        if (projectDirection.direction === Direction.Forward && !(yield this.$.manuallyScheduled) && !((ownConstraintType === ConstraintType.MustStartOn || ownConstraintType === ConstraintType.MustFinishOn) && Boolean(yield this.$.constraintDate))) {
          for (const dependency of yield this.$.incomingDeps) {
            const predecessor = yield dependency.$.fromEvent;
            const hasPredecessor = predecessor != null && !isAtomicValue(predecessor);
            const constraintType = hasPredecessor ? yield predecessor.$.constraintType : void 0;
            if (!hasPredecessor || !(yield dependency.$.active) || (yield predecessor.$.manuallyScheduled) || (constraintType === ConstraintType.MustStartOn || constraintType === ConstraintType.MustFinishOn) && Boolean(yield predecessor.$.constraintDate))
              continue;
            const dependencyType = yield dependency.$.type;
            const predecessorDirection = dependencyType === DependencyType.EndToEnd || dependencyType === DependencyType.EndToStart ? yield predecessor.$.endDateDirection : yield predecessor.$.startDateDirection;
            if (predecessorDirection.direction === Direction.Backward)
              return {
                // our TS version is a bit too old
                kind: "enforced",
                direction: Direction.Backward,
                enforcedBy: predecessorDirection.kind === "enforced" ? predecessorDirection.enforcedBy : predecessorDirection.kind === "own" ? predecessor : predecessorDirection.inheritedFrom
              };
          }
        }
        return yield* super.calculateEffectiveDirection();
      }
    }
    __decorate23([
      model_field({ type: "boolean" })
    ], ScheduledByDependenciesEarlyEventMixin2.prototype, "inactive", void 0);
    return ScheduledByDependenciesEarlyEventMixin2;
  }
) {
};
var BaseDependencyResolution = class extends Localizable_default(ConflictResolution) {
  static get $name() {
    return "BaseDependencyResolution";
  }
  getDescription() {
    const { dependency } = this, { type, fromEvent, toEvent } = dependency;
    return format(this.L("L{descriptionTpl}"), this.L("L{DependencyType.long}")[type], fromEvent.name || fromEvent.id, toEvent.name || toEvent.id);
  }
};
var RemoveDependencyResolution = class extends BaseDependencyResolution {
  static get $name() {
    return "RemoveDependencyResolution";
  }
  /**
   * Resolves the conflict by removing the dependency.
   */
  resolve() {
    this.dependency.remove();
  }
};
var DeactivateDependencyResolution = class extends BaseDependencyResolution {
  static get $name() {
    return "DeactivateDependencyResolution";
  }
  /**
   * Resolves the conflict by deactivating the dependency.
   */
  resolve() {
    this.dependency.active = false;
  }
};
var DependencyConstraintIntervalDescription = class extends ConstraintIntervalDescription {
  static get $name() {
    return "DependencyConstraintIntervalDescription";
  }
  static getDescriptionParameters(interval) {
    const dependency = interval.owner;
    return [
      DateHelper.format(interval.startDate, this.L("L{dateFormat}")),
      DateHelper.format(interval.endDate, this.L("L{dateFormat}")),
      this.L("L{DependencyType.long}")[dependency.type],
      dependency.fromEvent.name,
      dependency.toEvent.name
    ];
  }
};
var DependencyConstraintInterval = class extends ConstraintInterval {
  isAffectedByTransaction(transaction) {
    const dependency = this.owner;
    transaction = transaction || dependency.graph.activeTransaction;
    const { entries } = transaction, { fromEvent, toEvent, lag, lagUnit, type } = dependency.$, fromEventQuark = entries.get(fromEvent), toEventQuark = entries.get(toEvent), lagQuark = entries.get(lag), lagUnitQuark = entries.get(lagUnit), typeQuark = entries.get(type);
    return !transaction.baseRevision.hasIdentifier(dependency.$$) || fromEventQuark && !fromEventQuark.isShadow() || toEventQuark && !toEventQuark.isShadow() || lagQuark && !lagQuark.isShadow() || lagUnitQuark && !lagUnitQuark.isShadow() || typeQuark && !typeQuark.isShadow();
  }
  /**
   * Returns the interval resolution options.
   * There are two resolutions:
   * - [[RemoveDependencyResolution|removing the dependency]]
   * - [[DeactivateDependencyResolution|deactivating the dependency]].
   */
  getResolutions() {
    return this.resolutions || (this.resolutions = [
      this.deactivateDependencyConflictResolutionClass.new({ dependency: this.owner }),
      this.removeDependencyConflictResolutionClass.new({ dependency: this.owner })
    ]);
  }
};
__decorate23([
  prototypeValue(RemoveDependencyResolution)
], DependencyConstraintInterval.prototype, "removeDependencyConflictResolutionClass", void 0);
__decorate23([
  prototypeValue(DeactivateDependencyResolution)
], DependencyConstraintInterval.prototype, "deactivateDependencyConflictResolutionClass", void 0);
__decorate23([
  prototypeValue(DependencyConstraintIntervalDescription)
], DependencyConstraintInterval.prototype, "descriptionBuilderClass", void 0);

// ../Engine/lib/Engine/quark/model/scheduler_pro/SchedulerProAssignmentMixin.js
var __decorate24 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SchedulerProAssignmentMixin = class extends Mixin([BaseAssignmentMixin], (base) => {
  const superProto = base.prototype;
  class SchedulerProAssignmentMixin2 extends base {
    *calculateUnits() {
      const event = yield this.$.event;
      if (event)
        return yield* event.calculateAssignmentUnits(this);
      return yield ProposedOrPrevious;
    }
    *calculateEffort() {
      const event = yield this.$.event;
      if (event) {
        const startDate = yield event.$.startDate;
        const endDate = yield event.$.endDate;
        const calendar = yield event.$.effectiveCalendar;
        if (startDate && endDate) {
          const map2 = /* @__PURE__ */ new Map();
          map2.set(calendar, [this]);
          return yield* event.calculateProjectedEffort(startDate, endDate, map2);
        }
      }
      return null;
    }
    *calculateActualDate() {
      const event = yield this.$.event;
      if (event) {
        const startDate = yield event.$.startDate;
        const duration = yield event.$.duration;
        const percentDone = yield event.$.percentDone;
        return yield* event.calculateProjectedXDateWithDuration(startDate, true, duration * 0.01 * percentDone);
      }
      return null;
    }
    *calculateActualEffort() {
      const event = yield this.$.event;
      if (event) {
        const startDate = yield event.$.startDate;
        const calendar = yield event.$.effectiveCalendar;
        const actualDate = yield this.$.actualDate;
        const assignmentsByCalendar = /* @__PURE__ */ new Map();
        assignmentsByCalendar.set(calendar, [this]);
        return yield* event.calculateProjectedEffort(startDate, actualDate, assignmentsByCalendar);
      }
      return null;
    }
  }
  __decorate24([
    model_field({ type: "number", defaultValue: 100 })
  ], SchedulerProAssignmentMixin2.prototype, "units", void 0);
  __decorate24([
    calculate("units")
  ], SchedulerProAssignmentMixin2.prototype, "calculateUnits", null);
  __decorate24([
    field({ lazy: true })
  ], SchedulerProAssignmentMixin2.prototype, "effort", void 0);
  __decorate24([
    field({ lazy: true })
  ], SchedulerProAssignmentMixin2.prototype, "actualDate", void 0);
  __decorate24([
    field({ lazy: true })
  ], SchedulerProAssignmentMixin2.prototype, "actualEffort", void 0);
  __decorate24([
    calculate("effort")
  ], SchedulerProAssignmentMixin2.prototype, "calculateEffort", null);
  __decorate24([
    calculate("actualDate")
  ], SchedulerProAssignmentMixin2.prototype, "calculateActualDate", null);
  __decorate24([
    calculate("actualEffort")
  ], SchedulerProAssignmentMixin2.prototype, "calculateActualEffort", null);
  return SchedulerProAssignmentMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_pro/SchedulerProDependencyMixin.js
var __decorate25 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SchedulerProDependencyMixin = class extends Mixin([BaseDependencyMixin], (base) => {
  const superProto = base.prototype;
  class SchedulerProDependencyMixin2 extends base {
    *calculateCalendar() {
      const project = this.getProject();
      const dependenciesCalendar = yield project.$.dependenciesCalendar;
      let calendar;
      switch (dependenciesCalendar) {
        case DependenciesCalendar.Project:
          calendar = yield project.$.effectiveCalendar;
          break;
        case DependenciesCalendar.FromEvent:
          const fromEvent = yield this.$.fromEvent;
          calendar = fromEvent && !isAtomicValue(fromEvent) ? yield fromEvent.$.effectiveCalendar : null;
          break;
        case DependenciesCalendar.ToEvent:
          const toEvent = yield this.$.toEvent;
          calendar = toEvent && !isAtomicValue(toEvent) ? yield toEvent.$.effectiveCalendar : null;
          break;
      }
      if (!calendar)
        calendar = yield project.$.effectiveCalendar;
      return calendar;
    }
    /**
     * Setter for the [[lag]]. Can also set [[lagUnit]] if second argument is provided.
     *
     * @param lag
     * @param unit
     */
    async setLag(lag, unit) {
      if (this.graph) {
        this.graph.write(this.$.lag, lag, unit);
        return this.graph.commitAsync();
      } else {
        this.$.lag.DATA = lag;
        if (unit != null)
          this.$.lagUnit.DATA = unit;
      }
    }
    writeLag(me, transaction, quark, lag, unit = void 0) {
      me.constructor.prototype.write.call(this, me, transaction, quark, lag);
      if (unit != null)
        transaction.write(this.$.lagUnit, unit);
    }
  }
  __decorate25([
    model_field({ type: "number", defaultValue: 0 })
  ], SchedulerProDependencyMixin2.prototype, "lag", void 0);
  __decorate25([
    model_field({ type: "string", defaultValue: TimeUnit.Day }, { converter: DateHelper.normalizeUnit })
  ], SchedulerProDependencyMixin2.prototype, "lagUnit", void 0);
  __decorate25([
    field()
  ], SchedulerProDependencyMixin2.prototype, "calendar", void 0);
  __decorate25([
    model_field({ type: "boolean", defaultValue: true, persist: true })
  ], SchedulerProDependencyMixin2.prototype, "active", void 0);
  __decorate25([
    calculate("calendar")
  ], SchedulerProDependencyMixin2.prototype, "calculateCalendar", null);
  __decorate25([
    write("lag")
  ], SchedulerProDependencyMixin2.prototype, "writeLag", null);
  return SchedulerProDependencyMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_pro/HasPercentDoneMixin.js
var __decorate26 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HasPercentDoneMixin = class extends Mixin([HasChildrenMixin], (base) => {
  const superProto = base.prototype;
  class HasPercentDoneMixin2 extends base {
    /**
     * Method calculates the task [[percentDone]] field value.
     * For a summary task it calculates the value based on the task children if the project
     * [[SchedulerProProjectMixin.autoCalculatePercentDoneForParentTasks|autoCalculatePercentDoneForParentTasks]] is true (default).
     * And for a regular (leaf) task it just returns the field provided value as-is.
     */
    *calculatePercentDone() {
      const childEvents = yield this.$.childEvents;
      const project = this.getProject();
      const autoCalculatePercentDoneForParentTasks = yield project.$.autoCalculatePercentDoneForParentTasks;
      if (childEvents.size && autoCalculatePercentDoneForParentTasks) {
        const summaryData = yield this.$.percentDoneSummaryData;
        if (summaryData.totalDuration > 0) {
          return summaryData.completedDuration / summaryData.totalDuration;
        } else if (summaryData.milestonesNum > 0) {
          return summaryData.milestonesTotalPercentDone / summaryData.milestonesNum;
        } else {
          return null;
        }
      } else {
        return yield ProposedOrPrevious;
      }
    }
    /**
     * The method defines whether the provided child event should be
     * taken into account when calculating this summary event [[percentDone]].
     *
     * If the method returns `true` the child event is taken into account
     * and if the method returns `false` it's not.
     * By default the method returns `true` to include all child events data.
     * @param childEvent Child event to consider.
     * @returns `true` if the provided event should be taken into account, `false` if not.
     */
    *shouldRollupChildPercentDoneSummaryData(childEvent) {
      return true;
    }
    *calculatePercentDoneSummaryData() {
      const childEvents = yield this.$.childEvents;
      if (childEvents.size) {
        let summary = {
          totalDuration: 0,
          completedDuration: 0,
          milestonesNum: 0,
          milestonesTotalPercentDone: 0
        };
        for (const childEvent of childEvents) {
          if (!(yield* this.shouldRollupChildPercentDoneSummaryData(childEvent)))
            continue;
          const childSummaryData = yield childEvent.$.percentDoneSummaryData;
          if (childSummaryData) {
            summary.totalDuration += childSummaryData.totalDuration;
            summary.completedDuration += childSummaryData.completedDuration;
            summary.milestonesNum += childSummaryData.milestonesNum;
            summary.milestonesTotalPercentDone += childSummaryData.milestonesTotalPercentDone;
          }
        }
        return summary;
      } else {
        const duration = yield this.$.duration;
        if (typeof duration == "number") {
          const durationInMs = yield* this.getProject().$convertDuration(duration, yield this.$.durationUnit, TimeUnit.Millisecond);
          const percentDone = yield this.$.percentDone;
          return {
            totalDuration: durationInMs,
            completedDuration: durationInMs * percentDone,
            milestonesNum: durationInMs === 0 ? 1 : 0,
            milestonesTotalPercentDone: durationInMs === 0 ? percentDone : 0
          };
        } else {
          return null;
        }
      }
    }
  }
  __decorate26([
    model_field({ type: "number", defaultValue: 0 })
  ], HasPercentDoneMixin2.prototype, "percentDone", void 0);
  __decorate26([
    field()
  ], HasPercentDoneMixin2.prototype, "percentDoneSummaryData", void 0);
  __decorate26([
    calculate("percentDone")
  ], HasPercentDoneMixin2.prototype, "calculatePercentDone", null);
  __decorate26([
    calculate("percentDoneSummaryData")
  ], HasPercentDoneMixin2.prototype, "calculatePercentDoneSummaryData", null);
  return HasPercentDoneMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_pro/SchedulerProHasAssignmentsMixin.js
var __decorate27 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SchedulerProHasAssignmentsMixin = class extends Mixin([BaseHasAssignmentsMixin], (base) => {
  const superProto = base.prototype;
  class SchedulerProHasAssignmentsMixin2 extends base {
    *hasProposedValueForUnits() {
      const assignments = yield this.$.assigned;
      for (const assignment of assignments) {
        const resource = yield assignment.$.resource;
        if (resource && (yield HasProposedValue(assignment.$.units)))
          return true;
      }
      return false;
    }
    /**
     * A method which assigns a resource to the current event
     */
    async assign(resource, units = 100) {
      const assignmentCls = this.getProject().assignmentStore.modelClass;
      this.addAssignment(new assignmentCls({
        event: this,
        resource,
        units
      }));
      return this.commitAsync();
    }
    *forEachAvailabilityInterval(options, func) {
      const calendar = yield this.$.effectiveCalendar;
      const assignmentsByCalendar = yield this.$.assignmentsByCalendar;
      const effectiveCalendarsCombination = yield this.$.effectiveCalendarsCombination;
      const ignoreResourceCalendar = (yield this.$.ignoreResourceCalendar) || options.ignoreResourceCalendar || !assignmentsByCalendar.size;
      const maxRange = this.getProject().maxCalendarRange;
      if (maxRange) {
        options = Object.assign({ maxRange }, options);
      }
      return effectiveCalendarsCombination.forEachAvailabilityInterval(options, (startDate, endDate, calendarCacheIntervalMultiple) => {
        const calendarsStatus = calendarCacheIntervalMultiple.getCalendarsWorkStatus();
        const workCalendars = calendarCacheIntervalMultiple.getCalendarsWorking();
        if (calendarsStatus.get(calendar) && (ignoreResourceCalendar || workCalendars.some((calendar2) => assignmentsByCalendar.has(calendar2)))) {
          return func(startDate, endDate, calendarCacheIntervalMultiple);
        }
      });
    }
    *calculateEffectiveCalendarsCombination() {
      const manuallyScheduled = yield this.$.manuallyScheduled;
      const project = this.getProject();
      const calendars = [yield this.$.effectiveCalendar];
      if (!manuallyScheduled || project.skipNonWorkingTimeInDurationWhenSchedulingManually) {
        const assignmentsByCalendar = yield this.$.assignmentsByCalendar;
        calendars.push(...assignmentsByCalendar.keys());
      }
      return this.getProject().combineCalendars(calendars);
    }
    *calculateAssignmentsByCalendar() {
      const assignments = yield this.$.assigned;
      const result = /* @__PURE__ */ new Map();
      for (const assignment of assignments) {
        const resource = yield assignment.$.resource;
        if (resource) {
          const resourceCalendar = yield resource.$.effectiveCalendar;
          let assignments2 = result.get(resourceCalendar);
          if (!assignments2) {
            assignments2 = [];
            result.set(resourceCalendar, assignments2);
          }
          assignments2.push(assignment);
        }
      }
      return result;
    }
    *getBaseOptionsForDurationCalculations() {
      return { ignoreResourceCalendar: false };
    }
    *useEventAvailabilityIterator() {
      const assignmentsByCalendar = yield this.$.assignmentsByCalendar;
      return assignmentsByCalendar.size > 0;
    }
    *skipNonWorkingTime(date, isForward = true, iteratorOptions) {
      if (!date)
        return null;
      const assignmentsByCalendar = yield this.$.assignmentsByCalendar;
      const ignoreResourceCalendar = yield this.$.ignoreResourceCalendar;
      if (yield* this.useEventAvailabilityIterator()) {
        const options = Object.assign(yield* this.getBaseOptionsForDurationCalculations(), isForward ? { startDate: date, isForward } : { endDate: date, isForward }, iteratorOptions);
        let workingDate;
        const skipRes = yield* this.forEachAvailabilityInterval(options, (startDate, endDate, calendarCacheIntervalMultiple) => {
          workingDate = isForward ? startDate : endDate;
          return false;
        });
        if (skipRes === CalendarIteratorResult.MaxRangeReached || skipRes === CalendarIteratorResult.FullRangeIterated) {
          const calendars = [yield this.$.effectiveCalendar];
          if (!options.ignoreResourceCalendar && !ignoreResourceCalendar) {
            calendars.push(...assignmentsByCalendar.keys());
          }
          const effect = EmptyCalendarEffect.new({
            event: this,
            calendars,
            date,
            isForward
          });
          if ((yield effect) === EffectResolutionResult.Cancel) {
            yield Reject(effect);
          } else {
            return null;
          }
        }
        return new Date(workingDate);
      } else {
        return yield* superProto.skipNonWorkingTime.call(this, date, isForward);
      }
    }
    *calculateProjectedDuration(startDate, endDate, durationUnit, iteratorOptions) {
      if (!startDate || !endDate) {
        return null;
      }
      if (yield* this.useEventAvailabilityIterator()) {
        const options = Object.assign(yield* this.getBaseOptionsForDurationCalculations(), { startDate, endDate, isForward: true }, iteratorOptions);
        const adjustDurationToDST = this.getProject().adjustDurationToDST;
        let result = 0;
        yield* this.forEachAvailabilityInterval(options, (startDate2, endDate2) => {
          result += endDate2.getTime() - startDate2.getTime();
          if (adjustDurationToDST) {
            const dstDiff = startDate2.getTimezoneOffset() - endDate2.getTimezoneOffset();
            result += dstDiff * 60 * 1e3;
          }
        });
        if (!durationUnit)
          durationUnit = yield this.$.durationUnit;
        return yield* this.getProject().$convertDuration(result, TimeUnit.Millisecond, durationUnit);
      } else {
        return yield* superProto.calculateProjectedDuration.call(this, startDate, endDate, durationUnit);
      }
    }
    *calculateProjectedXDateWithDuration(baseDate, isForward = true, duration, durationUnit, iteratorOptions) {
      if (duration == null || isNaN(duration) || baseDate == null)
        return null;
      if (duration == 0)
        return baseDate;
      durationUnit = durationUnit || (yield this.$.durationUnit);
      const durationMS = yield* this.getProject().$convertDuration(duration, durationUnit, TimeUnit.Millisecond);
      let resultN = baseDate.getTime();
      let leftDuration = durationMS;
      const calendar = yield this.$.effectiveCalendar;
      if (yield* this.useEventAvailabilityIterator()) {
        const options = Object.assign(yield* this.getBaseOptionsForDurationCalculations(), isForward ? { startDate: baseDate, isForward } : { endDate: baseDate, isForward }, iteratorOptions);
        const adjustDurationToDST = this.getProject().adjustDurationToDST;
        const iterationRes = yield* this.forEachAvailabilityInterval(options, (intervalStart, intervalEnd, calendarCacheIntervalMultiple) => {
          const intervalStartN = intervalStart.getTime(), intervalEndN = intervalEnd.getTime(), intervalDuration = intervalEndN - intervalStartN;
          if (intervalDuration >= leftDuration) {
            if (adjustDurationToDST) {
              const dstDiff = isForward ? intervalStart.getTimezoneOffset() - new Date(intervalStartN + leftDuration).getTimezoneOffset() : new Date(intervalEndN - leftDuration).getTimezoneOffset() - intervalEnd.getTimezoneOffset();
              leftDuration -= dstDiff * 60 * 1e3;
            }
            resultN = isForward ? intervalStartN + leftDuration : intervalEndN - leftDuration;
            return false;
          } else {
            leftDuration -= intervalDuration;
            if (adjustDurationToDST) {
              const dstDiff = intervalStart.getTimezoneOffset() - intervalEnd.getTimezoneOffset();
              leftDuration -= dstDiff * 60 * 1e3;
            }
          }
        });
        return iterationRes === CalendarIteratorResult.StoppedByIterator ? new Date(resultN) : null;
      } else {
        return calendar.accumulateWorkingTime(baseDate, durationMS, isForward).finalDate;
      }
    }
  }
  __decorate27([
    field()
  ], SchedulerProHasAssignmentsMixin2.prototype, "effectiveCalendarsCombination", void 0);
  __decorate27([
    field()
  ], SchedulerProHasAssignmentsMixin2.prototype, "assignmentsByCalendar", void 0);
  __decorate27([
    model_field({ type: "boolean" })
  ], SchedulerProHasAssignmentsMixin2.prototype, "ignoreResourceCalendar", void 0);
  __decorate27([
    calculate("effectiveCalendarsCombination")
  ], SchedulerProHasAssignmentsMixin2.prototype, "calculateEffectiveCalendarsCombination", null);
  __decorate27([
    calculate("assignmentsByCalendar")
  ], SchedulerProHasAssignmentsMixin2.prototype, "calculateAssignmentsByCalendar", null);
  return SchedulerProHasAssignmentsMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_pro/SchedulerProEventSegment.js
var __decorate28 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var MasterStartDateVar = Symbol("MasterStartDateVar");
var MasterEndDateVar = Symbol("MasterEndDateVar");
var MasterDurationVar = Symbol("MasterDurationVar");
var MasterTotalDurationVar = Symbol("MasterTotalDurationVar");
var StartOffsetVar = Symbol("StartOffsetVar");
var EndOffsetVar = Symbol("EndOffsetVar");
var durationByOffsetsFormula = Formula.new({
  output: DurationVar,
  inputs: /* @__PURE__ */ new Set([StartOffsetVar, EndOffsetVar])
});
var startDateByMasterStartAndStartOffsetFormula = Formula.new({
  output: StartDateVar,
  inputs: /* @__PURE__ */ new Set([StartOffsetVar, MasterStartDateVar])
});
var endDateByMasterStartAndEndOffsetFormula = Formula.new({
  output: EndDateVar,
  inputs: /* @__PURE__ */ new Set([EndOffsetVar, MasterStartDateVar])
});
var startOffsetByMasterStartAndStartDateFormula = Formula.new({
  output: StartOffsetVar,
  inputs: /* @__PURE__ */ new Set([StartDateVar, MasterStartDateVar])
});
var endOffsetByMasterStartAndEndDateFormula = Formula.new({
  output: EndOffsetVar,
  inputs: /* @__PURE__ */ new Set([EndDateVar, MasterStartDateVar])
});
var startOffsetByEndOffsetAndDurationFormula = Formula.new({
  output: StartOffsetVar,
  inputs: /* @__PURE__ */ new Set([EndOffsetVar, DurationVar])
});
var endOffsetByStartOffsetAndDurationFormula = Formula.new({
  output: EndOffsetVar,
  inputs: /* @__PURE__ */ new Set([StartOffsetVar, DurationVar])
});
var endOffsetByMasterTotalDurationAndStartOffsetFormula = Formula.new({
  output: EndOffsetVar,
  inputs: /* @__PURE__ */ new Set([StartOffsetVar, MasterTotalDurationVar])
});
var endOffsetByMasterDurationAndStartOffsetFormula = Formula.new({
  output: EndOffsetVar,
  inputs: /* @__PURE__ */ new Set([StartOffsetVar, MasterDurationVar])
});
var durationByMasterEndDateFormula = Formula.new({
  output: DurationVar,
  inputs: /* @__PURE__ */ new Set([StartOffsetVar, MasterEndDateVar])
});
var segmentCycleDescription = CycleDescription.new({
  variables: /* @__PURE__ */ new Set([
    StartDateVar,
    EndDateVar,
    DurationVar,
    MasterStartDateVar,
    MasterEndDateVar,
    MasterDurationVar,
    MasterTotalDurationVar,
    StartOffsetVar,
    EndOffsetVar
  ]),
  formulas: /* @__PURE__ */ new Set([
    // the order of formulas is important here - the earlier ones are preferred
    durationByOffsetsFormula,
    startDateByMasterStartAndStartOffsetFormula,
    endDateByMasterStartAndEndOffsetFormula,
    startOffsetByEndOffsetAndDurationFormula,
    startOffsetByMasterStartAndStartDateFormula,
    endOffsetByStartOffsetAndDurationFormula,
    endOffsetByMasterTotalDurationAndStartOffsetFormula,
    endOffsetByMasterDurationAndStartOffsetFormula,
    // endOffsetByMasterEndDateAndStartOffsetFormula,
    endOffsetByMasterStartAndEndDateFormula,
    durationByMasterEndDateFormula
  ])
});
var segmentCycleResolution = CycleResolution.new({
  description: segmentCycleDescription,
  defaultResolutionFormulas: /* @__PURE__ */ new Set([
    endDateByMasterStartAndEndOffsetFormula,
    endOffsetByMasterStartAndEndDateFormula,
    endOffsetByStartOffsetAndDurationFormula
  ])
});
var SegmentSEDDispatcherIdentifier = class extends FieldIdentifier.mix(CalculatedValueGen) {
  equality(v1, v2) {
    const resolution1 = v1.resolution;
    const resolution2 = v2.resolution;
    return resolution1.get(StartDateVar) === resolution2.get(StartDateVar) && resolution1.get(EndDateVar) === resolution2.get(EndDateVar) && resolution1.get(DurationVar) === resolution2.get(DurationVar) && resolution1.get(MasterStartDateVar) === resolution2.get(MasterStartDateVar) && resolution1.get(MasterEndDateVar) === resolution2.get(MasterEndDateVar) && resolution1.get(MasterDurationVar) === resolution2.get(MasterDurationVar) && resolution1.get(MasterTotalDurationVar) === resolution2.get(MasterTotalDurationVar) && resolution1.get(StartOffsetVar) === resolution2.get(StartOffsetVar) && resolution1.get(EndOffsetVar) === resolution2.get(EndOffsetVar);
  }
};
var SchedulerProEventSegment = class extends Mixin([BaseEventMixin], (base) => {
  class SchedulerProEventSegment2 extends base {
    get isEventSegment() {
      return true;
    }
    get stm() {
      var _a2;
      return (_a2 = this.event) == null ? void 0 : _a2.stm;
    }
    set stm(value) {
    }
    writeStartDate(me, transaction, quark, date, keepDuration = true) {
      const event = this.event;
      const project = this.getProject();
      if (event && !this.previousSegment && transaction.baseRevision.hasIdentifier(me) && !(project && project.getStm().isRestoring)) {
        event.$.startDate.constructor.prototype.write.call(this, event.$.startDate, transaction, null, date, keepDuration);
      } else {
        me.constructor.prototype.write.call(this, me, transaction, quark, date, keepDuration);
      }
      if (keepDuration && this.nextSegment) {
        const shift = this.endOffset - this.nextSegment.startOffset;
        if (shift > 0) {
          let segment = this;
          while (segment = segment.nextSegment) {
            segment.startOffset += shift;
            segment.endOffset += shift;
          }
        }
      }
    }
    shouldRecordFieldChange(fieldName, oldValue, newValue) {
      return fieldName === "startOffset" || fieldName === "endOffset" || super.shouldRecordFieldChange(fieldName, oldValue, newValue);
    }
    *calculateStartOffset() {
      const dispatcher = yield this.$.dispatcher;
      const resolution = dispatcher.resolution.get(StartOffsetVar);
      if (!this.event) {
        return yield ProposedOrPrevious;
      }
      let result;
      if (resolution === CalculateProposed) {
        result = yield ProposedOrPrevious;
      } else if (resolution === startOffsetByEndOffsetAndDurationFormula.formulaId) {
        result = yield* this.calculateStartOffsetByEndOffsetAndDuration();
      } else if (resolution === startOffsetByMasterStartAndStartDateFormula.formulaId) {
        const masterStartDate = yield ProposedOrPreviousValueOf(this.event.$.startDate);
        const startDate = yield ProposedOrPreviousValueOf(this.$.startDate);
        result = yield* this.event.calculateProjectedDuration(masterStartDate, startDate, TimeUnit.Millisecond, { ignoreSegments: true });
      }
      return result;
    }
    *calculateEndOffset() {
      const dispatcher = yield this.$.dispatcher;
      const resolution = dispatcher.resolution.get(EndOffsetVar);
      if (!this.event) {
        return yield ProposedOrPrevious;
      }
      let result;
      if (resolution === CalculateProposed) {
        result = yield ProposedOrPrevious;
      } else if (resolution === endOffsetByStartOffsetAndDurationFormula.formulaId) {
        result = yield* this.calculateEndOffsetByStartOffsetAndDuration();
      } else if (resolution === endOffsetByMasterStartAndEndDateFormula.formulaId) {
        const masterStartDate = yield ProposedOrPreviousValueOf(this.event.$.startDate);
        const endDate = yield ProposedOrPreviousValueOf(this.$.endDate);
        result = yield* this.event.calculateProjectedDuration(masterStartDate, endDate, TimeUnit.Millisecond, { ignoreSegments: true });
      } else if (resolution === endOffsetByMasterDurationAndStartOffsetFormula.formulaId) {
        result = yield* this.calculateEndOffsetByMasterDurationAndStartOffset();
      } else if (resolution === endOffsetByMasterTotalDurationAndStartOffsetFormula.formulaId) {
        result = yield* this.calculateEndOffsetByMasterTotalDurationAndStartOffset();
      }
      return result;
    }
    *calculateStartDate() {
      const dispatcher = yield this.$.dispatcher;
      const formula = dispatcher.resolution.get(StartDateVar);
      if (!this.event) {
        return yield ProposedOrPrevious;
      }
      let result;
      if (formula === startDateByMasterStartAndStartOffsetFormula.formulaId) {
        result = yield* this.calculateStartDateByMasterStartAndStartOffset();
      } else {
        result = yield* super.calculateStartDate();
      }
      return result;
    }
    *calculateEndDate() {
      const dispatcher = yield this.$.dispatcher;
      const formula = dispatcher.resolution.get(EndDateVar);
      if (!this.event) {
        return yield ProposedOrPrevious;
      }
      let result;
      if (formula === endDateByMasterStartAndEndOffsetFormula.formulaId) {
        result = yield* this.calculateEndDateByMasterStartAndEndOffset();
      } else {
        result = yield* super.calculateEndDate();
      }
      return result;
    }
    *calculateDuration() {
      const dispatcher = yield this.$.dispatcher;
      const formula = dispatcher.resolution.get(DurationVar);
      if (!this.event) {
        return yield ProposedOrPrevious;
      }
      let result;
      if (formula === durationByOffsetsFormula.formulaId) {
        result = yield* this.calculateDurationByOffsets();
      } else if (formula === durationByMasterEndDateFormula.formulaId) {
        result = yield* this.calculateDurationByOffsets();
      } else {
        result = yield* super.calculateDuration();
      }
      return result;
    }
    buildProposedDispatcher(me, quark, transaction) {
      const dispatcher = super.buildProposedDispatcher(me, quark, transaction);
      dispatcher.addPreviousValueFlag(MasterStartDateVar);
      dispatcher.addPreviousValueFlag(StartOffsetVar);
      dispatcher.addPreviousValueFlag(EndOffsetVar);
      return dispatcher;
    }
    *prepareDispatcher(YIELD) {
      const dispatcher = yield* super.prepareDispatcher(YIELD);
      if (!this.event) {
        return dispatcher;
      }
      if (YIELD(PreviousValueOf(this.event.$.startDate)) != null)
        dispatcher.addPreviousValueFlag(MasterStartDateVar);
      if (YIELD(HasProposedValue(this.event.$.startDate)))
        dispatcher.addProposedValueFlag(MasterStartDateVar);
      if (!YIELD(HasProposedValue(this.event.$.segments))) {
        dispatcher.collectInfo(YIELD, this.event.$.duration, MasterDurationVar);
        if (YIELD(HasProposedValue(this.event.$.endDate))) {
          const masterEndDateArgs = YIELD(ProposedArgumentsOf(this.event.$.endDate));
          if (!(masterEndDateArgs == null ? void 0 : masterEndDateArgs[0])) {
            dispatcher.addProposedValueFlag(MasterEndDateVar);
          }
        }
        const masterDispatcher = YIELD(this.event.$.dispatcher);
        if (masterDispatcher.resolution.get(StartDateVar) === CalculateProposed && masterDispatcher.resolution.get(EndDateVar) === CalculateProposed) {
          dispatcher.addProposedValueFlag(MasterTotalDurationVar);
        }
      }
      dispatcher.collectInfo(YIELD, this.$.startOffset, StartOffsetVar);
      dispatcher.collectInfo(YIELD, this.$.endOffset, EndOffsetVar);
      return dispatcher;
    }
    cycleResolutionContext(Y) {
      return segmentCycleResolution;
    }
    // endOffsetByMasterDurationAndStartOffsetFormula
    *calculateEndOffsetByMasterDurationAndStartOffset() {
      const masterDuration = yield ProposedOrPreviousValueOf(this.event.$.duration);
      const masterDurationUnit = yield this.event.$.durationUnit;
      const startOffset = yield this.$.startOffset;
      const nextSegment = this.nextSegment;
      let result;
      let masterDurationMs = yield* this.getProject().$convertDuration(masterDuration, masterDurationUnit, TimeUnit.Millisecond);
      const segments = [];
      let segment = this;
      while (segment = segment.previousSegment) {
        segments.push(segment);
      }
      for (let i = segments.length - 1; i >= 0; i--) {
        const segment2 = segments[i];
        const segmentStartOffset = yield ProposedOrPreviousValueOf(segment2.$.startOffset);
        const segmentEndOffset = yield ProposedOrPreviousValueOf(segment2.$.endOffset);
        const segmentDurationMs = segmentEndOffset - segmentStartOffset;
        masterDurationMs -= segmentDurationMs;
      }
      if (masterDurationMs > 0) {
        if (!nextSegment) {
          result = startOffset + masterDurationMs;
        } else {
          result = startOffset + Math.min(masterDurationMs, (yield ProposedOrPreviousValueOf(this.$.endOffset)) - startOffset);
        }
      } else {
        result = startOffset;
      }
      return result;
    }
    // endOffsetByMasterDurationAndStartOffsetFormula
    *calculateEndOffsetByMasterTotalDurationAndStartOffset() {
      const masterStartDate = yield ProposedOrPreviousValueOf(this.event.$.startDate);
      const masterEndDate = yield ProposedOrPreviousValueOf(this.event.$.endDate);
      const masterTotalDurationMs = yield* this.event.calculateProjectedDuration(masterStartDate, masterEndDate, TimeUnit.Millisecond, { ignoreSegments: true });
      const startOffset = yield ProposedOrPreviousValueOf(this.$.startOffset);
      let endOffset = yield ProposedOrPreviousValueOf(this.$.endOffset);
      let nextSegment = this.nextSegment;
      if (startOffset <= masterTotalDurationMs) {
        if (endOffset <= masterTotalDurationMs) {
          if (!nextSegment || (yield ProposedOrPreviousValueOf(nextSegment.$.startOffset)) >= masterTotalDurationMs) {
            return masterTotalDurationMs;
          }
          return endOffset;
        } else {
          return masterTotalDurationMs;
        }
      }
      return yield this.$.startOffset;
    }
    // startOffsetByEndOffsetAndDurationFormula
    *calculateStartOffsetByEndOffsetAndDuration() {
      const duration = yield this.$.duration;
      const durationUnit = yield this.$.durationUnit;
      const endOffset = yield this.$.endOffset;
      return endOffset - (yield* this.event.getProject().$convertDuration(duration, durationUnit, TimeUnit.Millisecond));
    }
    // endOffsetByStartOffsetAndDurationFormula
    *calculateEndOffsetByStartOffsetAndDuration() {
      const duration = yield this.$.duration;
      const durationUnit = yield this.$.durationUnit;
      const startOffset = yield this.$.startOffset;
      return startOffset + (yield* this.event.getProject().$convertDuration(duration, durationUnit, TimeUnit.Millisecond));
    }
    // endDateByMasterStartAndEndOffsetFormula
    *calculateEndDateByMasterStartAndEndOffset() {
      const masterStartDate = yield this.event.$.startDate;
      const endOffset = yield this.$.endOffset;
      const rawDate = yield* this.event.calculateProjectedXDateWithDuration(masterStartDate, true, endOffset, TimeUnit.Millisecond, { ignoreSegments: true });
      const manuallyScheduled = yield this.$.manuallyScheduled;
      return manuallyScheduled && !this.getProject().skipNonWorkingTimeWhenSchedulingManually ? rawDate : yield* this.event.skipNonWorkingTime(rawDate, false);
    }
    // startDateByMasterStartAndStartOffsetFormula
    *calculateStartDateByMasterStartAndStartOffset() {
      const masterStartDate = yield this.event.$.startDate;
      const startOffset = yield this.$.startOffset;
      const rawDate = yield* this.event.calculateProjectedXDateWithDuration(masterStartDate, true, startOffset, TimeUnit.Millisecond, { ignoreSegments: true });
      const manuallyScheduled = yield this.$.manuallyScheduled;
      return manuallyScheduled && !this.getProject().skipNonWorkingTimeWhenSchedulingManually ? rawDate : yield* this.event.skipNonWorkingTime(rawDate);
    }
    // durationByOffsetsFormula
    *calculateDurationByOffsets() {
      const startOffset = yield this.$.startOffset;
      const endOffset = yield this.$.endOffset;
      const durationUnit = yield this.$.durationUnit;
      return yield* this.getProject().$convertDuration(endOffset - startOffset, TimeUnit.Millisecond, durationUnit);
    }
    *calculatePercentDone() {
      let result = 0;
      if (!this.event) {
        return yield ProposedOrPrevious;
      }
      const segments = yield this.event.$.segments;
      if (segments) {
        const masterPercentDone = yield this.event.$.percentDone;
        const masterDuration = yield this.event.$.duration;
        const masterDurationUnit = yield this.event.$.durationUnit;
        let masterDurationMs = yield* this.getProject().$convertDuration(masterDuration, masterDurationUnit, TimeUnit.Millisecond);
        let completeMasterDurationMs = masterPercentDone * 0.01 * masterDurationMs;
        for (const segment of segments) {
          const segmentStartOffset = segment.startOffset;
          const segmentEndOffset = segment.endOffset;
          const segmentDurationMs = segmentEndOffset - segmentStartOffset;
          if (segment === this) {
            if (completeMasterDurationMs >= segmentDurationMs)
              return 100;
            else if (completeMasterDurationMs > 0)
              return 100 * completeMasterDurationMs / segmentDurationMs;
            else
              return 0;
          }
          completeMasterDurationMs -= segmentDurationMs;
        }
      }
      return result;
    }
    *calculateMinPercent() {
      const previousSegment = this.previousSegment;
      if (!this.event) {
        return yield ProposedOrPrevious;
      }
      if (previousSegment) {
        return yield previousSegment.$.endPercentDone;
      }
      return 0;
    }
    *calculateMaxPercent() {
      if (!this.event) {
        return yield ProposedOrPrevious;
      }
      const masterDuration = yield this.event.$.duration;
      const masterDurationUnit = yield this.event.$.durationUnit;
      let masterDurationMs = yield* this.getProject().$convertDuration(masterDuration, masterDurationUnit, TimeUnit.Millisecond);
      const startOffset = yield this.$.startOffset;
      const endOffset = yield this.$.endOffset;
      const minPercent = yield this.$.startPercentDone;
      return minPercent + 100 * (endOffset - startOffset) / masterDurationMs;
    }
    // @override
    *calculateProjectedXDateWithDuration(baseDate, isForward, duration, durationUnit) {
      if (!durationUnit)
        durationUnit = yield this.$.durationUnit;
      return yield* this.event.calculateProjectedXDateWithDuration(baseDate, isForward, duration, durationUnit, { ignoreSegments: true });
    }
    // @override
    *calculateProjectedDuration(startDate, endDate, durationUnit) {
      if (!durationUnit)
        durationUnit = yield this.$.durationUnit;
      return yield* this.event.calculateProjectedDuration(startDate, endDate, durationUnit, { ignoreSegments: true });
    }
    *calculateManuallyScheduled() {
      if (this.event) {
        return yield this.event.$.manuallyScheduled;
      } else {
        return yield ProposedOrPrevious;
      }
    }
  }
  __decorate28([
    field({ identifierCls: SegmentSEDDispatcherIdentifier })
  ], SchedulerProEventSegment2.prototype, "dispatcher", void 0);
  __decorate28([
    model_field({ persist: false })
  ], SchedulerProEventSegment2.prototype, "startOffset", void 0);
  __decorate28([
    model_field({ persist: false })
  ], SchedulerProEventSegment2.prototype, "endOffset", void 0);
  __decorate28([
    field()
  ], SchedulerProEventSegment2.prototype, "percentDone", void 0);
  __decorate28([
    field()
  ], SchedulerProEventSegment2.prototype, "startPercentDone", void 0);
  __decorate28([
    field()
  ], SchedulerProEventSegment2.prototype, "endPercentDone", void 0);
  __decorate28([
    write("startDate")
  ], SchedulerProEventSegment2.prototype, "writeStartDate", null);
  __decorate28([
    calculate("startOffset")
  ], SchedulerProEventSegment2.prototype, "calculateStartOffset", null);
  __decorate28([
    calculate("endOffset")
  ], SchedulerProEventSegment2.prototype, "calculateEndOffset", null);
  __decorate28([
    calculate("percentDone")
  ], SchedulerProEventSegment2.prototype, "calculatePercentDone", null);
  __decorate28([
    calculate("startPercentDone")
  ], SchedulerProEventSegment2.prototype, "calculateMinPercent", null);
  __decorate28([
    calculate("endPercentDone")
  ], SchedulerProEventSegment2.prototype, "calculateMaxPercent", null);
  __decorate28([
    calculate("manuallyScheduled")
  ], SchedulerProEventSegment2.prototype, "calculateManuallyScheduled", null);
  return SchedulerProEventSegment2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_pro/SplitEventMixin.js
var __decorate29 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SegmentsVar = Symbol("SegmentsVar");
var segmentsConverter = (value, data, record) => record.processSegmentsValue(value);
var startDateByEndDateAndSegmentsFormula = Formula.new({
  output: StartDateVar,
  inputs: /* @__PURE__ */ new Set([EndDateVar, SegmentsVar])
});
var endDateByStartDateAndSegmentsFormula = Formula.new({
  output: EndDateVar,
  inputs: /* @__PURE__ */ new Set([StartDateVar, SegmentsVar])
});
var durationByStartDateAndEndDateAndSegmentsFormula = Formula.new({
  output: DurationVar,
  inputs: /* @__PURE__ */ new Set([StartDateVar, EndDateVar, SegmentsVar])
});
var SEDSGGraphDescription = CycleDescription.new({
  variables: /* @__PURE__ */ new Set([StartDateVar, EndDateVar, DurationVar, SegmentsVar]),
  formulas: /* @__PURE__ */ new Set([
    endDateByStartDateAndSegmentsFormula,
    startDateByEndDateAndSegmentsFormula,
    // durationByStartDateAndEndDateAndSegmentsFormula,
    startDateFormula,
    endDateFormula,
    durationFormula
  ])
});
var SEDSGForwardCycleResolution = CycleResolution.new({
  description: SEDSGGraphDescription,
  defaultResolutionFormulas: /* @__PURE__ */ new Set([endDateFormula, endDateByStartDateAndSegmentsFormula])
});
var SEDSGBackwardCycleResolution = CycleResolution.new({
  description: SEDSGGraphDescription,
  defaultResolutionFormulas: /* @__PURE__ */ new Set([startDateFormula, startDateByEndDateAndSegmentsFormula])
});
var SEDSGDispatcherIdentifier = class extends FieldIdentifier.mix(CalculatedValueGen) {
  equality(v1, v2) {
    const resolution1 = v1.resolution;
    const resolution2 = v2.resolution;
    return resolution1.get(StartDateVar) === resolution2.get(StartDateVar) && resolution1.get(EndDateVar) === resolution2.get(EndDateVar) && resolution1.get(DurationVar) === resolution2.get(DurationVar) && resolution1.get(SegmentsVar) === resolution2.get(SegmentsVar);
  }
};
function compareSegmentsArray(a, b) {
  if (!a && !b)
    return true;
  if (this._skipSegmentsIsEqual)
    return false;
  if (!a && b || a && !b)
    return false;
  if (a.length !== b.length)
    return false;
  return a.every((segment, index) => compareSegments(segment, b[index]));
}
var compareSegments = (a, b) => {
  if (a === b)
    return true;
  const segmentModel = a.isModel ? a : b;
  const fieldMap = segmentModel.fieldMap;
  const aStart = a.startDate instanceof Date ? a.startDate.getTime() : fieldMap.startDate.convert(a.startDate).getTime();
  const bStart = b.startDate instanceof Date ? b.startDate.getTime() : fieldMap.startDate.convert(b.startDate).getTime();
  const aEnd = a.endDate instanceof Date ? a.endDate.getTime() : fieldMap.endDate.convert(a.endDate).getTime();
  const bEnd = b.endDate instanceof Date ? b.endDate.getTime() : fieldMap.endDate.convert(b.endDate).getTime();
  return aStart === bStart && aEnd === bEnd;
};
var SplitEventMixin = class extends Mixin([SchedulerProHasAssignmentsMixin, HasPercentDoneMixin], (base) => {
  class SplitEventMixin2 extends base {
    constructor() {
      super(...arguments);
      this._segmentGeneration = {};
    }
    static get $name() {
      return "SplitEventMixin";
    }
    construct() {
      this.segmentModelClass = this.getDefaultSegmentModelClass();
      super.construct(...arguments);
    }
    get rawModifications() {
      let data = super.rawModifications;
      if (this.segments && (!data || !("segments" in data))) {
        for (const segment of this.segments) {
          if (segment.rawModifications) {
            data = data || {};
            data.segments = this.getFieldPersistentValue("segments");
            break;
          }
        }
      }
      return data;
    }
    clearChanges(includeDescendants, removeFromStoreChanges, changes) {
      for (const segment of this.segments || []) {
        segment.clearChanges(includeDescendants, removeFromStoreChanges, null);
      }
      super.clearChanges(includeDescendants, removeFromStoreChanges, changes);
    }
    getDefaultSegmentModelClass() {
      return SchedulerProEventSegment;
    }
    *prepareDispatcher(YIELD) {
      const dispatcher = yield* super.prepareDispatcher(YIELD);
      if (yield* this.hasSegmentChangesProposed()) {
        dispatcher.addProposedValueFlag(SegmentsVar);
      }
      return dispatcher;
    }
    cycleResolutionContext(Y) {
      const direction = Y(this.$.effectiveDirection);
      return direction.direction === Direction.Forward || direction.direction === Direction.None ? SEDSGForwardCycleResolution : SEDSGBackwardCycleResolution;
    }
    *hasSegmentChangesProposed() {
      const proposedSegments = yield ProposedValueOf(this.$.segments);
      let result = false;
      if (yield HasProposedValue(this.$.segments)) {
        result = Boolean(proposedSegments);
      }
      const segments = yield ProposedOrPreviousValueOf(this.$.segments);
      if (!segments)
        return false;
      for (const segment of segments) {
        const startDateProposed = yield HasProposedValue(segment.$.startDate);
        const endDateProposed = yield HasProposedValue(segment.$.endDate);
        const durationProposed = yield HasProposedValue(segment.$.duration);
        if (startDateProposed || endDateProposed || durationProposed)
          result = true;
      }
      return result;
    }
    writeSegments(me, transaction, quark, value) {
      var _a2;
      const oldSegmentsQuarkValue = (_a2 = transaction.getLatestEntryFor(me)) == null ? void 0 : _a2.getValue();
      const oldSegments = oldSegmentsQuarkValue !== TombStone ? oldSegmentsQuarkValue != null ? oldSegmentsQuarkValue : [] : [];
      const oldSegmentsSet = new Set(oldSegments);
      const newSegments = value != null ? value : [];
      const newSegmentsSet = new Set(newSegments);
      this.project.ion({
        // remove them from the graph, only the ones not listed in the new segments array,
        // and only after commit finalization, otherwise test fails
        // we don't know why, possibly because in the `calculateSegments` we use `previousValue` of `segments` atom
        commitFinalized: () => graph.removeEntities(oldSegments.filter((segment) => !newSegmentsSet.has(segment))),
        once: true
      });
      me.constructor.prototype.write.call(this, me, transaction, quark, value);
      this.$.isSegmented.write.call(this, this.$.isSegmented, transaction, null, Boolean(value == null ? void 0 : value.length));
      const project = this.project;
      const graph = project.replica;
      for (const newSegment of newSegments) {
        if (!oldSegmentsSet.has(newSegment) && newSegment.graph !== graph) {
          newSegment.setProject(project);
          graph.addEntity(newSegment);
        }
      }
    }
    *doWriteSegments(segments, writes) {
      writes = writes || [];
      if (segments.length <= 1) {
        const duration = segments.length ? yield* this.getProject().$convertDuration(segments[0].endOffset - segments[0].startOffset, TimeUnit.Millisecond, yield this.$.durationUnit) : 0;
        writes.push({
          identifier: this.$.duration,
          proposedArgs: [duration, null]
        });
        segments = null;
      }
      writes.push({
        identifier: this.$.segments,
        proposedArgs: [segments]
      });
      yield WriteSeveral(writes);
    }
    *calculateSegments() {
      const dispatcher = yield this.$.dispatcher;
      const { graph, project } = this;
      const previousValue = yield PreviousValueOf(this.$.segments);
      let segments = yield ProposedOrPrevious;
      const toRemove = [];
      let hasChanges = false;
      if (segments) {
        const result = /* @__PURE__ */ new Set();
        let previousSegment = null;
        let keepDuration = false;
        const { baseRevision } = graph.$activeTransaction;
        for (const segment of segments) {
          const startOffset = yield segment.$.startOffset;
          const endOffset = yield segment.$.endOffset;
          const startDateProposedArgs = baseRevision.hasIdentifier(segment.$.startDate) && (yield ProposedArgumentsOf(segment.$.startDate));
          const endDateProposedArgs = baseRevision.hasIdentifier(segment.$.endDate) && (yield ProposedArgumentsOf(segment.$.endDate));
          keepDuration = keepDuration || (startDateProposedArgs == null ? void 0 : startDateProposedArgs[0]) || (endDateProposedArgs == null ? void 0 : endDateProposedArgs[0]);
          if (startOffset === endOffset) {
            toRemove.push(segment);
          } else if (previousSegment && startOffset <= previousSegment.endOffset) {
            const prevEndOffset = previousSegment.endOffset;
            toRemove.push(segment);
            if (previousSegment.graph) {
              toRemove.push(previousSegment);
              const previousSegmentStartOffset = previousSegment.startOffset;
              const previousSegmentEndOffset = keepDuration ? endOffset + prevEndOffset - startOffset : Math.max(endOffset, prevEndOffset);
              const cls = previousSegment.cls;
              previousSegment = this.segmentModelClass.new({
                event: this,
                cls,
                startOffset: previousSegmentStartOffset,
                endOffset: previousSegmentEndOffset
              });
            } else {
              previousSegment.endOffset = keepDuration ? endOffset + previousSegment.endOffset - startOffset : Math.max(endOffset, previousSegment.endOffset);
            }
          } else {
            if (previousSegment) {
              result.add(previousSegment);
            }
            previousSegment = segment;
          }
        }
        if (previousSegment) {
          result.add(previousSegment);
        }
        if (result.size === 1) {
          toRemove.push(...result);
        }
        hasChanges = toRemove.length > 0;
        if (hasChanges) {
          segments = Array.from(result);
        }
        segments.reduce((previousSegment2, segment, index) => {
          if (previousSegment2) {
            previousSegment2.nextSegment = segment;
          }
          segment.previousSegment = previousSegment2;
          segment.segmentIndex = index;
          return segment;
        }, null);
        if (segments.length) {
          segments[segments.length - 1].nextSegment = null;
        }
      } else if (previousValue) {
        toRemove.push(...previousValue);
      }
      if (toRemove.length) {
        toRemove.forEach((segment) => segment.event = null);
        project.ion({
          commitFinalized: () => graph.removeEntities(toRemove),
          once: true
        });
      }
      if (hasChanges) {
        yield* this.doWriteSegments(segments);
      }
      segments = (segments == null ? void 0 : segments.length) > 1 ? segments : null;
      return segments;
    }
    *calculateAdjustedSegments() {
      const dispatcher = yield this.$.dispatcher;
      let segments = yield this.$.segments;
      const startDate = yield this.$.startDate;
      const endDate = yield this.$.endDate;
      const duration = yield this.$.duration;
      let value = yield ProposedOrPrevious;
      if (segments) {
        const project = this.project;
        const graph = this.graph;
        const toRemove = [];
        const toWrite = [];
        let spliceIndex = -1;
        for (let i = segments.length - 1; i >= 0; i--) {
          const segment = segments[i];
          const segmentStartDate = yield segment.$.startDate;
          const segmentEndDate = yield segment.$.endDate;
          if (segmentStartDate > endDate) {
            toRemove.push(segment);
            spliceIndex = i;
          } else {
            if (segmentEndDate.getTime() !== endDate.getTime()) {
              const durationMs = segment.endOffset + (endDate.getTime() - segmentEndDate.getTime()) - segment.startOffset;
              const duration2 = yield* project.$convertDuration(durationMs, TimeUnit.Millisecond, yield segment.$.durationUnit);
              toWrite.push({
                identifier: segment.$.duration,
                proposedArgs: [duration2, null]
              }, {
                identifier: segment.$.endDate,
                proposedArgs: [endDate, false]
              }, {
                identifier: segment.$.endOffset,
                proposedArgs: [segment.endOffset + (endDate.getTime() - segmentEndDate.getTime())]
              });
            }
            break;
          }
        }
        let hasChanges = false;
        if (spliceIndex > -1) {
          hasChanges = true;
          segments.splice(spliceIndex);
          if (segments.length) {
            segments[segments.length - 1].nextSegment = null;
          }
          project.ion({
            commitFinalized: () => graph.removeEntities(toRemove),
            once: true
          });
        }
        let segmentsSnapshot = "";
        if (segments) {
          segmentsSnapshot = this.getSegmentsSnapshot(segments);
        }
        if (
          /*this._lastSegmentsSnapshot &&*/
          segmentsSnapshot !== this._lastSegmentsSnapshot
        ) {
          hasChanges = true;
          segments = segments ? segments.slice() : segments;
          this._lastSegmentsSnapshot = segmentsSnapshot;
        }
        if (hasChanges) {
          yield* this.doWriteSegments(segments, toWrite);
        }
      }
      return value;
    }
    getSegmentsSnapshot(segments) {
      segments = segments || this.segments;
      return segments == null ? void 0 : segments.map((segment) => {
        var _a2, _b;
        return "" + segment.startOffset + "-" + ((_a2 = segment.startDate) == null ? void 0 : _a2.getTime()) + "-" + segment.endOffset + "-" + ((_b = segment.endDate) == null ? void 0 : _b.getTime());
      }).join(";");
    }
    processSegmentsValue(value) {
      let result = value;
      if (value) {
        for (let i = 0; i < value.length; i++) {
          const segment = value[i];
          const record = segment.isModel ? segment : this.segmentModelClass.new(segment);
          if (!record.event)
            record.event = this;
          value[i] = record;
        }
      }
      return result;
    }
    *calculateStartDate() {
      const dispatcher = yield this.$.dispatcher;
      const resolution = dispatcher.resolution.get(StartDateVar);
      let result;
      if (resolution === startDateByEndDateAndSegmentsFormula.formulaId) {
        result = yield* this.calculateStartDateBySegments();
      } else {
        result = yield* super.calculateStartDate();
      }
      return result;
    }
    *calculateStartDateBySegments() {
      const dispatcher = yield this.$.dispatcher;
      const segments = yield this.$.segments;
      const endDate = yield this.$.endDate;
      let result;
      if (segments) {
        const lastSegment = segments[segments.length - 1];
        const lastSegmentEndOffset = yield lastSegment.$.endOffset;
        const rawDate = yield* this.calculateProjectedXDateWithDuration(endDate, false, lastSegmentEndOffset, TimeUnit.Millisecond, { ignoreSegments: true });
        const manuallyScheduled = yield this.$.manuallyScheduled;
        result = manuallyScheduled && !this.getProject().skipNonWorkingTimeWhenSchedulingManually ? rawDate : yield* this.skipNonWorkingTime(rawDate, true);
      }
      return result;
    }
    *calculateEndDateBySegments() {
      const dispatcher = yield this.$.dispatcher;
      const segments = yield this.$.segments;
      const startDate = yield this.$.startDate;
      let result;
      if (segments) {
        const lastSegment = segments[segments.length - 1];
        const lastSegmentEndOffset = yield lastSegment.$.endOffset;
        const rawDate = yield* this.calculateProjectedXDateWithDuration(startDate, true, lastSegmentEndOffset, TimeUnit.Millisecond, { ignoreSegments: true });
        const manuallyScheduled = yield this.$.manuallyScheduled;
        result = manuallyScheduled && !this.getProject().skipNonWorkingTimeWhenSchedulingManually ? rawDate : yield* this.skipNonWorkingTime(rawDate, false);
      }
      return result;
    }
    *calculateEndDate() {
      const dispatcher = yield this.$.dispatcher;
      const resolution = dispatcher.resolution.get(EndDateVar);
      let result;
      if (resolution === endDateByStartDateAndSegmentsFormula.formulaId) {
        result = yield* this.calculateEndDateBySegments();
      } else {
        result = yield* super.calculateEndDate();
      }
      return result;
    }
    *calculateDurationProposed() {
      let result;
      if (yield* this.hasSegmentChangesProposed()) {
        result = yield* this.calculateDurationBySegments();
      } else {
        result = yield* super.calculateDurationProposed();
      }
      return result;
    }
    *skipNonWorkingTime(date, isForward = true, iteratorOptions) {
      if (!date)
        return null;
      iteratorOptions = Object.assign({ ignoreSegments: true }, iteratorOptions);
      return yield* super.skipNonWorkingTime(date, isForward, iteratorOptions);
    }
    *calculateDurationBySegments() {
      let duration;
      const dispatcher = yield this.$.dispatcher;
      const durationUnit = yield this.$.durationUnit;
      const segments = yield this.$.segments;
      if (segments) {
        let durationMs = 0;
        for (const segment of segments) {
          durationMs += segment.endOffset - segment.startOffset;
        }
        duration = yield* this.getProject().$convertDuration(durationMs, TimeUnit.Millisecond, durationUnit);
      }
      return duration;
    }
    *forEachAvailabilityInterval(options, func) {
      const calendar = yield this.$.effectiveCalendar;
      const assignmentsByCalendar = yield this.$.assignmentsByCalendar;
      const effectiveCalendarsCombination = yield this.$.effectiveCalendarsCombination;
      const isForward = options.isForward !== false;
      const ignoreResourceCalendar = (yield this.$.ignoreResourceCalendar) || options.ignoreResourceCalendar || !assignmentsByCalendar.size;
      const maxRange = this.getProject().maxCalendarRange;
      let ignoreSegments = options.ignoreSegments;
      let sign = 1;
      let currentSegment, currentOffsetMs, currentSegmentDurationMs, segments, currentSegmentEndOffset;
      if (!ignoreSegments) {
        segments = yield this.$.segments;
        ignoreSegments = ignoreSegments || !segments;
        if (!ignoreSegments) {
          segments = segments.slice();
          if (isForward) {
            currentSegment = segments.shift();
            currentOffsetMs = 0;
            sign = 1;
            currentSegmentEndOffset = currentSegment.nextSegment ? currentSegment.endOffset : MAX_DATE.getTime();
          } else {
            currentSegment = segments.pop();
            currentOffsetMs = currentSegment.endOffset;
            sign = -1;
            currentSegmentEndOffset = currentSegment.endOffset;
          }
          currentSegmentDurationMs = currentSegmentEndOffset - currentSegment.startOffset;
        }
      }
      const manuallyScheduled = yield this.$.manuallyScheduled;
      const project = this.getProject();
      return effectiveCalendarsCombination.forEachAvailabilityInterval(Object.assign({ maxRange }, options), (intervalStartDate, intervalEndDate, calendarCacheIntervalMultiple) => {
        const calendarsStatus = calendarCacheIntervalMultiple.getCalendarsWorkStatus();
        const workCalendars = calendarCacheIntervalMultiple.getCalendarsWorking();
        if (calendarsStatus.get(calendar) && (ignoreResourceCalendar || workCalendars.some((calendar2) => assignmentsByCalendar.has(calendar2)) || manuallyScheduled && !project.skipNonWorkingTimeInDurationWhenSchedulingManually)) {
          if (ignoreSegments) {
            return func(intervalStartDate, intervalEndDate, calendarCacheIntervalMultiple);
          } else {
            const startDateN = intervalStartDate.getTime();
            let intervalDuration = intervalEndDate.getTime() - intervalStartDate.getTime();
            if (this.getProject().adjustDurationToDST) {
              const dstDiff = intervalStartDate.getTimezoneOffset() - intervalEndDate.getTimezoneOffset();
              intervalDuration += dstDiff * 60 * 1e3;
            }
            let intervalStartOffset, intervalEndOffset;
            if (isForward) {
              intervalStartOffset = currentOffsetMs;
              intervalEndOffset = currentOffsetMs + intervalDuration;
            } else {
              intervalStartOffset = currentOffsetMs - intervalDuration;
              intervalEndOffset = currentOffsetMs;
            }
            while (currentSegment && intervalStartOffset <= currentSegmentEndOffset && intervalEndOffset > currentSegment.startOffset) {
              const callStartOffset = Math.max(intervalStartOffset, currentSegment.startOffset);
              const callEndOffset = Math.min(intervalEndOffset, currentSegmentEndOffset);
              const callStartDate = new Date(startDateN + callStartOffset - intervalStartOffset);
              const callEndDate = new Date(startDateN + callEndOffset - intervalStartOffset);
              const callResult = func(callStartDate, callEndDate, calendarCacheIntervalMultiple);
              if (callResult === false)
                return false;
              currentSegmentDurationMs -= callEndDate.getTime() - callStartDate.getTime();
              if (!currentSegmentDurationMs) {
                currentSegment = isForward ? segments.shift() : segments.pop();
                if (currentSegment) {
                  currentSegmentEndOffset = !isForward || currentSegment.nextSegment ? currentSegment.endOffset : MAX_DATE.getTime();
                  currentSegmentDurationMs = currentSegmentEndOffset - currentSegment.startOffset;
                }
              } else {
                break;
              }
            }
            currentOffsetMs += sign * intervalDuration;
          }
        }
      });
    }
    *useEventAvailabilityIterator() {
      const isSegmented = yield this.$.isSegmented;
      if (isSegmented)
        return true;
      const manuallyScheduled = yield this.$.manuallyScheduled;
      return !manuallyScheduled;
    }
    /**
     * Returns a segment that is ongoing on the provided date.
     * @param  date Date to find an ongoing segment on
     * @param  [segments] List of segments to check. When not provided the event segments is used
     * @return Ongoing segment
     */
    getSegmentByDate(date, segments) {
      segments = segments || this.getSegments();
      if (segments) {
        const index = this.getSegmentIndexByDate(date, segments);
        return segments[index];
      }
    }
    getSegmentIndexByDate(date, segments) {
      segments = segments || this.getSegments();
      return segments ? segments.findIndex((segment) => date >= segment.startDate && date < segment.endDate) : -1;
    }
    /**
     * The event first segment or null if the event is not segmented.
     */
    get firstSegment() {
      const segments = this.getSegments();
      return segments ? segments[0] : null;
    }
    /**
     * The event last segment or null if the event is not segmented.
     */
    get lastSegment() {
      const segments = this.getSegments();
      return segments ? segments[segments.length - 1] : null;
    }
    /**
     * Returns a segment by its index.
     * @param index The segment index (zero based value).
     * @return The segment matching the provided index.
     */
    getSegment(index) {
      const segments = this.getSegments();
      return segments == null ? void 0 : segments[index];
    }
    /**
     * Splits the event.
     * @param from The date to split this event at.
     * @param [lag=1] Split duration.
     * @param [lagUnit] Split duration unit.
     */
    async splitToSegments(from, lag = 1, lagUnit) {
      var _a2;
      const project = this.getProject();
      await project.commitAsync();
      const me = this;
      if (!from || me.isHasSubEventsMixin && ((_a2 = me.childEvents) == null ? void 0 : _a2.size))
        return;
      const duration = me.duration;
      const durationUnit = me.durationUnit;
      const startDate = me.startDate;
      const endDate = me.endDate;
      lagUnit = lagUnit ? DateHelper.normalizeUnit(lagUnit) : durationUnit;
      if (!startDate || !endDate || startDate >= from || from >= endDate || !duration)
        return;
      const isSegmented = me.isSegmented;
      let segments = me.segments || [];
      let segmentToSplit, segmentToSplitIndex;
      if (isSegmented) {
        segmentToSplitIndex = me.getSegmentIndexByDate(from, segments);
        segmentToSplit = segments[segmentToSplitIndex];
        if (!segmentToSplit)
          return;
      }
      const splitTarget = segmentToSplit || me;
      const splitTargetStart = segmentToSplit ? splitTarget.startDate : startDate;
      const splitTargetDuration = splitTarget.duration;
      const splitTargetDurationUnit = splitTarget.durationUnit;
      const prevSegmentDuration = me.run("calculateProjectedDuration", splitTargetStart, from, splitTargetDurationUnit, { ignoreSegments: true });
      const nextSegmentDuration = splitTargetDuration - prevSegmentDuration;
      const lagInMs = project.run("$convertDuration", lag, lagUnit, TimeUnit.Millisecond);
      const nextSegmentStartOffset = lagInMs + me.run("calculateProjectedDuration", startDate, from, TimeUnit.Millisecond, { ignoreSegments: true });
      if (segmentToSplit) {
        segmentToSplit.duration = prevSegmentDuration;
        const newSegment = this.segmentModelClass.new({
          duration: nextSegmentDuration,
          durationUnit: splitTargetDurationUnit,
          startOffset: nextSegmentStartOffset
        });
        segments = segments.slice(0);
        segments.splice(segmentToSplitIndex + 1, 0, newSegment);
        me.segments = segments;
        me.duration = duration;
        for (let i = segmentToSplitIndex + 2, l = segments.length; i < l; i++) {
          const segment = segments[i];
          if (segment) {
            segment.startOffset += lagInMs;
            segment.endOffset += lagInMs;
          }
        }
      } else {
        const previousSegment = this.segmentModelClass.new({
          duration: prevSegmentDuration,
          durationUnit: splitTargetDurationUnit,
          startOffset: 0
        });
        const newSegment = this.segmentModelClass.new({
          duration: duration - prevSegmentDuration,
          durationUnit: splitTargetDurationUnit,
          startOffset: nextSegmentStartOffset
        });
        me.duration = duration;
        me.segments = [previousSegment, newSegment];
      }
      return project.commitAsync();
    }
    /**
     * Merges the event segments.
     * The method merges two provided event segments (and all the segment between them if any).
     * @param [segment1] First segment to merge.
     * @param [segment2] Second segment to merge.
     */
    async mergeSegments(segment1, segment2) {
      if (!this.isSegmented)
        return;
      segment1 = segment1 || this.firstSegment;
      segment2 = segment2 || this.lastSegment;
      if (segment1.startOffset > segment2.startOffset) {
        let tmp = segment2;
        segment2 = segment1;
        segment1 = tmp;
      }
      segment1.endDate = segment2.startDate;
      return this.getProject().commitAsync();
    }
    // Override storeFieldChange to support revertChanges for segments field
    storeFieldChange(key, oldValue) {
      if (key === "segments" && oldValue) {
        const result = [];
        for (const segment of oldValue) {
          const segmentData = segment.toJSON();
          if (!this._segmentGeneration[segment.internalId] || segment.generation > this._segmentGeneration[segment.internalId]) {
            Object.assign(segmentData, segment.meta.modified);
          }
          result.push(segmentData);
          this._segmentGeneration[segment.internalId] = segment.generation;
        }
        oldValue = result;
      }
      super.storeFieldChange(key, oldValue);
    }
    leaveProject() {
      const segments = this.segments;
      if (segments) {
        this.graph.removeEntities(segments);
      }
      super.leaveProject();
    }
    endBatch(...args) {
      this.fieldMap.segments._skipSegmentsIsEqual++;
      super.endBatch(...args);
      this.fieldMap.segments._skipSegmentsIsEqual--;
    }
    copy(newId = null, deep = null) {
      const copy = super.copy(newId, deep);
      copy.data.segments = void 0;
      if (copy.segments) {
        copy.segments = copy.segments.map((seg) => Object.assign(seg.copy(), { event: copy }));
      }
      return copy;
    }
  }
  __decorate29([
    field({ identifierCls: SEDSGDispatcherIdentifier })
  ], SplitEventMixin2.prototype, "dispatcher", void 0);
  __decorate29([
    model_field({
      type: "array",
      isEqual: compareSegmentsArray,
      convert: segmentsConverter,
      // @ts-ignore
      _skipSegmentsIsEqual: 0
    })
  ], SplitEventMixin2.prototype, "segments", void 0);
  __decorate29([
    field()
  ], SplitEventMixin2.prototype, "adjustedSegments", void 0);
  __decorate29([
    field()
  ], SplitEventMixin2.prototype, "isSegmented", void 0);
  __decorate29([
    write("segments")
  ], SplitEventMixin2.prototype, "writeSegments", null);
  __decorate29([
    calculate("segments")
  ], SplitEventMixin2.prototype, "calculateSegments", null);
  __decorate29([
    calculate("adjustedSegments")
  ], SplitEventMixin2.prototype, "calculateAdjustedSegments", null);
  return SplitEventMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_pro/HasEffortMixin.js
var __decorate30 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HasEffortMixin = class extends Mixin([SchedulerProHasAssignmentsMixin, HasChildrenMixin], (base) => {
  const superProto = base.prototype;
  class HasEffortMixin2 extends base {
    /**
     * Getter for the effort. Can return effort in given unit, or will use [[effortUnit]].
     *
     * @param unit
     */
    getEffort(unit) {
      const effort = this.effort;
      return unit ? this.getProject().convertDuration(effort, this.effortUnit, unit) : effort;
    }
    writeEffort(me, transaction, quark, effort, unit) {
      if (effort < 0)
        effort = 0;
      if (!transaction.baseRevision.hasIdentifier(me) && effort == null)
        return;
      if (unit != null && unit !== this.effortUnit) {
        this.$.effortUnit.write.call(this, this.$.effortUnit, transaction, null, unit);
      }
      me.constructor.prototype.write(me, transaction, quark, effort);
    }
    setEffortUnit(_value) {
      throw new Error("Use `setEffort` instead");
    }
    /**
     * The method defines wether the provided child event should roll up its [[effort]] to this summary event or not.
     * If the method returns `true` the child event [[effort]] is summed up
     * when calculating this summary event [[effort]].
     * And if the method returns `false` the child effort is not taken into account.
     * By default the method returns `true` to include all child event [[effort]] values.
     * @param childEvent Child event to consider.
     * @returns `true` if the provided event [[effort]] should be included, `false` if not.
     */
    *shouldRollupChildEffort(childEvent) {
      return true;
    }
    /**
     * Helper method to calculate the total effort of all child events.
     */
    *calculateTotalChildrenEffort() {
      const childEvents = yield this.$.childEvents;
      const project = this.getProject();
      let totalEffortMs = 0;
      for (const childEvent of childEvents) {
        if (!(yield* this.shouldRollupChildEffort(childEvent)))
          continue;
        const childEventEffortUnit = yield childEvent.$.effortUnit;
        totalEffortMs += yield* project.$convertDuration(yield childEvent.$.effort, childEventEffortUnit, TimeUnit.Millisecond);
      }
      return yield* project.$convertDuration(totalEffortMs, TimeUnit.Millisecond, yield this.$.effortUnit);
    }
    *calculateEffort() {
      const childEvents = yield this.$.childEvents;
      if (childEvents.size > 0)
        return yield* this.calculateTotalChildrenEffort();
      else {
        const proposed = yield ProposedOrPrevious;
        return proposed !== void 0 ? proposed : yield* this.calculateEffortPure();
      }
    }
    *calculateEffortPure() {
      const childEvents = yield this.$.childEvents;
      if (childEvents.size > 0)
        return yield* this.calculateTotalChildrenEffort();
      else {
        return yield* this.calculateProjectedEffort(yield this.$.startDate, yield this.$.endDate);
      }
    }
    *calculateEffortProposed() {
      return yield ProposedOrPrevious;
    }
    *calculateAssignmentUnits(assignment) {
      return yield* this.calculateAssignmentUnitsProposed(assignment);
    }
    *calculateAssignmentUnitsPure(assignment) {
      return yield* this.calculateUnitsByStartEndAndEffort(assignment);
    }
    *calculateAssignmentUnitsProposed(assignment) {
      return yield ProposedOrPrevious;
    }
    *getBaseOptionsForEffortCalculations() {
      return { ignoreResourceCalendar: false };
    }
    *calculateProjectedEffort(startDate, endDate, assignmentsByCalendar) {
      if (startDate == null || endDate == null || startDate > endDate)
        return null;
      if (!assignmentsByCalendar) {
        assignmentsByCalendar = yield this.$.assignmentsByCalendar;
      }
      const totalUnitsByCalendar = /* @__PURE__ */ new Map();
      for (const [calendar, assignments] of assignmentsByCalendar) {
        let intervalUnits = 0;
        for (const assignment of assignments) {
          intervalUnits += yield assignment.$.units;
        }
        totalUnitsByCalendar.set(calendar, intervalUnits);
      }
      let resultN = 0;
      const options = Object.assign(yield* this.getBaseOptionsForEffortCalculations(), { startDate, endDate });
      if (totalUnitsByCalendar.size === 0) {
        totalUnitsByCalendar.set(yield this.$.effectiveCalendar, 100);
        options.ignoreResourceCalendar = true;
      }
      yield* this.forEachAvailabilityInterval(options, (intervalStart, intervalEnd, calendarCacheIntervalMultiple) => {
        const workCalendars = calendarCacheIntervalMultiple.getCalendarsWorking();
        const intervalStartN = intervalStart.getTime(), intervalEndN = intervalEnd.getTime(), intervalDuration = intervalEndN - intervalStartN;
        let intervalUnits = 0;
        for (const workingCalendar of workCalendars) {
          intervalUnits += totalUnitsByCalendar.get(workingCalendar) || 0;
        }
        resultN += intervalUnits * intervalDuration * 0.01;
      });
      return yield* this.getProject().$convertDuration(resultN, TimeUnit.Millisecond, yield this.$.effortUnit);
    }
    *calculateUnitsByStartEndAndEffort(_assignment) {
      const effort = yield this.$.effort, effortUnit = yield this.$.effortUnit, effortMS = yield* this.getProject().$convertDuration(effort, effortUnit, TimeUnit.Millisecond);
      let collectedEffort = 0;
      const options = Object.assign(yield* this.getBaseOptionsForEffortCalculations(), { startDate: yield this.$.startDate, endDate: yield this.$.endDate });
      const assignmentsByCalendar = yield this.$.assignmentsByCalendar;
      yield* this.forEachAvailabilityInterval(options, (intervalStart, intervalEnd, calendarCacheIntervalMultiple) => {
        const workCalendars = calendarCacheIntervalMultiple.getCalendarsWorking();
        const intervalStartN = intervalStart.getTime(), intervalEndN = intervalEnd.getTime(), intervalDuration = intervalEndN - intervalStartN;
        for (const workingCalendar of workCalendars) {
          collectedEffort += (assignmentsByCalendar.has(workingCalendar) ? assignmentsByCalendar.get(workingCalendar).length : 0) * intervalDuration;
        }
      });
      return collectedEffort ? 100 * effortMS / collectedEffort : 100;
    }
    *calculateProjectedXDateByEffort(baseDate, isForward = true, effort, effortUnit) {
      effort = effort !== void 0 ? effort : yield this.$.effort;
      effortUnit = effortUnit !== void 0 ? effortUnit : yield this.$.effortUnit;
      const effortMS = yield* this.getProject().$convertDuration(effort, effortUnit, TimeUnit.Millisecond);
      if (baseDate == null || effort == null)
        return null;
      let resultN = baseDate.getTime();
      let leftEffort = effortMS;
      if (leftEffort === 0)
        return new Date(resultN);
      const calendar = yield this.$.effectiveCalendar;
      const assignmentsByCalendar = yield this.$.assignmentsByCalendar;
      const totalUnitsByCalendar = /* @__PURE__ */ new Map();
      let hasUnits = false;
      for (const [calendar2, assignments] of assignmentsByCalendar) {
        let intervalUnits = 0;
        for (const assignment of assignments) {
          intervalUnits += yield assignment.$.units;
        }
        totalUnitsByCalendar.set(calendar2, intervalUnits);
        if (intervalUnits > 0)
          hasUnits = true;
      }
      if (hasUnits && (yield* this.useEventAvailabilityIterator())) {
        const options = Object.assign(yield* this.getBaseOptionsForDurationCalculations(), isForward ? { startDate: baseDate, isForward } : { endDate: baseDate, isForward });
        yield* this.forEachAvailabilityInterval(options, (intervalStart, intervalEnd, calendarCacheIntervalMultiple) => {
          const workCalendars = calendarCacheIntervalMultiple.getCalendarsWorking();
          const intervalStartN = intervalStart.getTime(), intervalEndN = intervalEnd.getTime(), intervalDuration = intervalEndN - intervalStartN;
          let intervalUnits = 0;
          for (const workingCalendar of workCalendars) {
            intervalUnits += totalUnitsByCalendar.get(workingCalendar) || 0;
          }
          const intervalEffort = intervalUnits * intervalDuration * 0.01;
          if (intervalEffort >= leftEffort) {
            resultN = isForward ? intervalStartN + leftEffort / (0.01 * intervalUnits) : intervalEndN - leftEffort / (0.01 * intervalUnits);
            return false;
          } else {
            leftEffort -= intervalEffort;
          }
        });
        return new Date(resultN);
      } else {
        return calendar.accumulateWorkingTime(baseDate, effortMS, isForward).finalDate;
      }
    }
  }
  __decorate30([
    model_field({
      "type": "number"
      /*, defaultValue : 0*/
    })
  ], HasEffortMixin2.prototype, "effort", void 0);
  __decorate30([
    model_field({ "type": "string", defaultValue: TimeUnit.Hour }, { converter: (unit) => DateHelper.normalizeUnit(unit) || TimeUnit.Hour })
  ], HasEffortMixin2.prototype, "effortUnit", void 0);
  __decorate30([
    write("effort")
  ], HasEffortMixin2.prototype, "writeEffort", null);
  __decorate30([
    calculate("effort")
  ], HasEffortMixin2.prototype, "calculateEffort", null);
  return HasEffortMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_pro/HasEffortDispatcher.js
var EffortVar = Symbol("EffortVar");
var UnitsVar = Symbol("UnitsVar");
var effortFormula = Formula.new({
  output: EffortVar,
  inputs: /* @__PURE__ */ new Set([StartDateVar, EndDateVar, UnitsVar])
});
var unitsFormula = Formula.new({
  output: UnitsVar,
  inputs: /* @__PURE__ */ new Set([StartDateVar, EndDateVar, EffortVar])
});
var endDateByEffortFormula = Formula.new({
  output: EndDateVar,
  inputs: /* @__PURE__ */ new Set([StartDateVar, EffortVar, UnitsVar])
});
var startDateByEffortFormula = Formula.new({
  output: StartDateVar,
  inputs: /* @__PURE__ */ new Set([EndDateVar, EffortVar, UnitsVar])
});
var SEDWUDispatcher = class extends SEDDispatcher {
};
var SEDWUDispatcherIdentifier = class extends SEDDispatcherIdentifier {
  equality(v1, v2) {
    const resolution1 = v1.resolution;
    const resolution2 = v2.resolution;
    return (v1 !== TombStone || v2 === TombStone) && (v1 === TombStone || v2 !== TombStone) && resolution1.get(EffortVar) === resolution2.get(EffortVar) && resolution1.get(UnitsVar) === resolution2.get(UnitsVar) && super.equality(v1, v2);
  }
};

// ../Engine/lib/Engine/quark/model/scheduler_pro/HasSchedulingModeMixin.js
var __decorate31 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HasSchedulingModeMixin = class extends Mixin([HasEffortMixin], (base) => {
  const superProto = base.prototype;
  class HasSchedulingModeMixin2 extends base {
    *calculateSchedulingMode() {
      return (yield ProposedOrPrevious) || SchedulingMode.Normal;
    }
    *effectiveSchedulingMode() {
      const assignmentsByCalendar = yield this.$.assignmentsByCalendar;
      return assignmentsByCalendar.size > 0 ? yield this.$.schedulingMode : SchedulingMode.Normal;
    }
    effectiveSchedulingModeSync(Y) {
      const assignmentsByCalendar = Y(this.$.assignmentsByCalendar);
      return assignmentsByCalendar.size > 0 ? Y(this.$.schedulingMode) : SchedulingMode.Normal;
    }
    *prepareDispatcher(YIELD) {
      const schedulingMode = yield* this.effectiveSchedulingMode();
      if (schedulingMode !== SchedulingMode.Normal) {
        const cycleDispatcher = yield* superProto.prepareDispatcher.call(this, YIELD);
        cycleDispatcher.collectInfo(YIELD, this.$.effort, EffortVar);
        if (yield* this.hasProposedValueForUnits())
          cycleDispatcher.addProposedValueFlag(UnitsVar);
        cycleDispatcher.addPreviousValueFlag(UnitsVar);
        return cycleDispatcher;
      } else {
        return yield* superProto.prepareDispatcher.call(this, YIELD);
      }
    }
    dispatcherClass(Y) {
      const schedulingMode = this.effectiveSchedulingModeSync(Y);
      if (schedulingMode !== SchedulingMode.Normal) {
        return SEDWUDispatcher;
      } else {
        return superProto.dispatcherClass.call(this, Y);
      }
    }
    buildProposedDispatcher(me, quark, transaction) {
      const dispatcher = superProto.buildProposedDispatcher.call(this, me, quark, transaction);
      dispatcher.addPreviousValueFlag(EffortVar);
      dispatcher.addPreviousValueFlag(UnitsVar);
      return dispatcher;
    }
    *calculateAssignmentUnits(assignment) {
      const schedulingMode = yield* this.effectiveSchedulingMode();
      if (schedulingMode !== SchedulingMode.Normal) {
        const dispatch = yield this.$.dispatcher;
        const formulaId = dispatch.resolution.get(UnitsVar);
        if (formulaId === CalculateProposed) {
          return yield* this.calculateAssignmentUnitsProposed(assignment);
        } else if (formulaId === unitsFormula.formulaId) {
          return yield* this.calculateAssignmentUnitsPure(assignment);
        } else {
          throw new Error("Unknown formula for `units`");
        }
      } else {
        return yield* superProto.calculateAssignmentUnits.call(this, assignment);
      }
    }
    *calculateEffort() {
      const schedulingMode = yield* this.effectiveSchedulingMode();
      if (schedulingMode !== SchedulingMode.Normal) {
        const dispatch = yield this.$.dispatcher;
        const formulaId = dispatch.resolution.get(EffortVar);
        if (formulaId === CalculateProposed) {
          return yield* this.calculateEffortProposed();
        } else if (formulaId === effortFormula.formulaId) {
          return yield* this.calculateEffortPure();
        } else {
          throw new Error("Unknown formula for `effort`");
        }
      } else {
        return yield* superProto.calculateEffort.call(this);
      }
    }
    *calculateStartDate() {
      const schedulingMode = yield* this.effectiveSchedulingMode();
      if (schedulingMode !== SchedulingMode.Normal) {
        const dispatch = yield this.$.dispatcher;
        const formulaId = dispatch.resolution.get(StartDateVar);
        if (formulaId === startDateByEffortFormula.formulaId) {
          return yield* this.calculateProjectedXDateByEffort(yield this.$.endDate, false);
        } else {
          return yield* superProto.calculateStartDate.call(this);
        }
      } else {
        return yield* superProto.calculateStartDate.call(this);
      }
    }
    *calculateEndDate() {
      const schedulingMode = yield* this.effectiveSchedulingMode();
      if (schedulingMode !== SchedulingMode.Normal) {
        const dispatch = yield this.$.dispatcher;
        const formulaId = dispatch.resolution.get(EndDateVar);
        if (formulaId === endDateByEffortFormula.formulaId) {
          return yield* this.calculateProjectedXDateByEffort(yield this.$.startDate, true);
        } else {
          return yield* superProto.calculateEndDate.call(this);
        }
      } else {
        return yield* superProto.calculateEndDate.call(this);
      }
    }
    *calculateEffectiveDuration() {
      const dispatch = yield this.$.dispatcher;
      const schedulingMode = yield* this.effectiveSchedulingMode();
      const durationResolution = dispatch.resolution.get(DurationVar);
      const effortResolution = dispatch.resolution.get(EffortVar);
      let effectiveDurationToUse;
      if (durationResolution === durationFormula.formulaId && schedulingMode != SchedulingMode.Normal) {
        const proposedOrPreviousStartDate = yield ProposedOrPreviousValueOf(this.$.startDate);
        const proposedOrPreviousEndDate = yield ProposedOrPreviousValueOf(this.$.endDate);
        const startDateResolution = dispatch.resolution.get(StartDateVar);
        const endDateResolution = dispatch.resolution.get(EndDateVar);
        const effortDriven = yield this.$.effortDriven;
        if (proposedOrPreviousEndDate && startDateResolution === startDateByEffortFormula.formulaId) {
          effectiveDurationToUse = yield* this.calculateProjectedDuration(yield* this.calculateProjectedXDateByEffort(proposedOrPreviousEndDate, false), proposedOrPreviousEndDate);
        } else if (proposedOrPreviousStartDate && endDateResolution === endDateByEffortFormula.formulaId) {
          effectiveDurationToUse = yield* this.calculateProjectedDuration(proposedOrPreviousStartDate, yield* this.calculateProjectedXDateByEffort(proposedOrPreviousStartDate, true));
        } else if (proposedOrPreviousStartDate && proposedOrPreviousEndDate || !proposedOrPreviousStartDate && !proposedOrPreviousEndDate) {
          effectiveDurationToUse = yield* superProto.calculateEffectiveDuration.call(this);
        }
      } else
        effectiveDurationToUse = yield* superProto.calculateEffectiveDuration.call(this);
      return effectiveDurationToUse;
    }
  }
  __decorate31([
    model_field({ "type": "boolean", defaultValue: false })
  ], HasSchedulingModeMixin2.prototype, "effortDriven", void 0);
  __decorate31([
    model_field({ type: "string", defaultValue: SchedulingMode.Normal }, { sync: true })
  ], HasSchedulingModeMixin2.prototype, "schedulingMode", void 0);
  __decorate31([
    field({ identifierCls: SEDWUDispatcherIdentifier })
  ], HasSchedulingModeMixin2.prototype, "dispatcher", void 0);
  __decorate31([
    calculate("schedulingMode")
  ], HasSchedulingModeMixin2.prototype, "calculateSchedulingMode", null);
  __decorate31([
    calculate("effort")
  ], HasSchedulingModeMixin2.prototype, "calculateEffort", null);
  __decorate31([
    calculate("startDate")
  ], HasSchedulingModeMixin2.prototype, "calculateStartDate", null);
  __decorate31([
    calculate("endDate")
  ], HasSchedulingModeMixin2.prototype, "calculateEndDate", null);
  return HasSchedulingModeMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_pro/scheduling_modes/FixedDurationDispatcher.js
var fixedDurationSEDWUGraphDescription = CycleDescription.new({
  variables: /* @__PURE__ */ new Set([StartDateVar, EndDateVar, DurationVar, EffortVar, UnitsVar]),
  formulas: /* @__PURE__ */ new Set([
    startDateFormula,
    endDateFormula,
    durationFormula,
    unitsFormula,
    effortFormula
  ])
});
var fixedDurationAndEffortSEDWUGraphDescription = CycleDescription.new({
  variables: /* @__PURE__ */ new Set([StartDateVar, EndDateVar, DurationVar, EffortVar, UnitsVar]),
  formulas: /* @__PURE__ */ new Set([
    startDateFormula,
    endDateFormula,
    durationFormula,
    unitsFormula
  ])
});
var fixedDurationSEDWUForwardNonEffortDriven = CycleResolution.new({
  description: fixedDurationSEDWUGraphDescription,
  defaultResolutionFormulas: /* @__PURE__ */ new Set([endDateFormula, effortFormula])
});
var fixedDurationSEDWUForwardEffortDriven = CycleResolution.new({
  description: fixedDurationAndEffortSEDWUGraphDescription,
  defaultResolutionFormulas: /* @__PURE__ */ new Set([endDateFormula, unitsFormula])
});
var fixedDurationSEDWUBackwardNonEffortDriven = CycleResolution.new({
  description: fixedDurationSEDWUGraphDescription,
  defaultResolutionFormulas: /* @__PURE__ */ new Set([startDateFormula, effortFormula])
});
var fixedDurationSEDWUBackwardEffortDriven = CycleResolution.new({
  description: fixedDurationAndEffortSEDWUGraphDescription,
  defaultResolutionFormulas: /* @__PURE__ */ new Set([startDateFormula, unitsFormula])
});

// ../Engine/lib/Engine/quark/model/scheduler_pro/scheduling_modes/FixedDurationMixin.js
var FixedDurationMixin = class extends Mixin([HasSchedulingModeMixin], (base) => {
  const superProto = base.prototype;
  class FixedDurationMixin2 extends base {
    *prepareDispatcher(YIELD) {
      const schedulingMode = yield* this.effectiveSchedulingMode();
      if (schedulingMode === SchedulingMode.FixedDuration) {
        const cycleDispatcher = yield* superProto.prepareDispatcher.call(this, YIELD);
        const effortDriven = yield this.$.effortDriven;
        if (effortDriven)
          cycleDispatcher.addKeepIfPossibleFlag(EffortVar);
        if (yield HasProposedValue(this.$.assigned)) {
          if (effortDriven) {
            cycleDispatcher.addProposedValueFlag(EffortVar);
          } else {
            cycleDispatcher.addProposedValueFlag(UnitsVar);
          }
        }
        return cycleDispatcher;
      } else {
        return yield* superProto.prepareDispatcher.call(this, YIELD);
      }
    }
    cycleResolutionContext(Y) {
      const schedulingMode = this.effectiveSchedulingModeSync(Y);
      if (schedulingMode === SchedulingMode.FixedDuration) {
        const direction = Y(this.$.effectiveDirection);
        const effortDriven = Y(this.$.effortDriven);
        if (direction.direction === Direction.Forward || direction.direction === Direction.None) {
          return effortDriven ? fixedDurationSEDWUForwardEffortDriven : fixedDurationSEDWUForwardNonEffortDriven;
        } else {
          return effortDriven ? fixedDurationSEDWUBackwardEffortDriven : fixedDurationSEDWUBackwardNonEffortDriven;
        }
      } else {
        return superProto.cycleResolutionContext.call(this, Y);
      }
    }
    *getBaseOptionsForDurationCalculations() {
      const schedulingMode = yield* this.effectiveSchedulingMode();
      if (schedulingMode === SchedulingMode.FixedDuration) {
        return { ignoreResourceCalendar: true };
      } else {
        return yield* superProto.getBaseOptionsForDurationCalculations.call(this);
      }
    }
  }
  return FixedDurationMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_pro/SchedulerProEvent.js
var SchedulerProEvent = class extends Mixin([
  SchedulerBasicEvent,
  HasDateConstraintMixin,
  HasPercentDoneMixin,
  SchedulerProHasAssignmentsMixin,
  HasEffortMixin,
  HasSchedulingModeMixin,
  FixedDurationMixin,
  ConstrainedEarlyEventMixin,
  ScheduledByDependenciesEarlyEventMixin,
  SplitEventMixin
], (base) => {
  class SchedulerProEvent2 extends base {
    // this seems to cause compilation error in incremental mode (IDE)
    // regular compilation does not produce errors
    // project         : SchedulerProProjectMixin
    static get fields() {
      return [
        { name: "name", type: "string" }
      ];
    }
  }
  return SchedulerProEvent2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_pro/SchedulerProResourceMixin.js
var __decorate32 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ResourceAllocationEventRangeCalendarIntervalMixin = class extends CalendarIntervalMixin {
  // @model_field({ type : 'boolean', defaultValue : true })
  // isWorking : boolean
  // Calendar classes not entering graph, thus not using @model_field
  static get fields() {
    return [
      { name: "isWorking", type: "boolean", defaultValue: true }
    ];
  }
};
var ResourceAllocationEventRangeCalendarIntervalStore = class extends CalendarIntervalStore {
  static get defaultConfig() {
    return {
      modelClass: ResourceAllocationEventRangeCalendarIntervalMixin
    };
  }
};
var ResourceAllocationEventRangeCalendar = class extends BaseCalendarMixin {
  get intervalStoreClass() {
    return ResourceAllocationEventRangeCalendarIntervalStore;
  }
};
__decorate32([
  model_field({ type: "boolean", defaultValue: false })
], ResourceAllocationEventRangeCalendar.prototype, "unspecifiedTimeIsWorking", void 0);
var BaseAllocationInterval = class extends Base {
  constructor() {
    super(...arguments);
    this.effort = 0;
    this.units = 0;
  }
};
var AssignmentAllocationInterval = class extends BaseAllocationInterval {
  constructor() {
    super(...arguments);
    this.inEventTimeSpan = false;
  }
};
var ResourceAllocationInterval = class extends BaseAllocationInterval {
  constructor() {
    super(...arguments);
    this.maxEffort = 0;
    this.isOverallocated = false;
    this.isUnderallocated = false;
    this.inEventTimeSpan = false;
    this.assignments = null;
    this.assignmentIntervals = null;
  }
};
var BaseAllocationInfo = class extends Entity.mix(Base) {
  getDefaultAllocationIntervalClass() {
    return BaseAllocationInterval;
  }
  initialize(props) {
    props = Object.assign({
      includeInactiveEvents: false,
      allocationIntervalClass: this.getDefaultAllocationIntervalClass()
    }, props);
    super.initialize(props);
  }
};
__decorate32([
  field()
], BaseAllocationInfo.prototype, "includeInactiveEvents", void 0);
__decorate32([
  field()
], BaseAllocationInfo.prototype, "allocation", void 0);
var ResourceAllocationInfo = class extends BaseAllocationInfo {
  enterGraph(graph) {
    super.enterGraph(graph);
  }
  leaveGraph(graph) {
    var _a2, _b;
    if (this.eventRangesCalendar) {
      (_a2 = this.resource) == null ? void 0 : _a2.getProject().clearCombinationsWith(this.eventRangesCalendar);
    }
    super.leaveGraph(graph);
    (_b = this.resource) == null ? void 0 : _b.entities.delete(this);
  }
  getDefaultAllocationIntervalClass() {
    return ResourceAllocationInterval;
  }
  *shouldIncludeAssignmentInAllocation(assignment) {
    const event = yield assignment.$.event, includeInactiveEvents = yield this.$.includeInactiveEvents, inactive = event && (yield event.$.inactive), startDate = event && (yield event.$.startDate), endDate = event && (yield event.$.endDate);
    return Boolean(event && startDate && endDate && (includeInactiveEvents || !inactive));
  }
  *calculateAllocation() {
    var _a2;
    const total = [], ticksCalendar = yield this.ticks, resource = yield this.$.resource, includeInactiveEvents = yield this.$.includeInactiveEvents, assignments = yield resource.$.assigned, calendar = yield resource.$.effectiveCalendar, assignmentsByCalendar = /* @__PURE__ */ new Map(), eventRanges = [], assignmentTicksData = /* @__PURE__ */ new Map(), byAssignments = /* @__PURE__ */ new Map();
    let hasIgnoreResourceCalendarEvent = false, weightedUnitsSum, weightsSum, lastTick;
    for (const assignment of assignments) {
      if (!(yield* this.shouldIncludeAssignmentInAllocation(assignment)))
        continue;
      yield assignment.$.units;
      const event = yield assignment.$.event;
      const ignoreResourceCalendar = yield event.$.ignoreResourceCalendar;
      const startDate2 = yield event.$.startDate;
      const endDate2 = yield event.$.endDate;
      const segments = yield event.$.segments;
      const eventCalendar = yield event.$.effectiveCalendar;
      hasIgnoreResourceCalendarEvent = hasIgnoreResourceCalendarEvent || ignoreResourceCalendar;
      if (segments) {
        for (const segment of segments) {
          const startDate3 = yield segment.$.startDate;
          const endDate3 = yield segment.$.endDate;
          eventRanges.push({ startDate: startDate3, endDate: endDate3, assignment });
        }
      } else {
        eventRanges.push({ startDate: startDate2, endDate: endDate2, assignment });
      }
      let assignments2 = assignmentsByCalendar.get(eventCalendar);
      if (!assignments2) {
        assignments2 = [];
        assignmentsByCalendar.set(eventCalendar, assignments2);
      }
      assignmentTicksData.set(assignment, /* @__PURE__ */ new Map());
      byAssignments.set(assignment, []);
      assignments2.push(assignment);
    }
    if (this.eventRangesCalendar) {
      (_a2 = this.resource) == null ? void 0 : _a2.getProject().clearCombinationsWith(this.eventRangesCalendar);
    }
    const eventRangesCalendar = this.eventRangesCalendar = new ResourceAllocationEventRangeCalendar({ intervals: eventRanges });
    const calendars = [ticksCalendar, eventRangesCalendar, ...assignmentsByCalendar.keys()];
    const ticksData = /* @__PURE__ */ new Map();
    ticksCalendar.intervalStore.forEach((tick) => {
      const tickData = ResourceAllocationInterval.new({ tick, resource });
      ticksData.set(tick, tickData);
      total.push(tickData);
      assignmentTicksData.forEach((ticksData2, assignment) => {
        const assignmentTickData = AssignmentAllocationInterval.new({ tick, assignment });
        ticksData2.set(tick, assignmentTickData);
        byAssignments.get(assignment).push(assignmentTickData);
      });
    });
    const startDate = total[0].tick.startDate, endDate = total[total.length - 1].tick.endDate, iterationOptions = {
      startDate,
      endDate,
      calendars,
      includeNonWorkingIntervals: hasIgnoreResourceCalendarEvent
    }, ticksTotalDuration = endDate.getTime() - startDate.getTime();
    if (ticksTotalDuration > resource.getProject().maxCalendarRange) {
      iterationOptions.maxRange = ticksTotalDuration;
    }
    yield* resource.forEachAvailabilityInterval(iterationOptions, (intervalStartDate, intervalEndDate, intervalData) => {
      const isWorkingCalendar = intervalData.getCalendarsWorkStatus();
      if (isWorkingCalendar.get(ticksCalendar)) {
        const tick = intervalData.intervalsByCalendar.get(ticksCalendar)[0], intervalDuration = intervalEndDate.getTime() - intervalStartDate.getTime(), tickData = ticksData.get(tick), tickAssignments = tickData.assignments || /* @__PURE__ */ new Set(), tickAssignmentIntervals = tickData.assignmentIntervals || /* @__PURE__ */ new Map();
        if (lastTick && lastTick !== tick) {
          const lastTicksData = ticksData.get(lastTick);
          lastTicksData.isUnderallocated = lastTicksData.isUnderallocated || lastTicksData.effort && lastTicksData.effort < lastTicksData.maxEffort;
        }
        lastTick = tick;
        if (!tickData.assignments) {
          weightedUnitsSum = 0;
          weightsSum = 0;
        }
        let units = 0, intervalHasAssignments = false, duration, intervalEffort = 0;
        intervalData.intervalsByCalendar.get(eventRangesCalendar).forEach((interval) => {
          const assignment = interval.assignment;
          const event = assignment == null ? void 0 : assignment.event;
          if (event && isWorkingCalendar.get(event.effectiveCalendar) && /* !hasIgnoreResourceCalendarEvent || */
          (event.ignoreResourceCalendar || isWorkingCalendar.get(calendar))) {
            const workingStartDate = Math.max(intervalStartDate.getTime(), assignment.event.startDate.getTime());
            const workingEndDate = Math.min(intervalEndDate.getTime(), assignment.event.endDate.getTime());
            intervalHasAssignments = true;
            duration = workingEndDate - workingStartDate;
            const assignmentInterval = assignmentTicksData.get(assignment).get(tick);
            const assignmentEffort = duration * assignment.units / 100;
            assignmentInterval.effort += assignmentEffort;
            assignmentInterval.units = assignment.units;
            assignmentInterval.inEventTimeSpan = true;
            intervalEffort += assignmentEffort;
            units += assignment.units;
            tickAssignments.add(assignment);
            tickAssignmentIntervals.set(assignment, assignmentInterval);
          }
        });
        tickData.inEventTimeSpan = tickData.inEventTimeSpan || intervalHasAssignments;
        if (isWorkingCalendar.get(calendar)) {
          tickData.maxEffort += intervalDuration;
        }
        if (units) {
          if (duration) {
            weightedUnitsSum += duration * units;
            weightsSum += duration;
            tickData.units = weightedUnitsSum / weightsSum;
          } else if (!weightedUnitsSum) {
            tickData.units = units;
          }
        }
        if (intervalHasAssignments) {
          tickData.effort += intervalEffort;
          tickData.assignments = tickAssignments;
          tickData.assignmentIntervals = tickAssignmentIntervals;
          tickData.isOverallocated = tickData.isOverallocated || tickData.effort > tickData.maxEffort || tickData.units > 100;
          tickData.isUnderallocated = tickData.isUnderallocated || intervalEffort < intervalDuration || tickData.units < 100;
        }
      }
    });
    if (lastTick) {
      const lastTicksData = ticksData.get(lastTick);
      lastTicksData.isUnderallocated = lastTicksData.isUnderallocated || lastTicksData.effort && lastTicksData.effort < lastTicksData.maxEffort;
    }
    return {
      owner: this,
      resource,
      total,
      byAssignments
    };
  }
};
__decorate32([
  field()
], ResourceAllocationInfo.prototype, "resource", void 0);
__decorate32([
  calculate("allocation")
], ResourceAllocationInfo.prototype, "calculateAllocation", null);
var SchedulerProResourceMixin = class extends Mixin([BaseResourceMixin], (base) => {
  const superProto = base.prototype;
  class SchedulerProResourceMixin2 extends base {
    constructor() {
      super(...arguments);
      this.observers = /* @__PURE__ */ new Set();
      this.entities = /* @__PURE__ */ new Set();
    }
    addObserver(observer) {
      this.graph.addIdentifier(observer);
      this.observers.add(observer);
    }
    removeObserver(observer) {
      if (this.graph) {
        this.graph.removeIdentifier(observer);
      }
      this.observers.delete(observer);
    }
    addEntity(entity2) {
      this.graph.addEntity(entity2);
      this.entities.add(entity2);
    }
    removeEntity(entity2) {
      if (this.graph) {
        this.graph.removeEntity(entity2);
      }
      this.entities.delete(entity2);
    }
    leaveGraph(replica) {
      const { graph } = this;
      for (const observer of this.observers) {
        this.removeObserver(observer);
      }
      for (const entity2 of this.entities) {
        this.removeEntity(entity2);
      }
      superProto.leaveGraph.call(this, replica);
    }
    *forEachAvailabilityInterval(options, func) {
      const project = this.getProject();
      const calendar = yield this.$.effectiveCalendar;
      const effectiveCalendarsCombination = project.combineCalendars([calendar].concat(options.calendars || []));
      const maxRange = project.maxCalendarRange;
      const includeNonWorkingIntervals = options.includeNonWorkingIntervals;
      if (maxRange) {
        options = Object.assign({ maxRange }, options);
      }
      return effectiveCalendarsCombination.forEachAvailabilityInterval(options, (startDate, endDate, calendarCacheIntervalMultiple) => {
        const calendarsStatus = calendarCacheIntervalMultiple.getCalendarsWorkStatus();
        if (includeNonWorkingIntervals || calendarsStatus.get(calendar)) {
          return func(startDate, endDate, calendarCacheIntervalMultiple);
        }
      });
    }
  }
  return SchedulerProResourceMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_pro/SchedulerProProjectMixin.js
var __decorate33 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SchedulerProProjectMixin = class extends Mixin([SchedulerBasicProjectMixin, ConstrainedEarlyEventMixin, HasChildrenMixin], (base) => {
  const superProto = base.prototype;
  class SchedulerProProjectMixin2 extends base {
    construct(config = {}) {
      var _a2;
      this.eventSegmentModelClass = config.eventSegmentModelClass || this.getDefaultEventSegmentModelClass();
      superProto.construct.call(this, config);
      this.includeAsapAlapAsConstraints = (_a2 = config.includeAsapAlapAsConstraints) != null ? _a2 : true;
      if (!this.resourceAllocationInfoClass)
        this.resourceAllocationInfoClass = this.getDefaultResourceAllocationInfoClass();
    }
    getDefaultEventStoreClass() {
      return ChronoEventStoreMixin;
    }
    getDefaultEventSegmentModelClass() {
      return SchedulerProEventSegment;
    }
    getDefaultResourceAllocationInfoClass() {
      return ResourceAllocationInfo;
    }
    afterConfigure() {
      superProto.afterConfigure.apply(this, arguments);
      this.dateConstraintIntervalClass = this.dateConstraintIntervalClass || DateConstraintInterval;
      this.dependencyConstraintIntervalClass = this.dependencyConstraintIntervalClass || DependencyConstraintInterval;
    }
    getType() {
      return ProjectType.SchedulerPro;
    }
    getDefaultCycleEffectClass() {
      return SchedulerProCycleEffect;
    }
    getDefaultEventModelClass() {
      return SchedulerProEvent;
    }
    getDefaultDependencyModelClass() {
      return SchedulerProDependencyMixin;
    }
    getDefaultAssignmentModelClass() {
      return SchedulerProAssignmentMixin;
    }
    getDefaultResourceModelClass() {
      return SchedulerProResourceMixin;
    }
    /**
     * Validates a hypothetical dependency with provided parameters.
     *
     * ```typescript
     * // let's check if a EndToStart dependency linking event1 with event2 will be valid
     * const validationResult = await project.validateDependency(event1, event2, DependencyType.EndToStart);
     *
     * switch (validationResult) {
     *     const DependencyValidationResult.CyclicDependency :
     *         console.log('Dependency builds a cycle');
     *         break;
     *
     *     const DependencyValidationResult.DuplicatingDependency :
     *         console.log('Such dependency already exists');
     *         break;
     *
     *     const DependencyValidationResult.NoError :
     *         console.log('Dependency is valid');
     * }
     * ```
     *
     * See also [[isValidDependency]] method for more basic usage.
     *
     * @param fromEvent The dependency predecessor
     * @param toEvent The dependency successor
     * @param type The dependency type
     * @param ignoreDependency Dependencies to ignore while validating. This parameter can be used for example if one plans to change
     * an existing dependency properties and wants to know if the change will lead to an error:
     *
     * ```typescript
     * // let's check if changing of the dependency predecessor to newPredecessor will make it invalid
     * const validationResult = await project.validateDependency(newPredecessor, dependency.toEvent, dependency.type, dependency);
     *
     * if (validationResult !== DependencyValidationResult.NoError) console.log("The dependency is invalid");
     * ```
     * @return The validation result
     */
    async validateDependency(fromEvent, toEvent, type, ignoreDependency) {
      let ingoredDependencies;
      if (ignoreDependency) {
        ingoredDependencies = Array.isArray(ignoreDependency) ? ignoreDependency : [ignoreDependency];
      }
      const alreadyLinked = CI(fromEvent.outgoingDeps).some((dependency) => dependency.toEvent === toEvent && !(ingoredDependencies == null ? void 0 : ingoredDependencies.includes(dependency)));
      if (alreadyLinked)
        return DependencyValidationResult.DuplicatingDependency;
      if (await this.isDependencyCyclic(fromEvent, toEvent, type, ingoredDependencies)) {
        return DependencyValidationResult.CyclicDependency;
      }
      return DependencyValidationResult.NoError;
    }
    /**
     * Validates a hypothetical dependency with provided parameters.
     *
     * ```typescript
     * // let's check if a EndToStart dependency linking event1 with event2 will be valid
     * if (await project.isValidDependency(event1, event2, DependencyType.EndToStart)) {
     *     console.log('Dependency is valid');
     * } else {
     *     console.log('Dependency is invalid');
     * }
     * ```
     *
     * See also [[validateDependency]] method for more detailed validation results.
     *
     * @param fromEvent The dependency predecessor
     * @param toEvent The dependency successor
     * @param type The dependency type
     * @param ignoreDependency Dependencies to ignore while validating. This parameter can be used for example if one plans to change
     * an existing dependency properties and wants to know if the change will lead to an error:
     *
     * ```typescript
     * // let's check if changing of the dependency predecessor to newPredecessor will make it invalid
     * if (await project.isValidDependency(newPredecessor, dependency.toEvent, dependency.type, dependency)) console.log("The dependency is valid");
     * ```
     * @return The validation result
     */
    // this does not account for possible scheduling conflicts
    async isValidDependency(fromEvent, toEvent, type, ignoreDependency) {
      const validationResult = await this.validateDependency(fromEvent, toEvent, type, ignoreDependency);
      return validationResult === DependencyValidationResult.NoError;
    }
    getDependencyCycleDetectionIdentifiers(fromEvent, toEvent) {
      return [
        // @ts-ignore
        toEvent.$.earlyStartDateConstraintIntervals,
        // @ts-ignore
        toEvent.$.earlyEndDateConstraintIntervals
      ];
    }
    async isDependencyCyclic(fromEvent, toEvent, type, ignoreDependency) {
      const dependencyClass = this.getDependencyStore().modelClass;
      const dependency = new dependencyClass({ fromEvent, toEvent, type });
      const branch = this.replica.branch({ autoCommit: false, onComputationCycle: "throw" });
      if (ignoreDependency) {
        if (!Array.isArray(ignoreDependency)) {
          ignoreDependency = [ignoreDependency];
        }
        ignoreDependency.forEach((dependency2) => branch.removeEntity(dependency2));
      }
      branch.addEntity(dependency);
      dependency.project = this;
      try {
        await Promise.all(this.getDependencyCycleDetectionIdentifiers(fromEvent, toEvent).map((i) => branch.readAsync(i)));
        return false;
      } catch (e) {
        if (/cycle/i.test(e))
          return true;
        if (!/conflict/i.test(e)) {
          throw e;
        }
      }
    }
    // work in progress
    // This method validates changes (e.g. type) for existing dependencies (which are already in the store)
    async isValidDependencyModel(dependency, ignoreDependencies) {
      return this.isValidDependency(dependency.fromEvent, dependency.toEvent, dependency.type, ignoreDependencies);
    }
  }
  __decorate33([
    model_field({ type: "string", defaultValue: DependenciesCalendar.ToEvent })
  ], SchedulerProProjectMixin2.prototype, "dependenciesCalendar", void 0);
  __decorate33([
    model_field({ type: "boolean", defaultValue: true })
  ], SchedulerProProjectMixin2.prototype, "autoCalculatePercentDoneForParentTasks", void 0);
  __decorate33([
    model_field({ type: "boolean", defaultValue: true })
  ], SchedulerProProjectMixin2.prototype, "addConstraintOnDateSet", void 0);
  return SchedulerProProjectMixin2;
}) {
};
var DeactivateDependencyCycleEffectResolution = class extends Localizable_default(SchedulingIssueEffectResolution) {
  static get $name() {
    return "DeactivateDependencyCycleEffectResolution";
  }
  getDescription() {
    return this.L("L{descriptionTpl}");
  }
  resolve(dependency) {
    dependency.active = false;
  }
};
var SchedulerProCycleEffect = class extends CycleEffect {
  /**
   * Returns dependencies taking part in the cycle that are treated as invalid.
   * For example a "parent-child" dependency or a dependency linking a task to itself.
   */
  getInvalidDependencies() {
    if (!this._invalidDependencies) {
      const dependencies = this.getDependencies();
      this._invalidDependencies = dependencies.filter((dependency) => (
        // @ts-ignore
        dependency.fromEvent === dependency.toEvent || (dependency.fromEvent.contains(dependency.toEvent) || dependency.toEvent.contains(dependency.fromEvent))
      ));
    }
    return this._invalidDependencies;
  }
  buildInvalidDependencyResolutions(config) {
    return [
      this.removeDependencyConflictResolutionClass.new(config),
      this.deactivateDependencyConflictResolutionClass.new(config)
    ];
  }
  matchDependencyBySourceAndTargetEvent(dependency, from, to) {
    return dependency.active && super.matchDependencyBySourceAndTargetEvent(dependency, from, to);
  }
  getResolutions() {
    if (!this._resolutions) {
      const invalidDependencies = this.getInvalidDependencies();
      const result = [];
      for (const dependency of invalidDependencies) {
        result.push(...this.buildInvalidDependencyResolutions({ dependency }));
      }
      if (!invalidDependencies.length) {
        result.push(this.deactivateDependencyCycleEffectResolutionClass.new(), ...super.getResolutions());
      }
      this._resolutions = result;
    }
    return this._resolutions;
  }
};
__decorate33([
  prototypeValue(DeactivateDependencyCycleEffectResolution)
], SchedulerProCycleEffect.prototype, "deactivateDependencyCycleEffectResolutionClass", void 0);
__decorate33([
  prototypeValue(RemoveDependencyResolution)
], SchedulerProCycleEffect.prototype, "removeDependencyConflictResolutionClass", void 0);
__decorate33([
  prototypeValue(DeactivateDependencyResolution)
], SchedulerProCycleEffect.prototype, "deactivateDependencyConflictResolutionClass", void 0);

// ../Engine/lib/Engine/quark/model/gantt/ConstrainedByParentMixin.js
var __decorate34 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ConstrainedByParentMixin = class extends Mixin([BaseEventMixin, HasChildrenMixin, ConstrainedEarlyEventMixin], (base) => {
  const superProto = base.prototype;
  class ConstrainedByParentMixin2 extends base {
    *maybeSkipNonWorkingTime(date, isForward = true) {
      const childEvents = yield this.$.childEvents;
      if (childEvents.size > 0)
        return date;
      return yield* superProto.maybeSkipNonWorkingTime.call(this, date, isForward);
    }
    *calculateStartDateConstraintIntervals() {
      const intervals = yield* superProto.calculateStartDateConstraintIntervals.call(this);
      const parentEvent = yield this.$.parentEvent;
      if (parentEvent == null ? void 0 : parentEvent.graph) {
        const parentIntervals = yield parentEvent.$.startDateConstraintIntervals;
        intervals.push.apply(intervals, parentIntervals);
      }
      return intervals;
    }
    *calculateEndDateConstraintIntervals() {
      const intervals = yield* superProto.calculateEndDateConstraintIntervals.call(this);
      const parentEvent = yield this.$.parentEvent;
      if (parentEvent == null ? void 0 : parentEvent.graph) {
        const parentIntervals = yield parentEvent.$.endDateConstraintIntervals;
        intervals.push.apply(intervals, parentIntervals);
      }
      return intervals;
    }
    *calculateEarlyStartDateConstraintIntervals() {
      const intervals = yield* superProto.calculateEarlyStartDateConstraintIntervals.call(this);
      const parentEvent = yield this.$.parentEvent;
      if (parentEvent == null ? void 0 : parentEvent.graph) {
        const parentIntervals = yield parentEvent.$.earlyStartDateConstraintIntervals;
        intervals.push.apply(intervals, parentIntervals);
        if ((yield parentEvent.$.manuallyScheduled) && (yield this.$.effectiveDirection).direction === Direction.Forward) {
          intervals.push(ManuallyScheduledParentConstraintInterval.new({
            owner: parentEvent,
            side: ConstraintIntervalSide.Start,
            startDate: yield parentEvent.$.startDate
          }));
        }
      }
      return intervals;
    }
    *calculateEarlyEndDateConstraintIntervals() {
      const intervals = yield* superProto.calculateEarlyEndDateConstraintIntervals.call(this);
      const parentEvent = yield this.$.parentEvent;
      if (parentEvent == null ? void 0 : parentEvent.graph) {
        const parentIntervals = yield parentEvent.$.earlyEndDateConstraintIntervals;
        intervals.push.apply(intervals, parentIntervals);
      }
      return intervals;
    }
  }
  return ConstrainedByParentMixin2;
}) {
};
var DisableManuallyScheduledConflictResolution = class extends Localizable_default(ConflictResolution) {
  static get $name() {
    return "RemoveManuallyScheduledParentConstraintConflictResolution";
  }
  construct() {
    super.construct(...arguments);
    this.event = this.interval.owner;
  }
  getDescription() {
    const { event } = this;
    return format(this.L("L{descriptionTpl}"), event.name || event.id);
  }
  /**
   * Resolves the conflict by setting the event [[ConstrainedByParentMixin.manuallyScheduled|manuallyScheduled]] to `false`.
   */
  resolve() {
    this.event.manuallyScheduled = false;
  }
};
var ManuallyScheduledParentConstraintIntervalDescription = class extends ConstraintIntervalDescription {
  static get $name() {
    return "ManuallyScheduledParentConstraintIntervalDescription";
  }
  /**
   * Returns description for the provided event constraint interval.
   * @param interval Constraint interval
   */
  static getDescription(interval) {
    let tpl;
    switch (interval.side) {
      case ConstraintIntervalSide.Start:
        tpl = this.L("L{startDescriptionTpl}");
        break;
      case ConstraintIntervalSide.End:
        tpl = this.L("L{endDescriptionTpl}");
        break;
    }
    return format(tpl, ...this.getDescriptionParameters(interval));
  }
  static getDescriptionParameters(interval) {
    const event = interval.owner;
    return [
      DateHelper.format(interval.startDate, this.L("L{dateFormat}")),
      DateHelper.format(interval.endDate, this.L("L{dateFormat}")),
      event.name || event.id
    ];
  }
};
var ManuallyScheduledParentConstraintInterval = class extends ConstraintInterval {
  getDescription() {
    return this.descriptionBuilderClass.getDescription(this);
  }
  isAffectedByTransaction(transaction) {
    const event = this.owner;
    transaction = transaction || event.graph.activeTransaction;
    const manuallyScheduledQuark = transaction.entries.get(event.$.manuallyScheduled);
    return !transaction.baseRevision.hasIdentifier(event.$$) || manuallyScheduledQuark && !manuallyScheduledQuark.isShadow();
  }
  /**
   * Returns possible resolution options for cases when
   * the interval takes part in a conflict.
   *
   * The interval suggests the only resolution option - disabling manual scheduling.
   */
  getResolutions() {
    return this.resolutions || (this.resolutions = [
      this.resetManuallyScheduledConflictResolutionClass.new({ interval: this })
    ]);
  }
};
__decorate34([
  prototypeValue(DisableManuallyScheduledConflictResolution)
], ManuallyScheduledParentConstraintInterval.prototype, "resetManuallyScheduledConflictResolutionClass", void 0);
__decorate34([
  prototypeValue(ManuallyScheduledParentConstraintIntervalDescription)
], ManuallyScheduledParentConstraintInterval.prototype, "descriptionBuilderClass", void 0);

// ../Engine/lib/Engine/quark/model/gantt/ConstrainedLateEventMixin.js
var __decorate35 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ConstrainedLateEventMixin = class extends Mixin([ConstrainedEarlyEventMixin, HasChildrenMixin], (base) => {
  const superProto = base.prototype;
  class ConstrainedLateEventMixin2 extends base {
    /**
     * Calculation method for the [[lateStartDateConstraintIntervals]]. Returns empty array by default.
     * Override this method to return some extra constraints for the start date during the ALAP scheduling.
     */
    *calculateLateStartDateConstraintIntervals() {
      const intervals = [];
      const parentEvent = yield this.$.parentEvent;
      if (parentEvent) {
        const parentIntervals = yield parentEvent.$.lateStartDateConstraintIntervals;
        intervals.push.apply(intervals, parentIntervals);
      }
      return intervals;
    }
    /**
     * Calculation method for the [[lateEndDateConstraintIntervals]]. Returns empty array by default.
     * Override this method to return some extra constraints for the end date during the ALAP scheduling.
     */
    *calculateLateEndDateConstraintIntervals() {
      const intervals = [];
      const parentEvent = yield this.$.parentEvent;
      if (parentEvent) {
        const parentIntervals = yield parentEvent.$.lateEndDateConstraintIntervals;
        intervals.push.apply(intervals, parentIntervals);
        if ((yield parentEvent.$.manuallyScheduled) && (yield this.$.effectiveDirection).direction === Direction.Backward) {
          intervals.push(ManuallyScheduledParentConstraintInterval.new({
            side: ConstraintIntervalSide.End,
            endDate: yield parentEvent.$.endDate
          }));
        }
      }
      return intervals;
    }
    /**
     * The method defines wether the provided child event should be
     * taken into account when calculating this summary event [[lateStartDate]].
     * Child events roll up their [[lateStartDate]] values to their summary tasks.
     * So a summary task [[lateStartDate]] date gets equal to its minimal child [[lateStartDate]].
     *
     * If the method returns `true` the child event is taken into account
     * and if the method returns `false` it's not.
     * By default the method returns `true` to include all child events data.
     * @param childEvent Child event to consider.
     * @returns `true` if the provided event should be taken into account, `false` if not.
     */
    *shouldRollupChildLateStartDate(childEvent) {
      return true;
    }
    *calculateMinChildrenLateStartDate() {
      let result = MAX_DATE;
      const subEventsIterator = yield* this.subEventsIterable();
      for (let childEvent of subEventsIterator) {
        if (!(yield* this.shouldRollupChildLateStartDate(childEvent)))
          continue;
        let childDate;
        if ((yield childEvent.$.manuallyScheduled) && (yield* childEvent.hasSubEvents())) {
          childDate = yield childEvent.$.minChildrenLateStartDate;
        }
        childDate = childDate || (yield childEvent.$.lateStartDate);
        if (childDate && childDate < result)
          result = childDate;
      }
      return result.getTime() - MAX_DATE.getTime() ? result : null;
    }
    *calculateLateStartDateRaw() {
      if ((yield this.$.manuallyScheduled) && (yield this.$.effectiveDirection).direction === Direction.Backward) {
        return yield this.$.startDate;
      }
      if (yield* this.hasSubEvents()) {
        return yield this.$.minChildrenLateStartDate;
      }
      if (!(yield* this.isConstrainedLate())) {
        return yield this.$.startDate;
      }
      const startDateConstraintIntervals = (yield this.$.lateStartDateConstraintIntervals).concat(yield this.$.startDateConstraintIntervals);
      const endDateConstraintIntervals = (yield this.$.lateEndDateConstraintIntervals).concat(yield this.$.endDateConstraintIntervals);
      let effectiveInterval = yield* this.calculateEffectiveConstraintInterval(true, startDateConstraintIntervals, endDateConstraintIntervals);
      if (effectiveInterval === null) {
        return null;
      } else if (effectiveInterval.isIntervalEmpty()) {
        effectiveInterval = yield* this.calculateEffectiveConstraintInterval(true, startDateConstraintIntervals, endDateConstraintIntervals, true);
        const conflict = ConflictEffect.new({
          intervals: [...effectiveInterval.intersectionOf]
        });
        if ((yield conflict) === EffectResolutionResult.Cancel) {
          yield Reject(conflict);
        } else {
          return null;
        }
      }
      return isDateFinite(effectiveInterval.endDate) ? effectiveInterval.endDate : null;
    }
    /**
     * The method defines wether the provided child event should be
     * taken into account when calculating this summary event [[lateEndDate]].
     * Child events roll up their [[lateEndDate]] values to their summary tasks.
     * So a summary task [[lateEndDate]] gets equal to its maximal child [[lateEndDate]].
     *
     * If the method returns `true` the child event is taken into account
     * and if the method returns `false` it's not.
     * By default the method returns `true` to include all child events data.
     * @param childEvent Child event to consider.
     * @returns `true` if the provided event should be taken into account, `false` if not.
     */
    *shouldRollupChildLateEndDate(childEvent) {
      return true;
    }
    *calculateMaxChildrenLateEndDate() {
      let result = MIN_DATE;
      const subEventsIterator = yield* this.subEventsIterable();
      for (let childEvent of subEventsIterator) {
        if (!(yield* this.shouldRollupChildLateEndDate(childEvent)))
          continue;
        let childDate;
        if ((yield childEvent.$.manuallyScheduled) && (yield* childEvent.hasSubEvents())) {
          childDate = yield childEvent.$.maxChildrenLateEndDate;
        }
        childDate = childDate || (yield childEvent.$.lateEndDate);
        if (childDate && childDate > result)
          result = childDate;
      }
      return result.getTime() - MIN_DATE.getTime() ? result : null;
    }
    *calculateLateStartDate() {
      return yield this.$.lateStartDateRaw;
    }
    *calculateLateEndDateRaw() {
      if ((yield this.$.manuallyScheduled) && (yield this.$.effectiveDirection).direction === Direction.Backward) {
        return yield this.$.endDate;
      }
      if (yield* this.hasSubEvents()) {
        return yield this.$.maxChildrenLateEndDate;
      }
      if (!(yield* this.isConstrainedLate())) {
        return yield this.$.endDate;
      }
      const startDateConstraintIntervals = yield this.$.lateStartDateConstraintIntervals;
      const endDateConstraintIntervals = yield this.$.lateEndDateConstraintIntervals;
      let effectiveInterval = yield* this.calculateEffectiveConstraintInterval(
        false,
        // need to use concat instead of directly mutating the `startDateConstraintIntervals` since that is
        // used as storage for `this.$.lateStartDateConstraintIntervals`
        startDateConstraintIntervals.concat(yield this.$.startDateConstraintIntervals),
        endDateConstraintIntervals.concat(yield this.$.endDateConstraintIntervals)
      );
      if (effectiveInterval === null) {
        return null;
      } else if (effectiveInterval.isIntervalEmpty()) {
        effectiveInterval = yield* this.calculateEffectiveConstraintInterval(
          false,
          // need to use concat instead of directly mutating the `startDateConstraintIntervals` since that is
          // used as storage for `this.$.lateStartDateConstraintIntervals`
          (yield this.$.lateStartDateConstraintIntervals).concat(yield this.$.startDateConstraintIntervals),
          (yield this.$.lateEndDateConstraintIntervals).concat(yield this.$.endDateConstraintIntervals),
          true
        );
        const conflict = ConflictEffect.new({
          intervals: [...effectiveInterval.intersectionOf]
        });
        if ((yield conflict) === EffectResolutionResult.Cancel) {
          yield Reject(conflict);
        } else {
          return null;
        }
      }
      return isDateFinite(effectiveInterval.endDate) ? effectiveInterval.endDate : null;
    }
    *calculateLateEndDate() {
      const date = yield this.$.lateEndDateRaw;
      return yield* this.maybeSkipNonWorkingTime(date, false);
    }
    *calculateTotalSlack() {
      const earlyStartDate = yield this.$.earlyStartDateRaw;
      const lateStartDate = yield this.$.lateStartDateRaw;
      const earlyEndDate = yield this.$.earlyEndDateRaw;
      const lateEndDate = yield this.$.lateEndDateRaw;
      const slackUnit = yield this.$.slackUnit;
      let endSlack, result;
      if (earlyStartDate && lateStartDate || earlyEndDate && lateEndDate) {
        if (earlyStartDate && lateStartDate) {
          result = yield* this.calculateProjectedDuration(earlyStartDate, lateStartDate, slackUnit);
          if (earlyEndDate && lateEndDate) {
            endSlack = yield* this.calculateProjectedDuration(earlyEndDate, lateEndDate, slackUnit);
            if (endSlack < result)
              result = endSlack;
          }
        } else if (earlyEndDate && lateEndDate) {
          result = yield* this.calculateProjectedDuration(earlyEndDate, lateEndDate, slackUnit);
        }
      }
      return result;
    }
    *calculateCritical() {
      const totalSlack = yield this.$.totalSlack;
      return totalSlack <= 0;
    }
    *isConstrainedLate() {
      const startDateIntervals = yield this.$.startDateConstraintIntervals;
      const endDateIntervals = yield this.$.endDateConstraintIntervals;
      const lateStartDateConstraintIntervals = yield this.$.lateStartDateConstraintIntervals;
      const lateEndDateConstraintIntervals = yield this.$.lateEndDateConstraintIntervals;
      return Boolean((startDateIntervals == null ? void 0 : startDateIntervals.length) || (endDateIntervals == null ? void 0 : endDateIntervals.length) || (lateStartDateConstraintIntervals == null ? void 0 : lateStartDateConstraintIntervals.length) || (lateEndDateConstraintIntervals == null ? void 0 : lateEndDateConstraintIntervals.length));
    }
    *calculateStartDatePure() {
      const direction = yield this.$.effectiveDirection;
      if (direction.direction === Direction.Backward) {
        if (!(yield* this.isConstrainedLate()) || (yield this.$.manuallyScheduled) || (yield this.$.unscheduled)) {
          return yield* superProto.calculateStartDatePure.call(this);
        }
        if (yield* this.hasSubEvents()) {
          return yield* this.calculateMinChildrenStartDate();
        } else
          return yield this.$.lateStartDate;
      } else {
        return yield* superProto.calculateStartDatePure.call(this);
      }
    }
    *calculateStartDateProposed() {
      const direction = yield this.$.effectiveDirection;
      switch (direction.direction) {
        case Direction.Backward:
          if (!(yield* this.isConstrainedLate()) || (yield this.$.manuallyScheduled) || (yield this.$.unscheduled)) {
            return yield* superProto.calculateStartDateProposed.call(this);
          }
          if (yield* this.hasSubEvents()) {
            return yield* this.calculateMinChildrenStartDate();
          }
          return (yield this.$.lateStartDate) || (yield* superProto.calculateStartDateProposed.call(this));
        default:
          return yield* superProto.calculateStartDateProposed.call(this);
      }
    }
    *calculateEndDatePure() {
      const direction = yield this.$.effectiveDirection;
      if (direction.direction === Direction.Backward) {
        if (!(yield* this.isConstrainedLate()) || (yield this.$.manuallyScheduled) || (yield this.$.unscheduled)) {
          return yield* superProto.calculateEndDatePure.call(this);
        }
        if (yield* this.hasSubEvents()) {
          return yield* this.calculateMaxChildrenEndDate();
        } else
          return yield this.$.lateEndDate;
      } else {
        return yield* superProto.calculateEndDatePure.call(this);
      }
    }
    *calculateEndDateProposed() {
      const direction = yield this.$.effectiveDirection;
      switch (direction.direction) {
        case Direction.Backward:
          if (!(yield* this.isConstrainedLate()) || (yield this.$.manuallyScheduled) || (yield this.$.unscheduled)) {
            return yield* superProto.calculateEndDateProposed.call(this);
          }
          if (yield* this.hasSubEvents()) {
            return yield* this.calculateMaxChildrenEndDate();
          }
          return (yield this.$.lateEndDate) || (yield* superProto.calculateEndDateProposed.call(this));
        default:
          return yield* superProto.calculateEndDateProposed.call(this);
      }
    }
  }
  __decorate35([
    field({ lazy: EarlyLateLazyness })
  ], ConstrainedLateEventMixin2.prototype, "minChildrenLateStartDate", void 0);
  __decorate35([
    field({ lazy: EarlyLateLazyness })
  ], ConstrainedLateEventMixin2.prototype, "lateStartDateRaw", void 0);
  __decorate35([
    model_field({ type: "date", persist: false }, { lazy: EarlyLateLazyness, converter: dateConverter, persistent: false })
  ], ConstrainedLateEventMixin2.prototype, "lateStartDate", void 0);
  __decorate35([
    field({ lazy: EarlyLateLazyness })
  ], ConstrainedLateEventMixin2.prototype, "maxChildrenLateEndDate", void 0);
  __decorate35([
    field({ lazy: EarlyLateLazyness })
  ], ConstrainedLateEventMixin2.prototype, "lateEndDateRaw", void 0);
  __decorate35([
    model_field({ type: "date", persist: false }, { lazy: EarlyLateLazyness, converter: dateConverter, persistent: false })
  ], ConstrainedLateEventMixin2.prototype, "lateEndDate", void 0);
  __decorate35([
    field({ lazy: EarlyLateLazyness })
  ], ConstrainedLateEventMixin2.prototype, "lateStartDateConstraintIntervals", void 0);
  __decorate35([
    field({ lazy: EarlyLateLazyness })
  ], ConstrainedLateEventMixin2.prototype, "lateEndDateConstraintIntervals", void 0);
  __decorate35([
    model_field({ type: "number", persist: false }, { lazy: EarlyLateLazyness, persistent: false })
  ], ConstrainedLateEventMixin2.prototype, "totalSlack", void 0);
  __decorate35([
    model_field({ type: "string", defaultValue: TimeUnit.Day, persist: false }, { lazy: EarlyLateLazyness, converter: DateHelper.normalizeUnit, persistent: false })
  ], ConstrainedLateEventMixin2.prototype, "slackUnit", void 0);
  __decorate35([
    model_field({ type: "boolean", defaultValue: false, persist: false }, { persistent: false, lazy: EarlyLateLazyness })
  ], ConstrainedLateEventMixin2.prototype, "critical", void 0);
  __decorate35([
    calculate("lateStartDateConstraintIntervals")
  ], ConstrainedLateEventMixin2.prototype, "calculateLateStartDateConstraintIntervals", null);
  __decorate35([
    calculate("lateEndDateConstraintIntervals")
  ], ConstrainedLateEventMixin2.prototype, "calculateLateEndDateConstraintIntervals", null);
  __decorate35([
    calculate("minChildrenLateStartDate")
  ], ConstrainedLateEventMixin2.prototype, "calculateMinChildrenLateStartDate", null);
  __decorate35([
    calculate("lateStartDateRaw")
  ], ConstrainedLateEventMixin2.prototype, "calculateLateStartDateRaw", null);
  __decorate35([
    calculate("maxChildrenLateEndDate")
  ], ConstrainedLateEventMixin2.prototype, "calculateMaxChildrenLateEndDate", null);
  __decorate35([
    calculate("lateStartDate")
  ], ConstrainedLateEventMixin2.prototype, "calculateLateStartDate", null);
  __decorate35([
    calculate("lateEndDateRaw")
  ], ConstrainedLateEventMixin2.prototype, "calculateLateEndDateRaw", null);
  __decorate35([
    calculate("lateEndDate")
  ], ConstrainedLateEventMixin2.prototype, "calculateLateEndDate", null);
  __decorate35([
    calculate("totalSlack")
  ], ConstrainedLateEventMixin2.prototype, "calculateTotalSlack", null);
  __decorate35([
    calculate("critical")
  ], ConstrainedLateEventMixin2.prototype, "calculateCritical", null);
  return ConstrainedLateEventMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/gantt/ScheduledByDependenciesLateEventMixin.js
var __decorate36 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ScheduledByDependenciesLateEventMixin = class extends Mixin([ScheduledByDependenciesEarlyEventMixin, ConstrainedLateEventMixin], (base) => {
  const superProto = base.prototype;
  class ScheduledByDependenciesLateEventMixin2 extends base {
    *shouldSuccessorAffectScheduling(dependency) {
      const toEvent = yield dependency.$.toEvent;
      return toEvent && !isAtomicValue(toEvent) && (yield dependency.$.active) && (!(yield toEvent.$.inactive) || (yield this.$.inactive));
    }
    *calculateLateStartDateConstraintIntervals() {
      const intervals = yield* superProto.calculateLateStartDateConstraintIntervals.call(this);
      const project = this.getProject();
      const dependencyConstraintIntervalClass = project.dependencyConstraintIntervalClass;
      let dependency;
      for (dependency of yield this.$.outgoingDeps) {
        if (!(yield* this.shouldSuccessorAffectScheduling(dependency)))
          continue;
        const successor = yield dependency.$.toEvent;
        const manuallyScheduled = yield successor.$.manuallyScheduled;
        let successorDate;
        switch (yield dependency.$.type) {
          case DependencyType.StartToStart:
            successorDate = manuallyScheduled ? yield successor.$.startDate : yield successor.$.lateStartDateRaw;
            break;
          case DependencyType.StartToEnd:
            successorDate = manuallyScheduled ? yield successor.$.endDate : yield successor.$.lateEndDateRaw;
            break;
        }
        if (successorDate) {
          const lag = yield dependency.$.lag;
          const lagUnit = yield dependency.$.lagUnit;
          const lagMS = yield* project.$convertDuration(lag, lagUnit, TimeUnit.Millisecond);
          const calendar = yield dependency.$.calendar;
          yield calendar.$.version;
          let endDate = successorDate;
          if (lagMS) {
            endDate = calendar.skipNonWorkingTime(calendar.calculateStartDate(successorDate, lagMS));
          }
          const interval = dependencyConstraintIntervalClass.new({
            owner: dependency,
            startDate: null,
            endDate
          });
          intervals.unshift(interval);
        }
      }
      return intervals;
    }
    *calculateLateEndDateConstraintIntervals() {
      const intervals = yield* superProto.calculateLateEndDateConstraintIntervals.call(this);
      const project = this.getProject();
      const dependencyConstraintIntervalClass = project.dependencyConstraintIntervalClass;
      let dependency;
      for (dependency of yield this.$.outgoingDeps) {
        if (!(yield* this.shouldSuccessorAffectScheduling(dependency)))
          continue;
        const successor = yield dependency.$.toEvent;
        const manuallyScheduled = yield successor.$.manuallyScheduled;
        let successorDate;
        switch (yield dependency.$.type) {
          case DependencyType.EndToEnd:
            successorDate = manuallyScheduled ? yield successor.$.endDate : yield successor.$.lateEndDateRaw;
            break;
          case DependencyType.EndToStart:
            successorDate = manuallyScheduled ? yield successor.$.startDate : yield successor.$.lateStartDateRaw;
            break;
        }
        if (successorDate) {
          const lag = yield dependency.$.lag;
          const lagUnit = yield dependency.$.lagUnit;
          const lagMS = yield* project.$convertDuration(lag, lagUnit, TimeUnit.Millisecond);
          const calendar = yield dependency.$.calendar;
          yield calendar.$.version;
          let endDate = successorDate;
          if (lagMS) {
            endDate = calendar.skipNonWorkingTime(calendar.calculateStartDate(successorDate, lagMS));
          }
          const interval = dependencyConstraintIntervalClass.new({
            owner: dependency,
            startDate: null,
            endDate
          });
          intervals.unshift(interval);
        }
      }
      return intervals;
    }
    *calculateEffectiveDirection() {
      const projectDirection = yield this.getProject().$.effectiveDirection;
      const ownConstraintType = yield this.$.constraintType;
      if (projectDirection.direction === Direction.Backward && !(yield this.$.manuallyScheduled) && !((ownConstraintType === ConstraintType.MustStartOn || ownConstraintType === ConstraintType.MustFinishOn) && Boolean(yield this.$.constraintDate))) {
        for (const dependency of yield this.$.outgoingDeps) {
          const successor = yield dependency.$.toEvent;
          const hasSuccessor = successor != null && !isAtomicValue(successor);
          const constraintType = hasSuccessor ? yield successor.$.constraintType : void 0;
          if (!hasSuccessor || !(yield dependency.$.active) || (yield successor.$.manuallyScheduled) || (constraintType === ConstraintType.MustStartOn || constraintType === ConstraintType.MustFinishOn) && Boolean(yield successor.$.constraintDate))
            continue;
          const dependencyType = yield dependency.$.type;
          const successorDirection = dependencyType === DependencyType.EndToEnd || dependencyType === DependencyType.StartToEnd ? yield successor.$.endDateDirection : yield successor.$.startDateDirection;
          if (successorDirection.direction === Direction.Forward)
            return {
              // our TS version is a bit too old
              kind: "enforced",
              direction: Direction.Forward,
              enforcedBy: successorDirection.kind === "enforced" ? successorDirection.enforcedBy : successorDirection.kind === "own" ? successor : successorDirection.inheritedFrom
            };
        }
      }
      return yield* super.calculateEffectiveDirection();
    }
  }
  __decorate36([
    calculate("lateStartDateIntervals")
  ], ScheduledByDependenciesLateEventMixin2.prototype, "calculateLateStartDateConstraintIntervals", null);
  return ScheduledByDependenciesLateEventMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/gantt/scheduling_modes/FixedEffortDispatcher.js
var fixedEffortSEDWUGraphDescription = CycleDescription.new({
  variables: /* @__PURE__ */ new Set([StartDateVar, EndDateVar, DurationVar, EffortVar, UnitsVar]),
  formulas: /* @__PURE__ */ new Set([
    // the order of formulas is important here - the earlier ones are preferred
    endDateByEffortFormula,
    durationFormula,
    unitsFormula,
    effortFormula,
    startDateByEffortFormula,
    startDateFormula,
    endDateFormula
  ])
});
var fixedEffortSEDWUForward = CycleResolution.new({
  description: fixedEffortSEDWUGraphDescription,
  defaultResolutionFormulas: /* @__PURE__ */ new Set([endDateByEffortFormula, durationFormula])
});
var fixedEffortSEDWUBackward = CycleResolution.new({
  description: fixedEffortSEDWUGraphDescription,
  defaultResolutionFormulas: /* @__PURE__ */ new Set([startDateByEffortFormula, durationFormula])
});

// ../Engine/lib/Engine/quark/model/gantt/scheduling_modes/FixedEffortMixin.js
var FixedEffortMixin = class extends Mixin([HasSchedulingModeMixin], (base) => {
  const superProto = base.prototype;
  class FixedEffortMixin2 extends base {
    *prepareDispatcher(YIELD) {
      const schedulingMode = yield* this.effectiveSchedulingMode();
      if (schedulingMode === SchedulingMode.FixedEffort) {
        const cycleDispatcher = yield* superProto.prepareDispatcher.call(this, YIELD);
        if (yield HasProposedValue(this.$.assigned))
          cycleDispatcher.addProposedValueFlag(UnitsVar);
        cycleDispatcher.addKeepIfPossibleFlag(EffortVar);
        return cycleDispatcher;
      } else {
        return yield* superProto.prepareDispatcher.call(this, YIELD);
      }
    }
    cycleResolutionContext(Y) {
      const schedulingMode = this.effectiveSchedulingModeSync(Y);
      if (schedulingMode === SchedulingMode.FixedEffort) {
        const direction = Y(this.$.effectiveDirection);
        return direction.direction === Direction.Forward || direction.direction === Direction.None ? fixedEffortSEDWUForward : fixedEffortSEDWUBackward;
      } else {
        return superProto.cycleResolutionContext.call(this, Y);
      }
    }
  }
  return FixedEffortMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/gantt/scheduling_modes/FixedUnitsDispatcher.js
var fixedUnitsSEDWUGraphDescription = CycleDescription.new({
  variables: /* @__PURE__ */ new Set([StartDateVar, EndDateVar, DurationVar, EffortVar, UnitsVar]),
  formulas: /* @__PURE__ */ new Set([
    // the order of formulas is important here - the earlier ones are preferred
    endDateByEffortFormula,
    durationFormula,
    effortFormula,
    unitsFormula,
    startDateByEffortFormula,
    startDateFormula,
    endDateFormula
  ])
});
var fixedUnitsSEDWUForwardNonEffortDriven = CycleResolution.new({
  description: fixedUnitsSEDWUGraphDescription,
  defaultResolutionFormulas: /* @__PURE__ */ new Set([endDateByEffortFormula, endDateFormula, effortFormula])
});
var fixedUnitsSEDWUForwardEffortDriven = CycleResolution.new({
  description: fixedUnitsSEDWUGraphDescription,
  defaultResolutionFormulas: /* @__PURE__ */ new Set([endDateByEffortFormula, endDateFormula, durationFormula])
});
var fixedUnitsSEDWUBackwardNonEffortDriven = CycleResolution.new({
  description: fixedUnitsSEDWUGraphDescription,
  defaultResolutionFormulas: /* @__PURE__ */ new Set([startDateByEffortFormula, startDateFormula, effortFormula])
});
var fixedUnitsSEDWUBackwardEffortDriven = CycleResolution.new({
  description: fixedUnitsSEDWUGraphDescription,
  defaultResolutionFormulas: /* @__PURE__ */ new Set([startDateByEffortFormula, startDateFormula, durationFormula])
});

// ../Engine/lib/Engine/quark/model/gantt/scheduling_modes/FixedUnitsMixin.js
var FixedUnitsMixin = class extends Mixin([HasSchedulingModeMixin], (base) => {
  const superProto = base.prototype;
  class FixedUnitsMixin2 extends base {
    *prepareDispatcher(YIELD) {
      const schedulingMode = yield* this.effectiveSchedulingMode();
      if (schedulingMode === SchedulingMode.FixedUnits) {
        const cycleDispatcher = yield* superProto.prepareDispatcher.call(this, YIELD);
        if (yield HasProposedValue(this.$.assigned))
          cycleDispatcher.addProposedValueFlag(UnitsVar);
        if (yield this.$.effortDriven)
          cycleDispatcher.addKeepIfPossibleFlag(EffortVar);
        cycleDispatcher.addKeepIfPossibleFlag(UnitsVar);
        return cycleDispatcher;
      } else {
        return yield* superProto.prepareDispatcher.call(this, YIELD);
      }
    }
    cycleResolutionContext(Y) {
      const schedulingMode = this.effectiveSchedulingModeSync(Y);
      if (schedulingMode === SchedulingMode.FixedUnits) {
        const direction = Y(this.$.effectiveDirection);
        const effortDriven = Y(this.$.effortDriven);
        if (direction.direction === Direction.Forward || direction.direction === Direction.None) {
          return effortDriven ? fixedUnitsSEDWUForwardEffortDriven : fixedUnitsSEDWUForwardNonEffortDriven;
        } else {
          return effortDriven ? fixedUnitsSEDWUBackwardEffortDriven : fixedUnitsSEDWUBackwardNonEffortDriven;
        }
      } else {
        return superProto.cycleResolutionContext.call(this, Y);
      }
    }
  }
  return FixedUnitsMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/gantt/InactiveEventMixin.js
var __decorate37 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var InactiveEventMixin = class extends Mixin([ScheduledByDependenciesLateEventMixin], (base) => {
  const superProto = base.prototype;
  class InactiveEventMixin2 extends base {
    writeInactive(me, transaction, quark, inactive) {
      var _a2;
      const isLoading = !transaction.baseRevision.hasIdentifier(me);
      me.constructor.prototype.write.call(this, me, transaction, quark, inactive);
      if (!isLoading && this.children && !((_a2 = this.stm) == null ? void 0 : _a2.isRestoring)) {
        for (const child of this.children) {
          child.inactive = inactive;
        }
      }
    }
    *calculateInactive() {
      const inactive = yield ProposedOrPrevious;
      if (yield* this.hasSubEvents()) {
        const subEvents = yield* this.subEventsIterable();
        let activeCnt = 0;
        for (const subEvent of subEvents) {
          if (!(yield subEvent.$.inactive))
            activeCnt++;
        }
        return !activeCnt;
      }
      return inactive;
    }
    *shouldRollupChildEffort(child) {
      return !(yield child.$.inactive) || (yield this.$.inactive);
    }
    *shouldRollupChildPercentDoneSummaryData(child) {
      return !(yield child.$.inactive) || (yield this.$.inactive);
    }
    *shouldRollupChildStartDate(child) {
      return !(yield child.$.inactive) || (yield this.$.inactive);
    }
    *shouldRollupChildEndDate(child) {
      return !(yield child.$.inactive) || (yield this.$.inactive);
    }
    *shouldRollupChildEarlyStartDate(childEvent) {
      return !(yield childEvent.$.inactive) || (yield this.$.inactive);
    }
    *shouldRollupChildEarlyEndDate(childEvent) {
      return !(yield childEvent.$.inactive) || (yield this.$.inactive);
    }
    *shouldRollupChildLateStartDate(childEvent) {
      return !(yield childEvent.$.inactive) || (yield this.$.inactive);
    }
    *shouldRollupChildLateEndDate(childEvent) {
      return !(yield childEvent.$.inactive) || (yield this.$.inactive);
    }
  }
  __decorate37([
    write("inactive")
  ], InactiveEventMixin2.prototype, "writeInactive", null);
  __decorate37([
    calculate("inactive")
  ], InactiveEventMixin2.prototype, "calculateInactive", null);
  return InactiveEventMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/gantt/GanttEvent.js
var GanttEvent = class extends MixinAny([
  SchedulerProEvent,
  ConstrainedByParentMixin,
  ConstrainedLateEventMixin,
  ScheduledByDependenciesLateEventMixin,
  FixedEffortMixin,
  FixedUnitsMixin,
  InactiveEventMixin
], (base) => {
  class GanttEvent2 extends base {
  }
  return GanttEvent2;
}) {
};

// ../Engine/lib/Engine/quark/model/gantt/HasCriticalPathsMixin.js
var __decorate38 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HasCriticalPathsMixin = class extends Mixin([HasChildrenMixin], (base) => {
  const superProto = base.prototype;
  class HasCriticalPathsMixin2 extends base {
    *calculateCriticalPaths() {
      const paths = [], pathsToProcess = [], events = yield this.$.childEvents, eventsToProcess = [...events], projectEndDate = yield this.$.endDate;
      let event;
      while (event = eventsToProcess.shift()) {
        const childEvents = yield event.$.childEvents, eventIsCritical = yield event.$.critical, eventIsActive = !(yield event.$.inactive), eventEndDate = yield event.$.endDate;
        if (eventIsActive && eventEndDate && eventEndDate.getTime() - projectEndDate.getTime() === 0 && eventIsCritical) {
          pathsToProcess.push([{ event }]);
        }
        eventsToProcess.push(...childEvents);
      }
      let path;
      while (path = pathsToProcess.shift()) {
        let taskIndex = path.length - 1, node;
        while (node = path[taskIndex]) {
          const criticalPredecessorNodes = [];
          for (const dependency of yield node.event.$.incomingDeps) {
            const event2 = yield dependency.$.fromEvent;
            if (event2 && (yield dependency.$.active) && !(yield event2.$.inactive) && (yield event2.$.critical)) {
              criticalPredecessorNodes.push({ event: event2, dependency });
            }
          }
          if (criticalPredecessorNodes.length) {
            const pathCopy = path.slice();
            path.push(criticalPredecessorNodes[0]);
            for (let i = 1; i < criticalPredecessorNodes.length; i++) {
              pathsToProcess.push(pathCopy.concat(criticalPredecessorNodes[i]));
            }
            taskIndex++;
          } else {
            taskIndex = -1;
          }
        }
        paths.push(path.reverse());
      }
      return paths;
    }
  }
  __decorate38([
    field({ lazy: true })
  ], HasCriticalPathsMixin2.prototype, "criticalPaths", void 0);
  __decorate38([
    calculate("criticalPaths")
  ], HasCriticalPathsMixin2.prototype, "calculateCriticalPaths", null);
  return HasCriticalPathsMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/gantt/GanttProjectMixin.js
var __decorate39 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var GanttProjectMixin = class extends Mixin([
  SchedulerProProjectMixin,
  HasEffortMixin,
  ConstrainedLateEventMixin,
  HasCriticalPathsMixin
], (base) => {
  const superProto = base.prototype;
  class GanttProjectMixin2 extends base {
    constructor() {
      super(...arguments);
      this.nonEqual = false;
    }
    *calculateNonEqual() {
      return !(yield ProposedOrPrevious);
    }
    get isGanttProjectMixin() {
      return true;
    }
    afterConfigure() {
      superProto.afterConfigure.apply(this, arguments);
      this.projectConstraintIntervalClass = this.projectConstraintIntervalClass || ProjectConstraintInterval;
    }
    *hasSubEvents() {
      const childEvents = yield this.$.childEvents;
      return childEvents.size > 0;
    }
    *subEventsIterable() {
      return yield this.$.childEvents;
    }
    *calculateStartDate() {
      const direction = yield this.$.effectiveDirection;
      if (direction.direction === Direction.Forward) {
        let result = yield ProposedOrPrevious;
        if (!result) {
          result = yield* this.unsafeCalculateInitialMinChildrenStartDateDeep();
          if (!result)
            yield this.$.nonEqual;
        }
        return result;
      } else if (direction.direction === Direction.Backward) {
        const startDate = yield* this.calculateMinChildrenStartDate();
        const endDate = yield this.$.endDate;
        return startDate && endDate > startDate ? startDate : endDate;
      }
    }
    *calculateEndDate() {
      const direction = yield this.$.effectiveDirection;
      if (direction.direction === Direction.Forward) {
        const startDate = yield this.$.startDate;
        const endDate = yield* this.calculateMaxChildrenEndDate();
        return endDate && endDate > startDate ? endDate : startDate;
      } else if (direction.direction === Direction.Backward) {
        let result = yield ProposedOrPrevious;
        if (!result) {
          result = yield* this.unsafeCalculateInitialMaxChildrenEndDateDeep();
          if (!result)
            yield this.$.nonEqual;
        }
        return result;
      }
    }
    *shouldRollupChildStartDate(child) {
      return !(yield child.$.inactive);
    }
    *shouldRollupChildEndDate(child) {
      return !(yield child.$.inactive);
    }
    *calculateEarlyStartDateConstraintIntervals() {
      const intervals = yield* superProto.calculateEarlyStartDateConstraintIntervals.call(this);
      const direction = yield this.$.effectiveDirection;
      if (direction.direction === Direction.Forward) {
        const startDate = yield this.$.startDate;
        startDate && intervals.push(this.projectConstraintIntervalClass.new({
          owner: this,
          side: ConstraintIntervalSide.Start,
          startDate
        }));
      } else if (direction.direction === Direction.Backward) {
        const startDate = yield this.$.lateStartDate;
        startDate && intervals.push(this.projectConstraintIntervalClass.new({
          owner: this,
          side: ConstraintIntervalSide.Start,
          startDate
        }));
      }
      return intervals;
    }
    *calculateLateEndDateConstraintIntervals() {
      const intervals = yield* superProto.calculateLateEndDateConstraintIntervals.call(this);
      const direction = yield this.$.effectiveDirection;
      if (direction.direction === Direction.Forward) {
        const endDate = yield this.$.earlyEndDate;
        endDate && intervals.push(this.projectConstraintIntervalClass.new({
          owner: this,
          side: ConstraintIntervalSide.End,
          endDate
        }));
      } else if (direction.direction === Direction.Backward) {
        const endDate = yield this.$.endDate;
        endDate && intervals.push(this.projectConstraintIntervalClass.new({
          owner: this,
          side: ConstraintIntervalSide.End,
          endDate
        }));
      }
      return intervals;
    }
    getDefaultEventModelClass() {
      return GanttEvent;
    }
    getDefaultAssignmentModelClass() {
      return SchedulerProAssignmentMixin;
    }
    getDefaultResourceModelClass() {
      return SchedulerProResourceMixin;
    }
    getDefaultEventStoreClass() {
      return ChronoEventTreeStoreMixin;
    }
    getType() {
      return ProjectType.Gantt;
    }
    // this method is only used to calculated "initial" project start date only
    *unsafeCalculateInitialMinChildrenStartDateDeep() {
      const childEvents = yield this.$.childEvents;
      if (!childEvents.size)
        return yield UnsafeProposedOrPreviousValueOf(this.$.startDate);
      let result = MAX_DATE, child;
      const toProcess = [...childEvents];
      while (child = toProcess.shift()) {
        let childDate = yield UnsafeProposedOrPreviousValueOf(child.$.startDate);
        if (!childDate) {
          childDate = yield UnsafeProposedOrPreviousValueOf(child.$.endDate);
        }
        if (childDate && childDate < result)
          result = childDate;
        toProcess.push(...yield child.$.childEvents);
      }
      return result.getTime() !== MIN_DATE.getTime() && result.getTime() !== MAX_DATE.getTime() ? result : null;
    }
    *unsafeCalculateInitialMaxChildrenEndDateDeep() {
      const childEvents = yield this.$.childEvents;
      if (!childEvents.size)
        return yield UnsafeProposedOrPreviousValueOf(this.$.endDate);
      let result = MIN_DATE, child;
      const toProcess = [...childEvents];
      while (child = toProcess.shift()) {
        let childDate = yield UnsafeProposedOrPreviousValueOf(child.$.endDate);
        if (!childDate) {
          childDate = yield UnsafeProposedOrPreviousValueOf(child.$.startDate);
        }
        if (childDate && childDate > result)
          result = childDate;
        toProcess.push(...yield child.$.childEvents);
      }
      return result.getTime() !== MIN_DATE.getTime() && result.getTime() !== MAX_DATE.getTime() ? result : null;
    }
    getDependencyCycleDetectionIdentifiers(fromEvent, toEvent) {
      return [
        // @ts-ignore
        toEvent.$.earlyStartDateConstraintIntervals,
        // @ts-ignore
        toEvent.$.earlyEndDateConstraintIntervals,
        // @ts-ignore
        toEvent.$.lateEndDateConstraintIntervals,
        // @ts-ignore
        toEvent.$.lateStartDateConstraintIntervals
      ];
    }
  }
  __decorate39([
    field({ equality: () => false })
  ], GanttProjectMixin2.prototype, "nonEqual", void 0);
  __decorate39([
    calculate("nonEqual")
  ], GanttProjectMixin2.prototype, "calculateNonEqual", null);
  return GanttProjectMixin2;
}) {
};
var ProjectConstraintIntervalDescription = class extends ConstraintIntervalDescription {
  static get $name() {
    return "ProjectConstraintIntervalDescription";
  }
  static getDescription(interval) {
    return format(interval.startDate ? this.L("L{startDateDescriptionTpl}") : this.L("L{endDateDescriptionTpl}"), ...this.getDescriptionParameters(interval));
  }
};
var ProjectConstraintInterval = class extends ConstraintInterval {
  isAffectedByTransaction(transaction) {
    const project = this.owner;
    transaction = transaction || project.graph.activeTransaction;
    const dateQuark = transaction.entries.get(this.startDate ? project.$.startDate : project.$.endDate);
    return dateQuark && !dateQuark.isShadow();
  }
};
__decorate39([
  prototypeValue(ProjectConstraintIntervalDescription)
], ProjectConstraintInterval.prototype, "descriptionBuilderClass", void 0);

// ../Engine/lib/Engine/quark/CorePartOfProjectGenericMixin.js
var CorePartOfProjectGenericMixin = class extends Mixin([AbstractPartOfProjectGenericMixin], (base) => {
  const superProto = base.prototype;
  class CorePartOfProjectGenericMixin2 extends base {
    //region Store getters
    get eventStore() {
      var _a2;
      return (_a2 = this.project) == null ? void 0 : _a2.eventStore;
    }
    get resourceStore() {
      var _a2;
      return (_a2 = this.project) == null ? void 0 : _a2.resourceStore;
    }
    get assignmentStore() {
      var _a2;
      return (_a2 = this.project) == null ? void 0 : _a2.assignmentStore;
    }
    get dependencyStore() {
      var _a2;
      return (_a2 = this.project) == null ? void 0 : _a2.dependencyStore;
    }
    get calendarManagerStore() {
      var _a2;
      return (_a2 = this.project) == null ? void 0 : _a2.calendarManagerStore;
    }
    //endregion
    //region Entity getters
    /**
     * Convenience method to get the instance of event by its id.
     */
    getEventById(id) {
      var _a2;
      return (_a2 = this.eventStore) == null ? void 0 : _a2.getById(id);
    }
    /**
     * Convenience method to get the instance of dependency by its id.
     */
    getDependencyById(id) {
      var _a2;
      return (_a2 = this.dependencyStore) == null ? void 0 : _a2.getById(id);
    }
    /**
     * Convenience method to get the instance of resource by its id.
     */
    getResourceById(id) {
      var _a2;
      return (_a2 = this.resourceStore) == null ? void 0 : _a2.getById(id);
    }
    /**
     * Convenience method to get the instance of assignment by its id.
     */
    getAssignmentById(id) {
      var _a2;
      return (_a2 = this.assignmentStore) == null ? void 0 : _a2.getById(id);
    }
    /**
     * Convenience method to get the instance of calendar by its id.
     */
    getCalendarById(id) {
      var _a2;
      return (_a2 = this.calendarManagerStore) == null ? void 0 : _a2.getById(id);
    }
  }
  return CorePartOfProjectGenericMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/mixin/CorePartOfProjectModelMixin.js
var CorePartOfProjectModelMixin = class extends Mixin([
  AbstractPartOfProjectModelMixin,
  CorePartOfProjectGenericMixin,
  Model
], (base) => {
  const superProto = base.prototype;
  class CorePartOfProjectModelMixin2 extends base {
    constructor() {
      super(...arguments);
      this.$isCalculating = false;
      this.$changed = {};
      this.$beforeChange = {};
    }
    get isInActiveTransaction() {
      return true;
    }
    // Invalidate record upon joining project, leads to a buffered commit
    joinProject() {
      this.invalidate();
    }
    // Trigger a buffered commit when leaving the project
    leaveProject(isReplacing = false) {
      var _a2;
      superProto.leaveProject.call(this, isReplacing);
      (_a2 = this.project) == null ? void 0 : _a2.bufferedCommitAsync();
    }
    /**
     * Invalidates this record, queueing it for calculation on project commit.
     */
    invalidate() {
      var _a2;
      (_a2 = this.project) == null ? void 0 : _a2.invalidate(this);
    }
    /**
     * Used to retrieve the proposed (before 'dataReady') or current (after 'dataReady') value for a field.
     * If there is no proposed change, it is functionally equal to a normal `record.get()` call.
     */
    getCurrentOrProposed(fieldName) {
      var _a2;
      if (fieldName in this.$changed && this.$changed[fieldName] !== true) {
        return this.$changed[fieldName];
      }
      return (_a2 = this.get(fieldName)) != null ? _a2 : null;
    }
    /**
     * Determines if the specified field has a value or not, value can be either current or proposed.
     */
    hasCurrentOrProposed(fieldName) {
      return fieldName in this.$changed && this.$changed[fieldName] != true || this.get(fieldName) != null;
    }
    /**
     * Propose changes, to be considered during calculation. Also invalidates the record.
     */
    propose(changes) {
      var _a2;
      if (this.project || ((_a2 = this.recurringTimeSpan) == null ? void 0 : _a2.project)) {
        const keys = Object.keys(changes);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          this.$changed[key] = changes[key];
        }
        this.invalidate();
      } else {
        this.set(changes);
      }
    }
    /**
     * Similar to propose, but with more options. Mostly used by buckets, since they need data to update early.
     */
    setChanged(field2, value, invalidate = true, setData = false) {
      const me = this;
      me.$changed[field2] = value;
      if (setData) {
        if (!(field2 in me.$beforeChange)) {
          me.$beforeChange[field2] = me.get(field2);
        }
        me.setData(field2, value);
      }
      invalidate && me.invalidate();
    }
    /**
     * Hook called before project refresh, override and calculate required changes in subclasses
     */
    calculateInvalidated() {
    }
    /**
     * Called after project refresh, before dataReady. Announce updated data
     */
    finalizeInvalidated(silent = false) {
      const me = this;
      me.$isCalculating = true;
      if (!silent) {
        me.setData(me.$beforeChange);
        me.set(me.$changed);
      } else {
        me.setData(me.$changed);
      }
      me.$changed = {};
      me.$beforeChange = {};
      me.$isCalculating = false;
    }
  }
  return CorePartOfProjectModelMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_core/CoreEventMixin.js
var CoreEventMixin = class extends Mixin([CorePartOfProjectModelMixin], (base) => {
  const superProto = base.prototype;
  class CoreEventMixin2 extends base {
    constructor() {
      super(...arguments);
      this._startDate = null;
      this._endDate = null;
      this._duration = null;
    }
    // Proper engine defines these fields since they enter graph, thus we need them
    static get fields() {
      return [
        { name: "startDate", type: "date" },
        { name: "endDate", type: "date" },
        { name: "duration", type: "number" },
        { name: "durationUnit", type: "durationunit", defaultValue: "day" }
      ];
    }
    // Getters return current or proposed value
    get startDate() {
      var _a2, _b;
      return (_b = (_a2 = this._startDate) != null ? _a2 : this.get("startDate")) != null ? _b : null;
    }
    get endDate() {
      var _a2, _b;
      return (_b = (_a2 = this._endDate) != null ? _a2 : this.get("endDate")) != null ? _b : null;
    }
    get duration() {
      var _a2, _b;
      return (_b = (_a2 = this._duration) != null ? _a2 : this.get("duration")) != null ? _b : null;
    }
    // Route all setting through applyXX (setStartDate, startDate = , set('startDate'), batching)
    set startDate(value) {
      this.proposeStartDate(value);
    }
    set endDate(value) {
      this.proposeEndDate(value);
    }
    set duration(value) {
      this.proposeDuration(value);
    }
    //region Edge case normalization
    inSet(field2, value, silent, fromRelationUpdate, skipAccessors) {
      const me = this;
      if (me.project && !me.project.isWritingData && typeof field2 !== "string" && !skipAccessors) {
        if ("startDate" in field2 && !("startDate" in me.$changed)) {
          me.$changed.startDate = true;
          me.invalidate();
        }
        if ("endDate" in field2 && !("endDate" in me.$changed)) {
          me.$changed.endDate = true;
          me.invalidate();
        }
      }
      return superProto.inSet.call(me, field2, value, silent, fromRelationUpdate, skipAccessors);
    }
    //endregion
    //region StartDate
    getStartDate() {
      return this.startDate;
    }
    proposeStartDate(startDate, keepDuration = !("endDate" in this.$changed)) {
      var _a2;
      if (this.inSetting || (startDate == null ? void 0 : startDate.getTime()) !== ((_a2 = this.startDate) == null ? void 0 : _a2.getTime())) {
        this._startDate = startDate;
        this.propose({ startDate, keepDuration });
      }
    }
    async setStartDate(startDate, keepDuration = true) {
      var _a2;
      this.proposeStartDate(startDate, keepDuration);
      return (_a2 = this.project) == null ? void 0 : _a2.commitAsync();
    }
    //endregion
    //region EndDate
    getEndDate() {
      return this.endDate;
    }
    proposeEndDate(endDate, keepDuration = false) {
      var _a2;
      if (this.inSetting || (endDate == null ? void 0 : endDate.getTime()) !== ((_a2 = this.endDate) == null ? void 0 : _a2.getTime())) {
        this._endDate = endDate;
        this.propose({ endDate, keepDuration });
      }
    }
    async setEndDate(endDate, keepDuration = false) {
      var _a2;
      this.proposeEndDate(endDate, keepDuration);
      return (_a2 = this.project) == null ? void 0 : _a2.commitAsync();
    }
    //endregion
    //region Duration
    getDuration() {
      return this.duration;
    }
    proposeDuration(duration, unit, keepStart = true) {
      this._duration = duration;
      this.propose({ duration, keepStart });
      if (unit)
        this.propose({ durationUnit: unit });
    }
    async setDuration(duration, unit, keepStart = true) {
      var _a2;
      this.proposeDuration(duration, unit, keepStart);
      return (_a2 = this.project) == null ? void 0 : _a2.commitAsync();
    }
    getDurationUnit() {
      return this.durationUnit;
    }
    //endregion
    // When joining as part of inline data, store is available. If joining through load, it is passed
    joinProject() {
      var _a2, _b;
      const me = this;
      const changed = me.$changed;
      const startDate = me.getCurrentOrProposed("startDate");
      const endDate = me.getCurrentOrProposed("endDate");
      const duration = me.getCurrentOrProposed("duration");
      if (startDate != null)
        changed.startDate = me._startDate = startDate;
      if (endDate != null)
        changed.endDate = me._endDate = endDate;
      if (duration != null)
        changed.duration = me._duration = duration;
      if (me.eventStore && !me.eventStore.isLoadingData) {
        const unresolved = (_a2 = me.assignmentStore) == null ? void 0 : _a2.storage.findItem("event", null);
        if (unresolved) {
          const cachedAssignments = (_b = me.assignmentStore) == null ? void 0 : _b.storage.findItem("eventId", me.id);
          if (cachedAssignments) {
            for (const assignment of cachedAssignments) {
              assignment.setChanged("event", me);
            }
          } else {
            for (const assignment of unresolved) {
              if (assignment.getCurrentOrProposed("event") === me.id) {
                assignment.setChanged("event", me);
              }
            }
          }
        }
      }
      superProto.joinProject.call(me);
    }
    // Mimic how proper engine applies values
    applyValue(useProp, key, value, skipAccessors, field2) {
      var _a2;
      if ((this.project || ((_a2 = this.recurringTimeSpan) == null ? void 0 : _a2.project)) && field2) {
        const { name } = field2;
        if (name === "startDate" || name == "duration" || name === "endDate") {
          useProp = true;
          this["_" + name] = value;
        }
        if (skipAccessors) {
          useProp = false;
        }
      }
      superProto.applyValue.call(this, useProp, key, value, skipAccessors, field2);
    }
    // Catch changes from batches etc. In which case it is sometimes expected for data to be available directly
    afterChange(toSet, wasSet, silent, fromRelationUpdate, skipAccessors) {
      if (!this.$isCalculating && !skipAccessors) {
        this.setData({
          startDate: this.getCurrentOrProposed("startDate"),
          endDate: this.getCurrentOrProposed("endDate"),
          duration: this.getCurrentOrProposed("duration"),
          durationUnit: this.getCurrentOrProposed("durationUnit")
        });
      }
      superProto.afterChange.call(this, toSet, wasSet, silent, fromRelationUpdate, skipAccessors);
    }
    // Normalizes dates & duration
    calculateInvalidated() {
      const me = this;
      const changed = me.$changed;
      const changedStart = "startDate" in changed;
      const changedEnd = "endDate" in changed;
      const changedDuration = "duration" in changed;
      const { startDate, endDate, duration, keepDuration, keepStart } = changed;
      let calculate2 = null;
      if (changedStart && !changedEnd && !changedDuration) {
        if (startDate === null) {
          changed.endDate = null;
        } else if (me.hasCurrentOrProposed("endDate") && startDate > me.getCurrentOrProposed("endDate") && !keepDuration) {
          changed.endDate = startDate;
          changed.duration = 0;
        } else if (me.hasCurrentOrProposed("duration") && (keepDuration || !me.hasCurrentOrProposed("endDate"))) {
          calculate2 = "endDate";
        } else if (me.hasCurrentOrProposed("endDate")) {
          calculate2 = "duration";
        }
      } else if (!changedStart && changedEnd && !changedDuration) {
        if (endDate === null) {
          changed.startDate = null;
        } else if (me.hasCurrentOrProposed("startDate") && !keepDuration && endDate !== true && endDate < me.getCurrentOrProposed("startDate")) {
          changed.startDate = endDate;
          changed.duration = 0;
        } else if (me.hasCurrentOrProposed("duration") && (keepDuration || !me.hasCurrentOrProposed("startDate"))) {
          calculate2 = "startDate";
        } else if (me.hasCurrentOrProposed("startDate")) {
          calculate2 = "duration";
        }
      } else if (!changedStart && !changedEnd && changedDuration) {
        if (duration === null) {
          changed.endDate = null;
        } else if (me.hasCurrentOrProposed("startDate") && (keepStart || !me.hasCurrentOrProposed("endDate"))) {
          if (keepStart && changed.duration < 0) {
            changed.duration = 0;
          }
          calculate2 = "endDate";
        } else if (me.hasCurrentOrProposed("endDate")) {
          calculate2 = "startDate";
        }
      } else if (changedStart && changedEnd && !changedDuration) {
        if (startDate === null && endDate === null) {
          changed.duration = null;
        } else {
          calculate2 = "duration";
        }
      } else if (changedStart && !changedEnd && changedDuration) {
        calculate2 = "endDate";
      } else if (!changedStart && changedEnd && changedDuration) {
        calculate2 = "startDate";
      } else if (changedStart && changedEnd && changedDuration) {
        if (duration == null) {
          calculate2 = "duration";
        } else if (startDate == null) {
          calculate2 = "startDate";
        } else {
          calculate2 = "endDate";
        }
      }
      const currentOrProposedStartDate = me.getCurrentOrProposed("startDate");
      const currentOrProposedEndDate = me.getCurrentOrProposed("endDate");
      const currentOrProposedDuration = me.getCurrentOrProposed("duration");
      const currentOrProposedDurationUnit = me.getCurrentOrProposed("durationUnit");
      let hourDuration, targetDuration;
      switch (calculate2) {
        case "startDate":
          changed.startDate = DateHelper.add(currentOrProposedEndDate, -currentOrProposedDuration, currentOrProposedDurationUnit);
          break;
        case "endDate":
          hourDuration = DateHelper.as("hour", currentOrProposedDuration, currentOrProposedDurationUnit);
          targetDuration = DateHelper.as(currentOrProposedDurationUnit, hourDuration, "h");
          changed.endDate = DateHelper.add(currentOrProposedStartDate, targetDuration, currentOrProposedDurationUnit);
          break;
        case "duration":
          hourDuration = DateHelper.diff(currentOrProposedStartDate, currentOrProposedEndDate, "h");
          changed.duration = DateHelper.as(currentOrProposedDurationUnit, hourDuration, "h");
          break;
      }
      if ("startDate" in changed && changed.startDate !== true)
        this._startDate = changed.startDate;
      if ("endDate" in changed && changed.endDate !== true)
        this._endDate = changed.endDate;
      if ("duration" in changed && changed.duration !== true)
        this._duration = changed.duration;
      if (changed.startDate === true)
        delete changed.startDate;
      if (changed.endDate === true)
        delete changed.endDate;
      delete changed.keepDuration;
      delete changed.keepStart;
    }
  }
  return CoreEventMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_core/CoreResourceMixin.js
var CoreResourceMixin = class extends Mixin([CorePartOfProjectModelMixin], (base) => {
  const superProto = base.prototype;
  class CoreResourceMixin2 extends base {
    get assigned() {
      var _a2;
      return (_a2 = this.project) == null ? void 0 : _a2.assignmentStore.getResourcesAssignments(this);
    }
    joinProject() {
      var _a2;
      if (this.resourceStore && !this.resourceStore.isLoadingData) {
        (_a2 = this.assignmentStore) == null ? void 0 : _a2.query((a) => a.get("resource") === this.id).forEach((unresolved) => unresolved.setChanged("resource", this));
      }
      superProto.joinProject.call(this);
    }
    leaveProject(isReplacing = false) {
      var _a2;
      if (this.assigned && !isReplacing && !((_a2 = this.resourceStore) == null ? void 0 : _a2.isLoadingData)) {
        const resourceStore = this.resourceStore;
        this.assigned.forEach((assignment) => resourceStore.assignmentsForRemoval.add(assignment));
      }
      superProto.leaveProject.call(this);
    }
    applyValue(useProp, key, value, skipAccessor, field2) {
      if ((field2 == null ? void 0 : field2.name) === "id") {
        this.assigned.forEach((assignment) => {
          assignment.set("resourceId", value);
        });
      }
      superProto.applyValue.call(this, useProp, key, value, skipAccessor, field2);
    }
  }
  return CoreResourceMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_core/CoreAssignmentMixin.js
function asId(recordOrId) {
  return (recordOrId == null ? void 0 : recordOrId.isModel) ? recordOrId.id : recordOrId;
}
var CoreAssignmentMixin = class extends Mixin([CorePartOfProjectModelMixin], (base) => {
  const superProto = base.prototype;
  class CoreAssignmentMixin2 extends base {
    // Fields declared in the Model way, existing decorators all assume ChronoGraph is used
    static get fields() {
      return [
        // isEqual required to properly detect changed resource / event
        { name: "resource", isEqual: (a, b) => a === b, persist: false },
        { name: "event", isEqual: (a, b) => a === b, persist: false }
      ];
    }
    // Resolve early + update indices to have buckets ready before commit
    setChanged(field2, value, invalidate) {
      const { assignmentStore, eventStore, resourceStore, project } = this;
      let update = false;
      if (field2 === "event") {
        const event = isInstanceOf(value, CoreEventMixin) ? value : eventStore == null ? void 0 : eventStore.$master.getById(value);
        if (event)
          update = true;
        value = event || value;
      }
      if (field2 === "resource") {
        const resource = isInstanceOf(value, CoreResourceMixin) ? value : resourceStore == null ? void 0 : resourceStore.$master.getById(value);
        if (resource)
          update = true;
        value = resource || value;
      }
      superProto.setChanged.call(this, field2, value, invalidate, true);
      if (assignmentStore && update && !project.isPerformingCommit && !assignmentStore.isLoadingData && !(resourceStore == null ? void 0 : resourceStore.isLoadingData) && !assignmentStore.skipInvalidateIndices) {
        assignmentStore.invalidateIndices();
      }
    }
    // Resolve event and resource when joining project
    joinProject() {
      superProto.joinProject.call(this);
      this.setChanged("event", this.get("event"));
      this.setChanged("resource", this.get("resource"));
    }
    // Resolved resource & event as part of commit
    // Normally done earlier in setChanged, but stores might not have been available yet at that point
    calculateInvalidated() {
      var _a2, _b;
      let { event = this.event, resource = this.resource } = this.$changed;
      if (event !== null && !isInstanceOf(event, CoreEventMixin)) {
        const resolved = (_a2 = this.eventStore) == null ? void 0 : _a2.getById(event);
        if (resolved)
          this.setChanged("event", resolved, false);
      }
      if (resource !== null && !isInstanceOf(resource, CoreResourceMixin)) {
        const resolved = (_b = this.resourceStore) == null ? void 0 : _b.getById(resource);
        if (resolved)
          this.setChanged("resource", resolved, false);
      }
    }
    // resourceId and eventId required to be available for new datasets
    finalizeInvalidated(silent) {
      const changed = this.$changed;
      if ("resource" in changed) {
        changed.resourceId = asId(changed.resource);
      }
      if ("event" in changed) {
        changed.eventId = asId(changed.event);
      }
      superProto.finalizeInvalidated.call(this, silent);
    }
    //region Event
    set event(event) {
      this.setChanged("event", event);
      this.setChanged("eventId", asId(event));
    }
    get event() {
      const event = this.get("event");
      return (event == null ? void 0 : event.id) != null ? event : null;
    }
    //endregion
    //region Resource
    set resource(resource) {
      this.setChanged("resource", resource);
      this.setChanged("resourceId", asId(resource));
    }
    get resource() {
      const resource = this.get("resource");
      return (resource == null ? void 0 : resource.id) != null ? resource : null;
    }
  }
  return CoreAssignmentMixin2;
}) {
};

// ../Engine/lib/Engine/quark/store/mixin/CorePartOfProjectStoreMixin.js
var CorePartOfProjectStoreMixin = class extends Mixin([
  AbstractPartOfProjectStoreMixin,
  CorePartOfProjectGenericMixin,
  Store
], (base) => {
  const superProto = base.prototype;
  class CorePartOfProjectStoreMixin2 extends base {
    setProject(project) {
      const result = superProto.setProject.call(this, project);
      if (project)
        this.joinProject(project);
      return result;
    }
    joinProject(project) {
    }
    onCommitAsync() {
    }
  }
  return CorePartOfProjectStoreMixin2;
}) {
};

// ../Engine/lib/Engine/quark/store/CoreAssignmentStoreMixin.js
var emptySet = /* @__PURE__ */ new Set();
var CoreAssignmentStoreMixin = class extends Mixin([AbstractAssignmentStoreMixin, CorePartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class CoreAssignmentStoreMixin2 extends base {
    constructor() {
      super(...arguments);
      this.skipInvalidateIndices = false;
    }
    static get defaultConfig() {
      return {
        modelClass: CoreAssignmentMixin,
        storage: {
          extraKeys: [
            { property: "event", unique: false },
            { property: "resource", unique: false },
            { property: "eventId", unique: false }
          ]
        }
      };
    }
    set data(value) {
      this.allAssignmentsForRemoval = true;
      super.data = value;
      this.allAssignmentsForRemoval = false;
    }
    getEventsAssignments(event) {
      return this.storage.findItem("event", event, true) || emptySet;
    }
    getResourcesAssignments(resource) {
      return this.storage.findItem("resource", resource.$original, true) || emptySet;
    }
    updateIndices() {
      this.storage.rebuildIndices();
    }
    invalidateIndices() {
      this.storage.invalidateIndices();
    }
    afterLoadData() {
      this.eventStore && this.linkAssignments(this.eventStore, "event");
      this.resourceStore && this.linkAssignments(this.resourceStore, "resource");
    }
    // Link events/resources to assignments, called when those stores are populated or joined to project
    linkAssignments(store, modelName) {
      store = store.masterStore || store;
      const unresolved = this.count && this.storage.findItem(modelName, null, true);
      if (unresolved) {
        for (const assignment of unresolved) {
          const record = store.getById(assignment.getCurrentOrProposed(modelName));
          if (record)
            assignment.setChanged(modelName, record);
        }
        this.invalidateIndices();
      }
    }
    // Unlink events/resources from assignments, called when those stores are cleared
    unlinkAssignments(modelName) {
      this.forEach((assignment) => {
        var _a2, _b, _c;
        return assignment.setChanged(modelName, (_c = (_b = (_a2 = assignment[modelName]) == null ? void 0 : _a2.id) != null ? _b : assignment == null ? void 0 : assignment.getData(modelName)) != null ? _c : assignment[modelName + "Id"]);
      });
      this.invalidateIndices();
    }
    onCommitAsync() {
      this.updateIndices();
    }
  }
  return CoreAssignmentStoreMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_core/CoreCalendarMixin.js
var CoreCalendarMixin = class extends Mixin([AbstractCalendarMixin, CorePartOfProjectModelMixin], (base) => {
  const superProto = base.prototype;
  class CoreCalendarMixin2 extends base {
  }
  return CoreCalendarMixin2;
}) {
};

// ../Engine/lib/Engine/quark/store/CoreCalendarManagerStoreMixin.js
var CoreCalendarManagerStoreMixin = class extends Mixin([AbstractCalendarManagerStoreMixin, CorePartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class CoreCalendarManagerStoreMixin2 extends base {
    static get defaultConfig() {
      return {
        tree: true,
        modelClass: CoreCalendarMixin
      };
    }
  }
  return CoreCalendarManagerStoreMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_core/CoreDependencyMixin.js
var CoreDependencyMixin = class extends Mixin([CorePartOfProjectModelMixin], (base) => {
  const superProto = base.prototype;
  class CoreDependencyMixin2 extends base {
    static get fields() {
      return [
        { name: "fromEvent", isEqual: (a, b) => a === b, persist: false },
        { name: "toEvent", isEqual: (a, b) => a === b, persist: false }
      ];
    }
    // Resolve early + update indices to have buckets ready before commit
    setChanged(field2, value, invalidate) {
      var _a2, _b, _c;
      let update = false;
      if (field2 === "fromEvent" || field2 === "toEvent") {
        const event = isInstanceOf(value, CoreEventMixin) ? value : (_a2 = this.eventStore) == null ? void 0 : _a2.getById(value);
        if (event)
          update = true;
        value = event || value;
      }
      superProto.setChanged.call(this, field2, value, invalidate, true);
      if (update && !this.project.isPerformingCommit && !((_b = this.dependencyStore) == null ? void 0 : _b.isLoadingData)) {
        (_c = this.dependencyStore) == null ? void 0 : _c.invalidateIndices();
      }
    }
    // Resolve events when joining project
    joinProject() {
      superProto.joinProject.call(this);
      this.setChanged("fromEvent", this.get("fromEvent"));
      this.setChanged("toEvent", this.get("toEvent"));
    }
    // Resolved events as part of commit
    // Normally done earlier in setChanged, but stores might not have been available yet at that point
    calculateInvalidated() {
      var _a2, _b;
      let { fromEvent, toEvent } = this.$changed;
      if (fromEvent !== null && !isInstanceOf(fromEvent, CoreEventMixin)) {
        const resolved = (_a2 = this.eventStore) == null ? void 0 : _a2.getById(fromEvent);
        if (resolved)
          this.$changed.fromEvent = resolved;
      }
      if (toEvent !== null && !isInstanceOf(toEvent, CoreEventMixin)) {
        const resolved = (_b = this.eventStore) == null ? void 0 : _b.getById(toEvent);
        if (resolved)
          this.$changed.toEvent = resolved;
      }
    }
    //region Events
    // Not using "propose" mechanism from CoreEventMixin, because buckets are expected to be up to date right away
    set fromEvent(fromEvent) {
      this.setChanged("fromEvent", fromEvent);
    }
    get fromEvent() {
      const fromEvent = this.get("fromEvent");
      return (fromEvent == null ? void 0 : fromEvent.id) != null ? fromEvent : null;
    }
    set toEvent(toEvent) {
      this.setChanged("toEvent", toEvent);
    }
    get toEvent() {
      const toEvent = this.get("toEvent");
      return (toEvent == null ? void 0 : toEvent.id) != null ? toEvent : null;
    }
  }
  return CoreDependencyMixin2;
}) {
};

// ../Engine/lib/Engine/quark/store/CoreDependencyStoreMixin.js
var emptySet2 = /* @__PURE__ */ new Set();
var CoreDependencyStoreMixin = class extends Mixin([AbstractDependencyStoreMixin, CorePartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class CoreDependencyStoreMixin2 extends base {
    constructor() {
      super(...arguments);
      this.dependenciesForRemoval = /* @__PURE__ */ new Set();
      this.allDependenciesForRemoval = false;
    }
    static get defaultConfig() {
      return {
        modelClass: CoreDependencyMixin,
        storage: {
          extraKeys: [
            { property: "fromEvent", unique: false },
            { property: "toEvent", unique: false }
          ]
        }
      };
    }
    getIncomingDepsForEvent(event) {
      return this.storage.findItem("toEvent", event) || emptySet2;
    }
    getOutgoingDepsForEvent(event) {
      return this.storage.findItem("fromEvent", event) || emptySet2;
    }
    set data(value) {
      this.allDependenciesForRemoval = true;
      super.data = value;
      this.allDependenciesForRemoval = false;
    }
    updateIndices() {
      this.storage.rebuildIndices();
    }
    invalidateIndices() {
      this.storage.invalidateIndices();
    }
    onCommitAsync() {
      this.updateIndices();
    }
  }
  return CoreDependencyStoreMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_core/CoreHasAssignmentsMixin.js
var CoreHasAssignmentsMixin = class extends Mixin([CoreEventMixin, AbstractHasAssignmentsMixin], (base) => {
  const superProto = base.prototype;
  class CoreHasAssignmentsMixin2 extends base {
    get assigned() {
      var _a2, _b;
      return (_b = (_a2 = this.project) == null ? void 0 : _a2.assignmentStore.getEventsAssignments(this)) != null ? _b : this.$cachedAssignments;
    }
    leaveProject(isReplacing = false) {
      this.$cachedAssignments = this.assigned;
      super.leaveProject(isReplacing);
    }
    applyValue(useProp, key, value, skipAccessor, field2) {
      var _a2;
      if (key === "id") {
        (_a2 = this.assigned) == null ? void 0 : _a2.forEach((assignment) => assignment.set("eventId", value));
      }
      superProto.applyValue.call(this, useProp, key, value, skipAccessor, field2);
    }
    copy(newId = null, deep = null) {
      const copy = superProto.copy.call(this, newId, deep);
      if (ObjectHelper.isObject(deep) && !deep.skipFieldIdentifiers || !ObjectHelper.isObject(deep)) {
        copy.$cachedAssignments = this.assigned;
      }
      return copy;
    }
  }
  return CoreHasAssignmentsMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_core/CoreHasDependenciesMixin.js
var CoreHasDependenciesMixin = class extends Mixin([CoreEventMixin], (base) => {
  const superProto = base.prototype;
  class CoreHasDependenciesMixin2 extends base {
    get outgoingDeps() {
      return this.project.dependencyStore.getOutgoingDepsForEvent(this);
    }
    get incomingDeps() {
      return this.project.dependencyStore.getIncomingDepsForEvent(this);
    }
    leaveProject() {
      const eventStore = this.eventStore;
      if (this.outgoingDeps) {
        this.outgoingDeps.forEach((dependency) => eventStore.dependenciesForRemoval.add(dependency));
      }
      if (this.incomingDeps) {
        this.incomingDeps.forEach((dependency) => eventStore.dependenciesForRemoval.add(dependency));
      }
      superProto.leaveProject.call(this);
    }
  }
  return CoreHasDependenciesMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_core/SchedulerCoreEvent.js
var SchedulerCoreEvent = class extends Mixin([
  CoreEventMixin,
  CoreHasAssignmentsMixin,
  CoreHasDependenciesMixin
], (base) => {
  const superProto = base.prototype;
  class SchedulerCoreEvent2 extends base {
  }
  return SchedulerCoreEvent2;
}) {
};

// ../Engine/lib/Engine/quark/store/CoreEventStoreMixin.js
var CoreEventStoreMixin = class extends Mixin([AbstractEventStoreMixin, CorePartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class CoreEventStoreMixin2 extends base {
    static get defaultConfig() {
      return {
        modelClass: SchedulerCoreEvent
      };
    }
    joinProject() {
      var _a2;
      (_a2 = this.assignmentStore) == null ? void 0 : _a2.linkAssignments(this, "event");
    }
    afterLoadData() {
      var _a2;
      this.afterEventRemoval();
      (_a2 = this.assignmentStore) == null ? void 0 : _a2.linkAssignments(this, "event");
    }
  }
  return CoreEventStoreMixin2;
}) {
};

// ../Engine/lib/Engine/quark/store/CoreResourceStoreMixin.js
var CoreResourceStoreMixin = class extends Mixin([AbstractResourceStoreMixin, CorePartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class CoreResourceStoreMixin2 extends base {
    static get defaultConfig() {
      return {
        modelClass: CoreResourceMixin
      };
    }
    joinProject() {
      var _a2;
      (_a2 = this.assignmentStore) == null ? void 0 : _a2.linkAssignments(this, "resource");
    }
    afterLoadData() {
      var _a2;
      (_a2 = this.assignmentStore) == null ? void 0 : _a2.linkAssignments(this, "resource");
    }
    clear(removing) {
      var _a2;
      superProto.clear.call(this, removing);
      (_a2 = this.assignmentStore) == null ? void 0 : _a2.unlinkAssignments("resource");
    }
  }
  return CoreResourceStoreMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_core/SchedulerCoreProjectMixin.js
var DelayableWrapper2 = class extends Mixin([], Delayable_default) {
};
var SchedulerCoreProjectMixin = class extends Mixin([
  AbstractProjectMixin,
  CorePartOfProjectGenericMixin,
  DelayableWrapper2,
  Model
], (base) => {
  const superProto = base.prototype;
  class SchedulerCoreProjectMixin2 extends base {
    static get configurable() {
      return {
        stm: {},
        eventStore: {},
        assignmentStore: {},
        resourceStore: {},
        dependencyStore: {},
        calendarManagerStore: {},
        eventModelClass: SchedulerCoreEvent,
        assignmentModelClass: CoreAssignmentMixin,
        resourceModelClass: CoreResourceMixin,
        dependencyModelClass: CoreDependencyMixin,
        calendarModelClass: CoreCalendarMixin,
        eventStoreClass: CoreEventStoreMixin,
        assignmentStoreClass: CoreAssignmentStoreMixin,
        resourceStoreClass: CoreResourceStoreMixin,
        dependencyStoreClass: CoreDependencyStoreMixin,
        calendarManagerStoreClass: CoreCalendarManagerStoreMixin,
        assignmentsData: null,
        calendarsData: null,
        dependenciesData: null,
        eventsData: null,
        resourcesData: null
      };
    }
    //endregion
    //region Init
    construct(config = {}) {
      var _a2;
      const me = this;
      me.$invalidated = /* @__PURE__ */ new Set();
      me.isPerformingCommit = false;
      me.silenceInitialCommit = true;
      me.ongoing = Promise.resolve();
      if (config.eventStore && !config.assignmentStore) {
        const eventStore = config.eventStore.masterStore || config.eventStore;
        const assignmentStore = eventStore.assignmentStore || ((_a2 = eventStore.crudManager) == null ? void 0 : _a2.assignmentStore);
        if (assignmentStore == null ? void 0 : assignmentStore.isAssignmentStore) {
          config.assignmentStore = assignmentStore;
          me.isSharingAssignmentStore = true;
        }
      }
      superProto.construct.call(me, config);
      me.defaultCalendar = new me.calendarManagerStore.modelClass({
        unspecifiedTimeIsWorking: me.unspecifiedTimeIsWorking
      });
      me.defaultCalendar.project = me;
      const { calendarsData, eventsData, dependenciesData, resourcesData, assignmentsData } = me;
      const hasInlineData = Boolean(calendarsData || eventsData || dependenciesData || resourcesData || assignmentsData);
      if (hasInlineData) {
        me.loadInlineData({
          calendarsData,
          eventsData,
          dependenciesData,
          resourcesData,
          assignmentsData
        });
        delete me.calendarsData;
        delete me.eventsData;
        delete me.dependenciesData;
        delete me.resourcesData;
        delete me.assignmentsData;
      } else {
        me.bufferedCommitAsync();
      }
    }
    doDestroy() {
      var _a2, _b, _c, _d, _e, _f;
      const me = this;
      (_a2 = me.eventStore) == null ? void 0 : _a2.destroy();
      (_b = me.dependencyStore) == null ? void 0 : _b.destroy();
      (_c = me.assignmentStore) == null ? void 0 : _c.destroy();
      (_d = me.resourceStore) == null ? void 0 : _d.destroy();
      (_e = me.calendarManagerStore) == null ? void 0 : _e.destroy();
      me.defaultCalendar.destroy();
      (_f = me.stm) == null ? void 0 : _f.destroy();
      superProto.doDestroy.call(this);
    }
    /**
     * This method loads the "raw" data into the project. The loading is basically happening by
     * assigning the individual data entries to the `data` property of the corresponding store.
     *
     * @param data
     */
    async loadInlineData(data) {
      const me = this;
      me.isLoadingInlineData = true;
      if (data.calendarsData) {
        me.calendarManagerStore.data = data.calendarsData;
      }
      if (data.resourcesData) {
        me.resourceStore.data = data.resourcesData;
      }
      if (data.assignmentsData) {
        me.assignmentStore.data = data.assignmentsData;
      }
      if (data.eventsData) {
        me.eventStore.data = data.eventsData;
      }
      if (data.tasksData) {
        me.eventStore.data = data.tasksData;
      }
      if (data.dependenciesData) {
        me.dependencyStore.data = data.dependenciesData;
      }
      await me.commitLoad();
      me.isLoadingInlineData = false;
      return;
    }
    //endregion
    //region Join
    async commitLoad() {
      await this.commitAsync();
      if (!this.isDestroyed)
        this.trigger("load");
    }
    joinStoreRecords(store) {
      const fn2 = (record) => {
        record.setProject(this);
        record.joinProject();
      };
      if (store.rootNode) {
        store.rootNode.traverse(fn2);
      } else {
        store.forEach(fn2);
      }
    }
    unJoinStoreRecords(store) {
      const fn2 = (record) => {
        record.leaveProject();
        record.setProject(this);
      };
      if (store.rootNode) {
        store.rootNode.traverse((node) => {
          if (node !== store.rootNode)
            fn2(node);
        });
      } else {
        store.forEach(fn2);
      }
    }
    //endregion
    //region EventStore
    resolveStoreAndModelClass(name, config) {
      const storeClass = (config == null ? void 0 : config.storeClass) || this[`${name}StoreClass`];
      let modelClass = config == null ? void 0 : config.modelClass;
      if (!modelClass) {
        if (this.getDefaultConfiguration()[`${name}ModelClass`] !== storeClass.getDefaultConfiguration().modelClass) {
          modelClass = storeClass.getDefaultConfiguration().modelClass;
        } else {
          modelClass = this[`${name}ModelClass`];
        }
      }
      return { storeClass, modelClass };
    }
    setEventStore(eventStore) {
      this.eventStore = eventStore;
    }
    changeEventStore(eventStore, oldStore) {
      const me = this, { stm } = me;
      me.detachStore(oldStore);
      if (!(eventStore instanceof Store)) {
        const { storeClass, modelClass } = me.resolveStoreAndModelClass("event", eventStore);
        eventStore = new storeClass(ObjectHelper.assign({
          modelClass,
          project: me,
          stm
        }, eventStore));
      } else {
        eventStore.project = me;
        stm.addStore(eventStore);
        me.joinStoreRecords(eventStore);
      }
      if (oldStore && stm.hasStore(oldStore)) {
        stm.removeStore(oldStore);
        me.unJoinStoreRecords(oldStore);
        const { assignmentsForRemoval } = oldStore;
        assignmentsForRemoval.forEach((assignment) => {
          const oldEvent = assignment.event;
          if (oldEvent) {
            const newEvent = eventStore.getById(oldEvent.id);
            if (newEvent) {
              assignment.event = newEvent;
              assignmentsForRemoval.delete(assignment);
            }
          }
        });
        oldStore.afterEventRemoval();
      }
      eventStore.setProject(me);
      return eventStore;
    }
    updateEventStore(eventStore, oldStore) {
      this.attachStore(eventStore);
      this.trigger("eventStoreChange", { store: eventStore });
    }
    //endregion
    //region AssignmentStore
    setAssignmentStore(assignmentStore) {
      this.assignmentStore = assignmentStore;
    }
    changeAssignmentStore(assignmentStore, oldStore) {
      const me = this, { stm } = me;
      me.detachStore(oldStore);
      if (oldStore && stm.hasStore(oldStore)) {
        stm.removeStore(oldStore);
        me.unJoinStoreRecords(oldStore);
      }
      if (!(assignmentStore instanceof Store)) {
        const { storeClass, modelClass } = me.resolveStoreAndModelClass("assignment", assignmentStore);
        assignmentStore = new storeClass(ObjectHelper.assign({
          modelClass,
          project: me,
          stm
        }, assignmentStore));
      } else {
        assignmentStore.project = me;
        stm.addStore(assignmentStore);
        me.joinStoreRecords(assignmentStore);
      }
      assignmentStore.setProject(me);
      return assignmentStore;
    }
    updateAssignmentStore(assignmentStore, oldStore) {
      this.attachStore(assignmentStore);
      this.trigger("assignmentStoreChange", { store: assignmentStore });
    }
    //endregion
    //region ResourceStore
    setResourceStore(resourceStore) {
      this.resourceStore = resourceStore;
    }
    changeResourceStore(resourceStore, oldStore) {
      const me = this, { stm } = me;
      me.detachStore(oldStore);
      if (!(resourceStore instanceof Store)) {
        const { storeClass, modelClass } = me.resolveStoreAndModelClass("resource", resourceStore);
        resourceStore = new storeClass(ObjectHelper.assign({
          modelClass,
          project: me,
          stm
        }, resourceStore));
      } else {
        resourceStore.project = me;
        stm.addStore(resourceStore);
        me.joinStoreRecords(resourceStore);
      }
      if (oldStore && stm.hasStore(oldStore)) {
        stm.removeStore(oldStore);
        me.unJoinStoreRecords(oldStore);
        const { assignmentsForRemoval } = oldStore;
        assignmentsForRemoval.forEach((assignment) => {
          const oldResource = assignment.resource;
          if (oldResource) {
            const newResource = resourceStore.getById(oldResource.id);
            if (newResource) {
              assignment.resource = newResource;
              assignmentsForRemoval.delete(assignment);
            }
          }
        });
        oldStore.afterResourceRemoval();
      }
      resourceStore.setProject(me);
      return resourceStore;
    }
    updateResourceStore(resourceStore, oldStore) {
      this.attachStore(resourceStore);
      this.trigger("resourceStoreChange", { store: resourceStore });
    }
    //endregion
    //region DependencyStore
    setDependencyStore(dependencyStore) {
      this.dependencyStore = dependencyStore;
    }
    changeDependencyStore(dependencyStore, oldStore) {
      const me = this;
      me.detachStore(oldStore);
      if (!(dependencyStore instanceof Store)) {
        const { storeClass, modelClass } = me.resolveStoreAndModelClass("dependency", dependencyStore);
        dependencyStore = new storeClass(ObjectHelper.assign({
          modelClass,
          project: me,
          stm: me.stm
        }, dependencyStore));
      } else {
        dependencyStore.project = me;
        me.stm.addStore(dependencyStore);
        me.joinStoreRecords(dependencyStore);
      }
      return dependencyStore;
    }
    updateDependencyStore(dependencyStore, oldStore) {
      this.attachStore(dependencyStore);
      this.trigger("dependencyStoreChange", { store: dependencyStore });
    }
    //endregion
    //region CalendarManagerStore
    setCalendarManagerStore(calendarManagerStore) {
      this.calendarManagerStore = calendarManagerStore;
    }
    changeCalendarManagerStore(calendarManagerStore, oldStore) {
      const me = this;
      me.detachStore(oldStore);
      if (!(calendarManagerStore instanceof Store)) {
        const storeClass = (calendarManagerStore == null ? void 0 : calendarManagerStore.storeClass) || me.calendarManagerStoreClass;
        const modelClass = (calendarManagerStore == null ? void 0 : calendarManagerStore.modelClass) || storeClass.getDefaultConfiguration().modelClass || me.calendarModelClass;
        calendarManagerStore = new storeClass(ObjectHelper.assign({
          modelClass,
          project: me,
          stm: me.stm
        }, calendarManagerStore));
      } else {
        me.stm.addStore(calendarManagerStore);
      }
      calendarManagerStore.setProject(me);
      return calendarManagerStore;
    }
    updateCalendarManagerStore(calendarManagerStore, oldStore) {
      this.attachStore(calendarManagerStore);
      this.trigger("calendarManagerStoreChange", { store: calendarManagerStore });
    }
    //endregion
    //region Calendar
    get calendar() {
      return this.$calendar || this.defaultCalendar;
    }
    set calendar(calendar) {
      this.$calendar = calendar;
    }
    get effectiveCalendar() {
      return this.calendar;
    }
    //endregion
    //region Add records
    async addEvent(event) {
      this.eventStore.add(event);
      return this.commitAsync();
    }
    async addAssignment(assignment) {
      this.assignmentStore.add(assignment);
      return this.commitAsync();
    }
    async addResource(resource) {
      this.resourceStore.add(resource);
      return this.commitAsync();
    }
    async addDependency(dependency) {
      this.dependencyStore.add(dependency);
      return this.commitAsync();
    }
    //endregion
    //region Auto commit
    // Buffer commitAsync using setTimeout. Not using `buffer` on purpose, for performance reasons and to better
    // mimic how graph does it
    bufferedCommitAsync() {
      if (!this.hasPendingAutoCommit) {
        this.setTimeout({
          fn: "commitAsync",
          delay: 10
        });
      }
    }
    get hasPendingAutoCommit() {
      return this.hasTimeout("commitAsync");
    }
    unScheduleAutoCommit() {
      this.clearTimeout("commitAsync");
    }
    //endregion
    //region Commit
    async commitAsync() {
      if (this.isPerformingCommit)
        return this.ongoing;
      return this.ongoing = this.doCommitAsync();
    }
    async doCommitAsync() {
      const me = this;
      me.isPerformingCommit = true;
      me.unScheduleAutoCommit();
      await delay2(0);
      if (!me.isDestroyed) {
        for (const record of me.$invalidated) {
          record.calculateInvalidated();
        }
        const { isInitialCommit, silenceInitialCommit } = me;
        const silenceCommit = isInitialCommit && silenceInitialCommit;
        me.assignmentStore.onCommitAsync();
        me.dependencyStore.onCommitAsync();
        me.isInitialCommitPerformed = true;
        me.hasLoadedDataToCommit = false;
        me.isPerformingCommit = false;
        const stores = [me.assignmentStore, me.dependencyStore, me.eventStore, me.resourceStore, me.calendarManagerStore];
        stores.forEach((store) => {
          var _a2;
          return (_a2 = store.suspendAutoCommit) == null ? void 0 : _a2.call(store);
        });
        me.isWritingData = true;
        me.trigger("refresh", { isInitialCommit, isCalculated: true });
        if (silenceCommit) {
          for (const record of me.$invalidated) {
            record.finalizeInvalidated(true);
          }
        } else {
          for (const record of me.$invalidated) {
            record.beginBatch(true);
            record.finalizeInvalidated();
          }
          for (const record of me.$invalidated) {
            record.endBatch(false, true);
          }
        }
        me.isWritingData = false;
        me.$invalidated.clear();
        me.trigger("dataReady");
        stores.forEach((store) => {
          var _a2;
          return (_a2 = store.resumeAutoCommit) == null ? void 0 : _a2.call(store);
        });
        me.trigger("commitFinalized");
        return true;
      }
    }
    async propagateAsync() {
      return this.commitAsync();
    }
    // Called when a record invalidates itself, queues it for calculation
    invalidate(record) {
      this.$invalidated.add(record);
      this.bufferedCommitAsync();
    }
    // this does not account for possible scheduling conflicts
    async isValidDependency() {
      return true;
    }
    //endregion
    //region STM
    getStm() {
      return this.stm;
    }
    /**
     * State tracking manager instance the project relies on
     */
    set stm(stm) {
      stm = this.$stm = new StateTrackingManager(ObjectHelper.assign({
        disabled: true
      }, stm));
      stm.ion({
        // Propagate on undo/redo
        restoringStop: async () => {
          stm.disable();
          await this.commitAsync();
          if (!this.isDestroyed) {
            stm.enable();
            this.trigger("stateRestoringDone");
          }
        }
      });
    }
    get stm() {
      return this.$stm;
    }
    //endregion
    isEngineReady() {
      return !this.hasPendingAutoCommit && !this.isPerformingCommit && this.isInitialCommitPerformed;
    }
  }
  SchedulerCoreProjectMixin2.applyConfigs = true;
  return SchedulerCoreProjectMixin2;
}) {
};

// ../Core/lib/Core/helper/util/DomClassList.js
var valueSymbol = Symbol("value");
var lengthSymbol = Symbol("length");
var DomClassList = class {
  static change(cls, add, remove, as = "string") {
    remove = DomClassList.normalize(remove, "object");
    const after = DomClassList.normalize(cls, "array").filter((c) => !remove[c]);
    if (add) {
      add = DomClassList.normalize(add, "array");
      for (let i = 0; i < add.length; ++i) {
        if (!after.includes(add[i])) {
          after.push(add[i]);
        }
      }
    }
    return DomClassList.normalize(after, as);
  }
  static from(classes, returnEmpty) {
    if (classes) {
      if (classes.isDomClassList) {
        returnEmpty = returnEmpty != null ? returnEmpty : true;
      } else {
        returnEmpty = returnEmpty != null ? returnEmpty : Objects.isObject(classes) && !Objects.isEmpty(classes);
        classes = new DomClassList(classes);
      }
      if (!classes.value && !returnEmpty) {
        classes = null;
      }
    }
    return classes || (returnEmpty ? new DomClassList() : null);
  }
  /**
   * Converts a class name of any understood type to a desired form.
   * @param {String|String[]|Object|Set|Map|HTMLElement} cls
   * @param {String} as Pass `'object'` to return an object with the class names as its keys (all keys will have a
   * value of `true`), or pass `'array'` to return an array of class names, or pass `'string'` (the default) to
   * return a space-separated string of class names.
   * @returns {String|String[]|Object}
   * @internal
   */
  static normalize(cls, as = "string") {
    cls = cls || "";
    const type = typeof cls, asArray = as === "array", asObject = as === "object", asString = !asArray && !asObject;
    let isString = type === "string", c, i, ret;
    if (type === "object") {
      if (cls.nodeType === Element.ELEMENT_NODE && typeof cls.getAttribute === "function") {
        cls = cls.getAttribute("class") || "";
        isString = true;
      } else if (cls == null ? void 0 : cls.isDomClassList) {
        cls = cls.values;
      } else if (cls instanceof DOMTokenList) {
        cls = Array.from(cls);
      } else if (cls instanceof Map) {
        cls = Array.from(cls.keys()).filter((k) => cls.get(k));
      } else if (cls instanceof Set) {
        cls = Array.from(cls);
      } else if (!Array.isArray(cls)) {
        cls = Objects.getTruthyKeys(cls);
      }
    }
    if (isString) {
      cls = [...new Set(StringHelper.split(cls))];
    }
    for (i = cls.length; i-- > 0; ) {
      c = cls[i];
      if (!c.length) {
        cls.splice(i, 1);
      } else if (c.includes(" ")) {
        cls.splice(i, 1, ...StringHelper.split(c));
      }
    }
    if (asArray) {
      ret = cls;
    } else if (asString) {
      ret = cls.join(" ");
    } else {
      ret = /* @__PURE__ */ Object.create(null);
      for (i = 0; i < cls.length; ++i) {
        ret[cls[i]] = true;
      }
    }
    return ret;
  }
  /**
   * Initializes a new DomClassList.
   * @param {...String|Object} classes The CSS classes as strings or objects.
   * @function constructor
   */
  constructor(...classes) {
    this.process(1, classes);
  }
  /**
   * Clears all class names from this DomClassList instance.
   * @returns {Core.helper.util.DomClassList} this DomClassList.
   */
  clear() {
    for (const key in this) {
      this[key] = false;
    }
    return this;
  }
  /**
   * Sets this DomClassList instance to represent the classes passed as either strings or objects.
   * @returns {Core.helper.util.DomClassList} this DomClassList.
   */
  set(...classes) {
    return this.clear().process(1, classes);
  }
  // To gain some speed in DomHelper.sync(), faster than instanceof etc
  get isDomClassList() {
    return true;
  }
  /**
   * Returns a clone of this DomClassList with all the same keys set.
   * @returns {Core.helper.util.DomClassList} A clone of this DomClassList.
   */
  clone() {
    return new DomClassList(this);
  }
  /**
   * Returns a Boolean value, indicating whether this ClassList has the specified CSS class name.
   * @param {String} className CSS class name to check
   * @returns {Boolean} true if this ClassList contains the passed CSS class name, false otherwise
   */
  contains(className) {
    if (typeof className === "string" && className) {
      return Boolean(this[className]);
    }
    return false;
  }
  // An instance of this class may be assigned directly to an element's className
  // it will be coerced to a string value using this method.
  toString() {
    return this.length ? `${this.value} ` : "";
  }
  toJSON() {
    return this.toString();
  }
  /**
   * Analogous to string.trim, returns the string value of this `DomClassList` with no trailing space.
   * @returns {String} A concatenated string value of all the class names in this `DomClassList`
   * separated by spaces.
   */
  trim() {
    return this.value;
  }
  /**
   * Compares this DomClassList to another DomClassList (or class name string of space separated classes).
   * If the same class names (regardless of order) are present, the two are considered equal.
   *
   * So `new DomClassList('foo bar bletch').isEqual('bletch bar foo')` would return `true`
   * @param {Core.helper.util.DomClassList|String} other The `DomClassList` or string of classes to compare to.
   * @returns {Boolean} `true` if the two contain the same class names.
   */
  isEqual(other) {
    const otherClasses = DomClassList.normalize(other, "array"), len = otherClasses.length;
    if (this.length === len) {
      for (let i = 0; i < len; i++) {
        if (!this[otherClasses[i]]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  /**
   * Get/set string value.
   * Class names separated with space.
   * @property {String}
   */
  get value() {
    let value = this[valueSymbol], keys;
    if (value == null) {
      keys = Objects.getTruthyKeys(this);
      this[lengthSymbol] = keys.length;
      this[valueSymbol] = value = keys.join(" ");
    }
    return value;
  }
  set value(value) {
    const me = this, keys = Object.keys(me), len = keys.length;
    for (let i = 0; i < len; i++) {
      delete me[keys[i]];
    }
    if (value) {
      me.process(1, [value]);
    } else {
      delete me[valueSymbol];
    }
  }
  /**
   * Returns string values as an array.
   * @readonly
   * @property {String[]}
   */
  get values() {
    return Objects.getTruthyKeys(this);
  }
  get length() {
    return this.value ? this[lengthSymbol] : 0;
  }
  process(value, classes) {
    for (let cls, k, i = 0; i < classes.length; i++) {
      if (classes[i]) {
        cls = classes[i];
        if (cls.isDomClassList || Objects.isObject(cls)) {
          for (k in cls) {
            this[k] = value ? cls[k] : !cls[k];
          }
        } else {
          cls = DomClassList.normalize(classes[i], "array");
          for (k = 0; k < cls.length; ++k) {
            this[cls[k]] = value;
          }
        }
      }
    }
    delete this[valueSymbol];
    return this;
  }
  /**
   * Adds/removes class names according to the passed object's properties.
   *
   * Properties with truthy values are added.
   * Properties with falsy values are removed.
   * @param {Object} classList Object containing properties to set/clear
   */
  assign(classList) {
    for (const cls in classList) {
      if (!this[cls] !== !classList[cls]) {
        this[cls] = classList[cls];
        delete this[valueSymbol];
      }
    }
    return this;
  }
  /**
   * Adds/removes this objects classes to the passed `classList` or element.
   *
   * Properties with truthy values are added.
   * Properties with falsy values are removed.
   * @param {HTMLElement|DOMTokenList} element The element or the element's `classList` to be updated.
   */
  assignTo(element) {
    const classList = element.nodeType === Element.ELEMENT_NODE ? element.classList : element, temp = DomClassList.from(classList);
    temp.add(this);
    classList.value = temp.value;
  }
  /**
   * Add CSS class(es)
   * ```
   * myClassList.add('bold', 'small');
   * ```javascript
   * @param {String|String[]|Object} classes CSS classes to add
   */
  add(...classes) {
    return this.process(1, classes);
  }
  /**
   * Remove CSS class(es)
   * ```javascript
   * myClassList.remove('bold', 'small');
   * ```
   * @param {String} classes CSS classes to remove
   */
  remove(...classes) {
    return this.process(0, classes);
  }
  /**
   * Toggles the passed CSS class name.
   *
   * If the `force` parameter is passed, `true` means add the class name, `false` means remove it.
   *
   * ```javascript
   * myClassList.toggle('bold', isImportant);
   * ```
   * @param {String} className CSS class to toggle
   * @param {Boolean} [force] `true` to add the class, `false` to remove it.
   * @returns {Boolean} `true` if the operation changed the value.
   */
  toggle(className, flag = Boolean(!this[className])) {
    flag = Boolean(flag);
    if (Boolean(this[className]) !== flag) {
      this[className] = flag;
      delete this[valueSymbol];
      return true;
    }
  }
  /**
   * Analogous to the `String#split` method, but with no delimiter
   * parameter. This method returns an array containing the individual
   * CSS class names set.
   * @returns {String[]} The individual class names in this `DomClassList`
   */
  split() {
    return Objects.getTruthyKeys(this);
  }
  forEach(fn2) {
    return Objects.getTruthyKeys(this).forEach(fn2);
  }
};
DomClassList.prototype[valueSymbol] = null;
DomClassList._$name = "DomClassList";

// ../Core/lib/Core/data/AjaxStore.js
var processParamEntry = (paramArray, entry) => {
  if (Array.isArray(entry[1])) {
    entry[1].forEach((value) => paramArray.push(encodeURIComponent(entry[0]) + "=" + encodeURIComponent(value)));
  } else {
    paramArray.push(encodeURIComponent(entry[0]) + "=" + encodeURIComponent(entry[1]));
  }
  return paramArray;
};
var immediatePromise = Promise.resolve();
var prependZeros = (num) => {
  return String(num).padStart(2, "0");
};
var dateToString = (date) => {
  return `${date.getFullYear()}-${prependZeros(date.getMonth() + 1)}-${prependZeros(date.getDate())}T${prependZeros(date.getHours())}:${prependZeros(date.getMinutes())}:${prependZeros(date.getSeconds())}.${date.getMilliseconds()}`;
};
var AjaxStore = class extends Store {
  // region Events
  /**
   * Fired when a remote request fails, either at the network level, or the server returns a failure, or an invalid
   * response.
   *
   * Note that when a {@link #function-commit} fails, more than one exception event will be triggered. The individual
   * operation, `create`, `update` or `delete` will trigger their own `exception` event, but the encapsulating commit
   * operation will also trigger an `exception` event when all the operations have finished, so if exceptions are
   * going to be handled gracefully, the event's `action` property must be examined, and the constituent operations of
   * the event must be examined.
   * @event exception
   * @param {Core.data.Store} source This Store
   * @param {Boolean} exception `true`
   * @param {'create'|'read'|'update'|'delete'|'commit'} action Action that failed, `'create'`, `'read'`,
   * `'update'` or `'delete'`. May also be fired with '`commit'` to indicate the failure of an aggregated `create`,
   * `update` and `delete` operation. In this case, the event will contain a property for each operation of the commit
   * named `'create'`, `'update'` and `'delete'`, each containing the individual `exception` events.
   * @param {'network'|'failure'} exceptionType The type of failure, `'network'` or `'server'`
   * @param {Response} response the `Response` object
   * @param {Object} json The decoded response object *if the exceptionType is `'server'`*
   */
  /**
   * Fired after committing added records
   * @event commitAdded
   * @param {Core.data.Store} source This Store
   */
  /**
   * Fired after committing modified records
   * @event commitModified
   * @param {Core.data.Store} source This Store
   */
  /**
   * Fired on successful load
   * @event load
   * @param {Core.data.Store} source This Store
   * @param {Object[]} data Data loaded
   * @param {Response} response the `Response` object
   * @param {Object} json The decoded response object.
   */
  /**
   * Fired on successful load of remote child nodes for a tree node.
   * @event loadChildren
   * @param {Core.data.Store} source This Store
   * @param {Object[]} data Data loaded
   * @param {Object} json The decoded response object.
   */
  /**
   * Fired after committing removed records
   * @event commitRemoved
   * @param {Core.data.Store} source This Store
   */
  /**
   * Fired before loading starts. Allows altering parameters and is cancelable
   * @event beforeLoad
   * @preventable
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax request.
   */
  /**
   * Fired before loading of remote child nodes of a tree node starts. Allows altering parameters and is cancelable
   * @event beforeLoadChildren
   * @preventable
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax request.
   */
  /**
   * When the store {@link #property-isPaged is paged}, this is fired before loading a page and is cancelable
   * @event beforeLoadPage
   * @preventable
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax request.
   */
  /**
   * Fired when loading is beginning. This is not cancelable. Parameters in the event may still be
   * mutated at this stage.
   * @event loadStart
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax request.
   */
  /**
   * Fired when loading of remote child nodes into a tree node is beginning. This is not cancelable. Parameters in the
   * event may still be mutated at this stage.
   * @event loadChildrenStart
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax request.
   */
  /**
   * Fired before any remote request is initiated.
   * @event beforeRequest
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing key/value pairs that are passed on the request query string
   * @param {Object} body The body of the request to be posted to the server.
   * @param {'create'|'read'|'update'|'delete'} action Action that is making the request, `'create'`,
   * `'read'`, `'update'` or `'delete'`
   */
  /**
   * Fired after any remote request has finished whether successfully or unsuccessfully.
   * @event afterRequest
   * @param {Boolean} exception `true`. *Only present if the request triggered an exception.*
   * @param {'create'|'read'|'update'|'delete'} action Action that has finished, `'create'`, `'read'`,
   * `'update'` or `'delete'`
   * @param {'network'|'failure'} exceptionType The type of failure, `'network'` or `'server'`. *Only present
   * if the request triggered an exception.*
   * @param {Response} response The `Response` object
   * @param {Object} json The decoded response object if there was no `'network'` exception.
   */
  // endregion
  //region Config
  static get defaultConfig() {
    return {
      /**
       * A string keyed object containing the HTTP headers to add to each server request issued by this store.
       *
       * `AjaxStore` uses the Fetch API under the hood, read more about headers on
       * [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#headers)
       *
       * Example usage:
       *
       * ```javascript
       * const store = new AjaxStore({
       *    headers : {
       *        Authorization : 'auth-contents-goes-here'
       *    }
       * });
       * ```
       *
       * @config {Object<String,String>}
       * @category Remote
       */
      headers: null,
      /**
       * An object containing the Fetch options to pass to each server request issued by this store. Use this to
       * control if credentials are sent and other options, read more at
       * [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#supplying_request_options).
       *
       * Example usage:
       *
       * ```javascript
       * const store = new AjaxStore({
       *    fetchOptions : {
       *        credentials : 'omit',
       *        redirect    : 'error'
       *    }
       * });
       * ```
       *
       * @config {Object}
       * @category Remote
       */
      fetchOptions: null,
      /**
       * Specify `true` to send payloads as form data, `false` to send as regular JSON.
       * @config {Boolean}
       * @default false
       * @category Remote
       */
      sendAsFormData: null,
      /**
       * Specify `true` to send all model fields when committing modified records (as opposed to just the
       * modified fields)
       * @config {Boolean}
       * @default false
       * @category Remote
       */
      writeAllFields: null,
      /**
       * The name of the HTTP parameter passed to this Store's {@link #config-readUrl} to indicate the node `id`
       * to load when loading child nodes on demand if the node being expanded was created with data containing
       * `children: true`.
       * @config {String}
       * @default
       * @category Remote
       */
      parentIdParamName: "id",
      /**
       * The optional property name in JSON responses from the server that contains a boolean
       * success/fail status.
       * ```json
       * {
       *   "responseMeta" : {
       *   {
       *     "success" : true,
       *     "count" : 100
       *   },
       *   // The property name used here should match that of 'responseDataProperty'
       *   "data" : [
       *     ...
       *   ]
       * }
       * ```
       *
       * The store would be configured with:
       * ```javascript
       *  {
       *      ...
       *      successDataProperty : 'responseMeta.success',
       *      responseTotalProperty : 'responseMeta.count'
       *      ...
       *  }
       *
       * ```
       * @config {String}
       * @default
       * @category Remote
       */
      responseSuccessProperty: "success",
      /**
       * The property name in JSON responses from the server that contains the data for the records
       * ```json
       * {
       *   "success" : true,
       *   // The property name used here should match that of 'responseDataProperty'
       *   "data" : [
       *     ...
       *   ]
       * }
       * ```
       * @config {String}
       * @default
       * @category Remote
       */
      responseDataProperty: "data",
      /**
       * The property name in JSON responses from the server that contains the dataset total size
       * **when this store {@link #property-isPaged is paged}**
       * ```json
       * {
       *   "success" : true,
       *   // The property name used here should match that of 'responseDataProperty'
       *   "data" : [
       *     ...
       *   ],
       *   // The property name used here should match that of 'responseTotalProperty'
       *   "total" : 65535
       * }
       * ```
       * @config {String}
       * @default
       * @category Remote
       */
      responseTotalProperty: "total",
      /**
       * The name of the HTTP parameter to use to pass any encoded filters when loading data from the server and a
       * filtered response is required.
       *
       * **Note:** When this is set, filters must be defined using a field name, an operator and a value
       * to compare, **not** a comparison function.
       * @config {String}
       * @category Remote
       */
      filterParamName: null,
      /**
       * Set this flag to true if you are filtering remote using restful URLs (e.g.
       * https://nominatim.openstreetmap.org/search/paris?format=json)
       *
       * **Note:** When this is set, the filter string is appended to the readUrl.
       * @config {Boolean}
       * @category Remote
       */
      restfulFilter: false,
      /**
       * The name of the HTTP parameter to use to pass any encoded sorters when loading data from the server and a
       * sorted response is required.
       *
       * **Note:** When this is set, sorters must be defined using a field name and an ascending flag,
       * **not** a sort function.
       * @config {String}
       * @category Remote
       */
      sortParamName: null,
      /**
       * The name of the HTTP parameter to use when requesting pages of data using the **one based** page number
       * required.
       * @config {String}
       * @category Paging
       */
      pageParamName: null,
      /**
       * The name of the HTTP parameter to use when requesting pages of data using the **zero based** index of the
       * required page's starting record.
       * @config {String}
       * @category Paging
       */
      pageStartParamName: null,
      /**
       * The name of the HTTP parameter to use when requesting pages of data using the **zero based** index of the
       * required page's starting record.
       * @config {String}
       * @default
       * @category Paging
       */
      pageSizeParamName: "pageSize",
      /**
       * When paging of data is requested by setting _either_ the {@link #config-pageParamName} _or_ the
       * {@link #config-pageStartParamName}, this is the value to send in the {@link #config-pageSizeParamName}.
       * @config {Number}
       * @default
       * @category Paging
       */
      pageSize: 50,
      /**
       * Set to true to use restful {@link #config-httpMethods}
       * @config {Boolean}
       * @default false
       * @category Remote
       */
      useRestfulMethods: null,
      /**
       * The HTTP methods to use for CRUD requests when {@link #config-useRestfulMethods} is enabled.
       *
       * ```javascript
       * new AjaxStore({
       *    useRestfulMethods : true,
       *    httpMethods : {
       *        create : 'POST',
       *        read   : 'POST',
       *        update : 'PATCH',
       *        delete : 'DELETE'
       *    }
       * });
       *
       * ```
       * @config {HttpMethods}
       * @default
       * @category Remote
       */
      httpMethods: {
        create: "POST",
        read: "GET",
        update: "PUT",
        delete: "DELETE"
      }
    };
  }
  static get configurable() {
    return {
      /**
       * An object containing key/value pairs that are passed on the request query string.
       * @member {Object} params
       * @category Remote
       */
      /**
       * An object containing key/value pairs that are passed on the request query string.
       * @config {Object}
       * @category Remote
       */
      params: null
    };
  }
  /**
   * Url to post newly created records to.
   *
   * The response must be in the form:
   *
   *     {
   *         "success": true,
   *         "data": [{
   *             "id": 0, "name": "General Motors"
   *         }, {
   *             "id": 1, "name": "Apple"
   *         }]
   *     }
   *
   * Just the array of data may be returned, however that precludes the orderly handling of errors encountered at the
   * server.
   *
   * If the server encountered an error, the packet would look like this:
   *
   *     {
   *         "success": false,
   *         "message": "Some kind of database error"
   *     }
   *
   * And that packet would be available in the {@link #event-exception} handler in the `response` property of the
   * event.
   *
   * The `success` property may be omitted, it defaults to `true`.
   *
   * @prp {String} createUrl
   * @category CRUD
   */
  /**
   * Url to read data from.
   *
   * The response must be in the form:
   *
   *     {
   *         "success": true,
   *         "data": [{
   *             "id": 0, "name": "General Motors"
   *         }, {
   *             "id": 1, "name": "Apple"
   *         }]
   *     }
   *
   * If the store {@link #property-isPaged is paged}, the total dataset size must be returned in the
   * {@link #config-responseTotalProperty} property:
   *
   *     {
   *         "success": true,
   *         "data": [{
   *             "id": 0, "name": "General Motors"
   *         }, {
   *             "id": 1, "name": "Apple"
   *         }],
   *         "total": 65535
   *     }
   *
   * Just the array of data may be returned, however that precludes the orderly handling of errors encountered at the
   * server.
   *
   * If the server encountered an error, the packet would look like this:
   *
   *     {
   *         "success": false,
   *         "message": "Some kind of database error"
   *     }
   *
   * And that packet would be available in the {@link #event-exception} handler in the `response` property of the
   * event.
   *
   * The `success` property may be omitted, it defaults to `true`.
   *
   * @prp {String} readUrl
   * @category CRUD
   */
  /**
   * Url to post record modifications to.
   *
   * The response must be in the form:
   *
   *     {
   *         "success": true,
   *         "data": [{
   *             "id": 0, "name": "General Motors"
   *         }, {
   *             "id": 1, "name": "Apple"
   *         }]
   *     }
   *
   * Just the array of data may be returned, however that precludes the orderly handling of errors encountered at the
   * server.
   *
   * If the server encountered an error, the packet would look like this:
   *
   *     {
   *         "success": false,
   *         "message": "Some kind of database error"
   *     }
   *
   * And that packet would be available in the {@link #event-exception} handler in the `response` property of the
   * event.
   *
   * The `success` property may be omitted, it defaults to `true`.
   *
   * @prp {String} updateUrl
   * @category CRUD
   */
  /**
   * Url for deleting records.
   *
   * The response must be in the form:
   *
   *     {
   *         "success": true
   *     }
   *
   * If the server encountered an error, the packet would look like this:
   *
   *     {
   *         "success": false,
   *         "message": "Some kind of database error"
   *     }
   *
   * And that packet would be available in the {@link #event-exception} handler in the `response` property of the
   * event.
   *
   * The `success` property may be omitted, it defaults to `true`.
   *
   * @prp {String} deleteUrl
   * @category CRUD
   */
  /**
   * True to initiate a load when the store is instantiated
   * @config {Boolean} autoLoad
   * @category Common
   */
  //endregion
  afterConstruct(config) {
    super.afterConstruct(config);
    if (this.autoLoad) {
      this.load().catch(() => {
      });
    }
  }
  /**
   * Returns a truthy value if the Store is currently loading.
   *
   * A load operation is initiated by a load call, but the network request is not sent until
   * after a delay until the next event loop because of allowing all operations which may
   * request a load to coalesce into one call.
   *
   * If the loading request is in this waiting state, the value will be `1`,
   *
   * If the network request is in flight, the value will be `2`
   * @property {Boolean|Number}
   * @readonly
   * @category CRUD
   */
  get isLoading() {
    return this._isLoading ? 2 : this.loadTriggerPromise ? 1 : false;
  }
  /**
   * Returns true if the Store is currently committing
   * @property {Boolean}
   * @readonly
   * @category CRUD
   */
  get isCommitting() {
    return Boolean(this.commitPromise);
  }
  set pageParamName(pageParamName) {
    if (this.tree) {
      throw new Error("Paging cannot be supported for tree stores");
    }
    if (this.pageStartParamName) {
      throw new Error("Configs pageStartParamName and pageParamName are mutually exclusive");
    }
    this._pageParamName = pageParamName;
  }
  get pageParamName() {
    return this._pageParamName;
  }
  set pageStartParamName(pageStartParamName) {
    if (this.tree) {
      throw new Error("Paging cannot be supported for tree stores");
    }
    if (this.pageParamName) {
      throw new Error("Configs pageParamName and pageStartParamName are mutually exclusive");
    }
    this._pageStartParamName = pageStartParamName;
  }
  get pageStartParamName() {
    return this._pageStartParamName;
  }
  /**
   * Yields true if this Store is loaded page by page. This yields `true` if either of the
   * {@link #config-pageParamName} of {@link #config-pageStartParamName} configs are set.
   * @property {Boolean}
   * @readonly
   * @category Paging
   */
  get isPaged() {
    return this.pageParamName || this.pageStartParamName;
  }
  /**
   * Yields the complete dataset size. If the store is {@link #property-isPaged is paged} this is the value
   * returned in the last loaded data block in the {@link #config-responseTotalProperty} property. Otherwise it is
   * the number of records in the store's underlying storage collection.
   * @property {Number}
   * @readonly
   * @category Paging
   */
  get allCount() {
    return "remoteTotal" in this ? this.remoteTotal : super.allCount;
  }
  /**
   * **If the store {@link #property-isPaged is paged}**, yields the highest page number in the dataset as calculated
   * from the {@link #config-responseTotalProperty}
   * returned in the last page data block loaded.
   * @property {Number}
   * @readonly
   * @category Paging
   */
  get lastPage() {
    if (this.isPaged) {
      return Math.floor((this.allCount + this.pageSize - 1) / this.pageSize);
    }
  }
  buildQueryString(url, ...paramObjects) {
    const hasParamsInUrl = url.includes("?"), queryString = Object.entries(Object.assign({}, ...paramObjects)).reduce(processParamEntry, []).join("&");
    return queryString ? (hasParamsInUrl ? "&" : "?") + queryString : "";
  }
  /**
   * Internal sort method.
   * Should not be used in application code directly.
   * @param silent
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @internal
   */
  async performSort(silent) {
    const me = this;
    if (me.remoteSort && !me.isRemoteDataLoading) {
      me.isRemoteDataLoading = true;
      const result = await me.internalLoad({}, "", (event) => {
        me.data = event.data;
        me.afterPerformSort(silent);
      });
      me.isRemoteDataLoading = false;
      return result;
    } else {
      super.performSort(silent);
    }
  }
  /**
   * Internal filter method.
   * Should not be used in application code directly.
   * @param silent
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @internal
   */
  async performFilter(silent) {
    var _a2;
    const me = this;
    if (me.remoteFilter) {
      (_a2 = me.loadingPromise) == null ? void 0 : _a2.abort();
      me.isRemoteDataLoading = true;
      const oldCount = me.count, { filters } = me;
      me.currentPage = 1;
      const result = await me.internalLoad({}, "", (event) => {
        me.data = event.data;
        event = silent ? null : {
          action: "filter",
          filters,
          oldCount,
          records: me.storage.values
        };
        me.afterPerformFilter(event);
        me.trigger("refresh", event);
      });
      me.isRemoteDataLoading = false;
      return result;
    } else {
      super.performFilter(silent);
    }
  }
  /**
   * A provided function which creates an array of values for the {@link #config-filterParamName} to pass
   * any filters to the server upon load.
   *
   * By default, this creates a JSON string containing the following properties:
   *
   * ```javascript
   *    [{
   *        field         : <theFieldName>
   *        operator      : May be: `'='`, `'!='`, `'>'`, `'>='`, `'<'`, `'<='`, `'*'`, `'startsWith'`, `'endsWith'`
   *        value         : The value to compare
   *        caseSensitive : true for case sensitive comparisons
   *    }]
   * ```
   * @param {Core.util.CollectionFilter[]} filters The filters to encode.
   */
  encodeFilterParams(filters) {
    const result = [];
    for (const { property, operator, value, caseSensitive } of filters) {
      result.push({
        field: property,
        operator,
        value,
        caseSensitive
      });
    }
    return JSON.stringify(result, function(key, value) {
      return key === "" ? value : this[key] instanceof Date ? dateToString(this[key]) : value;
    });
  }
  /**
   * A provided function which creates an array of values for the {#config-sortParamName} to pass
   * any sorters to the server upon load.
   *
   * By default, this creates a JSON string containing the following properties:
   *
   * ```javascript
   *    [{
   *        field     : <theFieldName>
   *        ascending : true/false
   *    }]
   * ```
   *
   * @param {Sorter[]} sorters The sorters to encode.
   */
  encodeSorterParams(sorters) {
    return JSON.stringify(sorters.filter((sorter) => !sorter.sortFn).map((sorter) => sorter));
  }
  buildReadUrl() {
    const { readUrl } = this;
    if (this.restfulFilter && this.filters.count) {
      const url = readUrl.endsWith("/") ? readUrl : readUrl + "/";
      return url + this.filters.first.value;
    }
    return readUrl;
  }
  /**
   * Internal data loading method.
   * @returns {Promise}
   * @internal
   */
  internalLoad(params, eventName, successFn, delay3 = 0) {
    params = ObjectHelper.assign({}, this.params, params);
    const me = this, url = me.buildReadUrl(), event = { action: "read" + eventName, params, url };
    if (!url) {
      throw new Error("No load url specified");
    }
    if (me.trigger("beforeLoad" + eventName, event) === false) {
      throw false;
    }
    me.loadArgs = [url, event, params, eventName, successFn];
    if (delay3 === false) {
      return new Promise((resolve, reject) => me.sendLoadRequest(resolve, reject));
    }
    return me.loadTriggerPromise || (me.loadTriggerPromise = new Promise((resolve, reject) => {
      me.setTimeout({
        delay: delay3,
        fn: "sendLoadRequest",
        args: [resolve, reject],
        cancelOutstanding: true
      });
    }));
  }
  // Send the request for the internalLoad.
  // This is called on a timeout 1ms after the internalLoad call.
  async sendLoadRequest(resolve, reject) {
    const me = this, [
      url,
      event,
      params,
      eventName,
      successFn
    ] = me.loadArgs;
    me.loadTriggerPromise = null;
    if (url) {
      me._isLoading = true;
      me.trigger(`load${eventName}Start`, event);
      me.trigger("beforeRequest", event);
      if (me.filterParamName && me.isFiltered) {
        params[me.filterParamName] = me.encodeFilterParams(me.filters.values);
      }
      if (me.remoteSort && me.isSorted) {
        params[me.sortParamName] = me.encodeSorterParams(me.groupers ? me.groupers.concat(me.sorters) : me.sorters);
      }
      if (me.isPaged) {
        if (!(me.pageParamName in params || me.pageStartParamName in params)) {
          const page = Math.min(me.currentPage || 1, me.allCount ? me.lastPage : Infinity);
          if (me.pageParamName) {
            params[me.pageParamName] = page;
          } else {
            params[me.pageStartParamName] = (page - 1) * me.pageSize;
          }
        }
        params[me.pageSizeParamName] = me.pageSize;
      }
      const options = { headers: me.headers, parseJson: true };
      if (me.useRestfulMethods) {
        options.method = me.httpMethods.read;
        if (event.body) {
          options.body = JSON.stringify(event.body);
        }
      }
      try {
        const promise = me.loadingPromise = AjaxHelper.get(event.url + me.buildQueryString(event.url, params), ObjectHelper.assign(options, me.fetchOptions)), response = await promise, data = response.parsedJson, isArray2 = Array.isArray(data), success = isArray2 || data && ObjectHelper.getPath(data, me.responseSuccessProperty) !== false, remoteTotal = isArray2 ? null : ObjectHelper.getPath(data, me.responseTotalProperty);
        if (me.isDestroyed) {
          return;
        }
        me.loadingPromise = null;
        me._isLoading = false;
        event.response = response;
        event.json = data;
        if (success) {
          if (remoteTotal != null) {
            me.remoteTotal = parseInt(remoteTotal, 10);
          }
          if (me.isPaged) {
            if (me.remoteTotal >= 0) {
              const requestedPage = me.pageParamName ? params[me.pageParamName] : params[me.pageStartParamName] / me.pageSize + 1;
              me.currentPage = Math.min(requestedPage, me.lastPage);
            } else {
              throw new Error("A paged store must receive its responseTotalProperty in each data packet");
            }
          }
          event.data = isArray2 ? data : ObjectHelper.getPath(data, me.responseDataProperty);
          await successFn(event);
          !me.isDestroyed && me.trigger("load" + eventName, event);
          resolve(event);
        } else {
          Object.assign(event, {
            exception: true,
            exceptionType: "server",
            error: data == null ? void 0 : data.error
          });
          !me.isDestroyed && me.trigger("exception", event);
          reject(event);
        }
        !me.isDestroyed && me.trigger("afterRequest", event);
      } catch (responseOrError) {
        me._isLoading = false;
        event.exception = true;
        if (responseOrError instanceof Response) {
          event.exceptionType = responseOrError.ok ? "server" : "network";
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = "server";
          event.error = responseOrError;
        }
        !me.isDestroyed && me.trigger("exception", event);
        reject(event);
        !me.isDestroyed && me.trigger("afterRequest", event);
      }
    }
  }
  /**
   * Load data from the {@link #config-readUrl}.
   * @param {Object} [params] A hash of parameters to append to querystring (will also append Store#params)
   * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is
   * vetoed by a {@link #event-beforeLoad} handler, or if an {@link #event-exception} is detected.
   * The resolved function is passed the event object passed to any event handlers.
   * The rejected function is passed the {@link #event-exception} event if an exception occurred,
   * or `false` if the load was vetoed by a {@link #event-beforeLoad} handler.
   * @fires beforeLoad
   * @fires loadStart
   * @fires beforeRequest
   * @fires load
   * @fires exception
   * @fires afterRequest
   * @category CRUD
   */
  async load(params) {
    const me = this;
    if (me.isPaged) {
      return me.loadPage(me.currentPage || 1, params);
    } else {
      return me.internalLoad(params, "", (event) => {
        me.data = event.data;
      });
    }
  }
  /**
   * Loads children into specified parent record. Parent records id is sent as a param (param name configured with
   * {@link #config-parentIdParamName}.
   * @param {Core.data.Model} parentRecord Parent record
   * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is
   * vetoed by a {@link #event-beforeLoadChildren} handler, or if an {@link #event-exception} is detected.
   * The resolved function is passed the event object passed to any event handlers.
   * The rejected function is passed the {@link #event-exception} event if an exception occurred,
   * or `false` if the load was vetoed by a {@link #event-beforeLoadChildren} handler.
   * @fires beforeLoadChildren
   * @fires loadChildrenStart
   * @fires beforeRequest
   * @fires loadChildren
   * @fires exception
   * @fires afterRequest
   * @category CRUD
   */
  async loadChildren(parentRecord) {
    return this.readUrl ? this.internalLoad({ [this.parentIdParamName]: parentRecord.id }, "Children", (event) => {
      event.parentRecord = parentRecord;
      if (parentRecord.children.length) {
        parentRecord.clearChildren(true);
      }
      parentRecord.data[parentRecord.constructor.childrenField] = event.data;
      parentRecord.processChildren(parentRecord.stores);
    }, false) : this.immediatePromise;
  }
  /**
   * Loads a page of data from the {@link #config-readUrl}.
   * @param {Number} page The *one based* page number to load.
   * @param {Object} params A hash of parameters to append to querystring (will also append Store#params)
   * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is
   * vetoed by a {@link #event-beforeLoadPage} handler, or if an {@link #event-exception} is detected.
   * The resolved function is passed the event object passed to any event handlers.
   * The rejected function is passed the {@link #event-exception} event if an exception occurred,
   * or `false` if the load was vetoed by a {@link #event-beforeLoadPage} handler.
   * @fires beforeLoadPage
   * @fires loadPageStart
   * @fires beforeRequest
   * @fires loadPage
   * @fires exception
   * @fires afterRequest
   * @category CRUD
   */
  async loadPage(page, params) {
    if (this.allCount) {
      page = Math.min(page, this.lastPage);
    }
    const me = this, pageParam = me.pageParamName ? {
      [me.pageParamName]: page
    } : {
      [me.pageStartParamName]: (page - 1) * me.pageSize
    };
    pageParam[me.pageSizeParamName] = me.pageSize;
    return me.internalLoad(ObjectHelper.assign(pageParam, params), "Page", (event) => {
      me.loadData(event.data, "pageLoad");
    });
  }
  /**
   * If this store {@link #property-isPaged is paged}, and is not already at the {@link #property-lastPage}
   * then this will load the next page of data.
   * @fires beforeLoadPage
   * @fires loadPageStart
   * @fires beforeRequest
   * @fires loadPage
   * @fires exception
   * @fires afterRequest
   * @category CRUD
   * @returns {Promise} A promise which is resolved when the Ajax request completes and has been processed.
   */
  async nextPage(params) {
    const me = this;
    return me.isPaged && me.currentPage !== me.lastPage ? me.loadPage(me.currentPage + 1, params) : immediatePromise;
  }
  /**
   * If this store {@link #property-isPaged is paged}, and is not already at the first page
   * then this will load the previous page of data.
   * @fires beforeLoadPage
   * @fires loadPageStart
   * @fires beforeRequest
   * @fires loadPage
   * @fires exception
   * @fires afterRequest
   * @category CRUD
   * @returns {Promise} A promise which is resolved when the Ajax request completes and has been processed.
   */
  async previousPage(params) {
    return this.isPaged && this.currentPage !== 1 ? this.loadPage(this.currentPage - 1, params) : immediatePromise;
  }
  /**
   * Commits all changes (added, modified and removed) using corresponding urls ({@link #config-createUrl},
   * {@link #config-updateUrl} and {@link #config-deleteUrl})
   * @fires beforeCommit
   * @returns {Promise} A Promise which is resolved only if all pending changes (Create, Update and Delete)
   * successfully resolve. Both the resolve and reject functions are passed a `commitState` object which is stored the
   * {@link #event-afterRequest} event for each request. Each event contains the `exception`, `request` and `response`
   * properties eg:
   *
   * ```javascript
   * {
   *      // If *all* commits succeeded
   *      success: true,
   *      changes: {
   *          added: [records...],
   *          modified: [records...],
   *          removed: [records...],
   *      },
   *      added: {
   *          source: theStore,
   *
   *          // Only if the add request triggered an exception
   *          exception: true,
   *
   *          // Only if the add request triggered an exception
   *          exceptionType: 'server', // Or 'network'
   *
   *          response: Response,
   *          json: parsedResponseObject
   *      },
   *      // Same format as added
   *      modified: {},
   *      removed: {}
   * }
   * ```
   *
   * If there were no pending changes, the resolve and reject functions are passed no parameters.
   *
   * Returns `false` if a commit operation is already in progress.
   * The resolved function is passed the event object passed to any event handlers.
   * The rejected function is passed the {@link #event-exception} event if an exception occurred,
   * @category CRUD
   */
  async commit() {
    const me = this, { changes } = me, allPromises = [];
    if (me.commitPromise) {
      return false;
    }
    if (!changes) {
      if (me.modified.count) {
        me.modified.forEach((record) => record.clearChanges(true, false));
        me.modified.clear();
      }
      return immediatePromise;
    }
    if (me.trigger("beforeCommit", { changes }) !== false) {
      [...changes.added, ...changes.modified, ...changes.removed].forEach((record) => record.meta.committing = true);
      me.trigger("commitStart", { changes });
      const commitState = {
        action: "commit",
        exception: false,
        changes
      };
      let p = me.commitRemoved(commitState);
      if (p) {
        allPromises.push(p);
      }
      p = me.commitAdded(commitState);
      if (p) {
        allPromises.push(p);
      }
      p = me.commitModified(commitState);
      if (p) {
        allPromises.push(p);
      }
      if (!allPromises.length) {
        me.modified.forEach((r) => r.clearChanges(true, false));
        me.modified.clear();
        me.added.forEach((r) => r.clearChanges(true, false));
        me.added.clear();
        me.removed.clear();
        me.trigger("commit", { changes });
        return immediatePromise;
      }
      p = allPromises.length === 1 ? allPromises[0] : Promise.all(allPromises);
      return me.commitPromise = new Promise((resolve, reject) => {
        p.then(() => {
          me.commitPromise = null;
          if (commitState.exception) {
            me.trigger("exception", commitState);
            reject(commitState);
          } else {
            me.trigger("commit", { changes });
            resolve(commitState);
          }
        }).catch(() => {
          me.commitPromise = null;
          reject(commitState);
        });
      });
    }
  }
  // Performs background autocommit with reject checking
  doAutoCommit() {
    if (this.suspendCount <= 0) {
      this.commit().catch((commitState) => {
        const { response } = commitState;
        if (!(response && (response.ok && response.parsedJson || [500, 404].includes(response.status)))) {
          throw commitState;
        }
      });
    }
  }
  /**
   * Commits added records by posting to {@link #config-createUrl}.
   * Server should return a JSON object with a 'success' property indicating whether the operation was successful.
   * @param {Object} commitState An object into which is added a `delete` property being the
   * {@link #event-afterRequest} event.
   * @returns {Promise|null} If there are added records, a Promise which will be resolved whether the commit
   * succeeds or fails. The resulting event is placed into the `add` property of the passed `commitState`
   * parameter. If there are no added records, `null` is returned.
   * The resolved function is passed the event object passed to any event handlers.
   * @async
   * @private
   * @fires beforeRequest
   * @fires commitAdded
   * @fires refresh
   * @fires exception
   * @fires afterRequest
   */
  commitAdded(commitState) {
    const me = this, added = me.added, event = { action: "create", params: me.params };
    return added.count && me.createUrl ? new Promise((resolve) => {
      const toAdd = added.values.map((r) => r.persistableData);
      commitState.create = event;
      event.body = { data: toAdd };
      me.trigger("beforeRequest", event);
      let dataToSend = event.body;
      if (me.sendAsFormData) {
        const formData = new FormData();
        formData.append("data", JSON.stringify(toAdd));
        dataToSend = formData;
      }
      const options = { headers: me.headers, parseJson: true }, url = me.createUrl + me.buildQueryString(me.createUrl, me.params);
      if (me.useRestfulMethods) {
        options.method = me.httpMethods.create;
      }
      AjaxHelper.post(url, dataToSend, ObjectHelper.assign(options, me.fetchOptions)).then((response) => {
        const data = response.parsedJson, isArray2 = Array.isArray(data), success = isArray2 || data && data.success !== false;
        commitState.response = response;
        event.json = data;
        event.response = response;
        if (success) {
          me.processReturnedData(added.values, isArray2 ? data : ObjectHelper.getPath(data, me.responseDataProperty));
          added.clear();
          me.trigger("commitAdded");
          me.trigger("refresh", event);
          resolve(commitState);
        } else {
          added.forEach((r) => r.meta.committing = false);
          commitState.exception = event.exception = true;
          commitState.exceptionType = event.exceptionType = "server";
          me.trigger("exception", event);
          resolve(commitState);
        }
        me.trigger("afterRequest", event);
      }).catch((responseOrError) => {
        added.forEach((r) => r.meta.committing = false);
        commitState.exception = event.exception = true;
        if (responseOrError instanceof Response) {
          commitState.response = responseOrError;
          event.exceptionType = responseOrError.ok ? "server" : "network";
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = "server";
          event.error = responseOrError;
        }
        me.trigger("exception", event);
        resolve(commitState);
        me.trigger("afterRequest", event);
      });
    }) : null;
  }
  /**
   * Commits modified records by posting to {@link #config-updateUrl}.
   * Server should return a JSON object with a 'success' property indicating whether the operation was successful.
   * @param {Object} commitState An object into which is added a `delete` property being the
   * {@link #event-afterRequest} event.
   * @returns {Promise|null} If there are added records, a Promise which will be resolved whether the commit
   * succeeds or fails. The resulting event is placed into the `update` property of the passed `commitState`
   * parameter. If there are no added records, `null` is returned.
   * The resolved function is passed the event object passed to any event handlers.
   * @async
   * @private
   * @fires beforeRequest
   * @fires commitModified
   * @fires refresh
   * @fires exception
   * @fires afterRequest
   */
  commitModified(commitState) {
    const me = this, { modified } = me.changes, event = { action: "update", params: me.params }, result = modified.length && me.updateUrl ? new Promise((resolve) => {
      const modifications = modified.map((record) => {
        if (me.writeAllFields) {
          return record.persistableData;
        } else {
          return record.modificationDataToWrite;
        }
      }).filter((el) => !ObjectHelper.isEmpty(el));
      if (modifications.length === 0) {
        me.modified.clear();
        modified.forEach((r) => r.meta.committing = false);
        resolve();
        return;
      }
      commitState.update = event;
      event.body = { data: modifications };
      me.trigger("beforeRequest", event);
      let dataToSend = event.body;
      if (me.sendAsFormData) {
        const formData = new FormData();
        formData.append("data", JSON.stringify(modifications));
        dataToSend = formData;
      }
      const options = { headers: me.headers, parseJson: true };
      if (me.useRestfulMethods) {
        options.method = me.httpMethods.update;
      }
      AjaxHelper.post(
        me.updateUrl + me.buildQueryString(me.updateUrl, me.params),
        dataToSend,
        ObjectHelper.assign(options, me.fetchOptions)
      ).then((response) => {
        const data = response.parsedJson, isArray2 = Array.isArray(data), success = isArray2 || data && data.success !== false;
        commitState.response = response;
        event.json = data;
        event.response = response;
        if (success) {
          me.processReturnedData(modified, isArray2 ? data : ObjectHelper.getPath(data, me.responseDataProperty), true);
          me.modified.clear();
          me.trigger("commitModified");
          me.trigger("refresh", event);
          resolve(commitState);
        } else {
          modified.forEach((r) => r.meta.committing = false);
          commitState.exception = event.exception = true;
          event.exceptionType = "server";
          me.trigger("exception", event);
          resolve(commitState);
        }
        me.trigger("afterRequest", event);
      }).catch((responseOrError) => {
        modified.forEach((r) => r.meta.committing = false);
        commitState.exception = event.exception = true;
        if (responseOrError instanceof Response) {
          commitState.response = responseOrError;
          event.exceptionType = responseOrError.ok ? "server" : "network";
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = "server";
          event.error = responseOrError;
        }
        me.trigger("exception", event);
        resolve(commitState);
        me.trigger("afterRequest", event);
      });
    }) : null;
    if (!modified.length && me.modified.count) {
      me.modified.clear();
    }
    return result;
  }
  processReturnedData(localRecords, returnedData, isUpdating = false) {
    const me = this, Model2 = me.modelClass, idDataSource = Model2.fieldMap.id.dataSource;
    returnedData.forEach((recData, i) => {
      const record = localRecords[i];
      record.clearChanges(true, false);
      record.syncId(recData[idDataSource]);
      Object.assign(localRecords[i].data, Model2.processData(recData, isUpdating, me, record));
    });
  }
  /**
   * Commits removed records by posting to {@link #config-deleteUrl}.
   * Server should return a JSON object with a 'success' property indicating whether the operation was successful.
   * @param {Object} commitState An object into which is added a `delete` property being the
   * {@link #event-afterRequest} event.
   * @returns {Promise|null} If there are added records, a Promise which will be resolved whether the commit
   * succeeds or fails. The resulting event is placed into the `delete` property of the passed `commitState`
   * parameter. If there are no added records, `null` is returned.
   * The resolved function is passed the event object passed to any event handlers.
   * @async
   * @private
   * @fires beforerequest
   * @fires commitremoved
   * @fires refresh
   * @fires exception
   * @fires afterrequest
   */
  commitRemoved(commitState) {
    const me = this, removed = me.removed, event = { action: "delete", params: me.params };
    return removed.count && me.deleteUrl ? new Promise((resolve) => {
      commitState.delete = event;
      event.body = { ids: removed.map((r) => r.id) };
      me.trigger("beforeRequest", event);
      let dataToSend = event.body;
      if (me.sendAsFormData) {
        const formData = new FormData();
        formData.append("id", JSON.stringify(dataToSend.ids));
        dataToSend = formData;
      }
      const options = { headers: me.headers, parseJson: true };
      if (me.useRestfulMethods) {
        options.method = me.httpMethods.delete;
      }
      AjaxHelper.post(
        me.deleteUrl + me.buildQueryString(me.deleteUrl, me.params),
        dataToSend,
        ObjectHelper.assign(options, me.fetchOptions)
      ).then((response) => {
        const data = response.parsedJson, isArray2 = Array.isArray(data), success = isArray2 || data && data.success !== false;
        commitState.response = response;
        event.json = data;
        event.response = response;
        if (success) {
          removed.forEach((record) => record.meta.committing = false);
          removed.clear();
          me.trigger("commitRemoved");
          me.trigger("refresh", event);
          resolve(commitState);
        } else {
          removed.forEach((r) => r.meta.committing = false);
          commitState.exception = event.exception = true;
          event.exceptionType = "server";
          me.trigger("exception", event);
          resolve(commitState);
        }
        me.trigger("afterRequest", event);
      }).catch((responseOrError) => {
        removed.forEach((r) => r.meta.committing = false);
        commitState.exception = event.exception = true;
        if (responseOrError instanceof Response) {
          commitState.response = responseOrError;
          event.exceptionType = responseOrError.ok ? "server" : "network";
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = "server";
          event.error = responseOrError;
        }
        me.trigger("exception", event);
        resolve(commitState);
        me.trigger("afterRequest", event);
      });
    }) : null;
  }
  get remoteFilter() {
    return Boolean(this.filterParamName || this.restfulFilter);
  }
  get remoteSort() {
    return Boolean(this.sortParamName);
  }
};
__publicField(AjaxStore, "$name", "AjaxStore");
AjaxStore._$name = "AjaxStore";

// ../Core/lib/Core/data/DomDataStore.js
var DomDataStore = class {
  /**
   * Get data that is connected to specified element.
   * @param {HTMLElement} element DOM element
   * @param {String} [key] The name of the property in the element data to return
   * @returns {Object} Data
   */
  static get(element, key) {
    const result = element._domData || (element._domData = {});
    return key != null ? result[key] : result;
  }
  /**
   * Remove data connected to specified element.
   * @param {HTMLElement} element DOM element
   * @param {String} key The name of the property in the element data to remove.
   */
  static remove(element, key) {
    const { _domData } = element, was = _domData == null ? void 0 : _domData[key];
    _domData == null ? true : delete _domData[key];
    return was;
  }
  /**
   * Set data connected to specified element (completely replacing any existing).
   * To update data, use DomDataStore#assign instead.
   * @param {HTMLElement} element DOM element
   * @param {Object|String} data Data object to set, or property name to set
   * @param {*} [value] If the previous parameter was a property name, this is the value to set.
   */
  static set(element, data, value) {
    if (arguments.length === 3) {
      (element._domData || (element._domData = {}))[data] = value;
    } else {
      element._domData = data;
    }
  }
  /**
   * Updates data connected to specified element.
   * @param {HTMLElement} element DOM element
   * @param {Object} data Data to assign
   */
  static assign(element, data) {
    Object.assign(element._domData || (element._domData = {}), data);
  }
};
DomDataStore._$name = "DomDataStore";

// ../SchedulerPro/lib/SchedulerPro/model/changelog/ChangeLogEntity.js
var _ChangeLogEntity = class {
  constructor({ model, type }) {
    var _a2, _b, _c;
    Object.assign(this, {
      /**
       * @member {String} id The unique id of the entity instance, e.g. 'TaskModel-1'.
       * @readonly
       * @category Common
       */
      id: (_a2 = model.id) != null ? _a2 : model.$entityName,
      /**
       * @member {String} type The name of the Model type of the entity, e.g. 'TaskModel'.
       * @readonly
       * @category Common
       */
      type: (_b = type == null ? void 0 : type.$$name) != null ? _b : model.constructor.name,
      /**
       * @member {String} name A user-friendly name for the entity instance, e.g. 'My important task'.
       * @readonly
       * @category Common
       */
      name: (_c = model.name) != null ? _c : model.$entityName
    });
    if (new.target === _ChangeLogEntity) {
      Object.freeze(this);
    }
  }
};
var ChangeLogEntity = _ChangeLogEntity;
__publicField(ChangeLogEntity, "$name", "ChangeLogEntity");
ChangeLogEntity._$name = "ChangeLogEntity";

// ../Grid/lib/Grid/data/GridRowModel.js
var GridRowModel = class extends Model {
  static get fields() {
    return [
      /**
       * Icon for row (used automatically in tree, feel free to use it in renderer in other cases)
       * @field {String} iconCls
       * @category Styling
       */
      {
        name: "iconCls",
        internal: true
      },
      /**
       * CSS class (or several classes divided by space) to append to row elements
       * @field {String} cls
       * @category Styling
       */
      {
        name: "cls",
        internal: true
      },
      /**
       * Used by the default implementation of {@link Grid.view.GridBase#config-getRowHeight} to determine row
       * height. Set it to use another height than the default for a the records row.
       * @field {Number} rowHeight
       * @category Styling
       */
      {
        name: "rowHeight",
        internal: true
      },
      /**
       * A link to use for this record when rendered into a {@link Grid.column.TreeColumn}.
       * @field {String} href
       * @category Tree
       */
      {
        name: "href",
        internal: true
      },
      /**
       * The target to use if this tree node provides a value for the {@link #field-href} field.
       * @field {'_self'|'_blank'|'_parent'|'_top'|null} target
       * @category Tree
       */
      {
        name: "target",
        internal: true
      }
    ];
  }
};
GridRowModel.exposeProperties();
GridRowModel._$name = "GridRowModel";

// ../Scheduler/lib/Scheduler/crud/mixin/AbstractCrudManagerValidation.js
var AbstractCrudManagerValidation_default = (Target) => class AbstractCrudManagerValidation extends Target {
  static get $name() {
    return "AbstractCrudManagerValidation";
  }
  static get configurable() {
    return {
      /**
       * This config validates the response structure for requests made by the Crud Manager.
       * When `true`, the Crud Manager checks every parsed response structure for errors
       * and if the response format is invalid, a warning is logged to the browser console.
       *
       * The config is intended to help developers implementing backend integration.
       *
       * @config {Boolean}
       * @default
       * @category CRUD
       */
      validateResponse: true,
      /**
       * When `true` treats parsed responses without `success` property as successful.
       * In this mode a parsed response is treated as invalid if it has explicitly set `success : false`.
       * @config {Boolean}
       * @default
       * @category CRUD
       */
      skipSuccessProperty: true,
      crudLoadValidationWarningPrefix: "CrudManager load response error(s):",
      crudSyncValidationWarningPrefix: "CrudManager sync response error(s):",
      supportShortSyncResponseNote: 'Note: Please consider enabling "supportShortSyncResponse" option to allow less detailed sync responses (https://bryntum.com/products/scheduler/docs/api/Scheduler/crud/AbstractCrudManagerMixin#config-supportShortSyncResponse)',
      disableValidationNote: 'Note: To disable this validation please set the "validateResponse" config to false'
    };
  }
  get crudLoadValidationMandatoryStores() {
    return [];
  }
  getStoreLoadResponseWarnings(storeInfo, responded, expectedResponse) {
    const messages = [], { storeId } = storeInfo, mandatoryStores = this.crudLoadValidationMandatoryStores, result = { [storeId]: {} };
    if (responded) {
      if (!responded.rows) {
        messages.push(`- "${storeId}" store section should have a "rows" property with an array of the store records.`);
        result[storeId].rows = ["..."];
      }
    } else if (mandatoryStores == null ? void 0 : mandatoryStores.includes(storeId)) {
      messages.push(`- No "${storeId}" store section found. It should contain the store data.`);
      result[storeId].rows = ["..."];
    }
    if (messages.length) {
      Object.assign(expectedResponse, result);
    }
    return messages;
  }
  getLoadResponseWarnings(response) {
    const messages = [], expectedResponse = {};
    if (!this.skipSuccessProperty) {
      expectedResponse.success = true;
    }
    this.forEachCrudStore((store, storeId, storeInfo) => {
      messages.push(...this.getStoreLoadResponseWarnings(storeInfo, response == null ? void 0 : response[storeId], expectedResponse));
    });
    if (messages.length) {
      messages.push("Please adjust your response to look like this:\n" + JSON.stringify(expectedResponse, null, 4).replace(/"\.\.\."/g, "..."));
      messages.push(this.disableValidationNote);
    }
    return messages;
  }
  validateLoadResponse(response) {
    const messages = this.getLoadResponseWarnings(response);
    if (messages.length) {
      console.warn(this.crudLoadValidationWarningPrefix + "\n" + messages.join("\n"));
    }
  }
  getStoreSyncResponseWarnings(storeInfo, requested, responded, expectedResponse) {
    const messages = [], missingRows = [], missingRemoved = [], { storeId } = storeInfo, result = { [storeId]: {} }, phantomIdField = storeInfo.phantomIdField || this.phantomIdField, { modelClass } = storeInfo.store, { idField } = modelClass, respondedRows = (responded == null ? void 0 : responded.rows) || [], respondedRemoved = (responded == null ? void 0 : responded.removed) || [];
    let showSupportShortSyncResponseNote = false;
    if (requested == null ? void 0 : requested.added) {
      missingRows.push(
        ...requested.added.filter((record) => {
          return !respondedRows.find((row) => row[phantomIdField] == record[phantomIdField]) && !respondedRemoved.find((row) => row[phantomIdField] == record[phantomIdField] || row[idField] == record[phantomIdField]);
        }).map((record) => ({ [phantomIdField]: record[phantomIdField], [idField]: "..." }))
      );
      if (missingRows.length) {
        const missingIds = missingRows.map((row) => "#" + row[phantomIdField]).join(", ");
        messages.push(`- "${storeId}" store "rows" section should mention added record(s) ${missingIds} sent in the request. It should contain the added records identifiers (both phantom and "real" ones assigned by the backend).`);
      }
    }
    if (this.supportShortSyncResponse) {
      if (!missingRows.length && responded) {
        if (typeof responded !== "object" || Array.isArray(responded)) {
          messages.push(`- "${storeId}" store section should be an Object.`);
          result[storeId]["..."] = "...";
        }
        if (responded.rows && !Array.isArray(responded.rows)) {
          messages.push(`- "${storeId}" store "rows" section should be an array`);
          missingRows.push("...");
        }
        if (responded.removed && !Array.isArray(responded.removed)) {
          messages.push(`- "${storeId}" store "removed" section should be an array:`);
          missingRemoved.push("...");
        }
      }
    } else {
      if (requested == null ? void 0 : requested.updated) {
        const missingUpdatedRows = requested.updated.filter((record) => !respondedRows.find((row) => row[idField] == record[idField])).map((record) => ({ [idField]: record[idField] }));
        missingRows.push(...missingUpdatedRows);
        if (missingUpdatedRows.length) {
          const missingIds = missingUpdatedRows.map((row) => "#" + row[idField]).join(", ");
          messages.push(`- "${storeId}" store "rows" section should mention updated record(s) ${missingIds} sent in the request. It should contain the updated record identifiers.`);
          showSupportShortSyncResponseNote = true;
        }
      }
      if (missingRows.length) {
        missingRows.push("...");
      }
      if (requested == null ? void 0 : requested.removed) {
        missingRemoved.push(
          ...requested.removed.filter((record) => !respondedRows.find((row) => row[idField] == record[idField])).map((record) => ({ [idField]: record[idField] }))
        );
        if (missingRemoved.length) {
          const missingIds = missingRemoved.map((row) => "#" + row[idField]).join(", ");
          messages.push(`- "${storeId}" store "removed" section should mention removed record(s) ${missingIds} sent in the request. It should contain the removed record identifiers.`);
          result[storeId].removed = missingRemoved;
          missingRemoved.push("...");
          showSupportShortSyncResponseNote = true;
        }
      }
    }
    if (missingRows.length) {
      result[storeId].rows = missingRows;
    }
    if (!messages.length) {
      delete result[storeId];
    }
    Object.assign(expectedResponse, result);
    return { messages, showSupportShortSyncResponseNote };
  }
  getSyncResponseWarnings(response, requestDesc) {
    const messages = [], expectedResponse = {}, request = requestDesc.pack;
    if (!this.skipSuccessProperty) {
      expectedResponse.success = true;
    }
    let showSupportShortSyncResponseNote = false;
    this.forEachCrudStore((store, storeId, storeInfo) => {
      const warnings = this.getStoreSyncResponseWarnings(storeInfo, request == null ? void 0 : request[storeId], response[storeId], expectedResponse);
      showSupportShortSyncResponseNote = showSupportShortSyncResponseNote || warnings.showSupportShortSyncResponseNote;
      messages.push(...warnings.messages);
    });
    if (messages.length) {
      messages.push("Please adjust your response to look like this:\n" + JSON.stringify(expectedResponse, null, 4).replace(/"\.\.\.":\s*"\.\.\."/g, ",,,").replace(/"\.\.\."/g, "..."));
      if (showSupportShortSyncResponseNote) {
        messages.push(this.supportShortSyncResponseNote);
      }
      messages.push(this.disableValidationNote);
    }
    return messages;
  }
  validateSyncResponse(response, request) {
    const messages = this.getSyncResponseWarnings(response, request);
    if (messages.length) {
      console.warn(this.crudSyncValidationWarningPrefix + "\n" + messages.join("\n"));
    }
  }
};

// ../Scheduler/lib/Scheduler/crud/AbstractCrudManagerMixin.js
var AbstractCrudManagerError = class extends Error {
};
var CrudManagerRequestError = class extends AbstractCrudManagerError {
  constructor(cfg = {}) {
    var _a2, _b;
    super(cfg.message || cfg.request && StringHelper.capitalize((_a2 = cfg.request) == null ? void 0 : _a2.type) + " failed" || "Crud Manager request failed");
    Object.assign(this, cfg);
    this.action = (_b = this.request) == null ? void 0 : _b.type;
  }
};
var storeSortFn = function(lhs, rhs, sortProperty) {
  if (lhs.store) {
    lhs = lhs.store;
  }
  if (rhs.store) {
    rhs = rhs.store;
  }
  lhs = lhs[sortProperty] || 0;
  rhs = rhs[sortProperty] || 0;
  return lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
};
var storeLoadSortFn = function(lhs, rhs) {
  return storeSortFn(lhs, rhs, "loadPriority");
};
var storeSyncSortFn = function(lhs, rhs) {
  return storeSortFn(lhs, rhs, "syncPriority");
};
var AbstractCrudManagerMixin_default = (Target) => {
  var _a2;
  Target.$$meta = Target.$meta;
  const mixins = [];
  if (!Target.isEvents) {
    mixins.push(Events_default);
  }
  if (!Target.isDelayable) {
    mixins.push(Delayable_default);
  }
  mixins.push(AbstractCrudManagerValidation_default);
  return _a2 = class extends (Target || Base2).mixin(...mixins) {
    /**
     * Fires before server response gets applied to the stores. Return `false` to prevent data applying.
     * This event can be used for server data preprocessing. To achieve it user can modify the `response` object.
     * @event beforeResponseApply
     * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.
     * @param {'sync'|'load'} requestType The request type (`sync` or `load`).
     * @param {Object} response The decoded server response object.
     */
    /**
     * Fires before loaded data get applied to the stores. Return `false` to prevent data applying.
     * This event can be used for server data preprocessing. To achieve it user can modify the `response` object.
     * @event beforeLoadApply
     * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.
     * @param {Object} response The decoded server response object.
     * @param {Object} options Options provided to the {@link #function-load} method.
     */
    /**
     * Fires before sync response data get applied to the stores. Return `false` to prevent data applying.
     * This event can be used for server data preprocessing. To achieve it user can modify the `response` object.
     * @event beforeSyncApply
     * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.
     * @param {Object} response The decoded server response object.
     */
    static get $name() {
      return "AbstractCrudManagerMixin";
    }
    //region Default config
    static get defaultConfig() {
      return {
        /**
         * The server revision stamp.
         * The _revision stamp_ is a number which should be incremented after each server-side change.
         * This property reflects the current version of the data retrieved from the server and gets updated
         * after each {@link #function-load} and {@link #function-sync} call.
         * @property {Number}
         * @readonly
         * @category CRUD
         */
        crudRevision: null,
        /**
         * A list of registered stores whose server communication will be collected into a single batch.
         * Each store is represented by a _store descriptor_.
         * @member {CrudManagerStoreDescriptor[]} crudStores
         * @category CRUD
         */
        /**
         * Sets the list of stores controlled by the CRUD manager.
         *
         * When adding a store to the CrudManager, make sure the server response format is correct for `load`
         * and `sync` requests. Learn more in the
         * [Working with data](#Scheduler/guides/data/crud_manager.md#loading-data) guide.
         *
         * Store can be provided by itself, its storeId or as a _store descriptor_.
         * @config {Core.data.Store[]|String[]|CrudManagerStoreDescriptor[]}
         * @category CRUD
         */
        crudStores: [],
        /**
         * Name of a store property to retrieve store identifiers from. Make sure you have an instance of a
         * store to use it by id. Store identifier is used as a container name holding corresponding store data
         * while transferring them to/from the server. By default, `storeId` property is used. And in case a
         * container identifier has to differ this config can be used:
         *
         * ```javascript
         * class CatStore extends Store {
         *     static configurable = {
         *         // store id is "meow" but for sending/receiving store data
         *         // we want to have "cats" container in JSON, so we create a new property "storeIdForCrud"
         *         id             : 'meow',
         *         storeIdForCrud : 'cats'
         *     }
         * });
         *
         * // create an instance to use a store by id
         * new CatStore();
         *
         * class MyCrudManager extends CrudManager {
         *     ...
         *     crudStores           : ['meow'],
         *     // crud manager will get store identifier from "storeIdForCrud" property
         *     storeIdProperty  : 'storeIdForCrud'
         * });
         * ```
         * The `storeIdProperty` property can also be specified directly on a store:
         *
         * ```javascript
         * class CatStore extends Store {
         *     static configurable = {
         *         // storeId is "meow" but for sending/receiving store data
         *         // we want to have "cats" container in JSON
         *         id              : 'meow',
         *         // so we create a new property "storeIdForCrud"..
         *         storeIdForCrud  : 'cats',
         *         // and point CrudManager to use it as the store identifier source
         *         storeIdProperty  : 'storeIdForCrud'
         *     }
         * });
         *
         * class DogStore extends Store {
         *     static configurable = {
         *         // storeId is "dogs" and it will be used as a container name for the store data
         *         storeId : 'dogs',
         *         // id is set to get a store by identifier
         *         id      : 'dogs'
         *     }
         * });
         *
         * // create an instance to use a store by id
         * new CatStore();
         * new DogStore();
         *
         * class MyCrudManager extends CrudManager {
         *     ...
         *     crudStores : ['meow', 'dogs']
         * });
         * ```
         * @config {String}
         * @category CRUD
         */
        storeIdProperty: "storeId",
        crudFilterParam: "filter",
        /**
         * Sends request to the server.
         * @function sendRequest
         * @param {Object} request The request to send. An object having following properties:
         * @param {'load'|'sync'} request.type Request type, can be either `load` or `sync`
         * @param {String} request.data {@link #function-encode Encoded} request.
         * @param {Function} request.success Callback to be started on successful request transferring
         * @param {Function} request.failure Callback to be started on request transfer failure
         * @param {Object} request.thisObj `this` reference for the above `success` and `failure` callbacks
         * @returns {Promise} The request promise.
         * @abstract
         */
        /**
         * Cancels request to the server.
         * @function cancelRequest
         * @param {Promise} promise The request promise to cancel (a value returned by corresponding
         * {@link #function-sendRequest} call).
         * @param {Function} reject Reject handle of the corresponding promise
         * @abstract
         */
        /**
         * Encodes request to the server.
         * @function encode
         * @param {Object} request The request to encode.
         * @returns {String} The encoded request.
         * @abstract
         */
        /**
         * Decodes response from the server.
         * @function decode
         * @param {String} response The response to decode.
         * @returns {Object} The decoded response.
         * @abstract
         */
        transport: {},
        /**
         * When `true` forces the CRUD manager to process responses depending on their `type` attribute.
         * So `load` request may be responded with `sync` response for example.
         * Can be used for smart server logic allowing the server to decide when it's better to respond with a
         * complete data set (`load` response) or it's enough to return just a delta (`sync` response).
         * @config {Boolean}
         * @default
         * @category CRUD
         */
        trackResponseType: false,
        /**
         * When `true` the Crud Manager does not require all updated and removed records to be mentioned in the
         * *sync* response. In this case response should include only server side changes.
         *
         * **Please note that added records should still be mentioned in response to provide real identifier
         * instead of the phantom one.**
         * @config {Boolean}
         * @default
         * @category CRUD
         */
        supportShortSyncResponse: true,
        /**
         * Field name to be used to transfer a phantom record identifier.
         * @config {String}
         * @default
         * @category CRUD
         */
        phantomIdField: "$PhantomId",
        /**
         * Field name to be used to transfer a phantom parent record identifier.
         * @config {String}
         * @default
         * @category CRUD
         */
        phantomParentIdField: "$PhantomParentId",
        /**
         * Specify `true` to automatically call {@link #function-load} method on the next frame after creation.
         *
         * Called on the next frame to allow a Scheduler (or similar) linked to a standalone CrudManager to
         * register its stores before loading starts.
         *
         * @config {Boolean}
         * @default
         * @category CRUD
         */
        autoLoad: false,
        /**
         * The timeout in milliseconds to wait before persisting changes to the server.
         * Used when {@link #config-autoSync} is set to `true`.
         * @config {Number}
         * @default
         * @category CRUD
         */
        autoSyncTimeout: 100,
        /**
         * `true` to automatically persist store changes after edits are made in any of the stores monitored.
         * Please note that sync request will not be invoked immediately but only after
         * {@link #config-autoSyncTimeout} interval.
         * @config {Boolean}
         * @default
         * @category CRUD
         */
        autoSync: false,
        /**
         * `True` to reset identifiers (defined by `idField` config) of phantom records before submitting them
         * to the server.
         * @config {Boolean}
         * @default
         * @category CRUD
         */
        resetIdsBeforeSync: true,
        /**
         * @member {CrudManagerStoreDescriptor[]} syncApplySequence
         * An array of stores presenting an alternative sync responses apply order.
         * Each store is represented by a _store descriptor_.
         * @category CRUD
         */
        /**
         * An array of store identifiers sets an alternative sync responses apply order.
         * By default, the order in which sync responses are applied to the stores is the same as they
         * registered in. But in case of some tricky dependencies between stores this order can be changed:
         *
         *```javascript
         * class MyCrudManager extends CrudManager {
         *     // register stores (will be loaded in this order: 'store1' then 'store2' and finally 'store3')
         *     crudStores : ['store1', 'store2', 'store3'],
         *     // but we apply changes from server to them in an opposite order
         *     syncApplySequence : ['store3', 'store2', 'store1']
         * });
         *```
         * @config {String[]}
         * @category CRUD
         */
        syncApplySequence: [],
        orderedCrudStores: [],
        /**
         * `true` to write all fields from the record to the server.
         * If set to `false` it will only send the fields that were modified.
         * Note that any fields that have {@link Core/data/field/DataField#config-persist} set to `false` will
         * still be ignored and fields having {@link Core/data/field/DataField#config-alwaysWrite} set to `true`
         * will always be included.
         * @config {Boolean}
         * @default
         * @category CRUD
         */
        writeAllFields: false,
        crudIgnoreUpdates: 0,
        autoSyncSuspendCounter: 0,
        // Flag that shows if crud manager performed successful load request
        crudLoaded: false,
        applyingLoadResponse: false,
        applyingSyncResponse: false,
        callOnFunctions: true
      };
    }
    get isCrudManager() {
      return true;
    }
    //endregion
    //region Init
    construct(config = {}) {
      this._requestId = 0;
      this.activeRequests = {};
      this.crudStoresIndex = {};
      super.construct(config);
    }
    afterConstruct() {
      super.afterConstruct();
      if (this.autoLoad) {
        this._autoLoadPromise = this.doAutoLoad();
      }
    }
    //endregion
    //region Configs
    get loadUrl() {
      var _a3, _b;
      return (_b = (_a3 = this.transport) == null ? void 0 : _a3.load) == null ? void 0 : _b.url;
    }
    updateLoadUrl(url) {
      ObjectHelper.setPath(this, "transport.load.url", url);
    }
    get syncUrl() {
      var _a3, _b;
      return (_b = (_a3 = this.transport) == null ? void 0 : _a3.sync) == null ? void 0 : _b.url;
    }
    updateSyncUrl(url) {
      ObjectHelper.setPath(this, "transport.sync.url", url);
    }
    //endregion
    //region Store descriptors & index
    /**
     * Returns a registered store descriptor.
     * @param {String|Core.data.Store} storeId The store identifier or registered store instance.
     * @returns {CrudManagerStoreDescriptor} The descriptor of the store.
     * @category CRUD
     */
    getStoreDescriptor(storeId) {
      if (!storeId)
        return null;
      if (storeId instanceof Store)
        return this.crudStores.find((storeDesc) => storeDesc.store === storeId);
      if (typeof storeId === "object")
        return this.crudStoresIndex[storeId.storeId];
      return this.crudStoresIndex[storeId] || this.getStoreDescriptor(Store.getStore(storeId));
    }
    fillStoreDescriptor(descriptor) {
      const { store } = descriptor, {
        storeIdProperty = this.storeIdProperty,
        modelClass
      } = store;
      if (!descriptor.storeId) {
        descriptor.storeId = store[storeIdProperty] || store.id;
      }
      if (!descriptor.idField) {
        descriptor.idField = modelClass.idField;
      }
      if (!descriptor.phantomIdField) {
        descriptor.phantomIdField = modelClass.phantomIdField;
      }
      if (!descriptor.phantomParentIdField) {
        descriptor.phantomParentIdField = modelClass.phantomParentIdField;
      }
      if (!("writeAllFields" in descriptor)) {
        descriptor.writeAllFields = store.writeAllFields;
      }
      return descriptor;
    }
    updateCrudStoreIndex() {
      const crudStoresIndex = this.crudStoresIndex = {};
      this.crudStores.forEach((store) => store.storeId && (crudStoresIndex[store.storeId] = store));
    }
    //endregion
    //region Store collection (add, remove, get & iterate)
    /**
     * Returns a registered store.
     * @param {String} storeId Store identifier.
     * @returns {Core.data.Store} Found store instance.
     * @category CRUD
     */
    getCrudStore(storeId) {
      const storeDescriptor = this.getStoreDescriptor(storeId);
      return storeDescriptor == null ? void 0 : storeDescriptor.store;
    }
    forEachCrudStore(fn2, thisObj = this) {
      if (!fn2) {
        throw new Error("Iterator function must be provided");
      }
      this.crudStores.every(
        (store) => fn2.call(thisObj, store.store, store.storeId, store) !== false
      );
    }
    set crudStores(stores) {
      this._crudStores = [];
      this.addCrudStore(stores);
      for (const store of this._crudStores) {
        store.loadPriority = store.syncPriority = 0;
      }
    }
    get crudStores() {
      return this._crudStores;
    }
    get orderedCrudStores() {
      return this._orderedCrudStores;
    }
    set orderedCrudStores(stores) {
      return this._orderedCrudStores = stores;
    }
    set syncApplySequence(stores) {
      this._syncApplySequence = [];
      this.addStoreToApplySequence(stores);
    }
    get syncApplySequence() {
      return this._syncApplySequence;
    }
    internalAddCrudStore(store) {
      const me = this;
      let storeInfo;
      if (store instanceof Store) {
        storeInfo = { store };
      } else if (typeof store === "object") {
        if (!store.store) {
          store = {
            storeId: store.id,
            store: new Store(store)
          };
        }
        storeInfo = store;
      } else {
        storeInfo = { store: Store.getStore(store) };
      }
      me.fillStoreDescriptor(storeInfo);
      store = storeInfo.store;
      if (store.setCrudManager) {
        store.setCrudManager(me);
      } else {
        store.crudManager = me;
      }
      store.pageSize = null;
      if (me.loadUrl || me.syncUrl) {
        store.autoCommit = false;
        store.autoLoad = false;
        if (store.createUrl || store.updateUrl || store.deleteUrl || store.readUrl) {
          console.warn("You have configured an URL on a Store that is handled by a CrudManager that is also configured with an URL. The Store URL's should be removed.");
        }
      }
      me.bindCrudStoreListeners(store);
      return storeInfo;
    }
    /**
     * Adds a store to the collection.
     *
     *```javascript
     * // append stores to the end of collection
     * crudManager.addCrudStore([
     *     store1,
     *     // storeId
     *     'bar',
     *     // store descriptor
     *     {
     *         storeId : 'foo',
     *         store   : store3
     *     },
     *     {
     *         storeId         : 'bar',
     *         store           : store4,
     *         // to write all fields of modified records
     *         writeAllFields  : true
     *     }
     * ]);
     *```
     *
     * **Note:** Order in which stores are kept in the collection is very essential sometimes.
     * Exactly in this order the loaded data will be put into each store.
     *
     * When adding a store to the CrudManager, make sure the server response format is correct for `load` and `sync`
     * requests. Learn more in the [Working with data](#Scheduler/guides/data/crud_manager.md#loading-data) guide.
     *
     * @param {Core.data.Store|String|CrudManagerStoreDescriptor|Core.data.Store[]|String[]|CrudManagerStoreDescriptor[]} store
     * A store or list of stores. Each store might be specified by its instance, `storeId` or _descriptor_.
     * @param {Number} [position] The relative position of the store. If `fromStore` is specified the position
     * will be taken relative to it. If not specified then store(s) will be appended to the end of collection.
     * Otherwise, it will be just a position in stores collection.
     *
     * ```javascript
     * // insert stores store4, store5 to the start of collection
     * crudManager.addCrudStore([ store4, store5 ], 0);
     * ```
     *
     * @param {String|Core.data.Store|CrudManagerStoreDescriptor} [fromStore] The store relative to which position
     * should be calculated. Can be defined as a store identifier, instance or descriptor (the result of
     * {@link #function-getStoreDescriptor} call).
     *
     * ```javascript
     * // insert store6 just before a store having storeId equal to 'foo'
     * crudManager.addCrudStore(store6, 0, 'foo');
     *
     * // insert store7 just after store3 store
     * crudManager.addCrudStore(store7, 1, store3);
     * ```
     * @category CRUD
     */
    addCrudStore(store, position, fromStore) {
      store = ArrayHelper.asArray(store);
      if (!(store == null ? void 0 : store.length)) {
        return;
      }
      const me = this, stores = store.map(me.internalAddCrudStore, me);
      if (typeof position === "undefined") {
        me.crudStores.push(...stores);
      } else {
        if (fromStore) {
          if (fromStore instanceof Store || typeof fromStore !== "object")
            fromStore = me.getStoreDescriptor(fromStore);
          position += me.crudStores.indexOf(fromStore);
        }
        me.crudStores.splice(position, 0, ...stores);
      }
      me.orderedCrudStores.push(...stores);
      me.updateCrudStoreIndex();
    }
    // Adds configured scheduler stores to the store collection ensuring correct order
    // unless they're already registered.
    addPrioritizedStore(store) {
      const me = this;
      if (!me.hasCrudStore(store)) {
        me.addCrudStore(store, ArrayHelper.findInsertionIndex(store, me.crudStores, storeLoadSortFn));
      }
      if (!me.hasApplySequenceStore(store)) {
        me.addStoreToApplySequence(store, ArrayHelper.findInsertionIndex(store, me.syncApplySequence, storeSyncSortFn));
      }
    }
    hasCrudStore(store) {
      var _a3;
      return (_a3 = this.crudStores) == null ? void 0 : _a3.some((s) => s === store || s.store === store || s.storeId === store);
    }
    /**
     * Removes a store from collection. If the store was registered in alternative sync sequence list
     * it will be removed from there as well.
     *
     * ```javascript
     * // remove store having storeId equal to "foo"
     * crudManager.removeCrudStore("foo");
     *
     * // remove store3
     * crudManager.removeCrudStore(store3);
     * ```
     *
     * @param {CrudManagerStoreDescriptor|String|Core.data.Store} store The store to remove. Either the store
     * descriptor, store identifier or store itself.
     * @category CRUD
     */
    removeCrudStore(store) {
      const me = this, stores = me.crudStores, foundStore = stores.find((s) => s === store || s.store === store || s.storeId === store);
      if (foundStore) {
        me.unbindCrudStoreListeners(foundStore.store);
        delete me.crudStoresIndex[foundStore.storeId];
        ArrayHelper.remove(stores, foundStore);
        if (me.syncApplySequence) {
          me.removeStoreFromApplySequence(store);
        }
      } else {
        throw new Error("Store not found in stores collection");
      }
    }
    //endregion
    //region Store listeners
    bindCrudStoreListeners(store) {
      store.ion({
        name: store.id,
        // When a tentatively added record gets confirmed as permanent, this signals a change
        addConfirmed: "onCrudStoreChange",
        change: "onCrudStoreChange",
        destroy: "onCrudStoreDestroy",
        thisObj: this
      });
    }
    unbindCrudStoreListeners(store) {
      this.detachListeners(store.id);
    }
    //endregion
    //region Apply sequence
    /**
     * Adds a store to the alternative sync responses apply sequence.
     * By default, the order in which sync responses are applied to the stores is the same as they registered in.
     * But this order can be changes either on construction step using {@link #config-syncApplySequence} option
     * or by calling this method.
     *
     * **Please note**, that if the sequence was not initialized before this method call then
     * you will have to do it yourself like this for example:
     *
     * ```javascript
     * // alternative sequence was not set for this crud manager
     * // so let's fill it with existing stores keeping the same order
     * crudManager.addStoreToApplySequence(crudManager.crudStores);
     *
     * // and now we can add our new store
     *
     * // we will load its data last
     * crudManager.addCrudStore(someNewStore);
     * // but changes to it will be applied first
     * crudManager.addStoreToApplySequence(someNewStore, 0);
     * ```
     * add registered stores to the sequence along with the store(s) you want to add
     *
     * @param {Core.data.Store|CrudManagerStoreDescriptor|Core.data.Store[]|CrudManagerStoreDescriptor[]} store The
     * store to add or its _descriptor_ (or array of stores or descriptors).
     * @param {Number} [position] The relative position of the store. If `fromStore` is specified the position
     * will be taken relative to it. If not specified then store(s) will be appended to the end of collection.
     * Otherwise, it will be just a position in stores collection.
     *
     * ```javascript
     * // insert stores store4, store5 to the start of sequence
     * crudManager.addStoreToApplySequence([ store4, store5 ], 0);
     * ```
     * @param {String|Core.data.Store|CrudManagerStoreDescriptor} [fromStore] The store relative to which position
     * should be calculated. Can be defined as a store identifier, instance or its descriptor (the result of
     * {@link #function-getStoreDescriptor} call).
     *
     * ```javascript
     * // insert store6 just before a store having storeId equal to 'foo'
     * crudManager.addStoreToApplySequence(store6, 0, 'foo');
     *
     * // insert store7 just after store3 store
     * crudManager.addStoreToApplySequence(store7, 1, store3);
     * ```
     * @category CRUD
     */
    addStoreToApplySequence(store, position, fromStore) {
      if (!store) {
        return;
      }
      store = ArrayHelper.asArray(store);
      const me = this, data = store.reduce((collection, store2) => {
        const s = me.getStoreDescriptor(store2);
        s && collection.push(s);
        return collection;
      }, []);
      if (typeof position === "undefined") {
        me.syncApplySequence.push(...data);
      } else {
        let pos = position;
        if (fromStore) {
          if (fromStore instanceof Store || typeof fromStore !== "object")
            fromStore = me.getStoreDescriptor(fromStore);
          pos += me.syncApplySequence.indexOf(fromStore);
        }
        me.syncApplySequence.splice(pos, 0, ...data);
      }
      const sequenceKeys = me.syncApplySequence.map(({ storeId }) => storeId);
      me.orderedCrudStores = [...me.syncApplySequence];
      me.crudStores.forEach((storeDesc) => {
        if (!sequenceKeys.includes(storeDesc.storeId)) {
          me.orderedCrudStores.push(storeDesc);
        }
      });
    }
    /**
     * Removes a store from the alternative sync sequence.
     *
     * ```javascript
     * // remove store having storeId equal to "foo"
     * crudManager.removeStoreFromApplySequence("foo");
     * ```
     *
     * @param {CrudManagerStoreDescriptor|String|Core.data.Store} store The store to remove. Either the store
     * descriptor, store identifier or store itself.
     * @category CRUD
     */
    removeStoreFromApplySequence(store) {
      const index = this.syncApplySequence.findIndex((s) => s === store || s.store === store || s.storeId === store);
      if (index > -1) {
        this.syncApplySequence.splice(index, 1);
        this.orderedCrudStores.splice(index, 1);
      }
    }
    hasApplySequenceStore(store) {
      return this.syncApplySequence.some((s) => s === store || s.store === store || s.storeId === store);
    }
    //endregion
    //region Events
    // Remove stores that are destroyed, to not try and apply response changes etc. to them
    onCrudStoreDestroy({ source: store }) {
      this.removeCrudStore(store);
    }
    onCrudStoreChange(event) {
      const me = this;
      if (me.crudIgnoreUpdates) {
        return;
      }
      if (me.crudStoreHasChanges(event == null ? void 0 : event.source)) {
        me.trigger("hasChanges");
        if (me.autoSync) {
          me.scheduleAutoSync();
        }
      } else {
        me.trigger("noChanges");
      }
    }
    /**
     * Suspends automatic sync upon store changes. Can be called multiple times (it uses an internal counter).
     * @category CRUD
     */
    suspendAutoSync() {
      this.autoSyncSuspendCounter++;
    }
    /**
     * Resumes automatic sync upon store changes. Will schedule a sync if the internal counter is 0.
     * @param {Boolean} [doSync=true] Pass `true` to schedule a sync after resuming (if there are pending
     * changes) and `false` to not persist the changes.
     * @category CRUD
     */
    resumeAutoSync(doSync = true) {
      const me = this;
      me.autoSyncSuspendCounter--;
      if (me.autoSyncSuspendCounter <= 0) {
        me.autoSyncSuspendCounter = 0;
        if (doSync && me.autoSync && me.crudStoreHasChanges()) {
          me.scheduleAutoSync();
        }
      }
    }
    get isAutoSyncSuspended() {
      return this.autoSyncSuspendCounter > 0;
    }
    scheduleAutoSync() {
      const me = this;
      if (!me.hasTimeout("autoSync") && !me.isAutoSyncSuspended) {
        me.setTimeout({
          name: "autoSync",
          fn: () => {
            me.sync().catch((error) => {
            });
          },
          delay: me.autoSyncTimeout
        });
      }
    }
    async triggerFailedRequestEvents(request, response, responseText, fetchOptions) {
      const { options, type: requestType } = request;
      this.trigger("requestFail", { requestType, response, responseText, responseOptions: fetchOptions });
      this.trigger(requestType + "Fail", { response, responseOptions: fetchOptions, responseText, options });
    }
    async internalOnResponse(request, responseText, fetchOptions) {
      const me = this, response = responseText ? me.decode(responseText) : null, { options, type: requestType } = request;
      if (responseText && !response) {
        console.error("Failed to parse response: " + responseText);
      }
      if (!response || (me.skipSuccessProperty ? response.success === false : !response.success)) {
        me.triggerFailedRequestEvents(request, response, responseText, fetchOptions);
      } else if (me.trigger("beforeResponseApply", { requestType, response }) !== false && me.trigger(`before${StringHelper.capitalize(requestType)}Apply`, { response, options }) !== false) {
        me.crudRevision = response.revision;
        await me.applyResponse(request, response, options);
        if (me.isDestroyed) {
          return;
        }
        me.trigger("requestDone", { requestType, response, responseOptions: fetchOptions });
        me.trigger(requestType, { response, responseOptions: fetchOptions, options });
        if (requestType === "load" || !me.crudStoreHasChanges()) {
          me.trigger("noChanges");
          if (requestType === "load") {
            me.emitCrudStoreEvents(request.pack.stores, "afterRequest");
          }
        }
      }
      return response;
    }
    //endregion
    //region Changes tracking
    suspendChangesTracking() {
      this.crudIgnoreUpdates++;
    }
    resumeChangesTracking(skipChangeCheck) {
      if (this.crudIgnoreUpdates && !--this.crudIgnoreUpdates && !skipChangeCheck) {
        this.onCrudStoreChange();
      }
    }
    get isBatchingChanges() {
      return this.crudIgnoreUpdates > 0;
    }
    /**
     * Returns `true` if any of registered stores (or some particular store) has non persisted changes.
     *
     * ```javascript
     * // if we have any unsaved changes
     * if (crudManager.crudStoreHasChanges()) {
     *     // persist them
     *     crudManager.sync();
     * // otherwise
     * } else {
     *     alert("There are no unsaved changes...");
     * }
     * ```
     *
     * @param {String|Core.data.Store} [storeId] The store identifier or store instance to check changes for.
     * If not specified then will check changes for all of the registered stores.
     * @returns {Boolean} `true` if there are not persisted changes.
     * @category CRUD
     */
    crudStoreHasChanges(storeId) {
      return storeId ? this.isCrudStoreDirty(this.getCrudStore(storeId)) : this.crudStores.some((config) => this.isCrudStoreDirty(config.store));
    }
    isCrudStoreDirty(store) {
      return Boolean(store.changes);
    }
    //endregion
    //region Load
    doAutoLoad() {
      return this.load().catch((error) => {
      });
    }
    emitCrudStoreEvents(stores, eventName, eventParams) {
      const event = { action: "read" + eventName, ...eventParams };
      for (const store of this.crudStores) {
        if (stores.includes(store.storeId)) {
          store.store.trigger(eventName, event);
        }
      }
    }
    getLoadPackage(options) {
      const pack = {
        type: "load",
        requestId: this.requestId
      }, stores = this.crudStores, optionsCopy = Object.assign({}, options);
      delete optionsCopy.request;
      pack.stores = stores.map((store) => {
        var _a3;
        const opts = optionsCopy == null ? void 0 : optionsCopy[store.storeId], pageSize = store.pageSize || ((_a3 = store.store) == null ? void 0 : _a3.pageSize);
        if (opts || pageSize) {
          const params = Object.assign({
            storeId: store.storeId,
            page: 1
          }, opts);
          if (pageSize) {
            params.pageSize = pageSize;
          }
          store.currentPage = params.page;
          if (opts) {
            delete optionsCopy[store.storeId];
          }
          return params;
        }
        return store.storeId;
      });
      Object.assign(pack, optionsCopy);
      return pack;
    }
    loadCrudStore(store, data, options) {
      const rows = data == null ? void 0 : data.rows;
      if ((options == null ? void 0 : options.append) || (data == null ? void 0 : data.append)) {
        store.add(rows);
      } else {
        store.data = rows;
      }
      store.trigger("load", { data: rows });
    }
    loadDataToCrudStore(storeDesc, data, options) {
      const store = storeDesc.store, rows = data == null ? void 0 : data.rows;
      store.__loading = true;
      if (rows) {
        this.loadCrudStore(store, data, options, storeDesc);
      }
      store.__loading = false;
    }
    /**
     * Loads data to the Crud Manager
     * @param {Object} response A simple object representing the data.
     * The object structure matches the decoded `load` response structure:
     *
     * ```js
     * // load static data into crudManager
     * crudManager.loadCrudManagerData({
     *     success   : true,
     *     resources : {
     *         rows : [
     *             { id : 1, name : 'John' },
     *             { id : 2, name : 'Abby' }
     *         ]
     *     }
     * });
     * ```
     * @param {Object} [options] Extra data loading options.
     * @category CRUD
     */
    loadCrudManagerData(response, options = {}) {
      this.suspendChangesTracking();
      this.crudStores.forEach((storeDesc) => {
        const storeId = storeDesc.storeId, data = response[storeId];
        if (data) {
          this.loadDataToCrudStore(storeDesc, data, options[storeId]);
        }
      });
      this.resumeChangesTracking(true);
    }
    /**
     * Returns true if the crud manager is currently loading data
     * @property {Boolean}
     * @readonly
     * @category CRUD
     */
    get isCrudManagerLoading() {
      return Boolean(this.activeRequests.load || this.applyingLoadResponse);
    }
    /**
     * Returns true if the crud manager is currently syncing data
     * @property {Boolean}
     * @readonly
     * @category CRUD
     */
    get isCrudManagerSyncing() {
      return Boolean(this.activeRequests.sync || this.applyingSyncResponse);
    }
    get isLoadingOrSyncing() {
      return Boolean(this.isCrudManagerLoading || this.isCrudManagerSyncing);
    }
    /**
     * Loads data to the stores registered in the crud manager. For example:
     *
     * ```javascript
     * crudManager.load(
     *     // here are request parameters
     *     {
     *         store1 : { append : true, page : 3, smth : 'foo' },
     *         store2 : { page : 2, bar : '!!!' }
     *     }
     * ).then(
     *     () => alert('OMG! It works!'),
     *     ({ response, cancelled }) => console.log(`Error: ${cancelled ? 'Cancelled' : response.message}`)
     * );
     * ```
     *
     * ** Note: ** If there is an incomplete load request in progress then system will try to cancel it by calling {@link #function-cancelRequest}.
     * @param {Object|String} [options] The request parameters or a URL.
     * @param {Object} [options.request] An object which contains options to merge
     * into the options which are passed to {@link Scheduler/crud/transport/AjaxTransport#function-sendRequest}.
     * ```javascript
     * {
     *     store1 : { page : 3, append : true, smth : 'foo' },
     *     store2 : { page : 2, bar : '!!!' },
     *     request : {
     *         params : {
     *             startDate : '2021-01-01'
     *         }
     *     }
     * },
     * ```
     *
     * Omitting request arg:
     * ```javascript
     * crudManager.load().then(
     *     () => alert('OMG! It works!'),
     *     ({ response, cancelled }) => console.log(`Error: ${cancelled ? 'Cancelled' : response.message}`)
     * );
     * ```
     *
     * When presented it should be an object where keys are store Ids and values are, in turn, objects
     * of parameters related to the corresponding store. These parameters will be transferred in each
     * store's entry in the `stores` property of the POST data.
     *
     * Additionally, for flat stores `append: true` can be specified to add loaded records to the existing records,
     * default is to remove corresponding store's existing records first.
     * **Please note** that for delta loading you can also use an {@link #config-trackResponseType alternative approach}.
     * @param {'sync'|'load'} [options.request.type] The request type. Either `load` or `sync`.
     * @param {String} [options.request.url] The URL for the request. Overrides the URL defined in the `transport`
     * object
     * @param {String} [options.request.data] The encoded _Crud Manager_ request data.
     * @param {Object} [options.request.params] An object specifying extra HTTP params to send with the request.
     * @param {Function} [options.request.success] A function to be started on successful request transferring.
     * @param {String} [options.request.success.rawResponse] `Response` object returned by the
     * [fetch api](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
     * @param {Function} [options.request.failure] A function to be started on request transfer failure.
     * @param {String} [options.request.failure.rawResponse] `Response` object returned by the
     * [fetch api](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
     * @param {Object} [options.request.thisObj] `this` reference for the above `success` and `failure` functions.
     * @returns {Promise} Promise, which is resolved if request was successful.
     * Both the resolve and reject functions are passed a `state` object. State object has following structure:
     *
     * ```
     * {
     *     cancelled       : Boolean, // **optional** flag, which is present when promise was rejected
     *     rawResponse     : String,  // raw response from ajax request, either response xml or text
     *     rawResponseText : String,  // raw response text as String from ajax request
     *     response        : Object,  // processed response in form of object
     *     options         : Object   // options, passed to load request
     * }
     * ```
     *
     * If promise was rejected by {@link #event-beforeLoad} event, `state` object will have the following structure:
     *
     * ```
     * {
     *     cancelled : true
     * }
     * ```
     * @category CRUD
     * @async
     */
    load(options) {
      if (typeof options === "string") {
        options = {
          request: {
            url: options
          }
        };
      }
      const me = this, pack = me.getLoadPackage(options);
      me._autoLoadPromise = null;
      return new Promise((resolve, reject) => {
        if (me.trigger("beforeLoad", { pack }) !== false) {
          const { load } = me.activeRequests;
          if (load) {
            me.cancelRequest(load.desc, load.reject);
            me.trigger("loadCanceled", { pack });
          }
          const request = Objects.assign({
            id: pack.requestId,
            data: me.encode(pack),
            type: "load",
            success: me.onCrudRequestSuccess,
            failure: me.onCrudRequestFailure,
            thisObj: me
          }, options == null ? void 0 : options.request);
          me.activeRequests.load = {
            type: "load",
            options,
            pack,
            resolve,
            reject(...args) {
              request.success = request.failure = null;
              reject(...args);
            },
            id: pack.requestId,
            desc: me.sendRequest(request)
          };
          me.emitCrudStoreEvents(pack.stores, "loadStart");
          me.trigger("loadStart", { pack });
        } else {
          me.trigger("loadCanceled", { pack });
          reject({ cancelled: true });
        }
      });
    }
    getActiveCrudManagerRequest(requestType) {
      let request = this.activeRequests[requestType];
      if (!request && this.trackResponseType) {
        request = Object.values(this.activeRequests)[0];
      }
      return request;
    }
    //endregion
    //region Changes (prepare, process, get)
    prepareAddedRecordData(record, storeInfo) {
      const me = this, { store } = storeInfo, { isTree } = store, phantomIdField = storeInfo.phantomIdField || me.phantomIdField, phantomParentIdField = storeInfo.phantomParentIdField || me.phantomParentIdField, subStoreFields = store.modelClass.allFields.filter((field2) => field2.subStore), cls = record.constructor, data = Object.assign(record.persistableData, {
        [phantomIdField]: record.id
      });
      if (isTree) {
        const { parent } = record;
        if (parent && !parent.isRoot && parent.isPhantom) {
          data[phantomParentIdField] = parent.id;
        }
      }
      if (me.resetIdsBeforeSync) {
        ObjectHelper.deletePath(data, cls.idField);
      }
      subStoreFields.forEach((field2) => {
        const subStore = record.get(field2.name);
        if (subStore.allCount) {
          data[field2.dataSource] = {
            added: subStore.getRange().map((record2) => me.prepareAddedRecordData(record2, { store: subStore }))
          };
        }
      });
      return data;
    }
    prepareAdded(list, storeInfo) {
      return list.filter((record) => record.isValid).map((record) => this.prepareAddedRecordData(record, storeInfo));
    }
    prepareUpdated(list, storeInfo) {
      const { store } = storeInfo, { isTree } = store, writeAllFields = storeInfo.writeAllFields || storeInfo.writeAllFields !== false && this.writeAllFields, phantomParentIdField = storeInfo.phantomParentIdField || this.phantomParentIdField, subStoreFields = store.modelClass.allFields.filter((field2) => field2.subStore);
      if (storeInfo.store.tree) {
        const rootNode = storeInfo.store.rootNode;
        list = list.filter((record) => record !== rootNode);
      }
      return list.filter((record) => record.isValid).reduce((data, record) => {
        let recordData;
        if (writeAllFields) {
          recordData = record.persistableData;
        } else {
          recordData = record.modificationDataToWrite;
        }
        if (isTree) {
          const { parent } = record;
          if (parent && !parent.isRoot && parent.isPhantom) {
            recordData[phantomParentIdField] = parent.id;
          }
        }
        subStoreFields.forEach((field2) => {
          const subStore = record.get(field2.name);
          recordData[field2.dataSource] = this.getCrudStoreChanges({ store: subStore });
        });
        if (!ObjectHelper.isEmpty(recordData)) {
          data.push(recordData);
        }
        return data;
      }, []);
    }
    prepareRemoved(list) {
      return list.map((record) => {
        const cls = record.constructor;
        return ObjectHelper.setPath({}, cls.idField, record.id);
      });
    }
    getCrudStoreChanges(storeDescriptor) {
      const { store } = storeDescriptor;
      let { added = [], modified: updated = [], removed = [] } = store.changes || {}, result;
      if (added.length)
        added = this.prepareAdded(added, storeDescriptor);
      if (updated.length)
        updated = this.prepareUpdated(updated, storeDescriptor);
      if (removed.length)
        removed = this.prepareRemoved(removed);
      if (added.length || updated.length || removed.length) {
        result = {};
        if (added.length)
          result.added = added;
        if (updated.length)
          result.updated = updated;
        if (removed.length)
          result.removed = removed;
      }
      return result;
    }
    getChangesetPackage() {
      const { changes } = this;
      return changes || this.forceSync ? {
        type: "sync",
        requestId: this.requestId,
        revision: this.crudRevision,
        ...changes
      } : null;
    }
    //endregion
    //region Apply
    /**
     * Returns current changes as an object consisting of added/modified/removed arrays of records for every
     * managed store, keyed by each store's `id`. Returns `null` if no changes exist. Format:
     *
     * ```javascript
     * {
     *     resources : {
     *         added    : [{ name : 'New guy' }],
     *         modified : [{ id : 2, name : 'Mike' }],
     *         removed  : [{ id : 3 }]
     *     },
     *     events : {
     *         modified : [{  id : 12, name : 'Cool task' }]
     *     },
     *     ...
     * }
     * ```
     *
     * @property {Object}
     * @readonly
     * @category CRUD
     */
    get changes() {
      const data = {};
      this.crudStores.forEach((store) => {
        const changes = this.getCrudStoreChanges(store);
        if (changes) {
          data[store.storeId] = changes;
        }
      });
      return Object.keys(data).length > 0 ? data : null;
    }
    getRowsToApplyChangesTo({ store, storeId }, storeResponse, storePack) {
      var _a3, _b;
      const me = this, { modelClass } = store, idDataSource = modelClass.idField, {
        updated: requestUpdated,
        removed: requestRemoved
      } = storePack || {};
      let rows, removed, remote;
      if (storeResponse) {
        remote = true;
        const respondedIds = {};
        rows = ((_a3 = storeResponse.rows) == null ? void 0 : _a3.slice()) || [];
        removed = ((_b = storeResponse.removed) == null ? void 0 : _b.slice()) || [];
        [...rows, ...removed].forEach((responseRecord) => {
          const id = ObjectHelper.getPath(responseRecord, idDataSource);
          respondedIds[id] = true;
        });
        if (me.supportShortSyncResponse) {
          requestUpdated == null ? void 0 : requestUpdated.forEach((data) => {
            const id = ObjectHelper.getPath(data, idDataSource);
            if (!respondedIds[id]) {
              rows.push({ [idDataSource]: id });
            }
          });
          requestRemoved == null ? void 0 : requestRemoved.forEach((data) => {
            const id = ObjectHelper.getPath(data, idDataSource);
            if (!respondedIds[id]) {
              removed.push({ [idDataSource]: id });
            }
          });
        }
      } else if (requestUpdated || requestRemoved) {
        remote = false;
        rows = requestUpdated;
        removed = requestRemoved;
      }
      rows = (rows == null ? void 0 : rows.length) ? rows : null;
      removed = (removed == null ? void 0 : removed.length) ? removed : null;
      return {
        rows,
        removed,
        remote
      };
    }
    applyChangesToStore(storeDesc, storeResponse, storePack) {
      var _a3;
      const me = this, phantomIdField = storeDesc.phantomIdField || me.phantomIdField, { store } = storeDesc, idField = store.modelClass.getFieldDataSource("id"), subStoreFields = store.modelClass.allFields.filter((field2) => field2.subStore), { rows, removed, remote } = me.getRowsToApplyChangesTo(storeDesc, storeResponse, storePack), added = [], updated = [];
      if (rows) {
        for (const data of rows) {
          if (store.getById((_a3 = data[phantomIdField]) != null ? _a3 : data[idField])) {
            updated.push(data);
          } else {
            added.push(data);
          }
        }
      }
      const extraLogEntries = [];
      if (updated.length && subStoreFields.length) {
        updated.forEach((updateData) => {
          var _a4, _b, _c;
          const record = store.getById((_a4 = updateData[phantomIdField]) != null ? _a4 : updateData[idField]), recordRequest = ((_b = storePack.added) == null ? void 0 : _b.find((t) => t[phantomIdField] == updateData[phantomIdField])) || ((_c = storePack.updated) == null ? void 0 : _c.find((t) => t[idField] == updateData[idField]));
          const extraLogInfo = {};
          subStoreFields.forEach((field2) => {
            const store2 = record.get(field2.name);
            me.applyChangesToStore(
              { store: store2 },
              updateData[field2.dataSource],
              recordRequest == null ? void 0 : recordRequest[field2.dataSource]
            );
            extraLogInfo[field2.dataSource] = "foo";
            delete updateData[field2.dataSource];
          });
          extraLogEntries.push([record, extraLogInfo]);
        });
      }
      const log = store.applyChangeset({ removed, added, updated }, null, phantomIdField, remote, true);
      extraLogEntries.forEach(([record, logEntry]) => Object.assign(log.get(record.id), logEntry));
      return log;
    }
    applySyncResponse(response, request) {
      var _a3;
      const me = this, stores = me.orderedCrudStores;
      me.applyingChangeset = me.applyingSyncResponse = true;
      me.suspendChangesTracking();
      for (const store of stores) {
        me.applyChangesToStore(store, response[store.storeId], (_a3 = request == null ? void 0 : request.pack) == null ? void 0 : _a3[store.storeId]);
      }
      me.resumeChangesTracking(true);
      me.applyingChangeset = me.applyingSyncResponse = false;
    }
    applyLoadResponse(response, options) {
      this.applyingLoadResponse = true;
      this.loadCrudManagerData(response, options);
      this.applyingLoadResponse = false;
    }
    async applyResponse(request, response, options) {
      const me = this, responseType = me.trackResponseType && response.type || request.type;
      switch (responseType) {
        case "load":
          if (me.validateResponse) {
            me.validateLoadResponse(response);
          }
          me.applyLoadResponse(response, options);
          break;
        case "sync":
          if (me.validateResponse) {
            me.validateSyncResponse(response, request);
          }
          me.applySyncResponse(response, request);
          break;
      }
    }
    /**
     * Applies a set of changes, as an object keyed by store id, to the affected stores. This function is intended
     * to use in apps that handle their own data syncing, it is not needed when using the CrudManager approach.
     *
     * Example of a changeset:
     * ```javascript
     * project.applyChangeset({
     *     events : {
     *         added : [
     *             { id : 10, name : 'Event 10', startDate : '2022-06-07' }
     *         ],
     *         updated : [
     *             { id : 5, name : 'Changed' }
     *         ],
     *         removed : [
     *             { id : 1 }
     *         ]
     *     },
     *     resources : { ... },
     *     ...
     * });
     * ```
     *
     * Optionally accepts a `transformFn` to convert an incoming changeset to the expected format.
     * See {@link Core/data/Store#function-applyChangeset} for more details.
     *
     * @param {Object} changes Changeset to apply, an object keyed by store id where each value follows the
     * format described in {@link Core/data/Store#function-applyChangeset}
     * @param {Function} [transformFn] Optional function used to preprocess a changeset per store in a different
     * format, should return an object with the format expected by {@link Core/data/Store#function-applyChangeset}
     * @param {String} [phantomIdField] Field used by the backend when communicating a record being assigned a
     * proper id instead of a phantom id
     */
    applyChangeset(changes, transformFn = null, phantomIdField, logChanges = false) {
      const me = this, log = logChanges ? /* @__PURE__ */ new Map() : void 0;
      me.suspendAutoSync();
      me.suspendChangesTracking();
      for (const { store, phantomIdField: phantomIdField2 } of me.orderedCrudStores) {
        if (changes[store.id]) {
          const storeLog = store.applyChangeset(
            changes[store.id],
            transformFn,
            phantomIdField2 || me.phantomIdField,
            // mark this changeset as remote to enforce it
            true,
            logChanges
          );
          if (storeLog) {
            log.set(store.id, storeLog);
          }
        }
      }
      me.resumeChangesTracking(true);
      me.resumeAutoSync(false);
      return log;
    }
    //endregion
    /**
     * Generates unique request identifier.
     * @internal
     * @template
     * @returns {Number} The request identifier.
     * @category CRUD
     */
    get requestId() {
      return Number.parseInt(`${Date.now()}${this._requestId++}`);
    }
    /**
     * Persists changes made on the registered stores to the server and/or receives changes made on the backend.
     * Usage:
     *
     * ```javascript
     * // persist and run a callback on request completion
     * crud.sync().then(
     *     () => console.log("Changes saved..."),
     *     ({ response, cancelled }) => console.log(`Error: ${cancelled ? 'Cancelled' : response.message}`)
     * );
     * ```
     *
     * ** Note: ** If there is an incomplete sync request in progress then system will queue the call and delay it
     * until previous request completion.
     * In this case {@link #event-syncDelayed} event will be fired.
     *
     * ** Note: ** Please take a look at {@link #config-autoSync} config. This option allows to persist changes
     * automatically after any data modification.
     *
     * ** Note: ** By default a sync request is only sent if there are any local {@link #property-changes}. To
     * always send a request when calling this function, configure {@link #config-forceSync} as `true`.
     *
     * @returns {Promise} Promise, which is resolved if request was successful.
     * Both the resolve and reject functions are passed a `state` object. State object has the following structure:
     * ```
     * {
     *     cancelled       : Boolean, // **optional** flag, which is present when promise was rejected
     *     rawResponse     : String,  // raw response from ajax request, either response xml or text
     *     rawResponseText : String,  // raw response text as String from ajax request
     *     response        : Object,  // processed response in form of object
     * }
     * ```
     * If promise was rejected by the {@link #event-beforeSync} event, `state` object will have this structure:
     * ```
     * {
     *     cancelled : true
     * }
     * ```
     * @category CRUD
     * @async
     */
    sync() {
      const me = this;
      me.clearTimeout("autoSync");
      if (me.activeRequests.sync) {
        me.trigger("syncDelayed");
        return me.activeSyncPromise = me.activeSyncPromise.finally(() => me.sync());
      }
      return me.activeSyncPromise = new Promise((resolve, reject) => {
        const pack = me.getChangesetPackage();
        if (!pack) {
          resolve(null);
          return;
        }
        if (me.trigger("beforeSync", { pack }) !== false) {
          me.trigger("syncStart", { pack });
          me.activeRequests.sync = {
            type: "sync",
            pack,
            resolve,
            reject,
            id: pack.requestId,
            desc: me.sendRequest({
              id: pack.requestId,
              data: me.encode(pack),
              type: "sync",
              success: me.onCrudRequestSuccess,
              failure: me.onCrudRequestFailure,
              thisObj: me
            })
          };
        } else {
          me.trigger("syncCanceled", { pack });
          reject({ cancelled: true });
        }
      }).catch((error) => {
        if (error && !error.cancelled) {
          throw error;
        }
        return error;
      });
    }
    async onCrudRequestSuccess(rawResponse, fetchOptions, request) {
      const me = this, {
        type: requestType,
        id: requestId
      } = request;
      if (me.isDestroyed)
        return;
      let responseText = "";
      request = me.activeRequests[requestType];
      try {
        responseText = await rawResponse.text();
      } catch (e) {
      }
      if (me.isDestroyed)
        return;
      if ((request == null ? void 0 : request.id) !== requestId) {
        throw new Error(`Interleaved ${requestType} operation detected`);
      }
      me.activeRequests[requestType] = null;
      const response = await me.internalOnResponse(request, responseText, fetchOptions);
      if (me.isDestroyed)
        return;
      if (!response || (me.skipSuccessProperty ? (response == null ? void 0 : response.success) === false : !(response == null ? void 0 : response.success))) {
        const error = {
          rawResponse,
          response,
          request
        };
        if (response == null ? void 0 : response.message) {
          error.message = response.message;
        }
        request.reject(new CrudManagerRequestError(error));
      }
      me["crud" + StringHelper.capitalize(request.type) + "ed"] = true;
      request.resolve({ response, rawResponse, responseText, request });
    }
    async onCrudRequestFailure(rawResponse, fetchOptions, request) {
      var _a3;
      const me = this;
      if (me.isDestroyed)
        return;
      request = me.activeRequests[request.type];
      const signal = (_a3 = fetchOptions == null ? void 0 : fetchOptions.abortController) == null ? void 0 : _a3.signal, wasAborted = Boolean(signal == null ? void 0 : signal.aborted);
      if (!wasAborted) {
        let response, responseText = "";
        try {
          responseText = await rawResponse.text();
          response = me.decode(responseText);
        } catch (e) {
        }
        if (me.isDestroyed)
          return;
        me.triggerFailedRequestEvents(request, response, responseText, fetchOptions);
        if (me.isDestroyed)
          return;
        request.reject(new CrudManagerRequestError({
          rawResponse,
          request
        }));
      }
      me.activeRequests[request.type] = null;
    }
    /**
     * Accepts all changes in all stores, resets the modification tracking:
     * * Clears change tracking for all records
     * * Clears added
     * * Clears modified
     * * Clears removed
     * Leaves the store in an "unmodified" state.
     * @category CRUD
     */
    acceptChanges() {
      this.crudStores.forEach((store) => store.store.acceptChanges());
    }
    /**
     * Reverts all changes in all stores and re-inserts any records that were removed locally. Any new uncommitted
     * records will be removed.
     * @category CRUD
     */
    revertChanges() {
      this.revertCrudStoreChanges();
    }
    revertCrudStoreChanges() {
      const { usesSingleAssignment } = this.eventStore;
      this.orderedCrudStores.forEach(({ store }) => (!store.isAssignmentStore || !usesSingleAssignment) && store.revertChanges());
    }
    /**
     * Removes all stores and cancels active requests.
     * @category CRUD
     * @internal
     */
    doDestroy() {
      const me = this, { load, sync } = me.activeRequests;
      load && me.cancelRequest(load.desc, load.reject);
      sync && me.cancelRequest(sync.desc, sync.reject);
      while (me.crudStores.length > 0) {
        me.removeCrudStore(me.crudStores[0]);
      }
      super.doDestroy && super.doDestroy();
    }
  }, __publicField(_a2, "configurable", {
    /**
     * Convenience shortcut to set only the url to load from, when you do not need to supply any other config
     * options in the `load` section of the `transport` config.
     *
     * Using `loadUrl`:
     * ```javascript
     * {
     *     loadUrl : 'read.php
     * }
     * ```
     *
     * Equals the following `transport` config:
     * ```javascript
     * {
     *     transport : {
     *         load : {
     *             url : 'read.php'
     *         }
     *     }
     * }
     * ```
     *
     * When read at runtime, it will return the value from `transport.load.url`.
     *
     * @prp {String}
     */
    loadUrl: null,
    /**
     * Convenience shortcut to set only the url to sync to, when you do not need to supply any other config
     * options in the `sync` section of the `transport` config.
     *
     * Using `loadUrl`:
     * ```javascript
     * {
     *     syncUrl : 'sync.php
     * }
     * ```
     *
     * Equals the following `transport` config:
     * ```javascript
     * {
     *     transport : {
     *         load : {
     *             url : 'sync.php'
     *         }
     *     }
     * }
     * ```
     *
     * When read at runtime, it will return the value from `transport.sync.url`.
     *
     * @prp {String}
     */
    syncUrl: null,
    /**
     * Specify as `true` to force sync requests to be sent when calling `sync()`, even if there are no local
     * changes. Useful in a polling scenario, to keep client up to date with the backend.
     * @prp {Boolean}
     */
    forceSync: null
  }), __publicField(_a2, "delayable", {
    // Postponed to next frame, to allow Scheduler created after CrudManager to inject its stores
    // (timeRanges, resourceTimeRanges)
    doAutoLoad: "raf"
  }), _a2;
};

// ../Scheduler/lib/Scheduler/crud/AbstractCrudManager.js
var AbstractCrudManager = class extends Base2.mixin(AbstractCrudManagerMixin_default) {
  //region Default config
  /**
   * The server revision stamp.
   * The _revision stamp_ is a number which should be incremented after each server-side change.
   * This property reflects the current version of the data retrieved from the server and gets updated after each
   * {@link Scheduler/crud/AbstractCrudManagerMixin#function-load} and {@link Scheduler/crud/AbstractCrudManagerMixin#function-sync} call.
   * @property {Number}
   * @readonly
   */
  get revision() {
    return this.crudRevision;
  }
  set revision(value) {
    this.crudRevision = value;
  }
  /**
   * Get or set data of {@link #property-crudStores} as a JSON string.
   *
   * Get a JSON string:
   * ```javascript
   *
   * const jsonString = scheduler.crudManager.json;
   *
   * // returned jsonString:
   * '{"eventsData":[...],"resourcesData":[...],...}'
   *
   * // object representation of the returned jsonString:
   * {
   *     resourcesData    : [...],
   *     eventsData       : [...],
   *     assignmentsData  : [...],
   *     dependenciesData : [...],
   *     timeRangesData   : [...],
   *     // data from other stores
   * }
   * ```
   *
   * Set a JSON string (to populate the CrudManager stores):
   *
   * ```javascript
   * scheduler.crudManager.json = '{"eventsData":[...],"resourcesData":[...],...}'
   * ```
   *
   * @property {String}
   */
  get json() {
    return StringHelper.safeJsonStringify(this);
  }
  set json(json) {
    if (typeof json === "string") {
      json = StringHelper.safeJsonParse(json);
    }
    this.forEachCrudStore((store) => {
      const dataName = `${store.storeId}Data`;
      if (json[dataName]) {
        store.data = json[dataName];
      }
    });
  }
  static get defaultConfig() {
    return {
      /**
       * Sets the list of stores controlled by the CRUD manager.
       *
       * When adding a store to the CrudManager, make sure the server response format is correct for `load` and `sync` requests.
       * Learn more in the [Working with data](#Scheduler/guides/data/crud_manager.md#loading-data) guide.
       *
       * Store can be provided as in instance, using its `storeId` or as an {@link #typedef-CrudManagerStoreDescriptor}
       * object.
       * @config {Core.data.Store[]|String[]|CrudManagerStoreDescriptor[]}
       */
      stores: null
      /**
       * Encodes request to the server.
       * @function encode
       * @param {Object} request The request to encode.
       * @returns {String} The encoded request.
       * @abstract
       */
      /**
       * Decodes response from the server.
       * @function decode
       * @param {String} response The response to decode.
       * @returns {Object} The decoded response.
       * @abstract
       */
    };
  }
  //endregion
  //region Init
  construct(config = {}) {
    if (config.stores) {
      config.crudStores = config.stores;
      delete config.stores;
    }
    super.construct(config);
  }
  //endregion
  //region inline data
  /**
   * Returns the data from all CrudManager `crudStores` in a format that can be consumed by `inlineData`.
   *
   * Used by JSON.stringify to correctly convert this CrudManager to json.
   *
   * The returned data is identical to what {@link Scheduler/crud/AbstractCrudManager#property-inlineData} contains.
   *
   * ```javascript
   *
   * const json = scheduler.crudManager.toJSON();
   *
   * // json:
   * {
   *     eventsData : [...],
   *     resourcesData : [...],
   *     dependenciesData : [...],
   *     assignmentsData : [...],
   *     timeRangesData : [...],
   *     resourceTimeRangesData : [...],
   *     // ... other stores data
   * }
   * ```
   *
   * Output can be consumed by `inlineData`.
   *
   * ```javascript
   * const json = scheduler.crudManager.toJSON();
   *
   * // Plug it back in later
   * scheduler.crudManager.inlineData = json;
   * ```
   *
   * @function toJSON
   * @returns {Object}
   * @category JSON
   */
  toJSON() {
    const result = {};
    this.forEachCrudStore((store, storeId) => result[`${storeId}Data`] = store.toJSON());
    return result;
  }
  /**
   * Get or set data of CrudManager stores. The returned data is identical to what
   * {@link Scheduler/crud/AbstractCrudManager#function-toJSON} returns:
   *
   * ```javascript
   *
   * const data = scheduler.crudManager.inlineData;
   *
   * // data:
   * {
   *     eventsData : [...],
   *     resourcesData : [...],
   *     dependenciesData : [...],
   *     assignmentsData : [...],
   *     timeRangesData : [...],
   *     resourceTimeRangesData : [...],
   *     ... other stores data
   * }
   *
   *
   * // Plug it back in later
   * scheduler.crudManager.inlineData = data;
   * ```
   *
   * @property {Object}
   */
  get inlineData() {
    return this.toJSON();
  }
  set inlineData(data) {
    this.json = data;
  }
  //endregion
  //region Store collection (add, remove, get & iterate)
  set stores(stores) {
    if (stores !== this.crudStores) {
      this.crudStores = stores;
    }
  }
  /**
   * A list of registered stores whose server communication will be collected into a single batch.
   * Each store is represented by a _store descriptor_.
   * @member {CrudManagerStoreDescriptor[]} stores
   */
  get stores() {
    return this.crudStores;
  }
  //endregion
  /**
   * Returns true if the crud manager is currently loading data
   * @property {Boolean}
   * @readonly
   * @category CRUD
   */
  get isLoading() {
    return this.isCrudManagerLoading;
  }
  /**
   * Adds a store to the collection.
   *
   *```javascript
   * // append stores to the end of collection
   * crudManager.addStore([
   *     store1,
   *     // storeId
   *     'bar',
   *     // store descriptor
   *     {
   *         storeId : 'foo',
   *         store   : store3
   *     },
   *     {
   *         storeId         : 'bar',
   *         store           : store4,
   *         // to write all fields of modified records
   *         writeAllFields  : true
   *     }
   * ]);
   *```
   *
   * **Note:** Order in which stores are kept in the collection is very essential sometimes.
   * Exactly in this order the loaded data will be put into each store.
   *
   * When adding a store to the CrudManager, make sure the server response format is correct for `load` and `sync`
   * requests. Learn more in the [Working with data](#Scheduler/guides/data/crud_manager.md#loading-data) guide.
   *
   * @param {Core.data.Store|String|CrudManagerStoreDescriptor|Core.data.Store[]|String[]|CrudManagerStoreDescriptor[]} store
   * A store or list of stores. Each store might be specified by its instance, `storeId` or _descriptor_.
   * @param {Number} [position] The relative position of the store. If `fromStore` is specified the position will be
   * taken relative to it.
   * If not specified then store(s) will be appended to the end of collection.
   * Otherwise, it will be an index in stores collection.
   *
   * ```javascript
   * // insert stores store4, store5 to the start of collection
   * crudManager.addStore([ store4, store5 ], 0);
   * ```
   *
   * @param {String|Core.data.Store|CrudManagerStoreDescriptor} [fromStore] The store relative to which position
   * should be calculated. Can be defined as a store identifier, instance or descriptor (the result of
   * {@link Scheduler/crud/AbstractCrudManagerMixin#function-getStoreDescriptor} call).
   *
   * ```javascript
   * // insert store6 just before a store having storeId equal to 'foo'
   * crudManager.addStore(store6, 0, 'foo');
   *
   * // insert store7 just after store3 store
   * crudManager.addStore(store7, 1, store3);
   * ```
   */
  addStore(...args) {
    return this.addCrudStore(...args);
  }
  removeStore(...args) {
    return this.removeCrudStore(...args);
  }
  getStore(...args) {
    return this.getCrudStore(...args);
  }
  hasChanges(...args) {
    return this.crudStoreHasChanges(...args);
  }
  loadData(...args) {
    return this.loadCrudManagerData(...args);
  }
};
AbstractCrudManager._$name = "AbstractCrudManager";

// ../Scheduler/lib/Scheduler/crud/transport/AjaxTransport.js
var AjaxTransport_default = (Target) => class AjaxTransport extends (Target || Base2) {
  static get $name() {
    return "AjaxTransport";
  }
  /**
   * Configuration of the AJAX requests used by _Crud Manager_ to communicate with a server-side.
   *
   * ```javascript
   * transport : {
   *     load : {
   *         url       : 'http://mycool-server.com/load.php',
   *         // HTTP request parameter used to pass serialized "load"-requests
   *         paramName : 'data',
   *         // pass extra HTTP request parameter
   *         params    : {
   *             foo : 'bar'
   *         }
   *     },
   *     sync : {
   *         url     : 'http://mycool-server.com/sync.php',
   *         // specify Content-Type for requests
   *         headers : {
   *             'Content-Type' : 'application/json'
   *         }
   *     }
   * }
   *```
   * Since the class uses Fetch API you can use
   * any its [Request interface](https://developer.mozilla.org/en-US/docs/Web/API/Request) options:
   *
   * ```javascript
   * transport : {
   *     load : {
   *         url         : 'http://mycool-server.com/load.php',
   *         // HTTP request parameter used to pass serialized "load"-requests
   *         paramName   : 'data',
   *         // pass few Fetch API options
   *         method      : 'GET',
   *         credentials : 'include',
   *         cache       : 'no-cache'
   *     },
   *     sync : {
   *         url         : 'http://mycool-server.com/sync.php',
   *         // specify Content-Type for requests
   *         headers     : {
   *             'Content-Type' : 'application/json'
   *         },
   *         credentials : 'include'
   *     }
   * }
   *```
   *
   * An object where you can set the following possible properties:
   * @config {Object} transport
   * @property {Object} [transport.load] Load requests configuration:
   * @property {String} [transport.load.url] URL to request for data loading.
   * @property {String} [transport.load.method='GET'] HTTP method to be used for load requests.
   * @property {String} [transport.load.paramName='data'] Name of the parameter that will contain a serialized `load`
   * request. The value is mandatory for requests using `GET` method (default for `load`) so if the value is not
   * provided `data` string is used as default.
   * This value is optional for HTTP methods like `POST` and `PUT`, the request body will be used for data
   * transferring in these cases.
   * @property {Object} [transport.load.params] An object containing extra HTTP parameters to pass to the server when
   * sending a `load` request.
   *
   * ```javascript
   * transport : {
   *     load : {
   *         url       : 'http://mycool-server.com/load.php',
   *         // HTTP request parameter used to pass serialized "load"-requests
   *         paramName : 'data',
   *         // pass extra HTTP request parameter
   *         // so resulting URL will look like: http://mycool-server.com/load.php?userId=123456&data=...
   *         params    : {
   *             userId : '123456'
   *         }
   *     },
   *     ...
   * }
   * ```
   * @property {Object<String,String>} [transport.load.headers] An object containing headers to pass to each server request.
   *
   * ```javascript
   * transport : {
   *     load : {
   *         url       : 'http://mycool-server.com/load.php',
   *         // HTTP request parameter used to pass serialized "load"-requests
   *         paramName : 'data',
   *         // specify Content-Type for "load" requests
   *         headers   : {
   *             'Content-Type' : 'application/json'
   *         }
   *     },
   *     ...
   * }
   * ```
   * @property {Object} [transport.load.fetchOptions] **DEPRECATED:** Any Fetch API options can be simply defined on
   * the upper configuration level:
   * ```javascript
   * transport : {
   *     load : {
   *         url          : 'http://mycool-server.com/load.php',
   *         // HTTP request parameter used to pass serialized "load"-requests
   *         paramName    : 'data',
   *         // Fetch API options
   *         method       : 'GET',
   *         credentials  : 'include'
   *     },
   *     ...
   * }
   * ```
   * @property {Object} [transport.load.requestConfig] **DEPRECATED:** The config options can be defined on the upper
   * configuration level.
   * @property {Object} [transport.sync] Sync requests (`sync` in further text) configuration:
   * @property {String} [transport.sync.url] URL to request for `sync`.
   * @property {String} [transport.sync.method='POST'] HTTP request method to be used for `sync`.
   * @property {String} [transport.sync.paramName=undefined] Name of the parameter in which `sync` data will be
   * transferred. This value is optional for requests using methods like `POST` and `PUT`, the request body will be
   * used for data transferring in this case (default for `sync`). And the value is mandatory for requests using `GET`
   * method (if the value is not provided `data` string will be used as fallback).
   * @property {Object} [transport.sync.params] HTTP parameters to pass with an HTTP request handling `sync`.
   *
   * ```javascript
   * transport : {
   *     sync : {
   *         url    : 'http://mycool-server.com/sync.php',
   *         // extra HTTP request parameter
   *         params : {
   *             userId : '123456'
   *         }
   *     },
   *     ...
   * }
   * ```
   * @property {Object<String,String>} [transport.sync.headers] HTTP headers to pass with an HTTP request handling `sync`.
   *
   * ```javascript
   * transport : {
   *     sync : {
   *         url     : 'http://mycool-server.com/sync.php',
   *         // specify Content-Type for "sync" requests
   *         headers : {
   *             'Content-Type' : 'application/json'
   *         }
   *     },
   *     ...
   * }
   * ```
   * @property {Object} [transport.sync.fetchOptions] **DEPRECATED:** Any Fetch API options can be simply defined on
   * the upper configuration level:
   * ```javascript
   * transport : {
   *     sync : {
   *         url         : 'http://mycool-server.com/sync.php',
   *         credentials : 'include'
   *     },
   *     ...
   * }
   * ```
   * @property {Object} [transport.sync.requestConfig] **DEPRECATED:** The config options can be defined on the upper
   * configuration level.
   * @category CRUD
   */
  static get defaultMethod() {
    return {
      load: "GET",
      sync: "POST"
    };
  }
  /**
   * Cancels a sent request.
   * @param {Promise} requestPromise The Promise object wrapping the Request to be cancelled.
   * The _requestPromise_ is the value returned from the corresponding {@link #function-sendRequest} call.
   * @category CRUD
   */
  cancelRequest(requestPromise, reject) {
    var _a2;
    (_a2 = requestPromise.abort) == null ? void 0 : _a2.call(requestPromise);
    if (!this.isDestroying) {
      reject({ cancelled: true });
    }
  }
  shouldUseBodyForRequestData(packCfg, method, paramName) {
    return !(method === "HEAD" || method === "GET") && !paramName;
  }
  /**
   * Sends a _Crud Manager_ request to the server.
   * @param {Object} request The request configuration object having following properties:
   * @param {'load'|'sync'} request.type The request type. Either `load` or `sync`.
   * @param {String} request.url The URL for the request. Overrides the URL defined in the `transport` object
   * @param {String} request.data The encoded _Crud Manager_ request data.
   * @param {Object} request.params An object specifying extra HTTP params to send with the request.
   * @param {Function} request.success A function to be started on successful request transferring.
   * @param {String} request.success.rawResponse `Response` object returned by the [fetch api](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
   * @param {Function} request.failure A function to be started on request transfer failure.
   * @param {String} request.failure.rawResponse `Response` object returned by the [fetch api](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
   * @param {Object} request.thisObj `this` reference for the above `success` and `failure` functions.
   * @returns {Promise} The fetch Promise object.
   * @fires beforeSend
   * @async
   * @category CRUD
   */
  sendRequest(request) {
    const me = this, { data } = request, transportConfig = me.transport[request.type] || {}, requestConfig = Objects.assign({}, transportConfig, transportConfig.requestConfig);
    if (request.url) {
      requestConfig.url = request.url;
    }
    requestConfig.method = requestConfig.method || AjaxTransport.defaultMethod[request.type];
    requestConfig.params = Objects.assign(requestConfig.params || {}, request.params);
    let { paramName } = requestConfig;
    if (me.shouldUseBodyForRequestData(transportConfig, requestConfig.method, paramName)) {
      requestConfig.body = data;
      requestConfig.headers = requestConfig.headers || {};
      requestConfig.headers["Content-Type"] = requestConfig.headers["Content-Type"] || "application/json";
    } else {
      paramName = paramName || "data";
      requestConfig.params[paramName] = data;
    }
    if (!requestConfig.url) {
      throw new Error("Trying to request without URL specified");
    }
    delete requestConfig.requestConfig;
    delete requestConfig.paramName;
    let ajaxPromise, resultPromise;
    function performSend() {
      requestConfig.queryParams = requestConfig.params;
      delete requestConfig.params;
      let cancelled = false;
      const fetchOptions = Objects.assign({}, requestConfig, requestConfig.fetchOptions);
      ajaxPromise = AjaxHelper.fetch(requestConfig.url, fetchOptions);
      return ajaxPromise.catch((error) => {
        var _a2, _b;
        ajaxPromise.done = true;
        (_a2 = me.trigger) == null ? void 0 : _a2.call(me, "responseReceived", { success: false });
        const signal = (_b = fetchOptions.abortController) == null ? void 0 : _b.signal;
        if (signal) {
          cancelled = signal.aborted;
          if (!cancelled) {
            console.warn(error);
          }
        }
        return { error, cancelled };
      }).then((response) => {
        var _a2;
        ajaxPromise.done = true;
        (_a2 = me.trigger) == null ? void 0 : _a2.call(me, "responseReceived", { success: Boolean(response == null ? void 0 : response.ok) });
        const callback = (response == null ? void 0 : response.ok) ? request.success : request.failure;
        return callback == null ? void 0 : callback.call(request.thisObj || me, response, fetchOptions, request);
      });
    }
    const beforeSendResult = me.trigger("beforeSend", {
      params: requestConfig.params,
      requestType: request.type,
      requestConfig,
      config: request
    });
    if (Objects.isPromise(beforeSendResult)) {
      resultPromise = beforeSendResult.then(performSend);
    } else {
      resultPromise = performSend();
    }
    resultPromise.abort = () => {
      var _a2;
      if (!ajaxPromise.done) {
        (_a2 = ajaxPromise.abort) == null ? void 0 : _a2.call(ajaxPromise);
      }
    };
    return resultPromise;
  }
};

// ../Scheduler/lib/Scheduler/crud/encoder/JsonEncoder.js
var JsonEncoder_default = (Target) => class JsonEncoder extends (Target || Base2) {
  static get $name() {
    return "JsonEncoder";
  }
  static get defaultConfig() {
    return {
      /**
       * Configuration of the JSON encoder used by the _Crud Manager_.
       *
       * @config {Object}
       * @property {Object} encoder.requestData Static data to send with the data request.
       *
       * ```js
       * new CrudManager({
       *     // add static "foo" property to all requests data
       *     encoder : {
       *         requestData : {
       *             foo : 'Bar'
       *         }
       *     },
       *     ...
       * });
       * ```
       *
       * The above snippet will result adding "foo" property to all requests data:
       *
       * ```json
       *     {
       *         "requestId"   : 756,
       *         "type"        : "load",
       *
       *         "foo"         : "Bar",
       *
       *         "stores"      : [
       *             ...
       * ```
       * @category CRUD
       */
      encoder: {}
    };
  }
  /**
   * Encodes a request object to _JSON_ encoded string. If encoding fails (due to circular structure), it returns null.
   * Supposed to be overridden in case data provided by the _Crud Manager_ has to be transformed into format requested by server.
   * @param {Object} requestData The request to encode.
   * @returns {String} The encoded request.
   * @category CRUD
   */
  encode(requestData) {
    var _a2;
    requestData = Object.assign({}, (_a2 = this.encoder) == null ? void 0 : _a2.requestData, requestData);
    return StringHelper.safeJsonStringify(requestData);
  }
  /**
   * Decodes (parses) a _JSON_ response string to an object. If parsing fails, it returns null.
   * Supposed to be overridden in case data provided by server has to be transformed into format requested by the _Crud Manager_.
   * @param {String} responseText The response text to decode.
   * @returns {Object} The decoded response.
   * @category CRUD
   */
  decode(responseText) {
    return StringHelper.safeJsonParse(responseText);
  }
};

// ../Scheduler/lib/Scheduler/model/mixin/TimeZonedDatesMixin.js
var dateFieldsToConvert = {
  startDate: 1,
  endDate: 1,
  constraintDate: 1,
  deadlineDate: 1
};
var TimeZonedDatesMixin_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || TimeSpan) {
    get timeZone() {
      return this.getData("timeZone");
    }
    set timeZone(timeZone) {
      this.setData("timeZone", timeZone);
    }
    setLocalDate(field2, date) {
      this.set(field2, this.timeZone != null ? TimeZoneHelper.toTimeZone(date, this.timeZone) : date, true);
      this.data[field2] = this[field2];
    }
    getLocalDate(field2) {
      if (this.timeZone != null && this[field2]) {
        return TimeZoneHelper.fromTimeZone(this[field2], this.timeZone);
      }
      return this[field2];
    }
    applyChangeset(rawChanges) {
      if (this.timeZone != null) {
        for (const field2 in dateFieldsToConvert) {
          if (rawChanges[field2]) {
            this.setLocalDate(field2, new Date(rawChanges[field2]));
            delete rawChanges[field2];
          }
        }
      }
      return super.applyChangeset(...arguments);
    }
    getFieldPersistentValue(field2) {
      var _a3, _b;
      if (this.timeZone != null) {
        const fieldName = (_b = (_a3 = field2 == null ? void 0 : field2.field) != null ? _a3 : field2 == null ? void 0 : field2.name) != null ? _b : field2;
        if (dateFieldsToConvert[fieldName]) {
          return this.getLocalDate(fieldName);
        }
      }
      return super.getFieldPersistentValue(field2);
    }
    // Converts current record into a timeZone
    convertToTimeZone(timeZone) {
      const me = this, metaModified = { ...me.meta.modified }, convertFields = { ...dateFieldsToConvert };
      if (me.isTask && !me.manuallyScheduled) {
        delete convertFields.startDate;
        delete convertFields.endDate;
      }
      for (const field2 in convertFields) {
        if (me[field2] != null) {
          convertFields[field2] = me[field2];
          if (me.timeZone != null) {
            convertFields[field2] = me.getLocalDate(field2);
            if (metaModified[field2]) {
              metaModified[field2] = TimeZoneHelper.fromTimeZone(metaModified[field2], me.timeZone);
            }
          }
        } else {
          delete convertFields[field2];
        }
      }
      me.timeZone = timeZone;
      for (const field2 in convertFields) {
        me.setLocalDate(field2, convertFields[field2], false);
        convertFields[field2] = 1;
        if (me.timeZone != null && metaModified[field2]) {
          metaModified[field2] = TimeZoneHelper.toTimeZone(metaModified[field2], me.timeZone);
        }
      }
      me.clearChanges(true, true, convertFields);
      if (!ObjectHelper.isEmpty(metaModified)) {
        me.meta.modified = metaModified;
        me.stores.forEach((store) => store.modified.add(me));
      }
    }
  }, __publicField(_a2, "$name", "TimeZonedDatesMixin"), __publicField(_a2, "fields", [
    /**
     * The current timeZone this record is converted to. Used internally to keep track of time zone conversions.
     *
     * Can also be used to create a new record with dates in a specific non-local timezone. That is useful for
     * example when replacing a store dataset. That would be interpreted as a new load, and all dates would be
     * converted to the configured timezone.
     *
     * For more information about timezone conversion, se {@link Scheduler.model.ProjectModel#config-timeZone}.
     *
     * This field will not {@link Core.data.field.DataField#config-persist} by default.
     *
     * @field {String|Number} timeZone
     * @category Advanced
     */
    {
      name: "timeZone",
      persist: false
    }
  ]), _a2;
};

// ../Scheduler/lib/Scheduler/model/TimeSpan.js
var TimeSpan = class extends Model.mixin(TimeZonedDatesMixin_default) {
  static get $name() {
    return "TimeSpan";
  }
  //region Field definitions
  static get fields() {
    return [
      /**
       * The start date of a time span (or Event / Task).
       *
       * Uses {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat} to convert a
       * supplied string to a Date. To specify another format, either change that setting or subclass TimeSpan and
       * change the dateFormat for this field.
       *
       * Note that the field always returns a `Date`.
       *
       * @field {Date} startDate
       * @accepts {String|Date}
       * @category Scheduling
       */
      {
        name: "startDate",
        type: "date"
      },
      /**
       * The end date of a time span (or Event / Task).
       *
       * Uses {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat} to convert a
       * supplied string to a Date. To specify another format, either change that setting or subclass TimeSpan and
       * change the dateFormat for this field.
       *
       * Note that the field always returns a `Date`.
       *
       * @field {Date} endDate
       * @accepts {String|Date}
       * @category Scheduling
       */
      {
        name: "endDate",
        type: "date"
      },
      /**
       * The numeric part of the timespan's duration (the number of units).
       * @field {Number} duration
       * @category Scheduling
       */
      {
        name: "duration",
        type: "number",
        allowNull: true,
        internal: true
      },
      /**
       * The unit part of the TimeSpan duration, defaults to "d" (days). Valid values are:
       *
       * - "millisecond" - Milliseconds
       * - "second" - Seconds
       * - "minute" - Minutes
       * - "hour" - Hours
       * - "day" - Days
       * - "week" - Weeks
       * - "month" - Months
       * - "quarter" - Quarters
       * - "year"- Years
       *
       * This field is readonly after creation, to change durationUnit use #setDuration().
       * @field {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} durationUnit
       * @category Scheduling
       */
      {
        type: "durationunit",
        name: "durationUnit",
        defaultValue: "d",
        internal: true
      },
      /**
       * Calculated field which encapsulates the duration's magnitude and unit. This field will not be persisted,
       * setting it will update the {@link #field-duration} and {@link #field-durationUnit} fields.
       *
       * @field {DurationConfig|Core.data.Duration} fullDuration
       * @category Scheduling
       */
      {
        name: "fullDuration",
        persist: false,
        column: {
          type: "duration"
        },
        useProp: true
      },
      /**
       * An encapsulation of the CSS classes to add to the rendered time span element.
       *
       * Always returns a {@link Core.helper.util.DomClassList}, but may still be treated as a string. For
       * granular control of adding and removing individual classes, it is recommended to use the
       * {@link Core.helper.util.DomClassList} API.
       *
       * @field {Core.helper.util.DomClassList} cls
       * @accepts {Core.helper.util.DomClassList|String|String[]|Object}
       *
       * @category Styling
       */
      {
        name: "cls",
        defaultValue: "",
        internal: true
      },
      /**
       * CSS class specifying an icon to apply to the rendered time span element.
       * **Note**: In case event is a milestone, using `iconCls` with dependency feature might slightly decrease
       * performance because feature will refer to the DOM to get exact size of the element.
       * @field {String} iconCls
       * @category Styling
       */
      {
        name: "iconCls",
        internal: true
      },
      /**
       * A CSS style string (applied to `style.cssText`) or object (applied to `style`)
       * ```
       * record.style = 'color: red;font-weight: 800';
       * ```
       *
       * @field {String} style
       * @category Styling
       */
      {
        name: "style",
        type: "object",
        internal: true
      },
      /**
       * The name of the time span (or Event / Task)
       * @field {String} name
       * @category Common
       */
      {
        name: "name",
        type: "string",
        defaultValue: ""
      }
    ];
  }
  //endregion
  //region Init
  construct(data, ...args) {
    if (data == null ? void 0 : data.fullDuration) {
      const { magnitude, unit } = data.fullDuration;
      data.duration = magnitude;
      data.unit = unit;
      delete data.fullDuration;
    }
    super.construct(data, ...args);
    this.normalize();
  }
  /**
   * Returns the event store this event is part of, if any.
   *
   * @property {Scheduler.data.EventStore}
   * @readonly
   * @category Misc
   */
  get eventStore() {
    var _a2;
    const me = this;
    if (me.isOccurrence) {
      return me.recurringTimeSpan.eventStore;
    }
    if (!me._eventStore) {
      me._eventStore = (_a2 = me.stores) == null ? void 0 : _a2.find((s) => s.isEventStore);
    }
    return me._eventStore;
  }
  normalize() {
    const me = this, { startDate, endDate, duration, durationUnit } = me, hasDuration = duration != null;
    if (startDate && endDate && !hasDuration) {
      me.setData("duration", DateHelper.diff(startDate, endDate, durationUnit, true));
    } else if (startDate && !endDate && hasDuration) {
      me.setData("endDate", DateHelper.add(startDate, duration, durationUnit));
    } else if (!startDate && endDate && hasDuration) {
      me.setData("startDate", DateHelper.add(endDate, -duration, durationUnit));
    }
  }
  //endregion
  //region Getters & Setters
  updateInternalCls(cls) {
    if (this._cls) {
      this._cls.value = cls;
    } else {
      this._cls = new DomClassList(cls);
    }
  }
  set internalCls(cls) {
    this.updateInternalCls(cls);
    this.set("cls", this._cls.value);
  }
  get internalCls() {
    const { cls } = this;
    if (cls == null ? void 0 : cls.isDomClassList) {
      return cls;
    }
    this.internalCls = cls;
    return this._cls;
  }
  get cls() {
    if (!this._cls) {
      this._cls = new DomClassList(super.get("cls"));
    }
    return this._cls;
  }
  set cls(cls) {
    this.internalCls = cls;
  }
  get startDate() {
    return this.get("startDate");
  }
  set startDate(date) {
    this.setStartDate(date);
  }
  get endDate() {
    return this.get("endDate");
  }
  set endDate(date) {
    this.setEndDate(date);
  }
  get endingDate() {
    const me = this, {
      endDate,
      startDate
    } = me;
    if (endDate) {
      return endDate;
    }
    return DateHelper.add(startDate, me.duration, me.durationUnit);
  }
  get duration() {
    return this.get("duration");
  }
  set duration(duration) {
    this.setDuration(duration, this.durationUnit);
  }
  get durationUnit() {
    return this.get("durationUnit");
  }
  /**
   * Sets duration and durationUnit in one go. Only allowed way to change durationUnit, the durationUnit field is
   * readonly after creation
   * @param {Number} duration Duration value
   * @param {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} durationUnit Unit for
   * specified duration value, see {@link #field-durationUnit} for valid values
   * @category Scheduling
   */
  setDuration(duration, durationUnit = this.durationUnit) {
    duration = parseFloat(duration);
    this.set({
      duration,
      durationUnit,
      ...this.updateDatesFromDuration(duration, durationUnit)
    });
  }
  updateDatesFromDuration(magnitude, unit, startDate = this.startDate, endDate = this.endDate) {
    const result = {};
    if (startDate) {
      result.endDate = DateHelper.add(startDate, magnitude, unit);
    } else if (endDate) {
      result.startDate = DateHelper.add(endDate, -magnitude, unit);
    }
    return result;
  }
  /**
   * Returns duration of the event in given unit. This is a wrapper for {@link Core.helper.DateHelper#function-getDurationInUnit-static}
   * @param {'ms'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} unit
   * @param {Boolean} [doNotRound]
   * @private
   * @returns {Number}
   */
  getDurationInUnit(unit, doNotRound) {
    const me = this;
    if (me.startDate && me.endDate) {
      return DateHelper.getDurationInUnit(me.startDate, me.endDate, unit, doNotRound);
    } else {
      return DateHelper.as(unit, me.duration, me.durationUnit);
    }
  }
  get fullDuration() {
    return new Duration({
      unit: this.durationUnit,
      magnitude: this.duration
    });
  }
  set fullDuration(duration) {
    if (typeof duration === "string") {
      duration = DateHelper.parseDuration(duration, true, this.durationUnit);
    }
    this.setDuration(duration.magnitude, duration.unit);
  }
  /**
   * Sets the range start date
   *
   * @param {Date} date The new start date
   * @param {Boolean} keepDuration Pass `true` to keep the duration of the task ("move" the event), `false` to change the duration ("resize" the event).
   * Defaults to `true`
   * @category Scheduling
   */
  setStartDate(date, keepDuration = true) {
    const me = this, toSet = {
      startDate: date
    };
    if (date) {
      let calcEndDate;
      if (keepDuration) {
        calcEndDate = me.duration != null;
      } else {
        if (me.endDate) {
          toSet.duration = DateHelper.diff(date, me.endDate, me.durationUnit, true);
          if (toSet.duration < 0)
            throw new Error("Negative duration");
        } else {
          calcEndDate = this.duration != null;
        }
      }
      if (calcEndDate) {
        toSet.endDate = DateHelper.add(date, me.getDurationInUnit("h"), "h");
      }
    } else {
      toSet.duration = null;
    }
    me.set(toSet);
  }
  /**
   * Sets the range end date
   *
   * @param {Date} date The new end date
   * @param {Boolean} keepDuration Pass `true` to keep the duration of the task ("move" the event), `false` to change the duration ("resize" the event).
   * Defaults to `false`
   * @category Scheduling
   */
  setEndDate(date, keepDuration = false) {
    const me = this, toSet = {
      endDate: date
    };
    if (date) {
      let calcStartDate;
      if (keepDuration === true) {
        calcStartDate = me.duration != null;
      } else {
        if (me.startDate) {
          toSet.duration = DateHelper.diff(me.startDate, date, me.durationUnit, true);
          if (toSet.duration < 0)
            throw new Error("Negative duration");
        } else {
          calcStartDate = this.duration != null;
        }
      }
      if (calcStartDate) {
        toSet.startDate = DateHelper.add(date, -me.duration, me.durationUnit);
      }
    }
    me.set(toSet);
  }
  /**
   * Sets the event start and end dates
   *
   * @param {Date} start The new start date
   * @param {Date} end The new end date
   * @param {Boolean} [silent] Pass `true` to not trigger events
   * @category Scheduling
   */
  setStartEndDate(start, end, silent) {
    this.set({
      startDate: start,
      endDate: end
    }, null, silent);
  }
  /**
   * Returns an array of dates in this range. If the range starts/ends not at the beginning of day, the whole day will be included.
   * @readonly
   * @property {Date[]}
   * @category Scheduling
   */
  get dates() {
    const dates = [], startDate = DateHelper.startOf(this.startDate, "day"), endDate = this.endDate;
    for (let date = startDate; date < endDate; date = DateHelper.add(date, 1, "day")) {
      dates.push(date);
    }
    return dates;
  }
  get startDateMS() {
    var _a2;
    return (_a2 = this.batching && this.hasBatchedChange("startDate") ? this.get("startDate") : this.startDate) == null ? void 0 : _a2.getTime();
  }
  get endDateMS() {
    var _a2;
    return (_a2 = this.batching && this.hasBatchedChange("endDate") ? this.get("endDate") : this.endDate) == null ? void 0 : _a2.getTime();
  }
  /**
   * Returns the duration of this Event in milliseconds.
   * @readonly
   * @property {Number}
   * @category Scheduling
   */
  get durationMS() {
    const { endDateMS, startDateMS } = this;
    if (endDateMS && startDateMS) {
      return endDateMS - startDateMS;
    } else {
      return DateHelper.asMilliseconds(this.duration || 0, this.durationUnit);
    }
  }
  /**
   * Returns true if record is a milestone.
   * @readonly
   * @property {Boolean}
   * @category Scheduling
   */
  get isMilestone() {
    return this.duration === 0;
  }
  inSetNormalize(field2) {
    if (typeof field2 !== "string") {
      let { startDate, endDate, duration, durationUnit = this.durationUnit } = field2;
      if (typeof startDate === "string") {
        startDate = this.getFieldDefinition("startDate").convert(startDate);
      }
      if (typeof endDate === "string") {
        endDate = this.getFieldDefinition("endDate").convert(endDate);
      }
      if ("duration" in field2) {
        if (startDate && !endDate) {
          endDate = DateHelper.add(startDate, duration, durationUnit, true, true);
        }
        if (!startDate && endDate) {
          startDate = DateHelper.add(endDate, -duration, durationUnit, true, true);
        }
      } else if (startDate && endDate) {
        duration = DateHelper.as(durationUnit, DateHelper.diff(startDate, endDate, "h", true), "h");
      }
      const fieldOrClone = Object.isFrozen(field2) ? ObjectHelper.clone(field2) : field2;
      startDate && (fieldOrClone.startDate = startDate);
      endDate && (fieldOrClone.endDate = endDate);
      duration != null && (fieldOrClone.duration = duration);
      return fieldOrClone;
    }
  }
  fieldToKeys(field2, value) {
    var _a2, _b;
    const result = super.fieldToKeys(field2, value);
    if (result.fullDuration) {
      const { magnitude, unit } = result.fullDuration;
      result.duration = magnitude;
      result.durationUnit = unit;
    }
    if (!this.isEventModel && !this.isTaskModel) {
      if (("duration" in result || result.durationUnit) && !(result.startDate && result.endDate)) {
        Object.assign(
          result,
          this.updateDatesFromDuration(
            (_a2 = result.duration) != null ? _a2 : this.duration,
            (_b = result.durationUnit) != null ? _b : this.durationUnit,
            result.startDate,
            result.endDate
          )
        );
      }
    }
    return result;
  }
  inSet(field2, value, silent, fromRelationUpdate, skipAccessors, validOnly) {
    if (!skipAccessors) {
      field2 = this.inSetNormalize(field2) || field2;
    }
    return super.inSet(field2, value, silent, fromRelationUpdate, skipAccessors, validOnly);
  }
  // Cls requires special handling since it is converted to a DomClassList
  applyValue(useProp, key, value, skipAccessors, field2) {
    if (key === "cls") {
      this.updateInternalCls(value);
    }
    super.applyValue(useProp, key, value, skipAccessors, field2);
  }
  //endregion
  //region Iteration
  /**
   * Iterates over the {@link #property-dates}
   * @param {Function} func The function to call for each date
   * @param {Object} thisObj `this` reference for the function
   * @category Scheduling
   */
  forEachDate(func, thisObj) {
    return this.dates.forEach(func.bind(thisObj));
  }
  //endregion
  /**
   * Checks if the range record has both start and end dates set and start <= end
   *
   * @property {Boolean}
   * @category Scheduling
   */
  get isScheduled() {
    const { startDateMS, endDateMS } = this;
    return endDateMS - startDateMS >= 0;
  }
  // Simple check if end date is greater than start date
  get isValid() {
    const { startDate, endDate } = this;
    return !startDate || !endDate || endDate - startDate >= 0;
  }
  /**
   * Shift the dates for the date range by the passed amount and unit
   * @param {'ms'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} unit The unit to shift by, see {@link Core.helper.DateHelper}
   * for more information on valid formats.
   * @param {Number} amount The amount to shift
   */
  shift(amount, unit = this.durationUnit) {
    if (typeof amount === "string") {
      const u = amount;
      amount = unit;
      unit = u;
    }
    return this.setStartDate(DateHelper.add(this.startDate, amount, unit, true), true);
  }
  /**
   * Returns the WBS code of this model (e.g '2.1.3'). Only relevant when part of a tree store, as in the Gantt chart.
   * @property {String}
   * @category Parent & children
   */
  get wbsCode() {
    return this._wbsCode || this.indexPath.join(".");
  }
  set wbsCode(value) {
    this._wbsCode = value;
  }
  fullCopy() {
    return this.copy.apply(this, arguments);
  }
  intersects(timeSpan) {
    return this.intersectsRange(timeSpan.startDate, timeSpan.endDate);
  }
  intersectsRange(start, end) {
    const myStart = this.startDate, myEnd = this.endDate;
    return myStart && myEnd && DateHelper.intersectSpans(myStart, myEnd, start, end);
  }
  /**
   * Splits this event into two pieces at the desired position.
   *
   * @param {Number|String} splitPoint The duration point at which to split this event.
   *
   * If less then `1`, this indicates the relative position at which it will be split.
   * 0.5 means cut it in half.
   *
   * If greater than `1`, this indicates the new duration in the current duration units of this event before the split.
   *
   * If this is a string, it will be a duration description as described in
   * {@link Core.helper.DateHelper#function-parseDuration-static}, for example `'15 min'`
   *
   * @returns {Scheduler.model.TimeSpan} The newly created split section of the timespan
   * @category Scheduling
   */
  split(splitPoint = 0.5) {
    const me = this, clone = me.copy(), {
      fullDuration,
      eventStore,
      assignmentStore
    } = me, oldDuration = new Duration(fullDuration), cloneDuration = new Duration(fullDuration);
    let ownNewDuration, unitsChanged;
    if (typeof splitPoint === "string") {
      ownNewDuration = new Duration(splitPoint);
      if (ownNewDuration.unit === oldDuration.unit) {
        cloneDuration.magnitude -= ownNewDuration.magnitude;
      } else {
        cloneDuration.magnitude = DateHelper.as(ownNewDuration.unit, oldDuration) - ownNewDuration.magnitude;
        cloneDuration.unit = ownNewDuration.unit;
        unitsChanged = true;
      }
    } else {
      ownNewDuration = new Duration(splitPoint > 1 ? splitPoint : me.duration * splitPoint, me.durationUnit);
      cloneDuration.magnitude -= ownNewDuration.magnitude;
    }
    clone.startDate = DateHelper.add(me.startDate, ownNewDuration.magnitude, ownNewDuration.unit);
    if (unitsChanged) {
      clone.fullDuration = cloneDuration;
      me.fullDuration = ownNewDuration;
    } else {
      clone.duration = cloneDuration.magnitude;
      me.duration = ownNewDuration.magnitude;
    }
    if (eventStore) {
      eventStore.add(clone);
      if (assignmentStore && !eventStore.usesSingleAssignment) {
        assignmentStore.add(
          me.assignments.map((assignment) => {
            const clonedData = Object.assign({}, assignment.data, {
              eventId: clone.id,
              // From engine
              event: null,
              resource: null
            });
            delete clonedData.id;
            return clonedData;
          })
        );
      }
    }
    return clone;
  }
  toICSString(icsEventConfig = {}) {
    if (!this.isScheduled) {
      return "";
    }
    const {
      startDate,
      endDate
    } = this, timestamp = icsEventConfig.DTSTAMP || DateHelper.format(/* @__PURE__ */ new Date(), "uu");
    delete icsEventConfig.DTSTAMP;
    let startEnd = {};
    if (this.allDay) {
      startEnd = {
        "DTSTART;VALUE=DATE": DateHelper.format(startDate, "u"),
        "DTEND;VALUE=DATE": DateHelper.format(endDate, "u")
      };
    } else {
      startEnd = {
        DTSTART: DateHelper.format(startDate, "uu"),
        DTEND: DateHelper.format(endDate, "uu")
      };
    }
    const version = VersionHelper.scheduler && VersionHelper.getVersion("scheduler") || VersionHelper.calendar && VersionHelper.getVersion("calendar") || "", icsWrapConfig = {
      BEGIN: "VCALENDAR",
      VERSION: "2.0",
      CALSCALE: "GREGORIAN",
      PRODID: `-//Bryntum AB//Bryntum Scheduler ${version} //EN`,
      END: "VCALENDAR"
    }, eventConfig = {
      BEGIN: "VEVENT",
      UID: this.id + "@bryntum.com",
      CLASS: "PUBLIC",
      SUMMARY: this.name,
      DTSTAMP: timestamp,
      ...startEnd,
      ...this.recurrenceRule ? { RRULE: this.recurrenceRule } : {},
      ...icsEventConfig,
      END: "VEVENT"
    }, icsItems = Object.keys(icsWrapConfig).map((key) => `${key}:${icsWrapConfig[key]}`), eventItems = Object.keys(eventConfig).map((key) => `${key}:${eventConfig[key]}`);
    icsItems.splice(icsItems.length - 1, 0, ...eventItems);
    return icsItems.join("\n");
  }
  /**
   * Triggers a download of this time span in ICS format (for import in Outlook etc.)
   *
   * ```javascript
   * timeSpan.downloadAsICS({
   *      LOCATION : timeSpan.location
   *  });
   * ```
   * @param {Object<String,String>} [icsEventConfig] A config object with properties to be added in to `BEGIN:VEVENT`
   * section of the exported event.
   * @category Misc
   */
  exportToICS(icsEventConfig) {
    if (this.isScheduled) {
      const blob = new Blob([this.toICSString(icsEventConfig)], { type: "text/calendar" });
      BrowserHelper.downloadBlob(blob, (this.name || "Event") + ".ics");
    }
  }
  /**
   * Defines if the given event field should be manually editable in UI.
   * You can override this method to provide your own logic.
   *
   * By default the method defines all the event fields as editable.
   *
   * @param {String} fieldName Name of the field
   * @returns {Boolean} Returns `true` if the field is editable, `false` if it is not and `undefined` if the model has no such field.
   */
  isEditable(fieldName) {
    return this.getFieldDefinition(fieldName) ? true : void 0;
  }
  isFieldModified(fieldName) {
    if (fieldName === "fullDuration") {
      return super.isFieldModified("duration") || super.isFieldModified("durationUnit");
    }
    return super.isFieldModified(fieldName);
  }
};
TimeSpan._$name = "TimeSpan";

// ../Scheduler/lib/Scheduler/data/util/recurrence/RecurrenceDayRuleEncoder.js
var dayParseRegExp = /^([+-]?[0-9])?(SU|MO|TU|WE|TH|FR|SA)$/;
var days = ["SU", "MO", "TU", "WE", "TH", "FR", "SA"];
var RecurrenceDayRuleEncoder = class extends Base2 {
  static decodeDay(rawDay) {
    let parsedDay, result;
    if (parsedDay = dayParseRegExp.exec(rawDay)) {
      result = [days.indexOf(parsedDay[2])];
      if (parsedDay[1]) {
        parsedDay[1] = parseInt(parsedDay[1], 10);
        result.push(parsedDay[1]);
      }
    }
    return result;
  }
  static encodeDay(day2) {
    let position;
    if (Array.isArray(day2)) {
      [day2, position] = day2;
    }
    return (position ? position.toString() : "") + days[day2];
  }
  // Turns days values provided as an array of strings (like [`-1MO`, `SU`, `+3FR`])
  // into an array of [ dayIndex, position ] elements, where:
  //
  // - `dayIndex` - zero-based week day index value (0 - Sunday, 1 - Monday, 2 - Tuesday, etc.)
  // - `position` - (optional) 1-based position of the day (integer value (can be both positive and negative))
  static decode(rawDays) {
    const result = [];
    let parsedDay;
    if (rawDays) {
      for (let i = 0; i < rawDays.length; i++) {
        if (parsedDay = this.decodeDay(rawDays[i])) {
          result.push(parsedDay);
        }
      }
    }
    return result;
  }
  static encode(days2) {
    const result = [];
    let day2;
    if (days2) {
      for (let i = 0; i < days2.length; i++) {
        if (day2 = this.encodeDay(days2[i])) {
          result.push(day2);
        }
      }
    }
    return result;
  }
};
RecurrenceDayRuleEncoder._$name = "RecurrenceDayRuleEncoder";

// ../Scheduler/lib/Scheduler/data/util/recurrence/AbstractRecurrenceIterator.js
var frequencyToUnitRe = /ly$/i;
var frequencyToUnit = (frequency) => {
  const result = frequency.replace(frequencyToUnitRe, "");
  return result === "DAI" ? "DAY" : result;
};
var fn = (date, counter, isFirst, timeSpan) => timeSpan.buildOccurrence(date, isFirst);
var captureLastOccurrence = (date) => lastOccurrenceDate = date;
var lastOccurrenceDate;
var AbstractRecurrenceIterator = class extends Base2 {
  static processIterationConfig(config) {
    const { recurrence } = config, {
      frequency,
      interval,
      timeSpan,
      endDate: until,
      count
    } = recurrence;
    if (!config.syncingStartDate && !timeSpan.meta.isSyncedWithRule) {
      const intervalEndDate = DateHelper.add(timeSpan.startDate, interval, frequencyToUnit(frequency)), endDate2 = DateHelper.min(
        intervalEndDate,
        config.endDate || intervalEndDate
      );
      this.forEachDate({
        syncingStartDate: true,
        startDate: timeSpan.startDate,
        endDate: endDate2,
        recurrence,
        fn
      });
    }
    const timeSpanStart = timeSpan.startDate;
    let {
      startDate = timeSpanStart,
      endDate = until
    } = config;
    if (startDate < timeSpanStart) {
      startDate = timeSpanStart;
    }
    if (until) {
      if (!endDate || endDate > until) {
        endDate = until;
      }
    } else if (count && startDate > timeSpanStart) {
      this.forEachDate({
        recurrence,
        fn: captureLastOccurrence
      });
      if (!endDate || endDate > lastOccurrenceDate) {
        endDate = new Date(lastOccurrenceDate.getTime() + 1);
      }
    }
    const earliestVisibleDate = startDate;
    if (!config.startOnly) {
      startDate = new Date(DateHelper.max(DateHelper.add(startDate, -interval, frequencyToUnit(frequency)), timeSpanStart));
    }
    return Object.assign({
      extraArgs: [],
      // Only check start date for time spans with 0 duration
      startOnly: !Boolean(timeSpan.durationMS)
    }, config, {
      startDate,
      endDate,
      timeSpan,
      timeSpanStart,
      earliestVisibleDate,
      endDateMS: endDate == null ? void 0 : endDate.getTime(),
      timeSpanStartMS: timeSpanStart.getTime(),
      earliestVisibleDateMS: earliestVisibleDate.getTime(),
      durationMS: timeSpan.durationMS,
      spansStart: startDate <= timeSpanStart && endDate > timeSpanStart
    });
  }
  static getOccurrenceIndex(event) {
    if (event.isOccurrence) {
      return DateHelper.diff(event.recurringTimeSpan.startDate, event.startDate, frequencyToUnit(event.recurringTimeSpan.recurrence.frequency));
    }
  }
  /**
   * Returns Nth occurrence of a week day in the provided period of time.
   * @param  {Date} startDate Period start date.
   * @param  {Date} endDate   Period end date.
   * @param  {Number} day    Week day (0 - Sunday, 1 - Monday, 2 - Tuesday, etc.)
   * @param  {Number} index  Index to find.
   * @returns {Date}           Returns the found date or null if there is no `index`th entry.
   * @private
   */
  static getNthDayInPeriod(startDate, endDate, day2, index) {
    let result, sign, borderDate;
    if (index) {
      if (index > 0) {
        sign = 1;
        borderDate = startDate;
      } else {
        sign = -1;
        borderDate = endDate;
      }
      const delta = day2 - borderDate.getDay();
      if (sign * delta < 0) {
        index += sign;
      }
      result = new Date(borderDate);
      result.setDate(borderDate.getDate() + (index - sign) * 7 + delta);
      if (result < startDate || result > endDate) {
        result = null;
      }
    }
    return result;
  }
  static buildDate(year, month2, date) {
    const dt = new Date(year, month2, date);
    if (dt.getFullYear() === year && dt.getMonth() === month2 && dt.getDate() === date) {
      return dt;
    }
  }
  static isValidPosition(position) {
    return Boolean(position);
  }
  static forEachDateAtPositions(dates, positions, fn2, scope) {
    const datesLength = dates.length, processed = {};
    for (let i = 0; i < positions.length; i++) {
      const index = positions[i];
      if (this.isValidPosition(index)) {
        const date = index > 0 ? dates[index - 1] : dates[datesLength + index];
        if (date && !processed[date.getTime()]) {
          processed[date.getTime()] = true;
          if (fn2.call(scope, date) === false) {
            return false;
          }
        }
      }
    }
  }
  static isInView(startOnly, occurrenceDate, earliestVisibleDate, durationMS, timeSpan) {
    return (startOnly ? occurrenceDate >= earliestVisibleDate : occurrenceDate.valueOf() + durationMS > earliestVisibleDate) && !timeSpan.hasException(occurrenceDate);
  }
  // Slightly faster version of ^, used by Daily & Weekly iterators
  static isInViewMS(startOnly, occurenceDate, occurrenceDateMS, earliestVisibleDateMS, durationMS, timeSpan) {
    return (startOnly ? occurrenceDateMS >= earliestVisibleDateMS : occurrenceDateMS + durationMS > earliestVisibleDateMS) && !timeSpan.hasException(occurenceDate);
  }
};
__publicField(AbstractRecurrenceIterator, "frequency", "NONE");
__publicField(AbstractRecurrenceIterator, "MAX_OCCURRENCES_COUNT", 1e6);
AbstractRecurrenceIterator._$name = "AbstractRecurrenceIterator";

// ../Scheduler/lib/Scheduler/data/util/recurrence/DailyRecurrenceIterator.js
var DailyRecurrenceIterator = class extends AbstractRecurrenceIterator {
  /**
   * Iterates over the passed date range, calling the passed callback on each date on which
   * starts a recurring event which matches the passed recurrence rule and overlaps the start and end dates
   * and is not an {@link Scheduler.model.mixin.RecurringTimeSpan#field-exceptionDates exceptionDate}
   * in the recurring event.
   * @param {Object} config An object which describes how to iterate.
   * @param {Date} config.startDate The point in time to begin iteration.
   * @param {Date} config.endDate The point in time to end iteration.
   * @param {Boolean} [config.startOnly] By default, all occurrences which intersect the date range
   * will be visited. Pass `true` to only visit occurrences which *start* in the date range.
   * @param {Scheduler.model.RecurrenceModel} config.recurrence The point in time to end iteration.
   * @param {Function} config.fn The function to call for each date which matches the recurrence in the date range.
   * @param {Date} config.fn.date The occurrence date.
   * @param {Number} config.fn.counter A counter of how many dates have been visited in this iteration.
   * @param {Boolean} config.fn.isFirst A flag which is `true` if the date is the first occurrence in the specified recurrence rule.
   * @param {Array} [config.extraArgs] Extra arguments to pass to the callback after the `isFirst` argument.
   */
  static forEachDate(config) {
    const {
      startOnly,
      startDate,
      endDate,
      endDateMS,
      timeSpan,
      timeSpanStart,
      earliestVisibleDateMS,
      durationMS,
      spansStart,
      recurrence,
      fn: fn2,
      extraArgs,
      scope = this
    } = this.processIterationConfig(config), { interval } = recurrence, delay3 = startDate - timeSpanStart, intervalDuration = interval * 864e5, delayInIntervals = Math.floor(delay3 / intervalDuration);
    let { count } = recurrence, counter = 0, occurrenceDate = DateHelper.add(timeSpanStart, delayInIntervals * interval, "day"), occurrenceDateMS = occurrenceDate.getTime();
    if (!endDate && !count) {
      count = this.MAX_OCCURRENCES_COUNT;
    }
    while (!endDateMS || occurrenceDateMS < endDateMS) {
      const inView = this.isInViewMS(startOnly, occurrenceDate, occurrenceDateMS, earliestVisibleDateMS, durationMS, timeSpan);
      counter++;
      if (inView && (endDateMS && occurrenceDateMS > endDateMS || fn2.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || count && counter >= count)) {
        break;
      }
      occurrenceDate = DateHelper.add(occurrenceDate, interval, "day");
      occurrenceDateMS = occurrenceDate.getTime();
    }
  }
};
__publicField(DailyRecurrenceIterator, "frequency", "DAILY");
DailyRecurrenceIterator._$name = "DailyRecurrenceIterator";

// ../Scheduler/lib/Scheduler/data/util/recurrence/WeeklyRecurrenceIterator.js
var WeeklyRecurrenceIterator = class extends AbstractRecurrenceIterator {
  /**
   * Iterates over the passed date range, calling the passed callback on each date on which
   * starts an event which matches the passed recurrence rule and overlaps the start and end dates.
   * @param {Object} config An object which describes how to iterate.
   * @param {Date} config.startDate The point in time to begin iteration.
   * @param {Date} config.endDate The point in time to end iteration.
   * @param {Boolean} [config.startOnly] By default, all occurrences which intersect the date range
   * will be visited. Pass `true` to only visit occurrences which *start* in the date range.
   * @param {Scheduler.model.RecurrenceModel} config.recurrence The point in time to end iteration.
   * @param {Function} config.fn The function to call for each date which matches the recurrence in the date range.
   * @param {Date} config.fn.date The occurrence date.
   * @param {Number} config.fn.counter A counter of how many dates have been visited in this iteration.
   * @param {Boolean} config.fn.isFirst A flag which is `true` if the date is the first occurrence in the specified recurrence rule.
   * @param {Array} [config.extraArgs] Extra arguments to pass to the callback after the `isFirst` argument.
   */
  static forEachDate(config) {
    const {
      startOnly,
      startDate,
      endDateMS,
      timeSpan,
      timeSpanStart,
      timeSpanStartMS,
      earliestVisibleDateMS,
      durationMS,
      spansStart,
      recurrence,
      fn: fn2,
      extraArgs,
      scope = this
    } = this.processIterationConfig(config), {
      interval,
      days: days2
    } = recurrence, { weekStartDay } = DateHelper, startHours = timeSpanStart.getHours(), startMinutes = timeSpanStart.getMinutes(), startSeconds = timeSpanStart.getSeconds(), startMS = timeSpanStart.getMilliseconds();
    let counter = 0, { count } = recurrence, weekDays = RecurrenceDayRuleEncoder.decode(days2), weekStartDate, occurrenceDate;
    if (!(weekDays == null ? void 0 : weekDays.length)) {
      weekDays = [[timeSpanStart.getDay()]];
    }
    if (weekStartDay > 0) {
      for (let i = 0; i < weekDays.length; i++) {
        if (weekStartDay > weekDays[i][0]) {
          weekDays[i][0] = 7 - weekStartDay - weekDays[i][0];
        } else {
          weekDays[i][0] -= weekStartDay;
        }
      }
    }
    weekDays.sort((a, b) => a[0] - b[0]);
    weekStartDate = DateHelper.getNext(count || interval > 1 ? timeSpanStart : startDate, "week", 0);
    if (!endDateMS && !count) {
      count = this.MAX_OCCURRENCES_COUNT;
    }
    while (!endDateMS || weekStartDate.getTime() < endDateMS) {
      for (let i = 0; i < weekDays.length; i++) {
        occurrenceDate = new Date(
          weekStartDate.getFullYear(),
          weekStartDate.getMonth(),
          weekStartDate.getDate() + weekDays[i][0],
          startHours,
          startMinutes,
          startSeconds,
          startMS
        );
        const occurrenceDateMS = occurrenceDate.getTime();
        if (occurrenceDateMS >= timeSpanStartMS) {
          const inView = this.isInViewMS(startOnly, occurrenceDate, occurrenceDateMS, earliestVisibleDateMS, durationMS, timeSpan);
          counter++;
          if (inView && (endDateMS && occurrenceDateMS >= endDateMS || fn2.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || count && counter >= count)) {
            return;
          }
        }
      }
      weekStartDate = DateHelper.getNext(weekStartDate, "week", interval);
    }
  }
};
__publicField(WeeklyRecurrenceIterator, "frequency", "WEEKLY");
WeeklyRecurrenceIterator._$name = "WeeklyRecurrenceIterator";

// ../Scheduler/lib/Scheduler/data/util/recurrence/MonthlyRecurrenceIterator.js
var MonthlyRecurrenceIterator = class extends AbstractRecurrenceIterator {
  static getNthDayOfMonth(date, dayNum) {
    const daysInMonth = DateHelper.daysInMonth(date);
    let result = null;
    if (dayNum && Math.abs(dayNum) <= daysInMonth) {
      result = new Date(date.getFullYear(), date.getMonth(), dayNum < 0 ? daysInMonth + dayNum + 1 : dayNum);
    }
    return result;
  }
  static isValidPosition(position) {
    return position && Math.abs(position) > 0 && Math.abs(position) <= 31;
  }
  /**
   * Iterates over the passed date range, calling the passed callback on each date on which
   * starts an event which matches the passed recurrence rule and overlaps the start and end dates.
   * @param {Object} config An object which describes how to iterate.
   * @param {Date} config.startDate The point in time to begin iteration.
   * @param {Date} config.endDate The point in time to end iteration.
   * @param {Boolean} [config.startOnly] By default, all occurrences which intersect the date range
   * will be visited. Pass `true` to only visit occurrences which *start* in the date range.
   * @param {Scheduler.model.RecurrenceModel} config.recurrence The point in time to end iteration.
   * @param {Function} config.fn The function to call for each date which matches the recurrence in the date range.
   * @param {Date} config.fn.date The occurrence date.
   * @param {Number} config.fn.counter A counter of how many dates have been visited in this iteration.
   * @param {Boolean} config.fn.isFirst A flag which is `true` if the date is the first occurrence in the specified recurrence rule.
   * @param {Array} [config.extraArgs] Extra arguments to pass to the callback after the `isFirst` argument.
   */
  static forEachDate(config) {
    const {
      startOnly,
      startDate,
      endDate,
      timeSpan,
      timeSpanStart,
      earliestVisibleDate,
      durationMS,
      spansStart,
      recurrence,
      fn: fn2,
      extraArgs,
      scope = this
    } = this.processIterationConfig(config), {
      interval,
      days: days2,
      count,
      positions
    } = recurrence, weekDays = RecurrenceDayRuleEncoder.decode(days2), hasPositions = positions && positions.length, processedDate = {};
    let { monthDays } = recurrence, counter = 0, weekDayPosition, monthStartDate, monthEndDate, dates, occurrenceDate, i;
    monthStartDate = DateHelper.startOf(count || interval > 1 ? timeSpanStart : startDate, "month");
    monthEndDate = new Date(DateHelper.getNext(monthStartDate, "month", 1) - 1);
    if (!(monthDays && monthDays.length) && !(weekDays && weekDays.length)) {
      monthDays = [timeSpanStart.getDate()];
    }
    if (weekDays && weekDays.length) {
      weekDays.forEach((day2) => {
        if (day2[1]) {
          weekDayPosition = weekDayPosition || {};
          weekDayPosition[day2[0]] = day2[1];
        }
      });
    }
    while ((!endDate || endDate > monthStartDate) && (!count || counter < count)) {
      dates = [];
      if (weekDays && weekDays.length) {
        weekDays.forEach((day2) => {
          const weekDay = day2[0];
          let from = 1, till = 53;
          if (day2[1]) {
            from = till = day2[1];
          }
          for (i = from; i <= till; i++) {
            if (occurrenceDate = this.getNthDayInPeriod(monthStartDate, monthEndDate, weekDay, i)) {
              occurrenceDate = DateHelper.copyTimeValues(occurrenceDate, timeSpanStart);
              if (!processedDate[occurrenceDate.getTime()]) {
                processedDate[occurrenceDate.getTime()] = true;
                dates.push(occurrenceDate);
              }
            }
          }
        });
        dates.sort((a, b) => a - b);
        if (!hasPositions) {
          for (i = 0; i < dates.length; i++) {
            occurrenceDate = dates[i];
            if (occurrenceDate >= timeSpanStart) {
              const inView = this.isInView(startOnly, occurrenceDate, earliestVisibleDate, durationMS, timeSpan);
              counter++;
              if (inView && (endDate && occurrenceDate >= endDate || fn2.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || count && counter >= count)) {
                return false;
              }
            }
          }
        }
      } else {
        const sortedMonthDates = [];
        for (i = 0; i < monthDays.length; i++) {
          if ((occurrenceDate = this.getNthDayOfMonth(monthStartDate, monthDays[i])) && !processedDate[occurrenceDate.getTime()]) {
            processedDate[occurrenceDate.getTime()] = true;
            sortedMonthDates.push(occurrenceDate);
          }
        }
        sortedMonthDates.sort((a, b) => a - b);
        for (i = 0; i < sortedMonthDates.length; i++) {
          occurrenceDate = DateHelper.copyTimeValues(sortedMonthDates[i], timeSpanStart);
          if (hasPositions) {
            dates.push(occurrenceDate);
          } else if (occurrenceDate >= timeSpanStart) {
            const inView = this.isInView(startOnly, occurrenceDate, earliestVisibleDate, durationMS, timeSpan);
            counter++;
            if (inView && (endDate && occurrenceDate > endDate || fn2.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || count && counter >= count)) {
              return;
            }
          }
        }
      }
      if (hasPositions && dates.length) {
        this.forEachDateAtPositions(dates, positions, (occurrenceDate2) => {
          if (occurrenceDate2 >= timeSpanStart) {
            const inView = startOnly ? occurrenceDate2 >= earliestVisibleDate : occurrenceDate2.valueOf() + durationMS > earliestVisibleDate && !timeSpan.hasException(occurrenceDate2);
            counter++;
            if (inView && (!endDate || occurrenceDate2 <= endDate) && // return false if it's time to stop recurring
            (fn2.apply(scope, [occurrenceDate2, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || count && counter >= count)) {
              return false;
            }
          }
        });
      }
      monthStartDate = DateHelper.getNext(monthStartDate, "month", interval);
      monthEndDate = new Date(DateHelper.getNext(monthStartDate, "month", 1) - 1);
    }
  }
};
__publicField(MonthlyRecurrenceIterator, "frequency", "MONTHLY");
MonthlyRecurrenceIterator._$name = "MonthlyRecurrenceIterator";

// ../Scheduler/lib/Scheduler/data/util/recurrence/YearlyRecurrenceIterator.js
var YearlyRecurrenceIterator = class extends AbstractRecurrenceIterator {
  /**
   * Iterates over the passed date range, calling the passed callback on each date on which
   * starts an event which matches the passed recurrence rule and overlaps the start and end dates.
   * @param {Object} config An object which describes how to iterate.
   * @param {Date} config.startDate The point in time to begin iteration.
   * @param {Date} config.endDate The point in time to end iteration.
   * @param {Boolean} [config.startOnly] By default, all occurrences which intersect the date range
   * will be visited. Pass `true` to only visit occurrences which *start* in the date range.
   * @param {Scheduler.model.RecurrenceModel} config.recurrence The point in time to end iteration.
   * @param {Function} config.fn The function to call for each date which matches the recurrence in the date range.
   * @param {Date} config.fn.date The occurrence date.
   * @param {Number} config.fn.counter A counter of how many dates have been visited in this iteration.
   * @param {Boolean} config.fn.isFirst A flag which is `true` if the date is the first occurrence in the specified recurrence rule.
   * @param {Array} [config.extraArgs] Extra arguments to pass to the callback after the `isFirst` argument.
   */
  static forEachDate(config) {
    const {
      startOnly,
      startDate,
      endDate,
      timeSpan,
      timeSpanStart,
      earliestVisibleDate,
      durationMS,
      spansStart,
      recurrence,
      fn: fn2,
      extraArgs,
      scope = this
    } = this.processIterationConfig(config), {
      interval,
      days: days2,
      count,
      positions
    } = recurrence, weekDays = RecurrenceDayRuleEncoder.decode(days2), hasPositions = positions && positions.length, processedDate = {};
    let { months } = recurrence, counter = 0, i, occurrenceDate, dates, yearStartDate, yearEndDate, weekDayPosition;
    yearStartDate = DateHelper.startOf(count || interval > 1 ? timeSpanStart : startDate, "year");
    yearEndDate = new Date(DateHelper.getNext(yearStartDate, "year", 1) - 1);
    months && months.sort((a, b) => a - b);
    if (!(months && months.length) && !(weekDays && weekDays.length)) {
      months = [timeSpanStart.getMonth() + 1];
    }
    if (weekDays && weekDays.length) {
      weekDays.forEach((day2) => {
        if (day2[1]) {
          weekDayPosition = weekDayPosition || {};
          weekDayPosition[day2[0]] = day2[1];
        }
      });
    }
    while ((!endDate || endDate > yearStartDate) && (!count || counter < count)) {
      dates = [];
      if (weekDays && weekDays.length) {
        weekDays.forEach((day2) => {
          const weekDay = day2[0];
          let from = 1, till = 53;
          if (day2[1]) {
            from = till = day2[1];
          }
          for (i = from; i <= till; i++) {
            if (occurrenceDate = this.getNthDayInPeriod(yearStartDate, yearEndDate, weekDay, i)) {
              occurrenceDate = DateHelper.copyTimeValues(occurrenceDate, timeSpanStart);
              if (!processedDate[occurrenceDate.getTime()]) {
                processedDate[occurrenceDate.getTime()] = true;
                dates.push(occurrenceDate);
              }
            }
          }
        });
        dates.sort((a, b) => a - b);
        if (!hasPositions) {
          for (i = 0; i < dates.length; i++) {
            occurrenceDate = dates[i];
            if (occurrenceDate >= timeSpanStart) {
              const inView = this.isInView(startOnly, occurrenceDate, earliestVisibleDate, durationMS, timeSpan);
              counter++;
              if (inView && (endDate && occurrenceDate >= endDate || fn2.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || count && counter >= count)) {
                return;
              }
            }
          }
        }
      } else {
        for (i = 0; i < months.length; i++) {
          if (occurrenceDate = this.buildDate(yearStartDate.getFullYear(), months[i] - 1, timeSpanStart.getDate())) {
            occurrenceDate = DateHelper.copyTimeValues(occurrenceDate, timeSpanStart);
            if (!processedDate[occurrenceDate.getTime()]) {
              processedDate[occurrenceDate.getTime()] = true;
              if (hasPositions) {
                dates.push(occurrenceDate);
              } else if (occurrenceDate >= timeSpanStart) {
                const inView = startOnly ? occurrenceDate >= earliestVisibleDate : occurrenceDate.valueOf() + durationMS > earliestVisibleDate && !timeSpan.hasException(occurrenceDate);
                counter++;
                if (inView && (endDate && occurrenceDate >= endDate || fn2.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || count && counter >= count)) {
                  return;
                }
              }
            }
          }
        }
      }
      if (hasPositions && dates.length) {
        this.forEachDateAtPositions(dates, positions, (occurrenceDate2) => {
          if (occurrenceDate2 >= timeSpanStart) {
            const inView = startOnly ? occurrenceDate2 >= earliestVisibleDate : occurrenceDate2.valueOf() + durationMS > earliestVisibleDate && !timeSpan.hasException(occurrenceDate2);
            counter++;
            if (inView && (!endDate || occurrenceDate2 < endDate)) {
              if (fn2.apply(scope, [occurrenceDate2, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || count && counter >= count) {
                return false;
              }
            }
          }
        });
      }
      yearStartDate = DateHelper.getNext(yearStartDate, "year", interval);
      yearEndDate = new Date(DateHelper.getNext(yearStartDate, "year", 1) - 1);
    }
  }
};
__publicField(YearlyRecurrenceIterator, "frequency", "YEARLY");
YearlyRecurrenceIterator._$name = "YearlyRecurrenceIterator";

// ../Scheduler/lib/Scheduler/model/RecurrenceModel.js
var recurrenceIterators = {};
[DailyRecurrenceIterator, WeeklyRecurrenceIterator, MonthlyRecurrenceIterator, YearlyRecurrenceIterator].forEach((it) => {
  recurrenceIterators[it.frequency] = it;
});
function convertStringOfIntegerItemsValue(value) {
  if (value) {
    if (typeof value == "string") {
      value = value.split(",").map((item) => parseInt(item, 10));
    }
  } else {
    value = null;
  }
  return value;
}
function convertStringOfItemsValue(value) {
  if (value) {
    if (typeof value == "string") {
      value = value.split(",");
    }
  } else {
    value = null;
  }
  return value;
}
function isEqualAsString(value1, value2) {
  return String(value1) === String(value2);
}
function convertInteger(value) {
  if (this.defaultValue && value === void 0) {
    return this.defaultValue;
  }
  if (this.allowNull && value == null) {
    return null;
  }
  value = parseInt(value);
  return isNaN(value) ? void 0 : value;
}
var RecurrenceModel = class extends Model {
  static get $name() {
    return "RecurrenceModel";
  }
  /**
   * Indicates that this is a `RecurrenceModel` class instance
   * (allows to avoid using `instanceof`).
   * @property {Boolean}
   * @readonly
   */
  get isRecurrenceModel() {
    return true;
  }
  //region Fields
  static get fields() {
    return [
      /**
       * Field defines the recurrence frequency. Supported values are: `DAILY`, `WEEKLY`, `MONTHLY`, `YEARLY`.
       * @field {'DAILY'|'WEEKLY'|'MONTHLY'|'YEARLY'} frequency
       */
      { name: "frequency", defaultValue: "DAILY" },
      /**
       * Field defines how often the recurrence repeats.
       * For example, if the recurrence is weekly its interval is 2, then the timespan repeats every two weeks.
       * @field {Number} interval
       */
      { name: "interval", defaultValue: 1, convert: convertInteger },
      /**
       * End date of the recurrence. Specifies when the recurrence ends.
       * The value is optional, the recurrence can as well be stopped using {@link #field-count} field value.
       * @field {Date} endDate
       */
      { name: "endDate", type: "date" },
      /**
       * Specifies the number of occurrences after which the recurrence ends.
       * The value includes the associated timespan itself so values less than 2 make no sense.
       * The field is optional, the recurrence as well can be stopped using {@link #field-endDate} field value.
       * @field {Number} count
       */
      { name: "count", allowNull: true, convert: convertInteger },
      /**
       * Specifies days of the week on which the timespan should occur.
       * An array of string values `SU`, `MO`, `TU`, `WE`, `TH`, `FR`, `SA`
       * corresponding to Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, and Saturday days of the week.
       * Each value can also be preceded by a positive (+n) or negative (-n) integer.
       * If present, this indicates the nth occurrence of a specific day within the monthly or yearly recurrence.
       *
       * **Not applicable** for daily {@link #field-frequency}.
       * @field {String[]} days
       */
      {
        name: "days",
        convert: convertStringOfItemsValue,
        isEqual: isEqualAsString
      },
      /**
       * Specifies days of the month on which the timespan should occur.
       * An array of integer values (-31..-1 - +1..+31, negative values mean counting backwards from the month end).
       * **Applicable only** for monthly {@link #field-frequency}.
       * @field {Number[]} monthDays
       */
      {
        name: "monthDays",
        convert: convertStringOfIntegerItemsValue,
        isEqual: isEqualAsString
      },
      /**
       * Specifies months of the year on which the timespan should occur.
       * An array of integer values (1 - 12).
       * **Applicable only** for yearly {@link #field-frequency}.
       * @field {Number[]} months
       */
      {
        name: "months",
        convert: convertStringOfIntegerItemsValue,
        isEqual: isEqualAsString
      },
      /**
       * The positions to include in the recurrence. The values operate on a set of recurrence instances **in one interval** of the recurrence rule.
       * An array of integer values (valid values are 1 to 366 or -366 to -1, negative values mean counting backwards from the end of the built list of occurrences).
       * **Not applicable** for daily {@link #field-frequency}.
       * @field {Number} positions
       */
      {
        name: "positions",
        convert: convertStringOfIntegerItemsValue,
        isEqual: isEqualAsString
      }
    ];
  }
  get dateFormat() {
    return this._dateFormat || "YYYYMMDDTHHmmss";
  }
  set dateFormat(format2) {
    this._dateFormat = format2;
  }
  get recurrenceIterator() {
    return recurrenceIterators[this.frequency];
  }
  /**
   * The timespan this recurrence is associated with.
   * @property {Scheduler.model.TimeSpan}
   */
  get timeSpan() {
    return this._timeSpan;
  }
  set timeSpan(value) {
    this._timeSpan = value;
  }
  /**
   * The recurrence rule. A string in [RFC-5545](https://tools.ietf.org/html/rfc5545#section-3.3.10) described format
   * ("RRULE" expression).
   * @property {String}
   */
  get rule() {
    const me = this, result = [];
    if (me.frequency) {
      result.push(`FREQ=${me.frequency}`);
      if (me.interval > 1) {
        result.push(`INTERVAL=${me.interval}`);
      }
      if (me.days && me.days.length) {
        result.push("BYDAY=" + me.days.join(","));
      }
      if (me.monthDays && me.monthDays.length) {
        result.push("BYMONTHDAY=" + me.monthDays.join(","));
      }
      if (me.months && me.months.length) {
        result.push("BYMONTH=" + me.months.join(","));
      }
      if (me.count) {
        result.push(`COUNT=${me.count}`);
      }
      if (me.endDate) {
        result.push("UNTIL=" + DateHelper.format(me.endDate, me.dateFormat));
      }
      if (me.positions && me.positions.length) {
        result.push("BYSETPOS=" + me.positions.join(","));
      }
    }
    return result.join(";");
  }
  set rule(rule) {
    const me = this, values = {
      frequency: null,
      interval: null,
      count: null,
      endDate: null,
      days: null,
      monthDays: null,
      months: null,
      positions: null
    };
    me.beginBatch();
    if (rule) {
      const parts = rule.split(";");
      for (let i = 0, len = parts.length; i < len; i++) {
        const part = parts[i].split("="), value = part[1];
        switch (part[0]) {
          case "FREQ":
            values.frequency = value;
            break;
          case "INTERVAL":
            values.interval = value;
            break;
          case "COUNT":
            values.count = value;
            values.until = null;
            break;
          case "UNTIL":
            if (value) {
              values.endDate = DateHelper.parse(value, me.dateFormat);
            } else {
              values.endDate = null;
            }
            values.count = null;
            break;
          case "BYDAY":
            values.days = value;
            break;
          case "BYMONTHDAY":
            values.monthDays = value;
            break;
          case "BYMONTH":
            values.months = value;
            break;
          case "BYSETPOS":
            values.positions = value;
            break;
        }
      }
    }
    me.set(values);
    if (rule) {
      me.sanitize();
    }
    me.endBatch();
  }
  construct(data = {}) {
    const me = this, { rule, timeSpan } = data;
    me._suspendedTimeSpanNotifying = 0;
    delete data.timeSpan;
    delete data.rule;
    super.construct(...arguments);
    if (rule) {
      me.suspendTimeSpanNotifying();
      me.rule = rule;
      me.resumeTimeSpanNotifying();
    }
    me.timeSpan = timeSpan;
  }
  /**
   * Iterate occurrences for the owning timespan across the specified date range. This method can be called even
   * if the timespan is not yet a member of a store, however, the occurrences returned will not be cached across
   * subsequent calls to this method.
   * @param {Date} startDate The start date of the iteration.
   * @param {Date} endDate The end date of the iteration.
   * @param {Function} fn The function to call for each occurrence.
   * @param {Scheduler.model.TimeSpan} fn.occurrence The occurrence.
   * @param {Boolean} fn.first A flag which is `true` for the first occurrence of this recurrence.
   * @param {Number} fn.counter A counter of how many dates have been visited in this iteration.
   * @param {Date} fn.date The occurrence date.
   * @internal
   */
  forEachOccurrence(startDate, endDate, fn2) {
    if (this.timeSpan.startDate) {
      this.recurrenceIterator.forEachDate({
        recurrence: this,
        startDate,
        endDate,
        fn(date, counter, first, timeSpan) {
          return fn2(timeSpan.buildOccurrence(date, first), first, counter, date);
        }
      });
    }
  }
  /**
   * Cleans up fields that do not makes sense for the current {@link #field-frequency} value.
   * @private
   */
  sanitize() {
    var _a2, _b;
    const me = this, timeSpanStartDate = (_a2 = me.timeSpan) == null ? void 0 : _a2.startDate, values = {};
    me.isSanitizing = true;
    switch (me.frequency) {
      case "DAILY":
        values.positions = null;
        values.days = null;
        values.monthDays = null;
        values.months = null;
        break;
      case "WEEKLY": {
        values.positions = null;
        values.monthDays = null;
        values.months = null;
        const { days: days2 } = me;
        if (timeSpanStartDate && (days2 == null ? void 0 : days2.length) === 1 && days2[0] === RecurrenceDayRuleEncoder.encodeDay(timeSpanStartDate.getDay())) {
          values.days = null;
        }
        break;
      }
      case "MONTHLY": {
        if ((_b = me.monthDays) == null ? void 0 : _b.length) {
          values.positions = null;
          values.days = null;
        }
        values.months = null;
        const { monthDays } = me;
        if (timeSpanStartDate && (monthDays == null ? void 0 : monthDays.length) === 1 && monthDays[0] === timeSpanStartDate.getDate()) {
          values.monthDays = null;
        }
        break;
      }
      case "YEARLY": {
        values.monthDays = null;
        const { months } = me;
        if (timeSpanStartDate && (months == null ? void 0 : months.length) === 1 && months[0] === timeSpanStartDate.getMonth() + 1) {
          values.months = null;
        }
        break;
      }
    }
    me.set(values);
    me.isSanitizing = false;
  }
  copy(...args) {
    const result = super.copy(...args);
    result.dateFormat = this.dateFormat;
    result.timeSpan = this.timeSpan;
    return result;
  }
  afterChange(toSet, wasSet, silent) {
    const result = super.afterChange(toSet, wasSet, silent), { timeSpan } = this;
    if (!this.isSanitizing) {
      this.sanitize();
    }
    if (timeSpan) {
      timeSpan.sanitizeRecurrenceData(this);
      if (!this.isTimeSpanNotifyingSuspended) {
        timeSpan.onRecurrenceChanged();
      }
    }
    return result;
  }
  set(field2, value, ...args) {
    const values = typeof field2 === "object" ? field2 : { [field2]: value };
    if (values.count) {
      values.endDate = null;
    } else if (values.endDate) {
      values.count = null;
    }
    super.set(values, void 0, ...args);
  }
  get isTimeSpanNotifyingSuspended() {
    return Boolean(this._suspendedTimeSpanNotifying);
  }
  suspendTimeSpanNotifying() {
    this._suspendedTimeSpanNotifying++;
  }
  resumeTimeSpanNotifying() {
    if (this._suspendedTimeSpanNotifying)
      this._suspendedTimeSpanNotifying--;
  }
};
RecurrenceModel._$name = "RecurrenceModel";

// ../Scheduler/lib/Scheduler/model/mixin/RecurringTimeSpan.js
function convertExceptionDatesValue(value) {
  const result = {}, { dateFormat } = this;
  if (value) {
    value = typeof value == "string" ? value.split(",") : ArrayHelper.asArray(value);
    value.forEach((item) => {
      if (typeof item == "string") {
        item = DateHelper.parse(item, dateFormat);
      }
      if (!isNaN(item)) {
        result[DateHelper.makeKey(item)] = 1;
      }
    });
  }
  return result;
}
function serializeExceptionDatesValue(value) {
  const result = [], { dateFormat } = this;
  for (const date in value) {
    if (value[date]) {
      result.push(DateHelper.format(DateHelper.parseKey(date), dateFormat));
    }
  }
  return result;
}
var emptyArray4 = [];
var RecurringTimeSpan_default = (Target) => class RecurringTimeSpan extends (Target || TimeSpan) {
  static get $name() {
    return "RecurringTimeSpan";
  }
  /**
   * Returns `true` if this timespan supports recurring.
   * @property {Boolean}
   * @category Recurrence
   */
  get supportsRecurring() {
    return true;
  }
  static get fields() {
    return [
      /**
       * The timespan recurrence rule. A string in [RFC-5545](https://tools.ietf.org/html/rfc5545#section-3.3.10)
       * described format ("RRULE" expression).
       * @field {String} recurrenceRule
       * @category Scheduling
       */
      {
        name: "recurrenceRule",
        internal: true
      },
      /**
       * A string (either a single date or multiple dates separated by comma) or an array of strings containing
       * the timespan exception dates. The dates that must be skipped when generating occurrences for a repeating
       * timespan. This is used to modify only individual occurrences of the timespan so the further regenerations
       * won't create another copy of this occurrence again.
       *
       * ```javascript
       * {
       *     id: 7,
       *     startDate: '2021-10-12T14:00:00',
       *     endDate: '2021-10-12T15:00:00',
       *     name: 'Lunch',
       *     resourceId: 'hotel',
       *     recurrenceRule: 'FREQ=DAILY;COUNT=5',
       *     exceptionDates: ['2021-10-14']
       * }
       * ```
       *
       * Use {@link #function-addExceptionDate} method to add an individual entry to the dates array:
       *
       * ```javascript
       * // Break the link between the occurrence and its base.
       * // This also adds the occurrence date as an exception date
       * // so that the base timespan knows that this date should be skipped when regenerating its occurrences.
       * occurrence.recurringTimeSpan = null;
       *
       * // now the occurrence is an individual record that can be changed & persisted freely
       * occurrence.setStartEndDate(new Date(2018, 6, 2), new Date(2018, 6, 3));
       * ```
       * **Note:** The dates in this field get automatically removed when the event changes its {@link Scheduler.model.TimeSpan#field-startDate start date}.
       *
       * @field {String|String[]} exceptionDates
       * @category Scheduling
       */
      {
        name: "exceptionDates",
        convert: convertExceptionDatesValue,
        serialize: serializeExceptionDatesValue,
        internal: true
      }
    ];
  }
  /**
   * Override of {@link Core/data/Model}'s method. If an {@link #property-isOccurrence}
   * is passed, it is detached from its parent recurring event. If it still has a recurrence
   * then the recurring event is changed to stop at the occurrence date. If it has no recurrence
   * an exception is added at the occurrence date.
   * @category Recurrence
   */
  remove() {
    if (this.isOccurrence) {
      const me = this, { recurringTimeSpan } = me;
      me.cancelBatch();
      recurringTimeSpan.beginBatch();
      me.detachFromRecurringEvent();
      recurringTimeSpan.endBatch();
    } else {
      return super.remove(...arguments);
    }
  }
  get eventStore() {
    var _a2;
    let result = this.isOccurrence ? this.recurringEvent.eventStore : super.eventStore;
    if (!result && ((_a2 = this.firstStore) == null ? void 0 : _a2.isRecurringTimeSpansMixin)) {
      result = this.firstStore;
    }
    return result;
  }
  /**
   * Name of the class representing the recurrence model, defaults to {@link Scheduler.model.RecurrenceModel}
   * @property {String}
   * @category Recurrence
   */
  get recurrenceModel() {
    return this._recurrenceModel || RecurrenceModel;
  }
  set recurrenceModel(model) {
    this._recurrenceModel = model;
  }
  /**
   * Sets a recurrence for the timespan with a given frequency, interval, and end.
   * @param {RecurrenceModelConfig|String|Scheduler.model.RecurrenceModel} recurrence A data object for an instance of
   * {@link Scheduler.model.RecurrenceModel}. May also be the frequency string: `DAILY`, `WEEKLY`, `MONTHLY`, or
   * `YEARLY`.
   *
   * ```javascript
   * // repeat the event every other week till Jan 2 2039
   * event.setRecurrence({
   *     frequency : "WEEKLY",
   *     interval  : 2,
   *     endDate   : new Date(2039, 0, 2)
   * });
   * ```
   *
   * Also a {@link Scheduler.model.RecurrenceModel recurrence model} can be provided as the only argument for this
   * method:
   *
   * ```javascript
   * const recurrence = new RecurrenceModel({ frequency : 'DAILY', interval : 5 });
   *
   * event.setRecurrence(recurrence);
   * ```
   *
   * or
   *
   * ```javascript
   * event.setRecurrence("WEEKLY", 2, new Date(2039, 0, 2));
   * ```
   * @param {Number} [interval] The interval between occurrences (instances of this recurrence). For example, a daily
   * recurrence with an interval of 2 occurs every other day. Must be greater than 0.
   * @param {Number|Date} [recurrenceEnd] The end of the recurrence. The value can be specified by a date or by a
   * maximum count of occurrences (has to greater than 1, since 1 means the event itself).
   * @category Recurrence
   */
  setRecurrence(recurrence, interval, recurrenceEnd) {
    const me = this;
    let recurrenceRule;
    if (recurrence) {
      if (!recurrence.isRecurrenceModel) {
        if (typeof recurrence === "string") {
          recurrence = {
            frequency: recurrence
          };
          if (interval) {
            recurrence.interval = interval;
          }
          if (recurrenceEnd) {
            if (recurrenceEnd instanceof Date) {
              recurrence.endDate = recurrenceEnd;
            } else {
              recurrence.count = recurrenceEnd;
            }
          }
        }
        recurrence = new me.recurrenceModel(recurrence);
      }
      recurrence.timeSpan = me;
      recurrenceRule = recurrence.rule;
    }
    me.recurrence = recurrence;
    me.recurrenceRule = recurrenceRule;
  }
  /**
   * The recurrence model used for the timespan.
   * @property {Scheduler.model.RecurrenceModel}
   * @category Recurrence
   */
  get recurrence() {
    const me = this, rule = me.recurrenceRule;
    if (!me._recurrence && rule) {
      me._recurrence = new me.recurrenceModel({ rule, timeSpan: me, id: `${me.id}-recurrence` });
    }
    return me._recurrence;
  }
  set recurrence(recurrence) {
    const me = this;
    me._recurrence = recurrence;
    if (recurrence) {
      recurrence.timeSpan = me;
      me.recurrenceRule = recurrence.rule;
    } else {
      if (me.isOccurrence) {
        me.setData("recurrenceRule", null);
      } else {
        me.recurrenceRule = null;
      }
    }
  }
  /**
   * Indicates if the timespan is recurring.
   * @property {Boolean}
   * @readonly
   * @category Recurrence
   */
  get isRecurring() {
    return Boolean(!this.isOccurrence && this.recurrence);
  }
  /**
   * Indicates if the timespan is an occurrence of another recurring timespan.
   * @property {Boolean}
   * @readonly
   * @category Recurrence
   */
  get isOccurrence() {
    return Boolean(this.recurringTimeSpan);
  }
  /**
   * The "main" timespan this model is an occurrence of. For non-occurrences returns `null`.
   * @property {Scheduler.model.TimeSpan}
   * @readonly
   * @internal
   * @category Recurrence
   */
  get recurringTimeSpan() {
    return this._recurringTimeSpan;
  }
  get isPersistable() {
    return super.isPersistable && (!this.supportsRecurring || !this.isOccurrence);
  }
  set recurringTimeSpan(recurringTimeSpan) {
    this._recurringTimeSpan = recurringTimeSpan;
  }
  /**
   * Returns the occurrences of this event over the specified time range. If the first
   * occurrence is in the time range `*this*` record is included in that position.
   * @param {Date} startDate The start date of the range for which to include occurrences.
   * @param {Date} [endDate] The end date of the range for which to include occurrences.
   * Defaults to the startDate.
   * @returns {Scheduler.model.TimeSpan[]} The array of occurrences which occur over the specified range.
   * @category Recurrence
   */
  getOccurrencesForDateRange(startDate, endDate = startDate) {
    return this.eventStore.getOccurrencesForTimeSpan(this, startDate, endDate);
  }
  /**
   * Array of this recurring timespan's cached occurrences. __Not including the owning recurring
   * event__.
   *
   * Empty if the timespan is not recurring.
   *
   * __Note that this is an internal accessor and is cleared whenever changes are made to the
   * owning recurring event__.
   * @property {Scheduler.model.TimeSpan[]}
   * @readonly
   * @internal
   * @category Recurrence
   */
  get occurrences() {
    if (this.isRecurring) {
      const result = [];
      this.occurrenceMap.forEach((occurrence) => {
        if (occurrence !== this) {
          result.push(occurrence);
        }
      });
      return result;
    }
    return emptyArray4;
  }
  /**
   * A Map, keyed by each date an occurrence intersects, of occurrences of this event.
   * @property {Map}
   * @readonly
   * @internal
   * @category Recurrence
   */
  get occurrenceMap() {
    return this._occurrencesMap || (this._occurrencesMap = /* @__PURE__ */ new Map());
  }
  /**
   * Removes an occurrence from this recurring timespan's cached occurrences.
   * @param dateOrTimeSpan occurrence date or occurrence TimeSpan
   * @internal
   * @category Recurrence
   */
  removeOccurrence(dateOrTimeSpan) {
    var _a2;
    const date = dateOrTimeSpan.isTimeSpan ? dateOrTimeSpan.occurrenceDate : dateOrTimeSpan;
    (_a2 = this.eventStore) == null ? void 0 : _a2.globalOccurrences.delete(this.createRecurrenceKey(date));
    this.occurrenceMap.delete(DateHelper.makeKey(date));
  }
  /**
   * Removes all cached occurrences on or after the passed date from this recurring timespan's cached occurrences.
   * @internal
   * @category Recurrence
   */
  removeOccurrencesFrom(date) {
    this.occurrenceMap.forEach((occurrence, dateKey) => {
      if (DateHelper.parseKey(dateKey) >= date) {
        this.removeOccurrence(occurrence);
      }
    });
  }
  /**
   * Removes this recurring timespan's cached occurrences.
   * @internal
   * @category Recurrence
   */
  removeOccurrences() {
    [this, ...this.occurrences].forEach((occurrence) => this.removeOccurrence(occurrence));
  }
  /**
   * The method is triggered when the timespan recurrence settings get changed.
   * It updates the {@link #field-recurrenceRule} field in this case.
   * @internal
   * @category Recurrence
   */
  onRecurrenceChanged() {
    var _a2;
    this.recurrenceRule = ((_a2 = this.recurrence) == null ? void 0 : _a2.rule) || null;
  }
  sanitizeRecurrenceData(recurrence = this.recurrence) {
    if (recurrence.endDate) {
      const endDate = DateHelper.clearTime(recurrence.endDate), { exceptionDates } = this;
      this.removeOccurrencesFrom(endDate);
      if (exceptionDates) {
        for (const dateKey in exceptionDates) {
          const exceptionDate = DateHelper.parseKey(dateKey);
          if (exceptionDate >= endDate) {
            delete exceptionDates[dateKey];
          }
        }
      }
    }
  }
  /**
   * The original {@lScheduler.model.TimeSpan#field-startDate startDate} of this event before any modifications
   * took place. Used by {@link #function-removeOccurrence} and {@link #function-detachFromRecurringEvent}
   * @internal
   * @readonly
   * @category Recurrence
   */
  get occurrenceDate() {
    var _a2;
    return ((_a2 = this.meta.modified) == null ? void 0 : _a2.startDate) || this.startDate;
  }
  /**
   * If this event is an {@link #property-isOccurrence occurrence} of a recurring event, then this
   * property yields its zero-based occurrence index in the sequence.
   * @property {Number}
   * @readonly
   * @category Recurrence
   */
  get occurrenceIndex() {
    return AbstractRecurrenceIterator.getOccurrenceIndex(this);
  }
  /**
   * Builds an occurrence of this recurring event by cloning the timespan data.
   * The method is used internally by the __RecurringTimeSpans__ mixin.
   * Override it if you need to customize the generated occurrences.
   *
   * If the date requested is the start date of the event sequence, `this`
   * record is returned. All runs of recurring events begin with the base record.
   * @param  {Date} occurrenceDate The occurrence start date.
   * @param  {Boolean} isFirst `true` if this is the first occurrence.
   * @returns {Scheduler.model.TimeSpan} The occurrence.
   * @internal
   * @category Recurrence
   */
  buildOccurrence(occurrenceDate, isFirst) {
    var _a2;
    const me = this, {
      occurrenceMap,
      recurrence,
      meta
    } = me, globalOccurrences = (_a2 = me.eventStore) == null ? void 0 : _a2.globalOccurrences, occurrenceKey = DateHelper.makeKey(occurrenceDate), id = me.createRecurrenceKey(occurrenceDate, occurrenceKey), onStartDate = !(occurrenceDate - me.startDate), { fieldMap } = me.constructor;
    let occurrence = globalOccurrences == null ? void 0 : globalOccurrences.get(id), { duration } = me;
    if (me.endDate && (me.allDay || !duration)) {
      duration = DateHelper.as(me.durationUnit, me.endDate.getTime() - me.startDate.getTime());
    }
    const occurrenceEndDate = duration !== void 0 ? DateHelper.add(occurrenceDate, duration, me.durationUnit) : void 0;
    if (!occurrence) {
      if (isFirst || onStartDate) {
        occurrence = me;
        if (!onStartDate) {
          me.setStartEndDate(occurrenceDate, occurrenceEndDate, true);
          recurrence.suspendTimeSpanNotifying();
          recurrence.sanitize();
          recurrence.resumeTimeSpanNotifying();
        }
        meta.isSyncedWithRule = true;
      } else {
        occurrence = me.copy(
          {
            [fieldMap.id.dataSource]: id,
            [fieldMap.startDate.dataSource]: occurrenceDate,
            [fieldMap.endDate.dataSource]: occurrenceEndDate,
            [fieldMap.duration.dataSource]: duration,
            constraintDate: null,
            constraintType: null
          },
          { creatingOccurrence: true }
        );
        occurrence.recurringTimeSpan = me;
      }
      globalOccurrences == null ? void 0 : globalOccurrences.set(id, occurrence);
      occurrenceMap.set(occurrenceKey, occurrence);
    }
    return occurrence;
  }
  createRecurrenceKey(date = this.startDate, dateKey = null) {
    return `_generated:${this.id}:${dateKey || DateHelper.makeKey(date)}`;
  }
  // Converts this occurrence to a new "master" event
  convertToRealEvent(wasSet, silent) {
    var _a2;
    if (!this.isOccurrence) {
      return;
    }
    const me = this, {
      recurringTimeSpan,
      resource,
      occurrenceIndex,
      recurrence
    } = me, count = recurrence && recurringTimeSpan.recurrence.count, newResource = ((_a2 = wasSet == null ? void 0 : wasSet.resourceRecords) == null ? void 0 : _a2.value) || me.data.newResource;
    recurringTimeSpan.beginBatch();
    me.detachFromRecurringEvent();
    me.clearChanges();
    me.setData("id", me.generateId(recurringTimeSpan.eventStore));
    if (newResource) {
      delete me.data.resourceId;
    }
    recurringTimeSpan.eventStore.add(me, silent);
    if (count) {
      me.recurrence.count = count - occurrenceIndex;
    }
    if (newResource || resource) {
      me.assign(newResource || resource);
    }
    if (newResource) {
      delete me.data.resourceRecords;
    }
    if (wasSet) {
      delete wasSet.resourceRecords;
    }
    recurringTimeSpan.endBatch();
  }
  afterChange(toSet, wasSet, silent, ...args) {
    const me = this, { eventStore } = me;
    if ("recurrenceRule" in wasSet) {
      me._recurrence = null;
      eventStore == null ? void 0 : eventStore.recurringEvents[wasSet.recurrenceRule.value ? "add" : "delete"](me);
    }
    if (me.isOccurrence) {
      me.convertToRealEvent(wasSet, silent);
    } else if ("newExceptionDate" in wasSet) {
      me.meta.modified.exceptionDates = true;
      delete me.meta.modified.newExceptionDate;
      me.removeOccurrence(wasSet.newExceptionDate.value);
    }
    return super.afterChange(toSet, wasSet, silent, ...args);
  }
  /**
   * Detaches an occurrence from its owning recurring event so that it can be added to the eventStore
   * either as an exception, or as the start of a new recurring sequence.
   * @internal
   * @category Recurrence
   */
  detachFromRecurringEvent() {
    const me = this, { recurringTimeSpan, occurrenceDate, startDate } = me;
    me.recurringTimeSpan = null;
    recurringTimeSpan.addExceptionDate(occurrenceDate);
    if (me.recurrenceRule) {
      recurringTimeSpan.recurrence.endDate = DateHelper.add(startDate, -1, "minute");
    }
  }
  /**
   * The setter used by Model#inSet when {@link #function-addExceptionDate} is called.
   * Adding an exception must trigger change processing in a recurring event, so it must
   * be changed through a {@link Core.data.Model#function-set} call. Also, the change must be batchable
   * with other changes.
   * @private
   * @readonly
   * @category Recurrence
   */
  set newExceptionDate(date) {
    if (date) {
      const exceptionDates = this.exceptionDates || (this.exceptionDates = {});
      exceptionDates[DateHelper.makeKey(date)] = 1;
    }
  }
  /**
   * Adds an exception date that should be skipped when generating occurrences for the timespan.
   * The methods adds an entry to the array kept in {@link #field-exceptionDates} field.
   * @param {Date} date Exception date.
   * @internal
   * @category Recurrence
   */
  addExceptionDate(newExceptionDate) {
    return this.set({
      newExceptionDate
    });
  }
  /**
   * Does this recurring event have an exception on the passed date.
   * @param {Date} date The date to find an exception for.
   * @returns {Boolean} `true` if the event has an exception starting on the passed date.
   * @category Recurrence
   */
  hasException(date) {
    var _a2;
    return (_a2 = this.exceptionDates) == null ? void 0 : _a2[DateHelper.makeKey(date)];
  }
};

// ../Scheduler/lib/Scheduler/model/ResourceTimeRangeModel.js
var ResourceTimeRangeModel = class extends TimeSpan.mixin(RecurringTimeSpan_default) {
  get domId() {
    return `${this.constructor.domIdPrefix}-${this.id}`;
  }
  //endregion
  // Used internally to differentiate between Event and ResourceTimeRange
  get isResourceTimeRange() {
    return true;
  }
  // To match EventModel API
  get resources() {
    return this.resource ? [this.resource] : [];
  }
  // To match EventModel API
  get $linkedResources() {
    return this.resources;
  }
};
__publicField(ResourceTimeRangeModel, "$name", "ResourceTimeRangeModel");
//region Fields
__publicField(ResourceTimeRangeModel, "fields", [
  /**
   * Id of the resource this time range is associated with
   * @field {String|Number} resourceId
   */
  "resourceId",
  /**
   * Controls this time ranges primary color, defaults to using current themes default time range color.
   * @field {String} timeRangeColor
   */
  "timeRangeColor"
]);
__publicField(ResourceTimeRangeModel, "relations", {
  /**
   * The associated resource, retrieved using a relation to a ResourceStore determined by the value assigned
   * to `resourceId`. The relation also lets you access all time ranges on a resource through
   * `ResourceModel#timeRanges`.
   * @member {Scheduler.model.ResourceModel} resource
   */
  resource: {
    foreignKey: "resourceId",
    foreignStore: "resourceStore",
    relatedCollectionName: "timeRanges",
    nullFieldOnRemove: true
  }
});
__publicField(ResourceTimeRangeModel, "domIdPrefix", "resourcetimerange");
ResourceTimeRangeModel._$name = "ResourceTimeRangeModel";

// ../Scheduler/lib/Scheduler/data/mixin/RecurringTimeSpansMixin.js
var emptyArray5 = Object.freeze([]);
var RecurringTimeSpansMixin_default = (Target) => class RecurringTimeSpansMixin extends (Target || Base2) {
  static get $name() {
    return "RecurringTimeSpansMixin";
  }
  construct(...args) {
    const me = this;
    me.globalOccurrences = /* @__PURE__ */ new Map();
    me.recurringEvents = /* @__PURE__ */ new Set();
    super.construct(...args);
  }
  // Override to refreshRecurringEventsCache on initial load
  afterLoadData() {
    this.globalOccurrences.clear();
    this.refreshRecurringEventsCache("clear");
    this.refreshRecurringEventsCache("splice", this.storage.allValues);
    super.afterLoadData && super.afterLoadData();
  }
  /**
   * Responds to mutations of the underlying storage Collection.
   *
   * Maintain indices for fast finding of events by date.
   * @param {Object} event
   * @private
   */
  onDataChange({ action, added, removed, replaced }) {
    this.refreshRecurringEventsCache(action, added, removed, replaced);
    super.onDataChange(...arguments);
  }
  refreshRecurringEventsCache(action, added = emptyArray5, removed = emptyArray5, replaced) {
    const me = this, { recurringEvents } = me, replacedCount = replaced == null ? void 0 : replaced.length;
    switch (action) {
      case "clear":
        recurringEvents.clear();
        break;
      case "splice": {
        if (replacedCount) {
          added = added.slice();
          removed = removed.slice();
          for (let i = 0; i < replacedCount; i++) {
            removed.push(replaced[i][0]);
            added.push(replaced[i][1]);
          }
        }
        const addedCount = added.length, removedCount = removed.length;
        if (removedCount && recurringEvents.size) {
          for (let i = 0; i < removedCount; i++) {
            recurringEvents.delete(removed[i]);
          }
        }
        if (addedCount) {
          for (let i = 0; i < addedCount; i++) {
            const newEvent = added[i];
            if (newEvent.isRecurring) {
              recurringEvents.add(newEvent);
            }
          }
        }
        break;
      }
    }
  }
  getById(id) {
    let result = super.getById(id);
    if (!result) {
      result = this.globalOccurrences.get(this.modelClass.asId(id));
    }
    return result;
  }
  onModelChange(record, toSet, wasSet, silent, fromRelationUpdate) {
    const isRecurrenceRelatedFieldChange = !silent && this.isRecurrenceRelatedFieldChange(record, wasSet);
    if (isRecurrenceRelatedFieldChange) {
      record.removeOccurrences();
    }
    super.onModelChange(...arguments);
    if (isRecurrenceRelatedFieldChange) {
      const event = { action: "batch", records: this.storage.values };
      this.trigger("refresh", event);
      this.trigger("change", event);
    }
  }
  /**
   * The method restricts which field modifications should trigger timespan occurrences building.
   * By default, any field change of a recurring timespan causes the rebuilding.
   * @param  {Scheduler.model.TimeSpan} timeSpan The modified timespan.
   * @param  {Object} wasSet Object containing the change set.
   * @returns {Boolean} `True` if the fields modification should trigger the timespan occurrences rebuilding.
   * @internal
   * @category Recurrence
   */
  isRecurrenceRelatedFieldChange(timeSpan, wasSet) {
    return timeSpan.isRecurring || "recurrenceRule" in wasSet;
  }
  /**
   * Builds occurrences for the provided timespan across the provided date range.
   * @private
   * @category Recurrence
   */
  getOccurrencesForTimeSpan(timeSpan, startDate, endDate) {
    const result = [];
    if (timeSpan.isRecurring) {
      timeSpan.recurrence.forEachOccurrence(startDate, endDate, (r) => result.push(r));
    }
    return result;
  }
  set data(data) {
    this.globalOccurrences.clear();
    super.data = data;
  }
  /**
   * Returns all the recurring timespans.
   * @returns {Scheduler.model.TimeSpan[]} Array of recurring events.
   * @category Recurrence
   */
  getRecurringTimeSpans() {
    return [...this.recurringEvents];
  }
};

// ../Scheduler/lib/Scheduler/data/ResourceTimeRangeStore.js
var ResourceTimeRangeStore = class extends AjaxStore.mixin(RecurringTimeSpansMixin_default) {
  static get defaultConfig() {
    return {
      /**
       * CrudManager must load stores in the correct order. Lowest first.
       * @private
       */
      loadPriority: 500,
      /**
       * CrudManager must sync stores in the correct order. Lowest first.
       * @private
       */
      syncPriority: 500,
      /**
       * This store should be linked to a ResourceStore to link the time ranges to resources
       * @config {Scheduler.data.ResourceStore}
       */
      resourceStore: null,
      modelClass: ResourceTimeRangeModel,
      storeId: "resourceTimeRanges"
    };
  }
  set resourceStore(store) {
    this._resourceStore = store;
    if (!this.isConfiguring) {
      this.initRelations(true);
    }
  }
  get resourceStore() {
    return this._resourceStore;
  }
  // Matching signature in EventStore to allow reusage of SchedulerStores#onInternalEventStoreChange()
  getResourcesForEvent(resourceTimeRange) {
    return [resourceTimeRange.resource];
  }
  /**
   * Get resource time ranges intersecting the specified date range for a resource.
   *
   * The result is sorted by `startDate`.
   *
   * @param {Object} options Options
   * @param {Scheduler.model.ResourceModel} options.resourceRecord Resource record
   * @param {Date} options.startDate Start date of the range
   * @param {Date} options.endDate End date of the range
   * @returns {Scheduler.model.ResourceTimeRangeModel[]}
   */
  getRanges({ resourceRecord, startDate, endDate }) {
    const rangesInDateRange = resourceRecord.timeRanges.flatMap((range) => {
      if (range.supportsRecurring) {
        return range.getOccurrencesForDateRange(startDate, endDate);
      }
      if (range.intersectsRange(startDate, endDate)) {
        return range;
      }
      return [];
    });
    return rangesInDateRange.sort((span1, span2) => span1.startDate - span2.startDate);
  }
};
__publicField(ResourceTimeRangeStore, "$name", "ResourceTimeRangeStore");
ResourceTimeRangeStore._$name = "ResourceTimeRangeStore";

// ../Scheduler/lib/Scheduler/data/mixin/PartOfProject.js
var PartOfProject_default = (Target) => class PartOfProject extends (Target || Base2) {
  /**
   * Returns the project this entity belongs to.
   *
   * @member {Scheduler.model.ProjectModel} project
   * @readonly
   * @category Project
   */
  /**
   * Returns the event store of the project this entity belongs to.
   *
   * @member {Scheduler.data.EventStore} eventStore
   * @readonly
   * @category Project
   */
  /**
   * Returns the dependency store of the project this entity belongs to.
   *
   * @member {Scheduler.data.DependencyStore} dependencyStore
   * @readonly
   * @category Project
   */
  /**
   * Returns the assignment store of the project this entity belongs to.
   *
   * @member {Scheduler.data.AssignmentStore} assignmentStore
   * @readonly
   * @category Project
   */
  /**
   * Returns the resource store of the project this entity belongs to.
   *
   * @member {Scheduler.data.ResourceStore} resourceStore
   * @readonly
   * @category Project
   */
  static get $name() {
    return "PartOfProject";
  }
};

// ../Scheduler/lib/Scheduler/model/mixin/AssignmentModelMixin.js
var AssignmentModelMixin_default = (Target) => class AssignmentModelMixin extends Target {
  static get $name() {
    return "AssignmentModelMixin";
  }
  /**
   * Set value for the specified field(s), triggering engine calculations immediately. See
   * {@link Core.data.Model#function-set Model#set()} for arguments.
   *
   * ```javascript
   * assignment.set('resourceId', 2);
   * // assignment.resource is not yet resolved
   *
   * await assignment.setAsync('resourceId', 2);
   * // assignment.resource is resolved
   * ```
   *
   * @param {String|Object} field The field to set value for, or an object with multiple values to set in one call
   * @param {*} value Value to set
   * @param {Boolean} [silent=false] Set to true to not trigger events
   * automatically.
   * @function setAsync
   * @category Editing
   * @async
   */
  //region Fields
  static get fields() {
    return [
      /**
       * Id for the resource to assign to
       * @field {String|Number} resourceId
       * @category Common
       */
      "resourceId",
      /**
       * Id for the event to assign
       * @field {String|Number} eventId
       * @category Common
       */
      "eventId",
      /**
       * Specify `false` to opt out of drawing dependencies from/to this assignment
       * @field {Boolean} drawDependencies
       * @category Common
       */
      { name: "drawDependencies", type: "boolean" },
      "event",
      "resource"
    ];
  }
  //endregion
  construct(data, ...args) {
    data = data || {};
    const { fieldMap } = this, eventIdField = fieldMap.eventId.dataSource, resourceIdField = fieldMap.resourceId.dataSource, eventField = fieldMap.event.dataSource, resourceField = fieldMap.resource.dataSource, eventId = data[eventIdField], resourceId = data[resourceIdField], event = data[eventField], resource = data[resourceField];
    if (eventId != null) {
      data[eventField] = eventId;
    } else if (event != null) {
      data[eventIdField] = event.isModel ? event.id : event;
    }
    if (resourceId != null) {
      data[resourceField] = resourceId;
    } else if (resource != null) {
      data[resourceIdField] = resource.isModel ? resource.id : resource;
    }
    super.construct(data, ...args);
  }
  //region Event & resource
  /**
   * A key made up from the event id and the id of the resource assigned to.
   * @property eventResourceKey
   * @readonly
   * @internal
   */
  get eventResourceKey() {
    return this.buildEventResourceKey(this.event, this.resource);
  }
  buildEventResourceKey(event, resource) {
    let eventKey, resourceKey;
    if (event) {
      eventKey = event.isModel ? event.id : event;
    } else {
      eventKey = this.internalId;
    }
    if (resource) {
      resourceKey = resource.isModel ? resource.id : resource;
    } else {
      resourceKey = this.internalId;
    }
    return `${eventKey}-${resourceKey}`;
  }
  buildIndexKey({ event, resource }) {
    return this.buildEventResourceKey(event, resource);
  }
  set(field2, value, ...args) {
    var _a2, _b;
    const toSet = this.fieldToKeys(field2, value);
    if ("resource" in toSet) {
      if (((_a2 = toSet.resource) == null ? void 0 : _a2.id) !== void 0) {
        toSet.resourceId = toSet.resource.id;
      }
    } else if ("resourceId" in toSet && this.constructor.isProAssignmentModel) {
      toSet.resource = toSet.resourceId;
    }
    if ("event" in toSet) {
      if (((_b = toSet.event) == null ? void 0 : _b.id) !== void 0) {
        toSet.eventId = toSet.event.id;
      }
    } else if ("eventId" in toSet && this.constructor.isProAssignmentModel) {
      toSet.event = toSet.eventId;
    }
    return super.set(toSet, null, ...args);
  }
  afterChange(toSet, wasSet, silent, fromRelationUpdate, skipAccessors) {
    var _a2, _b;
    const me = this;
    if (!me.constructor.isProAssignmentModel && (wasSet == null ? void 0 : wasSet.resourceId) && ((_a2 = me.resource) == null ? void 0 : _a2.id) !== wasSet.resourceId.value) {
      me.resource = wasSet.resourceId.value;
    } else if (me.constructor.isProAssignmentModel && ((_b = me.project) == null ? void 0 : _b.propagatingSyncChanges) && (wasSet == null ? void 0 : wasSet.eventId) && !(wasSet == null ? void 0 : wasSet.event) && (toSet.event.value === wasSet.eventId.value || toSet.event.value.id === wasSet.eventId.value)) {
      delete wasSet.eventId;
      delete me.meta.modified.eventId;
    }
    return super.afterChange(...arguments);
  }
  // Settings resourceId relays to `resource`. Underlying data will be updated in `afterChange()` above
  set resourceId(value) {
    const { resource } = this;
    if ((resource == null ? void 0 : resource.isModel) && resource.id === value) {
      this.set("resourceId", value);
    } else {
      this.resource = value;
    }
  }
  get resourceId() {
    var _a2, _b;
    return (_b = (_a2 = this.resource) == null ? void 0 : _a2.id) != null ? _b : this.get("resourceId");
  }
  // Same for event as for resourceId
  set eventId(value) {
    const { event } = this;
    if ((event == null ? void 0 : event.isModel) && event.id === value) {
      this.set("eventId", value);
    } else {
      this.event = value;
    }
  }
  get eventId() {
    var _a2, _b;
    return (_b = (_a2 = this.event) == null ? void 0 : _a2.id) != null ? _b : this.get("eventId");
  }
  /**
   * Convenience property to get the name of the associated event.
   * @property {String}
   * @readonly
   */
  get eventName() {
    var _a2;
    return (_a2 = this.event) == null ? void 0 : _a2.name;
  }
  /**
   * Convenience property to get the name of the associated resource.
   * @property {String}
   * @readonly
   */
  get resourceName() {
    var _a2;
    return (_a2 = this.resource) == null ? void 0 : _a2.name;
  }
  /**
   * Returns the resource associated with this assignment.
   *
   * @returns {Scheduler.model.ResourceModel} Instance of resource
   */
  getResource() {
    return this.resource;
  }
  //endregion
  // Convenience getter to not have to check `instanceof AssignmentModel`
  get isAssignment() {
    return true;
  }
  /**
   * Returns true if the Assignment can be persisted (e.g. task and resource are not 'phantoms')
   *
   * @property {Boolean}
   */
  get isPersistable() {
    var _a2;
    const {
      event,
      resource,
      unjoinedStores,
      assignmentStore
    } = this, crudManager = assignmentStore == null ? void 0 : assignmentStore.crudManager;
    let result;
    if (assignmentStore) {
      result = this.isValid && event.isPersistable && (crudManager || !event.hasGeneratedId && !resource.hasGeneratedId);
    } else {
      result = !this.isPhantom && Boolean(unjoinedStores[0]);
    }
    return result && super.isPersistable && !((_a2 = this.event) == null ? void 0 : _a2.isCreating);
  }
  get isValid() {
    return this.resource != null && this.event != null;
  }
  /**
   * Returns a textual representation of this assignment (e.g. Mike 50%).
   * @returns {String}
   */
  toString() {
    if (this.resourceName) {
      return `${this.resourceName} ${Math.round(this.units)}%`;
    }
    return "";
  }
  //region STM hooks
  shouldRecordFieldChange(fieldName, oldValue, newValue) {
    var _a2, _b;
    if (!super.shouldRecordFieldChange(fieldName, oldValue, newValue)) {
      return false;
    }
    if (fieldName === "event" || fieldName === "eventId") {
      const eventStore = (_a2 = this.project) == null ? void 0 : _a2.eventStore;
      if (eventStore && eventStore.oldIdMap[oldValue] === eventStore.getById(newValue)) {
        return false;
      }
    }
    if (fieldName === "resource" || fieldName === "resourceId") {
      const resourceStore = (_b = this.project) == null ? void 0 : _b.resourceStore;
      if (resourceStore && resourceStore.oldIdMap[oldValue] === resourceStore.getById(newValue)) {
        return false;
      }
    }
    return true;
  }
  //endregion
};

// ../Scheduler/lib/Scheduler/model/AssignmentModel.js
var EngineMixin = CoreAssignmentMixin;
var AssignmentModel = class extends AssignmentModelMixin_default(PartOfProject_default(EngineMixin.derive(Model))) {
  // NOTE: Leave field defs at top to be picked up by jsdoc
  /**
   * Id for event to assign. Can be used as an alternative to `eventId`, but please note that after
   * load it will be populated with the actual event and not its id. This field is not persistable.
   * @field {Scheduler.model.EventModel} event
   * @accepts {String|Number|Scheduler.model.EventModel}
   * @category Common
   */
  /**
   * Id for resource to assign to. Can be used as an alternative to `resourceId`, but please note that after
   * load it will be populated with the actual resource and not its id. This field is not persistable.
   * @field {Scheduler.model.ResourceModel} resource
   * @accepts {String|Number|Scheduler.model.ResourceModel}
   * @category Common
   */
  static get $name() {
    return "AssignmentModel";
  }
};
AssignmentModel.exposeProperties();
AssignmentModel._$name = "AssignmentModel";

// ../Scheduler/lib/Scheduler/data/mixin/AssignmentStoreMixin.js
var AssignmentStoreMixin_default = (Target) => class AssignmentStoreMixin extends Target {
  static get $name() {
    return "AssignmentStoreMixin";
  }
  /**
   * Add assignments to the store.
   *
   * NOTE: References (event, resource) on the assignments are determined async by a calculation engine. Thus they
   * cannot be directly accessed after using this function.
   *
   * For example:
   *
   * ```javascript
   * const [assignment] = assignmentStore.add({ eventId, resourceId });
   * // assignment.event is not yet available
   * ```
   *
   * To guarantee references are set up, wait for calculations for finish:
   *
   * ```javascript
   * const [assignment] = assignmentStore.add({ eventId, resourceId });
   * await assignmentStore.project.commitAsync();
   * // assignment.event is available (assuming EventStore is loaded and so on)
   * ```
   *
   * Alternatively use `addAsync()` instead:
   *
   * ```javascript
   * const [assignment] = await assignmentStore.addAsync({ eventId, resourceId });
   * // assignment.event is available (assuming EventStore is loaded and so on)
   * ```
   *
   * @param {Scheduler.model.AssignmentModel|Scheduler.model.AssignmentModel[]|AssignmentModelConfig|AssignmentModelConfig[]} records
   * Array of records/data or a single record/data to add to store
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Scheduler.model.AssignmentModel[]} Added records
   * @function add
   * @category CRUD
   */
  /**
   * Add assignments to the store and triggers calculations directly after. Await this function to have up to date
   * references on the added assignments.
   *
   * ```javascript
   * const [assignment] = await assignmentStore.addAsync({ eventId, resourceId });
   * // assignment.event is available (assuming EventStore is loaded and so on)
   * ```
   *
   * @param {Scheduler.model.AssignmentModel|Scheduler.model.AssignmentModel[]|AssignmentModelConfig|AssignmentModelConfig[]} records
   * Array of records/data or a single record/data to add to store
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Scheduler.model.AssignmentModel[]} Added records
   * @function addAsync
   * @category CRUD
   * @async
   */
  /**
   * Applies a new dataset to the AssignmentStore. Use it to plug externally fetched data into the store.
   *
   * NOTE: References (assignments, resources) on the assignments are determined async by a calculation engine. Thus
   * they cannot be directly accessed after assigning the new dataset.
   *
   * For example:
   *
   * ```javascript
   * assignmentStore.data = [{ eventId, resourceId }];
   * // assignmentStore.first.event is not yet available
   * ```
   *
   * To guarantee references are available, wait for calculations for finish:
   *
   * ```javascript
   * assignmentStore.data = [{ eventId, resourceId  }];
   * await assignmentStore.project.commitAsync();
   * // assignmentStore.first.event is available
   * ```
   *
   * Alternatively use `loadDataAsync()` instead:
   *
   * ```javascript
   * await assignmentStore.loadDataAsync([{ eventId, resourceId }]);
   * // assignmentStore.first.event is available
   * ```
   *
   * @member {AssignmentModelConfig[]} data
   * @category Records
   */
  /**
   * Applies a new dataset to the AssignmentStore and triggers calculations directly after. Use it to plug externally
   * fetched data into the store.
   *
   * ```javascript
   * await assignmentStore.loadDataAsync([{ eventId, resourceId }]);
   * // assignmentStore.first.event is available
   * ```
   *
   * @param {AssignmentModelConfig[]} data Array of AssignmentModel data objects
   * @function loadDataAsync
   * @category CRUD
   * @async
   */
  static get defaultConfig() {
    return {
      /**
       * CrudManager must load stores in the correct order. Lowest first.
       * @private
       */
      loadPriority: 300,
      /**
       * CrudManager must sync stores in the correct order. Lowest first.
       * @private
       */
      syncPriority: 300,
      storeId: "assignments"
    };
  }
  add(newAssignments, ...args) {
    var _a2;
    newAssignments = ArrayHelper.asArray(newAssignments);
    for (let i = 0; i < newAssignments.length; i++) {
      let assignment = newAssignments[i];
      if (!(assignment instanceof Model)) {
        newAssignments[i] = assignment = this.createRecord(assignment);
      }
      if (!this.isSyncingDataOnLoad && this.storage.findIndex("eventResourceKey", assignment.eventResourceKey, true) !== -1) {
        throw new Error(`Duplicate assignment Event: ${assignment.eventId} to resource: ${assignment.resourceId}`);
      }
      if ((_a2 = assignment.event) == null ? void 0 : _a2.isCreating) {
        assignment.isCreating = true;
      }
    }
    return super.add(newAssignments, ...args);
  }
  includesAssignment(eventId, resourceId) {
    return this.storage.findIndex("eventResourceKey", `${eventId}-${resourceId}`, true) !== -1;
  }
  setStoreData(data) {
    if (this.usesSingleAssignment) {
      throw new Error("Data loading into AssignmentStore (multi-assignment mode) cannot be combined EventStore data containing resourceId (single-assignment mode)");
    }
    super.setStoreData(data);
  }
  //region Init & destroy
  // This index fixes poor performance when you add large number of events to an event store with large number of
  // events - if cache is missing existing records are iterated n times.
  // https://github.com/bryntum/support/issues/3154#issuecomment-881336588
  set storage(storage) {
    super.storage = storage;
    this.storage.addIndex({ property: "eventResourceKey", dependentOn: { event: true, resource: true } });
  }
  get storage() {
    return this._storage || super.storage;
  }
  //endregion
  //region Stores
  // To not have to do instanceof checks
  get isAssignmentStore() {
    return true;
  }
  //endregion
  //region Recurrence
  /**
   * Returns a "fake" assignment used to identify a certain occurrence of a recurring event.
   * If passed the original event, it returns `originalAssignment`.
   * @param {Scheduler.model.AssignmentModel} originalAssignment
   * @param {Scheduler.model.EventModel} occurrence
   * @returns {Object} Temporary assignment
   * @internal
   */
  getOccurrence(originalAssignment, occurrence) {
    if (!originalAssignment || !(occurrence == null ? void 0 : occurrence.isOccurrence)) {
      return originalAssignment;
    }
    const me = this;
    return {
      id: `${occurrence.id}:a${originalAssignment.id}`,
      event: occurrence,
      resource: originalAssignment.resource,
      eventId: occurrence.id,
      resourceId: originalAssignment.resource.id,
      isAssignment: true,
      // This field is required to distinguish this fake assignment when event is being removed from UI
      isOccurrenceAssignment: true,
      // Not being an actual record, instanceMeta is stored on the store instead
      instanceMeta(instanceOrId) {
        return me.occurrenceInstanceMeta(this, instanceOrId);
      }
    };
  }
  // Per fake assignment instance meta, stored on store since fakes are always generated on demand
  occurrenceInstanceMeta(occurrenceAssignment, instanceOrId) {
    const me = this, instanceId = instanceOrId.id || instanceOrId, { id } = occurrenceAssignment;
    let { occurrenceMeta } = me;
    if (!occurrenceMeta) {
      occurrenceMeta = me.occurrenceMeta = {};
    }
    if (!occurrenceMeta[id]) {
      occurrenceMeta[id] = {};
    }
    return occurrenceMeta[id][instanceId] || (occurrenceMeta[id][instanceId] = {});
  }
  //endregion
  //region Mapping
  /**
   * Maps over event assignments.
   *
   * @param {Scheduler.model.EventModel} event
   * @param {Function} [fn]
   * @param {Function} [filterFn]
   * @returns {Scheduler.model.EventModel[]|Array}
   * @category Assignments
   */
  mapAssignmentsForEvent(event, fn2, filterFn) {
    event = this.eventStore.getById(event);
    const fnSet = Boolean(fn2), filterFnSet = Boolean(filterFn);
    if (fnSet || filterFnSet) {
      return event.assignments.reduce((result, assignment) => {
        const mapResult = fnSet ? fn2(assignment) : assignment;
        if (!filterFnSet || filterFn(mapResult)) {
          result.push(mapResult);
        }
        return result;
      }, []);
    }
    return event.assignments;
  }
  /**
   * Maps over resource assignments.
   *
   * @param {Scheduler.model.ResourceModel|Number|String} resource
   * @param {Function} [fn]
   * @param {Function} [filterFn]
   * @returns {Scheduler.model.ResourceModel[]|Array}
   * @category Assignments
   */
  mapAssignmentsForResource(resource, fn2, filterFn) {
    resource = this.resourceStore.getById(resource);
    const fnSet = Boolean(fn2), filterFnSet = Boolean(filterFn);
    if (fnSet || filterFnSet) {
      return resource.assignments.reduce((result, assignment) => {
        const mapResult = fnSet ? fn2(assignment) : assignment;
        if (!filterFnSet || filterFn(mapResult)) {
          result.push(mapResult);
        }
        return result;
      }, []);
    }
    return resource.assignments;
  }
  /**
   * Returns all assignments for a given event.
   *
   * @param {Scheduler.model.TimeSpan} event
   * @returns {Scheduler.model.AssignmentModel[]}
   * @category Assignments
   */
  getAssignmentsForEvent(event) {
    return event.assignments;
  }
  /**
   * Removes all assignments for given event
   *
   * @param {Scheduler.model.TimeSpan} event
   * @category Assignments
   */
  removeAssignmentsForEvent(event) {
    return this.remove(event.assignments);
  }
  /**
   * Returns all assignments for a given resource.
   *
   * @param {Scheduler.model.ResourceModel} resource
   * @returns {Scheduler.model.AssignmentModel[]}
   * @category Assignments
   */
  getAssignmentsForResource(resource) {
    resource = this.resourceStore.getById(resource);
    return resource.assignments;
  }
  /**
   * Removes all assignments for given resource
   *
   * @param {Scheduler.model.ResourceModel|*} resource
   * @category Assignments
   */
  removeAssignmentsForResource(resource) {
    this.remove(this.getAssignmentsForResource(resource));
  }
  /**
   * Returns all resources assigned to an event.
   *
   * @param {Scheduler.model.EventModel} event
   * @returns {Scheduler.model.ResourceModel[]}
   * @category Assignments
   */
  getResourcesForEvent(event) {
    return event.resources;
  }
  /**
   * Returns all events assigned to a resource
   *
   * @param {Scheduler.model.ResourceModel|String|Number} resource
   * @returns {Scheduler.model.TimeSpan[]}
   * @category Assignments
   */
  getEventsForResource(resource) {
    resource = this.resourceStore.getById(resource);
    return resource == null ? void 0 : resource.events;
  }
  /**
   * Creates and adds assignment record(s) for a given event and resource(s).
   *
   * @param {Scheduler.model.TimeSpan} event
   * @param {Scheduler.model.ResourceModel|Scheduler.model.ResourceModel[]} resources The resource(s) to assign to the event
   * @param {Function} [assignmentSetupFn] A hook function which takes an assignment as its argument and must return an assignment.
   * @param {Boolean} [removeExistingAssignments] `true` to remove assignments for other resources
   * @returns {Scheduler.model.AssignmentModel[]} An array with the created assignment(s)
   * @category Assign
   */
  assignEventToResource(event, resources, assignmentSetupFn = null, removeExistingAssignments = false) {
    var _a2, _b;
    const me = this, toRemove = removeExistingAssignments ? new Set(event.assignments) : null;
    resources = ArrayHelper.asArray(resources).map((r) => {
      var _a3;
      return (_a3 = r.$original) != null ? _a3 : r;
    });
    if ((_a2 = me.eventStore) == null ? void 0 : _a2.usesSingleAssignment) {
      if ((_b = event.assignments) == null ? void 0 : _b.length) {
        if (!me.isEventAssignedToResource(event, resources[0])) {
          event.resource = resources[0];
        }
        return [];
      } else {
        event.resourceId = resources[0].id;
      }
    }
    let newAssignments = [];
    me.suspendAutoCommit();
    resources.forEach((resource) => {
      var _a3;
      const existingAssignment = me.getAssignmentForEventAndResource(event, resource);
      if (!existingAssignment) {
        const assignment = {
          event,
          resource
        };
        newAssignments.push((_a3 = assignmentSetupFn == null ? void 0 : assignmentSetupFn(assignment)) != null ? _a3 : assignment);
      } else if (removeExistingAssignments) {
        toRemove.delete(existingAssignment);
      }
    });
    newAssignments = me.add(newAssignments);
    if (removeExistingAssignments) {
      me.remove(Array.from(toRemove));
    }
    me.resumeAutoCommit();
    return newAssignments;
  }
  /**
   * Removes assignment record for a given event and resource.
   *
   * @param {Scheduler.model.TimeSpan|String|Number} event
   * @param {Scheduler.model.ResourceModel|String|Number} [resources] The resource to unassign the event from. If omitted, all resources of the events will be unassigned
   * @returns {Scheduler.model.AssignmentModel|Scheduler.model.AssignmentModel[]}
   * @category Assign
   */
  unassignEventFromResource(event, resources) {
    const me = this, assignmentsToRemove = [];
    if (!resources) {
      return me.removeAssignmentsForEvent(event);
    }
    resources = ArrayHelper.asArray(resources);
    for (let i = 0; i < resources.length; i++) {
      if (me.isEventAssignedToResource(event, resources[i])) {
        assignmentsToRemove.push(me.getAssignmentForEventAndResource(event, resources[i]));
      }
    }
    return me.remove(assignmentsToRemove);
  }
  /**
   * Checks whether an event is assigned to a resource.
   *
   * @param {Scheduler.model.EventModel|String|Number} event Event record or id
   * @param {Scheduler.model.ResourceModel|String|Number} resource Resource record or id
   * @returns {Boolean}
   * @category Assignments
   */
  isEventAssignedToResource(event, resource) {
    return Boolean(this.getAssignmentForEventAndResource(event, resource));
  }
  /**
   * Returns an assignment record for a given event and resource
   *
   * @param {Scheduler.model.EventModel|String|Number} event The event or its id
   * @param {Scheduler.model.ResourceModel|String|Number} resource The resource or its id
   * @returns {Scheduler.model.AssignmentModel}
   * @category Assignments
   */
  getAssignmentForEventAndResource(event, resource) {
    let assignments;
    if (!(event = this.eventStore.getById(event)) || !(assignments = event.assignments) || // Also note that resources are looked for in the master store if chained, to handle dragging between
    // schedulers using chained versions of the same resource store. Needed since assignmentStore is shared and
    // might point to wrong resourceStore (can only point to one)
    !(resource = this.resourceStore.$master.getById(resource))) {
      return null;
    }
    return this.getOccurrence(assignments.find((a) => {
      var _a2;
      return ((_a2 = a.resource) == null ? void 0 : _a2.$original) === resource.$original;
    }), event);
  }
  //endregion
};

// ../Scheduler/lib/Scheduler/data/AssignmentStore.js
var EngineMixin2 = PartOfProject_default(CoreAssignmentStoreMixin.derive(AjaxStore));
var AssignmentStore = class extends AssignmentStoreMixin_default(EngineMixin2) {
  static get defaultConfig() {
    return {
      modelClass: AssignmentModel
    };
  }
};
__publicField(AssignmentStore, "$name", "AssignmentStore");
AssignmentStore._$name = "AssignmentStore";

// ../Scheduler/lib/Scheduler/data/mixin/EventStoreMixin.js
var EventStoreMixin_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base2) {
    /**
     * Add events to the store.
     *
     * NOTE: Dates, durations and references (assignments, resources) on the events are determined async by a calculation
     * engine. Thus they cannot be directly accessed after using this function.
     *
     * For example:
     *
     * ```javascript
     * eventStore.add({ startDate, duration });
     * // endDate is not yet calculated
     * ```
     *
     * To guarantee data is in a calculated state, wait for calculations for finish:
     *
     * ```javascript
     * eventStore.add({ startDate, duration });
     * await eventStore.project.commitAsync();
     * // endDate is calculated
     * ```
     *
     * Alternatively use `addAsync()` instead:
     *
     * ```javascript
     * await eventStore.addAsync({ startDate, duration });
     * // endDate is calculated
     * ```
     *
     * @param {Scheduler.model.EventModel|Scheduler.model.EventModel[]|EventModelConfig|EventModelConfig[]} records
     * Array of records/data or a single record/data to add to store
     * @param {Boolean} [silent] Specify `true` to suppress events
     * @returns {Scheduler.model.EventModel[]} Added records
     * @function add
     * @category CRUD
     */
    /**
     * Add events to the store and triggers calculations directly after. Await this function to have up to date data on
     * the added events.
     *
     * ```javascript
     * await eventStore.addAsync({ startDate, duration });
     * // endDate is calculated
     * ```
     *
     * @param {Scheduler.model.EventModel|Scheduler.model.EventModel[]|EventModelConfig|EventModelConfig[]} records
     * Array of records/data or a single record/data to add to store
     * @param {Boolean} [silent] Specify `true` to suppress events
     * @returns {Scheduler.model.EventModel[]} Added records
     * @function addAsync
     * @category CRUD
     * @async
     */
    /**
     * Applies a new dataset to the EventStore. Use it to plug externally fetched data into the store.
     *
     * NOTE: Dates, durations and relations (assignments, resources) on the events are determined async by a calculation
     * engine. Thus they cannot be directly accessed after assigning the new dataset.
     *
     * For example:
     *
     * ```javascript
     * eventStore.data = [{ startDate, duration }];
     * // eventStore.first.endDate is not yet calculated
     * ```
     *
     * To guarantee data is in a calculated state, wait for calculations for finish:
     *
     * ```javascript
     * eventStore.data = [{ startDate, duration }];
     * await eventStore.project.commitAsync();
     * // eventStore.first.endDate is calculated
     * ```
     *
     * Alternatively use `loadDataAsync()` instead:
     *
     * ```javascript
     * await eventStore.loadDataAsync([{ startDate, duration }]);
     * // eventStore.first.endDate is calculated
     * ```
     *
     * @member {EventModelConfig[]} data
     * @category Records
     */
    /**
     * Applies a new dataset to the EventStore and triggers calculations directly after. Use it to plug externally
     * fetched data into the store.
     *
     * ```javascript
     * await eventStore.loadDataAsync([{ startDate, duration }]);
     * // eventStore.first.endDate is calculated
     * ```
     *
     * @param {EventModelConfig[]} data Array of EventModel data objects
     * @function loadDataAsync
     * @category CRUD
     * @async
     */
    /**
     * Class used to represent records. Defaults to class EventModel.
     * @member {Scheduler.model.EventModel} modelClass
     * @typings {typeof EventModel}
     * @category Records
     */
    static get defaultConfig() {
      return {
        /**
         * CrudManager must load stores in the correct order. Lowest first.
         * @private
         */
        loadPriority: 100,
        /**
         * CrudManager must sync stores in the correct order. Lowest first.
         * @private
         */
        syncPriority: 200,
        storeId: "events",
        /**
         * Configure with `true` to also remove the event when removing the last assignment from the linked
         * AssignmentStore. This config has not effect when using EventStore in legacy `resourceId`-mode.
         * @config {Boolean}
         * @default
         * @category Common
         */
        removeUnassignedEvent: true,
        /**
         * Configure with `true` to force single-resource mode, an event can only be assigned to a single resource.
         * If not provided, the mode will be inferred from
         *
         * 1. presence of an assignment store (i.e. multi-assignment)
         * 2. presence of `resourceId` in the event store data (i.e. single assignment mode)
         * @config {Boolean}
         * @category Common
         */
        singleAssignment: null
      };
    }
    //region Init & destroy
    construct(config) {
      super.construct(config);
      this.autoTree = true;
      if (this.singleAssignment) {
        this.usesSingleAssignment = true;
      }
      if (!this.modelClass.isEventModel) {
        throw new Error("The model for the EventStore must subclass EventModel");
      }
    }
    //endregion
    //region Events records, iteration etc.
    set filtersFunction(filtersFunction) {
      super.filtersFunction = filtersFunction;
    }
    get filtersFunction() {
      const result = super.filtersFunction;
      if (result && result !== FunctionHelper.returnTrue) {
        return (r) => r.isCreating || result(r);
      }
      return result;
    }
    /**
     * Returns a `Map`, keyed by `YYYY-MM-DD` date keys containing event counts for all the days
     * between the passed `startDate` and `endDate`. Occurrences of recurring events are included.
     *
     * Example:
     *
     * ```javascript
     *  eventCounts = eventStore.getEventCounts({
     *      startDate : scheduler.timeAxis.startDate,
     *      endDate   : scheduler.timeAxis.endDate
     *  });
     * ```
     *
     * @param {Object} options An options object determining which events to return
     * @param {Date} options.startDate The start date for the range of events to include.
     * @param {Date} [options.endDate] The end date for the range of events to include.
     * @category Events
     */
    getEventCounts(options) {
      const me = this, {
        filtersFunction,
        added
      } = me, result = me.getEvents({
        ...options,
        storeFilterFn: me.isFiltered ? me.reapplyFilterOnAdd ? filtersFunction : (eventRecord) => added.includes(eventRecord) ? me.indexOf(eventRecord) > -1 : filtersFunction(eventRecord) : null,
        dateMap: options.dateMap || true
      });
      result.forEach((value, key) => result.set(key, value.length));
      return result;
    }
    /**
     * Calls the supplied iterator function once for every scheduled event, providing these arguments
     * - event : the event record
     * - startDate : the event start date
     * - endDate : the event end date
     *
     * Returning false cancels the iteration.
     *
     * @param {Function} fn iterator function
     * @param {Object} [thisObj] `this` reference for the function
     * @category Events
     */
    forEachScheduledEvent(fn2, thisObj = this) {
      this.forEach((event) => {
        const { startDate, endDate } = event;
        if (startDate && endDate) {
          return fn2.call(thisObj, event, startDate, endDate);
        }
      });
    }
    /**
     * Returns an object defining the earliest start date and the latest end date of all the events in the store.
     *
     * @returns {Object} An object with 'startDate' and 'endDate' properties (or null values if data is missing).
     * @category Events
     */
    getTotalTimeSpan() {
      let earliest = new Date(9999, 0, 1), latest = /* @__PURE__ */ new Date(0);
      this.forEach((event) => {
        if (event.startDate) {
          earliest = DateHelper.min(event.startDate, earliest);
        }
        if (event.endDate) {
          latest = DateHelper.max(event.endDate, latest);
        }
      });
      earliest = earliest < new Date(9999, 0, 1) ? earliest : null;
      latest = latest > /* @__PURE__ */ new Date(0) ? latest : null;
      return this.lastTotalTimeSpan = {
        startDate: earliest || null,
        endDate: latest || earliest || null
      };
    }
    /**
     * Checks if given event record is persistable. By default it always is, override EventModels `isPersistable` if you
     * need custom logic.
     *
     * @param {Scheduler.model.EventModel} event
     * @returns {Boolean}
     * @category Events
     */
    isEventPersistable(event) {
      return event.isPersistable;
    }
    //endregion
    //region Resource
    /**
     * Checks if a date range is allocated or not for a given resource.
     * @param {Date} start The start date
     * @param {Date} end The end date
     * @param {Scheduler.model.EventModel|null} excludeEvent An event to exclude from the check (or null)
     * @param {Scheduler.model.ResourceModel} resource The resource
     * @returns {Boolean} True if the timespan is available for the resource
     * @category Resource
     */
    isDateRangeAvailable(start, end, excludeEvent, resource) {
      if (resource.data.generatedParent) {
        return false;
      }
      const allEvents = new Set(this.getEventsForResource(resource));
      if (excludeEvent == null ? void 0 : excludeEvent.isAssignment) {
        const currentEvent = excludeEvent.event, resources = currentEvent.resources;
        resources.forEach((resource2) => {
          if (resource2.id !== excludeEvent.resourceId) {
            this.getEventsForResource(resource2).forEach((event) => allEvents.add(event));
          }
        });
      }
      if (excludeEvent) {
        const eventToRemove = excludeEvent.isAssignment ? excludeEvent.event : excludeEvent;
        allEvents.delete(eventToRemove);
      }
      return !Array.from(allEvents).some((event) => event.isScheduled && DateHelper.intersectSpans(start, end, event.startDate, event.endDate));
    }
    /**
     * Filters the events associated with a resource, based on the function provided. An array will be returned for those
     * events where the passed function returns true.
     * @param {Scheduler.model.ResourceModel} resource
     * @param {Function} fn The function
     * @param {Object} [thisObj] `this` reference for the function
     * @returns {Scheduler.model.EventModel[]} the events in the time span
     * @private
     * @category Resource
     */
    filterEventsForResource(resource, fn2, thisObj = this) {
      return resource.getEvents(this).filter(fn2.bind(thisObj));
    }
    /**
     * Returns all resources assigned to an event.
     *
     * @param {Scheduler.model.EventModel|String|Number} event
     * @returns {Scheduler.model.ResourceModel[]}
     * @category Resource
     */
    getResourcesForEvent(event) {
      if (event.isOccurrence) {
        event = event.recurringTimeSpan;
      }
      return this.assignmentStore.getResourcesForEvent(event);
    }
    /**
     * Returns all events assigned to a resource.
     * *NOTE:* this does not include occurrences of recurring events. Use the
     * {@link Scheduler/data/mixin/GetEventsMixin#function-getEvents} API to include occurrences of recurring events.
     * @param {Scheduler.model.ResourceModel|String|Number} resource Resource or resource id.
     * @returns {Scheduler.model.EventModel[]}
     * @category Resource
     */
    getEventsForResource(resource) {
      return this.assignmentStore.getEventsForResource(resource);
    }
    //endregion
    //region Assignment
    /**
     * Returns all assignments for a given event.
     *
     * @param {Scheduler.model.EventModel|String|Number} event
     * @returns {Scheduler.model.AssignmentModel[]}
     * @category Assignment
     */
    getAssignmentsForEvent(event) {
      return this.assignmentStore.getAssignmentsForEvent(event) || [];
    }
    /**
     * Returns all assignments for a given resource.
     *
     * @param {Scheduler.model.ResourceModel|String|Number} resource
     * @returns {Scheduler.model.AssignmentModel[]}
     * @category Assignment
     */
    getAssignmentsForResource(resource) {
      return this.assignmentStore.getAssignmentsForResource(resource) || [];
    }
    /**
     * Creates and adds assignment record for a given event and a resource.
     *
     * @param {Scheduler.model.EventModel|String|Number} event
     * @param {Scheduler.model.ResourceModel|String|Number|Scheduler.model.ResourceModel[]|String[]|Number[]} resource The resource(s) to assign to the event
     * @param {Boolean} [removeExistingAssignments] `true` to first remove existing assignments
     * @returns {Scheduler.model.AssignmentModel[]} An array with the created assignment(s)
     * @category Assignment
     */
    assignEventToResource(event, resource, removeExistingAssignments = false) {
      return this.assignmentStore.assignEventToResource(event, resource, void 0, removeExistingAssignments);
    }
    /**
     * Removes assignment record for a given event and a resource.
     *
     * @param {Scheduler.model.EventModel|String|Number} event
     * @param {Scheduler.model.ResourceModel|String|Number} resource
     * @category Assignment
     */
    unassignEventFromResource(event, resource) {
      this.assignmentStore.unassignEventFromResource(event, resource);
    }
    /**
     * Reassigns an event from an old resource to a new resource
     *
     * @param {Scheduler.model.EventModel}    event    An event or id of the event to reassign
     * @param {Scheduler.model.ResourceModel|Scheduler.model.ResourceModel[]} oldResource A resource or id to unassign from
     * @param {Scheduler.model.ResourceModel|Scheduler.model.ResourceModel[]} newResource A resource or id to assign to
     * @category Assignment
     */
    reassignEventFromResourceToResource(event, oldResource, newResource) {
      const me = this, newResourceId = Model.asId(newResource), assignment = me.assignmentStore.getAssignmentForEventAndResource(event, oldResource);
      if (assignment) {
        assignment.resourceId = newResourceId;
      } else {
        me.assignmentStore.assignEventToResource(event, newResource);
      }
    }
    /**
     * Checks whether an event is assigned to a resource.
     *
     * @param {Scheduler.model.EventModel|String|Number} event
     * @param {Scheduler.model.ResourceModel|String|Number} resource
     * @returns {Boolean}
     * @category Assignment
     */
    isEventAssignedToResource(event, resource) {
      return this.assignmentStore.isEventAssignedToResource(event, resource);
    }
    /**
     * Removes all assignments for given event
     *
     * @param {Scheduler.model.EventModel|String|Number} event
     * @category Assignment
     */
    removeAssignmentsForEvent(event) {
      this.assignmentStore.removeAssignmentsForEvent(event);
    }
    /**
     * Removes all assignments for given resource
     *
     * @param {Scheduler.model.ResourceModel|String|Number} resource
     * @category Assignment
     */
    removeAssignmentsForResource(resource) {
      this.assignmentStore.removeAssignmentsForResource(resource);
    }
    //endregion
    /**
     * Appends a new record to the store
     * @param {Scheduler.model.EventModel} record The record to append to the store
     * @category CRUD
     */
    append(record) {
      return this.add(record);
    }
    //region Project
    get project() {
      return super.project;
    }
    set project(project) {
      var _a3;
      super.project = project;
      this.detachListeners("project");
      if (project) {
        if ((_a3 = project.assignmentStore) == null ? void 0 : _a3.isAssignmentStore) {
          this.attachToAssignmentStore(project.assignmentStore);
        }
        project.ion({
          name: "project",
          assignmentStoreChange: "onProjectAssignmentStoreChange",
          thisObj: this,
          prio: 200
          // Before UI updates
        });
      }
    }
    //endregion
    //region Single assignment
    get usesSingleAssignment() {
      if (this.isChained) {
        return this.masterStore.usesSingleAssignment;
      }
      return this._usesSingleAssignment;
    }
    set usesSingleAssignment(value) {
      this._usesSingleAssignment = value;
      const { assignmentStore } = this;
      if ((assignmentStore == null ? void 0 : assignmentStore.isStore) && !assignmentStore.hasGenerateIdOverride) {
        assignmentStore.modelClass.generateId = function() {
          if (this.singleAssignmentIdCounter == null) {
            this.singleAssignmentIdCounter = 0;
          }
          return `a-${++this.singleAssignmentIdCounter}`;
        };
        assignmentStore.hasGenerateIdOverride = true;
      }
    }
    processRecords(eventRecords) {
      var _a3;
      const { assignmentStore } = this, assignmentsToAdd = [];
      if (assignmentStore) {
        assignmentStore.skipInvalidateIndices = true;
      }
      eventRecords = super.processRecords(eventRecords, assignmentStore && !((_a3 = this.stm) == null ? void 0 : _a3.isRestoring) && ((eventRecord) => {
        const resourceId = eventRecord.get("resourceId");
        if (!eventRecord.reassignedFromReplace && resourceId != null) {
          if (!assignmentStore.includesAssignment(eventRecord.id, resourceId)) {
            assignmentsToAdd.push({
              id: assignmentStore.modelClass.generateId(""),
              resourceId,
              eventId: eventRecord.id
            });
          }
        }
        eventRecord.reassignedFromReplace = false;
      }) || void 0);
      if (assignmentStore) {
        assignmentStore.storage.invalidateIndices();
        assignmentStore.skipInvalidateIndices = false;
        assignmentStore.add(assignmentsToAdd);
      }
      return eventRecords;
    }
    joinRecordsToStore(records) {
      const { assignmentStore } = this;
      if (assignmentStore) {
        assignmentStore.skipInvalidateIndices = true;
        super.joinRecordsToStore(records);
        assignmentStore.storage.invalidateIndices();
        assignmentStore.skipInvalidateIndices = false;
      } else {
        super.joinRecordsToStore(records);
      }
    }
    processRecord(eventRecord, isDataset = false) {
      var _a3, _b, _c;
      eventRecord = super.processRecord(eventRecord, isDataset);
      const me = this, assignmentStore = (_b = me.assignmentStore) != null ? _b : (_a3 = me.crudManager) == null ? void 0 : _a3.assignmentStore, resourceId = eventRecord.get("resourceId"), { resourceIds } = eventRecord;
      if ((resourceIds == null ? void 0 : resourceIds.length) && eventRecord.meta.skipEnforcingSingleAssignment !== false && ((_c = me.modelClass.fieldMap) == null ? void 0 : _c.resourceIds.persist)) {
        if (assignmentStore) {
          assignmentStore.add(resourceIds.filter((resourceId2) => !assignmentStore.some((a) => a.eventId === eventRecord.id && a.resourceId === resourceId2)).map((resourceId2) => ({ resource: resourceId2, event: eventRecord })));
        } else {
          me.$processResourceIds = true;
        }
      } else if (resourceId != null && !eventRecord.meta.skipEnforcingSingleAssignment) {
        const existingRecord = me.getById(eventRecord.id), isReplacing = existingRecord && existingRecord !== eventRecord && !isDataset;
        if (isReplacing) {
          const assignmentSet = assignmentStore.storage.findItem("eventId", eventRecord.id);
          if (assignmentSet == null ? void 0 : assignmentSet.size) {
            const assignment = assignmentSet.values().next().value;
            assignment.resource = resourceId;
            eventRecord.reassignedFromReplace = true;
          }
        } else {
          me.$processResourceIds = true;
        }
        me.usesSingleAssignment = true;
      }
      return eventRecord;
    }
    processResourceIds() {
      var _a3, _b, _c;
      const me = this, assignmentStore = (_b = me.assignmentStore) != null ? _b : (_a3 = me.crudManager) == null ? void 0 : _a3.assignmentStore;
      if (me.$processResourceIds && (assignmentStore == null ? void 0 : assignmentStore.isAssignmentStore) && !(((_c = me.project) == null ? void 0 : _c.isSharingAssignmentStore) && me.isChained)) {
        const assignments = [];
        me.forEach((eventRecord) => {
          const { resourceId, resourceIds, id: eventId } = eventRecord;
          if (resourceId != null) {
            assignments.push({
              id: assignmentStore.modelClass.generateId(""),
              resourceId,
              eventId
            });
          } else if (resourceIds == null ? void 0 : resourceIds.length) {
            resourceIds.forEach((rId) => {
              assignments.push({
                id: assignmentStore.modelClass.generateId(""),
                resourceId: rId,
                eventId
              });
            });
          }
        });
        assignmentStore.useRawData = {
          disableDefaultValue: true,
          disableDuplicateIdCheck: true,
          disableTypeConversion: true
        };
        assignmentStore.usesSingleAssignment = false;
        assignmentStore.verifyNoGeneratedIds = false;
        assignmentStore.data = assignments;
        assignmentStore.usesSingleAssignment = true;
        me.$processResourceIds = false;
      }
    }
    loadData() {
      super.loadData(...arguments);
      this.processResourceIds();
    }
    // Optionally remove unassigned events
    onBeforeRemoveAssignment({ records }) {
      var _a3;
      const me = this;
      if (me.removeUnassignedEvent && !me.isRemoving && !me.isSettingData && !((_a3 = me.stm) == null ? void 0 : _a3.isRestoring) && !me.usesSingleAssignment && // Do not remove unassigned events when syncing data, new assignments etc. might be synced afterwards
      !me.assignmentStore.isSyncingDataOnLoad && !me.resourceStore.isSyncingDataOnLoad) {
        const toRemove = /* @__PURE__ */ new Set();
        records.forEach((assignmentRecord) => {
          const { event } = assignmentRecord;
          if (event && !event.isRemoved && event.assignments.every((a) => records.includes(a))) {
            toRemove.add(event);
          }
        });
        if (toRemove.size) {
          me.remove([...toRemove]);
        }
      }
    }
    onProjectAssignmentStoreChange({ store }) {
      this.attachToAssignmentStore(store);
    }
    attachToAssignmentStore(assignmentStore) {
      const me = this;
      me.detachListeners("assignmentStore");
      if (assignmentStore) {
        me.processResourceIds();
        assignmentStore.ion({
          name: "assignmentStore",
          // Adding an assignment in single assignment mode should set events resourceId if needed,
          // otherwise it should set events resourceIds (if persistable)
          addPreCommit({ records }) {
            var _a3;
            if (!me.isSettingData && !me.isAssigning) {
              if (me.usesSingleAssignment) {
                records.forEach((assignment) => {
                  const { event } = assignment;
                  if ((event == null ? void 0 : event.isEvent) && event.resourceId !== assignment.resourceId) {
                    event.meta.isAssigning = true;
                    event.set("resourceId", assignment.resourceId);
                    event.meta.isAssigning = false;
                  }
                });
              } else if ((_a3 = me.modelClass.fieldMap) == null ? void 0 : _a3.resourceIds.persist) {
                records.forEach((assignment) => {
                  var _a4;
                  const { event } = assignment;
                  if (event == null ? void 0 : event.isEvent) {
                    event.meta.isAssigning = true;
                    const resourceIds = (_a4 = event.resourceIds) != null ? _a4 : [];
                    if (!resourceIds.includes(assignment.resourceId)) {
                      event.resourceIds = [...resourceIds, assignment.resourceId];
                    }
                    event.meta.isAssigning = false;
                  }
                });
              }
            }
          },
          // Called both for remove and removeAll
          beforeRemove: "onBeforeRemoveAssignment",
          // Removing an assignment in single assignment mode should set events resourceId to null,
          // otherwise it should set events resourceIds to an empty array
          removePreCommit({ records }) {
            var _a3;
            if (!me.isSettingData && !me.isAssigning) {
              if (me.usesSingleAssignment) {
                records.forEach((assignment) => {
                  var _a4;
                  (_a4 = me.getById(assignment.eventId)) == null ? void 0 : _a4.set("resourceId", null);
                });
              } else if ((_a3 = me.modelClass.fieldMap) == null ? void 0 : _a3.resourceIds.persist) {
                records.forEach(({ event, resourceId }) => {
                  const resourceIds = event.resourceIds.slice(), indexToRemove = resourceIds == null ? void 0 : resourceIds.indexOf(resourceId);
                  if (indexToRemove >= 0) {
                    resourceIds.splice(indexToRemove, 1);
                    event.resourceIds = resourceIds;
                  }
                });
              }
            }
          },
          removeAllPreCommit() {
            var _a3;
            if (!me.isSettingData && !me.isAssigning) {
              if (me.usesSingleAssignment) {
                me.allRecords.forEach((eventRecord) => eventRecord.set("resourceId", null));
              } else if ((_a3 = me.modelClass.fieldMap) == null ? void 0 : _a3.resourceIds.persist) {
                me.allRecords.forEach((eventRecord) => {
                  eventRecord.resourceIds = [];
                });
              }
            }
          },
          // Keep events resourceId and resourceIds in sync with assignment on changes
          update({ record, changes }) {
            var _a3;
            if ("resourceId" in changes) {
              const { event } = record;
              if (me.usesSingleAssignment) {
                event.meta.isAssigning = true;
                event.set("resourceId", changes.resourceId.value);
                event.meta.isAssigning = false;
              } else if ((_a3 = me.modelClass.fieldMap) == null ? void 0 : _a3.resourceIds.persist) {
                event.meta.isAssigning = true;
                const resourceIds = event.resourceIds.slice(), indexToRemove = resourceIds == null ? void 0 : resourceIds.indexOf(changes.resourceId.oldValue);
                if (indexToRemove >= 0) {
                  resourceIds.splice(indexToRemove, 1);
                }
                if (!(resourceIds == null ? void 0 : resourceIds.includes(changes.resourceId.value))) {
                  resourceIds.push(changes.resourceId.value);
                  event.resourceIds = resourceIds;
                }
                event.meta.isAssigning = false;
              }
            }
          },
          // Keep events resourceIds in sync with assignment on dataset loading
          change({ action, records }) {
            var _a3;
            if (action === "dataset" && ((_a3 = me.modelClass.fieldMap) == null ? void 0 : _a3.resourceIds.persist)) {
              records.forEach(({ event, resourceId }) => {
                var _a4;
                const resourceIds = (_a4 = event.resourceIds) != null ? _a4 : [];
                if (!resourceIds.includes(resourceId)) {
                  resourceIds.push(resourceId);
                  event.meta.isAssigning = true;
                  event.setData("resourceIds", resourceIds);
                  event.meta.isAssigning = false;
                }
              });
            }
          },
          thisObj: me
        });
      }
    }
    set data(data) {
      this.isSettingData = true;
      if (this.usesSingleAssignment && !this.syncDataOnLoad && !this.isChained) {
        this.assignmentStore.removeAll(true);
      }
      super.data = data;
      this.isSettingData = false;
    }
    // Override trigger to decorate update/change events with a flag if resourceId was the only thing changed, in which
    // case the change most likely can be ignored since the assignment will also change
    trigger(eventName, params) {
      var _a3;
      const { changes } = params || {};
      if (changes && "resourceId" in changes && Object.keys(changes).length === 1 && !((_a3 = this.stm) == null ? void 0 : _a3.isRestoring)) {
        params.isAssign = true;
      }
      return super.trigger(...arguments);
    }
    remove(records, ...args) {
      var _a3, _b;
      const result = super.remove(records, ...args);
      if (result.length && this.usesSingleAssignment) {
        for (const eventRecord of result) {
          if (!eventRecord.isOccurrence) {
            (_b = this.assignmentStore || ((_a3 = this.crudManager) == null ? void 0 : _a3.assignmentStore)) == null ? void 0 : _b.remove(eventRecord.assignments, true);
          }
        }
      }
      return result;
    }
    //endregion
  }, __publicField(_a2, "$name", "EventStoreMixin"), _a2;
};

// ../Scheduler/lib/Scheduler/data/mixin/GetEventsMixin.js
var returnTrue2 = () => true;
var notRecurring = (event) => !event.isRecurring;
var GetEventsMixin_default = (Target) => {
  var _a2;
  return _a2 = class extends Target {
    /**
     * Returns an array of events for the date range specified by the `startDate` and `endDate` options.
     *
     * By default, for any date, this includes any event which *intersects* that date.
     *
     * To only include events that are fully contained *within* the date range, pass the `allowPartial`
     * option as `false`.
     *
     * By default, any occurrences of recurring events are included in the resulting array (not applicable in Gantt). If
     * that is not required, pass the `includeOccurrences` option as `false`. **Note that if `includeOccurrences` is
     * `true`, the start date and end date options are mandatory. The method must know what range of occurrences needs
     * to be generated and returned.**
     *
     * Example:
     *
     * ```javascript
     *  visibleEvents = eventStore.getEvents({
     *      resourceRecord : myResource,
     *      startDate      : scheduler.timeAxis.startDate,
     *      endDate        : scheduler.timeAxis.endDate
     *  });
     * ```
     *
     * @param {Object} options An options object determining which events to return
     * @param {Date} [options.date] If only one date is required, pass this option instead of the
     * `startDate` and `endDate` options.
     * @param {Date} options.startDate The start date for the range of events to include.
     * @param {Date} [options.endDate] The end date for the range of events to include.
     * @param {Scheduler.model.ResourceModel} [options.resourceRecord] Pass a resource to only return events assigned to
     *   this resource. Not supported when using the `dateMap` option (see below)
     * @param {Function} [options.filter] A function to filter out events which are not required.
     * @param {Boolean} [options.ignoreFilters] By default, store filters are honoured. Pass this
     * as `true` to include filtered out events.
     * @param {Boolean} [options.includeOccurrences=true] Occurrences of recurring events are included by default.
     * @param {Boolean} [options.allowPartial=true] Events which start before or after the range, but *intersect* the
     *   range are included by default.
     * @param {Boolean} [options.startOnly] Pass `true` to only include events which *start on* each date in the range.
     * @param {Boolean} [options.onlyAssigned] Pass `true` to only include events that are assigned to a resource
     * @param {Boolean|Map} [options.dateMap] Populates the passed `Map`, or if passed as `true`, creates and
     * returns a new `Map`. The keys are `YYYY-MM-DD` date strings and the entries are arrays of
     * {@link Scheduler.model.EventModel EventModel}s.
     * @returns {Scheduler.model.EventModel[]|Map} Events which match the passed configuration.
     * @category Events
     */
    getEvents({
      filter: filter2,
      date,
      startDate,
      // Events which intersect the startDate/endDate
      endDate,
      // will be returned
      startOnly,
      // Only events which start on each date will be returned
      includeOccurrences,
      // Interpolate occurrences into the returned event set
      allowPartial,
      // Include events which *intersect* the date range
      onlyAssigned = false,
      // Only include events that are assigned to a resource
      dateMap = false,
      // Return a Map keyed by date each value being an array of events
      dayTime = null,
      // Private option. Select which date index to look up events in depending on the date
      // we are examining in the date iteration process. Some callers may want to use
      // different indices depending on the stage through the date iteration.
      // See Calendar package for usage.
      getDateIndex
    }) {
      const me = this, options = arguments[0], {
        lastDateRange,
        added,
        filtersFunction
      } = me, passedFilter = filter2;
      if (onlyAssigned) {
        options.filter = passedFilter ? (e) => passedFilter(e) && e.resources.length : (e) => e.resources.length;
      }
      if (!("startDate" in options)) {
        startDate = options.startDate = date;
      }
      if (!("includeOccurrences" in options)) {
        includeOccurrences = options.includeOccurrences = true;
      }
      if (!("allowPartial" in options)) {
        allowPartial = options.allowPartial = !startOnly;
      }
      options.storeFilterFn = me.isFiltered && !options.ignoreFilters ? me.reapplyFilterOnAdd ? filtersFunction : (eventRecord) => added.includes(eventRecord) ? me.indexOf(eventRecord) > -1 : filtersFunction(eventRecord) : null;
      if (!endDate) {
        if (startDate) {
          endDate = options.endDate = DateHelper.clearTime(startDate);
          endDate.setDate(endDate.getDate() + 1);
        } else {
          if (includeOccurrences) {
            throw new Error("getEvents MUST be passed startDate and endDate if recurring occurrences are requested");
          }
          options.dateFilter = returnTrue2;
        }
      }
      if (!options.dateFilter) {
        if (startOnly) {
          options.dateFilter = (e) => {
            const eventStartDate = e.hasBatchedChange("startDate") ? e.get("startDate") : e.startDate;
            return eventStartDate && !(DateHelper.clearTime(eventStartDate) - startDate);
          };
        } else if (allowPartial) {
          options.dateFilter = (e) => {
            const eventStartDate = e.hasBatchedChange("startDate") ? e.get("startDate") : e.startDate, eventEndDate = e.hasBatchedChange("endDate") ? e.get("endDate") : e.endDate || eventStartDate, isMilestone = !(eventStartDate - eventEndDate);
            return eventStartDate && (isMilestone ? DateHelper.betweenLesserEqual(eventStartDate, startDate, endDate) : DateHelper.intersectSpans(eventStartDate, eventEndDate, startDate, endDate));
          };
        } else {
          options.dateFilter = (e) => {
            const eventStartDate = e.hasBatchedChange("startDate") ? e.get("startDate") : e.startDate, eventEndDate = e.hasBatchedChange("endDate") ? e.get("endDate") : e.endDate || eventStartDate;
            return eventStartDate && eventStartDate >= startDate && eventEndDate <= endDate;
          };
        }
      }
      const newDateRange = {
        startDate,
        endDate
      };
      me.processConfiguredListeners();
      me.trigger("loadDateRange", {
        old: lastDateRange || {},
        new: Objects.clone(newDateRange),
        changed: Boolean(!lastDateRange || (lastDateRange.startDate - newDateRange.startDate || lastDateRange.endDate - newDateRange.endDate))
      });
      me.lastDateRange = Objects.clone(newDateRange);
      return dateMap ? me.getEventsAsMap(options) : me.getEventsAsArray(options);
    }
    /**
     * Internal implementation for {@link #function-getEvents} to use when not using dateMap.
     * @private
     */
    getEventsAsArray({
      filter: filter2,
      date,
      resourceRecord,
      startDate = date,
      // Events which intersect the startDate/endDate
      endDate,
      // will be returned
      startOnly,
      // Only events which start on each date will be returned
      includeOccurrences = true,
      // Interpolate occurrences into the returned event set
      dayTime = null,
      // Injected by the getEvents master method
      dateFilter,
      storeFilterFn,
      // Private option. Select which date index to look up events in depending on the date
      // we are examining in the date iteration process. Some callers may want to use
      // different indices depending on the stage through the date iteration.
      // See Calendar package for usage.
      getDateIndex
    }) {
      const me = this, events = [], count = storeFilterFn ? me.count : me.allCount;
      if (count) {
        let candidateEvents = resourceRecord ? me.getEventsForResource(resourceRecord) : null;
        if (!resourceRecord) {
          const dateIndex = me.useDayIndex(dayTime), eventSet = /* @__PURE__ */ new Set(), indexName = startOnly ? "startDate" : "date";
          me.recurringEvents.forEach((e) => {
            if (dateIndex.dayTime.startOfDay(e.startDate) <= startDate) {
              eventSet.add(e);
            }
          });
          for (const date2 = new Date(startDate); date2 < endDate; date2.setDate(date2.getDate() + 1)) {
            const coincidingEvents = dateIndex.get(getDateIndex ? getDateIndex(date2) : indexName, date2);
            coincidingEvents == null ? void 0 : coincidingEvents.forEach((e) => eventSet.add(e));
          }
          candidateEvents = [...eventSet];
        }
        if (storeFilterFn) {
          candidateEvents = candidateEvents.filter(storeFilterFn);
        }
        for (let i = 0, { length } = candidateEvents; i < length; i++) {
          const e = candidateEvents[i];
          if (includeOccurrences && e.isRecurring) {
            events.push.apply(events, e.getOccurrencesForDateRange(startDate, endDate).filter(dateFilter));
          } else if (dateFilter(e)) {
            events.push(e);
          }
        }
      }
      return filter2 ? events.filter(filter2) : events;
    }
    /**
     * Internal implementation for {@link #function-getEvents} to use when using dateMap.
     * @private
     */
    getEventsAsMap({
      filter: passedFilter,
      date,
      resourceRecord,
      // Not supported yet. Will add if ever requested.
      startDate = date,
      // Events which intersect the startDate/endDate
      endDate,
      // will be returned
      startOnly,
      // Only events which start on each date will be returned
      includeOccurrences = true,
      // Interpolate occurrences into the returned event set
      dateMap,
      // Return a Map keyed by date each value being an array of events
      dayTime = null,
      storeFilterFn,
      // Private option. Select which date index to look up events in depending on the date
      // we are examining in the date iteration process. Some callers may want to use
      // different indices depending on the stage through the date iteration.
      // See Calendar package for usage.
      getDateIndex
    }) {
      var _a3;
      const me = this;
      if (dateMap == null ? void 0 : dateMap.clear) {
        dateMap.clear();
      } else {
        dateMap = /* @__PURE__ */ new Map();
      }
      if (me.count) {
        const dateIndex = me.useDayIndex(dayTime), indexName = startOnly ? "startDate" : "date", recurringEvents = [], filter2 = (e) => (!passedFilter || passedFilter(e)) && (!storeFilterFn || storeFilterFn(e)), baseEventFilter = (e) => notRecurring(e) && filter2(e);
        dayTime = dateIndex.dayTime;
        if (resourceRecord) {
          throw new Error("Querying for events for a resource and returning a date-keyed Map is not supported");
        } else {
          (_a3 = me.recurringEvents) == null ? void 0 : _a3.forEach((e) => {
            if (dayTime.startOfDay(e.startDate) < endDate) {
              recurringEvents.push(e);
            }
          });
          for (const date2 = new Date(startDate); date2 < endDate; date2.setDate(date2.getDate() + 1)) {
            let [coincidingEvents, key] = dateIndex.get(getDateIndex ? getDateIndex(date2) : indexName, date2, true);
            if (coincidingEvents == null ? void 0 : coincidingEvents.size) {
              coincidingEvents = [...coincidingEvents].filter(baseEventFilter);
              if (coincidingEvents.length) {
                (dateMap.get(key) || dateMap.set(key, []).get(key)).push(...coincidingEvents);
              }
            }
          }
        }
        for (let i = 0, { length } = recurringEvents; i < length; i++) {
          const e = recurringEvents[i], occurrences = (includeOccurrences ? e.getOccurrencesForDateRange(startDate, endDate) : [e]).filter(filter2), lastDate = DateHelper.add(endDate, 1, "day");
          for (let bucket2, i2 = 0, { length: length2 } = occurrences; i2 < length2; i2++) {
            const occurrence = occurrences[i2], date2 = dayTime.startOfDay(occurrence.startDate), indexName2 = getDateIndex ? getDateIndex(date2) : startOnly ? "startDate" : "date", lastIntersectingDate = indexName2 === "startDate" || !occurrence.durationMS ? DateHelper.add(date2, 1, "day") : DateHelper.min(occurrence.endDate || DateHelper.add(occurrence.startDate, occurrence.duration, occurrence.durationUnit), lastDate);
            for (; date2 < lastIntersectingDate; date2.setDate(date2.getDate() + 1)) {
              const key = dayTime.dateKey(date2);
              (bucket2 = dateMap.get(key)) || dateMap.set(key, bucket2 = []);
              bucket2.push(occurrence);
            }
          }
        }
      }
      return dateMap;
    }
  }, __publicField(_a2, "$name", "GetEventsMixin"), _a2;
};

// ../Core/lib/Core/util/DayTime.js
var MILLIS_PER_MINUTE = 60 * 1e3;
var MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;
var MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR;
var timeRe = /(\d+)?:?(\d*)/;
var DayTime = class {
  /**
   * Returns a string of "HH:MM" for a given time of day in milliseconds.
   * @param {Number} timeOfDay The time of day in milliseconds.
   * @returns {String}
   * @private
   */
  static format(timeOfDay) {
    const h = Math.floor(timeOfDay / MILLIS_PER_HOUR), m = Math.floor(timeOfDay / MILLIS_PER_MINUTE) % 60;
    return `${h}:${m < 10 ? "0" : ""}${m}`;
  }
  /**
   * Parses a time of day which may be a number (0-24 for the hour of the day) or a string in "H:MM" format and
   * returns the time of day as a number of milliseconds.
   *
   * If `time` is a `Date` instance, its time of day is returned.
   * @param {Date|Number|String} time
   * @returns {Number}
   * @private
   */
  static parse(time) {
    const type = typeof time;
    if (type === "string") {
      const match = timeRe.exec(time);
      time = Number(match[1] || 0) * MILLIS_PER_HOUR + Number(match[2] || 0) * MILLIS_PER_MINUTE;
    } else if (type !== "number") {
      time = DateHelper.getTimeOfDay(time);
    } else if (time <= 24) {
      time *= MILLIS_PER_HOUR;
    }
    return Math.min(Math.max(Math.floor(time), 0), MILLIS_PER_DAY);
  }
  constructor(config) {
    let startShift = 0, startTime, endTime;
    if (config == null ? void 0 : config.isDayView) {
      startShift = config.dayStartShift;
      startTime = config.dayStartTime;
      endTime = config.dayEndTime;
    } else if (typeof config === "number") {
      startShift = startTime = endTime = config;
    } else if (config) {
      startShift = config.startShift;
      startTime = config.timeStart;
      endTime = config.timeEnd;
    }
    this.startShift = startShift = DayTime.parse(startShift || 0);
    this.timeEnd = (endTime == null ? (startShift + MILLIS_PER_DAY) % MILLIS_PER_DAY : DayTime.parse(endTime)) || MILLIS_PER_DAY;
    this.timeStart = startTime == null ? startShift : DayTime.parse(startTime);
  }
  get startHour() {
    return Math.floor(this.timeStart / MILLIS_PER_HOUR);
  }
  get endHour() {
    return Math.floor(this.timeEnd / MILLIS_PER_HOUR);
  }
  /**
   * The number of milliseconds from the day's `startShift` to its `timeStart`.
   * @member {Number}
   */
  get startTimeOffsetMs() {
    const { startShift, timeStart } = this;
    return timeStart < startShift ? MILLIS_PER_DAY - startShift + timeStart : timeStart - startShift;
  }
  /**
   * The `Date` object for the most recently started, shifted day. The time of this `Date` will be the `startShift`.
   * It is possible for this date to be yesterday on a midnight-based calendar. For example, if the `startShift` is
   * 6PM and the current time is 6AM on May 20, this value will be 6PM of May 19 (the most recently started day).
   * @member {Date}
   */
  get today() {
    return this.startOfDay(/* @__PURE__ */ new Date());
  }
  /**
   * Returns `Date` object for the nearest (shifted) day ending after the given `date`. The time of this `Date` will
   * be the `startShift`.
   *
   * It is possible for this date to be in the next day on a midnight-based calendar. For example, if the `startShift`
   * is 6PM and `date` is 7PM on May 20, this method will return 6PM of May 21 (the nearest day ending).
   * @param {Date} date The date for which to find the nearest day ending.
   * @returns {Date}
   */
  ceil(date) {
    const ret = this.startOfDay(date);
    if (ret < date) {
      ret.setDate(ret.getDate() + 1);
    }
    return ret;
  }
  /**
   * Returns `true` if the time of day for the given `date` is between `timeStart` and `timeEnd`.
   * @param {Date|Number|String} date The hour number, 'HH:MM' time or a `Date` instance to test.
   * @returns {Boolean}
   */
  contains(date) {
    return !this.outside(date);
  }
  /**
   * Returns a "YYYY-MM-DD" string for the given `date`. This value will match the `date` if the time of day is at or
   * after `startShift`, but will be the prior date otherwise.
   * @param {Date|Number} date The date from which to compute the 'YYYY-MM-DD' key.
   * @returns {String}
   */
  dateKey(date) {
    date = this.shiftDate(date, -1);
    return DateHelper.makeKey(date);
  }
  /**
   * Returns a `Date` instance with `startShift` as the time of day and the Y/M/D of the given `date`.
   * @param {Date} date The date's year, month, and day values.
   * @returns {Date}
   */
  dayOfDate(date) {
    return this.shiftDate(DateHelper.clearTime(date));
  }
  /**
   * Returns the day of week (0-8) for the given `date`. This value will match the `date` if the time of day is at or
   * after `startShift`, but will be the prior day otherwise.
   * @param {Date|Number} date The date from which to compute the day of week.
   * @returns {Number}
   */
  dayOfWeek(date) {
    date = this.shiftDate(date, -1);
    return date.getDay();
  }
  /**
   * Returns the difference between the time of day of the given `date` and `timeStart` in the specified time `unit`.
   * @param {Date|Number|String} date The hour number, 'HH:MM' time or a `Date` instance.
   * @param {String} unit The desired unit of time to return (see {@link Core.helper.DateHelper#function-as-static}).
   * @returns {Number}
   */
  delta(date, unit = "ms") {
    const { timeStart } = this, time = DayTime.parse(date), t = (this.startShift && time < timeStart ? time + MILLIS_PER_DAY : time) - timeStart;
    return unit === "ms" ? t : DateHelper.as(unit, t, "ms");
  }
  /**
   * Returns the duration of the visible day (between `timeStart` and `timeEnd`) in the specified time `unit`.
   * @param {String} unit The desired unit of time to return (see {@link Core.helper.DateHelper#function-as-static}).
   * @returns {Number}
   */
  duration(unit = "ms") {
    const { timeStart, timeEnd } = this, millis = timeStart < timeEnd ? timeEnd - timeStart : MILLIS_PER_DAY - timeStart + timeEnd;
    return unit === "ms" ? millis : DateHelper.as(unit, millis, "ms");
  }
  /**
   * Returns `true` if this instance describes the same day as the `other`.
   * @param {Core.util.DayTime} other The other instance to which `this` instance should be tested for equality.
   * @returns {Boolean}
   */
  equals(other) {
    return this.startShift === (other == null ? void 0 : other.startShift) && this.timeStart === other.timeStart && this.timeEnd === other.timeEnd;
  }
  /**
   * Returns `true` if the times of day described by `startDate` and `endDate` intersect the visible time of this day.
   * @param {Date} startDate The start date of the date range or an event record containing both startDate and endDate
   * fields.
   * @param {Date} [endDate] The end date if `startDate` is not an event record.
   * @returns {Boolean}
   */
  intersects(startDate, endDate) {
    const me = this, { timeStart, timeEnd } = me, [date0, date1] = me._dateRangeArgs(startDate, endDate), [start, end] = me.timeRange(date0, date1);
    if (timeStart < timeEnd) {
      if (start < end) {
        return start < timeEnd && timeStart <= end;
      }
      return start < timeEnd || timeStart <= end;
    }
    return !(start < end) || start < timeEnd || timeStart <= end;
  }
  /**
   * Returns `true` if the given date range is contained within one day.
   * @param {Date} startDate The start date of the date range or an event record containing both startDate and endDate
   * fields.
   * @param {Date} [endDate] The end date if `startDate` is not an event record.
   * @returns {Boolean}
   */
  isIntraDay(startDate, endDate) {
    const me = this, [date0, date1] = me._dateRangeArgs(startDate, endDate), dayStart = me.startOfDay(date0), diff = MILLIS_PER_DAY - DateHelper.diff(dayStart, date1, "ms");
    if (diff < 0) {
      return false;
    }
    return diff > 0 || dayStart < date0;
  }
  /**
   * Returns `true` if the given date range or event crosses the day boundary.
   * @param {Date} startDate The start date of the date range or an event record containing both startDate and endDate
   * fields.
   * @param {Date} [endDate] The end date if `startDate` is not an event record.
   * @returns {Boolean}
   */
  isInterDay(timeSpan) {
    return timeSpan.allDay || !this.isIntraDay(...arguments);
  }
  /**
   * Returns -1, 0, or 1 based on whether the time of day for the given `date` is before `timeStart` (-1), or after
   * `timeEnd` (1), or between these times (0).
   * @param {Date|Number|String} date The hour number, 'HH:MM' time or a `Date` instance to test.
   * @returns {Number}
   */
  outside(date) {
    const { startShift, timeStart, timeEnd } = this, time = DayTime.parse(date);
    if (timeStart < timeEnd) {
      if (time < timeStart) {
        return time < startShift ? 1 : -1;
      }
      if (time < timeEnd) {
        return 0;
      }
      return time < startShift ? -1 : 1;
    }
    if (time < timeEnd || time >= timeStart) {
      return 0;
    }
    return time < startShift ? 1 : -1;
  }
  parseKey(key) {
    return this.dayOfDate(DateHelper.parseKey(key));
  }
  /**
   * Returns the given `date` shifted forward (`direction` > 0) or backward (`direction` < 0) by the `startShift`.
   * @param {Number|Date} date The date as a `Date` or the millisecond UTC epoch.
   * @param {Number} direction A value > 0 to shift `date` forward, or < 0 to shift it backwards.
   * @returns {Date}
   */
  shiftDate(date, direction = 1) {
    const { startShift } = this, type = typeof date;
    date = type === "number" ? new Date(date) : type === "string" ? DateHelper.parse(date) : new Date(date.getTime());
    if (direction && startShift) {
      date.setMilliseconds(direction > 0 ? startShift : -startShift);
    }
    return date;
  }
  /**
   * Sorts the given set of `events` by the maximum of `startDate` and `startOfDay` for the given `date`, followed
   * by `duration` in case of a tie.
   * @param {Date} date The day for which events are to be sorted.
   * @param {Object[]} events The events to sort, typically an `Scheduler.model.EventModel[]` but any objects with
   * both `startDate` and `endDate` fields are acceptable.
   * @returns {Object[]} The passed `events` array.
   * @internal
   */
  sortEvents(date, events) {
    const startOfDay = this.startOfDay(date);
    return events == null ? void 0 : events.sort((event1, event2) => {
      event1 = event1.eventRecord || event1;
      event2 = event2.eventRecord || event2;
      let { startDate: start1 } = event1, { startDate: start2 } = event2;
      if (!start1) {
        return -1;
      }
      if (!start2) {
        return 1;
      }
      start1 = start1 < startOfDay ? startOfDay : start1;
      start2 = start2 < startOfDay ? startOfDay : start2;
      return start1 - start2 || event2.endDate - start2 - (event1.endDate - start1);
    });
  }
  /**
   * Returns `Date` object for the nearest started (shifted) day prior to the given `date`. The time of this `Date`
   * will be the `startShift`.
   *
   * It is possible for this date to be in the prior day on a midnight-based calendar. For example, if the `startShift`
   * is 6PM and `date` is 6AM on May 20, this method will return 6PM of May 19 (the nearest started day).
   * @param {Date} date The date for which to find the nearest started day.
   * @returns {Date}
   */
  startOfDay(date) {
    date = this.shiftDate(date, -1);
    date = DateHelper.clearTime(date);
    date = this.shiftDate(date);
    return date;
  }
  /**
   * Returns a range of {@link Core.helper.DateHelper#function-getTimeOfDay-static times of day} for the given
   * date range.
   * @param {Date} startDate The start date of the date range or an event record containing both `startDate` and `endDate` fields
   * @param {Date} [endDate] The end date if `startDate` is not an event record
   * @returns {Number[]}
   */
  timeRange(startDate, endDate) {
    const [start, end] = this._dateRangeArgs(startDate, endDate);
    return [DateHelper.getTimeOfDay(start), DateHelper.getTimeOfDay(end)];
  }
  toString() {
    const { startShift, timeEnd, timeStart } = this, suffix = startShift ? `@${DayTime.format(startShift)}` : "", prefix = DayTime.format(timeStart);
    if (timeStart === timeEnd) {
      return startShift ? suffix : prefix;
    }
    return `${prefix}-${DayTime.format(timeEnd)}${suffix}`;
  }
  /**
   * Decodes the arguments and returns a pair of `Date` objects for the start and end of the date range.
   * @param {Date} startDate The start date of the date range or an event record containing both startDate and endDate
   * fields.
   * @param {Date} [endDate] The end date if `startDate` is not an event record.
   * @returns {Date[]}
   * @private
   */
  _dateRangeArgs(startDate, endDate) {
    return startDate.isModel ? [startDate.startDate, startDate.endingDate] : [startDate, endDate];
  }
};
DayTime.MIDNIGHT = new DayTime({
  startShift: 0,
  timeStart: 0,
  timeEnd: 24
});
DayTime.MILLIS_PER_MINUTE = MILLIS_PER_MINUTE;
DayTime.MILLIS_PER_HOUR = MILLIS_PER_HOUR;
DayTime.MILLIS_PER_DAY = MILLIS_PER_DAY;
DayTime._$name = "DayTime";

// ../Scheduler/lib/Scheduler/data/util/EventDayIndex.js
var indexNameMap = {
  date: "_dateIndex",
  startDate: "_startDateIndex"
};
var indexProps = Object.values(indexNameMap);
var emptyArray6 = Object.freeze([]);
var { MILLIS_PER_DAY: MILLIS_PER_DAY2 } = DayTime;
var EventDayIndex = class {
  constructor(store, dayTime) {
    this.dayTime = dayTime || DayTime.MIDNIGHT;
    this.store = store;
    this.users = [this.dayTime];
  }
  /**
   * Adds an event record to the specified index (either "startDate" or "date") for a given `date`.
   * @param {String} indexName The index to which the event record is to be added (either "startDate" or "date").
   * @param {Date|Number} date A date for which the event record overlaps. The {@link Core.util.DayTime#function-dateKey}
   * method is used to convert this date to a "YYYY-MM-DD" key for the index.
   * @param {Scheduler.model.EventModel} eventRecord The event record.
   * @private
   */
  add(indexName, date, eventRecord) {
    const index = this[indexNameMap[indexName]], key = this.dayTime.dateKey(date), entry = index[key] || (index[key] = /* @__PURE__ */ new Set());
    entry.add(eventRecord);
  }
  /**
   * Adds an event record to all indexes for all dates which the event overlaps.
   * @param {Scheduler.model.EventModel} eventRecord The event record.
   * @private
   */
  addEvent(eventRecord) {
    var _a2, _b, _c;
    let dateMS = (_a2 = this.dayTime.startOfDay(eventRecord.startDate)) == null ? void 0 : _a2.getTime(), endDateMS;
    if (dateMS) {
      endDateMS = (_c = (_b = eventRecord.endDate) == null ? void 0 : _b.getTime()) != null ? _c : dateMS;
      this.add("startDate", dateMS, eventRecord);
      do {
        this.add("date", dateMS, eventRecord);
        dateMS += MILLIS_PER_DAY2;
      } while (dateMS < endDateMS);
    }
  }
  /**
   * Clear this index.
   */
  clear() {
    indexProps.forEach((name) => this[name] = /* @__PURE__ */ Object.create(null));
  }
  /**
   * Returns an object that has properties named by the {@link Core.util.DayTime#function-dateKey} method, or the
   * array of event records if a `date` is specified, or the event record array and the date key in a 2-element array
   * if `returnKey` is `true`.
   * @param {String} indexName The name of the desired index (either 'date' or 'startDate').
   * @param {Number|Date} date The date as a `Date` or the millisecond UTC epoch. When passed, this method will return
   * the array of event records for this date.
   * @param {Boolean} [returnKey] Specify `true` to return the date key along with the event record array.
   * @returns {Object|Scheduler.model.EventModel[]}
   */
  get(indexName, date, returnKey) {
    !this.initialized && this.initialize();
    let ret = this[indexNameMap[indexName]], key;
    if (date) {
      key = this.dayTime.dateKey(date);
      ret = returnKey ? [ret[key], key] : ret[key];
    }
    return ret;
  }
  /**
   * Called when this index is first used. Once called, further store changes will be used to maintain this index.
   * @private
   */
  initialize() {
    this.initialized = true;
    this.clear();
    this.sync("splice", this.store.storage.allValues);
  }
  invalidate() {
    this.initialized = false;
    indexProps.forEach((name) => this[name] = null);
  }
  /**
   * Returns `true` if the given `dayTime` matches this index.
   * @param {Core.util.DayTime} dayTime
   * @returns {Boolean}
   */
  matches(dayTime) {
    return this.dayTime.startShift === dayTime.startShift;
  }
  /**
   * Removes an event record from the specified index (either "startDate" or "date") for a given `date`.
   * @param {String} indexName The index to which the event record is to be removed (either "startDate" or "date").
   * @param {Date|Number} date A date for which the event record overlaps. The {@link Core.util.DayTime#function-dateKey}
   * method is used to convert this date to a "YYYY-MM-DD" key for the index.
   * @param {Scheduler.model.EventModel} eventRecord The event record.
   * @private
   */
  remove(indexName, date, eventRecord) {
    const index = this[indexNameMap[indexName]], key = this.dayTime.dateKey(date), entry = index[key];
    if (entry) {
      entry.delete(eventRecord);
    }
  }
  /**
   * Removes an event record from all indexes for all dates which the event overlaps.
   * @param {Scheduler.model.EventModel} eventRecord The event record.
   * @param {Date} startDate The start date for the event. This may be different from the `startDate` of the given
   * `eventRecord` when the event is rescheduled.
   * @param {Date} endDate The end date for the event. This may be different from the `endDate` of the given
   * `eventRecord` when the event is rescheduled.
   * @private
   */
  removeEvent(eventRecord, startDate, endDate) {
    var _a2, _b;
    let dateMS = (_a2 = this.dayTime.startOfDay(startDate)) == null ? void 0 : _a2.getTime(), endDateMS;
    if (dateMS) {
      endDateMS = (_b = endDate == null ? void 0 : endDate.getTime()) != null ? _b : dateMS;
      this.remove("startDate", dateMS, eventRecord);
      do {
        this.remove("date", dateMS, eventRecord);
        dateMS += MILLIS_PER_DAY2;
      } while (dateMS < endDateMS);
    }
  }
  sync(action, added, removed, replaced, wasSet) {
    var _a2, _b;
    added = added || emptyArray6;
    removed = removed || emptyArray6;
    const me = this, addedCount = added.length, removedCount = removed.length, replacedCount = replaced == null ? void 0 : replaced.length;
    let i, newEvent, outgoingEvent;
    if (!me.initialized) {
      return;
    }
    switch (action) {
      case "clear":
        me.clear();
        break;
      case "splice":
        if (replacedCount) {
          added = added.slice();
          removed = removed.slice();
          for (i = 0; i < replacedCount; i++) {
            removed.push(replaced[i][0]);
            added.push(replaced[i][1]);
          }
        }
        if (removedCount) {
          for (i = 0; i < removedCount; i++) {
            outgoingEvent = removed[i];
            me.removeEvent(outgoingEvent, outgoingEvent.startDate, outgoingEvent.endDate);
          }
        }
        if (addedCount) {
          for (i = 0; i < addedCount; i++) {
            newEvent = added[i];
            if (newEvent.isScheduled && !newEvent.isParent) {
              me.addEvent(newEvent);
            }
          }
        }
        break;
      case "reschedule":
        outgoingEvent = added[0];
        me.removeEvent(
          outgoingEvent,
          ((_a2 = wasSet.startDate) == null ? void 0 : _a2.oldValue) || outgoingEvent.startDate,
          ((_b = wasSet.endDate) == null ? void 0 : _b.oldValue) || outgoingEvent.endDate
        );
        me.sync("splice", added);
        break;
    }
  }
  /**
   * This method registers a `dayTime` instance with this index in the `users` array.
   * @param {Core.util.DayTime} dayTime The instance to register.
   */
  register(dayTime) {
    this.users.push(dayTime);
  }
  /**
   * This method unregisters a `dayTime` instance, removing it from the `users` array. This method returns `true` if
   * this was the last registered instance and this index is no longer needed.
   * @param {Core.util.DayTime} dayTime The instance to register.
   * @returns {Boolean}
   */
  unregister(dayTime) {
    const { users } = this, i = users.indexOf(dayTime);
    if (i > -1) {
      users.splice(i, 1);
    }
    return !users.length;
  }
};
var proto2 = EventDayIndex.prototype;
indexProps.forEach((name) => proto2[name] = null);
proto2.initialized = false;
EventDayIndex._$name = "EventDayIndex";

// ../Scheduler/lib/Scheduler/data/mixin/DayIndexMixin.js
var { MIDNIGHT } = DayTime;
var DayIndexMixin_default = (Target) => {
  var _a2;
  return _a2 = class extends Target {
    construct(config) {
      super.construct(config);
      this.dayIndices = null;
    }
    //region Keeping index in sync
    // Override to syncIndices on initial load
    afterLoadData() {
      var _a3;
      this.syncIndices("splice", this.storage.allValues);
      (_a3 = super.afterLoadData) == null ? void 0 : _a3.call(this);
    }
    /**
     * Responds to mutations of the underlying storage Collection.
     *
     * Maintain indices for fast finding of events by date.
     * @param {Object} event
     * @private
     */
    onDataChange({ action, added, removed, replaced }) {
      this.syncIndices(action, added, removed, replaced);
      super.onDataChange(...arguments);
    }
    onDataReplaced(action, data) {
      this.syncIndices("clear");
      this.syncIndices("splice", this.storage.values);
      super.onDataReplaced(action, data);
    }
    onModelChange(record, toSet, wasSet, silent, fromRelationUpdate) {
      if ("startDate" in wasSet || "endDate" in wasSet) {
        this.syncIndices("reschedule", [record], null, null, wasSet);
      }
      super.onModelChange(...arguments);
    }
    //endregion
    //region Index
    /**
     * Invalidates associated day indices.
     * @internal
     */
    invalidateDayIndices() {
      var _a3;
      (_a3 = this.dayIndices) == null ? void 0 : _a3.forEach((dayIndex) => dayIndex.invalidate());
    }
    /**
     * Registers a `DayTime` instance, creating an `EventDayIndex` for each distinct `startShift`. This index is
     * maintained until all instances with a matching `startShift` are {@link #function-unregisterDayIndex unregistered}.
     * @param {Core.util.DayTime} dayTime The instance to register.
     * @internal
     * @category Indexing
     */
    registerDayIndex(dayTime) {
      const me = this, dayIndices = me.dayIndices || (me.dayIndices = []);
      let dayIndex, i;
      for (i = 0; !dayIndex && i < dayIndices.length; ++i) {
        if (dayIndices[i].matches(dayTime)) {
          (dayIndex = dayIndices[i]).register(dayTime);
        }
      }
      !dayIndex && dayIndices.push(dayIndex = new EventDayIndex(me, dayTime));
      return dayIndex;
    }
    syncIndices(...args) {
      var _a3;
      (_a3 = this.dayIndices) == null ? void 0 : _a3.forEach((dayIndex) => dayIndex.sync(...args));
    }
    /**
     * Removes a registered `DayTime` instance. If this is the last instance registered to an `EventDayIndex`, that
     * index is removed.
     * @param {Core.util.DayTime} dayTime The instance to unregister.
     * @internal
     * @category Indexing
     */
    unregisterDayIndex(dayTime) {
      const me = this, { dayIndices } = me;
      for (let i = dayIndices == null ? void 0 : dayIndices.length; i-- > 0; ) {
        if (dayIndices[i].matches(dayTime)) {
          if (dayIndices[i].unregister(dayTime)) {
            dayIndices.splice(i, 1);
          }
          break;
        }
      }
    }
    /**
     * Returns the `EventDayIndex` to use for the given `DayTime` instance. This may be the primary instance or a
     * child instance created by {@link #function-registerDayIndex}.
     * @param {Core.util.DayTime} dayTime The `DayTime` of the desired index.
     * @returns {Scheduler.data.util.EventDayIndex}
     * @private
     * @category Indexing
     */
    useDayIndex(dayTime) {
      const me = this, { dayIndices } = me;
      dayTime = dayTime || MIDNIGHT;
      for (let i = 0; dayIndices && i < dayIndices.length; ++i) {
        if (dayIndices[i].matches(dayTime)) {
          return dayIndices[i];
        }
      }
      if (dayTime.startShift) {
        throw new Error(`No day index registered for ${dayTime} on ${me.id}`);
      }
      return me.registerDayIndex(MIDNIGHT);
    }
    //endregion
  }, __publicField(_a2, "$name", "DayIndexMixin"), _a2;
};

// ../Scheduler/lib/Scheduler/data/mixin/RecurringEventsMixin.js
var RecurringEventsMixin_default = (Target) => class RecurringEventsMixin extends RecurringTimeSpansMixin_default(Target || Base2) {
  static get $name() {
    return "RecurringEventsMixin";
  }
  /**
   * Returns all the recurring events.
   *
   * **An alias for ** {@link Scheduler.data.mixin.RecurringTimeSpansMixin#function-getRecurringTimeSpans} method.
   *
   * @returns {Scheduler.model.EventModel[]} Array of recurring events.
   * @category Recurrence
   */
  getRecurringEvents() {
    return this.getRecurringTimeSpans();
  }
  isEventPersistable(event) {
    return super.isEventPersistable(event) && (!event.supportsRecurring || !event.isOccurrence);
  }
};

// ../Scheduler/lib/Scheduler/model/mixin/EventModelMixin.js
var oneDayMS = 1e3 * 60 * 60 * 24;
var EventModelMixin_default = (Target) => class EventModelMixin extends Target {
  static get $name() {
    return "EventModelMixin";
  }
  // Flag checked by EventStore to make sure it uses a valid subclass
  static get isEventModel() {
    return true;
  }
  /**
   * Set value for the specified field(s), triggering engine calculations immediately. See
   * {@link Core.data.Model#function-set Model#set()} for arguments.
   *
   * ```javascript
   * eventRecord.set('duration', 4);
   * // eventRecord.endDate is not yet calculated
   *
   * await eventRecord.setAsync('duration', 4);
   * // eventRecord.endDate is calculated
   * ```
   *
   * @param {String|Object} field The field to set value for, or an object with multiple values to set in one call
   * @param {*} value Value to set
   * @param {Boolean} [silent=false] Set to true to not trigger events. If event is recurring, occurrences won't be updated
   * automatically.
   * @function setAsync
   * @category Editing
   * @async
   */
  //region Fields
  static get fields() {
    return [
      /**
       * The start date of a time span (or Event / Task).
       *
       * Uses {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat} to convert a
       * supplied string to a Date. To specify another format, either change that setting or subclass TimeSpan and
       * change the dateFormat for this field.
       *
       * UI fields representing this data field are disabled for summary tasks. See {@link #function-isEditable}
       * for details.
       *
       * Note that the field always returns a `Date`.
       *
       * Also note that modifying the `startDate` at runtime will move the event in time, without affecting its
       * duration (with reservation for other scheduling logic affecting the duration). If you want to change the
       * `startDate` and `duration`, use {@link Scheduler/model/TimeSpan#function-setStartDate} instead (passing
       * `false` as the second argument).
       *
       * @field {Date} startDate
       * @accepts {String|Date}
       * @category Scheduling
       */
      /**
       * The end date of a time span (or Event / Task).
       *
       * Uses {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat} to convert a
       * supplied string to a Date. To specify another format, either change that setting or subclass TimeSpan and
       * change the dateFormat for this field.
       *
       * UI fields representing this data field are disabled for summary tasks. See {@link #function-isEditable} for details.
       *
       * Note that the field always returns a `Date`.
       *
       * @field {Date} endDate
       * @accepts {String|Date}
       * @category Scheduling
       */
      /**
       * The numeric part of the timespan's duration (the number of units).
       *
       * UI fields representing this data field are disabled for summary tasks. See {@link #function-isEditable}
       * for details.
       *
       * @field {Number} duration
       * @category Scheduling
       */
      /**
       * Calculated field which encapsulates the duration's magnitude and unit. This field will not be persisted,
       * setting it will update the {@link #field-duration} and
       * {@link Scheduler.model.TimeSpan#field-durationUnit} fields.
       *
       * UI fields representing this data field are disabled for summary tasks. See {@link #function-isEditable}
       * for details.
       *
       * @field {DurationConfig|Core.data.Duration} fullDuration
       * @category Scheduling
       */
      /**
       * The unique identifier of a task (mandatory)
       * @field {String|Number} id
       * @category Common
       */
      /**
       * Id of the resource this event is associated with (only usable for single assignments). We recommend
       * using assignments in an AssignmentStore over this approach. Internally any Event using `resourceId`
       * will have an assignment in AssignmentStore generated.
       * @field {String|Number} resourceId
       * @category Common
       */
      {
        name: "resourceId",
        internal: true
      },
      /**
       * Ids of the resources this event is associated with (can be used for for multiple assignments).
       * Any event using `resourceIds` will have assignments in AssignmentStore generated automatically.
       * It only applies if is configured with `perist: true`.
       * ```javascript
       *   class CustomEventModel extends EventModel {
       *       static get $name() {
       *           return 'CustomEventModel';
       *       }
       *
       *       static get fields() {
       *           return [
       *               { name : 'resourceIds', persist : true }
       *           ];
       *       }
       *   };
       *
       *   const
       *       resources   = [
       *           { id : 'r1', name : 'Celia' },
       *           { id : 'r2', name : 'Lee' },
       *           { id : 'r3', name : 'Macy' },
       *           { id : 'r4', name : 'Madison' }
       *       ],
       *       events      = [
       *           {
       *               id          : 1,
       *               resourceIds : ['r1', 'r2']
       *               ...
       *           },
       *           {
       *               id          : 2,
       *               resourceIds : ['r3', 'r4']
       *               ...
       *           }
       *       ];
       *
       *   const scheduler = new Scheduler({
       *       ...
       *       eventStore : {
       *           modelClass : CustomEventModel,
       *           data       : events
       *       },
       *       ...
       *   });
       * ```
       * @field {String[]|Number[]} resourceIds
       * @category Common
       */
      {
        name: "resourceIds",
        type: "array",
        persist: false,
        internal: true
      },
      /**
       * The array of {@link Scheduler.model.ResourceModel resources} which are assigned to this event.
       * @field {String|Number} resources
       * @category Common
       */
      {
        name: "resources",
        column: {
          type: "resourceassignment"
        },
        persist: false,
        internal: true,
        useProp: true
      },
      /**
       * Specify false to prevent the event from being dragged (if EventDrag feature is used)
       * @field {Boolean} draggable
       * @default true
       * @category Interaction
       */
      {
        name: "draggable",
        type: "boolean",
        persist: false,
        defaultValue: true,
        internal: true
      },
      /**
       * Specify `false` to prevent the event from being resized (if EventResize feature is used). You can also
       * specify `'start'` or `'end'` to only allow resizing in one direction
       * @field {Boolean|String} resizable
       * @default true
       * @category Interaction
       */
      {
        name: "resizable",
        persist: false,
        defaultValue: true,
        internal: true
      },
      // true, false, 'start' or 'end'
      /**
       * A field marking event as all day(s) spanning event.
       * For example, a holiday day may be represented by a `startDate`, and the `allDay` flag.
       * @field {Boolean} allDay
       * @category Scheduling
       */
      {
        name: "allDay",
        type: "boolean",
        defaultValue: false
      },
      /**
       * Controls this events appearance, see Schedulers
       * {@link Scheduler.view.mixin.TimelineEventRendering#config-eventStyle eventStyle config} for
       * available options.
       * @field {'plain'|'border'|'colored'|'hollow'|'line'|'dashed'|'minimal'|'rounded'|'calendar'|'interday'|null} eventStyle
       * @category Styling
       */
      {
        name: "eventStyle",
        internal: true
      },
      /**
       * Controls the primary color of the event. For available standard colors, see
       * {@link #typedef-EventColor}.
       * @field {EventColor|String|null} eventColor
       * @category Styling
       */
      {
        name: "eventColor",
        internal: true
      },
      /**
       * Width (in px) to use for this milestone when using Scheduler#milestoneLayoutMode 'data'.
       * @field {Number} milestoneWidth
       * @category Styling
       */
      {
        name: "milestoneWidth",
        internal: true
      },
      /**
       * Set this field to `false` to opt out of {@link Scheduler.feature.StickyEvents sticky event content}
       * (keeping event text in view while scrolling).
       * @field {Boolean} stickyContents
       * @category Styling
       */
      {
        name: "stickyContents",
        internal: true
      }
    ];
  }
  //endregion
  //region Id change
  updateAssignmentEventIds() {
    this.assigned.forEach((assignment) => {
      assignment.eventId = this.id;
    });
  }
  syncId(value) {
    super.syncId(value);
    this.updateAssignmentEventIds();
  }
  //endregion
  //region Resources
  /**
   * Returns all resources assigned to an event.
   *
   * @property {Scheduler.model.ResourceModel[]}
   * @category Assignments & Resources
   * @readonly
   */
  get resources() {
    return this.assignments.reduce((resources, { resource }) => {
      resource && resources.push(resource.$original);
      return resources;
    }, []);
  }
  set resources(resources) {
    var _a2;
    resources = ArrayHelper.asArray(resources);
    const me = this, newResourceIds = resources.map(me.constructor.asId);
    if (me.usesSingleAssignment) {
      me.set("resourceId", newResourceIds[0]);
    } else if ((_a2 = me.fieldMap) == null ? void 0 : _a2.resourceIds.persist) {
      me.resourceIds = newResourceIds;
    } else {
      const existingResourceIds = me.assignments.map((a) => a.resource.id), { onlyInA: toAdd, onlyInB: toRemove } = ArrayHelper.delta(newResourceIds, existingResourceIds);
      me.assignmentStore.add(toAdd.map((resourceId) => ({ resource: resourceId, event: me })));
      me.assignmentStore.remove(toRemove.map((resourceId) => me.assignments.find((a) => a.resource.id === resourceId)));
    }
  }
  /**
   * Iterate over all associated resources
   * @private
   * @category Assignments & Resources
   */
  forEachResource(fn2, thisObj = this) {
    for (const resource of this.resources) {
      if (fn2.call(thisObj, resource) === false) {
        return;
      }
    }
  }
  /**
   * Returns either the resource associated with this event (when called w/o `resourceId`) or resource
   * with specified id.
   *
   * @param {String} [resourceId] To retrieve a specific resource
   * @returns {Scheduler.model.ResourceModel}
   * @category Assignments & Resources
   */
  getResource(resourceId) {
    if (resourceId == null) {
      return this.resource;
    }
    return this.resourceStore ? this.resourceStore.getById(resourceId) : null;
  }
  //endregion
  //region Dates
  get startDate() {
    var _a2;
    let dt;
    if (this.isOccurrence) {
      dt = this.get("startDate");
    } else {
      dt = (_a2 = this._startDate) != null ? _a2 : super.startDate;
    }
    if (this.allDay) {
      dt = this.constructor.getAllDayStartDate(dt);
    }
    return dt;
  }
  set startDate(startDate) {
    if (this.batching) {
      this._startDate = startDate;
      this.set({ startDate });
    } else {
      super.startDate = startDate;
    }
  }
  get endDate() {
    var _a2;
    let dt;
    if (this.isOccurrence) {
      dt = this.get("endDate");
    } else {
      dt = (_a2 = this._endDate) != null ? _a2 : super.endDate;
    }
    if (this.allDay) {
      dt = this.constructor.getAllDayEndDate(dt);
    }
    return dt;
  }
  set endDate(endDate) {
    if (this.batching) {
      this._endDate = endDate;
      this.set({ endDate });
    } else {
      super.endDate = endDate;
    }
  }
  // Cannot use `convert` method because it might be disabled by `useRawData : true` and we always need to calculate
  // that value
  get wrapStartDate() {
    return this.startDate;
  }
  set wrapStartDate(value) {
  }
  get wrapEndDate() {
    return this.endDate;
  }
  set wrapEndDate(value) {
  }
  /**
   * Shift the dates for the date range by the passed amount and unit
   * @param {'ms'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} unit The unit to shift by, see {@link Core.helper.DateHelper}
   * for more information on valid formats.
   * @param {Number} amount The amount to shift
   * @returns {Promise} A promise which is resolved when shift calculations are done
   * @async
   * @method shift
   * @category Scheduling
   */
  //endregion
  //region Is
  // Used internally to differentiate between Event and ResourceTimeRange
  get isEvent() {
    return true;
  }
  /**
   * Returns true if event can be drag and dropped
   * @property {Boolean}
   * @category Editing
   */
  get isDraggable() {
    return !this.readOnly && this.draggable;
  }
  /**
   * Returns true if event can be resized, but can additionally return 'start' or 'end' indicating how this event can
   * be resized.
   *
   * Milestones and parent events (that are not manuallyScheduled) cannot be resized.
   *
   * @property {Boolean|String}
   * @readonly
   * @category Editing
   */
  get isResizable() {
    return !this.isMilestone && (!this.isParent || this.manuallyScheduled) && this.resizable;
  }
  /**
   * Returns false if the event is not persistable. By default it always is, override this getter if you need
   * custom logic.
   *
   * @property {Boolean}
   * @readonly
   * @category Editing
   */
  get isPersistable() {
    return super.isPersistable && !this.isCreating;
  }
  endBatch() {
    const me = this, { isPersistable: wasPersistable, meta: { batchChanges } } = me;
    if (batchChanges) {
      if ("endDate" in batchChanges) {
        delete me._endDate;
        if (me.postamble) {
          me.wrapEndDate = null;
        }
      }
      if ("startDate" in batchChanges) {
        delete me._startDate;
        if (me.preamble) {
          me.wrapStartDate = null;
        }
      }
    }
    super.endBatch(...arguments);
    if (me.isPersistable && !wasPersistable && !me.ignoreBag && me.assigned) {
      for (const assignment of me.assigned) {
        assignment.stores.forEach(
          (s) => s.updateModifiedBagForRecord(assignment)
        );
      }
    }
  }
  get isCreating() {
    return super.isCreating;
  }
  set isCreating(value) {
    var _a2, _b;
    super.isCreating = value;
    (_a2 = this.assignmentStore) == null ? void 0 : _a2.suspendAutoCommit();
    this.assignments.forEach((record) => record.isCreating = value);
    (_b = this.assignmentStore) == null ? void 0 : _b.resumeAutoCommit();
  }
  //endregion
  //region Single assignment compatibility
  get usesSingleAssignment() {
    return !this.eventStore || this.eventStore.usesSingleAssignment;
  }
  copy(...args) {
    const copy = super.copy(...args);
    if (!this.usesSingleAssignment) {
      copy.resourceId = null;
    }
    return copy;
  }
  /**
   * Override persistable getter to prevent sending resourceId when using multiple resource assignment mode
   * https://github.com/bryntum/support/issues/1345
   * @private
   */
  get persistableData() {
    const data = super.persistableData;
    if (!this.usesSingleAssignment) {
      delete data.resourceId;
    }
    return data;
  }
  /**
   * Returns the first assigned resource, or assigns a resource
   * @member {Scheduler.model.ResourceModel} resource
   * @category Assignments & Resources
   */
  get resource() {
    const { resources } = this;
    return resources.length ? resources[0] : null;
  }
  set resource(resourceRecord) {
    this.resourceId = this.constructor.asId(resourceRecord);
  }
  get resourceId() {
    var _a2;
    return this.usesSingleAssignment ? this.get("resourceId") : (_a2 = this.resource) == null ? void 0 : _a2.id;
  }
  set resourceId(resourceId) {
    this.applyResourceId(resourceId);
  }
  get resourceIds() {
    var _a2, _b, _c;
    if ((_a2 = this.fieldMap) == null ? void 0 : _a2.resourceIds.persist) {
      return this.get("resourceIds");
    } else {
      return (_c = (_b = this.resources) == null ? void 0 : _b.map((r) => r.id)) != null ? _c : [];
    }
  }
  set resourceIds(ids) {
    this.set("resourceIds", ids);
  }
  // Resources + any links to any of them
  get $linkedResources() {
    var _a2, _b;
    return (_b = (_a2 = this.resources) == null ? void 0 : _a2.flatMap((resourceRecord) => [
      resourceRecord,
      ...resourceRecord.$links
    ])) != null ? _b : [];
  }
  applyResourceId(resourceId, fromApplyValue = false) {
    var _a2, _b;
    const me = this, { eventStore, assignments } = me;
    if (eventStore) {
      const assignmentStore = eventStore.assignmentStore || ((_a2 = eventStore.crudManager) == null ? void 0 : _a2.assignmentStore);
      if (resourceId != null) {
        if (!me.meta.skipEnforcingSingleAssignment) {
          eventStore.usesSingleAssignment = true;
        }
        if ((assignments == null ? void 0 : assignments.length) && resourceId !== assignments[0].resourceId) {
          const eventsSuspended = Boolean(eventStore.eventsSuspended);
          eventsSuspended && assignmentStore.suspendEvents();
          assignments[0].resource = resourceId;
          eventsSuspended && assignmentStore.resumeEvents();
        } else {
          assignmentStore.assignEventToResource(me, resourceId);
        }
      } else if (me.usesSingleAssignment || ((_b = me.resourceIds) == null ? void 0 : _b.length)) {
        assignmentStore.remove(assignments);
      }
    } else if (!fromApplyValue) {
      me.set({ resourceId });
    }
  }
  applyResourceIds(resourceIds, fromApplyValue = false) {
    var _a2;
    const me = this, { eventStore, assignments } = me;
    if (me.fieldMap["resourceIds"].persist === false) {
      return false;
    }
    resourceIds = [...new Set(resourceIds)];
    if (eventStore) {
      const assignmentStore = eventStore.assignmentStore || ((_a2 = eventStore.crudManager) == null ? void 0 : _a2.assignmentStore);
      if (resourceIds == null ? void 0 : resourceIds.length) {
        if (assignments == null ? void 0 : assignments.length) {
          const eventsSuspended = Boolean(eventStore.eventsSuspended);
          eventsSuspended && assignmentStore.suspendEvents();
          assignments.forEach((assignment) => {
            const resourceIdToUpdate = resourceIds.find((resourceId) => !assignments.some((a) => a.resourceId === resourceId));
            if (resourceIdToUpdate) {
              assignment.resource = resourceIdToUpdate;
            }
          });
          const { onlyInA: toAdd, onlyInB: toRemove } = ArrayHelper.delta(resourceIds, assignments.map((assignment) => assignment.resourceId));
          assignmentStore.add(toAdd.map((resourceId) => ({ resource: resourceId, event: me })));
          assignmentStore.remove(toRemove.map((resourceId) => assignments.find((a) => a.resource.id === resourceId)));
          eventsSuspended && assignmentStore.resumeEvents();
        } else {
          assignmentStore.add(resourceIds.map((resourceId) => ({ resource: resourceId, event: me })));
        }
      } else {
        assignmentStore.remove(assignments);
      }
    } else if (!fromApplyValue) {
      me.set({ resourceIds });
    }
  }
  // Special handling of setting resourceId and resourceIds, creates assignment
  applyValue(useProp, mapping, value, skipAccessors, field2) {
    if (field2 && !this.meta.isAssigning) {
      const { eventStore } = this;
      switch (field2.name) {
        case "resourceId":
          eventStore && (eventStore.isAssigning = true);
          this.applyResourceId(value, true);
          break;
        case "resourceIds":
          eventStore && (eventStore.isAssigning = true);
          this.applyResourceIds(value, true);
          break;
      }
      eventStore && (eventStore.isAssigning = false);
    }
    super.applyValue(useProp, mapping, value, skipAccessors, field2);
  }
  //endregion
  //region Assignment
  /**
   * Returns all assignments for the event. Event must be part of the store for this method to work.
   * @property {Scheduler.model.AssignmentModel[]}
   * @readonly
   * @category Assignments & Resources
   */
  get assignments() {
    return [...this.assigned || []];
  }
  /**
   * Assigns this event to the specified resource.
   *
   * *Note:* The event must be part of an EventStore for this to work. If the EventStore uses single assignment
   * (loaded using resourceId) existing assignments will always be removed.
   *
   * @param {Scheduler.model.ResourceModel|String|Number|Scheduler.model.ResourceModel[]|String[]|Number[]} resource A new resource for this event, either as a full
   *        Resource record or an id (or an array of such).
   * @param {Boolean} [removeExistingAssignments] `true` to first remove existing assignments
   * @category Assignments & Resources
   */
  assign(resource, removeExistingAssignments = false) {
    const { eventStore } = this;
    if (eventStore && !eventStore.usesSingleAssignment) {
      eventStore.assignEventToResource(this, resource, removeExistingAssignments);
    } else {
      this.resourceId = this.constructor.asId(resource);
      if (!eventStore) {
        this.meta.skipEnforcingSingleAssignment = true;
      }
    }
  }
  /**
   * Unassigns this event from the specified resource
   *
   * @param {Scheduler.model.ResourceModel|String|Number} [resource] The resource to unassign from.
   * @category Assignments & Resources
   */
  unassign(resource, removingResource = false) {
    var _a2;
    const me = this;
    resource = me.constructor.asId(resource);
    me.meta.removingResource = removingResource;
    (_a2 = me.eventStore) == null ? void 0 : _a2.unassignEventFromResource(me, resource);
    me.meta.removingResource = null;
  }
  /**
   * Reassigns an event from an old resource to a new resource
   *
   * @param {Scheduler.model.ResourceModel|String|Number} oldResourceId A resource to unassign from or its id
   * @param {Scheduler.model.ResourceModel|String|Number} newResourceId A resource to assign to or its id
   * @category Assignments & Resources
   */
  reassign(oldResourceId, newResourceId) {
    this.eventStore && this.eventStore.reassignEventFromResourceToResource(this, oldResourceId, newResourceId);
  }
  /**
   * Returns true if this event is assigned to a certain resource.
   *
   * @param {Scheduler.model.ResourceModel|String|Number} resource The resource to query for
   * @returns {Boolean}
   * @category Assignments & Resources
   */
  isAssignedTo(resource) {
    const resourceId = this.constructor.asId(resource);
    return this.assignments.some((assignment) => assignment.resourceId === resourceId);
  }
  //endregion
  //region Dependencies
  /**
   * Returns all predecessor dependencies of this event
   *
   * @readonly
   * @property {Scheduler.model.DependencyBaseModel[]}
   * @category Dependencies
   */
  get predecessors() {
    var _a2;
    return [...(_a2 = this.incomingDeps) != null ? _a2 : []];
  }
  /**
   * Returns all successor dependencies of this event
   *
   * @readonly
   * @property {Scheduler.model.DependencyBaseModel[]}
   * @category Dependencies
   *
   */
  get successors() {
    var _a2;
    return [...(_a2 = this.outgoingDeps) != null ? _a2 : []];
  }
  get dependencies() {
    var _a2, _b;
    return [...(_a2 = this.incomingDeps) != null ? _a2 : [], ...(_b = this.outgoingDeps) != null ? _b : []];
  }
  //endregion
  normalize() {
  }
  inSetNormalize() {
  }
  /**
   * The "main" event this model is an occurrence of.
   * Returns `null` for non-occurrences.
   * @property {Scheduler.model.EventModel}
   * @alias #Scheduler.model.mixin.RecurringTimeSpan#property-recurringTimeSpan
   * @readonly
   * @category Scheduling
   */
  get recurringEvent() {
    return this.recurringTimeSpan;
  }
  /**
   * Flag which indicates that this event is an interday event. This means that it spans
   * an entire day or multiple days.
   *
   * This is essentially used by the Calendar package to determine if an event should
   * go into the all day zone of a DayView.
   *
   * @property {Boolean}
   * @readonly
   * @category Scheduling
   */
  get isInterDay() {
    const { durationMS } = this;
    if (durationMS >= oneDayMS || !durationMS && this.allDay) {
      return true;
    }
    const {
      endDate,
      startDate
    } = this, eventStartMidnight = DateHelper.clearTime(startDate);
    if (startDate && endDate) {
      eventStartMidnight.setDate(eventStartMidnight.getDate() + 1);
      return (endDate || DateHelper.add(startDate, durationMS)) > eventStartMidnight;
    }
  }
  //region All day statics
  static getAllDayStartDate(dt) {
    if (dt && dt.isEvent) {
      dt = dt.get("startDate");
    }
    if (dt) {
      dt = DateHelper.clearTime(dt, true);
    }
    return dt;
  }
  static getAllDayEndDate(dt) {
    if (dt && dt.isEvent) {
      dt = dt.get("endDate");
    }
    if (dt && (dt.getHours() > 0 || dt.getMinutes() > 0 || dt.getSeconds() > 0 || dt.getMilliseconds() > 0)) {
      dt = DateHelper.getNext(dt, "d", 1);
    }
    return dt;
  }
  static getAllDayDisplayStartDate(dt) {
    if (dt && dt.isEvent) {
      dt = dt.get("startDate");
    }
    return DateHelper.clearTime(dt, true);
  }
  static getAllDayDisplayEndDate(startDate, endDate) {
    if (startDate && startDate.isEvent) {
      endDate = startDate.get("endDate");
      startDate = startDate.get("startDate");
    }
    if (endDate) {
      startDate = this.constructor.getAllDayDisplayStartDate(startDate);
      if (DateHelper.clearTime(endDate, true).valueOf() === endDate.valueOf()) {
        endDate = DateHelper.add(endDate, DateHelper.DAY, -1);
      } else if (startDate.valueOf() !== endDate.valueOf()) {
        endDate = DateHelper.clearTime(endDate, true);
      }
    }
    return endDate;
  }
  /**
   * Defines if the given event field should be manually editable in UI.
   * You can override this method to provide your own logic.
   *
   * By default, the method defines {@link #field-endDate}, {@link #field-duration} and {@link #field-fullDuration}
   * fields editable for leaf events only (in case the event is part of a tree store) and all other fields as
   * editable.
   *
   * @param {String} fieldName Name of the field
   * @returns {Boolean} Returns `true` if the field is editable, `false` if it is not and `undefined` if the event has
   * no such field.
   * @category Editing
   */
  isEditable(fieldName) {
    switch (fieldName) {
      case "endDate":
      case "duration":
      case "fullDuration":
        return this.isLeaf;
    }
    return super.isEditable(fieldName);
  }
  //endregion
};

// ../Scheduler/lib/Scheduler/model/EventModel.js
var EngineMixin3 = SchedulerCoreEvent;
var EventModel = class extends EngineMixin3.derive(TimeSpan).mixin(
  RecurringTimeSpan_default,
  PartOfProject_default,
  EventModelMixin_default
) {
  static get $name() {
    return "EventModel";
  }
};
EventModel.exposeProperties();
EventModel._$name = "EventModel";

// ../Scheduler/lib/Scheduler/data/EventStore.js
var EngineMixin4 = PartOfProject_default(CoreEventStoreMixin.derive(AjaxStore));
var EventStore = class extends EngineMixin4.mixin(
  RecurringEventsMixin_default,
  EventStoreMixin_default,
  DayIndexMixin_default,
  GetEventsMixin_default
) {
  static get defaultConfig() {
    return {
      /**
       * Class used to represent records
       * @config {Scheduler.model.EventModel}
       * @typings {typeof EventModel}
       * @default
       * @category Common
       */
      modelClass: EventModel
    };
  }
};
__publicField(EventStore, "$name", "EventStore");
EventStore._$name = "EventStore";

// ../Scheduler/lib/Scheduler/data/mixin/ResourceStoreMixin.js
var ResourceStoreMixin_default = (Target) => class ResourceStoreMixin extends (Target || Base2) {
  static get $name() {
    return "ResourceStoreMixin";
  }
  get isResourceStore() {
    return true;
  }
  /**
   * Add resources to the store.
   *
   * NOTE: References (events, assignments) on the resources are determined async by a calculation engine. Thus they
   * cannot be directly accessed after using this function.
   *
   * For example:
   *
   * ```javascript
   * const [resource] = resourceStore.add({ id });
   * // resource.events is not yet available
   * ```
   *
   * To guarantee references are set up, wait for calculations for finish:
   *
   * ```javascript
   * const [resource] = resourceStore.add({ id });
   * await resourceStore.project.commitAsync();
   * // resource.events is available (assuming EventStore is loaded and so on)
   * ```
   *
   * Alternatively use `addAsync()` instead:
   *
   * ```javascript
   * const [resource] = await resourceStore.addAsync({ id });
   * // resource.events is available (assuming EventStore is loaded and so on)
   * ```
   *
   * @param {Scheduler.model.ResourceModel|Scheduler.model.ResourceModel[]|ResourceModelConfig|ResourceModelConfig[]} records
   * Array of records/data or a single record/data to add to store
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Scheduler.model.ResourceModel[]} Added records
   * @function add
   * @category CRUD
   */
  /**
   * Add resources to the store and triggers calculations directly after. Await this function to have up to date
   * references on the added resources.
   *
   * ```javascript
   * const [resource] = await resourceStore.addAsync({ id });
   * // resource.events is available (assuming EventStore is loaded and so on)
   * ```
   *
   * @param {Scheduler.model.ResourceModel|Scheduler.model.ResourceModel[]|ResourceModelConfig|ResourceModelConfig[]} records
   * Array of records/data or a single record/data to add to store
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Scheduler.model.ResourceModel[]} Added records
   * @function addAsync
   * @category CRUD
   * @async
   */
  /**
   * Applies a new dataset to the ResourceStore. Use it to plug externally fetched data into the store.
   *
   * NOTE: References (events, assignments) on the resources are determined async by a calculation engine. Thus
   * they cannot be directly accessed after assigning the new dataset.
   *
   * For example:
   *
   * ```javascript
   * resourceStore.data = [{ id }];
   * // resourceStore.first.events is not yet available
   * ```
   *
   * To guarantee references are available, wait for calculations for finish:
   *
   * ```javascript
   * resourceStore.data = [{ id }];
   * await resourceStore.project.commitAsync();
   * // resourceStore.first.events is available
   * ```
   *
   * Alternatively use `loadDataAsync()` instead:
   *
   * ```javascript
   * await resourceStore.loadDataAsync([{ id }]);
   * // resourceStore.first.events is available
   * ```
   *
   * @member {ResourceModelConfig[]} data
   * @category Records
   */
  /**
   * Applies a new dataset to the ResourceStore and triggers calculations directly after. Use it to plug externally
   * fetched data into the store.
   *
   * ```javascript
   * await resourceStore.loadDataAsync([{ id }]);
   * // resourceStore.first.events is available
   * ```
   *
   * @param {ResourceModelConfig[]} data Array of ResourceModel data objects
   * @function loadDataAsync
   * @category CRUD
   * @async
   */
  static get defaultConfig() {
    return {
      /**
       * CrudManager must load stores in the correct order. Lowest first.
       * @private
       */
      loadPriority: 200,
      /**
       * CrudManager must sync stores in the correct order. Lowest first.
       * @private
       */
      syncPriority: 100,
      storeId: "resources",
      autoTree: true
    };
  }
  construct(config) {
    super.construct(config);
    if (!this.modelClass.isResourceModel) {
      throw new Error("Model for ResourceStore must subclass ResourceModel");
    }
  }
  removeAll() {
    const result = super.removeAll(...arguments);
    result && this.assignmentStore.removeAll();
    return result;
  }
  // Apply id changes also to assignments (used to be handled automatically by relations earlier, but engine does not
  // care about ids so needed now)
  // problems:
  // 1. orientation/HorizontalRendering listens to assignment store changes and is trying to refresh view
  // When we update resource id on assignment, listener will be invoked and view will try to refresh. And it will
  // fail, because row is not updated yet. Flag is raised on resource store to make HorizontalRendering to skip
  // refreshing view in this particular case of resource id changing
  onRecordIdChange({ record, oldValue, value }) {
    super.onRecordIdChange({ record, oldValue, value });
    if (record.isFieldModified("id")) {
      this.isChangingId = true;
      record.updateAssignmentResourceIds();
      this.isChangingId = false;
    }
  }
  // Cache used by VerticalRendering, reset from there
  get allResourceRecords() {
    return this._allResourceRecords || (this._allResourceRecords = this.getAllDataRecords());
  }
  /**
   * Returns all resources that have no events assigned during the specified time range.
   * @param {Date} startDate Time range start date
   * @param {Date} endDate Time range end date
   * @returns {Scheduler.model.ResourceModel[]} Resources without events
   */
  getAvailableResources({ startDate, endDate }) {
    return this.query((resource) => this.eventStore.isDateRangeAvailable(startDate, endDate, null, resource));
  }
};

// ../Scheduler/lib/Scheduler/model/mixin/ResourceModelMixin.js
var ResourceModelMixin_default = (Target) => class ResourceModelMixin extends Target {
  static get $name() {
    return "ResourceModelMixin";
  }
  // Flag checked by ResourceStore to make sure it uses a valid subclass
  static get isResourceModel() {
    return true;
  }
  /**
   * Set value for the specified field(s), triggering engine calculations immediately. See
   * {@link Core.data.Model#function-set Model#set()} for arguments.
   *
   * This does not matter much on the resource itself, but is of importance when manipulating its references:
   *
   * ```javascript
   * assignment.set('resourceId', 2);
   * // resource.assignments is not yet up to date
   *
   * await assignment.setAsync('resourceId', 2);
   * // resource.assignments is up to date
   * ```
   *
   * @param {String|Object} field The field to set value for, or an object with multiple values to set in one call
   * @param {*} value Value to set
   * @param {Boolean} [silent=false] Set to true to not trigger events
   * automatically.
   * @function setAsync
   * @category Editing
   * @async
   */
  //region Fields
  static get fields() {
    return [
      /**
       * Unique identifier
       * @field {String|Number} id
       * @category Common
       */
      /**
       * Get or set resource name
       * @field {String} name
       * @category Common
       */
      { name: "name", type: "string", persist: true },
      /**
       * Controls the primary color used for events assigned to this resource. Can be overridden per event using
       * EventModels {@link Scheduler.model.mixin.EventModelMixin#field-eventColor eventColor config}. Also, see
       * Schedulers {@link Scheduler.view.mixin.TimelineEventRendering#config-eventColor eventColor config}.
       *
       * For available standard colors, see
       * {@link Scheduler.model.mixin.EventModelMixin#typedef-EventColor}.
       *
       * @field {EventColor} eventColor
       * @category Styling
       */
      "eventColor",
      /**
       * Controls the style used for events assigned to this resource. Can be overridden per event using
       * EventModels {@link Scheduler/model/mixin/EventModelMixin#field-eventStyle eventStyle config}. See Schedulers
       * {@link Scheduler.view.mixin.TimelineEventRendering#config-eventStyle eventStyle config} for available
       * options.
       * @field {String} eventStyle
       * @category Styling
       */
      "eventStyle",
      /**
       * Fully qualified image URL, used by `ResourceInfoColumn` and vertical modes `ResourceHeader` to display a miniature image
       * for the resource.
       * @field {String} imageUrl
       * @category Styling
       */
      "imageUrl",
      /**
       * Image name relative to {@link Scheduler/view/mixin/SchedulerEventRendering#config-resourceImagePath},
       * used by `ResourceInfoColumn` and vertical modes `ResourceHeader` to display a miniature image
       * for the resource.
       * Set value to `false` to disable image display.
       * @field {String|Boolean} image
       * @category Styling
       */
      "image",
      /**
       * Margin from rows edge to topmost event bar for this resource, in px.
       * @field {Number} resourceMargin
       * @category Layout
       */
      { name: "resourceMargin", type: "number" },
      /**
       * Margin between stacked event bars for this resource, in px.
       * @field {Number} barMargin
       * @category Layout
       */
      { name: "barMargin", type: "number" },
      /**
       * Base height of this resource, in px. When unset, Schedulers configured rowHeight is used.
       *
       * This value is used in horizontal mode to determine row height. When stacking, it is used as input for
       * calculating the actual row height:
       *
       * ```javascript
       * row.height = (resource.rowHeight - resourceMargin * 2) * overlap count - barMargin * (overlap count - 1)
       * ```
       *
       * When packing or overlapping, it is used as the actual row height.
       *
       * @field {Number} rowHeight
       * @category Layout
       */
      /**
       * Base width of this resource, in px. If not set, the `columnWidth` specified in
       * the Scheduler's configured {@link Scheduler.view.Scheduler#config-resourceColumns} is used.
       *
       * This value is used in vertical mode to determine column width.
       *
       * @field {Number} columnWidth
       * @category Layout
       */
      /**
       * Specify this to use a resource specific event layout in horizontal mode, see
       * {@link Scheduler.view.mixin.SchedulerEventRendering#config-eventLayout} for options.
       *
       * When unset (the default) Schedulers setting is used.
       *
       * @field {'stack'|'pack'|'mixed'|'none'} eventLayout
       * @category Layout
       */
      "eventLayout"
    ];
  }
  //endregion
  //region Id change
  updateAssignmentResourceIds() {
    this.assigned.forEach((assignment) => {
      assignment.resourceId = this.id;
    });
  }
  syncId(value) {
    super.syncId(value);
    this.updateAssignmentResourceIds();
  }
  //endregion
  //region Getters
  // Documented in Scheduler.model.ResourceModel, SchedulerPro.model.ResourceModel, Gantt.model.ResourceModel
  get events() {
    return this.assignments.reduce((events, assignment) => {
      if (assignment.event) {
        events.push(assignment.event);
      }
      return events;
    }, []);
  }
  /**
   * Returns all assignments for the resource
   *
   * @property {Scheduler.model.AssignmentModel[]}
   * @category Common
   */
  get assignments() {
    return this.assigned ? [...this.assigned] : [];
  }
  set assignments(assignments) {
    assignments.forEach((assignment) => {
      assignment.resource = this;
    });
  }
  /**
   * Returns an array of events, associated with this resource
   *
   * @deprecated 5.3.6 Use the events property instead
   *
   * @returns {Scheduler.model.EventModel[]}
   */
  getEvents() {
    VersionHelper.deprecate("scheduler", "6.0.0", "getEvents() is deprecated, use the events property instead");
    return this.events;
  }
  /**
   * Returns `true` if the resource can be persisted.
   * In a flat store, a resource is always considered persistable. In a tree store, a resource is considered
   * persistable if its parent node is persistable.
   *
   * @property {Boolean}
   * @readonly
   * @category Editing
   */
  get isPersistable() {
    return super.isPersistable && (!this.parent || this.parent.isPersistable);
  }
  //endregion
  /**
   * Unassigns this Resource from all its Events
   */
  unassignAll() {
    this.assignments && this.assignmentStore.remove(this.assignments);
  }
  /**
   * Returns the initials (first letter of the first & last space-separated word in the name) or an empty string
   * if this resource has no name. You can override this method in a ResourceModel subclass to provide your own implementation
   *
   * @property {String}
   * @readonly
   * @category Common
   */
  get initials() {
    const { name = "" } = this;
    if (!name) {
      return "";
    }
    const names = name.split(" "), firstInitial = names[0][0], lastInitial = names.length > 1 ? names[names.length - 1][0] : "";
    return firstInitial + lastInitial;
  }
  isWorkingTime(date) {
    var _a2, _b;
    const calendar = this.effectiveCalendar || ((_a2 = this.project) == null ? void 0 : _a2.calendar);
    return !calendar || ((_b = calendar.isWorkingTime) == null ? void 0 : _b.call(calendar, date));
  }
};

// ../Scheduler/lib/Scheduler/model/ResourceModel.js
var EngineMixin5 = CoreResourceMixin;
var ResourceModel = class extends ResourceModelMixin_default(PartOfProject_default(EngineMixin5.derive(GridRowModel))) {
};
/**
 * Get associated events
 *
 * @member {Scheduler.model.EventModel[]} events
 * @readonly
 * @category Common
 */
__publicField(ResourceModel, "$name", "ResourceModel");
ResourceModel.exposeProperties();
ResourceModel._$name = "ResourceModel";

// ../Scheduler/lib/Scheduler/data/ResourceStore.js
var EngineMixin6 = PartOfProject_default(CoreResourceStoreMixin.derive(AjaxStore));
var ResourceStore = class extends ResourceStoreMixin_default(EngineMixin6) {
  static get defaultConfig() {
    return {
      modelClass: ResourceModel
    };
  }
};
ResourceStore._$name = "ResourceStore";

// ../Scheduler/lib/Scheduler/model/DependencyBaseModel.js
var canonicalDependencyTypes = [
  "SS",
  "SF",
  "FS",
  "FF"
];
var DependencyBaseModel = class extends Model {
  static get $name() {
    return "DependencyBaseModel";
  }
  /**
   * Set value for the specified field(s), triggering engine calculations immediately. See
   * {@link Core.data.Model#function-set Model#set()} for arguments.
   **
   * ```javascript
   * dependency.set('from', 2);
   * // dependency.fromEvent is not yet up to date
   *
   * await dependency.setAsync('from', 2);
   * // dependency.fromEvent is up to date
   * ```
   *
   * @param {String|Object} field The field to set value for, or an object with multiple values to set in one call
   * @param {*} value Value to set
   * @param {Boolean} [silent=false] Set to true to not trigger events
   * automatically.
   * @function setAsync
   * @category Editing
   * @async
   */
  //region Fields
  /**
   * An enumerable object, containing names for the dependency types integer constants.
   * - 0 StartToStart
   * - 1 StartToEnd
   * - 2 EndToStart
   * - 3 EndToEnd
   * @property {Object}
   * @readonly
   * @category Dependency
   */
  static get Type() {
    return {
      StartToStart: 0,
      StartToEnd: 1,
      EndToStart: 2,
      EndToEnd: 3
    };
  }
  static get fields() {
    return [
      // 3 mandatory fields
      /**
       * From event, id of source event
       * @field {String|Number} from
       * @category Dependency
       */
      { name: "from" },
      /**
       * To event, id of target event
       * @field {String|Number} to
       * @category Dependency
       */
      { name: "to" },
      /**
       * Dependency type, see static property {@link #property-Type-static}
       * @field {Number} type=2
       * @category Dependency
       */
      { name: "type", type: "int", defaultValue: 2 },
      /**
       * CSS class to apply to lines drawn for the dependency
       * @field {String} cls
       * @category Styling
       */
      { name: "cls", defaultValue: "" },
      /**
       * Bidirectional, drawn with arrows in both directions
       * @field {Boolean} bidirectional
       * @category Dependency
       */
      { name: "bidirectional", type: "boolean" },
      /**
       * Start side on source (top, left, bottom, right)
       * @field {'top'|'left'|'bottom'|'right'} fromSide
       * @category Dependency
       */
      { name: "fromSide", type: "string" },
      /**
       * End side on target (top, left, bottom, right)
       * @field {'top'|'left'|'bottom'|'right'} toSide
       * @category Dependency
       */
      { name: "toSide", type: "string" },
      /**
       * The magnitude of this dependency's lag (the number of units).
       * @field {Number} lag
       * @category Dependency
       */
      { name: "lag", type: "number", allowNull: true, defaultValue: 0 },
      /**
       * The units of this dependency's lag, defaults to "d" (days). Valid values are:
       *
       * - "ms" (milliseconds)
       * - "s" (seconds)
       * - "m" (minutes)
       * - "h" (hours)
       * - "d" (days)
       * - "w" (weeks)
       * - "M" (months)
       * - "y" (years)
       *
       * This field is readonly after creation, to change `lagUnit` use {@link #function-setLag setLag()}.
       * @field {'ms'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} lagUnit
       * @category Dependency
       * @readonly
       */
      {
        name: "lagUnit",
        type: "string",
        defaultValue: "d"
      },
      { name: "highlighted", persist: false, internal: true }
    ];
  }
  // fromEvent/toEvent defined in CoreDependencyMixin in engine
  /**
   * Gets/sets the source event of the dependency.
   *
   * Accepts multiple formats but always returns an {@link Scheduler.model.EventModel}.
   *
   * **NOTE:** This is not a proper field but rather an alias, it will be serialized but cannot be remapped. If you
   * need to remap, consider using {@link #field-from} instead.
   *
   * @field {Scheduler.model.EventModel} fromEvent
   * @accepts {String|Number|Scheduler.model.EventModel}
   * @category Dependency
   */
  /**
   * Gets/sets the target event of the dependency.
   *
   * Accepts multiple formats but always returns an {@link Scheduler.model.EventModel}.
   *
   * **NOTE:** This is not a proper field but rather an alias, it will be serialized but cannot be remapped. If you
   * need to remap, consider using {@link #field-to} instead.
   *
   * @field {Scheduler.model.EventModel} toEvent
   * @accepts {String|Number|Scheduler.model.EventModel}
   * @category Dependency
   */
  //endregion
  //region Init
  construct(data) {
    const from = data[this.fieldMap.from.dataSource], to = data[this.fieldMap.to.dataSource];
    if (from != null) {
      data.fromEvent = from;
    }
    if (to != null) {
      data.toEvent = to;
    }
    super.construct(...arguments);
  }
  //endregion
  get eventStore() {
    var _a2;
    return this.eventStore || ((_a2 = this.unjoinedStores[0]) == null ? void 0 : _a2.eventStore);
  }
  set from(value) {
    const { fromEvent } = this;
    if ((fromEvent == null ? void 0 : fromEvent.isModel) && fromEvent.id === value) {
      this.set("from", value);
    } else {
      this.fromEvent = value;
    }
  }
  get from() {
    return this.get("from");
  }
  set to(value) {
    const { toEvent } = this;
    if ((toEvent == null ? void 0 : toEvent.isModel) && toEvent.id === value) {
      this.set("to", value);
    } else {
      this.toEvent = value;
    }
  }
  get to() {
    return this.get("to");
  }
  /**
   * Alias to dependency type, but when set resets {@link #field-fromSide} & {@link #field-toSide} to null as well.
   *
   * @property {Number}
   * @category Dependency
   */
  get hardType() {
    return this.getHardType();
  }
  set hardType(type) {
    this.setHardType(type);
  }
  /**
   * Returns dependency hard type, see {@link #property-hardType}.
   *
   * @returns {Number}
   * @category Dependency
   */
  getHardType() {
    return this.get("type");
  }
  /**
   * Sets dependency {@link #field-type} and resets {@link #field-fromSide} and {@link #field-toSide} to null.
   *
   * @param {Number} type
   * @category Dependency
   */
  setHardType(type) {
    let result;
    if (type !== this.hardType) {
      result = this.set({
        type,
        fromSide: null,
        toSide: null
      });
    }
    return result;
  }
  get lag() {
    return this.get("lag");
  }
  set lag(lag) {
    this.setLag(lag);
  }
  /**
   * Sets lag and lagUnit in one go. Only allowed way to change lagUnit, the lagUnit field is readonly after creation
   * @param {Number|String|Object} lag The lag value. May be just a numeric magnitude, or a full string descriptor eg '1d'
   * @param {'ms'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} [lagUnit] Unit for numeric lag value, see
   * {@link #field-lagUnit} for valid values
   * @category Dependency
   */
  setLag(lag, lagUnit = this.lagUnit) {
    if (arguments.length === 1) {
      if (typeof lag === "number") {
        this.lag = lag;
      } else {
        lag = DateHelper.parseDuration(lag);
        this.set({
          lag: lag.magnitude,
          lagUnit: lag.unit
        });
      }
      return;
    }
    lag = parseFloat(lag);
    this.set({
      lag,
      lagUnit
    });
  }
  getLag() {
    if (this.lag) {
      return `${this.lag < 0 ? "-" : "+"}${Math.abs(this.lag)}${DateHelper.getShortNameOfUnit(this.lagUnit)}`;
    }
    return "";
  }
  /**
   * Property which encapsulates the lag's magnitude and units. An object which contains two properties:
   * @property {Core.data.Duration}
   * @property {Number} fullLag.magnitude The magnitude of the duration
   * @property {'ms'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} fullLag.unit The unit in which the duration is measured, eg
   * `'d'` for days
   * @category Dependency
   */
  get fullLag() {
    return new Duration({
      unit: this.lagUnit,
      magnitude: this.lag
    });
  }
  set fullLag(lag) {
    if (typeof lag === "string") {
      this.setLag(lag);
    } else {
      this.setLag(lag.magnitude, lag.unit);
    }
  }
  /**
   * Returns true if the linked events have been persisted (e.g. neither of them are 'phantoms')
   *
   * @property {Boolean}
   * @readonly
   * @category Editing
   */
  get isPersistable() {
    const me = this, { stores, unjoinedStores } = me, store = stores[0];
    let result;
    if (store) {
      const { fromEvent, toEvent } = me, crudManager = store.crudManager;
      result = fromEvent && (crudManager || !fromEvent.hasGeneratedId) && toEvent && (crudManager || !toEvent.hasGeneratedId);
    } else {
      result = Boolean(unjoinedStores[0]);
    }
    return result && super.isPersistable;
  }
  getDateRange() {
    const { fromEvent, toEvent } = this;
    if ((fromEvent == null ? void 0 : fromEvent.isScheduled) && (toEvent == null ? void 0 : toEvent.isScheduled)) {
      const Type = DependencyBaseModel.Type;
      let sourceDate, targetDate;
      switch (this.type) {
        case Type.StartToStart:
          sourceDate = fromEvent.startDateMS;
          targetDate = toEvent.startDateMS;
          break;
        case Type.StartToEnd:
          sourceDate = fromEvent.startDateMS;
          targetDate = toEvent.endDateMS;
          break;
        case Type.EndToEnd:
          sourceDate = fromEvent.endDateMS;
          targetDate = toEvent.endDateMS;
          break;
        case Type.EndToStart:
          sourceDate = fromEvent.endDateMS;
          targetDate = toEvent.startDateMS;
          break;
        default:
          throw new Error("Invalid dependency type: " + this.type);
      }
      return {
        start: Math.min(sourceDate, targetDate),
        end: Math.max(sourceDate, targetDate)
      };
    }
    return null;
  }
  /**
   * Applies given CSS class to dependency, the value doesn't persist
   *
   * @param {String} cls
   * @category Dependency
   */
  highlight(cls) {
    var _a2, _b;
    const classes = (_b = (_a2 = this.highlighted) == null ? void 0 : _a2.split(" ")) != null ? _b : [];
    if (!classes.includes(cls)) {
      this.highlighted = classes.concat(cls).join(" ");
    }
  }
  /**
   * Removes given CSS class from dependency if applied, the value doesn't persist
   *
   * @param {String} cls
   * @category Dependency
   */
  unhighlight(cls) {
    const { highlighted } = this;
    if (highlighted) {
      const classes = highlighted.split(" "), index = classes.indexOf(cls);
      if (index >= 0) {
        classes.splice(index, 1);
        this.highlighted = classes.join(" ");
      }
    }
  }
  /**
   * Checks if the given CSS class is applied to dependency.
   *
   * @param {String} cls
   * @returns {Boolean}
   * @category Dependency
   */
  isHighlightedWith(cls) {
    return this.highlighted && this.highlighted.split(" ").includes(cls);
  }
  getConnectorString(raw) {
    const rawValue = canonicalDependencyTypes[this.type];
    if (raw) {
      return rawValue;
    }
    if (this.type === DependencyBaseModel.Type.EndToStart) {
      return "";
    }
    return rawValue;
  }
  // getConnectorStringFromType(type, raw) {
  //     const rawValue = canonicalDependencyTypes[type];
  //
  //     if (raw) {
  //         return rawValue;
  //     }
  //
  //     // FS => empty string; it's the default
  //     if (type === DependencyBaseModel.Type.EndToStart) {
  //         return '';
  //     }
  //
  //     const locale = LocaleManager.locale;
  //
  //     // See if there is a local version of SS, SF or FF
  //     if (locale) {
  //         const localized = locale.Scheduler && locale.Scheduler[rawValue];
  //         if (localized) {
  //             return localized;
  //         }
  //     }
  //
  //     return rawValue;
  // }
  // getConnectorString(raw) {
  //     return this.getConnectorStringFromType(this.type);
  // }
  // * getConnectorStringGenerator(raw) {
  //     return this.getConnectorStringFromType(yield this.$.type);
  // }
  toString() {
    return `${this.from}${this.getConnectorString()}${this.getLag()}`;
  }
  /**
   * Returns `true` if the dependency is valid. It is considered valid if it has a valid type and both from and to
   * events are set and pointing to different events.
   *
   * @property {Boolean}
   * @typings ignore
   * @category Editing
   */
  get isValid() {
    const { fromEvent, toEvent, type } = this;
    return typeof type === "number" && fromEvent && toEvent && fromEvent !== toEvent;
  }
  get fromEventName() {
    var _a2;
    return ((_a2 = this.fromEvent) == null ? void 0 : _a2.name) || "";
  }
  get toEventName() {
    var _a2;
    return ((_a2 = this.toEvent) == null ? void 0 : _a2.name) || "";
  }
  //region STM hooks
  shouldRecordFieldChange(fieldName, oldValue, newValue) {
    var _a2;
    if (!super.shouldRecordFieldChange(fieldName, oldValue, newValue)) {
      return false;
    }
    if (fieldName === "from" || fieldName === "to" || fieldName === "fromEvent" || fieldName === "toEvent") {
      const eventStore = (_a2 = this.project) == null ? void 0 : _a2.eventStore;
      if (eventStore && eventStore.oldIdMap[oldValue] === eventStore.getById(newValue)) {
        return false;
      }
    }
    return true;
  }
  //endregion
};
DependencyBaseModel.exposeProperties();
DependencyBaseModel._$name = "DependencyBaseModel";

// ../Scheduler/lib/Scheduler/model/DependencyModel.js
var EngineMixin7 = CoreDependencyMixin;
var DependencyModel = class extends PartOfProject_default(EngineMixin7.derive(DependencyBaseModel)) {
  static get $name() {
    return "DependencyModel";
  }
  // Determines the type of dependency based on fromSide and toSide
  getTypeFromSides(fromSide, toSide, rtl) {
    const types = DependencyBaseModel.Type, startSide = rtl ? "right" : "left", endSide = rtl ? "left" : "right";
    if (fromSide === startSide) {
      return toSide === startSide ? types.StartToStart : types.StartToEnd;
    }
    return toSide === endSide ? types.EndToEnd : types.EndToStart;
  }
};
DependencyModel.exposeProperties();
DependencyModel._$name = "DependencyModel";

// ../Scheduler/lib/Scheduler/data/mixin/DependencyStoreMixin.js
var DependencyStoreMixin_default = (Target) => class DependencyStoreMixin extends Target {
  static get $name() {
    return "DependencyStoreMixin";
  }
  /**
   * Add dependencies to the store.
   *
   * NOTE: References (fromEvent, toEvent) on the dependencies are determined async by a calculation engine. Thus they
   * cannot be directly accessed after using this function.
   *
   * For example:
   *
   * ```javascript
   * const [dependency] = dependencyStore.add({ from, to });
   * // dependency.fromEvent is not yet available
   * ```
   *
   * To guarantee references are set up, wait for calculations for finish:
   *
   * ```javascript
   * const [dependency] = dependencyStore.add({ from, to });
   * await dependencyStore.project.commitAsync();
   * // dependency.fromEvent is available (assuming EventStore is loaded and so on)
   * ```
   *
   * Alternatively use `addAsync()` instead:
   *
   * ```javascript
   * const [dependency] = await dependencyStore.addAsync({ from, to });
   * // dependency.fromEvent is available (assuming EventStore is loaded and so on)
   * ```
   *
   * @param {Scheduler.model.DependencyModel|Scheduler.model.DependencyModel[]|DependencyModelConfig|DependencyModelConfig[]} records
   * Array of records/data or a single record/data to add to store
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Scheduler.model.DependencyModel[]} Added records
   * @function add
   * @category CRUD
   */
  /**
   * Add dependencies to the store and triggers calculations directly after. Await this function to have up to date
   * references on the added dependencies.
   *
   * ```javascript
   * const [dependency] = await dependencyStore.addAsync({ from, to });
   * // dependency.fromEvent is available (assuming EventStore is loaded and so on)
   * ```
   *
   * @param {Scheduler.model.DependencyModel|Scheduler.model.DependencyModel[]|DependencyModelConfig|DependencyModelConfig[]} records
   * Array of records/data or a single record/data to add to store
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Scheduler.model.DependencyModel[]} Added records
   * @function addAsync
   * @category CRUD
   * @async
   */
  /**
   * Applies a new dataset to the DependencyStore. Use it to plug externally fetched data into the store.
   *
   * NOTE: References (fromEvent, toEvent) on the dependencies are determined async by a calculation engine. Thus
   * they cannot be directly accessed after assigning the new dataset.
   *
   * For example:
   *
   * ```javascript
   * dependencyStore.data = [{ from, to }];
   * // dependencyStore.first.fromEvent is not yet available
   * ```
   *
   * To guarantee references are available, wait for calculations for finish:
   *
   * ```javascript
   * dependencyStore.data = [{ from, to }];
   * await dependencyStore.project.commitAsync();
   * // dependencyStore.first.fromEvent is available
   * ```
   *
   * Alternatively use `loadDataAsync()` instead:
   *
   * ```javascript
   * await dependencyStore.loadDataAsync([{ from, to }]);
   * // dependencyStore.first.fromEvent is available
   * ```
   *
   * @member {DependencyModelConfig[]} data
   * @category Records
   */
  /**
   * Applies a new dataset to the DependencyStore and triggers calculations directly after. Use it to plug externally
   * fetched data into the store.
   *
   * ```javascript
   * await dependencyStore.loadDataAsync([{ from, to }]);
   * // dependencyStore.first.fromEvent is available
   * ```
   *
   * @param {DependencyModelConfig[]} data Array of DependencyModel data objects
   * @function loadDataAsync
   * @category CRUD
   * @async
   */
  static get defaultConfig() {
    return {
      /**
       * CrudManager must load stores in the correct order. Lowest first.
       * @private
       */
      loadPriority: 400,
      /**
       * CrudManager must sync stores in the correct order. Lowest first.
       * @private
       */
      syncPriority: 400,
      storeId: "dependencies"
    };
  }
  reduceEventDependencies(event, reduceFn, result, flat = true, depsGetterFn) {
    depsGetterFn = depsGetterFn || ((event2) => this.getEventDependencies(event2));
    event = ArrayHelper.asArray(event);
    event.reduce((result2, event2) => {
      if (event2.children && !flat) {
        event2.traverse((evt) => {
          result2 = depsGetterFn(evt).reduce(reduceFn, result2);
        });
      } else {
        result2 = depsGetterFn(event2).reduce(reduceFn, result2);
      }
    }, result);
    return result;
  }
  mapEventDependencies(event, fn2, filterFn, flat, depsGetterFn) {
    return this.reduceEventDependencies(event, (result, dependency) => {
      filterFn(dependency) && result.push(dependency);
      return result;
    }, [], flat, depsGetterFn);
  }
  mapEventPredecessors(event, fn2, filterFn, flat) {
    return this.reduceEventPredecessors(event, (result, dependency) => {
      filterFn(dependency) && result.push(dependency);
      return result;
    }, [], flat);
  }
  mapEventSuccessors(event, fn2, filterFn, flat) {
    return this.reduceEventSuccessors(event, (result, dependency) => {
      filterFn(dependency) && result.push(dependency);
      return result;
    }, [], flat);
  }
  /**
   * Returns all dependencies for a certain event (both incoming and outgoing)
   *
   * @param {Scheduler.model.EventModel} event
   * @returns {Scheduler.model.DependencyModel[]}
   */
  getEventDependencies(event) {
    return [].concat(event.predecessors || [], event.successors || []);
  }
  removeEventDependencies(event) {
    this.remove(this.getEventDependencies(event));
  }
  removeEventPredecessors(event) {
    this.remove(event.predecessors);
  }
  removeEventSuccessors(event, flat) {
    this.remove(event.successors);
  }
  getBySourceTargetId(key) {
    return this.records.find(
      (r) => key == this.constructor.makeDependencySourceTargetCompositeKey(r.from, r.to)
    );
  }
  /**
   * Returns dependency model instance linking tasks with given ids. The dependency can be forward (from 1st
   * task to 2nd) or backward (from 2nd to 1st).
   *
   * @param {Scheduler.model.EventModel|String} sourceEvent 1st event
   * @param {Scheduler.model.EventModel|String} targetEvent 2nd event
   * @returns {Scheduler.model.DependencyModel}
   */
  getDependencyForSourceAndTargetEvents(sourceEvent, targetEvent) {
    sourceEvent = Model.asId(sourceEvent);
    targetEvent = Model.asId(targetEvent);
    return this.getBySourceTargetId(this.constructor.makeDependencySourceTargetCompositeKey(sourceEvent, targetEvent));
  }
  /**
   * Returns a dependency model instance linking given events if such dependency exists in the store.
   * The dependency can be forward (from 1st event to 2nd) or backward (from 2nd to 1st).
   *
   * @param {Scheduler.model.EventModel|String} sourceEvent
   * @param {Scheduler.model.EventModel|String} targetEvent
   * @returns {Scheduler.model.DependencyModel}
   */
  getEventsLinkingDependency(sourceEvent, targetEvent) {
    return this.getDependencyForSourceAndTargetEvents(sourceEvent, targetEvent) || this.getDependencyForSourceAndTargetEvents(targetEvent, sourceEvent);
  }
  /**
   * Validation method used to validate a dependency. Override and return `true` to indicate that an
   * existing dependency between two tasks is valid. For a new dependency being created please see
   * {@link #function-isValidDependencyToCreate}.
   *
   * @param {Scheduler.model.DependencyModel|Scheduler.model.TimeSpan|Number|String} dependencyOrFromId The dependency
   * model, the from task/event or the id of the from task/event
   * @param {Scheduler.model.TimeSpan|Number|String} [toId] To task/event or id thereof if the first parameter is not
   * a dependency record
   * @param {Number} [type] Dependency {@link Scheduler.model.DependencyBaseModel#property-Type-static} if the first
   * parameter is not a dependency model instance.
   * @returns {Boolean}
   */
  async isValidDependency(dependencyOrFromId, toId, type) {
    let fromEvent = dependencyOrFromId, toEvent = toId;
    if (dependencyOrFromId == null) {
      return false;
    }
    if (dependencyOrFromId.isDependencyModel) {
      ({ fromEvent, toEvent } = dependencyOrFromId);
    }
    fromEvent = this.eventStore.getById(fromEvent);
    toEvent = this.eventStore.getById(toEvent);
    if (fromEvent && toEvent) {
      if (!fromEvent.project || !toEvent.project) {
        return false;
      }
      return this.project.isValidDependency(fromEvent, toEvent, type);
    }
    return dependencyOrFromId !== toId;
  }
  /**
   * Validation method used to validate a dependency while creating. Override and return `true` to indicate that
   * a new dependency is valid to be created.
   *
   * @param {Scheduler.model.TimeSpan|Number|String} fromId From event/task or id
   * @param {Scheduler.model.TimeSpan|Number|String} toId To event/task or id
   * @param {Number} type Dependency {@link Scheduler.model.DependencyBaseModel#property-Type-static}
   * @returns {Boolean}
   */
  isValidDependencyToCreate(fromId, toId, type) {
    return this.isValidDependency(fromId, toId, type);
  }
  /**
   * Returns all dependencies highlighted with the given CSS class
   *
   * @param {String} cls
   * @returns {Scheduler.model.DependencyBaseModel[]}
   */
  getHighlightedDependencies(cls) {
    return this.records.reduce((result, dep) => {
      if (dep.isHighlightedWith(cls))
        result.push(dep);
      return result;
    }, []);
  }
  static makeDependencySourceTargetCompositeKey(from, to) {
    return `source(${from})-target(${to})`;
  }
  //region Product neutral
  getTimeSpanDependencies(record) {
    return this.getEventDependencies(record);
  }
  //endregion
};

// ../Scheduler/lib/Scheduler/data/DependencyStore.js
var EngineMixin8 = PartOfProject_default(CoreDependencyStoreMixin.derive(AjaxStore));
var DependencyStore = class extends DependencyStoreMixin_default(EngineMixin8.derive(AjaxStore)) {
  static get defaultConfig() {
    return {
      modelClass: DependencyModel
    };
  }
};
DependencyStore._$name = "DependencyStore";

// ../Scheduler/lib/Scheduler/data/mixin/ProjectCrudManager.js
var ProjectCrudManager_default = (Target) => class ProjectCrudManager extends (Target || Base2).mixin(AbstractCrudManagerMixin_default, AjaxTransport_default, JsonEncoder_default) {
  //region Config
  static get defaultConfig() {
    return {
      project: null
    };
  }
  startConfigure(config) {
    this.getConfig("project");
    super.startConfigure(config);
    this._changesToClear = /* @__PURE__ */ new Map();
  }
  async doAutoLoad() {
    const { project } = this;
    if (project) {
      await project.commitAsync();
    }
    return super.doAutoLoad();
  }
  applyProjectResponse(response) {
    const me = this, { project } = me;
    me.applyingProjectResponse = true;
    const startDateField = project.fieldMap.startDate, endDateField = project.fieldMap.endDate, startDate = ObjectHelper.getPath(response, startDateField.dataSource), endDate = ObjectHelper.getPath(response, endDateField.dataSource);
    if (typeof startDate === "string") {
      ObjectHelper.setPath(response, startDateField.dataSource, startDateField.convert(startDate));
    }
    if (typeof endDate === "string") {
      ObjectHelper.setPath(response, endDateField.dataSource, endDateField.convert(endDate));
    }
    Object.assign(project, response);
    me._changesToClear.set(me, response);
    me.applyingProjectResponse = false;
  }
  loadCrudManagerData(response, options = {}) {
    const me = this, { project } = me;
    me.suspendChangesTracking();
    super.loadCrudManagerData(...arguments);
    if (response == null ? void 0 : response.project) {
      if (project.delayEnteringReplica) {
        project.ion({
          recordsUnlinked: () => {
            me.suspendChangesTracking();
            me.applyProjectResponse(response.project);
            me.resumeChangesTracking();
          },
          once: true
        });
      } else {
        me.applyProjectResponse(response.project);
      }
    }
    me.resumeChangesTracking();
  }
  async sync() {
    const { project } = this;
    this.suspendAutoSync();
    if (project) {
      await project.commitAsync();
    }
    if (this.isDestroying) {
      return;
    }
    this.resumeAutoSync(false);
    return super.sync();
  }
  async applyResponse(request, response, options) {
    var _a2, _b, _c, _d, _e, _f;
    const me = this;
    if (me.isDestroyed || ((_a2 = me.project) == null ? void 0 : _a2.isDestroyed)) {
      return;
    }
    me.trigger("beforeApplyResponse");
    await super.applyResponse(request, response, options);
    if ((response == null ? void 0 : response.project) || me.supportShortSyncResponse && ((_b = request == null ? void 0 : request.pack) == null ? void 0 : _b.project)) {
      me.applyProjectResponse(response.project || ((_c = request == null ? void 0 : request.pack) == null ? void 0 : _c.project));
    }
    if (me.project) {
      let requestType = request.type;
      if (me.trackResponseType) {
        requestType = response.type || requestType;
      }
      const propagationFlag = `propagating${StringHelper.capitalize(requestType)}Changes`;
      me.suspendAutoSync();
      me[propagationFlag] = true;
      const loud = me.project.isInitialCommit && !me.project.silenceInitialCommit;
      await me.project.commitAsync();
      me[propagationFlag] = false;
      (_d = me.resumeAutoSync) == null ? void 0 : _d.call(me, loud);
      (_e = me.commitRespondedChanges) == null ? void 0 : _e.call(me);
    }
    (_f = me.trigger) == null ? void 0 : _f.call(me, "applyResponse");
  }
  applySyncResponse(...args) {
    var _a2;
    const me = this, stmDisabled = (_a2 = me.project) == null ? void 0 : _a2.stm.disabled;
    if (stmDisabled === false && me.ignoreRemoteChangesInSTM) {
      me.project.stm.disable();
    }
    super.applySyncResponse(...args);
    if (stmDisabled === false) {
      me.project.stm.enable();
    }
  }
  shouldClearRecordFieldChange(record, field2, value) {
    const oldValue = record.getValue(field2);
    field2 = record.getFieldDefinition(field2);
    return (field2 == null ? void 0 : field2.isEqual) ? field2.isEqual(oldValue, value) : ObjectHelper.isEqual(oldValue, value);
  }
  commitRespondedChanges() {
    this._changesToClear.forEach((changes, record) => {
      Object.entries(changes).forEach(([key, value]) => {
        if (this.shouldClearRecordFieldChange(record, key, value)) {
          delete record.meta.modified[key];
        }
      });
    });
    this._changesToClear.clear();
  }
  applyChangesToStore(storeDesc, storeResponse, storePack, ...rest) {
    const changesMap = super.applyChangesToStore(storeDesc, storeResponse, storePack, ...rest);
    if (changesMap.size && this.project) {
      for (const [id, changes] of changesMap) {
        const record = storeDesc.store.getById(id);
        record && this._changesToClear.set(record, changes);
      }
    }
    return changesMap;
  }
};

// ../Scheduler/lib/Scheduler/model/mixin/ProjectModelCommon.js
var ProjectModelCommon_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Model) {
    static get configurable() {
      return {
        // Documented in Gantt/Scheduler/SchedulerPro version of ./model/ProjectModel since types differ
        assignments: null,
        dependencies: null,
        resources: null,
        timeRanges: null
      };
    }
    //region Inline data
    get assignments() {
      return this.assignmentStore.allRecords;
    }
    updateAssignments(assignments) {
      this.assignmentStore.data = assignments;
    }
    get dependencies() {
      return this.dependencyStore.allRecords;
    }
    updateDependencies(dependencies) {
      this.dependencyStore.data = dependencies;
    }
    get resources() {
      return this.resourceStore.allRecords;
    }
    updateResources(resources) {
      this.resourceStore.data = resources;
    }
    get timeRanges() {
      return this.timeRangeStore.allRecords;
    }
    getTimeRanges(startDate, endDate) {
      const store = this.timeRangeStore, ret = [];
      for (const timeSpan of store) {
        if (timeSpan.isRecurring) {
          ret.push(...timeSpan.getOccurrencesForDateRange(startDate, endDate));
        } else if (timeSpan.startDate < endDate && startDate < timeSpan.endDate) {
          ret.push(timeSpan);
        }
      }
      return ret;
    }
    updateTimeRanges(timeRanges) {
      this.timeRangeStore.data = timeRanges;
    }
    getResourceTimeRanges(startDate, endDate) {
      const store = this.resourceTimeRangeStore, ret = [];
      for (const timeSpan of store) {
        if (timeSpan.isRecurring) {
          ret.push(...timeSpan.getOccurrencesForDateRange(startDate, endDate));
        } else if (timeSpan.startDate < endDate && startDate < timeSpan.endDate) {
          ret.push(timeSpan);
        }
      }
      return ret;
    }
    //endregion
  }, __publicField(_a2, "$name", "ProjectModelCommon"), _a2;
};

// ../Scheduler/lib/Scheduler/model/mixin/ProjectModelTimeZoneMixin.js
var ProjectModelTimeZoneMixin_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Model) {
    get _storesWithDates() {
      return [this.taskStore, this.timeRangeStore, this.resourceTimeRangeStore].filter((s) => s);
    }
    // Overrides a Store's processRecord function to be able to convert records added by a dataset
    // before they are processed by the engine
    overrideStoreProcessRecord(store) {
      if (this._storesWithDates.includes(store) && !store.$originalProcessRecord) {
        store.$originalProcessRecord = FunctionHelper.before(store, "processRecord", (record, isDataSet) => {
          if (isDataSet || store.isLoadingData) {
            this.convertRecordToTimeZone(record);
          }
        });
      }
    }
    attachStore(store) {
      super.attachStore(store);
      if (store && this.timeZone != null && this._storesWithDates.includes(store)) {
        this.convertStoresToTimeZone([store]);
        this.overrideStoreProcessRecord();
      }
    }
    detachStore(store) {
      super.detachStore(store);
      if (store && !store.isDestroyed) {
        const { $originalProcessRecord } = store;
        if ($originalProcessRecord) {
          $originalProcessRecord();
          store.$originalProcessRecord = null;
          this.convertStoresToTimeZone([store], null);
        }
      }
    }
    relayStoreChange({ source, action, records, replaced }) {
      const me = this;
      if (me.timeZone != null && me._storesWithDates.includes(source)) {
        if (["add", "replace"].includes(action)) {
          if (!(records == null ? void 0 : records.length) && (replaced == null ? void 0 : replaced.length)) {
            records = replaced;
          }
          if (records.length) {
            records.forEach((record) => record.timeZone = me.timeZone);
          }
        }
      }
    }
    convertStoresToTimeZone(stores, timeZone = this.timeZone) {
      var _a3;
      const me = this, stmAutoRecord = (_a3 = me.stm) == null ? void 0 : _a3.autoRecord;
      if (stmAutoRecord) {
        me.stm.autoRecord = false;
      }
      for (const store of stores) {
        store == null ? void 0 : store.forEach((r) => me.convertRecordToTimeZone(r, timeZone));
      }
      if (stmAutoRecord) {
        me.stmAutoRecord = stmAutoRecord;
      }
    }
    convertRecordToTimeZone(record, timeZone = this.timeZone) {
      var _a3;
      if (record.timeZone !== timeZone) {
        record.$ignoreChange = true;
        if ((_a3 = record.baselines) == null ? void 0 : _a3.count) {
          for (const bl of record.baselines) {
            if (record.timeZone !== bl.timeZone) {
              bl.timeZone = record.timeZone;
            }
            bl.convertToTimeZone(timeZone);
          }
        }
        record.convertToTimeZone(timeZone);
        record.$ignoreChange = false;
      }
    }
    updateTimeZone(timeZone, oldTimeZone) {
      const me = this, isConfiguring = me._isConfiguringTimeZone || me.isConfiguring;
      me.trigger("beforeTimeZoneChange", {
        timeZone,
        oldTimeZone,
        isConfiguring
      });
      me.calendarManagerStore.forEach((calendar) => calendar.bumpVersion());
      me.convertStoresToTimeZone(me._storesWithDates);
      me._storesWithDates.forEach((store) => me.overrideStoreProcessRecord(store));
      if (me.startDate) {
        const startDate = oldTimeZone != null ? TimeZoneHelper.fromTimeZone(me.startDate, oldTimeZone) : me.startDate;
        me.startDate = timeZone != null ? TimeZoneHelper.toTimeZone(startDate, timeZone) : startDate;
      }
      me.ignoreRecordChanges = true;
      me.commitAsync().then(() => {
        if (!me.isDestroyed) {
          me.trigger("timeZoneChange", {
            timeZone,
            oldTimeZone,
            isConfiguring
          });
        }
        delete me._isConfiguringTimeZone;
      });
    }
  }, __publicField(_a2, "$name", "ProjectModelTimeZoneMixin"), __publicField(_a2, "configurable", {
    /**
     * Set to a IANA time zone (i.e. `Europe/Stockholm`) or a UTC offset in minutes (i.e. `-120`). This will
     * convert all events, tasks and time ranges to the specified time zone or offset. It will also affect the
     * displayed timeline's headers as well at the start and end date of it.
     *
     * There is currently no built-in time zone support in JavaScript which means that the converted dates
     * technically still are in the local system time zone, but adjusted to match the configured time zone.
     *
     * ### DST
     * If a IANA time zone is provided, there will be support for DST. But if local system time zone has DST that
     * will affect the time zone conversion at the exact hour when the local system time zone switches DST on and
     * off.
     *
     * *For example:*
     * 1. The local system time zone is `Europe/Stockholm` (which is UTC+1 or UTC+2 when DST).
     * 2. The date `2022-03-27T07:00:00Z` (which is UTC) is converted to `America/Chicago` (which is UTC-6 or UTC-5
     *    when DST).
     * 3. The converted JS date will be created from `2022-03-27T02:00:00` which is exactly the hour when
     *    `Europe/Stockholm` adds an DST hour. This has the effect that the converted date shows up incorrectly as
     *    `2022-03-27T03:00` instead.
     *
     * If a UTC offset is provided, there is no DST support at all.
     *
     * ### Editing
     * If creating new records or editing existing record dates, the dates will be interpreted as in the selected
     * time zone.
     *
     * ### Saving
     * When saving or syncing data, the dates will be restored to local system time and converted to JSON
     * ISO formatted.
     *
     * @prp {String|Number} [timeZone]
     * @category Advanced
     */
    timeZone: {
      // Don't ingest the config eagerly because it relies on project being present.
      // Lazy means it waits for ingestion until timeZone property is referenced.
      $config: "lazy",
      value: null
    }
  }), _a2;
};

// ../Scheduler/lib/Scheduler/model/mixin/ProjectModelMixin.js
var ProjectModelMixin_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Model).mixin(
    ProjectModelCommon_default,
    ProjectModelTimeZoneMixin_default
  ) {
    static get $name() {
      return "ProjectModelMixin";
    }
    //region Config
    static get defaultConfig() {
      return {
        /**
         * State tracking manager instance the project relies on
         * @member {Core.data.stm.StateTrackingManager} stm
         * @category Advanced
         */
        /**
         * Configuration options to provide to the STM manager
         *
         * @config {StateTrackingManagerConfig|Core.data.stm.StateTrackingManager}
         * @category Advanced
         */
        stm: {},
        timeRangeModelClass: TimeSpan,
        resourceTimeRangeModelClass: ResourceTimeRangeModel,
        /**
         * The constructor to create a time range store instance with. Should be a class subclassing the
         * {@link Core.data.Store}
         * @config {Core.data.Store|Object}
         * @typings {typeof Store|object}
         * @category Models & Stores
         */
        timeRangeStoreClass: Store,
        /**
         * The constructor to create a resource time range store instance with. Should be a class subclassing the
         * {@link Scheduler.data.ResourceTimeRangeStore}
         * @config {Scheduler.data.ResourceTimeRangeStore|Object}
         * @typings {typeof ResourceTimeRangeStore|object}
         * @category Models & Stores
         */
        resourceTimeRangeStoreClass: ResourceTimeRangeStore,
        /**
         * The initial data, to fill the {@link #property-timeRangeStore timeRangeStore} with.
         * Should be an array of {@link Scheduler.model.TimeSpan TimeSpan} or its configuration objects.
         *
         * @config {Scheduler.model.TimeSpan[]} [timeRangesData]
         * @category Legacy inline data
         */
        /**
         * The initial data, to fill the {@link #property-resourceTimeRangeStore resourceTimeRangeStore} with.
         * Should be an array of {@link Scheduler.model.ResourceTimeRangeModel ResourceTimeRangeModel} or it's
         * configuration objects.
         *
         * @config {Scheduler.model.ResourceTimeRangeModel[]} [resourceTimeRangesData]
         * @category Legacy inline data
         */
        eventStore: {},
        assignmentStore: {},
        dependencyStore: {},
        resourceStore: {},
        timeRangesData: null
      };
    }
    //endregion
    //region Properties
    /**
     * Get or set data of project stores. The returned data is identical to what
     * {@link #function-toJSON} returns:
     *
     * ```javascript
     *
     * const data = scheduler.project.inlineData;
     *
     * // data:
     * {
     *     eventsData             : [...],
     *     resourcesData          : [...],
     *     dependenciesData       : [...],
     *     assignmentsData        : [...],
     *     resourceTimeRangesData : [...],
     *     timeRangesData         : [...]
     * }
     *
     *
     * // Plug it back in later
     * scheduler.project.inlineData = data;
     * ```
     *
     * @property {Object}
     * @category Inline data
     */
    get inlineData() {
      return StringHelper.safeJsonParse(super.json);
    }
    set inlineData(inlineData) {
      this.json = inlineData;
    }
    //endregion
    //region Functions
    /**
     * Accepts a "data package" consisting of data for the projects stores, which is then loaded into the stores.
     *
     * The package can hold data for `EventStore`, `AssignmentStore`, `ResourceStore`, `DependencyStore`,
     * `TimeRangeStore` and `ResourceTimeRangeStore`. It uses the same format as when creating a project with inline
     * data:
     *
     * ```javascript
     * await project.loadInlineData({
     *     eventsData             : [...],
     *     resourcesData          : [...],
     *     assignmentsData        : [...],
     *     dependenciesData       : [...],
     *     resourceTimeRangesData : [...],
     *     timeRangesData         : [...]
     * });
     * ```
     *
     * After populating the stores it commits the project, starting its calculations. By awaiting `loadInlineData()` you
     * can be sure that project calculations are finished.
     *
     * @function loadInlineData
     * @param {Object} dataPackage A data package as described above
     * @fires load
     * @async
     * @category Inline data
     */
    /**
     * Project changes (CRUD operations to records in its stores) are automatically committed on a buffer to the
     * underlying graph based calculation engine. The engine performs it calculations async.
     *
     * By calling this function, the commit happens right away. And by awaiting it you are sure that project
     * calculations are finished and that references between records are up to date.
     *
     * The returned promise is resolved with an object. If that object has `rejectedWith` set, there has been a conflict and the calculation failed.
     *
     * ```javascript
     * // Move an event in time
     * eventStore.first.shift(1);
     *
     * // Trigger calculations directly and wait for them to finish
     * const result = await project.commitAsync();
     *
     * if (result.rejectedWith) {
     *     // there was a conflict during the scheduling
     * }
     * ```
     *
     * @async
     * @function commitAsync
     * @category Common
     */
    //endregion
    //region Init
    construct(config = {}) {
      super.construct(...arguments);
      if (config.timeRangesData) {
        this.timeRangeStore.data = config.timeRangesData;
      }
      if (config.resourceTimeRangesData) {
        this.resourceTimeRangeStore.data = config.resourceTimeRangesData;
      }
    }
    afterConstruct() {
      super.afterConstruct();
      const me = this;
      !me.timeRangeStore.stm && me.stm.addStore(me.timeRangeStore);
      !me.resourceTimeRangeStore.stm && me.stm.addStore(me.resourceTimeRangeStore);
    }
    //endregion
    //region Attaching stores
    // Attach to a store, relaying its change events
    attachStore(store) {
      if (store) {
        store.ion({
          name: store.$$name,
          change: "relayStoreChange",
          thisObj: this
        });
      }
      super.attachStore(store);
    }
    // Detach a store, stop relaying its change events
    detachStore(store) {
      if (store) {
        this.detachListeners(store.$$name);
        super.detachStore(store);
      }
    }
    relayStoreChange(event) {
      super.relayStoreChange(event);
      return this.trigger("change", { store: event.source, ...event, source: this });
    }
    updateTimeRangeStore(store, oldStore) {
      this.detachStore(oldStore);
      this.attachStore(store);
    }
    setTimeRangeStore(store) {
      this.timeRangeStore = store;
    }
    changeTimeRangeStore(store) {
      if (store && !store.isStore) {
        store = this.timeRangeStoreClass.new({
          modelClass: this.timeRangeModelClass
        }, store);
      }
      return store;
    }
    updateResourceTimeRangeStore(store, oldStore) {
      this.detachStore(oldStore);
      this.attachStore(store);
    }
    changeResourceTimeRangeStore(store) {
      if (store && !store.isStore) {
        store = this.resourceTimeRangeStoreClass.new({
          modelClass: this.resourceTimeRangeModelClass
        }, store);
      }
      return store;
    }
    setResourceTimeRangeStore(store) {
      this.resourceTimeRangeStore = store;
    }
    //endregion
    //region Inline data
    get events() {
      return this.eventStore.allRecords;
    }
    updateEvents(events) {
      this.eventStore.data = events;
    }
    get resourceTimeRanges() {
      return this.resourceTimeRangeStore.allRecords;
    }
    updateResourceTimeRanges(resourceTimeRanges) {
      this.resourceTimeRangeStore.data = resourceTimeRanges;
    }
    async loadInlineData(data) {
      this.isLoadingInlineData = true;
      if (data.resourceTimeRangesData) {
        this.resourceTimeRangeStore.data = data.resourceTimeRangesData;
      }
      if (data.timeRangesData) {
        this.timeRangeStore.data = data.timeRangesData;
      }
      return super.loadInlineData(data);
    }
    //endregion
    //region JSON
    /**
     * Returns the data from the records of the projects stores, in a format that can be consumed by `loadInlineData()`.
     *
     * Used by JSON.stringify to correctly convert this record to json.
     *
     *
     * ```javascript
     * const project = new ProjectModel({
     *     eventsData             : [...],
     *     resourcesData          : [...],
     *     assignmentsData        : [...],
     *     dependenciesData       : [...],
     *     resourceTimeRangesData : [...],
     *     timeRangesData         : [...]
     * });
     *
     * const json = project.toJSON();
     *
     * // json:
     * {
     *     eventsData             : [...],
     *     resourcesData          : [...],
     *     dependenciesData       : [...],
     *     assignmentsData        : [...],
     *     resourceTimeRangesData : [...],
     *     timeRangesData         : [...]
     * }
     * ```
     *
     * Output can be consumed by `loadInlineData()`:
     *
     * ```javascript
     * const json = project.toJSON();
     *
     * // Plug it back in later
     * project.loadInlineData(json);
     * ```
     *
     * @returns {Object}
     * @category Inline data
     */
    toJSON() {
      const me = this, result = {
        eventsData: me.eventStore.toJSON(),
        resourcesData: me.resourceStore.toJSON(),
        dependenciesData: me.dependencyStore.toJSON(),
        timeRangesData: me.timeRangeStore.toJSON(),
        resourceTimeRangesData: me.resourceTimeRangeStore.toJSON()
      };
      if (!me.eventStore.usesSingleAssignment) {
        result.assignmentsData = me.assignmentStore.toJSON();
      }
      return result;
    }
    /**
     * Get or set project data (records from its stores) as a JSON string.
     *
     * Get a JSON string:
     *
     * ```javascript
     * const project = new ProjectModel({
     *     eventsData             : [...],
     *     resourcesData          : [...],
     *     assignmentsData        : [...],
     *     dependenciesData       : [...],
     *     resourceTimeRangesData : [...],
     *     timeRangesData         : [...]
     * });
     *
     * const jsonString = project.json;
     *
     * // jsonString:
     * '{"eventsData":[...],"resourcesData":[...],...}'
     * ```
     *
     * Set a JSON string (to populate the project stores):
     *
     * ```javascript
     * project.json = '{"eventsData":[...],"resourcesData":[...],...}'
     * ```
     *
     * @property {String}
     * @category Inline data
     */
    get json() {
      return super.json;
    }
    changeJson(json) {
      if (typeof json === "string") {
        json = StringHelper.safeJsonParse(json);
      }
      return json;
    }
    updateJson(json) {
      json && this.loadInlineData(json);
    }
    //endregion
    afterChange(toSet, wasSet) {
      super.afterChange(...arguments);
      if (wasSet.calendar) {
        this.trigger("calendarChange");
      }
    }
    doDestroy() {
      this.timeRangeStore.destroy();
      this.resourceTimeRangeStore.destroy();
      super.doDestroy();
    }
  }, __publicField(_a2, "configurable", {
    /**
     * Project data as a JSON string, used to populate its stores.
     *
     * ```javascript
     * const project = new ProjectModel({
     *     json : '{"eventsData":[...],"resourcesData":[...],...}'
     * }
     * ```
     *
     * @config {String}
     * @category Inline data
     */
    json: null,
    /**
     * The {@link Core.data.Store store} holding the time ranges information.
     *
     * See also {@link Scheduler.model.TimeSpan}
     *
     * @member {Core.data.Store} timeRangeStore
     * @category Models & Stores
     */
    /**
     * A {@link Core.data.Store} instance or a config object.
     * @config {Core.data.Store|StoreConfig}
     * @category Models & Stores
     */
    timeRangeStore: {
      value: {
        id: "timeRanges",
        modelClass: TimeSpan
      },
      $config: "nullify"
    },
    /**
     * The {@link Scheduler.data.ResourceTimeRangeStore store} holding the resource time ranges information.
     *
     * See also {@link Scheduler.model.ResourceTimeRangeModel}
     *
     * @member {Scheduler.data.ResourceTimeRangeStore} resourceTimeRangeStore
     * @category Models & Stores
     */
    /**
     * A {@link Scheduler.data.ResourceTimeRangeStore} instance or a config object.
     * @config {Scheduler.data.ResourceTimeRangeStore|ResourceTimeRangeStoreConfig}
     * @category Models & Stores
     */
    resourceTimeRangeStore: {
      value: {},
      $config: "nullify"
    },
    // Documented in Scheduler/SchedulerPro versions of model/ProjectModel since types differ
    events: null,
    resourceTimeRanges: null
  }), _a2;
};

// ../Scheduler/lib/Scheduler/model/mixin/ProjectCurrentConfig.js
var ProjectCurrentConfig_default = (Target) => class ProjectCurrentConfig extends Target {
  // This function is not meant to be called by any code other than Base#getCurrentConfig().
  // It extracts the current configs/fields for the project, with special handling for inline data
  getCurrentConfig(options) {
    const me = this, result = super.getCurrentConfig(options);
    if (result) {
      for (const storeName of ["eventStore", "resourceStore", "assignmentStore", "dependencyStore", "timeRangeStore", "resourceTimeRangeStore"]) {
        const store = me[storeName];
        if (store) {
          if (store.count) {
            result[store.id + "Data"] = store.getInlineData(options);
          }
          const storeState = store.getCurrentConfig(options);
          if (storeState && Object.keys(storeState).length > 0) {
            result[storeName] = Object.assign(result[storeName] || {}, storeState);
          } else if (result[storeName] && Object.keys(result[storeName]).length === 0) {
            delete result[storeName];
          }
        }
      }
      if (result.timeRangeStore) {
        if (me.timeRangeStore.originalModelClass === me.timeRangeModelClass || me.timeRangeStore.originalModelClass.$name === "TimeSpan") {
          delete result.timeRangeStore.modelClass;
        }
        if (result.timeRangeStore.storeId === "timeRanges") {
          delete result.timeRangeStore.storeId;
        }
        if (Object.keys(result.timeRangeStore).length === 1) {
          delete result.timeRangeStore;
        }
      }
      if (me.taskStore.isTaskStore) {
        delete result.eventModelClass;
        delete result.eventStoreClass;
        delete result.children;
      }
      return result;
    }
  }
};

// ../Scheduler/lib/Scheduler/data/util/ModelPersistencyManager.js
var ModelPersistencyManager = class extends Base2 {
  // region Event attachers
  set eventStore(newEventStore) {
    const me = this;
    me.eventStoreDetacher && me.eventStoreDetacher();
    me._eventStore = newEventStore;
    if (newEventStore && newEventStore.autoCommit) {
      me.eventStoreDetacher = newEventStore.ion({
        beforecommit: me.onEventStoreBeforeSync,
        thisObj: me,
        detachable: true,
        // Just in case
        prio: 100
      });
    }
  }
  get eventStore() {
    return this._eventStore;
  }
  set resourceStore(newResourceStore) {
    const me = this;
    me.resourceStoreDetacher && me.resourceStoreDetacher();
    me._resourceStore = newResourceStore;
    if (newResourceStore && newResourceStore.autoCommit) {
      me.resourceStoreDetacher = newResourceStore.ion({
        beforecommit: me.onResourceStoreBeforeSync,
        thisObj: me,
        detachable: true,
        // Just in case
        prio: 100
      });
    }
  }
  get resourceStore() {
    return this._resourceStore;
  }
  set assignmentStore(newAssignmentStore) {
    const me = this;
    me.assignmentStoreDetacher && me.assignmentStoreDetacher();
    me._assignmentStore = newAssignmentStore;
    if (newAssignmentStore && newAssignmentStore.autoSync) {
      me.assignmentStoreDetacher = newAssignmentStore.ion({
        beforecommit: me.onAssignmentStoreBeforeSync,
        thisObj: me,
        detachable: true,
        // Just in case
        prio: 100
      });
    }
  }
  get assignmentStore() {
    return this._assignmentStore;
  }
  set dependencyStore(newDependencyStore) {
    const me = this;
    me.dependencyStoreDetacher && me.dependencyStoreDetacher();
    me._dependencyStore = newDependencyStore;
    if (newDependencyStore && newDependencyStore.autoSync) {
      me.dependencyStoreDetacher = newDependencyStore.ion({
        beforecommit: me.onDependencyStoreBeforeSync,
        thisObj: me,
        detachable: true,
        // Just in case
        prio: 100
      });
    }
  }
  get dependencyStore() {
    return this._dependencyStore;
  }
  // endregion
  // region Event handlers
  onEventStoreBeforeSync({ changes }) {
    const me = this;
    me.removeNonPersistableRecordsToCreate(changes);
    return me.shallContinueSync(changes);
  }
  onResourceStoreBeforeSync({ changes }) {
    const me = this;
    me.removeNonPersistableRecordsToCreate(changes);
    return me.shallContinueSync(changes);
  }
  onAssignmentStoreBeforeSync({ changes }) {
    const me = this;
    me.removeNonPersistableRecordsToCreate(changes);
    return me.shallContinueSync(changes);
  }
  onDependencyStoreBeforeSync({ changes }) {
    const me = this;
    me.removeNonPersistableRecordsToCreate(changes);
    return me.shallContinueSync(changes);
  }
  // endregion
  // region Management rules
  removeNonPersistableRecordsToCreate(changes) {
    const recordsToCreate = changes.added || [];
    let r, i;
    for (i = recordsToCreate.length - 1; i >= 0; --i) {
      r = recordsToCreate[i];
      if (!r.isPersistable) {
        recordsToCreate.splice(recordsToCreate.indexOf(r), 1);
      }
    }
    if (recordsToCreate.length === 0) {
      changes.added.length = 0;
    }
  }
  shallContinueSync(options) {
    return Boolean(options.added && options.added.length > 0 || options.modified && options.modified.length > 0 || options.removed && options.removed.length > 0);
  }
  // endregion
};
ModelPersistencyManager._$name = "ModelPersistencyManager";

// ../Scheduler/lib/Scheduler/model/ProjectModel.js
var EngineMixin9 = SchedulerCoreProjectMixin;
var ProjectModel = class extends ProjectCurrentConfig_default(ProjectModelMixin_default(EngineMixin9)) {
  static get $name() {
    return "ProjectModel";
  }
  //region Inline data configs & properties
  /**
   * @hidefields id, readOnly, children, parentId, parentIndex
   */
  /**
   * Get/set {@link #property-eventStore} data.
   *
   * Always returns an array of {@link Scheduler.model.EventModel EventModels} but also accepts an array of
   * its configuration objects as input.
   *
   * @member {Scheduler.model.EventModel[]} events
   * @accepts {Scheduler.model.EventModel[]|EventModelConfig[]}
   * @category Inline data
   */
  /**
   * Data use to fill the {@link #property-eventStore}. Should be an array of
   * {@link Scheduler.model.EventModel EventModels} or its configuration objects.
   *
   * @config {Scheduler.model.EventModel[]|EventModelConfig[]} events
   * @category Inline data
   */
  /**
   * Get/set {@link #property-resourceStore} data.
   *
   * Always returns an array of {@link Scheduler.model.ResourceModel ResourceModels} but also accepts an array
   * of its configuration objects as input.
   *
   * @member {Scheduler.model.ResourceModel[]} resources
   * @accepts {Scheduler.model.ResourceModel[]|ResourceModelConfig[]}
   * @category Inline data
   */
  /**
   * Data use to fill the {@link #property-resourceStore}. Should be an array of
   * {@link Scheduler.model.ResourceModel ResourceModels} or its configuration objects.
   *
   * @config {Scheduler.model.ResourceModel[]|ResourceModelConfig[]} resources
   * @category Inline data
   */
  /**
   * Get/set {@link #property-assignmentStore} data.
   *
   * Always returns an array of {@link Scheduler.model.AssignmentModel AssignmentModels} but also accepts an
   * array of its configuration objects as input.
   *
   * @member {Scheduler.model.AssignmentModel[]} assignments
   * @accepts {Scheduler.model.AssignmentModel[]|AssignmentModelConfig[]}
   * @category Inline data
   */
  /**
   * Data use to fill the {@link #property-assignmentStore}. Should be an array of
   * {@link Scheduler.model.AssignmentModel AssignmentModels} or its configuration objects.
   *
   * @config {Scheduler.model.AssignmentModel[]|AssignmentModelConfig[]} assignments
   * @category Inline data
   */
  /**
   * Get/set {@link #property-dependencyStore} data.
   *
   * Always returns an array of {@link Scheduler.model.DependencyModel DependencyModels} but also accepts an
   * array of its configuration objects as input.
   *
   * @member {Scheduler.model.DependencyModel[]} dependencies
   * @accepts {Scheduler.model.DependencyModel[]|DependencyModelConfig[]}
   * @category Inline data
   */
  /**
   * Data use to fill the {@link #property-dependencyStore}. Should be an array of
   * {@link Scheduler.model.DependencyModel DependencyModels} or its configuration objects.
   *
   * @config {Scheduler.model.DependencyModel[]|DependencyModelConfig[]} dependencies
   * @category Inline data
   */
  /**
   * Get/set {@link #property-timeRangeStore} data.
   *
   * Always returns an array of {@link Scheduler.model.TimeSpan TimeSpans} but also accepts an
   * array of its configuration objects as input.
   *
   * @member {Scheduler.model.TimeSpan[]} timeRanges
   * @accepts {Scheduler.model.TimeSpan[]|TimeSpanConfig[]}
   * @category Inline data
   */
  /**
   * Data use to fill the {@link #property-timeRangeStore}. Should be an array of
   * {@link Scheduler.model.TimeSpan TimeSpans} or its configuration objects.
   *
   * @config {Scheduler.model.TimeSpan[]|TimeSpanConfig[]} timeRanges
   * @category Inline data
   */
  /**
   * Get/set {@link #property-resourceTimeRangeStore} data.
   *
   * Always returns an array of {@link Scheduler.model.ResourceTimeRangeModel ResourceTimeRangeModels} but
   * also accepts an array of its configuration objects as input.
   *
   * @member {Scheduler.model.ResourceTimeRangeModel[]} resourceTimeRanges
   * @accepts {Scheduler.model.ResourceTimeRangeModel[]|ResourceTimeRangeModelConfig[]}
   * @category Inline data
   */
  /**
   * Data use to fill the {@link #property-resourceTimeRangeStore}. Should be an array
   * of {@link Scheduler.model.ResourceTimeRangeModel ResourceTimeRangeModels} or its configuration objects.
   *
   * @config {Scheduler.model.ResourceTimeRangeModel[]|ResourceTimeRangeModelConfig[]} resourceTimeRanges
   * @category Inline data
   */
  //endregion
  //region Legacy inline data configs & properties
  /**
   * The initial data, to fill the {@link #property-eventStore} with.
   * Should be an array of {@link Scheduler.model.EventModel EventModels} or its configuration objects.
   *
   * @config {Scheduler.model.EventModel[]|EventModelConfig[]} eventsData
   * @category Legacy inline data
   */
  /**
   * The initial data, to fill the {@link #property-dependencyStore} with.
   * Should be an array of {@link Scheduler.model.DependencyModel DependencyModels} or its configuration
   * objects.
   *
   * @config {Scheduler.model.DependencyModel[]|DependencyModelConfig[]} [dependenciesData]
   * @category Legacy inline data
   */
  /**
   * The initial data, to fill the {@link #property-resourceStore} with.
   * Should be an array of {@link Scheduler.model.ResourceModel ResourceModels} or its configuration objects.
   *
   * @config {Scheduler.model.ResourceModel[]|ResourceModelConfig[]} [resourcesData]
   * @category Legacy inline data
   */
  /**
   * The initial data, to fill the {@link #property-assignmentStore} with.
   * Should be an array of {@link Scheduler.model.AssignmentModel AssignmentModels} or its configuration
   * objects.
   *
   * @config {Scheduler.model.AssignmentModel[]|AssignmentModelConfig[]} [assignmentsData]
   * @category Legacy inline data
   */
  //endregion
  //region Store configs & properties
  /**
   * The {@link Scheduler.data.EventStore store} holding the events information.
   *
   * See also {@link Scheduler.model.EventModel}
   *
   * @member {Scheduler.data.EventStore} eventStore
   * @category Models & Stores
   */
  /**
   * An {@link Scheduler.data.EventStore} instance or a config object.
   * @config {Scheduler.data.EventStore|EventStoreConfig} eventStore
   * @category Models & Stores
   */
  /**
   * The {@link Scheduler.data.DependencyStore store} holding the dependencies information.
   *
   * See also {@link Scheduler.model.DependencyModel}
   *
   * @member {Scheduler.data.DependencyStore} dependencyStore
   * @category Models & Stores
   */
  /**
   * A {@link Scheduler.data.DependencyStore} instance or a config object.
   * @config {Scheduler.data.DependencyStore|DependencyStoreConfig} dependencyStore
   * @category Models & Stores
   */
  /**
   * The {@link Scheduler.data.ResourceStore store} holding the resources that can be assigned to the events in the event store.
   *
   * See also {@link Scheduler.model.ResourceModel}
   *
   * @member {Scheduler.data.ResourceStore} resourceStore
   * @category Models & Stores
   */
  /**
   * A {@link Scheduler.data.ResourceStore} instance or a config object.
   * @config {Scheduler.data.ResourceStore|ResourceStoreConfig} resourceStore
   * @category Models & Stores
   */
  /**
   * The {@link Scheduler.data.AssignmentStore store} holding the assignments information.
   *
   * See also {@link Scheduler.model.AssignmentModel}
   *
   * @member {Scheduler.data.AssignmentStore} assignmentStore
   * @category Models & Stores
   */
  /**
   * An {@link Scheduler.data.AssignmentStore} instance or a config object.
   * @config {Scheduler.data.AssignmentStore|AssignmentStoreConfig} assignmentStore
   * @category Models & Stores
   */
  //endregion
  //region Configs
  static get defaultConfig() {
    return {
      /**
       * The constructor of the event model class, to be used in the project. Will be set as the
       * {@link Core.data.Store#config-modelClass modelClass} property of the {@link #property-eventStore}
       *
       * @config {Scheduler.model.EventModel}
       * @typings {typeof EventModel}
       * @category Models & Stores
       */
      eventModelClass: EventModel,
      /**
       * The constructor of the dependency model class, to be used in the project. Will be set as the
       * {@link Core.data.Store#config-modelClass modelClass} property of the {@link #property-dependencyStore}
       *
       * @config {Scheduler.model.DependencyModel}
       * @typings {typeof DependencyModel}
       * @category Models & Stores
       */
      dependencyModelClass: DependencyModel,
      /**
       * The constructor of the resource model class, to be used in the project. Will be set as the
       * {@link Core.data.Store#config-modelClass modelClass} property of the {@link #property-resourceStore}
       *
       * @config {Scheduler.model.ResourceModel}
       * @typings {typeof ResourceModel}
       * @category Models & Stores
       */
      resourceModelClass: ResourceModel,
      /**
       * The constructor of the assignment model class, to be used in the project. Will be set as the
       * {@link Core.data.Store#config-modelClass modelClass} property of the {@link #property-assignmentStore}
       *
       * @config {Scheduler.model.AssignmentModel}
       * @typings {typeof AssignmentModel}
       * @category Models & Stores
       */
      assignmentModelClass: AssignmentModel,
      /**
       * The constructor to create an event store instance with. Should be a class, subclassing the
       * {@link Scheduler.data.EventStore}
       * @config {Scheduler.data.EventStore|Object}
       * @typings {typeof EventStore|object}
       * @category Models & Stores
       */
      eventStoreClass: EventStore,
      /**
       * The constructor to create a dependency store instance with. Should be a class, subclassing the
       * {@link Scheduler.data.DependencyStore}
       * @config {Scheduler.data.DependencyStore|Object}
       * @typings {typeof DependencyStore|object}
       * @category Models & Stores
       */
      dependencyStoreClass: DependencyStore,
      /**
       * The constructor to create a resource store instance with. Should be a class, subclassing the
       * {@link Scheduler.data.ResourceStore}
       * @config {Scheduler.data.ResourceStore|Object}
       * @typings {typeof ResourceStore|object}
       * @category Models & Stores
       */
      resourceStoreClass: ResourceStore,
      /**
       * The constructor to create an assignment store instance with. Should be a class, subclassing the
       * {@link Scheduler.data.AssignmentStore}
       * @config {Scheduler.data.AssignmentStore|Object}
       * @typings {typeof AssignmentStore|object}
       * @category Models & Stores
       */
      assignmentStoreClass: AssignmentStore
    };
  }
  //endregion
  //region Events
  /**
   * Fired when the engine has finished its calculations and the results has been written back to the records.
   *
   * ```javascript
   * scheduler.project.on({
   *     dataReady() {
   *        console.log('Calculations finished');
   *     }
   * });
   *
   * scheduler.eventStore.first.duration = 10;
   *
   * // At some point a bit later it will log 'Calculations finished'
   * ```
   *
   * @event dataReady
   * @param {Scheduler.model.ProjectModel} source The project
   * @param {Boolean} isInitialCommit Flag that shows if this commit is initial
   * @param {Set} records Set of all {@link Core.data.Model}s that were modified in the completed transaction.
   * Use the {@link Core.data.Model#property-modifications} property of each Model to identify
   * modified fields.
   */
  //endregion
  /**
   * Silences propagations caused by the project loading.
   *
   * Applying the loaded data to the project occurs in two basic stages:
   *
   * 1. Data gets into the engine graph which triggers changes propagation
   * 2. The changes caused by the propagation get written to related stores
   *
   * Setting this flag to `true` makes the component perform step 2 silently without triggering events causing reactions on those changes
   * (like sending changes back to the server if `autoSync` is enabled) and keeping stores in unmodified state.
   *
   * This is safe if the loaded data is consistent so propagation doesn't really do any adjustments.
   * By default the system treats the data as consistent so this option is `true`.
   *
   * ```js
   * new Scheduler({
   *     project : {
   *         // We want scheduling engine to recalculate the data properly
   *         // so then we could save it back to the server
   *         silenceInitialCommit : false
   *     }
   *     ...
   * })
   * ```
   *
   * @config {Boolean} silenceInitialCommit
   * @default true
   * @category Advanced
   */
  construct(...args) {
    super.construct(...args);
    if (VersionHelper.isTestEnv) {
      globalThis.bryntum.testProject = this;
    }
    this.modelPersistencyManager = this.createModelPersistencyManager();
  }
  /**
   * Creates and returns model persistency manager
   *
   * @returns {Scheduler.data.util.ModelPersistencyManager}
   * @internal
   */
  createModelPersistencyManager() {
    return new ModelPersistencyManager({
      eventStore: this,
      resourceStore: this.resourceStore,
      assignmentStore: this.assignmentStore,
      dependencyStore: this.dependencyStore
    });
  }
  doDestroy() {
    this.modelPersistencyManager.destroy();
    super.doDestroy();
  }
  // To comply with TaskBoards expectations
  get taskStore() {
    return this.eventStore;
  }
};
ProjectModel.applyConfigs = true;
ProjectModel.initClass();
ProjectModel._$name = "ProjectModel";

// ../SchedulerPro/lib/SchedulerPro/data/mixin/PartOfProject.js
var throwIfNotTheSameStore = (oldStore, newStore) => {
  if (oldStore !== newStore) {
    throw new Error("Store set is prohibited for Scheduler Pro entity!");
  }
};
var PartOfProject_default2 = (Target) => class PartOfProject extends (Target || Base2) {
  static get $name() {
    return "PartOfProject";
  }
  /**
   * Returns the project this entity belongs to.
   *
   * @member {SchedulerPro.model.ProjectModel} project
   * @readonly
   */
  /**
   * An {@link SchedulerPro.data.EventStore} instance or a config object.
   * @config {SchedulerPro.data.EventStore|EventStoreConfig} taskStore
   * @category Project
   */
  /**
   * The {@link SchedulerPro.data.EventStore store} holding data on events.
   *
   * @member {SchedulerPro.data.EventStore}
   * @category Project
   * @readonly
   */
  get taskStore() {
    return this.eventStore;
  }
  // this setter actually does nothing, intentionally, setting the stores on other stores is deprecated
  set taskStore(store) {
    this.eventStore = store;
  }
  /**
   * Returns the task store of the project this entity belongs to.
   *
   * @property {SchedulerPro.data.EventStore}
   * @category Project
   * @readonly
   * @typings Scheduler.model.mixin.ProjectModelMixin:eventStore -> {Scheduler.data.EventStore||SchedulerPro.data.EventStore}
   */
  get eventStore() {
    var _a2;
    return (_a2 = this.project) == null ? void 0 : _a2.eventStore;
  }
  get leftProjectEventStore() {
    const project = this.leftProject;
    return (project == null ? void 0 : project.getEventStore()) || null;
  }
  // this setter actually does nothing, intentionally, setting the stores on other stores is deprecated
  set eventStore(store) {
    throwIfNotTheSameStore(this.eventStore, store);
  }
  /**
   * Returns the dependency store of the project this entity belongs to.
   *
   * @property {SchedulerPro.data.DependencyStore}
   * @category Project
   * @readonly
   * @typings Scheduler.model.mixin.ProjectModelMixin:dependencyStore -> {Scheduler.data.DependencyStore||SchedulerPro.data.DependencyStore}
   */
  get dependencyStore() {
    var _a2;
    return (_a2 = this.project) == null ? void 0 : _a2.dependencyStore;
  }
  // this setter actually does nothing, intentionally, setting the stores on other stores is deprecated
  set dependencyStore(store) {
    throwIfNotTheSameStore(this.dependencyStore, store);
  }
  /**
   * Returns the assignment store of the project this entity belongs to.
   *
   * @property {SchedulerPro.data.AssignmentStore}
   * @readonly
   * @category Project
   * @typings Scheduler.model.mixin.ProjectModelMixin:assignmentStore -> {Scheduler.data.AssignmentStore||SchedulerPro.data.AssignmentStore}
   */
  get assignmentStore() {
    var _a2;
    return (_a2 = this.project) == null ? void 0 : _a2.assignmentStore;
  }
  // this setter actually does nothing, intentionally, setting the stores on other stores is deprecated
  set assignmentStore(store) {
    throwIfNotTheSameStore(this.assignmentStore, store);
  }
  /**
   * Returns the resource store of the project this entity belongs to.
   *
   * @property {SchedulerPro.data.ResourceStore}
   * @readonly
   * @category Project
   * @typings Scheduler.model.mixin.ProjectModelMixin:resourceStore -> {Scheduler.data.ResourceStore||SchedulerPro.data.ResourceStore}
   */
  get resourceStore() {
    var _a2;
    return (_a2 = this.project) == null ? void 0 : _a2.resourceStore;
  }
  // this setter actually does nothing, intentionally, setting the stores on other stores is deprecated
  set resourceStore(store) {
    throwIfNotTheSameStore(this.resourceStore, store);
  }
  /**
   * Returns the calendar manager store of the project this entity belongs to.
   *
   * @property {SchedulerPro.data.CalendarManagerStore}
   * @readonly
   * @category Project
   */
  get calendarManagerStore() {
    var _a2;
    return (_a2 = this.project) == null ? void 0 : _a2.calendarManagerStore;
  }
  // this setter actually does nothing, intentionally, setting the stores on other stores is deprecated
  set calendarManagerStore(store) {
    throwIfNotTheSameStore(this.calendarManagerStore, store);
  }
};

// ../SchedulerPro/lib/SchedulerPro/model/AssignmentModel.js
var AssignmentModel2 = class extends PartOfProject_default2(AssignmentModelMixin_default(SchedulerProAssignmentMixin.derive(Model))) {
  //endregion
  //region Early render
  get event() {
    const { project } = this, event = super.event;
    if (project == null ? void 0 : project.isDelayingCalculation) {
      return project.eventStore.getById(event);
    }
    return event;
  }
  set event(event) {
    super.event = event;
  }
  get resource() {
    const { project } = this;
    let resource = super.resource;
    if (project == null ? void 0 : project.isDelayingCalculation) {
      resource = project.resourceStore.getById(resource);
    }
    return resource == null ? void 0 : resource.$original;
  }
  set resource(resource) {
    super.resource = resource;
  }
  //endregion
  get eventResourceKey() {
    return this.isInActiveTransaction ? this.buildEventResourceKey(this.event, this.resource) : this.buildEventResourceKey(this.$.event.DATA, this.$.resource.DATA);
  }
};
// NOTE: Leave field defs at top to be picked up by jsdoc
/**
 * Id for event to assign. Can be used as an alternative to `eventId`, but please note that after
 * load it will be populated with the actual event and not its id. This field is not persistable.
 * @field {SchedulerPro.model.EventModel} event
 * @accepts {String|Number|SchedulerPro.model.EventModel}
 * @typings {String||Number||SchedulerPro.model.EventModel||Core.model.Model}
 * @category Common
 */
/**
 * Id for resource to assign to. Can be used as an alternative to `resourceId`, but please note that after
 * load it will be populated with the actual resource and not its id. This field is not persistable.
 * @field {SchedulerPro.model.ResourceModel} resource
 * @accepts {String|Number|SchedulerPro.model.ResourceModel}
 * @category Common
 */
/**
 * A numeric, percent-like value, indicating the "contribution level"
 * of the resource availability to the {@link #field-event}.
 * Number 100 means that the assigned {@link #field-resource} spends all its working time
 * on the {@link #field-event}.
 * And number 50 means that the resource spends only half of its available time
 * on the {@link #field-event}.
 * Setting the value to 0 will unassign the resource (and remove the assignment)
 * @field {Number} units
 * @category Common
 */
//region Config
__publicField(AssignmentModel2, "$name", "AssignmentModel");
__publicField(AssignmentModel2, "isProAssignmentModel", true);
AssignmentModel2._$name = "AssignmentModel";

// ../SchedulerPro/lib/SchedulerPro/data/AssignmentStore.js
var AssignmentStore2 = class extends PartOfProject_default2(AssignmentStoreMixin_default(ChronoAssignmentStoreMixin.derive(AjaxStore))) {
  static get defaultConfig() {
    return {
      modelClass: AssignmentModel2
    };
  }
};
__publicField(AssignmentStore2, "$name", "AssignmentStore");
AssignmentStore2._$name = "AssignmentStore";

// ../SchedulerPro/lib/SchedulerPro/model/CalendarIntervalModel.js
var CalendarIntervalModel = class extends PartOfProject_default2(CalendarIntervalMixin.derive(Model)) {
  // NOTE: Leave field defs at top to be picked up by jsdoc
  //region Fields
  /**
   * The start date of the fixed (not recurrent) time interval.
   *
   * @field {Date} startDate
   */
  /**
   * The end date of the fixed (not recurrent) time interval.
   *
   * @field {Date} endDate
   */
  /**
   * The start date of the recurrent time interval. Should be specified as any expression, recognized
   * by the excellent [later](http://bunkat.github.io/later/) library.
   *
   * @field {String} recurrentStartDate
   */
  /**
   * The end date of the recurrent time interval. Should be specified as any expression, recognized
   * by the excellent [later](http://bunkat.github.io/later/) library.
   *
   * @field {String} recurrentEndDate
   */
  /**
   * The "is working" flag, which defines what kind of interval this is - either working or non-working. Default value is `false`,
   * denoting non-working intervals.
   *
   * @field {Boolean} isWorking
   * @default false
   */
  /**
   * A CSS class to add to the element visualizing this interval, when using the NonWorkingTime feature.
   * <div class="note">Note that only non working intervals are visible.</div>
   *
   * @field {String} cls
   */
  /**
   * A CSS class used to add an icon to the element visualizing this interval, when using the NonWorkingTime feature.
   * <div class="note">Note that only non working intervals are visible.</div>
   *
   * @field {String} iconCls
   */
  //endregion
  //region Methods
  /**
   * Whether this interval is recurrent (both `recurrentStartDate` and `recurrentEndDate` are present and parsed correctly
   * by the `later` library).
   *
   * @method isRecurrent
   * @returns {Boolean}
   */
  /**
   * Whether this interval is static - both `startDate` and `endDate` are present.
   *
   * @method isStatic
   * @returns {Boolean}
   */
  /**
   * Returns an internal representation of the recurrent start date from the `later` library.
   *
   * @method getStartDateSchedule
   * @returns {Object}
   */
  /**
   * Returns an internal representation of the recurrent end date from the `later` library.
   *
   * @method getEndDateSchedule
   * @returns {Object}
   */
  //endregion
  //region Config
  static get $name() {
    return "CalendarIntervalModel";
  }
  //endregion
};
CalendarIntervalModel._$name = "CalendarIntervalModel";

// ../SchedulerPro/lib/SchedulerPro/model/CalendarModel.js
var CalendarModel = class extends PartOfProject_default2(BaseCalendarMixin.derive(Model)) {
  //region Config
  static get $name() {
    return "CalendarModel";
  }
  /**
   * Returns the earliest point at which a working period of time starts, following the given date.
   * Can be the date itself, if it occurs during working time.
   * @method skipNonWorkingTime
   * @param {Date} date The date after which to skip the non-working time
   * @param {Boolean} [isForward=true] Whether the "following" means forward in time or backward
   * @returns {Date} The earliest available date
   */
  /**
   * Returns working time ranges between the provided dates.
   * @method getWorkingTimeRanges
   * @param {Date} startDate Start of the period to get ranges from
   * @param {Date} endDate End of the period to get ranges from
   * @returns {Array<{name: string, startDate: Date, endDate: Date}>} An array of objects representing working time ranges
   */
  /**
   * Returns non-working time ranges between the provided dates.
   * @method getNonWorkingTimeRanges
   * @param {Date} startDate Start of the period to get ranges from
   * @param {Date} endDate End of the period to get ranges from
   * @returns {Array<{name: string, startDate: Date, endDate: Date}>} An array of objects representing non-working time ranges
   */
  /**
   * This method adds a single {@link SchedulerPro.model.CalendarIntervalModel} to the internal collection of the
   * calendar
   * @method addInterval
   * @param {SchedulerPro.model.CalendarIntervalModel|CalendarIntervalModelConfig} interval record or an object with
   * data used to create a new record
   * @returns {SchedulerPro.model.CalendarIntervalModel[]} Added intervals
   */
  /**
   * This method adds an array of {@link SchedulerPro.model.CalendarIntervalModel} to the internal collection of the
   * calendar
   * @method addIntervals
   * @param {SchedulerPro.model.CalendarIntervalModel[]|CalendarIntervalModelConfig[]} intervals An array of records
   * or an array of objects with data used to create new records
   * @returns {SchedulerPro.model.CalendarIntervalModel[]} Added intervals
   */
  /**
   * This method removes all intervals from the internal collection of the calendar
   * @method clearIntervals
   * @param {Boolean} [silent] Do not trigger events
   */
  /**
   * Calculate the working time duration for specific interval, in milliseconds.
   * @method calculateDurationMs
   * @param {Date} startDate Start of the interval
   * @param {Date} endDate End of the interval
   * @returns {Number} Returns working time in milliseconds
   */
  /**
   * Checks if there is a working time interval in the provided time range
   * @method isWorkingTime
   * @param {Date} startDate Start of the interval
   * @param {Date} endDate End of the interval
   * @returns {Boolean} Returns `true` if the interval contains working time
   */
  /**
   * Calculates the end date of the time interval which starts at `startDate` and has `durationMs` working time
   * duration (in milliseconds).
   * @method calculateEndDate
   * @param {Date} startDate Start date
   * @param {Number} durationMs Duration in milliseconds
   * @returns {Date} The end date
   */
  /**
   * Calculates the start date of the time interval which ends at `endDate` and has `durationMs` working time
   * duration (in milliseconds).
   * @method calculateStartDate
   * @param {Date} endDate End date
   * @param {Number} durationMs Duration in milliseconds
   * @returns {Date} The start date
   */
  static get fields() {
    return [
      /**
       * The calendar name.
       * @field {String} name
       */
      /**
       * A CSS class to add to calendar interval elements rendered in the UI.
       * @field {String} cls
       */
      /**
       * A CSS class defining an icon to show in non-working time elements rendered in the UI.
       * @field {String} iconCls
       */
      /**
       * The flag, indicating, whether the "unspecified" time (time that does not belong to any interval
       * is working (`true`) or not (`false`).
       *
       * @field {Boolean} unspecifiedTimeIsWorking
       * @default true
       */
      /**
       * {@link SchedulerPro.model.CalendarIntervalModel Intervals} collection of the calendar. Accepts an array
       * as its input, which behind the scenes will be converted to a store containing the intervals. When
       * serializing it will be converted back to an array.
       *
       * @field {Core.data.Store} intervals
       * @accepts {SchedulerPro.model.CalendarIntervalModel[]|CalendarIntervalModelConfig[]}
       */
      /**
       * Start expanded or not
       * @readonly
       * @field {Boolean} expanded
       * @default true
       * @category Tree
       */
      {
        name: "expanded",
        internal: true,
        defaultValue: true
      },
      /**
       * If using the {@link Scheduler.model.ProjectModel#config-timeZone} config, you can set this to `true` to
       * *not* convert this calendar to the specified time zone.
       * @field {Boolean} ignoreTimeZone
       */
      "ignoreTimeZone"
    ];
  }
  //endregion
  toString() {
    return this.name || "";
  }
  static get defaultConfig() {
    return {
      calendarIntervalModelClass: CalendarIntervalModel
    };
  }
};
CalendarModel._$name = "CalendarModel";

// ../SchedulerPro/lib/SchedulerPro/data/CalendarManagerStore.js
var CalendarManagerStore = class extends PartOfProject_default2(ChronoCalendarManagerStoreMixin.derive(AjaxStore)) {
  //region Config
  static get defaultConfig() {
    return {
      tree: true,
      modelClass: CalendarModel,
      /**
       * CrudManager must load stores in the correct order. Lowest first.
       * @private
       */
      loadPriority: 100,
      /**
       * CrudManager must sync stores in the correct order. Lowest first.
       * @private
       */
      syncPriority: 100,
      storeId: "calendars"
    };
  }
  //endregion
};
CalendarManagerStore._$name = "CalendarManagerStore";

// ../SchedulerPro/lib/SchedulerPro/model/DependencyModel.js
var DependencyModel2 = class extends PartOfProject_default2(SchedulerProDependencyMixin.derive(DependencyBaseModel)) {
  // NOTE: Leave field defs at top to be picked up by jsdoc
  /**
   * The calendar of the dependency used to take `lag` duration into account.
   * @field {SchedulerPro.model.CalendarModel} calendar
   */
  /**
   * Set to `false` to ignore this dependency in scheduling
   * @field {Boolean} active
   * @category Dependency
   */
  //region Config
  static get $name() {
    return "DependencyModel";
  }
  static get isProDependencyModel() {
    return true;
  }
  //endregion
  //region Render early
  // Buckets and references are not set up yet during early render, need to look up on stores
  get fromEvent() {
    var _a2;
    if ((_a2 = this.project) == null ? void 0 : _a2.isDelayingCalculation) {
      return this.project.eventStore.getById(super.fromEvent);
    }
    return super.fromEvent;
  }
  set fromEvent(from) {
    super.fromEvent = from;
  }
  get toEvent() {
    var _a2;
    if ((_a2 = this.project) == null ? void 0 : _a2.isDelayingCalculation) {
      return this.project.eventStore.getById(super.toEvent);
    }
    return super.toEvent;
  }
  set toEvent(to) {
    super.toEvent = to;
  }
  //endregion
};
DependencyModel2._$name = "DependencyModel";

// ../SchedulerPro/lib/SchedulerPro/data/DependencyStore.js
var DependencyStore2 = class extends PartOfProject_default2(DependencyStoreMixin_default(ChronoDependencyStoreMixin.derive(AjaxStore))) {
  static get defaultConfig() {
    return {
      modelClass: DependencyModel2
    };
  }
};
DependencyStore2._$name = "DependencyStore";

// ../SchedulerPro/lib/SchedulerPro/model/mixin/PercentDoneMixin.js
var PercentDoneMixin_default = (Target) => class PercentDoneMixin extends Target {
  static get $name() {
    return "PercentDoneMixin";
  }
  /**
   * The current status of a task, expressed as the percentage completed (integer from 0 to 100)
   * @field {Number} percentDone
   * @category Scheduling
   */
  // Field defined in Engine
  /**
   * Indicates if the task is started (its {@link #field-percentDone percent completion} is greater than zero).
   * @property {Boolean}
   * @category Progress
   */
  get isStarted() {
    return this.percentDone > 0;
  }
  /**
   * Indicates if the task is complete (its {@link #field-percentDone percent completion} is 100% (or greater)).
   * @property {Boolean}
   * @category Progress
   */
  get isCompleted() {
    return this.percentDone >= 100;
  }
  /**
   * Indicates if the task is in progress (its {@link #field-percentDone percent completion} is greater than zero and less than 100%).
   * @property {Boolean}
   * @category Progress
   */
  get isInProgress() {
    return this.isStarted && !this.isCompleted;
  }
  // Reset % done value when copying a task
  copy() {
    const copy = super.copy(...arguments);
    copy.percentDone = 0;
    copy.clearChanges();
    return copy;
  }
  /**
   * Human-friendly rounding. When task is completed < 99%, it rounds the value. It floors value between 99 and 100, to not
   * show task as completed when it is for example 99.51% done.
   * @property {Number}
   * @category Progress
   */
  get renderedPercentDone() {
    const value = typeof this.percentDone === "number" && !isNaN(this.percentDone) ? this.percentDone : 0;
    return this.getFormattedPercentDone(value);
  }
  getFormattedPercentDone(value = 0) {
    if (value <= 99) {
      return Math.round(value);
    }
    return Math.floor(value);
  }
  set renderedPercentDone(value) {
    this.percentDone = value;
  }
};

// ../SchedulerPro/lib/SchedulerPro/model/EventSegmentModel.js
var EventSegmentModel = class extends SchedulerProEventSegment.derive(TimeSpan).mixin(
  EventModelMixin_default,
  PercentDoneMixin_default
) {
  static get $name() {
    return "EventSegmentModel";
  }
  /**
   * Zero-based index of the segment.
   * @property {Number} segmentIndex
   */
  /**
   * The event this segment belongs to.
   * @member {SchedulerPro.model.EventModel} event
   * @readonly
   */
  /**
   * Alias for `event`, to better match naming in Gantt.
   * @member {SchedulerPro.model.EventModel} task
   * @readonly
   */
  get task() {
    return this.event;
  }
};
EventSegmentModel._$name = "EventSegmentModel";

// ../SchedulerPro/lib/SchedulerPro/model/EventModel.js
var EventModel2 = class extends SchedulerProEvent.derive(TimeSpan).mixin(
  RecurringTimeSpan_default,
  PartOfProject_default2,
  EventModelMixin_default,
  PercentDoneMixin_default
) {
  /**
   * Returns the event store this event is part of.
   *
   * @member {SchedulerPro.data.EventStore} eventStore
   * @readonly
   * @typings Scheduler.model.TimeSpan:eventStore -> {Scheduler.data.EventStore||SchedulerPro.data.EventStore}
   */
  /**
   * If given resource is assigned to this event, returns a {@link SchedulerPro.model.AssignmentModel} record.
   * Otherwise returns `null`
   *
   * @method getAssignmentFor
   * @param {SchedulerPro.model.ResourceModel} resource The instance of {@link SchedulerPro.model.ResourceModel}
   *
   * @returns {SchedulerPro.model.AssignmentModel|null}
   */
  /**
   * This method assigns a resource to this event.
   *
   * Will cause the schedule to be updated - returns a `Promise`
   *
   * @method assign
   * @param {SchedulerPro.model.ResourceModel} resource The instance of {@link SchedulerPro.model.ResourceModel}
   * @param {Number} [units=100] The `units` field of the new assignment
   *
   * @async
   * @propagating
   */
  /**
   * This method unassigns a resource from this event.
   *
   * Will cause the schedule to be updated - returns a `Promise`
   *
   * @method unassign
   * @param {SchedulerPro.model.ResourceModel} resource The instance of {@link SchedulerPro.model.ResourceModel}
   *
   * @async
   * @propagating
   */
  /**
   * Sets the calendar of the event. Will cause the schedule to be updated - returns a `Promise`
   *
   * @method setCalendar
   * @param {SchedulerPro.model.CalendarModel} calendar The new calendar. Provide `null` to fall back to the project calendar.
   * @async
   * @propagating
   */
  /**
   * Returns the event calendar.
   *
   * @method getCalendar
   * @returns {SchedulerPro.model.CalendarModel} The event calendar.
   */
  /**
   * Either activates or deactivates the task depending on the passed value.
   * Will cause the schedule to be updated - returns a `Promise`
   *
   * @method setInactive
   * @param {Boolean} inactive `true` to deactivate the task, `false` to activate it.
   * @async
   * @propagating
   */
  /**
   * Sets the start date of the event. Will cause the schedule to be updated - returns a `Promise`
   *
   * Note, that the actually set start date may be adjusted, according to the calendar, by skipping the non-working time forward.
   *
   * @method setStartDate
   * @param {Date} date The new start date.
   * @param {Boolean} [keepDuration=true] Whether to keep the duration (and update the end date), while changing the start date, or vice-versa.
   * @async
   * @propagating
   */
  /**
   * Sets the end date of the event. Will cause the schedule to be updated - returns a `Promise`
   *
   * Note, that the actually set end date may be adjusted, according to the calendar, by skipping the non-working time backward.
   *
   * @method setEndDate
   * @param {Date} date The new end date.
   * @param {Boolean} [keepDuration=false] Whether to keep the duration (and update the start date), while changing the end date, or vice-versa.
   * @async
   * @propagating
   */
  /**
   * Updates the duration (and optionally unit) of the event. Will cause the schedule to be updated - returns a `Promise`
   *
   * @method setDuration
   * @param {Number} duration New duration value
   * @param {String} [unit] New duration unit
   * @async
   * @propagating
   */
  /**
   * Sets the constraint type and (optionally) constraining date to the event.
   *
   * @method setConstraint
   * @param {'finishnoearlierthan'|'finishnolaterthan'|'mustfinishon'|'muststarton'|'startnoearlierthan'|'startnolaterthan'|null} constraintType
   * Constraint type, please refer to the {@link #field-constraintType} for the valid
   * values.
   * @param {Date} [constraintDate] Constraint date.
   * @async
   * @propagating
   */
  /**
   * Updates the {@link #field-effort} (and optionally {@link #field-effortUnit unit}) of the event.
   * Will cause the schedule to be updated - returns a `Promise`
   *
   * @method setEffort
   * @param {Number} effort New effort value
   * @param {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} [unit] New effort
   * unit
   * @async
   * @propagating
   */
  /**
   * Sets {@link #field-segments} field value.
   *
   * @method
   * @name setSegments
   * @param {SchedulerPro.model.EventSegmentModel[]} segments Array of segments or null to make the event not segmented.
   * @returns {Promise}
   * @propagating
   */
  /**
   * Splits the event into segments.
   * @method splitToSegments
   * @param {Date} from The date to split this event at.
   * @param {Number} [lag=1] Split duration.
   * @param {String} [lagUnit] Split duration unit.
   * @returns {Promise}
   * @propagating
   */
  /**
   * Merges the event segments.
   * The method merges two provided event segments (and all the segment between them if any).
   * @method mergeSegments
   * @param {SchedulerPro.model.EventSegmentModel} [segment1] First segment to merge.
   * @param {SchedulerPro.model.EventSegmentModel} [segment2] Second segment to merge.
   * @returns {Promise}
   * @propagating
   */
  /**
   * Sets the event {@link #field-ignoreResourceCalendar} field value and triggers rescheduling.
   *
   * @method setIgnoreResourceCalendar
   * @param {Boolean} ignore Provide `true` to ignore the calendars of the assigned resources
   * when scheduling the event. If `false` the event performs only when
   * its own {@link #field-calendar} and some of the assigned
   * resource calendars allow that.
   * @async
   * @propagating
   */
  /**
   * Returns the event {@link #field-ignoreResourceCalendar} field value.
   *
   * @method getIgnoreResourceCalendar
   * @returns {Boolean} The event {@link #field-ignoreResourceCalendar} field value.
   */
  /**
   * The event first segment or null if the event is not segmented.
   * @member {SchedulerPro.model.EventSegmentModel} firstSegment
   */
  /**
   * The event last segment or null if the event is not segmented.
   * @member {SchedulerPro.model.EventSegmentModel} lastSegment
   */
  //region Config
  static get $name() {
    return "EventModel";
  }
  static get fields() {
    return [
      /**
       * This field is automatically set to `true` when the event is "unscheduled" - user has provided an empty
       * string in one of the UI editors for start date, end date or duration. Such event is not rendered,
       * and does not affect the schedule of its successors.
       *
       * To schedule the event back, enter one of the missing values, so that there's enough information
       * to calculate start date, end date and duration.
       *
       * Note, that setting this field manually does nothing. This field should be persisted, but not updated
       * manually.
       *
       * @field {Boolean} unscheduled
        * @readonly
        * @category Scheduling
       */
      /**
       * Segments of the event that appear when the event gets {@link #function-splitToSegments}.
       * @field {SchedulerPro.model.EventSegmentModel[]} segments
       * @category Scheduling
       */
      /**
       * The current status of a task, expressed as the percentage completed (integer from 0 to 100)
       *
       * UI fields representing this data field are disabled for summary events.
       * See {@link #function-isEditable} for details.
       *
       * @field {Number} percentDone
       * @category Scheduling
       */
      /**
       * The start date of a time span (or Event / Task).
       *
       * Uses {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat} to convert a
       * supplied string to a Date. To specify another format, either change that setting or subclass TimeSpan and
       * change the dateFormat for this field.
       *
       * UI fields representing this data field are disabled for summary events
       * except the {@link #field-manuallyScheduled manually scheduled} events.
       * See {@link #function-isEditable} for details.
       *
       * Note that the field always returns a `Date`.
       *
       * @field {Date} startDate
       * @accepts {String|Date}
       * @category Scheduling
       */
      /**
       * The end date of a time span (or Event / Task).
       *
       * Uses {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat} to convert a
       * supplied string to a Date. To specify another format, either change that setting or subclass TimeSpan and
       * change the dateFormat for this field.
       *
       * UI fields representing this data field are disabled for summary events
       * except the {@link #field-manuallyScheduled manually scheduled} events.
       * See {@link #function-isEditable} for details.
       *
       * Note that the field always returns a `Date`.
       *
       * @field {Date} endDate
       * @accepts {String|Date}
       * @category Scheduling
       */
      /**
       * The numeric part of the timespan's duration (the number of units).
       *
       * UI fields representing this data field are disabled for summary events
       * except the {@link #field-manuallyScheduled manually scheduled} events.
       * See {@link #function-isEditable} for details.
       *
       * @field {Number} duration
       * @category Scheduling
       */
      /**
       * Field storing the event constraint alias or NULL if not constraint set.
       * Valid values are:
       * - "finishnoearlierthan"
       * - "finishnolaterthan"
       * - "mustfinishon"
       * - "muststarton"
       * - "startnoearlierthan"
       * - "startnolaterthan"
       *
       * @field {'finishnoearlierthan'|'finishnolaterthan'|'mustfinishon'|'muststarton'|'startnoearlierthan'|'startnolaterthan'|null} constraintType
       * @category Scheduling
       */
      /**
       * Field defining the constraint boundary date, if applicable.
       * @field {Date} constraintDate
       * @category Scheduling
       */
      /**
       * When set to `true`, the `startDate` of the event will not be changed by any of its incoming dependencies
       * or constraints.
       *
       * @field {Boolean} manuallyScheduled
       * @category Scheduling
       */
      /**
       * When set to `true` the event becomes inactive and stops taking part in the project scheduling (doesn't
       * affect linked events and affect its assigned resources allocation).
       *
       * @field {Boolean} inactive
       * @category Scheduling
       */
      /**
       * When set to `true` the calendars of the assigned resources
       * are not taken into account when scheduling the event.
       *
       * By default the field value is `false` resulting in that the event performs only when
       * its own {@link #field-calendar} and some of the assigned
       * resource calendars allow that.
       * @field {Boolean} ignoreResourceCalendar
       * @category Scheduling
       */
      /**
       * A calculated field storing the _early start date_ of the event.
       * The _early start date_ is the earliest possible date the event can start.
       * This value is calculated based on the earliest dates of the event predecessors and the event own constraints.
       * If the event has no predecessors nor other constraints, its early start date matches the project start date.
       *
       * UI fields representing this data field are naturally disabled since the field is readonly.
       * See {@link #function-isEditable} for details.
       *
       * @field {Date} earlyStartDate
       * @calculated
       * @readonly
       * @category Scheduling
       */
      /**
       * A calculated field storing the _early end date_ of the event.
       * The _early end date_ is the earliest possible date the event can finish.
       * This value is calculated based on the earliest dates of the event predecessors and the event own constraints.
       * If the event has no predecessors nor other constraints, its early end date matches the project start date plus the event duration.
       *
       * UI fields representing this data field are naturally disabled since the field is readonly.
       * See {@link #function-isEditable} for details.
       *
       * @field {Date} earlyEndDate
       * @calculated
       * @readonly
       * @category Scheduling
       */
      /**
       * The calendar, assigned to the entity. Allows you to set the time when entity can perform the work.
       *
       * All entities are by default assigned to the project calendar, provided as the {@link SchedulerPro.model.ProjectModel#field-calendar} option.
       *
       * @field {SchedulerPro.model.CalendarModel} calendar
       * @category Scheduling
       */
      /**
       * The numeric part of the event effort (the number of units).
       *
       * @field {Number} effort
       * @category Scheduling
       */
      /**
       * The unit part of the event effort, defaults to "h" (hours). Valid values are:
       *
       * - "millisecond" - Milliseconds
       * - "second" - Seconds
       * - "minute" - Minutes
       * - "hour" - Hours
       * - "day" - Days
       * - "week" - Weeks
       * - "month" - Months
       * - "quarter" - Quarters
       * - "year"- Years
       *
       * This field is readonly after creation, to change it use the {@link #function-setEffort} call.
       * @field {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} effortUnit
       * @default "hour"
       * @category Scheduling
       * @readonly
       */
      /**
       * This field defines the event scheduling mode. Based on this field some fields of the event
       * will be "fixed" (should be provided by the user) and some - computed.
       *
       * Possible values are:
       *
       * - `Normal` is the default (and backward compatible) mode. It means the event will be scheduled based on
       * information about its start/end dates, event own calendar (project calendar if there's no one) and
       * calendars of the assigned resources.
       *
       * - `FixedDuration` mode means, that event has fixed start and end dates, but its effort will be computed
       * dynamically, based on the assigned resources information. When duration of such event increases,
       * its effort is increased too. The mode tends to preserve user provided duration so changing effort
       * results adjusting assignment units and vise-versa assignment changes adjusts effort.
       *
       * @field {'Normal'|'FixedDuration'} schedulingMode
       * @category Scheduling
       */
      /**
       * This boolean flag defines what part the data should be updated in the `FixedDuration` scheduling
       * mode.
       * If it is `true`, then {@link #field-effort} is kept intact when new duration is provided and
       * assignment {@link SchedulerPro.model.AssignmentModel#field-units} is updated.
       * If it is `false`, then assignment {@link SchedulerPro.model.AssignmentModel#field-units} is kept
       * intact when new duration is provided and {@link #field-effort} is updated.
       *
       * @field {Boolean} effortDriven
       * @default false
       * @category Scheduling
       */
      /**
       * The event effective calendar. Returns the
       * {@link SchedulerPro.model.ProjectModel#field-calendar project calendar} if the event has no own
       * {@link #field-calendar} provided.
       * @member {SchedulerPro.model.CalendarModel} effectiveCalendar
       */
      /**
       * Set this to true if this task should be shown in the Timeline widget
       * @field {Boolean} showInTimeline
       * @category Common
       */
      { name: "showInTimeline", type: "boolean", defaultValue: false },
      /**
       * Note about the event
       * @field {String} note
       * @category Common
       */
      "note",
      /**
       * Buffer time before event start. Specified in a human-friendly form as accepted by
       * {@link Core.helper.DateHelper#function-parseDuration-static}:
       * ```javascript
       * // Create event model with a 30 minutes buffer time before the event start
       * new EventModel({ startDate : '2020-01-01', endDate : '2020-01-02', preamble : '30 minutes' })
       * ```
       *
       * Used by the {@link SchedulerPro.feature.EventBuffer} feature.
       *
       * @field {Core.data.Duration} preamble
       * @accepts {String}
       * @category Scheduling
       */
      {
        name: "preamble",
        convert: (value) => value ? new Duration(value) : null
      },
      /**
       * Buffer time after event end. Specified in a human-friendly form as accepted by
       * {@link Core.helper.DateHelper#function-parseDuration-static}:
       * ```javascript
       * // Create event model with a 1 hour buffer time after the event end
       * new EventModel({ startDate : '2020-01-01', endDate : '2020-01-02', postamble : '1 hour' })
       * ```
       *
       * Used by the {@link SchedulerPro.feature.EventBuffer} feature.
       *
       * @field {String} postamble
       * @accepts {String}
       * @category Scheduling
       */
      {
        name: "postamble",
        convert: (value) => value ? new Duration(value) : null
      }
    ];
  }
  getDefaultSegmentModelClass() {
    return EventSegmentModel;
  }
  //endregion
  //region EventBuffer
  updateWrapDate(date, duration, forward = true) {
    duration = new Duration(duration);
    return new Date(date.getTime() + (forward ? 1 : -1) * duration.milliseconds);
  }
  get startDate() {
    var _a2;
    let dt;
    if (this.isOccurrence) {
      dt = this.get("startDate");
    } else {
      dt = (_a2 = this._startDate) != null ? _a2 : super.startDate;
    }
    if (this.allDay) {
      dt = this.constructor.getAllDayStartDate(dt);
    }
    return dt;
  }
  set startDate(startDate) {
    const me = this;
    if (me.generation && me.isParent && !me.$ignoreChange) {
      const timeDiff = DateHelper.diff(me.startDate, startDate);
      if (timeDiff) {
        for (const child of this.children) {
          child.startDate = DateHelper.add(child.startDate, timeDiff);
        }
      }
    }
    if (me.batching) {
      me._startDate = startDate;
      me.set({ startDate });
    } else {
      super.startDate = startDate;
      if (me.preamble) {
        me.wrapStartDate = null;
        me.wrapEndDate = null;
      }
    }
  }
  get endDate() {
    var _a2;
    let dt;
    if (this.isOccurrence) {
      dt = this.get("endDate");
    } else {
      dt = (_a2 = this._endDate) != null ? _a2 : super.endDate;
    }
    if (this.allDay) {
      dt = this.constructor.getAllDayEndDate(dt);
    }
    return dt;
  }
  set endDate(endDate) {
    const me = this;
    if (me.batching) {
      me._endDate = endDate;
      me.set({ endDate });
    } else {
      super.endDate = endDate;
      if (me.postamble) {
        me.wrapStartDate = null;
        me.wrapEndDate = null;
      }
    }
  }
  /**
   * Property which encapsulates the effort's magnitude and units.
   *
   * UI fields representing this property are disabled for summary events.
   * See {@link #function-isEditable} for details.
   *
   * @property {Core.data.Duration}
   */
  get fullEffort() {
    return new Duration({
      unit: this.effortUnit,
      magnitude: this.effort
    });
  }
  set fullEffort(effort) {
    this.setEffort(effort.magnitude, effort.unit);
  }
  // Cannot use `convert` method because it might be disabled by `useRawData : true` and we always need to calculate
  // that value
  get wrapStartDate() {
    const me = this, { preamble, startDate } = me, wrapStartDate = me._wrapStartDate;
    let result;
    if (wrapStartDate) {
      result = wrapStartDate;
    } else {
      if (preamble) {
        result = me.updateWrapDate(startDate, preamble, false);
        me._wrapStartDate = result;
      } else {
        result = startDate;
      }
    }
    return result;
  }
  set wrapStartDate(value) {
    this._wrapStartDate = value;
  }
  get wrapEndDate() {
    const me = this, { postamble, endDate } = me, wrapEndDate = me._wrapEndDate;
    let result;
    if (wrapEndDate) {
      result = wrapEndDate;
    } else {
      if (postamble) {
        result = me.updateWrapDate(endDate, postamble, true);
        me._wrapEndDate = result;
      } else {
        result = endDate;
      }
    }
    return result;
  }
  set wrapEndDate(value) {
    this._wrapEndDate = value;
  }
  set(data) {
    const isObject = typeof data === "object";
    if (data === "preamble" || isObject && "preamble" in data) {
      this.wrapStartDate = null;
    }
    if (data === "postamble" || isObject && "postamble" in data) {
      this.wrapEndDate = null;
    }
    return super.set(...arguments);
  }
  /**
   * Returns event start date adjusted by {@link #field-preamble} (start date - duration).
   * @property {Date}
   * @readonly
   */
  get outerStartDate() {
    return this.wrapStartDate;
  }
  /**
   * Returns event end date adjusted by {@link #field-postamble} (end date + duration).
   * @property {Date}
   * @readonly
   */
  get outerEndDate() {
    return this.wrapEndDate;
  }
  //endregion
  /**
   * Defines if the given event field should be manually editable in UI.
   * You can override this method to provide your own logic.
   *
   * By default, the method defines:
   * - {@link #field-earlyStartDate}, {@link #field-earlyEndDate} as not editable;
   * - {@link #field-endDate}, {@link #field-duration} and {@link #field-fullDuration} fields
   *   as not editable for summary events except the {@link #field-manuallyScheduled manually scheduled} ones;
   * - {@link #field-percentDone} as not editable for summary events.
   *
   * @param {String} fieldName Name of the field
   * @returns {Boolean} Returns `true` if the field is editable, `false` if it is not and `undefined` if the event has
   * no such field.
   */
  isEditable(fieldName) {
    switch (fieldName) {
      case "earlyStartDate":
      case "earlyEndDate":
        return false;
      case "percentDone":
      case "renderedPercentDone":
        return this.isLeaf;
      case "endDate":
      case "duration":
      case "fullDuration":
        return this.isLeaf || this.manuallyScheduled;
    }
    return super.isEditable(fieldName);
  }
  // Occurrences are not part of the project, when requesting their stm we retrieve it from the master event instead
  get stm() {
    var _a2, _b;
    return (_b = (_a2 = this.recurringEvent) == null ? void 0 : _a2.stm) != null ? _b : super.stm;
  }
  set stm(stm) {
    super.stm = stm;
  }
  //region Early render
  get assigned() {
    const { project } = this, assigned = super.assigned;
    if ((project == null ? void 0 : project.isDelayingCalculation) && !assigned) {
      return project.assignmentStore.storage.findItem("event", this);
    }
    return assigned;
  }
  set assigned(assigned) {
    super.assigned = assigned;
  }
  //endregion
  getCurrentConfig(options) {
    const { segments } = this, result = super.getCurrentConfig(options);
    if (result && segments) {
      result.segments = segments.map((segment) => segment.getCurrentConfig(options));
    }
    return result;
  }
};
__publicField(EventModel2, "isProEventModel", true);
EventModel2._$name = "EventModel";

// ../SchedulerPro/lib/SchedulerPro/data/EventStore.js
var EventStore2 = class extends PartOfProject_default2(RecurringEventsMixin_default(GetEventsMixin_default(DayIndexMixin_default(EventStoreMixin_default(ChronoEventStoreMixin.derive(AjaxStore)))))) {
  static get defaultConfig() {
    return {
      modelClass: EventModel2
    };
  }
  //endregion
};
__publicField(EventStore2, "$name", "EventStore");
EventStore2._$name = "EventStore";

// ../SchedulerPro/lib/SchedulerPro/model/ResourceModel.js
var ResourceModel2 = class extends PartOfProject_default2(ResourceModelMixin_default(SchedulerProResourceMixin.derive(GridRowModel))) {
  //region Calendar
  /**
   * Sets the calendar of the task. Will cause the schedule to be updated - returns a `Promise`
   *
   * @method setCalendar
   * @param {SchedulerPro.model.CalendarModel} calendar The new calendar. Provide `null` to use the project calendar.
   * @async
   * @propagating
   */
  /**
   * Returns the resource calendar.
   *
   * @method getCalendar
   * @returns {SchedulerPro.model.CalendarModel} The resource calendar.
   */
  /**
   * The calendar, assigned to the entity. Allows you to set the time when entity can perform the work.
   *
   * @field {SchedulerPro.model.CalendarModel} calendar
   * @accepts {SchedulerPro.model.CalendarModel|String}
   * @category Scheduling
   */
  //endregion
  //region Config
  static get $name() {
    return "ResourceModel";
  }
  //endregion
  /**
   * Get associated events
   *
   * @member {SchedulerPro.model.EventModel[]} events
   * @readonly
   * @category Common
   */
  /**
   * Returns all assignments for the resource
   *
   * @member {SchedulerPro.model.AssignmentModel[]} assignments
   * @category Common
   */
  //region Early render
  get assigned() {
    var _a2, _b;
    const { project } = this;
    if ((_a2 = project == null ? void 0 : project.assignmentStore.storage._indices) == null ? void 0 : _a2.resource) {
      return (_b = project.assignmentStore.storage.findItem("resource", this)) != null ? _b : /* @__PURE__ */ new Set();
    }
    return super.assigned;
  }
  set assigned(assigned) {
    super.assigned = assigned;
  }
  //endregion
};
ResourceModel2._$name = "ResourceModel";

// ../SchedulerPro/lib/SchedulerPro/data/ResourceStore.js
var ResourceStore2 = class extends PartOfProject_default2(ResourceStoreMixin_default(ChronoResourceStoreMixin.derive(AjaxStore))) {
  static get defaultConfig() {
    return {
      modelClass: ResourceModel2
    };
  }
};
ResourceStore2._$name = "ResourceStore";

// ../SchedulerPro/lib/SchedulerPro/data/mixin/ProjectCrudManager.js
var ProjectCrudManager_default2 = (Target) => class ProjectCrudManager extends (Target || Base2).mixin(ProjectCrudManager_default) {
  static get configurable() {
    return {
      crudLoadValidationWarningPrefix: "Project load response error(s):",
      crudSyncValidationWarningPrefix: "Project sync response error(s):",
      /**
       * If `true`, project {@link #property-changes} API will also report project model changes: start/end date,
       * calendar, effort, duration, etc.
       * @prp {Boolean}
       * @default
       */
      trackProjectModelChanges: false
    };
  }
  construct(...args) {
    const me = this;
    super.construct(...args);
    me.addPrioritizedStore(me.calendarManagerStore);
    me.addPrioritizedStore(me.assignmentStore);
    me.addPrioritizedStore(me.dependencyStore);
    me.addPrioritizedStore(me.resourceStore);
    me.addPrioritizedStore(me.eventStore);
    if (me.timeRangeStore) {
      me.addPrioritizedStore(me.timeRangeStore);
    }
    if (me.resourceTimeRangeStore) {
      me.addPrioritizedStore(me.resourceTimeRangeStore);
    }
  }
  get project() {
    return this;
  }
  set project(value) {
    super.project = value;
  }
  get crudLoadValidationMandatoryStores() {
    return [this.getStoreDescriptor(this.eventStore).storeId];
  }
  loadCrudManagerData(...args) {
    if (this.delayCalculation && !this.isDelayingCalculation && !this.usingSyncDataOnLoad()) {
      this.scheduleDelayedCalculation();
    }
    super.loadCrudManagerData(...args);
  }
  acceptChanges() {
    super.acceptChanges();
    this.clearChanges(true, false);
  }
  revertChanges() {
    this.revertCrudStoreChanges();
    this.set(this.meta.modified, void 0, true);
  }
  // Override to take into account project model own field changes
  crudStoreHasChanges(storeId) {
    const store = this.getCrudStore(storeId);
    let result;
    if (store) {
      result = super.crudStoreHasChanges(store);
    } else {
      result = this.hasPersistableChanges || super.crudStoreHasChanges();
    }
    return result;
  }
  /**
   * Returns current changes as an object consisting of added/modified/removed arrays of records for every
   * managed store, keyed by each store's `id`. Returns `null` if no changes exist. Format:
   *
   * ```javascript
   * {
   *     resources : {
   *         added    : [{ name : 'New guy' }],
   *         modified : [{ id : 2, name : 'Mike' }],
   *         removed  : [{ id : 3 }]
   *     },
   *     events : {
   *         modified : [{  id : 12, name : 'Cool task' }]
   *     },
   *     ...
   * }
   * ```
   *
   * To also include changes of the project model itself set {@link #property-trackProjectModelChanges} to `true`:
   *
   * ```javascript
   * {
   *     project : {
   *         calendar  : 'custom',
   *         startDate : '2020-02-02',
   *         endDate   : '2020-02-10
   *     },
   *     resources : {...},
   *     events    : {...}
   * }
   * ```
   *
   * @property {Object}
   * @readonly
   * @category CRUD
   */
  get changes() {
    let changes = super.changes;
    if (this.trackProjectModelChanges) {
      const projectChanges = this.modificationDataToWrite;
      if (projectChanges) {
        changes = changes || {};
        changes.project = projectChanges;
      }
    }
    return changes;
  }
  shouldClearRecordFieldChange(record, field2, value) {
    if (record.isCalendarModel && field2 === "intervals") {
      return !record.get("intervals").changes;
    }
    return super.shouldClearRecordFieldChange(...arguments);
  }
};

// ../SchedulerPro/lib/SchedulerPro/model/mixin/ProjectChangeHandlerMixin.js
var willChange = (fieldName, rawData, record) => {
  const field2 = record.getFieldDefinition(fieldName), { dataSource } = field2, newValue = record.constructor.processField(fieldName, rawData[dataSource], record);
  return dataSource in rawData && !field2.isEqual(newValue, record.getValue(fieldName));
};
var ProjectChangeHandlerMixin_default = (Target) => class ProjectChangeHandlerMixin extends (Target || Base2) {
  startConfigure(config) {
    this.getConfig("project");
    super.startConfigure(config);
  }
  beforeApplyProjectChanges() {
    const { stm } = this;
    let shouldResume = false, transactionId = null;
    this.suspendChangesTracking();
    if (stm.enabled) {
      shouldResume = true;
      if (stm.isRecording) {
        transactionId = stm.stash();
      }
      if (this.ignoreRemoteChangesInSTM) {
        stm.disable();
      } else {
        stm.startTransaction();
      }
    }
    return { shouldResume, transactionId };
  }
  /**
   * Allows to apply changes from one project to another. For method to produce correct results, projects should be
   * isomorphic - they should use same models and store configuration, also data in source and target projects
   * should be identical before changes to the source project are made and applied to the target project.
   * This method is meant to apply changes in real time - as source project is changed, changes should be applied to
   * the target project before it is changed.
   * When changes are applied all changes are committed and project is recalculated, which means target project
   * won't have any local changes after.
   *
   * Usage:
   * ```javascript
   * // Collect changes from first project
   * const { changes } = projectA;
   *
   * // Apply changes to second project
   * await projectB.applyProjectChanges(changes);
   * ```
   *
   * <div class="note">
   * This method will apply changes from the incoming object and accept all current project changes. Before
   * applying changes make sure you've processed current project changes in order not to lose them.
   * </div>
   *
   * @param {Object} changes Project {@link Scheduler/crud/AbstractCrudManagerMixin#property-changes} object
   * @returns {Promise}
   */
  async applyProjectChanges(changes) {
    var _a2, _b;
    const me = this, {
      shouldResume,
      transactionId
    } = me.beforeApplyProjectChanges();
    me.trigger("startApplyChangeset");
    me.applyingChangeset = true;
    if (changes.project) {
      me.applyProjectResponse(changes.project);
    }
    me.applyChangeset(ObjectHelper.clone(changes), (storeChanges, store) => {
      if (store.id === "tasks" || store.id === "events") {
        const { modelClass } = store, startDate = modelClass.getFieldDataSource("startDate"), endDate = modelClass.getFieldDataSource("endDate");
        if (storeChanges.updated) {
          for (const data of storeChanges.updated) {
            const record = store.getById(data[modelClass.idField]);
            if (!(willChange("constraintType", data, record) || willChange("constraintDate", data, record))) {
              delete data[startDate];
              delete data[endDate];
            }
          }
        }
      }
    });
    await me.commitAsync();
    me.commitRespondedChanges();
    for (const storeId in changes) {
      const storeDescriptor = me.getStoreDescriptor(storeId);
      if (storeDescriptor) {
        const { store } = storeDescriptor, storeChanges = changes[storeId], changedRows = [...(_a2 = storeChanges.updated) != null ? _a2 : [], ...(_b = storeChanges.added) != null ? _b : []];
        if (store) {
          for (const data of changedRows) {
            const record = store.getById(data[store.modelClass.idField]);
            if (record) {
              for (const fieldName in record.modifications) {
                if (!willChange(fieldName, data, record)) {
                  delete record.meta.modified[fieldName];
                }
              }
            }
          }
        }
      }
    }
    me.afterApplyProjectChanges(shouldResume, transactionId);
    me.applyingChangeset = false;
    await me.commitAsync();
    me.trigger("endApplyChangeset");
  }
  afterApplyProjectChanges(shouldResume, transactionId) {
    if (shouldResume) {
      const { stm } = this;
      if (this.ignoreRemoteChangesInSTM) {
        stm.enable();
      } else {
        stm.stopTransaction();
      }
      stm.applyStash(transactionId);
    }
    this.resumeChangesTracking();
  }
};

// ../SchedulerPro/lib/SchedulerPro/data/stm/action/EventUpdateAction.js
var EventUpdateAction = class extends UpdateAction {
  get type() {
    return "EventUpdateAction";
  }
  construct(config) {
    let {
      model,
      newData,
      oldData
    } = config;
    if (newData.segments && oldData.segments) {
      oldData = { ...oldData };
      newData = { ...newData };
      const oldDataSegments = oldData.segments.slice(), newDataSegments = newData.segments.slice();
      let hasChanges = false;
      oldData.segments.forEach((segment, index) => {
        const newDataIndex = newData.segments.indexOf(segment);
        if (newDataIndex > -1) {
          oldDataSegments[index] = newDataSegments[newDataIndex] = segment;
          hasChanges = true;
        }
      });
      if (hasChanges) {
        oldData.segments = oldDataSegments;
        newData.segments = newDataSegments;
      }
    }
    return super.construct({
      model,
      newData,
      oldData
    });
  }
};
EventUpdateAction._$name = "EventUpdateAction";

// ../SchedulerPro/lib/SchedulerPro/data/stm/StateTrackingManager.js
var makeModelUpdateAction2 = (model, newData, oldData) => {
  if (model.isSplitEventMixin) {
    return new EventUpdateAction({
      model,
      newData,
      oldData
    });
  }
  return new UpdateAction({
    model,
    newData,
    oldData
  });
};
var StateTrackingManager2 = class extends StateTrackingManager {
  static get defaultConfig() {
    return {
      makeModelUpdateAction: makeModelUpdateAction2
    };
  }
};
StateTrackingManager2._$name = "StateTrackingManager";

// ../SchedulerPro/lib/SchedulerPro/model/ProjectModel.js
var ProjectModel2 = class extends ProjectChangeHandlerMixin_default(ProjectCrudManager_default2(ProjectModelMixin_default(SchedulerProProjectMixin))) {
  //region Events
  /**
   * Fired when the engine has finished its calculations and the results has been written back to the records.
   *
   * ```javascript
   * scheduler.project.on({
   *     dataReady() {
   *        console.log('Calculations finished');
   *     }
   * });
   *
   * scheduler.eventStore.first.duration = 10;
   *
   * // At some point a bit later it will log 'Calculations finished'
   * ```
   *
   * @event dataReady
   * @param {SchedulerPro.model.ProjectModel} source The project
   * @param {Boolean} isInitialCommit Flag that shows if this commit is initial
   * @param {Set} records Set of all {@link Core.data.Model}s that were modified in the completed transaction.
   * Use the {@link Core.data.Model#property-modifications} property of each Model to identify
   * modified fields.
   */
  /**
   * Fired during the Engine calculation if {@link #config-enableProgressNotifications enableProgressNotifications} config is `true`
   * @event progress
   * @param {Number} total The total number of operations
   * @param {Number} remaining The number of remaining operations
   * @param {'storePopulation'|'propagating'} phase The phase of the calculation, either 'storePopulation'
   * when data is getting loaded, or 'propagating' when data is getting calculated
   */
  /**
   * Fired when the Engine detects a computation cycle.
   * @event cycle
   * @param {Object} schedulingIssue Scheduling error describing the case:
   * @param {Function} schedulingIssue.getDescription Returns the cycle description
   * @param {Object} schedulingIssue.cycle Object providing the cycle info
   * @param {Function} schedulingIssue.getResolutions Returns possible resolutions
   * @param {Function} continueWithResolutionResult Function to call after a resolution is chosen to
   * proceed with the Engine calculations:
   * ```js
   * project.on('cycle', ({ continueWithResolutionResult }) => {
   *     // cancel changes in case of a cycle
   *     continueWithResolutionResult(EffectResolutionResult.Cancel);
   * })
   * ```
   */
  /**
   * Fired when the Engine detects a scheduling conflict.
   * @event schedulingConflict
   * @param {Object} schedulingIssue The conflict details:
   * @param {Function} schedulingIssue.getDescription Returns the conflict description
   * @param {Object[]} schedulingIssue.intervals Array of conflicting intervals
   * @param {Function} schedulingIssue.getResolutions Function to get possible resolutions
   * @param {Function} continueWithResolutionResult Function to call after a resolution is chosen to
   * proceed with the Engine calculations:
   * ```js
   * project.on('schedulingConflict', ({ schedulingIssue, continueWithResolutionResult }) => {
   *     // apply the first resolution and continue
   *     schedulingIssue.getResolutions()[0].resolve();
   *     continueWithResolutionResult(EffectResolutionResult.Resume);
   * })
   * ```
   */
  /**
   * Fired when the Engine detects a calendar misconfiguration when the calendar does
   * not provide any working periods of time which makes the calendar usage impossible.
   * @event emptyCalendar
   * @param {Object} schedulingIssue Scheduling error describing the case:
   * @param {Function} schedulingIssue.getDescription Returns the error description
   * @param {Function} schedulingIssue.getCalendar Returns the calendar that must be fixed
   * @param {Function} schedulingIssue.getResolutions Returns possible resolutions
   * @param {Function} continueWithResolutionResult Function to call after a resolution is chosen to
   * proceed with the Engine calculations:
   * ```js
   * project.on('emptyCalendar', ({ schedulingIssue, continueWithResolutionResult }) => {
   *     // apply the first resolution and continue
   *     schedulingIssue.getResolutions()[0].resolve();
   *     continueWithResolutionResult(EffectResolutionResult.Resume);
   * })
   * ```
   */
  //endregion
  //region Config
  static get $name() {
    return "ProjectModel";
  }
  /**
   * Class implementing resource allocation report used by
   * {@link SchedulerPro.view.ResourceHistogram resource histogram} and
   * {@link SchedulerPro.view.ResourceUtilization resource utilization} views
   * for collecting resource allocation.
   * @config {ResourceAllocationInfo} resourceAllocationInfoClass
   */
  /**
   * Silences propagations caused by the project loading.
   *
   * Applying the loaded data to the project occurs in two basic stages:
   *
   * 1. Data gets into the engine graph which triggers changes propagation
   * 2. The changes caused by the propagation get written to related stores
   *
   * Setting this flag to `true` makes the component perform step 2 silently without triggering events causing reactions on those changes
   * (like sending changes back to the server if `autoSync` is enabled) and keeping stores in unmodified state.
   *
   * This is safe if the loaded data is consistent so propagation doesn't really do any adjustments.
   * By default the system treats the data as consistent so this option is `true`.
   *
   * ```js
   * new SchedulerPro{
   *     project : {
   *         // We want scheduling engine to recalculate the data properly
   *         // so then we could save it back to the server
   *         silenceInitialCommit : false,
   *         ...
   *     }
   *     ...
   * })
   * ```
   *
   * @config {Boolean} silenceInitialCommit
   * @default true
   * @category Advanced
   */
  /**
   * Maximum range the project calendars can iterate.
   * The value is defined in milliseconds and by default equals `5 years` roughly.
   * ```javascript
   * new SchedulerPro({
   *     project : {
   *         // adjust calendar iteration limit to 10 years roughly:
   *         // 10 years expressed in ms
   *         maxCalendarRange : 10 * 365 * 24 * 3600000,
   *         ...
   *     }
   * });
   * ```
   * @config {Number} maxCalendarRange
   * @default 157680000000
   * @category Advanced
   */
  /**
   * When `true` the project manually scheduled tasks will adjust their proposed start/end dates
   * to skip non working time.
   *
   * @field {Boolean} skipNonWorkingTimeWhenSchedulingManually
   * @default false
   */
  /**
   * When `true` the project's manually scheduled tasks adjust their duration by excluding the non-working time from it,
   * according to the calendar. However, this may lead to inconsistencies, when moving an event which both starts
   * and ends on the non-working time. For such cases you can disable this option.
   *
   * Default value is `true`
   *
   * IMPORTANT: Setting this option to `false` also forcefully sets the {@link #field-skipNonWorkingTimeWhenSchedulingManually} option
   * to `false`.
   * IMPORTANT: This option is going to be disabled by default from version 6.0.0.
   *
   * @field {Boolean} skipNonWorkingTimeInDurationWhenSchedulingManually
   * @default true
   */
  /**
   * This config manages DST correction in the scheduling engine. It only has effect when DST transition hour is
   * working time. Usually DST transition occurs on Sunday, so with non working weekends the DST correction logic
   * is not involved.
   *
   * If **true**, it will add/remove one hour when calculating end date. For example:
   * Assume weekends are working and on Sunday, 2020-10-25 at 03:00 clocks are set back 1 hour. Assume there is an event:
   *
   * ```javascript
   * {
   *     startDate    : '2020-10-20',
   *     duration     : 10 * 24 + 1,
   *     durationUnit : 'hour'
   * }
   * ```
   * It will end on 2020-10-30 01:00 (which is wrong) but duration will be reported correctly. Because of the DST
   * transition the SchedulerPro project will add one more hour when calculating the end date.
   *
   * Also this may occur when day with DST transition is working but there are non-working intervals between that day
   * and event end date.
   *
   * ```javascript
   * {
   *     calendar         : 1,
   *     calendarsData    : [
   *         {
   *             id           : 1,
   *             startDate    : '2020-10-26',
   *             endDate      : '2020-10-27',
   *             isWorking    : false
   *         }
   *     ],
   *     eventsData       : [
   *         {
   *             id           : 1,
   *             startDate    : '2020-10-20',
   *             endDate      : '2020-10-30'
   *         },
   *         {
   *             id           : 2,
   *             startDate    : '2020-10-20',
   *             duration     : 10 * 24 + 1,
   *             durationUnit : 'hour'
   *         }
   *     ]
   * }
   * ```
   *
   * Event 1 duration will be incorrectly reported as 9 days * 24 hours, missing 1 extra hour added by DST transition.
   * Event 2 end date will be calculated to 2020-10-30 01:00, adding one extra hour.
   *
   * If **false**, the SchedulerPro project will not add DST correction which fixes the quirk mentioned above.
   * Event 1 duration will be correctly reported as 9 days * 24 hours + 1 hour. Event 2 end date will be calculated
   * to 2020-10-30.
   *
   * Also, for those events days duration will be a floating point number due to extra (or missing) hour:
   *
   * ```javascript
   * eventStore.getById(1).getDuration('day')  // 10.041666666666666
   * eventStore.getById(1).getDuration('hour') // 241
   * ```
   *
   * @config {Boolean} adjustDurationToDST
   * @default false
   */
  /**
   * The number of hours per day.
   *
   * **Please note:** the value **does not define** the amount of **working** time per day
   * for that purpose one should use calendars.
   *
   * The value is used when converting the duration from one unit to another.
   * So when user enters a duration of, for example, `5 days` the system understands that it
   * actually means `120 hours` and schedules accordingly.
   * @field {Number} hoursPerDay
   * @default 24
   */
  /**
   * The number of days per week.
   *
   * **Please note:** the value **does not define** the amount of **working** time per week
   * for that purpose one should use calendars.
   *
   * The value is used when converting the duration from one unit to another.
   * So when user enters a duration of, for example, `2 weeks` the system understands that it
   * actually means `14 days` (which is then converted to {@link #field-hoursPerDay hours}) and
   * schedules accordingly.
   * @field {Number} daysPerWeek
   * @default 7
   */
  /**
   * The number of days per month.
   *
   * **Please note:** the value **does not define** the amount of **working** time per month
   * for that purpose one should use calendars.
   *
   * The value is used when converting the duration from one unit to another.
   * So when user enters a duration of, for example, `1 month` the system understands that it
   * actually means `30 days` (which is then converted to {@link #field-hoursPerDay hours}) and
   * schedules accordingly.
   * @field {Number} daysPerMonth
   * @default 30
   */
  /**
   * The source of the calendar for dependencies (the calendar used for taking dependencies lag into account).
   * Possible values are:
   *
   * - `ToEvent` - successor calendar will be used (default);
   * - `FromEvent` - predecessor calendar will be used;
   * - `Project` - the project calendar will be used.
   *
   * @field {'ToEvent'|'FromEvent'|'Project'} dependenciesCalendar
   * @default 'ToEvent'
   */
  /**
   * The project calendar.
   * @field {SchedulerPro.model.CalendarModel} calendar
   * @accepts {String|CalendarModelConfig|SchedulerPro.model.CalendarModel}
   */
  /**
   * Returns current Project changes as an object consisting of added/modified/removed arrays of records for every
   * managed store. Returns `null` if no changes exist. Format:
   *
   * ```javascript
   * {
   *     resources : {
   *         added    : [{ name : 'New guy' }],
   *         modified : [{ id : 2, name : 'Mike' }],
   *         removed  : [{ id : 3 }]
   *     },
   *     events : {
   *         modified : [{  id : 12, name : 'Cool task' }]
   *     },
   *     ...
   * }
   * ```
   *
   * @member {Object} changes
   * @readonly
   * @category Models & Stores
   */
  /**
   * Project changes (CRUD operations to records in its stores) are automatically committed on a buffer to the
   * underlying graph based calculation engine. The engine performs it calculations async.
   *
   * By calling this function, the commit happens right away. And by awaiting it you are sure that project
   * calculations are finished and that references between records are up to date.
   *
   * The returned promise is resolved with an object. If that object has `rejectedWith` set, there has been a conflict and the calculation failed.
   *
   * ```javascript
   * // Move an event in time
   * eventStore.first.shift(1);
   *
   * // Trigger calculations directly and wait for them to finish
   * const result = await project.commitAsync();
   *
   * if (result.rejectedWith) {
   *     // there was a conflict during the scheduling
   * }
   * ```
   *
   * @async
   * @function commitAsync
   * @category Common
   */
  /**
   * Set to `true` to enable calculation progress notifications.
   * When enabled the project fires {@link #event-progress progress} event.
   *
   * **Note**: Enabling progress notifications will impact calculation performance, since it needs to pause calculations to allow redrawing the UI.
   * @config {Boolean} enableProgressNotifications
   * @category Advanced
   */
  /**
   * Enables/disables the calculation progress notifications.
   * @member {Boolean} enableProgressNotifications
   * @category Advanced
   */
  /**
   * If this flag is set to `true` (default) when a start/end date is set on the event, a corresponding
   * `start-no-earlier/later-than` constraint is added, automatically. This is done in order to
   * keep the event "attached" to this date, according to the user intention.
   *
   * Depending on your use case, you might want to disable this behaviour.
   *
   * @field {Boolean} addConstraintOnDateSet
   * @default true
   */
  static get defaultConfig() {
    return {
      /**
       * @hideproperties project, taskStore
       */
      //region Inline data configs & properties
      /**
       * Get/set {@link #property-eventStore} data.
       *
       * Always returns an array of {@link SchedulerPro.model.EventModel EventModels} but also accepts an array of
       * its configuration objects as input.
       *
       * @member {SchedulerPro.model.EventModel[]} events
       * @accepts {SchedulerPro.model.EventModel[]|EventModelConfig[]}
       * @category Inline data
       */
      /**
       * Data use to fill the {@link #property-eventStore}. Should be an array of
       * {@link SchedulerPro.model.EventModel EventModels} or its configuration objects.
       *
       * @config {SchedulerPro.model.EventModel[]|EventModelConfig[]} events
       * @category Inline data
       */
      /**
       * Get/set {@link #property-resourceStore} data.
       *
       * Always returns an array of {@link SchedulerPro.model.ResourceModel ResourceModels} but also accepts an
       * array of its configuration objects as input.
       *
       * @member {SchedulerPro.model.ResourceModel[]} resources
       * @accepts {SchedulerPro.model.ResourceModel[]|ResourceModelConfig[]}
       * @category Inline data
       */
      /**
       * Data use to fill the {@link #property-resourceStore}. Should be an array of
       * {@link SchedulerPro.model.ResourceModel ResourceModels} or its configuration objects.
       *
       * @config {SchedulerPro.model.ResourceModel[]|ResourceModelConfig[]} resources
       * @category Inline data
       */
      /**
       * Get/set {@link #property-assignmentStore} data.
       *
       * Always returns an array of {@link SchedulerPro.model.AssignmentModel AssignmentModels} but also accepts
       * an array of its configuration objects as input.
       *
       * @member {SchedulerPro.model.AssignmentModel[]} assignments
       * @accepts {SchedulerPro.model.AssignmentModel[]|AssignmentModelConfig[]}
       * @category Inline data
       */
      /**
       * Data use to fill the {@link #property-assignmentStore}. Should be an array of
       * {@link SchedulerPro.model.AssignmentModel AssignmentModels} or its configuration objects.
       *
       * @config {SchedulerPro.model.AssignmentModel[]|AssignmentModelConfig[]} assignments
       * @category Inline data
       */
      /**
       * Get/set {@link #property-dependencyStore} data.
       *
       * Always returns an array of {@link SchedulerPro.model.DependencyModel DependencyModels} but also accepts an
       * array of its configuration objects as input.
       *
       * @member {SchedulerPro.model.DependencyModel[]} dependencies
       * @accepts {SchedulerPro.model.DependencyModel[]|DependencyModelConfig[]}
       * @category Inline data
       */
      /**
       * Data use to fill the {@link #property-dependencyStore}. Should be an array of
       * {@link SchedulerPro.model.DependencyModel DependencyModels} or its configuration objects.
       *
       * @config {SchedulerPro.model.DependencyModel[]|DependencyModelConfig[]} dependencies
       * @category Inline data
       */
      /**
       * Get/set {@link #property-timeRangeStore} data.
       *
       * Always returns an array of {@link Scheduler.model.TimeSpan TimeSpans} but also accepts an
       * array of its configuration objects as input.
       *
       * @member {Scheduler.model.TimeSpan[]} timeRanges
       * @accepts {Scheduler.model.TimeSpan[]|TimeSpanConfig[]}
       * @category Inline data
       */
      /**
       * Data use to fill the {@link #property-timeRangeStore}. Should be an array of
       * {@link Scheduler.model.TimeSpan TimeSpans} or its configuration objects.
       *
       * @config {Scheduler.model.TimeSpan[]|TimeSpanConfig[]} timeRanges
       * @category Inline data
       */
      /**
       * Get/set {@link #property-resourceTimeRangeStore} data.
       *
       * Always returns an array of {@link Scheduler.model.ResourceTimeRangeModel ResourceTimeRangeModels} but
       * also accepts an array of its configuration objects as input.
       *
       * @member {Scheduler.model.ResourceTimeRangeModel[]} resourceTimeRanges
       * @accepts {Scheduler.model.ResourceTimeRangeModel[]|ResourceTimeRangeModelConfig[]}
       * @category Inline data
       */
      /**
       * Data use to fill the {@link #property-resourceTimeRangeStore}. Should be an array
       * of {@link Scheduler.model.ResourceTimeRangeModel ResourceTimeRangeModels} or its configuration objects.
       *
       * @config {Scheduler.model.ResourceTimeRangeModel[]|ResourceTimeRangeModelConfig[]} resourceTimeRanges
       * @category Inline data
       */
      //endregion
      //region Legacy inline data configs & properties
      /**
       * The initial data, to fill the {@link #property-eventStore eventStore} with.
       * Should be an array of {@link SchedulerPro.model.EventModel EventModels} or its configuration objects.
       *
       * @config {SchedulerPro.model.EventModel[]} eventsData
       * @category Legacy inline data
       */
      /**
       * The initial data, to fill the {@link #property-dependencyStore dependencyStore} with.
       * Should be an array of {@link SchedulerPro.model.DependencyModel DependencyModels} or its configuration
       * objects.
       *
       * @config {SchedulerPro.model.DependencyModel[]} [dependenciesData]
       * @category Legacy inline data
       */
      /**
       * The initial data, to fill the {@link #property-resourceStore resourceStore} with.
       * Should be an array of {@link SchedulerPro.model.ResourceModel ResourceModels} or its configuration objects.
       *
       * @config {SchedulerPro.model.ResourceModel[]} [resourcesData]
       * @category Legacy inline data
       */
      /**
       * The initial data, to fill the {@link #property-assignmentStore assignmentStore} with.
       * Should be an array of {@link SchedulerPro.model.AssignmentModel AssignmentModels} or its configuration
       * objects.
       *
       * @config {SchedulerPro.model.AssignmentModel[]} [assignmentsData]
       * @category Legacy inline data
       */
      //endregion
      //region Store configs and properties
      /**
       * The {@link SchedulerPro.data.EventStore store} holding the event information.
       *
       * See also {@link SchedulerPro.model.EventModel}
       *
       * @member {SchedulerPro.data.EventStore} eventStore
       * @category Models & Stores
       */
      /**
       * An {@link SchedulerPro.data.EventStore} instance or a config object.
       * @config {SchedulerPro.data.EventStore|EventStoreConfig} eventStore
       * @category Models & Stores
       */
      /**
       * The {@link SchedulerPro.data.DependencyStore store} holding the dependency information.
       *
       * See also {@link SchedulerPro.model.DependencyModel}
       *
       * @member {SchedulerPro.data.DependencyStore} dependencyStore
       * @category Models & Stores
       */
      /**
       * A {@link SchedulerPro.data.DependencyStore} instance or a config object.
       * @config {SchedulerPro.data.DependencyStore|DependencyStoreConfig} dependencyStore
       * @category Models & Stores
       */
      /**
       * The {@link SchedulerPro.data.ResourceStore store} holding the resources that can be assigned to the
       * events in the event store.
       *
       * See also {@link SchedulerPro.model.ResourceModel}
       *
       * @member {SchedulerPro.data.ResourceStore} resourceStore
       * @category Models & Stores
       */
      /**
       * A {@link SchedulerPro.data.ResourceStore} instance or a config object.
       * @config {SchedulerPro.data.ResourceStore|ResourceStoreConfig} resourceStore
       * @category Models & Stores
       */
      /**
       * The {@link SchedulerPro.data.AssignmentStore store} holding the assignment information.
       *
       * See also {@link SchedulerPro.model.AssignmentModel}
       *
       * @member {SchedulerPro.data.AssignmentStore} assignmentStore
       * @category Models & Stores
       */
      /**
       * An {@link SchedulerPro.data.AssignmentStore} instance or a config object.
       * @config {SchedulerPro.data.AssignmentStore|AssignmentStoreConfig} assignmentStore
       * @category Models & Stores
       */
      /**
       * The {@link SchedulerPro.data.CalendarManagerStore store} holding the calendar information.
       *
       * See also {@link SchedulerPro.model.CalendarModel}
       * @member {SchedulerPro.data.CalendarManagerStore} calendarManagerStore
       * @category Models & Stores
       */
      /**
       * A {@link SchedulerPro.data.CalendarManagerStore} instance or a config object.
       * @config {SchedulerPro.data.CalendarManagerStore|CalendarManagerStoreConfig} calendarManagerStore
       * @category Models & Stores
       */
      //endregion
      //region Model & store class configs
      /**
       * The constructor of the calendar model class, to be used in the project. Will be set as the
       * {@link Core.data.Store#config-modelClass modelClass} property of the
       * {@link #property-calendarManagerStore}
       *
       * @config {SchedulerPro.model.CalendarModel} [calendarModelClass]
       * @typings {typeof CalendarModel}
       * @category Models & Stores
       */
      calendarModelClass: CalendarModel,
      /**
       * The constructor of the dependency model class, to be used in the project. Will be set as the
       * {@link Core.data.Store#config-modelClass modelClass} property of the {@link #property-dependencyStore}
       *
       * @config {SchedulerPro.model.DependencyModel}
       * @typings {typeof DependencyModel}
       * @category Models & Stores
       */
      dependencyModelClass: DependencyModel2,
      /**
       * The constructor of the event model class, to be used in the project. Will be set as the
       * {@link Core.data.Store#config-modelClass modelClass} property of the {@link #property-eventStore}
       *
       * @config {SchedulerPro.model.EventModel}
       * @typings {typeof EventModel}
       * @category Models & Stores
       */
      eventModelClass: EventModel2,
      /**
       * The constructor of the assignment model class, to be used in the project. Will be set as the
       * {@link Core.data.Store#config-modelClass modelClass} property of the {@link #property-assignmentStore}
       *
       * @config {SchedulerPro.model.AssignmentModel}
       * @typings {typeof AssignmentModel}
       * @category Models & Stores
       */
      assignmentModelClass: AssignmentModel2,
      /**
       * The constructor of the resource model class, to be used in the project. Will be set as the
       * {@link Core.data.Store#config-modelClass modelClass} property of the {@link #property-resourceStore}
       *
       * @config {SchedulerPro.model.ResourceModel}
       * @typings {typeof ResourceModel}
       * @category Models & Stores
       */
      resourceModelClass: ResourceModel2,
      /**
       * The constructor to create a calendar store instance with. Should be a class, subclassing the
       * {@link SchedulerPro.data.CalendarManagerStore}
       * @config {SchedulerPro.data.CalendarManagerStore|Object}
       * @typings {typeof CalendarManagerStore|object}
       * @category Models & Stores
       */
      calendarManagerStoreClass: CalendarManagerStore,
      /**
       * The constructor to create a dependency store instance with. Should be a class, subclassing the
       * {@link SchedulerPro.data.DependencyStore}
       * @config {SchedulerPro.data.DependencyStore|Object}
       * @typings {typeof DependencyStore|object}
       * @category Models & Stores
       */
      dependencyStoreClass: DependencyStore2,
      /**
       * The constructor to create an event store instance with. Should be a class, subclassing the
       * {@link SchedulerPro.data.EventStore}
       * @config {SchedulerPro.data.EventStore|Object}
       * @typings {typeof EventStore|object}
       * @category Models & Stores
       */
      eventStoreClass: EventStore2,
      /**
       * The constructor to create an assignment store instance with. Should be a class, subclassing the
       * {@link SchedulerPro.data.AssignmentStore}
       * @config {SchedulerPro.data.AssignmentStore|Object}
       * @typings {typeof AssignmentStore|object}
       * @category Models & Stores
       */
      assignmentStoreClass: AssignmentStore2,
      /**
       * The constructor to create a resource store instance with. Should be a class, subclassing the
       * {@link SchedulerPro.data.ResourceStore}
       * @config {SchedulerPro.data.ResourceStore|Object}
       * @typings {typeof ResourceStore|object}
       * @category Models & Stores
       */
      resourceStoreClass: ResourceStore2,
      //endregion
      /**
       * The initial data, to fill the {@link #property-calendarManagerStore} with.
       * Should be an array of {@link SchedulerPro.model.CalendarModel} or it's configuration objects.
       *
       * @config {SchedulerPro.model.CalendarModel[]}
       * @category Legacy inline data
       */
      calendarsData: null,
      /**
       * Set to `true` to reset the undo/redo queues of the internal {@link Core.data.stm.StateTrackingManager}
       * after the Project has loaded. Defaults to `false`
       * @config {Boolean} resetUndoRedoQueuesAfterLoad
       * @category Advanced
       */
      supportShortSyncResponseNote: 'Note: Please consider enabling "supportShortSyncResponse" option to allow less detailed sync responses (https://bryntum.com/products/schedulerpro/docs/api/SchedulerPro/model/ProjectModel#config-supportShortSyncResponse)',
      /**
       * Enables early rendering in SchedulerPro, by postponing calculations to after the first refresh.
       *
       * Requires event data loaded to be pre-normalized to function as intended, since it will be used to render
       * before engine has normalized the data. Given un-normalized data events will snap into place when
       * calculations are finished.
       *
       * The Gantt chart will be read-only until the initial calculations are finished.
       *
       * @config {Boolean}
       * @default
       * @category Advanced
       */
      delayCalculation: true,
      calendarManagerStore: {},
      stmClass: StateTrackingManager2
    };
  }
  static get configurable() {
    return {
      /**
       * Get/set {@link #property-calendarManagerStore} data.
       *
       * Always returns a {@link SchedulerPro.model.CalendarModel} array but also accepts an array of
       * its configuration objects as input.
       *
       * @member {SchedulerPro.model.CalendarModel[]} calendars
       * @accepts {SchedulerPro.model.CalendarModel[]|CalendarModelConfig[]}
       * @category Inline data
       */
      /**
       * Data use to fill the {@link #property-eventStore}. Should be a {@link SchedulerPro.model.CalendarModel}
       * array or its configuration objects.
       *
       * @config {SchedulerPro.model.CalendarModel[]|CalendarModelConfig[]} calendars
       * @category Inline data
       */
      calendars: null
    };
  }
  // For TaskBoard compatibility
  get taskStore() {
    return this.eventStore;
  }
  //endregion
  //region Inline data
  get calendars() {
    return this.calendarManagerStore.allRecords;
  }
  updateCalendars(calendars) {
    this.calendarManagerStore.data = calendars;
  }
  //endregion
};
ProjectModel2._$name = "ProjectModel";

// lib/Gantt/model/AssignmentModel.js
var AssignmentModel3 = class extends AssignmentModel2 {
  //region Fields
  static get fields() {
    return [
      /**
       * Id for event to assign. Note that after load it will be populated with the actual event.
       * @field {Gantt.model.TaskModel} event
       * @accepts {String|Number|Gantt.model.TaskModel}
       */
      {
        name: "event",
        persist: true,
        serialize: (record) => record == null ? void 0 : record.id,
        isEqual: isSerializableEqual
      },
      /**
       * Id for resource to assign to. Note that after load it will be populated with the actual resource.
       * @field {Gantt.model.ResourceModel} resource
       * @accepts {String|Number|Gantt.model.ResourceModel}
       */
      {
        name: "resource",
        persist: true,
        serialize: (record) => record == null ? void 0 : record.id,
        isEqual: isSerializableEqual
      },
      /**
       * Hidden
       * @field {String|Number} eventId
       * @hide
       */
      "eventId",
      /**
       * Hidden
       * @field {String|Number} resourceId
       * @hide
       */
      "resourceId"
    ];
  }
  //endregion
};
AssignmentModel3._$name = "AssignmentModel";

// lib/Gantt/data/AssignmentStore.js
var AssignmentStore3 = class extends AssignmentStore2 {
  static get defaultConfig() {
    return {
      modelClass: AssignmentModel3,
      /**
       * CrudManager must load stores in the correct order. Lowest first.
       * @private
       */
      loadPriority: 500,
      /**
       * CrudManager must sync stores in the correct order. Lowest first.
       * @private
       */
      syncPriority: 400
    };
  }
};
AssignmentStore3._$name = "AssignmentStore";

// lib/Gantt/model/CalendarModel.js
var CalendarModel2 = class extends CalendarModel {
};
CalendarModel2._$name = "CalendarModel";

// lib/Gantt/data/CalendarManagerStore.js
var CalendarManagerStore2 = class extends CalendarManagerStore {
  static get defaultConfig() {
    return {
      modelClass: CalendarModel2
    };
  }
};
CalendarManagerStore2._$name = "CalendarManagerStore";

// lib/Gantt/model/DependencyModel.js
var DependencyModel3 = class extends DependencyModel2 {
  constructor(...args) {
    const [config] = args;
    if (config == null ? void 0 : config.fromTask) {
      config.fromEvent = config.fromTask;
    }
    if (config == null ? void 0 : config.toTask) {
      config.toEvent = config.toTask;
    }
    super(...args);
  }
  get from() {
    var _a2;
    return (_a2 = this.fromEvent) == null ? void 0 : _a2.id;
  }
  set from(value) {
    super.from = value;
  }
  /**
   * The origin task of this dependency.
   *
   * Accepts multiple formats but always returns an {@link Gantt.model.TaskModel}.
   *
   * **NOTE:** This is not a proper field but rather an alias, it will be serialized but cannot be remapped. If you
   * need to remap, consider using {@link #field-from} instead.
   *
   * @field {Gantt.model.TaskModel} fromTask
   * @accepts {String|Number|Gantt.model.TaskModel}
   * @category Dependency
   */
  /**
   * The destination task of this dependency.
   *
   * Accepts multiple formats but always returns an {@link Gantt.model.TaskModel}.
   *
   * **NOTE:** This is not a proper field but rather an alias, it will be serialized but cannot be remapped. If you
   * need to remap, consider using {@link #field-to} instead.
   *
   * @field {Gantt.model.TaskModel} toTask
   * @accepts {String|Number|Gantt.model.TaskModel}
   * @category Dependency
   */
  get fromTask() {
    return this.fromEvent;
  }
  set fromTask(task) {
    this.fromEvent = task;
  }
  get to() {
    var _a2;
    return (_a2 = this.toEvent) == null ? void 0 : _a2.id;
  }
  set to(value) {
    super.to = value;
  }
  get toTask() {
    return this.toEvent;
  }
  set toTask(task) {
    this.toEvent = task;
  }
  get persistableData() {
    const data = super.persistableData, { fromTask, toTask } = data;
    if (fromTask) {
      data.fromTask = fromTask.id;
    }
    if (toTask) {
      data.toTask = toTask.id;
    }
    return data;
  }
  shouldRecordFieldChange(fieldName, oldValue, newValue) {
    if (fieldName === "from" || fieldName === "to") {
      return false;
    } else {
      return super.shouldRecordFieldChange(fieldName, oldValue, newValue);
    }
  }
};
DependencyModel3._$name = "DependencyModel";

// lib/Gantt/data/DependencyStore.js
var DependencyStore3 = class extends DependencyStore2 {
  static get defaultConfig() {
    return {
      modelClass: DependencyModel3,
      /**
       * CrudManager must load stores in the correct order. Lowest first.
       * @private
       */
      loadPriority: 300,
      /**
       * CrudManager must sync stores in the correct order. Lowest first.
       * @private
       */
      syncPriority: 500
    };
  }
};
DependencyStore3._$name = "DependencyStore";

// lib/Gantt/model/ResourceModel.js
var ResourceModel3 = class extends ResourceModel2 {
  /**
   * Get associated tasks
   *
   * @member {SchedulerPro.model.EventModel[]} events
   * @readonly
   */
};
ResourceModel3._$name = "ResourceModel";

// lib/Gantt/data/ResourceStore.js
var ResourceStore3 = class extends ResourceStore2 {
  static get defaultConfig() {
    return {
      modelClass: ResourceModel3,
      /**
       * CrudManager must load stores in the correct order. Lowest first.
       * @private
       */
      loadPriority: 400,
      /**
       * CrudManager must sync stores in the correct order. Lowest first.
       * @private
       */
      syncPriority: 200
    };
  }
};
ResourceStore3._$name = "ResourceStore";

// lib/Gantt/model/Baseline.js
var Baseline = class extends TimeSpan {
  constructor() {
    super(...arguments);
    //endregion
    __publicField(this, "isBaseline", true);
  }
  //region Milestone
  get milestone() {
    if (!this.isLeaf) {
      const { startDate, endDate } = this;
      if (startDate && endDate) {
        return endDate.getTime() === startDate.getTime();
      }
    }
    return this.duration === 0;
  }
  set milestone(value) {
    value ? this.convertToMilestone() : this.convertToRegular();
  }
  async setMilestone(value) {
    return value ? this.convertToMilestone() : this.convertToRegular();
  }
  /**
   * Converts this baseline to a milestone (start date will match the end date).
   *
   * @propagating
   */
  async convertToMilestone() {
    return this.setDuration(0, this.durationUnit, false);
  }
  /**
   * Converts a milestone baseline to a regular baseline with a duration of 1 (keeping current `durationUnit`).
   *
   * @propagating
   */
  async convertToRegular() {
    if (this.milestone) {
      return this.setDuration(1, this.durationUnit, false);
    }
  }
  //endregion
  // Uses engine to calculate dates and/or duration.
  normalize() {
    const me = this, { task, startDate, endDate, duration } = me, hasDuration = duration != null;
    if (!task.graph) {
      super.normalize();
    } else {
      if (startDate && endDate && !hasDuration) {
        me.setData("duration", task.run("calculateProjectedDuration", startDate, endDate));
      } else if (startDate && !endDate && hasDuration) {
        me.setData("endDate", task.run("calculateProjectedXDateWithDuration", startDate, true, duration));
      } else if (!startDate && endDate && hasDuration) {
        me.setData("startDate", task.run("calculateProjectedXDateWithDuration", endDate, false, duration));
      }
    }
  }
  //region Baseline APIs
  /**
   * Baseline start variance in the task's duration unit.
   * @member {Core.data.Duration}
   * @category Scheduling
   */
  get startVariance() {
    const { task } = this, variance = DateHelper.getDurationInUnit(this.startDate, task.startDate, task.durationUnit);
    return new Duration({ magnitude: variance, unit: task.durationUnit });
  }
  /**
   * Baseline end variance in the task's duration unit.
   * @member {Core.data.Duration}
   * @category Scheduling
   */
  get endVariance() {
    const { task } = this, variance = DateHelper.getDurationInUnit(this.endDate, task.endDate, task.durationUnit);
    return new Duration({ magnitude: variance, unit: task.durationUnit });
  }
  /**
   * Baseline duration variance in the task's duration unit.
   * @member {Core.data.Duration}
   * @category Scheduling
   */
  get durationVariance() {
    return this.fullDuration && this.task.fullDuration.diff(this.fullDuration);
  }
  //endregion
};
//region Fields
__publicField(Baseline, "fields", [
  /**
   * The owning Task of the Baseline
   * @field {Gantt.model.TaskModel} task
   */
  {
    name: "task",
    persist: false
  }
  /**
   * Start date of the baseline in ISO 8601 format.
   *
   * Note that the field always returns a `Date`.
   *
   * @field {Date} startDate
   * @accepts {String|Date}
   */
  /**
   * End date of the baseline in ISO 8601 format.
   *
   * Note that the field always returns a `Date`.
   *
   * @field {Date} endDate
   * @accepts {String|Date}
   */
  /**
   * An encapsulation of the CSS classes to be added to the rendered baseline element.
   *
   * Always returns a {@link Core.helper.util.DomClassList}, but may still be treated as a string. For
   * granular control of adding and removing individual classes, it is recommended to use the
   * {@link Core.helper.util.DomClassList} API.
   *
   * @field {Core.helper.util.DomClassList} cls
   * @accepts {Core.helper.util.DomClassList|String}
   */
]);
Baseline._$name = "Baseline";

// lib/Gantt/data/field/WbsField.js
var WbsField = class extends DataField {
  static get type() {
    return "wbs";
  }
  convert(value) {
    return Wbs.from(value);
  }
  serialize(value) {
    return String(value);
  }
};
WbsField.prototype.compare = Wbs.compare;
WbsField.initClass();
WbsField._$name = "WbsField";

// lib/Gantt/model/TaskModel.js
var applyBaselineDefaults = (task, baselines) => {
  const {
    startDate,
    durationUnit,
    endDate
  } = task;
  return baselines ? baselines.map((baseline) => {
    const hasData = +("startDate" in baseline) + ("endDate" in baseline) + ("duration" in baseline) > 1, data = { task, ...baseline };
    if (!hasData) {
      Object.assign(data, { startDate, endDate, durationUnit });
    }
    return data;
  }) : [];
};
var descendingWbsSorter = (s) => s.field === "wbsValue" && !s.ascending;
var isReversed = (children) => {
  for (let firstChildWbs, childWbs, i = 0, n = children.length; i < n; ++i) {
    childWbs = children[i].wbsValue;
    if (childWbs) {
      if (firstChildWbs) {
        return childWbs < firstChildWbs;
      }
      firstChildWbs = childWbs;
    }
  }
  return false;
};
var refreshWbsOptions = { deep: true };
var refreshWbsOnJoinOptions = { deep: true, silent: true };
var TaskModel = class extends GanttEvent.derive(TimeSpan).mixin(
  PartOfProject_default2,
  PercentDoneMixin_default
) {
  constructor() {
    super(...arguments);
    //endregion
    //region Config
    // Flag for storing the initial manuallyScheduled value during tree transform. To avoid deoptimizing
    __publicField(this, "$manuallyScheduled", null);
  }
  //region Fields
  /**
   * This static configuration option allows you to control whether an empty parent task should be converted into a
   * leaf. Enable/disable it for a whole class:
   *
   * ```javascript
   * TaskModel.convertEmptyParentToLeaf = false;
   * ```
   *
   * By specifying `true`, all empty parents will be considered leafs. Can also be assigned a configuration object
   * with the following Boolean properties to customize the behaviour:
   *
   * * `onLoad` - Apply the transformation on load to any parents without children (`children : []`)
   * * `onRemove` - Apply the transformation when all children have been removed from a parent
   *
   * ```javascript
   * TaskModel.convertEmptyParentToLeaf = {
   *     onLoad   : false,
   *     onRemove : true
   * }
   * ```
   *
   * @member {Boolean|ConvertEmptyParentToLeafOptions} convertEmptyParentToLeaf
   * @default true
   * @static
   * @category Parent & children
   */
  static get fields() {
    return [
      /**
       * The scheduling direction of this event. The `Forward` direction corresponds to the as-soon-as-possible scheduling (ASAP),
       * `Backward` - to as-late-as-possible (ALAP). The ASAP tasks "sticks" to the project's start date,
       * and ALAP tasks - to the project's end date.
       *
       * If not specified (which is the default), direction is inherited from the parent task (and from the project for top-level tasks).
       * By default, the project model has forward scheduling mode.
       *
       * **Note** The ALAP-scheduled task in the ASAP-scheduled project will turn all of its successors into ALAP-scheduled tasks,
       * even if their scheduling direction is specified explicitly by the user as ASAP. We can say that ALAP-scheduling
       * is propagated down through the successors chain. This propagation, however, will stop in the following cases:
       * - If a successor is manually scheduled
       * - If a successor has a "Must start/finish on" constraint
       * - If a dependency to successor is inactive
       *
       * Similarly, the ASAP-scheduled task in the ALAP-scheduled project will turn all of its predecessors into ASAP-scheduled tasks
       * (also regardless of the user-provided value).
       *
       * When such propagation is in action, the value of this field is ignored and the UI will disable controls for it.
       *
       * To determine the actual scheduling direction of the task (which might be different from the user-provided value),
       * one can use the {@link Gantt/model/TaskModel#field-effectiveDirection} field.
       *
       * **Note** For the purposes of compatibility with MS Project and to ease the migration process for users,
       * by default, scheduling direction can be set using the "Constraint type" field on the "Advanced"
       * tab of the task editor. The forward scheduling is specified in it as "As soon as possible" option and backward -
       * "As late as possible". One can also disable the {@link Gantt/model/ProjectModel#config-includeAsapAlapAsConstraints}
       * config to render a separate "Scheduling direction" field.
       *
       * @field {'Forward'|'Backward'} direction
       * @default null
       * @category Common
       */
      /**
       * @typedef {Object} EffectiveDirection
       * @property {'own'|'enforced'|'inherited'} kind The type of the direction value.
       * @property {'Forward'|'Backward'} direction The actual direction. Depending on the `kind` value, it might be
       * a user-provided value (`own`), or value, enforced by the predecessor/successor (`enforced`), or value inherited
       * from the parent task (or project).
       * @property {Gantt.model.TaskModel} enforcedBy The task which forces the current direction
       * @property {Gantt.model.TaskModel} inheritedFrom The task from which the current direction is inherited
       */
      /**
       * The calculated effective scheduling direction of this event. See the {@link Gantt/model/TaskModel#field-direction} field for details.
       *
       * @field {EffectiveDirection} effectiveDirection
       * @category Common
       */
      /**
       * Unique identifier of task (mandatory)
       * @field {String|Number} id
       * @category Common
       */
      /**
       * Name of the task
       * @field {String} name
       * @category Common
       */
      /**
       * A set of resources assigned to this task
       * @field {Set} assigned
       * @readonly
       * @category Common
       */
      /**
       * This field is automatically set to `true` when the task is "unscheduled" - user has provided an empty
       * string in one of the UI editors for start date, end date or duration. Such task is not rendered,
       * and does not affect the schedule of its successors.
       *
       * To schedule the task back, enter one of the missing values, so that there's enough information
       * to calculate start date, end date and duration.
       *
       * Note, that setting this field manually does nothing. This field should be persisted, but not updated
       * manually.
       *
       * @field {Boolean} unscheduled
       * @readonly
       * @category Scheduling
       */
      /**
       * Start date of the task in ISO 8601 format
       *
       * UI fields representing this data field are disabled for summary events
       * except the {@link #field-manuallyScheduled manually scheduled} events.
       * See {@link #function-isEditable} for details.
       *
       * Note that the field always returns a `Date`.
       *
       * @field {Date} startDate
       * @accepts {String|Date}
       * @category Scheduling
       */
      /**
       * End date of the task in ISO 8601 format
       *
       * UI fields representing this data field are disabled for summary events
       * except the {@link #field-manuallyScheduled manually scheduled} events.
       * See {@link #function-isEditable} for details.
       *
       * Note that the field always returns a `Date`.
       *
       * @field {Date} endDate
       * @accepts {String|Date}
       * @category Scheduling
       */
      /**
       * The numeric part of the task duration (the number of units).
       *
       * UI fields representing this data field are disabled for summary events
       * except the {@link #field-manuallyScheduled manually scheduled} events.
       * See {@link #function-isEditable} for details.
       *
       * @field {Number} duration
       * @category Scheduling
       */
      /**
       * Segments of the task that appear when the task gets {@link #function-splitToSegments}.
       * @field {SchedulerPro.model.EventSegmentModel[]} segments
       * @category Scheduling
       */
      /**
       * An encapsulation of the CSS classes to be added to the rendered event element.
       *
       * Always returns a {@link Core.helper.util.DomClassList}, but may still be treated as a string. For
       * granular control of adding and removing individual classes, it is recommended to use the
       * {@link Core.helper.util.DomClassList} API.
       *
       * @field {Core.helper.util.DomClassList} cls
       * @accepts {Core.helper.util.DomClassList|String} cls
       * @category Styling
       */
      {
        name: "cls",
        serialize: (value) => {
          return value.isDomClassList ? value.toString() : value;
        },
        persist: true
      },
      /**
       * The current status of a task, expressed as the percentage completed (integer from 0 to 100)
       *
       * UI fields representing this data field are disabled for summary events.
       * See {@link #function-isEditable} for details.
       *
       * @field {Number} percentDone
       * @category Scheduling
       */
      /**
       * The numeric part of the task effort (the number of units). The effort of the "parent" tasks will be automatically set to the sum
       * of efforts of their "child" tasks
       *
       * UI fields representing this data field are disabled for summary events.
       * See {@link #function-isEditable} for details.
       *
       * @field {Number} effort
       * @category Scheduling
       */
      /**
       * The unit part of the task duration, defaults to "day" (days). Valid values are:
       *
       * - "millisecond" - Milliseconds
       * - "second" - Seconds
       * - "minute" - Minutes
       * - "hour" - Hours
       * - "day" - Days
       * - "week" - Weeks
       * - "month" - Months
       * - "quarter" - Quarters
       * - "year"- Years
       *
       * This field is readonly after creation, to change it use the {@link #function-setDuration} call.
       * @field {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} durationUnit
       * @default "day"
       * @category Scheduling
       */
      /**
       * The unit part of the task's effort, defaults to "h" (hours). Valid values are:
       *
       * - "millisecond" - Milliseconds
       * - "second" - Seconds
       * - "minute" - Minutes
       * - "hour" - Hours
       * - "day" - Days
       * - "week" - Weeks
       * - "month" - Months
       * - "quarter" - Quarters
       * - "year"- Years
       *
       * This field is readonly after creation, to change it use the {@link #function-setEffort} call.
       * @field {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} effortUnit
       * @default "hour"
       * @category Scheduling
       */
      { name: "fullEffort", persist: false },
      /**
       * The effective calendar used by the task.
       * Returns the task own {@link #field-calendar} if provided or the project {@link Gantt.model.ProjectModel#field-calendar calendar}.
       *
       * @field {Gantt.model.CalendarModel} effectiveCalendar
       * @category Scheduling
       * @calculated
       * @readonly
       */
      /**
       * The calendar, assigned to the task. Allows you to set the time when task can be performed.
       *
       * @field {Gantt.model.CalendarModel} calendar
       * @category Scheduling
       */
      /**
       * The getter will yield a {@link Core.data.Store} of {@link Gantt.model.Baseline}s.
       *
       * When constructing a task the baselines will be constructed from an array of
       * {@link Gantt.model.Baseline} data objects.
       *
       * When serializing, it will yield an array of {@link Gantt.model.Baseline} data objects.
       *
       * @field {Core.data.Store} baselines
       * @accepts {BaselineConfig[]}
       * @category Features
       */
      { name: "baselines", type: "store", modelClass: Baseline, storeClass: Store, lazy: true },
      /**
       * A freetext note about the task.
       * @field {String} note
       * @category Common
       */
      { name: "note", type: "string" },
      "parentId",
      /**
       * Field storing the task constraint alias or `null` if not constraint set.
       * Valid values are:
       * - "finishnoearlierthan"
       * - "finishnolaterthan"
       * - "mustfinishon"
       * - "muststarton"
       * - "startnoearlierthan"
       * - "startnolaterthan"
       *
       * @field {'finishnoearlierthan'|'finishnolaterthan'|'mustfinishon'|'muststarton'|'startnoearlierthan'|'startnolaterthan'|null} constraintType
       * @category Scheduling
       */
      /**
       * Field defining the constraint boundary date or `null` if {@link #field-constraintType} is `null`.
       * @field {String|Date|null} constraintDate
       * @category Scheduling
       */
      /**
       * When set to `true`, the {@link #field-startDate} of the task will not be changed by any of its incoming
       * dependencies or constraints.
       *
       * @field {Boolean} manuallyScheduled
       * @category Scheduling
       */
      /**
       * When set to `true` the task becomes inactive and stops taking part in the project scheduling (doesn't
       * affect linked tasks, rolls up its attributes and affect its assigned resources allocation).
       *
       * @field {Boolean} inactive
       * @category Scheduling
       */
      /**
       * When set to `true` the calendars of the assigned resources
       * are not taken into account when scheduling the task.
       *
       * By default the field value is `false` resulting in that the task performs only when
       * its own {@link #field-calendar} and some of the assigned
       * resource calendars allow that.
       * @field {Boolean} ignoreResourceCalendar
       * @category Scheduling
       */
      /**
       * This field defines the scheduling mode for the task. Based on this field some fields of the task
       * will be "fixed" (should be provided by the user) and some - computed.
       *
       * Possible values are:
       *
       * - `Normal` is the default (and backward compatible) mode. It means the task will be scheduled based on
       * information about its start/end dates, task own calendar (project calendar if there's no one) and
       * calendars of the assigned resources.
       *
       * - `FixedDuration` mode means, that task has fixed start and end dates, but its effort will be computed
       * dynamically, based on the assigned resources information. Typical example of such task is - meeting.
       * Meetings typically have pre-defined start and end dates and the more people are participating in the
       * meeting, the more effort is spent on the task. When duration of such task increases, its effort is
       * increased too (and vice-versa). Note: fixed start and end dates here doesn't mean that a user can't
       * update them via GUI, the only field which won't be editable in GUI is the
       * {@link #field-effort effort field}, it will be calculated according to duration and resources assigned to
       * the task.
       *
       * - `FixedEffort` mode means, that task has fixed effort and computed duration. The more resources will be
       * assigned to this task, the less the duration will be. The typical example will be a "paint the walls"
       * task - several painters will complete it faster.
       *
       * - `FixedUnits` mode means, that the assignment level of all assigned resources will be kept as provided
       * by the user, and either {@link #field-effort} or duration of the task is recalculated, based on the
       * {@link #field-effortDriven} flag.
       *
       * @field {'Normal'|'FixedDuration'|'FixedEffort'|'FixedUnits'} schedulingMode
       * @category Scheduling
       */
      /**
       * This boolean flag defines what part of task data should be updated in the `FixedUnits` scheduling mode.
       * If it is `true`, then {@link #field-effort} is kept intact, and duration is updated. If it is `false` -
       * vice-versa.
       *
       * @field {Boolean} effortDriven
       * @default false
       * @category Scheduling
       */
      /**
       * A calculated field storing the _early start date_ of the task.
       * The _early start date_ is the earliest possible date the task can start.
       * This value is calculated based on the earliest dates of the task predecessors and the task own
       * constraints. If the task has no predecessors nor other constraints, its early start date matches the
       * project start date.
       *
       * UI fields representing this data field are naturally disabled since the field is readonly.
       * See {@link #function-isEditable} for details.
       *
       * @field {Date} earlyStartDate
       * @calculated
       * @readonly
       * @category Scheduling
       */
      /**
       * A calculated field storing the _early end date_ of the task.
       * The _early end date_ is the earliest possible date the task can finish.
       * This value is calculated based on the earliest dates of the task predecessors and the task own
       * constraints. If the task has no predecessors nor other constraints, its early end date matches the
       * project start date plus the task duration.
       *
       * UI fields representing this data field are naturally disabled since the field is readonly.
       * See {@link #function-isEditable} for details.
       *
       * @field {Date} earlyEndDate
       * @calculated
       * @readonly
       * @category Scheduling
       */
      /**
       * A calculated field storing the _late start date_ of the task.
       * The _late start date_ is the latest possible date the task can start.
       * This value is calculated based on the latest dates of the task successors and the task own constraints.
       * If the task has no successors nor other constraints, its late start date matches the project end date
       * minus the task duration.
       *
       * UI fields representing this data field are naturally disabled since the field is readonly.
       * See {@link #function-isEditable} for details.
       *
       * @field {Date} lateStartDate
       * @calculated
       * @readonly
       * @category Scheduling
       */
      /**
       * A calculated field storing the _late end date_ of the task.
       * The _late end date_ is the latest possible date the task can finish.
       * This value is calculated based on the latest dates of the task successors and the task own constraints.
       * If the task has no successors nor other constraints, its late end date matches the project end date.
       *
       * UI fields representing this data field are naturally disabled since the field is readonly.
       * See {@link #function-isEditable} for details.
       *
       * @field {Date} lateEndDate
       * @calculated
       * @readonly
       * @category Scheduling
       */
      /**
       * A calculated field storing the _total slack_ (or _total float_) of the task.
       * The _total slack_ is the amount of working time the task can be delayed without causing a delay
       * to the project end.
       * The value is expressed in {@link #field-slackUnit} units.
       *
       * ```javascript
       * // let output slack info to the console
       * console.log(`The ${task.name} task can be delayed for ${task.totalSlack} ${slackUnit}s`)
       * ```
       *
       * UI fields representing this data field are naturally disabled since the field is readonly.
       * See {@link #function-isEditable} for details.
       *
       *
       * @field {Number} totalSlack
       * @calculated
       * @readonly
       * @category Scheduling
       */
      /**
       * A calculated field storing unit for the {@link #field-totalSlack} value.
       * @field {String} slackUnit
       * @default "day"
       * @category Scheduling
       */
      /**
       * A calculated field indicating if the task is _critical_.
       * A task considered _critical_ if its delaying causes the project delay.
       * The field value is calculated based on {@link #field-totalSlack} field value.
       *
       * ```javascript
       * if (task.critical) {
       *     Toast.show(`The ${task.name} is critical!`);
       * }
       * ```
       *
       * @field {Boolean} critical
       * @calculated
       * @readonly
       * @category Scheduling
       */
      // NOTE: These are not actually fields, they are never set during task lifespan and only used by crud manager
      // to send changes to the backend
      // Two fields which specify the relations between "phantom" tasks when they are
      // being sent to the server to be created (e.g. when you create a new task containing a new child task).
      // { name : 'phantomId', type : 'string' },
      // { name : 'phantomParentId', type : 'string' },
      /**
       * Child nodes. To allow loading children on demand, specify `children : true` in your data. Omit the field
       * for leaf tasks.
       *
       * Note, if the task store loads data from a remote origin, make sure {@link Core/data/AjaxStore#config-readUrl}
       * is specified, and optionally {@link Core/data/AjaxStore#config-parentIdParamName} is set, otherwise
       * {@link Core/data/Store#function-loadChildren} has to be implemented.
       *
       * @field {Gantt.model.TaskModel[]} children
       * @accepts {Boolean|Object[]|Gantt.model.TaskModel[]}
       * @category Parent & children
       */
      { name: "children", persist: false },
      /**
       * Set this to true if this task should be shown in the Timeline widget
       * @field {Boolean} showInTimeline
       * @category Features
       */
      { name: "showInTimeline", type: "boolean" },
      /**
       * Set this to true to roll up a task to its closest parent
       * @field {Boolean} rollup
       * @category Features
       */
      { name: "rollup", type: "boolean" },
      /**
       * The {@link Gantt.data.Wbs WBS} for this task record. This field is automatically calculated and
       * maintained by the store. This calculation can be refreshed by calling {@link #function-refreshWbs}.
       *
       * To get string representation of the WBS value (e.g. '2.1.3'), use {@link Gantt.data.Wbs#property-value}
       * property.
       *
       * @readonly
       * @field {Gantt.data.Wbs} wbsValue
       * @accepts {Gantt.data.Wbs|String}
       * @category Scheduling
       */
      { name: "wbsValue", type: "wbs", persist: false },
      /**
       * A deadline date for this task. Does not affect scheduling logic.
       *
       * Note that the field always returns a `Date`.
       *
       * @field {Date} deadlineDate
       * @accepts {String|Date}
       * @category Scheduling
       */
      { name: "deadlineDate", type: "date" },
      // Override TreeNode parentIndex to make it persistable
      { name: "parentIndex", type: "number", persist: true },
      /**
       * CSS class specifying an icon to apply to the task row
       * @field {String} iconCls
       * @category Styling
       */
      "iconCls",
      /**
       * CSS class specifying an icon to apply to the task bar
       * @field {String} taskIconCls
       * @category Styling
       */
      "taskIconCls",
      /**
       * Specify false to prevent the event from being dragged (if {@link Gantt/feature/TaskDrag} feature is used)
       * @field {Boolean} draggable
       * @default true
       * @category Interaction
       */
      { name: "draggable", type: "boolean", persist: false, defaultValue: true },
      // true or false
      /**
       * Specify false to prevent the task from being resized (if {@link Gantt/feature/TaskResize} feature is
       * used). You can also specify 'start' or 'end' to only allow resizing in one direction
       * @field {Boolean|String} resizable
       * @default true
       * @category Interaction
       */
      { name: "resizable", persist: false, defaultValue: true },
      // true, false, 'start' or 'end'
      /**
       * Changes task's background color. Named colors are applied as a `b-sch-color-{color}` (for example
       * `b-sch-color-red`) CSS class to the task's bar. Colors specified as hex, `rgb()` etc. are applied as
       * `style.color` to the bar.
       *
       * If no color is specified, any color defined in Gantt's {@link Gantt/view/GanttBase#config-eventColor}
       * config will apply instead.
       *
       * For available standard colors, see
       * {@link Scheduler/model/mixin/EventModelMixin#typedef-EventColor}.
       *
       * Using named colors:
       *
       * ```javascript
       * const gantt = new Gantt({
       *     project {
       *         tasksData : [
       *             { id : 1, name : 'Important task', eventColor : 'red' }
       *         ]
       *     }
       * });
       * ```
       *
       * Will result in:
       * ```html
       * <div class="b-gantt-task-wrap b-sch-color-red">
       * ```
       *
       * Using non-named colors:
       *
       * ```javascript
       * const gantt = new Gantt({
       *     project {
       *         tasksData : [
       *             { id : 1, name : 'Important task', eventColor : '#ff0000' }
       *         ]
       *     }
       * });
       * ```
       *
       * Will result in:
       *
       * ```html
       * <div class="b-gantt-task-wrap" style="color: #ff0000">
       * ```
       *
       * @field {EventColor} eventColor
       */
      "eventColor"
    ];
  }
  //endregion
  getDefaultSegmentModelClass() {
    return EventSegmentModel;
  }
  endBatch() {
    const { isPersistable: wasPersistable } = this;
    super.endBatch(...arguments);
    if (this.isPersistable && !wasPersistable) {
      this.assignments.forEach((assignment) => {
        assignment.stores.forEach((s) => {
          s.updateModifiedBagForRecord(assignment);
        });
      });
    }
  }
  /**
   * Returns all predecessor dependencies of this task
   * @member {Gantt.model.DependencyModel[]} predecessors
   * @readonly
   */
  /**
   * Returns all successor dependencies of this task
   * @member {Gantt.model.DependencyModel[]} successors
   * @readonly
   */
  get isTask() {
    return true;
  }
  get isTaskModel() {
    return true;
  }
  // To pass as an event when using a Gantt project with Scheduler Pro
  get isEvent() {
    return true;
  }
  get wbsCode() {
    return String(this.wbsValue);
  }
  set wbsCode(value) {
    this.wbsValue = Wbs.from(value);
  }
  copy(...args) {
    const copy = super.copy(...args);
    copy.setData("wbsValue", null);
    return copy;
  }
  /**
   * Propagates changes to the dependent tasks. For example:
   *
   * ```js
   * // double a task duration
   * task.duration *= 2;
   * // call commitAsync() to do further recalculations caused by the duration change
   * task.commitAsync().then(() => console.log('Schedule updated'));
   * ```
   *
   * @method commitAsync
   * @async
   * @propagating
   */
  /**
   * Either activates or deactivates the task depending on the passed value.
   * Will cause the schedule to be updated - returns a `Promise`
   *
   * @method
   * @name setInactive
   * @param {Boolean} inactive `true` to deactivate the task, `false` to activate it.
   * @async
   * @propagating
   */
  /**
   * Sets {@link #field-segments} field value.
   *
   * @method
   * @name setSegments
   * @param {SchedulerPro.model.EventSegmentModel[]} segments Array of segments or null to make the task not segmented.
   * @returns {Promise}
   * @propagating
   */
  /**
   * Splits the task to segments.
   * @method splitToSegments
   * @param {Date} from The date to split this task at.
   * @param {Number} [lag=1] Split duration.
   * @param {String} [lagUnit] Split duration unit.
   * @returns {Promise}
   * @propagating
   */
  /**
   * Merges the task segments.
   * The method merges two provided task segments (and all the segment between them if any).
   * @method mergeSegments
   * @param {SchedulerPro.model.EventSegmentModel} [segment1] First segment to merge.
   * @param {SchedulerPro.model.EventSegmentModel} [segment2] Second segment to merge.
   * @returns {Promise}
   * @propagating
   */
  /**
   * Sets the task {@link #field-ignoreResourceCalendar} field value and triggers rescheduling.
   *
   * @method setIgnoreResourceCalendar
   * @param {Boolean} ignore Provide `true` to ignore the calendars of the assigned resources
   * when scheduling the task. If `false` the task performs only when
   * its own {@link #field-calendar} and some of the assigned
   * resource calendars allow that.
   * @async
   * @propagating
   */
  /**
   * Returns the event {@link #field-ignoreResourceCalendar} field value.
   *
   * @method getIgnoreResourceCalendar
   * @returns {Boolean} The event {@link #field-ignoreResourceCalendar} field value.
   */
  /**
   * The event first segment or null if the event is not segmented.
   * @member {SchedulerPro.model.EventSegmentModel} firstSegment
   */
  /**
   * The event last segment or null if the event is not segmented.
   * @member {SchedulerPro.model.EventSegmentModel} lastSegment
   */
  // Apply baseline defaults to records added to the baselines store
  processBaselinesStoreData(data) {
    return applyBaselineDefaults(this, data);
  }
  set baselines(baselines) {
    this.set({ baselines });
  }
  // Tests expect baselines to initialize on first access, not when task is created
  get baselines() {
    const me = this;
    if (!me.$initializedBaselines) {
      const baselinesField = me.fieldMap.baselines;
      baselinesField.init(me.data, me);
      me.assignInitables();
      me.$initializedBaselines = true;
    }
    return me.meta.baselinesStore;
  }
  get hasBaselines() {
    var _a2, _b;
    const baselinesField = this.fieldMap.baselines;
    return Boolean((_b = (_a2 = this.baselines) == null ? void 0 : _a2.count) != null ? _b : this.originalData[baselinesField.dataSource]);
  }
  /**
   * Applies the start/end dates from the task to the corresponding baseline.
   *
   * ```javascript
   * const task = new TaskModel({
   *      name: 'New task',
   *      startDate: '2019-01-14',
   *      endDate: '2019-01-17',
   *      duration: 3,
   *      baselines: [
   *          // Baseline version 1
   *          {
   *              startDate: '2019-01-13',
   *              endDate: '2019-01-16'
   *          },
   *          // Baseline version 2
   *          {
   *              startDate: '2019-01-14',
   *              endDate: '2019-01-17'
   *          },
   *          // Baseline version 3
   *          {
   *              startDate: '2019-01-15',
   *              endDate: '2019-01-18'
   *          }
   *      ]
   * });
   *
   * // Apply the task's start/end dates to the baseline version 3
   * task.setBaseline(3);
   * ```
   * @param {Number} version The baseline version to update
   */
  setBaseline(version) {
    if (version <= 0) {
      return;
    }
    const { baselines } = this, missingBaselines = version - baselines.count;
    if (missingBaselines > 0) {
      baselines.add(applyBaselineDefaults(this, new Array(missingBaselines).fill({})));
    } else {
      baselines.getAt(version - 1).set(applyBaselineDefaults(this, [{}])[0]);
    }
  }
  get successors() {
    return Array.from(this.outgoingDeps || []);
  }
  set successors(successors) {
    this.outgoingDeps = successors;
  }
  setSuccessors(successors) {
    return this.replaceDependencies(successors, true);
  }
  // Updates either predecessors or successors with a new array, updating existing dependency records and
  // removing existing dependencies not part of current set
  replaceDependencies(dependencyRecords, isSuccessors) {
    const me = this, { dependencyStore } = me.project, updated = /* @__PURE__ */ new Set(), toAdd = /* @__PURE__ */ new Set(), toRemove = [], currentSet = isSuccessors ? me.outgoingDeps : me.incomingDeps, depsArr = Array.from(currentSet);
    dependencyRecords.forEach((dependency) => {
      const existingDep = depsArr.find(isSuccessors ? (dep) => dep.toEvent === dependency.toEvent : (dep) => dep.fromEvent === dependency.fromEvent);
      if (existingDep) {
        updated.add(existingDep);
        existingDep.copyData(dependency);
      } else {
        toAdd.add(dependency);
      }
    });
    currentSet.forEach((dependency) => {
      if (!updated.has(dependency)) {
        toRemove.push(dependency);
      }
    });
    toRemove.forEach((dependency) => dependencyStore.remove(dependency));
    toAdd.forEach((dependency) => {
      if (isSuccessors) {
        dependency.fromEvent = me;
      } else {
        dependency.toEvent = me;
      }
      dependencyStore.add(dependency);
    });
    return me.commitAsync();
  }
  get predecessors() {
    return Array.from(this.incomingDeps || []);
  }
  set predecessors(predecessors) {
    this.incomingDeps = predecessors;
  }
  setPredecessors(predecessors) {
    return this.replaceDependencies(predecessors, false);
  }
  get assignments() {
    return super.assignments;
  }
  set assignments(assignments) {
    const me = this, { assignmentStore } = me.project, toAdd = [], currentAssignments = me.assignments, removedAssignments = currentAssignments.filter((current) => !(assignments == null ? void 0 : assignments.find((newAss) => newAss.resource === current.resource)));
    assignments.forEach((assignment) => {
      const currentAssignment = assignmentStore.getAssignmentForEventAndResource(this, assignment.resource);
      if (currentAssignment) {
        currentAssignment.copyData(assignment);
      } else {
        assignment.remove();
        toAdd.push(assignment);
      }
    });
    assignmentStore.remove(removedAssignments);
    assignmentStore.add(toAdd);
  }
  get assigned() {
    var _a2;
    const { project } = this;
    if (project == null ? void 0 : project.isDelayingCalculation) {
      return (_a2 = project.assignmentStore.storage.findItem("event", this)) != null ? _a2 : /* @__PURE__ */ new Set();
    }
    return super.assigned;
  }
  set assigned(assigned) {
    super.assigned = assigned;
  }
  //region Is
  get isDraggable() {
    return this.draggable;
  }
  get isResizable() {
    return this.resizable && !this.milestone && this.isEditable("endDate");
  }
  // override `isMilestone` on TimeSpan model and make it to return the same value what `milestone` returns
  get isMilestone() {
    return this.milestone;
  }
  /**
   * Defines if the given task field should be manually editable in UI.
   * You can override this method to provide your own logic.
   *
   * By default, the method defines:
   * - {@link #field-earlyStartDate}, {@link #field-earlyEndDate}, {@link #field-lateStartDate},
   * {@link #field-lateEndDate}, {@link #field-totalSlack} as not editable;
   * - {@link #field-effort}, {@link #property-fullEffort}, {@link #field-percentDone} as not editable for summary
   *   tasks;
   * - {@link #field-endDate}, {@link #field-duration} and {@link #field-fullDuration} fields
   *   as not editable for summary tasks except the {@link #field-manuallyScheduled manually scheduled} ones.
   *
   * @param {String} fieldName Name of the field
   * @returns {Boolean} Returns `true` if the field is editable, `false` if it is not and `undefined` if the task has
   * no such field.
   */
  isEditable(fieldName) {
    switch (fieldName) {
      case "earlyStartDate":
      case "earlyEndDate":
      case "lateStartDate":
      case "lateEndDate":
      case "totalSlack":
        return false;
      case "effort":
      case "fullEffort":
      case "percentDone":
      case "renderedPercentDone":
        return this.isLeaf;
      case "endDate":
      case "duration":
      case "fullDuration":
        return this.isLeaf || this.manuallyScheduled;
    }
    return super.isEditable(fieldName);
  }
  isFieldModified(fieldName) {
    if (fieldName === "fullEffort") {
      return super.isFieldModified("effort") || super.isFieldModified("effortUnit");
    }
    return super.isFieldModified(fieldName);
  }
  //endregion
  //region Milestone
  get milestone() {
    if (!this.isLeaf) {
      const { startDate, endDate } = this;
      if (startDate && endDate) {
        return endDate.getTime() === startDate.getTime();
      }
    }
    return this.duration === 0;
  }
  set milestone(value) {
    value ? this.convertToMilestone() : this.convertToRegular();
  }
  async setMilestone(value) {
    return value ? this.convertToMilestone() : this.convertToRegular();
  }
  /**
   * Converts this task to a milestone (start date will match the end date).
   * @propagating
   */
  async convertToMilestone() {
    return this.setDuration(0, this.durationUnit, false);
  }
  /**
   * Converts the milestone task to a regular task with a duration of 1 (keeping current {@link #field-durationUnit}).
   * @propagating
   */
  async convertToRegular() {
    if (this.milestone) {
      return this.setDuration(1, this.durationUnit, false);
    }
  }
  //endregion
  //region Dependencies
  /**
   * Returns all dependencies of this task (both incoming and outgoing)
   *
   * @property {Gantt.model.DependencyModel[]}
   */
  get allDependencies() {
    return this.dependencies;
  }
  get dependencies() {
    var _a2;
    if ((_a2 = this.project) == null ? void 0 : _a2.isDelayingCalculation) {
      return [];
    }
    return [...this.incomingDeps || [], ...this.outgoingDeps || []];
  }
  set dependencies(dependencies) {
    const me = this, predecessors = [], successors = [];
    dependencies == null ? void 0 : dependencies.forEach((dependency) => {
      if (dependency.fromEvent === me || dependency.fromEvent === me.id) {
        successors.push(dependency);
      } else if (dependency.toEvent === me || dependency.toEvent === me.id) {
        predecessors.push(dependency);
      }
    });
    me.setPredecessors(predecessors);
    me.setSuccessors(successors);
  }
  /**
   * Returns all predecessor tasks of a task
   *
   * @property {Gantt.model.TaskModel[]}
   */
  get predecessorTasks() {
    return [...this.incomingDeps || []].map((dependency) => dependency.fromEvent);
  }
  /**
   * Returns all successor tasks of a task
   *
   * @readonly
   * @property {Gantt.model.TaskModel[]}
   */
  get successorTasks() {
    return [...this.outgoingDeps || []].map((dependency) => dependency.toEvent);
  }
  //endregion
  //region Calculated fields
  /**
   * Returns count of all sibling nodes (including their children).
   * @property {Number}
   */
  get previousSiblingsTotalCount() {
    let task = this.previousSibling, count = this.parentIndex;
    while (task) {
      count += task.descendantCount;
      task = task.previousSibling;
    }
    return count;
  }
  /**
   * Returns the sequential number of the task. A sequential number means the ordinal position of the task in the
   * total dataset, regardless of its nesting level and collapse/expand state of any parent tasks. The root node has a
   * sequential number equal to 0.
   *
   * For example, in the following tree data sample sequential numbers are specified in the comments:
   * ```javascript
   * root : {
   *     children : [
   *         {   // 1
   *             leaf : true
   *         },
   *         {       // 2
   *             children : [
   *                 {   // 3
   *                     children : [
   *                         {   // 4
   *                             leaf : true
   *                         },
   *                         {   // 5
   *                             leaf : true
   *                         }
   *                     ]
   *                 }]
   *         },
   *         {   // 6
   *             leaf : true
   *         }
   *     ]
   * }
   * ```
   * If we collapse parent tasks, sequential number of collapsed tasks won't change.
   *
   * @property {Number}
   */
  get sequenceNumber() {
    if (this.taskStore) {
      return this.taskStore.allIndexOf(this) + 1;
    }
    let code = 0, task = this;
    while (task.parent) {
      code += task.previousSiblingsTotalCount + 1;
      task = task.parent;
    }
    return code;
  }
  //endregion
  //region Project related methods
  get isSubProject() {
    return false;
  }
  get subProject() {
    const me = this;
    let project = null;
    if (me.isProject) {
      project = me;
    } else {
      me.bubbleWhile((t) => {
        if (t.isProject) {
          project = t;
        }
        return !project;
      });
    }
    return project;
  }
  //endregion
  /**
   * Property which encapsulates the effort's magnitude and units.
   *
   *
   * UI fields representing this property are disabled for summary events.
   * See {@link #function-isEditable} for details.
   *
   * @property {Core.data.Duration}
   */
  get fullEffort() {
    return new Duration({
      unit: this.effortUnit,
      magnitude: this.effort
    });
  }
  set fullEffort(effort) {
    this.setEffort(effort.magnitude, effort.unit);
  }
  //region Scheduler Pro compatibility
  /**
   * Returns all resources assigned to an event.
   *
   * @property {Gantt.model.ResourceModel[]}
   * @readonly
   */
  get resources() {
    return this.assignments.reduce((resources, assignment) => {
      assignment.resource && resources.push(assignment.resource);
      return resources;
    }, []);
  }
  // Resources + any links to any of them
  get $linkedResources() {
    var _a2, _b;
    return (_b = (_a2 = this.resources) == null ? void 0 : _a2.flatMap((resourceRecord) => [
      resourceRecord,
      ...resourceRecord.$links
    ])) != null ? _b : [];
  }
  //endregion
  /**
   * A `Set<Gantt.model.DependencyModel>` of the outgoing dependencies for this task
   * @member {Set} outgoingDeps
   * @readonly
   */
  /**
   * A `Set<Gantt.model.DependencyModel>` of the incoming dependencies for this task
   * @member {Set} incomingDeps
   * @readonly
   */
  /**
   * An array of the assignments, related to this task
   * @member {Gantt.model.AssignmentModel[]} assignments
   * @readonly
   */
  /**
   * If given resource is assigned to this task, returns a {@link Gantt.model.AssignmentModel} record.
   * Otherwise returns `null`
   *
   * @method getAssignmentFor
   * @param {Gantt.model.ResourceModel} resource The instance of {@link Gantt.model.ResourceModel}
   *
   * @returns {Gantt.model.AssignmentModel|null}
   */
  /**
   * This method assigns a resource to this task.
   *
   * Will cause the schedule to be updated - returns a `Promise`
   *
   * @method assign
   * @param {Gantt.model.ResourceModel} resource The instance of {@link Gantt.model.ResourceModel}
   * @param {Number} [units=100] The `units` field of the new assignment
   *
   * @async
   * @propagating
   */
  /**
   * This method unassigns a resource from this task.
   *
   * Will cause the schedule to be updated - returns a `Promise`
   *
   * @method unassign
   * @param {Gantt.model.ResourceModel} resource The instance of {@link Gantt.model.ResourceModel}
   * @async
   * @propagating
   */
  /**
   * Sets the calendar of the task. Will cause the schedule to be updated - returns a `Promise`
   *
   * @method setCalendar
   * @param {Gantt.model.CalendarModel} calendar The new calendar. Provide `null` to return back to the project calendar.
   * @async
   * @propagating
   */
  /**
   * Returns the task calendar.
   *
   * @method getCalendar
   * @returns {Gantt.model.CalendarModel} The task calendar.
   */
  /**
   * Sets the start date of the task. Will cause the schedule to be updated - returns a `Promise`
   *
   * Note, that the actually set start date may be adjusted, according to the calendar, by skipping the non-working time forward.
   *
   * @method setStartDate
   * @param {Date} date The new start date.
   * @param {Boolean} [keepDuration=true] Whether to keep the duration (and update the end date), while changing the start date, or vice-versa.
   * @async
   * @propagating
   */
  /**
   * Sets the end date of the task. Will cause the schedule to be updated - returns a `Promise`
   *
   * Note, that the actually set end date may be adjusted, according to the calendar, by skipping the non-working time backward.
   *
   * @method setEndDate
   * @param {Date} date The new end date.
   * @param {Boolean} [keepDuration=false] Whether to keep the duration (and update the start date), while changing the end date, or vice-versa.
   * @async
   * @propagating
   */
  /**
   * Updates the duration (and optionally unit) of the task. Will cause the schedule to be updated - returns a `Promise`
   *
   * @method setDuration
   * @param {Number} duration New duration value
   * @param {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} [unit] New duration
   * unit
   * @async
   * @propagating
   */
  /**
   * Updates the effort (and optionally unit) of the task. Will cause the schedule to be updated - returns a `Promise`
   *
   * @method setEffort
   * @param {Number} effort New effort value
   * @param {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} [unit] New effort
   * unit
   * @async
   * @propagating
   */
  /**
   * Sets the constraint type and (optionally) constraining date to the task.
   *
   * @method setConstraint
   * @param {'finishnoearlierthan'|'finishnolaterthan'|'mustfinishon'|'muststarton'|'startnoearlierthan'|'startnolaterthan'|null} constraintType
   * Constraint type, please refer to the {@link Gantt.model.TaskModel#field-constraintType} for the valid values.
   * @param {Date}   [constraintDate] Constraint date.
   * @async
   * @propagating
   */
  //region Normalization
  normalize() {
  }
  inSetNormalize(field2) {
  }
  /**
   * Not (yet) supported by the underlying scheduling engine
   * @function setStartEndDate
   * @hide
   * @param {Date} start The new start date
   * @param {Date} end The new end date
   */
  //endregion
  joinStore(store) {
    var _a2, _b;
    const me = this, useOrderedTree = (me.firstStore || store).useOrderedTreeForWbs;
    if (!me.wbsValue && !me.generatedParent) {
      if ((me.taskStore || store).isLoadingData || !(((_a2 = me.nextSibling) == null ? void 0 : _a2.wbsValue) || ((_b = me.previousSibling) == null ? void 0 : _b.wbsValue))) {
        me.refreshWbs({ useOrderedTree, ...refreshWbsOnJoinOptions });
      } else {
        me.parent.refreshWbs(refreshWbsOptions, -1);
      }
    }
    super.joinStore(store);
  }
  /**
   * Refreshes the {@link #field-wbsValue} of this record and its children. This is rarely needed but may be required
   * after a complex series of filtering, inserting, or removing nodes. In particular, removing nodes does create a
   * gap in `wbsValue` values that may be undesirable.
   * @param {Object} [options] A set of options for refreshing.
   * @param {Boolean} [options.deep=true] Pass `false` to not update the `wbsValue` of this node's children.
   * @param {Boolean} [options.silent=false] Pass `true` to update the `wbsValue` silently (no events). This is done
   * at load time since this value represents the clean state. Passing `true` also has the effect of not marking the
   * change as a dirty state on the record, in the case where `wbsValue` has been flagged as `persist: true`.
   * @param {Boolean} [options.useOrderedTree=false] Pass `true` to use ordered tree to calculate WBS index.
   * @param {Number} [index] The index of this node in its parent's children array. Pass -1 to ignore this node's
   * `wbsValue` and only operate on children (if `options.deep`).
   */
  refreshWbs(options, index) {
    var _a2, _b, _c, _d, _e, _f;
    const me = this, { parent } = me, taskStore = me.firstStore || null, {
      useOrderedTree = (_a2 = taskStore == null ? void 0 : taskStore.useOrderedTreeForWbs) != null ? _a2 : false
    } = options || {};
    if (parent && index !== -1 && me.fieldMap.wbsValue) {
      if (useOrderedTree) {
        index = me.orderedParentIndex;
      } else {
        index = (_b = index != null ? index : me.unfilteredIndex) != null ? _b : me.parentIndex;
      }
      index++;
      const wbs = parent.isRoot ? new Wbs(index) : parent.wbsValue.append(index);
      if (options == null ? void 0 : options.silent) {
        me.setData("wbsValue", wbs);
      } else {
        me.set("wbsValue", wbs);
      }
    }
    if ((_c = options == null ? void 0 : options.deep) != null ? _c : true) {
      if (useOrderedTree) {
        for (const child of (_d = me.orderedChildren) != null ? _d : []) {
          child.refreshWbs(options);
        }
      } else {
        const children = (_e = me.unfilteredChildren) != null ? _e : me.children, n = (children == null ? void 0 : children.length) || 0;
        if (n) {
          const reverse = isReversed(children) && ((_f = taskStore == null ? void 0 : taskStore.sorters) == null ? void 0 : _f.findIndex(descendingWbsSorter)) === 0;
          for (let i = 0; i < n; ++i) {
            children[i].refreshWbs(options, reverse ? n - i - 1 : i);
          }
        }
      }
    }
  }
  async tryInsertChild() {
    return this.getProject().tryPropagateWithChanges(() => {
      this.insertChild(...arguments);
    });
  }
  updateDependencies(startDate, endDate) {
    this.outgoingDeps.forEach((dep) => {
      if (dep.toEvent.isScheduled) {
        const {
          type,
          calendar,
          toEvent
        } = dep;
        if (startDate) {
          if (type === DependencyBaseModel.Type.StartToStart) {
            dep.setLag(DateHelper.as("hour", calendar.calculateDurationMs(startDate, toEvent.startDate, true)), "hour");
          } else if (type === DependencyBaseModel.Type.StartToEnd) {
            dep.setLag(DateHelper.as("hour", calendar.calculateDurationMs(startDate, toEvent.endDate, true)), "hour");
          }
        }
        if (endDate) {
          if (type === DependencyBaseModel.Type.EndToStart) {
            dep.setLag(DateHelper.as("hour", calendar.calculateDurationMs(endDate, toEvent.startDate, true)), "hour");
          } else if (type === DependencyBaseModel.Type.EndToEnd) {
            dep.setLag(DateHelper.as("hour", calendar.calculateDurationMs(endDate, toEvent.endDate, true)), "hour");
          }
        }
      }
    });
  }
  async moveTaskPinningSuccessors(date) {
    const me = this;
    me.startDate = date;
    me.bubble((node) => {
      if (!node.isRoot) {
        const startDate = node.run("calculateStartDate"), endDate = node.run("calculateEndDate");
        node.updateDependencies(startDate, endDate);
      }
    });
    return me.project.commitAsync();
  }
  async setStartDatePinningSuccessors(date) {
    const me = this, promise = me.setStartDate(date, false);
    me.bubble((node) => {
      if (!node.isRoot) {
        const startDate = node.run("calculateStartDate");
        node.updateDependencies(startDate, null);
      }
    });
    return promise;
  }
  async setEndDatePinningSuccessors(date) {
    const me = this;
    me.endDate = date;
    me.bubble((node) => {
      if (!node.isRoot) {
        const endDate = node.run("calculateEndDate");
        node.updateDependencies(null, endDate);
      }
    });
    return me.project.commitAsync();
  }
  getCurrentConfig(options) {
    const { segments } = this, result = super.getCurrentConfig(options);
    if (result && segments) {
      result.segments = segments.map((segment) => segment.getCurrentConfig(options));
    }
    return result;
  }
};
TaskModel.convertEmptyParentToLeaf = true;
TaskModel._$name = "TaskModel";

// lib/Gantt/data/TaskStore.js
var refreshWbsForChildrenOptions = { deep: true };
var wbsAuto = Object.freeze({
  add: true,
  remove: true,
  sort: true
});
var wbsManual = Object.freeze({
  add: false,
  remove: false,
  sort: false
});
var sortByWbs = (lhs, rhs) => Wbs.compare(lhs == null ? void 0 : lhs.wbsCode, rhs == null ? void 0 : rhs.wbsCode);
var TaskStore = class extends ChronoEventTreeStoreMixin.derive(AjaxStore).mixin(
  PartOfProject_default2,
  DayIndexMixin_default,
  GetEventsMixin_default
) {
  static get defaultConfig() {
    return {
      modelClass: TaskModel,
      /**
       * CrudManager must load stores in the correct order. Lowest first.
       * @config {Number}
       * @private
       */
      loadPriority: 200,
      /**
       * CrudManager must sync stores in the correct order. Lowest first.
       * @config {Number}
       * @private
       */
      syncPriority: 300,
      storeId: "tasks",
      tree: true
    };
  }
  static get configurable() {
    return {
      /**
       * Set to `'auto'` to automatically update {@link Gantt.model.TaskModel#field-wbsValue} as records in the
       * store are manipulated (e.g., when the user performs drag-and-drop reordering).
       *
       * In manual mode, the WBS value is initialized as the store loads and only altered implicitly by the
       * {@link #function-indent} and {@link #function-outdent} methods. The WBS values are otherwise updated only
       * by an explicit call to {@link Gantt.model.TaskModel#function-refreshWbs}.
       *
       * This can also be a {@link #typedef-WbsMode} object that indicates what operations
       * should automatically {@link Gantt.model.TaskModel#function-refreshWbs refresh} WBS values.
       *
       * The operations that trigger WBS refresh can be enabled explicitly in this object, for example:
       *
       * ```javascript
       *  wbsMode : {
       *      add : true,
       *      remove : true
       *  }
       * ```
       * The above is an opt-in list that enable auto WBS refresh for node add and remove operations (these two
       * operations are associated with dragging to reorder items). No other operation will trigger WBS refresh.
       * At present, this leaves out only the `sort` operation, but if new auto-refreshing operations were added
       * in future releases, those would also not be included.
       *
       * Alternatively, this object can be an opt-out specification if all values are falsy:
       *
       * ```javascript
       *  wbsMode : {
       *      sort : false
       *  }
       * ```
       * The above two examples are (currently) equivalent in outcome. The choice between opt-in or opt-out form
       * is a matter of convenience as well as future-proofing preference.
       *
       * The value `'auto'` is equivalent to all properties being `true`.
       * The value `'manual'` (the default) is equivalent to all properties being `false`.
       * @config {String|WbsMode}
       */
      wbsMode: "manual",
      /**
       * Specifies which tree to use to calculate WBS. Ordered tree is unsortable and unfilterable, it
       * always holds complete tree hierarchy. By default, it uses sortable and filterable tree.
       * @config {Boolean}
       * @default
       */
      useOrderedTreeForWbs: false,
      /**
       * Controls behavior of the outdent logic regarding siblings. By default, outdent will move child to be
       * its parent's sibling and will move all previous siblings to the outdented node's children. Visually, node
       * will remain in place just changing the level. When set to `true` only node with its subtree will be
       * outdented, siblings will not change parent. Visually, node will be moved as last child of the new parent.
       * @config {Boolean}
       * @default
       */
      outdentIgnoringSiblings: false,
      /**
       * Always return changes in increasing WBS order.
       * @config {Boolean}
       * @default
       */
      forceWbsOrderForChanges: false
    };
  }
  changeWbsMode(value) {
    if (value === "auto") {
      return wbsAuto;
    }
    if (value && typeof value === "object") {
      if (ObjectHelper.values(value).every((v) => !v)) {
        value = ObjectHelper.assign({}, wbsAuto, value);
      }
      return value;
    }
    return wbsManual;
  }
  /**
   * For each task in this TaskStore, sets the data in the passed baseline index to the current state of the task.
   * @param {Number} index The index in the baselines list of the baseline to update.
   */
  setBaseline(index) {
    const data = this.storage.values;
    this.forEach((task) => task.setBaseline(index));
    this.trigger("refresh", {
      action: "batch",
      records: data,
      data
    });
  }
  /**
   * Increase the indentation level of one or more tasks in the tree
   * @param {Gantt.model.TaskModel|Gantt.model.TaskModel[]} nodes The nodes to indent.
   * @returns {Promise} A promise which yields the result of the operation
   * @fires indent
   * @fires change
   */
  async indent(nodes) {
    const me = this, { taskStore, project } = me;
    let result = false;
    nodes = Array.isArray(nodes) ? nodes.slice() : [nodes];
    nodes = nodes.filter((node) => !node.isProjectModel);
    nodes = nodes.filter((node) => {
      let result2;
      result2 = Boolean(node.previousSibling);
      while (result2 && !node.isRoot) {
        result2 = !nodes.includes(node.parent);
        node = node.parent;
      }
      return result2;
    });
    if (nodes.length && taskStore.trigger("beforeIndent", { records: nodes }) !== false) {
      nodes.sort((lhs, rhs) => Wbs.compare(lhs.wbsCode, rhs.wbsCode));
      taskStore.beginBatch();
      result = await project.tryPropagateWithChanges(() => {
        for (const node of nodes) {
          const newParent = node.previousSibling;
          newParent.appendChild(node);
          me.toggleCollapse(newParent, false);
        }
      });
      if (me.isDestroyed) {
        return;
      }
      taskStore.endBatch();
      if (result) {
        me.refreshWbsForChildren({
          up: 2,
          // the nodes are now deeper but that move affects their grandparent node's WBS
          nodes
        });
        me.trigger("indent", { records: nodes });
        me.trigger("change", {
          action: "indent",
          records: nodes
        });
      }
    }
    return result;
  }
  /**
   * Decrease the indentation level of one or more tasks in the tree
   * @param {Gantt.model.TaskModel|Gantt.model.TaskModel[]} nodes The nodes to outdent.
   * @returns {Promise} A promise which yields the result of the operation
   * @fires outdent
   * @fires change
   */
  async outdent(nodes) {
    const me = this, { taskStore, project } = me;
    let result = false;
    nodes = Array.isArray(nodes) ? nodes.slice() : [nodes];
    nodes = nodes.filter((node) => !node.isProjectModel);
    nodes = nodes.filter((node) => {
      let result2;
      result2 = node.parent && !node.parent.isRoot;
      while (result2 && !node.isRoot) {
        result2 = !nodes.includes(node.parent);
        node = node.parent;
      }
      return result2;
    });
    if (nodes.length && taskStore.trigger("beforeOutdent", { records: nodes }) !== false) {
      nodes.sort((lhs, rhs) => Wbs.compare(rhs.wbsCode, lhs.wbsCode));
      taskStore.beginBatch();
      result = await project.tryPropagateWithChanges(() => {
        for (const node of nodes) {
          const newChildren = !this.outdentIgnoringSiblings && node.parent.children.slice(node.parent.children.indexOf(node) + 1);
          node.parent.parent.insertChild(node, node.parent.nextSibling, false, {
            orderedBeforeNode: node.parent.nextOrderedSibling
          });
          newChildren.length && node.appendChild(newChildren);
          me.toggleCollapse(node, false);
        }
      });
      if (me.isDestroyed) {
        return;
      }
      taskStore.endBatch();
      if (result) {
        me.refreshWbsForChildren({
          up: 1,
          // only need to update the (new) parent
          nodes
        });
        me.trigger("outdent", { records: nodes });
        me.trigger("change", {
          action: "outdent",
          records: nodes
        });
      }
    }
    return result;
  }
  onNodeAddChild(parent, children, index, isMove, silent = false) {
    super.onNodeAddChild(parent, children, index, isMove, silent);
    if (!this.isLoadingData && this.wbsMode.add) {
      parent.refreshWbs(refreshWbsForChildrenOptions);
      const wbsRefreshed = /* @__PURE__ */ new Set();
      children.forEach((child) => {
        const oldParent = this.getById(child.meta.oldParentId);
        if (oldParent && parent !== oldParent && !wbsRefreshed.has(oldParent)) {
          wbsRefreshed.add(oldParent);
          oldParent.refreshWbs(refreshWbsForChildrenOptions, -1);
        }
      });
    }
  }
  onNodeRemoveChild(parent, children, index, flags = { isMove: false, silent: false, unfiltered: false }) {
    const result = super.onNodeRemoveChild(parent, children, index, flags);
    if (this.wbsMode.remove && !flags.isMove) {
      parent.refreshWbs(refreshWbsForChildrenOptions);
    }
    return result;
  }
  // Preserve outdented nodes' position among new siblings when unsorted (#7135)
  // Requires forceWbsOrderInChanges=true
  applyChangeset(changes, transformFn = null, ...rest) {
    var _a2, _b, _c;
    const me = this, { updated, modified } = (_a2 = transformFn == null ? void 0 : transformFn(changes, me)) != null ? _a2 : changes, altered = (_b = updated != null ? updated : modified) != null ? _b : [];
    const outdented = me.forceWbsOrderForChanges && me.tree && !me.isSorted && !me.isGrouped ? altered.reduce((outdented2, { id, parentId }) => {
      var _a3, _b2;
      if (parentId !== void 0) {
        const node = me.getById(id), currentGrandparentId = (_a3 = node == null ? void 0 : node.parent) == null ? void 0 : _a3.parentId;
        if (parentId === currentGrandparentId) {
          outdented2.push({
            node,
            originalNodeAbove: (_b2 = node.previousSibling) != null ? _b2 : node.parent
          });
        }
      }
      return outdented2;
    }, []) : [];
    const log = super.applyChangeset(changes, transformFn, ...rest);
    if (outdented.length > 0) {
      for (const { node, originalNodeAbove } of outdented) {
        const { parent } = node, nodeAboveIndex = originalNodeAbove.parent === parent ? originalNodeAbove.parentIndex : ((_c = originalNodeAbove.parent) == null ? void 0 : _c.parent) === parent ? originalNodeAbove.parent.parentIndex : void 0;
        if (nodeAboveIndex !== void 0 && parent.children.includes(node)) {
          parent.insertChild(node, nodeAboveIndex + 1);
        }
      }
    }
    return log;
  }
  afterChangesetApplied(modifiedParents) {
    super.afterChangesetApplied(modifiedParents);
    modifiedParents.forEach((record) => {
      record.refreshWbs({ deep: true, useOrderedTree: true });
    });
  }
  afterPerformSort(silent) {
    if (this.wbsMode.sort) {
      this.rootNode.refreshWbs(refreshWbsForChildrenOptions);
    }
    super.afterPerformSort(silent);
  }
  /**
   * This method updates the WBS values due to changes in the indentation of a given set of child nodes.
   * @param {Object} options An object containing options in addition to a `nodes` property with the children.
   * @param {Gantt.model.TaskModel[]} options.nodes The array of child record to refresh. This is required.
   * @param {Boolean} [options.silent=false] Pass `true` to update the `wbsValue` silently (no events).
   * @param {Number} [options.up=1] The number of ancestors to ascend when determining the parent(s) to refresh.
   * By default, this value is 1 which indicates the immediate parent of the supplied nodes. This is suitable for
   * outdenting. For indenting, this value should be 2. This is because the previous parent node (now grandparent
   * node) needs to be refreshed, not merely the new parent.
   * @private
   */
  refreshWbsForChildren(options) {
    const nodes = options.nodes, opts = { ...refreshWbsForChildrenOptions, ...options }, parents = /* @__PURE__ */ new Set(), up = opts.up || 0;
    let n, parent;
    nodes.forEach((node) => {
      for (parent = node, n = up; parent && n; --n) {
        parent = parent.parent;
      }
      parents.add(parent);
    });
    for (parent of parents) {
      parent.refreshWbs(opts);
    }
  }
  getTotalTimeSpan() {
    return {
      startDate: this.getProject().startDate,
      endDate: this.getProject().endDate
    };
  }
  getEventsForResource(resourceId) {
    const resource = this.resourceStore.getById(resourceId), assignments = (resource == null ? void 0 : resource.assignments.filter((assignment) => assignment.isPartOfStore(this.assignmentStore))) || [], events = [];
    assignments.forEach(({ event }) => event && events.push(event));
    return events;
  }
  /**
   * Checks if a date range is allocated or not for a given resource.
   * @param {Date} start The start date
   * @param {Date} end The end date
   * @param {Scheduler.model.EventModel|null} excludeEvent An event to exclude from the check (or null)
   * @param {Scheduler.model.ResourceModel} resource The resource
   * @returns {Boolean} True if the timespan is available for the resource
   * @category Resource
   */
  isDateRangeAvailable(start, end, excludeEvent, resource) {
    const allEvents = new Set(this.getEventsForResource(resource));
    if (excludeEvent == null ? void 0 : excludeEvent.isAssignment) {
      const currentEvent = excludeEvent.event, resources = currentEvent.resources;
      resources.forEach((resource2) => {
        if (resource2.id !== excludeEvent.resourceId) {
          this.getEventsForResource(resource2).forEach((event) => allEvents.add(event));
        }
      });
    }
    if (excludeEvent) {
      const eventToRemove = excludeEvent.isAssignment ? excludeEvent.event : excludeEvent;
      allEvents.delete(eventToRemove);
    }
    return !Array.from(allEvents).some((event) => event.isScheduled && DateHelper.intersectSpans(start, end, event.startDate, event.endDate));
  }
  linkTasks(tasks) {
    for (let i = 1; i < tasks.length; i++) {
      const from = tasks[i - 1], to = tasks[i];
      if (!this.dependencyStore.getEventsLinkingDependency(from, to)) {
        this.dependencyStore.add({ from, to });
      }
    }
  }
  unlinkTasks(tasks) {
    this.dependencyStore.remove(this.dependencyStore.query(({ fromTask, toTask }) => tasks.includes(fromTask) || tasks.includes(toTask)));
  }
  /**
   * Enforce `forceWbsOrderForChanges` if set.
   * @private
   */
  get changes() {
    const changes = super.changes;
    if (changes && this.forceWbsOrderForChanges) {
      changes.added.sort(sortByWbs);
      changes.modified.sort(sortByWbs);
      changes.removed.sort(sortByWbs);
    }
    return changes;
  }
};
__publicField(TaskStore, "$name", "TaskStore");
TaskStore._$name = "TaskStore";

// lib/Gantt/model/CalendarIntervalModel.js
var CalendarIntervalModel2 = class extends CalendarIntervalModel {
};
CalendarIntervalModel2._$name = "CalendarIntervalModel";

// lib/Gantt/model/ProjectModel.js
var ProjectModel3 = class extends GanttProjectMixin.derive(Model).mixin(
  ProjectChangeHandlerMixin_default,
  ProjectCurrentConfig_default,
  ProjectCrudManager_default2,
  ProjectModelTimeZoneMixin_default,
  ProjectModelCommon_default
) {
  /**
   * @hidefields id, readOnly, children, parentId, parentIndex
   */
  /**
   * Silences propagations caused by the project loading.
   *
   * Applying the loaded data to the project occurs in two basic stages:
   *
   * 1. Data gets into the engine graph which triggers changes propagation
   * 2. The changes caused by the propagation get written to related stores
   *
   * Setting this flag to `true` makes the component perform step 2 silently without triggering events causing reactions on those changes
   * (like sending changes back to the server if `autoSync` is enabled) and keeping stores in unmodified state.
   *
   * This is safe if the loaded data is consistent so propagation doesn't really do any adjustments.
   * By default the system treats the data as consistent so this option is `true`.
   *
   * ```javascript
   * new Gantt({
   *     project : {
   *         // We want scheduling engine to recalculate the data properly
   *         // so then we could save it back to the server
   *         silenceInitialCommit : false,
   *         ...
   *     }
   *     ...
   * })
   * ```
   *
   * @config {Boolean} silenceInitialCommit
   * @default true
   * @category Advanced
   */
  /**
   * Maximum range the project calendars can iterate.
   * The value is defined in milliseconds and by default equals `5 years` roughly.
   * ```javascript
   * new Gantt({
   *     project : {
   *         // adjust calendar iteration limit to 10 years roughly:
   *         // 10 years expressed in ms
   *         maxCalendarRange : 10 * 365 * 24 * 3600000,
   *         ...
   *     }
   * });
   * ```
   * @config {Number} maxCalendarRange
   * @default 157680000000
   * @category Advanced
   */
  /**
   * When `true` the project manually scheduled tasks will adjust their proposed start/end dates
   * to skip non working time.
   *
   * @field {Boolean} skipNonWorkingTimeWhenSchedulingManually
   * @default false
   */
  /**
   * This config manages DST correction in the scheduling engine. It only has effect when DST transition hour is
   * working time. Usually DST transition occurs on Sunday, so with non working weekends the DST correction logic
   * is not involved.
   *
   * If **true**, it will add/remove one hour when calculating duration from start/end dates. For example:
   * Assume weekends are working and on Sunday, 2020-10-25 at 03:00 clocks are set back 1 hour. Assume there is a task:
   *
   * ```javascript
   * {
   *     startDate    : '2020-10-20',
   *     duration     : 10,
   *     durationUnit : 'day'
   * }
   * ```
   * It will end on 2020-10-29 23:00. Because of the DST transition Sunday is actually 25 hours long and when the
   * Gantt project calculates the end date it converts days to hours multiplying by 24. If you're setting duration
   * and want task to end on the end of the day you should manually correct for DST, like so:
   *
   * ```javascript
   * {
   *     startDate    : '2020-10-20',
   *     duration     : 10 * 24 + 1,
   *     durationUnit : 'hour'
   * },
   * ```
   *
   * If task has start and end dates it will correct for DST twice:
   *
   * ```javascript
   * {
   *     startDate    : '2020-10-20',
   *     endDate      : '2020-10-30'
   * }
   * ```
   * This task will end on 2020-10-29 22:00 which is a known quirk.
   *
   * If **false**, the Gantt project will not add DST correction which fixes the quirk mentioned above and such task
   * will end on 2020-10-30 exactly, having hours duration of 10 days * 24 hours + 1 hour.
   *
   * Also, for this task days duration will be a floating point number due to extra (or missing) hour:
   *
   * ```javascript
   * task.getDuration('day')  // 10.041666666666666
   * task.getDuration('hour') // 241
   * ```
   *
   * @config {Boolean} adjustDurationToDST
   * @default false
   * @category Advanced
   */
  /**
   * Set to `true` to enable calculation progress notifications.
   * When enabled, the project fires {@link #event-progress} events and the Gantt chart load mask reacts by showing a progress bar for the Engine calculations.
   *
   * **Note**: Enabling progress notifications will impact calculation performance, since it needs to pause calculations to allow the UI to redraw.
   *
   * @config {Boolean} enableProgressNotifications
   * @category Advanced
   */
  /**
   * Enables/disables the calculation progress notifications.
   * @member {Boolean} enableProgressNotifications
   * @category Advanced
   */
  /**
   * Returns current Project changes as an object consisting of added/modified/removed arrays of records for every
   * managed store. Returns `null` if no changes exist. Format:
   *
   * ```javascript
   * {
   *     resources : {
   *         added    : [{ name : 'New guy' }],
   *         modified : [{ id : 2, name : 'Mike' }],
   *         removed  : [{ id : 3 }]
   *     },
   *     events : {
   *         modified : [{  id : 12, name : 'Cool task' }]
   *     },
   *     ...
   * }
   * ```
   *
   * @member {Object} changes
   * @readonly
   * @category Models & Stores
   */
  // region Events
  /**
   * Fired during the Engine calculation if {@link #config-enableProgressNotifications} config is `true`
   * @event progress
   * @param {Number} total The total number of operations
   * @param {Number} remaining The number of remaining operations
   * @param {'storePopulation'|'propagating'} phase The phase of the calculation, either 'storePopulation'
   * when data is getting loaded, or 'propagating' when data is getting calculated
   */
  /**
   * Fired when the Engine detects a computation cycle.
   * @event cycle
   * @param {Object} schedulingIssue Scheduling error describing the case:
   * @param {Function} schedulingIssue.getDescription Returns the cycle description
   * @param {Object} schedulingIssue.cycle Object providing the cycle info
   * @param {Function} schedulingIssue.getResolutions Returns possible resolutions
   * @param {Function} continueWithResolutionResult Function to call after a resolution is chosen to
   * proceed with the Engine calculations:
   * ```javascript
   * project.on('cycle', ({ continueWithResolutionResult }) => {
   *     // cancel changes in case of a cycle
   *     continueWithResolutionResult(EffectResolutionResult.Cancel);
   * })
   * ```
   */
  /**
   * Fired when the Engine detects a scheduling conflict.
   *
   * @event schedulingConflict
   * @param {Object} schedulingIssue The conflict details:
   * @param {Function} schedulingIssue.getDescription Returns the conflict description
   * @param {Object[]} schedulingIssue.intervals Array of conflicting intervals
   * @param {Function} schedulingIssue.getResolutions Function to get possible resolutions
   * @param {Function} continueWithResolutionResult Function to call after a resolution is chosen to
   * proceed with the Engine calculations:
   * ```javascript
   * project.on('schedulingConflict', ({ schedulingIssue, continueWithResolutionResult }) => {
   *     // apply the first resolution and continue
   *     schedulingIssue.getResolutions()[0].resolve();
   *     continueWithResolutionResult(EffectResolutionResult.Resume);
   * })
   * ```
   */
  /**
   * Fired when the Engine detects a calendar misconfiguration when the calendar does
   * not provide any working periods of time which makes usage impossible.
   * @event emptyCalendar
   * @param {Object} schedulingIssue Scheduling error describing the case:
   * @param {Function} schedulingIssue.getDescription Returns the error description
   * @param {Function} schedulingIssue.getCalendar Returns the calendar that must be fixed
   * @param {Function} schedulingIssue.getResolutions Returns possible resolutions
   * @param {Function} continueWithResolutionResult Function to call after a resolution is chosen to
   * proceed with the Engine calculations:
   * ```javascript
   * project.on('emptyCalendar', ({ schedulingIssue, continueWithResolutionResult }) => {
   *     // apply the first resolution and continue
   *     schedulingIssue.getResolutions()[0].resolve();
   *     continueWithResolutionResult(EffectResolutionResult.Resume);
   * })
   * ```
   */
  /**
   * Fired when the engine has finished its calculations and the results has been written back to the records.
   *
   * ```javascript
   * gantt.project.on({
   *     dataReady({ records }) {
   *         console.log('Calculations finished');
   *         for (const record of records) {
   *             console.log(`Modified #${record.id}: ${JSON.stringify(record.modifications)}`);
   *         }
   *         // Output:
   *         // Modified #12: {"endDate":null,"duration":7200000,"id":12}
   *         // Modified #1: {"percentDone":49.99998611112847,"id":1}
   *         // Modified #1000: {"percentDone":49.99965834045124,"id":1000}
   *     }
   * });
   *
   * gantt.project.taskStore.first.duration = 10;
   *
   * // At some point a bit later it will log 'Calculations finished', etc.
   * ```
   *
   * @event dataReady
   * @param {Gantt.model.ProjectModel} source The project
   * @param {Boolean} isInitialCommit Flag that shows if this commit is initial
   * @param {Set} records Set of all {@link Core.data.Model}s that were modified in the completed transaction.
   * Use the {@link Core.data.Model#property-modifications} property of each Model to identify
   * modified fields.
   */
  //endregion
  static get defaults() {
    return {
      /**
       * Whether to include "As soon as possible" and "As late as possible" in the list of the constraints,
       * for compatibility with the MS Project. Enabled by default.
       *
       * Note, that when enabling this option, you can not have a regular constraint on the task and ASAP/ALAP flag
       * in the same time.
       *
       * See also docs of the {@link Gantt.model.TaskModel#field-direction direction} field.
       *
       * @config {Boolean} includeAsapAlapAsConstraints
       * @default true
       */
      /**
       * If this flag is set to `true` (default) when a start/end date is set on the event, a corresponding
       * `start-no-earlier/later-than` constraint is added, automatically. This is done in order to
       * keep the event "attached" to this date, according to the user intention.
       *
       * Depending on your use case, you might want to disable this behaviour.
       *
       * @field {Boolean} addConstraintOnDateSet
       * @default true
       */
      /**
       * The number of hours per day.
       *
       * **Please note:** the value **does not define** the amount of **working** time per day
       * for that purpose one should use calendars.
       *
       * The value is used when converting the duration from one unit to another.
       * So when user enters a duration of, for example, `5 days` the system understands that it
       * actually means `120 hours` and schedules accordingly.
       * @field {Number} hoursPerDay
       * @default 24
       */
      /**
       * The number of days per week.
       *
       * **Please note:** the value **does not define** the amount of **working** time per week
       * for that purpose one should use calendars.
       *
       * The value is used when converting the duration from one unit to another.
       * So when user enters a duration of, for example, `2 weeks` the system understands that it
       * actually means `14 days` (which is then converted to {@link #field-hoursPerDay hours}) and
       * schedules accordingly.
       * @field {Number} daysPerWeek
       * @default 7
       */
      /**
       * The number of days per month.
       *
       * **Please note:** the value **does not define** the amount of **working** time per month
       * for that purpose one should use calendars.
       *
       * The value is used when converting the duration from one unit to another.
       * So when user enters a duration of, for example, `1 month` the system understands that it
       * actually means `30 days` (which is then converted to {@link #field-hoursPerDay hours}) and
       * schedules accordingly.
       * @field {Number} daysPerMonth
       * @default 30
       */
      /**
       * The source of the calendar for dependencies (the calendar used for taking dependencies lag into account).
       * Possible values are:
       *
       * - `ToEvent` - successor calendar will be used (default);
       * - `FromEvent` - predecessor calendar will be used;
       * - `Project` - the project calendar will be used.
       *
       * @field {String} dependenciesCalendar
       * @default 'ToEvent'
       */
      /**
       * The project calendar.
       * @config {String|CalendarModelConfig|Gantt.model.CalendarModel} calendar
       */
      /**
       * The project calendar.
       * @field {Gantt.model.CalendarModel} calendar
       */
      /**
       * `true` to enable automatic {@link Gantt/model/TaskModel#field-percentDone % done} calculation for summary
       * tasks, `false` to disable it.
       * @field {Boolean} autoCalculatePercentDoneForParentTasks
       * @default true
       */
      /**
       * State tracking manager instance the project relies on
       * @member {Core.data.stm.StateTrackingManager} stm
       * @category Advanced
       */
      /**
       * Configuration options to provide to the STM manager
       *
       * @config {StateTrackingManagerConfig|Core.data.stm.StateTrackingManager} stm
       * @category Advanced
       */
      /**
       * The {@link Gantt.data.TaskStore store} holding the task information.
       *
       * See also {@link Gantt.model.TaskModel}
       * @member {Gantt.data.TaskStore} eventStore
       * @category Models & Stores
       */
      /**
       * A {@link Gantt.data.TaskStore} instance or a config object.
       * @config {Gantt.data.TaskStore|Object} eventStore
       * @category Models & Stores
       */
      /**
       * An alias for the {@link #property-eventStore}.
       *
       * See also {@link Gantt.model.TaskModel}
       * @member {Gantt.data.TaskStore} taskStore
       * @category Models & Stores
       */
      /**
       * An alias for the {@link #config-eventStore}.
       * @config {Gantt.data.TaskStore|TaskStoreConfig} taskStore
       * @category Models & Stores
       */
      /**
       * The {@link Gantt.data.DependencyStore store} holding the dependency information.
       *
       * See also {@link Gantt.model.DependencyModel}
       * @member {Gantt.data.DependencyStore} dependencyStore
       * @category Models & Stores
       */
      /**
       * A {@link Gantt.data.DependencyStore} instance or a config object.
       * @config {Gantt.data.DependencyStore|DependencyStoreConfig} dependencyStore
       * @category Models & Stores
       */
      /**
       * The {@link Gantt.data.ResourceStore store} holding the resources that can be assigned to the tasks in the
       * task store.
       *
       * See also {@link Gantt.model.ResourceModel}
       * @member {Gantt.data.ResourceStore} resourceStore
       * @category Models & Stores
       */
      /**
       * A {@link Gantt.data.ResourceStore} instance or a config object.
       * @config {Gantt.data.ResourceStore|ResourceStoreConfig} resourceStore
       * @category Models & Stores
       */
      /**
       * The {@link Gantt.data.AssignmentStore store} holding the assignment information.
       *
       * See also {@link Gantt.model.AssignmentModel}
       * @member {Gantt.data.AssignmentStore} assignmentStore
       * @category Models & Stores
       */
      /**
       * An {@link Gantt.data.AssignmentStore} instance or a config object.
       * @config {Gantt.data.AssignmentStore|AssignmentStoreConfig} assignmentStore
       * @category Models & Stores
       */
      /**
       * The {@link Gantt.data.CalendarManagerStore store} holding the calendar information.
       *
       * See also {@link Gantt.model.CalendarModel}
       * @member {Gantt.data.CalendarManagerStore} calendarManagerStore
       * @category Models & Stores
       */
      /**
       * A {@link Gantt.data.CalendarManagerStore} instance or a config object.
       * @config {Gantt.data.CalendarManagerStore|CalendarManagerStoreConfig} calendarManagerStore
       * @category Models & Stores
       */
      /**
       * The {@link Core.data.Store store} containing time ranges to be visualized.
       *
       * See also {@link Scheduler.model.TimeSpan}
       * @member {Core.data.Store} timeRangeStore
       * @category Models & Stores
       */
      /**
       * Returns an array of critical paths.
       * Each _critical path_ is an array of critical path nodes.
       * Each _critical path node_ is an object which contains {@link Gantt/model/TaskModel#field-critical critical task}
       * and {@link Gantt/model/DependencyModel dependency} leading to the next critical path node.
       * Dependency is missing if it is the last critical path node in the critical path.
       * To highlight critical paths, enable {@link Gantt/feature/CriticalPaths} feature.
       *
       * ```javascript
       * // This is an example of critical paths structure
       * [
       *      // First path
       *      [
       *          {
       *              event : Gantt.model.TaskModel
       *              dependency : Gantt.model.DependencyModel
       *          },
       *          {
       *              event : Gantt.model.TaskModel
       *          }
       *      ],
       *      // Second path
       *      [
       *          {
       *              event : Gantt.model.TaskModel
       *          }
       *      ]
       *      // and so on....
       * ]
       * ```
       *
       * For more details on the _critical path method_ theory please check
       * [this article](https://en.wikipedia.org/wiki/Critical_path_method).
       *
       * @member {Array[]} criticalPaths
       * @category Scheduling
       */
      // root should be always expanded
      expanded: true
    };
  }
  static get defaultConfig() {
    return {
      projectConstraintIntervalClass: ProjectConstraintInterval,
      dateConstraintIntervalClass: DateConstraintInterval,
      dependencyConstraintIntervalClass: DependencyConstraintInterval,
      /**
       * The constructor of the event model class, to be used in the project. Will be set as the {@link Core.data.Store#config-modelClass modelClass}
       * property of the {@link #property-eventStore}
       *
       * @config {Gantt.model.TaskModel} [taskModelClass]
       * @typings {typeof TaskModel}
       * @category Models & Stores
       */
      taskModelClass: TaskModel,
      /**
       * The constructor of the dependency model class, to be used in the project. Will be set as the {@link Core.data.Store#config-modelClass modelClass}
       * property of the {@link #property-dependencyStore}
       *
       * @config {Gantt.model.DependencyModel} [dependencyModelClass]
       * @typings {typeof DependencyModel}
       * @category Models & Stores
       */
      dependencyModelClass: DependencyModel3,
      /**
       * The constructor of the resource model class, to be used in the project. Will be set as the {@link Core.data.Store#config-modelClass modelClass}
       * property of the {@link #property-resourceStore}
       *
       * @config {Gantt.model.ResourceModel} [resourceModelClass]
       * @typings {typeof ResourceModel}
       * @category Models & Stores
       */
      resourceModelClass: ResourceModel3,
      /**
       * The constructor of the assignment model class, to be used in the project. Will be set as the {@link Core.data.Store#config-modelClass modelClass}
       * property of the {@link #property-assignmentStore}
       *
       * @config {Gantt.model.AssignmentModel} [assignmentModelClass]
       * @typings {typeof AssignmentModel}
       * @category Models & Stores
       */
      assignmentModelClass: AssignmentModel3,
      /**
       * The constructor of the calendar model class, to be used in the project. Will be set as the {@link Core.data.Store#config-modelClass modelClass}
       * property of the {@link #property-calendarManagerStore}
       *
       * @config {Gantt.model.CalendarModel} [calendarModelClass]
       * @typings {typeof CalendarModel}
       * @category Models & Stores
       */
      calendarModelClass: CalendarModel2,
      /**
       * The constructor to create an task store instance with. Should be a class, subclassing the {@link Gantt.data.TaskStore}
       * @config {Gantt.data.TaskStore}
       * @typings {typeof TaskStore}
       * @category Models & Stores
       */
      taskStoreClass: TaskStore,
      /**
       * The constructor to create a dependency store instance with. Should be a class, subclassing the {@link Gantt.data.DependencyStore}
       * @config {Gantt.data.DependencyStore}
       * @typings {typeof DependencyStore}
       * @category Models & Stores
       */
      dependencyStoreClass: DependencyStore3,
      /**
       * The constructor to create a dependency store instance with. Should be a class, subclassing the {@link Gantt.data.ResourceStore}
       * @config {Gantt.data.ResourceStore}
       * @typings {typeof ResourceStore}
       * @category Models & Stores
       */
      resourceStoreClass: ResourceStore3,
      /**
       * The constructor to create a dependency store instance with. Should be a class, subclassing the {@link Gantt.data.AssignmentStore}
       * @config {Gantt.data.AssignmentStore}
       * @typings {typeof AssignmentStore}
       * @category Models & Stores
       */
      assignmentStoreClass: AssignmentStore3,
      /**
       * The constructor to create a calendar store instance with. Should be a class, subclassing the {@link Gantt.data.CalendarManagerStore}
       * @config {Gantt.data.CalendarManagerStore}
       * @typings {typeof CalendarManagerStore}
       * @category Models & Stores
       */
      calendarManagerStoreClass: CalendarManagerStore2,
      /**
       * Start date of the project in the ISO 8601 format. Setting this date will constrain all other tasks in the
       * project to start no earlier than it.
       *
       * If this date is not provided, it will be calculated as the earliest date among all tasks.
       *
       * Note that the field always returns a `Date`.
       *
       * @field {Date} startDate
       * @accepts {String|Date}
       */
      /**
       * End date of the project in the ISO 8601 format.
       * The value is calculated as the latest date among all tasks.
       *
       * Note that the field always returns a `Date`.
       *
       * @field {Date} endDate
       * @accepts {String|Date}
       */
      /**
       * The scheduling direction of the project tasks.
       * The `Forward` direction corresponds to the As-Soon-As-Possible (ASAP) scheduling,
       * `Backward` - to As-Late-As-Possible (ALAP).
       *
       * <div class="note">When using backward scheduling on the project, you should either make
       * both start and end date fields persistent on all tasks, or make both start and end date fields on
       * the project persistent. This is because for initial calculation, Gantt will need to have the project's
       * end date upfront, before performing calculations.</div>
       *
       * To set the scheduling direction of the individual tasks, use the {@link Gantt.model.TaskModel#field-direction}
       * field of the TaskModel.
       *
       * @field {'Forward'|'Backward'} direction
       * @default 'Forward'
       */
      /**
       * The initial data, to fill the {@link #property-taskStore taskStore} with.
       * Should be an array of {@link Gantt.model.TaskModel TaskModels} or configuration objects.
       *
       * @config {TaskModelConfig[]|Gantt.model.TaskModel[]}
       * @category Legacy inline data
       */
      tasksData: null,
      // What is actually used to hold initial tasks, tasksData is transformed in construct()
      /**
       * Alias to {@link #config-tasksData}.
       *
       * @config {TaskModelConfig[]|Gantt.model.TaskModel[]}
       * @category Legacy inline data
       */
      eventsData: null,
      /**
       * The initial data, to fill the {@link #property-dependencyStore dependencyStore} with.
       * Should be an array of {@link Gantt.model.DependencyModel DependencyModels} or configuration objects.
       *
       * @config {DependencyModelConfig[]|Gantt.model.DependencyModel[]}
       * @category Legacy inline data
       */
      dependenciesData: null,
      /**
       * The initial data, to fill the {@link #property-resourceStore resourceStore} with.
       * Should be an array of {@link Gantt.model.ResourceModel ResourceModels} or configuration objects.
       *
       * @config {ResourceModelConfig[]|Gantt.model.ResourceModel[]}
       * @category Legacy inline data
       */
      resourcesData: null,
      /**
       * The initial data, to fill the {@link #property-assignmentStore assignmentStore} with.
       * Should be an array of {@link Gantt.model.AssignmentModel AssignmentModels} or configuration objects.
       *
       * @config {AssignmentModelConfig[]|Gantt.model.AssignmentModel[]}
       * @category Legacy inline data
       */
      assignmentsData: null,
      /**
       * The initial data, to fill the {@link #property-calendarManagerStore calendarManagerStore} with.
       * Should be an array of {@link Gantt.model.CalendarModel CalendarModels} or configuration objects.
       *
       * @config {CalendarModelConfig[]|Gantt.model.CalendarModel[]}
       * @category Legacy inline data
       */
      calendarsData: null,
      /**
       * Store that holds time ranges (using the {@link Scheduler.model.TimeSpan} model or subclass thereof) for
       * {@link Scheduler.feature.TimeRanges} feature. A store will be automatically created if none is specified.
       * @config {StoreConfig|Core.data.Store}
       * @category Models & Stores
       */
      timeRangeStore: {
        modelClass: TimeSpan,
        storeId: "timeRanges"
      },
      /**
       * Set to `true` to reset the undo/redo queues of the internal {@link Core.data.stm.StateTrackingManager}
       * after the Project has loaded. Defaults to `false`
       * @config {Boolean} resetUndoRedoQueuesAfterLoad
       * @category Advanced
       */
      convertEmptyParentToLeaf: false,
      supportShortSyncResponseNote: 'Note: Please consider enabling "supportShortSyncResponse" option to allow less detailed sync responses (https://bryntum.com/products/gantt/docs/api/Gantt/model/ProjectModel#config-supportShortSyncResponse)',
      /**
       * Enables early rendering in Gantt, by postponing calculations to after the first refresh.
       *
       * Requires task data loaded in Gantt to be pre-normalized to function as intended, since it will be used to
       * render tasks before engine has normalized the data. Given un-normalized data tasks will snap into place
       * when calculations are finished.
       *
       * The Gantt chart will be read-only until the initial calculations are finished.
       *
       * @config {Boolean}
       * @default
       * @category Advanced
       */
      delayCalculation: true,
      eventStore: {},
      assignmentStore: {},
      resourceStore: {},
      dependencyStore: {},
      calendarManagerStore: {},
      stmClass: StateTrackingManager2
    };
  }
  static get configurable() {
    return {
      /**
       * Get/set {@link #property-taskStore} data.
       *
       * Always returns an array of {@link Gantt.model.TaskModel TaskModels} but also accepts an array of
       * its configuration objects as input.
       *
       * @member {Gantt.model.TaskModel[]} tasks
       * @accepts {Gantt.model.TaskModel[]|TaskModelConfig[]}
       * @category Inline data
       */
      /**
       * Data use to fill the {@link #property-taskStore}. Should be an array of
       * {@link Gantt.model.TaskModel TaskModels} or its configuration objects.
       *
       * @config {Gantt.model.TaskModel[]|TaskModelConfig[]}
       * @category Inline data
       */
      tasks: null,
      /**
       * Get/set {@link #property-resourceStore} data.
       *
       * Always returns an array of {@link Gantt.model.ResourceModel ResourceModels} but also accepts an array
       * of its configuration objects as input.
       *
       * @member {Gantt.model.ResourceModel[]} resources
       * @accepts {Gantt.model.ResourceModel[]|ResourceModelConfig[]}
       * @category Inline data
       */
      /**
       * Data use to fill the {@link #property-resourceStore}. Should be an array of
       * {@link Gantt.model.ResourceModel ResourceModels} or its configuration objects.
       *
       * @config {Gantt.model.ResourceModel[]|ResourceModelConfig[]}
       * @category Inline data
       */
      resources: null,
      /**
       * Get/set {@link #property-assignmentStore} data.
       *
       * Always returns an array of {@link Gantt.model.AssignmentModel AssignmentModels} but also accepts an
       * array of its configuration objects as input.
       *
       * @member {Gantt.model.AssignmentModel[]} assignments
       * @accepts {Gantt.model.AssignmentModel[]|AssignmentModelConfig[]}
       * @category Inline data
       */
      /**
       * Data use to fill the {@link #property-assignmentStore}. Should be an array of
       * {@link Gantt.model.AssignmentModel AssignmentModels} or its configuration objects.
       *
       * @config {Gantt.model.AssignmentModel[]|AssignmentModelConfig[]}
       * @category Inline data
       */
      assignments: null,
      /**
       * Get/set {@link #property-dependencyStore} data.
       *
       * Always returns an array of {@link Gantt.model.DependencyModel DependencyModels} but also accepts an
       * array of its configuration objects as input.
       *
       * @member {Gantt.model.DependencyModel[]} dependencies
       * @accepts {Gantt.model.DependencyModel[]|DependencyModelConfig[]}
       * @category Inline data
       */
      /**
       * Data use to fill the {@link #property-dependencyStore}. Should be an array of
       * {@link Gantt.model.DependencyModel DependencyModels} or its configuration objects.
       *
       * @config {Gantt.model.DependencyModel[]|DependencyModelConfig[]}
       * @category Inline data
       */
      dependencies: null,
      /**
       * Get/set {@link #property-timeRangeStore} data.
       *
       * Always returns an array of {@link Scheduler.model.TimeSpan TimeSpans} but also accepts an
       * array of its configuration objects as input.
       *
       * @member {Scheduler.model.TimeSpan[]} timeRanges
       * @accepts {Scheduler.model.TimeSpan[]|TimeSpanConfig[]}
       * @category Inline data
       */
      /**
       * Data use to fill the {@link #property-timeRangeStore}. Should be an array of
       * {@link Scheduler.model.TimeSpan TimeSpans} or its configuration objects.
       *
       * @config {Scheduler.model.TimeSpan[]|TimeSpanConfig[]}
       * @category Inline data
       */
      timeRanges: null,
      /**
       * Get/set {@link #property-calendarManagerStore} data.
       *
       * Always returns a {@link Gantt.model.CalendarModel} array but also accepts an array of its configuration
       * objects as input.
       *
       * @member {Gantt.model.CalendarModel[]} calendars
       * @accepts {Gantt.model.CalendarModel[]|CalendarModelConfig[]}
       * @category Inline data
       */
      /**
       * Data use to fill the {@link #property-calendarManagerStore}. Should be a
       * {@link Gantt.model.CalendarModel} array or its configuration objects.
       *
       * @config {Gantt.model.CalendarModel[]|CalendarModelConfig[]}
       * @category Inline data
       */
      calendars: null,
      /**
       * The initial data, to fill the {@link #property-timeRangeStore} with.
       * Should be an array of {@link Scheduler.model.TimeSpan TimeSpans} or configuration objects.
       *
       * @config {TimeSpanConfig[]|Scheduler.model.TimeSpan[]}
       * @category Legacy inline data
       */
      timeRangesData: null,
      syncDataOnLoad: null,
      /**
       * Set to `true` to make STM ignore changes coming from the backend. This will allow user to only undo redo
       * local changes.
       * @prp {Boolean}
       */
      ignoreRemoteChangesInSTM: false
    };
  }
  //endregion
  construct(...args) {
    const config = args[0] || {};
    args[0] = config;
    if ("tasksData" in config) {
      config.eventsData = config.tasksData;
      delete config.tasksData;
    }
    if ("taskStore" in config) {
      config.eventStore = config.taskStore;
      delete config.taskStore;
    }
    config.eventModelClass = config.taskModelClass || config.eventModelClass || this.getDefaultConfiguration().taskModelClass || this.defaultEventModelClass;
    config.eventStoreClass = config.taskStoreClass || config.eventStoreClass || this.getDefaultConfiguration().taskStoreClass || this.defaultEventStoreClass;
    super.construct(...args);
  }
  //region Attaching stores
  // Attach to a store, relaying its change events
  attachStore(store) {
    if (this.syncDataOnLoad) {
      store.syncDataOnLoad = this.syncDataOnLoad;
    }
    store.ion({
      name: store.$$name,
      change: "relayStoreChange",
      thisObj: this
    });
    super.attachStore(store);
  }
  // Detach a store, stop relaying its change events
  detachStore(store) {
    store && this.detachListeners(store.$$name);
    super.detachStore(store);
  }
  relayStoreChange(event) {
    super.relayStoreChange(event);
    return this.trigger("change", { store: event.source, ...event, source: this });
  }
  //endregion
  get defaultEventModelClass() {
    return TaskModel;
  }
  get defaultEventStoreClass() {
    return TaskStore;
  }
  set taskStore(store) {
    this.eventStore = store;
  }
  get taskStore() {
    return this.eventStore;
  }
  get timeRangeStore() {
    return this._timeRangeStore;
  }
  set timeRangeStore(store) {
    const me = this;
    me.detachStore(me._timeRangeStore);
    me._timeRangeStore = Store.getStore(store, Store);
    if (!me._timeRangeStore.storeId) {
      me._timeRangeStore.storeId = "timeRanges";
    }
    me.attachStore(me._timeRangeStore);
  }
  async tryInsertChild() {
    return this.tryPropagateWithChanges(() => {
      this.insertChild(...arguments);
    });
  }
  /**
   * Overrides the project owned store identifiers calculation and launches rescheduling.
   * @method setCalculations
   * @param {Object} calculations Object providing new _engine_ fields calculation function names.
   * The object is grouped by store identifiers. For example below code
   * overrides task {@link Gantt/model/TaskModel#field-startDate}, {@link Gantt/model/TaskModel#field-endDate}
   * and {@link Gantt/model/TaskModel#field-duration} calculation so
   * the fields will always simply return their current values:
   *
   * ```javascript
   * // task startDate, endDate and duration will use their userProvidedValue method
   * // which simply returns their current values as-is
   * const oldCalculations = await project.setCalculations({
   *     tasks : {
   *         startDate : "userProvidedValue",
   *         endDate   : "userProvidedValue",
   *         duration  : "userProvidedValue"
   *     }
   * })
   * ```
   * @returns {Promise} Promise that resolves with an object having the overridden calculations.
   * The object can be used to toggle the calculations back in the future:
   * ```javascript
   * // override event duration calculation
   * const oldCalculations = await project.setCalculations({
   *     events : {
   *         duration  : "userProvidedValue"
   *     }
   * })
   * // revert the duration calculation back
   * project.setCalculations(oldCalculations)
   * ```
   * @category Advanced
   */
  /**
   * Returns a calendar of the project. If task has never been assigned a calendar a project's calendar will be returned.
   *
   * @method getCalendar
   * @returns {Gantt.model.CalendarModel}
   * @category Scheduling
   */
  /**
   * Sets the calendar of the project. Will cause the schedule to be updated - returns a `Promise`
   *
   * @method setCalendar
   * @param {Gantt.model.CalendarModel} calendar The new calendar.
   * @async
   * @propagating
   * @category Scheduling
   */
  /**
   * Causes the scheduling engine to re-evaluate the task data and all associated data and constraints
   * and apply necessary changes.
   * @async
   * @function propagate
   * @propagating
   * @category Scheduling
   */
  /**
   * Suspend {@link #function-propagate propagation} processing. When propagation is suspended,
   * calls to {@link #function-propagate} do not proceed, instead a propagate call is deferred
   * until a matching {@link #function-resumePropagate} is called.
   * @function suspendPropagate
   * @category Scheduling
   */
  /**
   * Resume {@link #function-propagate propagation}. If propagation is resumed (calls may be nested
   * which increments a suspension counter), then if a call to propagate was made during suspension,
   * {@link #function-propagate} is executed.
   * @param {Boolean} [trigger] Pass `false` to inhibit automatic propagation if propagate was requested during suspension.
   * @async
   * @function resumePropagate
   * @category Scheduling
   */
  /**
   * Accepts a "data package" consisting of data for the projects stores, which is then loaded into the stores.
   *
   * The package can hold data for EventStore, AssignmentStore, ResourceStore, DependencyStore and Calendar Manager.
   * It uses the same format as when creating a project with inline data:
   *
   * ```javascript
   * await project.loadInlineData({
   *     eventsData       : [...],
   *     resourcesData    : [...],
   *     assignmentsData  : [...],
   *     dependenciesData : [...],
   *     calendarsData    : [...]
   * });
   * ```
   *
   * After populating the stores it commits the project, starting its calculations. By awaiting `loadInlineData()` you
   * can be sure that project calculations are finished.
   *
   * @function loadInlineData
   * @param {Object} dataPackage A data package as described above
   * @fires load
   * @async
   * @category Inline data
   */
  /**
   * Project changes (CRUD operations to records in its stores) are automatically committed on a buffer to the
   * underlying graph based calculation engine. The engine performs it calculations async.
   *
   * By calling this function, the commit happens right away. And by awaiting it you are sure that project
   * calculations are finished and that references between records are up to date.
   *
   * The returned promise is resolved with an object. If that object has `rejectedWith` set, there has been a conflict and the calculation failed.
   *
   * ```javascript
   * // Move a task in time
   * taskStore.first.shift(1);
   *
   * // Trigger calculations directly and wait for them to finish
   * const result = await project.commitAsync();
   *
   * if (result.rejectedWith) {
   *     // there was a conflict during the scheduling
   * }
   * ```
   *
   * @async
   * @propagating
   * @function commitAsync
   * @category Scheduling
   */
  //region JSON
  /**
   * Returns the data from the records of the projects stores, in a format that can be consumed by `loadInlineData()`.
   *
   * Used by JSON.stringify to correctly convert this record to json.
   *
   *
   * ```javascript
   * const project = new ProjectModel({
   *     eventsData       : [...],
   *     resourcesData    : [...],
   *     assignmentsData  : [...],
   *     dependenciesData : [...]
   * });
   *
   * const json = project.toJSON();
   *
   * // json:
   * {
   *     eventsData : [...],
   *     resourcesData : [...],
   *     dependenciesData : [...],
   *     assignmentsData : [...]
   * }
   * ```
   *
   * Output can be consumed by `loadInlineData()`:
   *
   * ```javascript
   * const json = project.toJSON();
   *
   * // Plug it back in later
   * project.loadInlineData(json);
   * ```
   *
   * @returns {Object}
   * @category Inline data
   */
  toJSON() {
    return {
      eventsData: this.eventStore.toJSON(),
      resourcesData: this.resourceStore.toJSON(),
      dependenciesData: this.dependencyStore.toJSON(),
      assignmentsData: this.assignmentStore.toJSON()
    };
  }
  /**
   * Get or set project data (records from its stores) as a JSON string.
   *
   * Get a JSON string:
   *
   * ```javascript
   * const project = new ProjectModel({
   *     eventsData       : [...],
   *     resourcesData    : [...],
   *     assignmentsData  : [...],
   *     dependenciesData : [...]
   * });
   *
   * const jsonString = project.json;
   *
   * // jsonString:
   * '{"eventsData":[...],"resourcesData":[...],...}'
   * ```
   *
   * Set a JSON string (to populate the project stores):
   *
   * ```javascript
   * project.json = '{"eventsData":[...],"resourcesData":[...],...}'
   * ```
   *
   * @property {String}
   * @category Inline data
   */
  get json() {
    return super.json;
  }
  set json(json) {
    if (typeof json === "string") {
      json = StringHelper.safeJsonParse(json);
    }
    this.loadInlineData(json);
  }
  //endregion
  //#region Inline data
  get tasks() {
    return this.taskStore.allRecords;
  }
  updateTasks(events) {
    this.taskStore.data = events;
  }
  get calendars() {
    return this.calendarManagerStore.allRecords;
  }
  updateCalendars(calendars) {
    this.calendarManagerStore.data = calendars;
  }
  updateTimeRangesData(ranges) {
    this.timeRangeStore.data = ranges;
  }
  /**
   * Get or set data of project stores. The returned data is identical to what
   * {@link #function-toJSON} returns:
   *
   * ```javascript
   *
   * const data = scheduler.project.inlineData;
   *
   * // data:
   * {
   *     eventsData : [...],
   *     resourcesData : [...],
   *     dependenciesData : [...],
   *     assignmentsData : [...]
   * }
   *
   *
   * // Plug it back in later
   * scheduler.project.inlineData = data;
   * ```
   *
   * @member {Object} inlineData
   * @category Inline data
   */
  get inlineData() {
    return this.toJSON();
  }
  set inlineData(inlineData) {
    this.json = inlineData;
  }
  //#endregion
  afterChange(toSet, wasSet) {
    super.afterChange(...arguments);
    if (wasSet.calendar) {
      this.trigger("calendarChange");
    }
  }
  refreshWbs(options) {
    var _a2, _b;
    const me = this, children = (_a2 = me.unfilteredChildren) != null ? _a2 : me.children;
    if (children == null ? void 0 : children.length) {
      (_b = children[0].refreshWbs) == null ? void 0 : _b.call(me, options, -1);
    }
  }
};
//region Config
__publicField(ProjectModel3, "$name", "ProjectModel");
ProjectModel3.applyConfigs = true;
ProjectModel3._$name = "ProjectModel";
export {
  AbstractAssignmentStoreMixin,
  AbstractCalendarManagerStoreMixin,
  AbstractCalendarMixin,
  AbstractCrudManager,
  AbstractCrudManagerMixin_default as AbstractCrudManagerMixin,
  AbstractCrudManagerValidation_default as AbstractCrudManagerValidation,
  AbstractDependencyStoreMixin,
  AbstractEventStoreMixin,
  AbstractHasAssignmentsMixin,
  AbstractPartOfProjectGenericMixin,
  AbstractPartOfProjectModelMixin,
  AbstractPartOfProjectStoreMixin,
  AbstractResourceStoreMixin,
  ActionBase,
  AjaxStore,
  AjaxTransport_default as AjaxTransport,
  AssignmentAllocationInterval,
  AssignmentModel3 as AssignmentModel,
  AssignmentModelMixin_default as AssignmentModelMixin,
  AssignmentStore3 as AssignmentStore,
  AssignmentStoreMixin_default as AssignmentStoreMixin,
  Base2 as Base,
  BaseAllocationInfo,
  BaseAllocationInterval,
  BaseAssignmentMixin,
  BaseCalendarMixin,
  BaseDependencyMixin,
  BaseDependencyResolution,
  BaseEmptyCalendarEffectResolution,
  BaseEventMixin,
  BaseHasAssignmentsMixin,
  BaseResourceMixin,
  Baseline,
  BreakCurrentStackExecution,
  CI,
  CIFromSetOrArrayOrValue,
  CalculateProposed,
  CalculatedValueGen,
  CalculatedValueGenC,
  CalculatedValueSync,
  CalculatedValueSyncC,
  CalculationGen,
  CalculationSync,
  CalendarCache,
  CalendarCacheInterval,
  CalendarCacheIntervalMultiple,
  CalendarCacheMultiple,
  CalendarCacheSingle,
  CalendarIntervalMixin,
  CalendarIntervalModel2 as CalendarIntervalModel,
  CalendarIntervalStore,
  CalendarIteratorResult,
  CalendarManagerStore2 as CalendarManagerStore,
  CalendarModel2 as CalendarModel,
  CanCombineCalendarsMixin,
  ChangeLogEntity,
  ChronoAbstractProjectMixin,
  ChronoAssignmentStoreMixin,
  ChronoCalendarManagerStoreMixin,
  ChronoDependencyStoreMixin,
  ChronoEventStoreMixin,
  ChronoEventTreeStoreMixin,
  Field as ChronoField,
  ChronoGraph,
  Base as ChronoMixinBase,
  ChronoModelFieldIdentifier,
  ChronoModelMixin,
  ChronoModelReferenceBucketFieldIdentifier,
  ChronoModelReferenceFieldIdentifier,
  ChronoModelReferenceFieldQuark,
  ChronoPartOfProjectGenericMixin,
  ChronoPartOfProjectModelMixin,
  ChronoPartOfProjectStoreMixin,
  ChronoResourceStoreMixin,
  ChronoStoreMixin,
  Transaction as ChronoTransaction,
  Collection,
  CollectionFilter,
  CollectionSorter,
  CommitZero,
  ComputationCycle,
  ConflictEffect,
  ConflictEffectDescription,
  ConflictResolution,
  ConflictSymbol,
  ConstrainedByParentMixin,
  ConstrainedEarlyEventMixin,
  ConstrainedLateEventMixin,
  ConstraintInterval,
  ConstraintIntervalDescription,
  ConstraintIntervalSide,
  ConstraintType,
  ContextGen,
  ContextSync,
  CoreAssignmentMixin,
  CoreAssignmentStoreMixin,
  CoreCalendarManagerStoreMixin,
  CoreCalendarMixin,
  CoreDependencyMixin,
  CoreDependencyStoreMixin,
  CoreEventMixin,
  CoreEventStoreMixin,
  CoreHasAssignmentsMixin,
  CoreHasDependenciesMixin,
  CorePartOfProjectGenericMixin,
  CorePartOfProjectModelMixin,
  CorePartOfProjectStoreMixin,
  CoreResourceMixin,
  CoreResourceStoreMixin,
  StateTrackingManager as CoreStateTrackingManager,
  CycleDescription,
  CycleEffect,
  CycleEffectDescription,
  CycleResolution,
  CycleResolutionInput,
  CycleResolutionInputChrono,
  CycleSymbol,
  DataField,
  DateConstraintInterval,
  DateConstraintIntervalDescription,
  DateInterval,
  DeactivateDependencyCycleEffectResolution,
  DeactivateDependencyResolution,
  Delayable_default as Delayable,
  DelayableWrapper2 as DelayableWrapper,
  DependenciesCalendar,
  DependencyBaseModel,
  DependencyConstraintInterval,
  DependencyConstraintIntervalDescription,
  DependencyModel3 as DependencyModel,
  DependencyStore3 as DependencyStore,
  DependencyStoreMixin_default as DependencyStoreMixin,
  DependencyType,
  DependencyValidationResult,
  Direction,
  DisableManuallyScheduledConflictResolution,
  DomClassList,
  DomDataStore,
  Duration,
  DurationConverterMixin,
  DurationVar,
  EMPTY_INTERVAL,
  EarlyLateLazyness,
  EdgeInclusion,
  EdgeType,
  EdgeTypeNormal,
  EdgeTypePast,
  Effect,
  EffectResolutionResult,
  EffortVar,
  EmptyCalendarEffect,
  EmptyCalendarEffectDescription,
  EmptyCalendarSymbol,
  EndDateVar,
  EngineReplica,
  EngineRevision,
  EngineTransaction,
  Entity,
  EntityIdentifier,
  EntityMeta,
  EventModel2 as EventModel,
  EventModelMixin_default as EventModelMixin,
  EventSegmentModel,
  EventStore2 as EventStore,
  EventStoreMixin_default as EventStoreMixin,
  Events_default as Events,
  FieldIdentifier,
  FixedDurationMixin,
  FixedEffortMixin,
  FixedUnitsMixin,
  Formula,
  FormulasCache,
  GanttEvent,
  GanttProjectMixin,
  GetEventsMixin_default as GetEventsMixin,
  GetTransaction,
  GridRowModel,
  HasCalendarMixin,
  HasChildrenMixin,
  HasCriticalPathsMixin,
  HasDateConstraintMixin,
  HasDependenciesMixin,
  HasEffortMixin,
  HasPercentDoneMixin,
  HasProposedNotPreviousValue,
  HasProposedNotPreviousValueEffect,
  HasProposedNotPreviousValueSymbol,
  HasProposedValue,
  HasProposedValueEffect,
  HasProposedValueSymbol,
  HasSchedulingModeMixin,
  HasSubEventsMixin,
  Identifier,
  IdentifierC,
  IndexPosition,
  Instruction,
  IntervalCache,
  IsChronoModelSymbol,
  JsonEncoder_default as JsonEncoder,
  Levels,
  Listener,
  MAX_DATE,
  MI,
  MIN_DATE,
  ManuallyScheduledParentConstraintInterval,
  ManuallyScheduledParentConstraintIntervalDescription,
  Meta,
  MinimalChronoModelFieldIdentifierGen,
  MinimalChronoModelFieldIdentifierSync,
  MinimalChronoModelFieldVariable,
  MinimalEntityIdentifier,
  MinimalFieldIdentifierGen,
  MinimalFieldIdentifierSync,
  MinimalFieldVariable,
  MinimalReferenceBucketIdentifier,
  MinimalReferenceBucketQuark,
  MinimalReferenceIdentifier,
  Model,
  ModelBucketField,
  ModelField,
  ModelLink_default as ModelLink,
  ModelReferenceField,
  ModelStm_default as ModelStm,
  NOT_VISITED,
  OnCycleAction,
  OwnIdentifier,
  OwnIdentifierSymbol,
  OwnQuark,
  OwnQuarkSymbol,
  PartOfProject_default2 as PartOfProject,
  PercentDoneMixin_default as PercentDoneMixin,
  PreviousValueOf,
  PreviousValueOfEffect,
  PreviousValueOfSymbol,
  ProjectChangeHandlerMixin_default as ProjectChangeHandlerMixin,
  ProjectConstraintInterval,
  ProjectConstraintIntervalDescription,
  ProjectCrudManager_default2 as ProjectCrudManager,
  ProjectModel3 as ProjectModel,
  ProjectModelMixin_default as ProjectModelMixin,
  ProjectModelTimeZoneMixin_default as ProjectModelTimeZoneMixin,
  ProjectType,
  ProposedArgumentsOf,
  ProposedArgumentsOfEffect,
  ProposedArgumentsOfSymbol,
  ProposedOrPrevious,
  ProposedOrPreviousSymbol,
  ProposedOrPreviousValueOf,
  ProposedOrPreviousValueOfEffect,
  ProposedOrPreviousValueOfSymbol,
  ProposedValueOf,
  ProposedValueOfEffect,
  ProposedValueOfSymbol,
  Quark,
  QuarkGen,
  QuarkSync,
  ReadMode,
  RecurrenceModel,
  RecurringEventsMixin_default as RecurringEventsMixin,
  RecurringTimeSpan_default as RecurringTimeSpan,
  RecurringTimeSpansMixin_default as RecurringTimeSpansMixin,
  ReferenceBucketField,
  ReferenceBucketIdentifier,
  ReferenceBucketQuark,
  ReferenceField,
  ReferenceIdentifier,
  Reject,
  RejectEffect,
  RejectSymbol,
  RemoveDateConstraintConflictResolution,
  RemoveDependencyCycleEffectResolution,
  RemoveDependencyResolution,
  Replica,
  ResourceAllocationEventRangeCalendar,
  ResourceAllocationEventRangeCalendarIntervalMixin,
  ResourceAllocationEventRangeCalendarIntervalStore,
  ResourceAllocationInfo,
  ResourceAllocationInterval,
  ResourceModel3 as ResourceModel,
  ResourceModelMixin_default as ResourceModelMixin,
  ResourceStore3 as ResourceStore,
  ResourceStoreMixin_default as ResourceStoreMixin,
  ResourceTimeRangeModel,
  ResourceTimeRangeStore,
  Revision,
  SEDBackwardCycleResolutionContext,
  SEDDispatcher,
  SEDDispatcherIdentifier,
  SEDForwardCycleResolutionContext,
  SEDGraphDescription,
  SEDWUDispatcher,
  SEDWUDispatcherIdentifier,
  ScheduledByDependenciesEarlyEventMixin,
  ScheduledByDependenciesLateEventMixin,
  AssignmentModel as SchedulerAssignmentModel,
  AssignmentStore as SchedulerAssignmentStore,
  SchedulerBasicEvent,
  SchedulerBasicProjectMixin,
  SchedulerCoreEvent,
  SchedulerCoreProjectMixin,
  DependencyModel as SchedulerDependencyModel,
  DependencyStore as SchedulerDependencyStore,
  EventModel as SchedulerEventModel,
  EventStore as SchedulerEventStore,
  PartOfProject_default as SchedulerPartOfProject,
  SchedulerProAssignmentMixin,
  AssignmentModel2 as SchedulerProAssignmentModel,
  AssignmentStore2 as SchedulerProAssignmentStore,
  CalendarIntervalModel as SchedulerProCalendarIntervalModel,
  CalendarManagerStore as SchedulerProCalendarManagerStore,
  CalendarModel as SchedulerProCalendarModel,
  SchedulerProCycleEffect,
  SchedulerProDependencyMixin,
  DependencyModel2 as SchedulerProDependencyModel,
  DependencyStore2 as SchedulerProDependencyStore,
  SchedulerProEvent,
  SchedulerProHasAssignmentsMixin,
  SchedulerProProjectMixin,
  ProjectModel2 as SchedulerProProjectModel,
  SchedulerProResourceMixin,
  ResourceModel2 as SchedulerProResourceModel,
  ResourceStore2 as SchedulerProResourceStore,
  ProjectCrudManager_default as SchedulerProjectCrudManager,
  ProjectModel as SchedulerProjectModel,
  ResourceModel as SchedulerResourceModel,
  ResourceStore as SchedulerResourceStore,
  SchedulingIssueEffectResolution,
  SchedulingMode,
  Schema,
  SortedMap,
  StartDateVar,
  StateBase,
  StateTrackingManager,
  Store,
  StoreCRUD_default as StoreCRUD,
  StoreChained_default as StoreChained,
  StoreChanges_default as StoreChanges,
  StoreFilter_default as StoreFilter,
  StoreGroup_default as StoreGroup,
  StoreRelation_default as StoreRelation,
  StoreSearch_default as StoreSearch,
  StoreSort_default as StoreSort,
  StoreState_default as StoreState,
  StoreStm_default as StoreStm,
  StoreSum_default as StoreSum,
  StoreSync_default as StoreSync,
  StoreTree_default as StoreTree,
  SynchronousCalculationStarted,
  TaskModel,
  TaskStore,
  TimeSpan,
  TimeUnit,
  TimeZonedDatesMixin_default as TimeZonedDatesMixin,
  TombStone,
  Transaction2 as Transaction,
  TransactionCycleDetectionWalkContext,
  TransactionSymbol,
  TransactionWalkDepth,
  TreeNode_default as TreeNode,
  UnitsVar,
  UnsafePreviousValueOf,
  UnsafePreviousValueOfEffect,
  UnsafePreviousValueOfSymbol,
  UnsafeProposedOrPreviousValueOf,
  UnsafeProposedOrPreviousValueOfEffect,
  UnsafeProposedOrPreviousValueOfSymbol,
  UnspecifiedTimeIntervalModel,
  Use24hrsEmptyCalendarEffectResolution,
  Use8hrsEmptyCalendarEffectResolution,
  VISITED_TOPOLOGICALLY,
  Variable,
  VariableC,
  VariableInputState,
  VariableWalkContext,
  WalkContext,
  WalkSource,
  WalkState,
  Wbs,
  WbsField,
  Write,
  WriteEffect,
  WriteSeveral,
  WriteSeveralEffect,
  WriteSeveralSymbol,
  WriteSymbol,
  binarySearch,
  bucket,
  build_proposed,
  calculate,
  calculateEffectiveEndDateConstraintInterval,
  calculateEffectiveStartDateConstraintInterval,
  combineCalendars,
  createEntityOnPrototype,
  cycleInfo,
  dateConverter,
  delay2 as delay,
  durationFormula,
  effortFormula,
  endDateByEffortFormula,
  endDateFormula,
  ensureEntityOnPrototype,
  entity,
  entityDecoratorBody,
  field,
  fixedDurationAndEffortSEDWUGraphDescription,
  fixedDurationSEDWUBackwardEffortDriven,
  fixedDurationSEDWUBackwardNonEffortDriven,
  fixedDurationSEDWUForwardEffortDriven,
  fixedDurationSEDWUForwardNonEffortDriven,
  fixedDurationSEDWUGraphDescription,
  fixedEffortSEDWUBackward,
  fixedEffortSEDWUForward,
  fixedEffortSEDWUGraphDescription,
  fixedUnitsSEDWUBackwardEffortDriven,
  fixedUnitsSEDWUBackwardNonEffortDriven,
  fixedUnitsSEDWUForwardEffortDriven,
  fixedUnitsSEDWUForwardNonEffortDriven,
  fixedUnitsSEDWUGraphDescription,
  format,
  generic_field,
  getDecoratedModelFields,
  injectStaticFieldsProperty,
  intersectIntervals,
  isAtomicValue,
  isDateFinite,
  isEqualEffectiveDirection,
  isNotNumber,
  isSerializableEqual,
  later,
  model_field,
  prototypeValue,
  reference,
  required,
  runGeneratorAsyncWithEffect,
  runGeneratorSyncWithEffect,
  startDateByEffortFormula,
  startDateFormula,
  stripDuplicates,
  throwUnknownIdentifier,
  unitsFormula,
  validateRequiredProperties,
  write
};
//# sourceMappingURL=gantt.node.mjs.map
