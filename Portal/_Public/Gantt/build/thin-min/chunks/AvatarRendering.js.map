{
  "version": 3,
  "sources": ["../../../../Core/lib/Core/data/stm/action/ActionBase.js", "../../../../Core/lib/Core/data/stm/state/StateBase.js", "../../../../Core/lib/Core/data/stm/Props.js", "../../../../Core/lib/Core/data/stm/state/Registry.js", "../../../../Core/lib/Core/data/stm/Helpers.js", "../../../../Core/lib/Core/data/stm/state/DisabledState.js", "../../../../Core/lib/Core/data/stm/Transaction.js", "../../../../Core/lib/Core/data/stm/state/ReadyState.js", "../../../../Core/lib/Core/data/stm/state/RecordingState.js", "../../../../Core/lib/Core/data/stm/state/RestoringState.js", "../../../../Core/lib/Core/data/stm/state/AutoReadyState.js", "../../../../Core/lib/Core/data/stm/state/AutoRecordingState.js", "../../../../Core/lib/Core/data/stm/action/UpdateAction.js", "../../../../Core/lib/Core/data/stm/action/InsertChildAction.js", "../../../../Core/lib/Core/data/stm/action/RemoveChildAction.js", "../../../../Core/lib/Core/data/stm/action/AddAction.js", "../../../../Core/lib/Core/data/stm/action/InsertAction.js", "../../../../Core/lib/Core/data/stm/action/RemoveAction.js", "../../../../Core/lib/Core/data/stm/action/RemoveAllAction.js", "../../../../Core/lib/Core/data/stm/StateTrackingManager.js", "../../../../Core/lib/Core/mixin/Finalizable.js", "../../../../Core/lib/Core/util/drag/DragContext.js", "../../../../Core/lib/Core/util/drag/DragProxy.js", "../../../../Core/lib/Core/mixin/Draggable.js", "../../../../Core/lib/Core/mixin/Droppable.js", "../../../../Core/lib/Core/widget/ColorField.js", "../../../../Core/lib/Core/widget/SlideToggle.js", "../../../../Core/lib/Core/widget/util/AvatarRendering.js"],
  "sourcesContent": ["/**\n * @module Core/data/stm/action/ActionBase\n */\nimport Base from '../../../Base.js';\n\nconst throwAbstractMethodCall = () => {\n    throw new Error('Abstract method call!');\n};\n\n/**\n * Base class for STM actions.\n *\n * @abstract\n */\nexport default class ActionBase extends Base {\n\n    /**\n     * Gets the type of the action (stringified class name).\n     * @readonly\n     * @property {String}\n     */\n    get type() {\n        return this.constructor.name;\n    }\n\n    /**\n     * Undoes an action\n     */\n    undo() {\n        throwAbstractMethodCall();\n    }\n\n    /**\n     * Redoes an action\n     */\n    redo() {\n        throwAbstractMethodCall();\n    }\n}\n", "/**\n * @module Core/data/stm/state/StateBase\n */\nimport Base from '../../../Base.js';\n\nexport const throwAbstractMethodCall = () => {\n    throw new Error('Abstract method call!');\n};\n\nexport const throwInvalidMethodCall = () => {\n    throw new Error('Method cannot be called at this state!');\n};\n\n/**\n * Abstract class for STM states\n *\n * Every on* method should return a state for the STM which it should switch to\n * or throw an exception that this call at this state is illegal.\n *\n * Interface of this class mirrors interface of {@link Core.data.stm.StateTrackingManager}.\n *\n * @abstract\n */\nexport default class StateBase extends Base {\n\n    canUndo(stm) {\n        throwAbstractMethodCall();\n    }\n\n    canRedo(stm) {\n        throwAbstractMethodCall();\n    }\n\n    onUndo(stm) {\n        throwAbstractMethodCall();\n    }\n\n    onRedo(stm) {\n        throwAbstractMethodCall();\n    }\n\n    onStartTransaction(stm) {\n        throwAbstractMethodCall();\n    }\n\n    onStopTransaction(stm) {\n        throwAbstractMethodCall();\n    }\n\n    onStopTransactionDelayed(stm) {\n        throwAbstractMethodCall();\n    }\n\n    onRejectTransaction(stm) {\n        throwAbstractMethodCall();\n    }\n\n    onEnable(stm) {\n        throwAbstractMethodCall();\n    }\n\n    onDisable(stm) {\n        throwAbstractMethodCall();\n    }\n\n    onAutoRecordOn(stm) {\n        throwAbstractMethodCall();\n    }\n\n    onAutoRecordOff(stm) {\n        throwAbstractMethodCall();\n    }\n\n    onResetQueue(stm) {\n        throwAbstractMethodCall();\n    }\n\n    onModelUpdate(stm) {\n        throwAbstractMethodCall();\n    }\n\n    onStoreModelAdd(stm) {\n        throwAbstractMethodCall();\n    }\n\n    onStoreModelInsert(stm) {\n        throwAbstractMethodCall();\n    }\n\n    onStoreModelRemove(stm) {\n        throwAbstractMethodCall();\n    }\n\n    onStoreModelRemoveAll(stm) {\n        throwAbstractMethodCall();\n    }\n\n    onModelInsertChild(stm) {\n        throwAbstractMethodCall();\n    }\n\n    onModelRemoveChild(stm) {\n        throwAbstractMethodCall();\n    }\n}\n", "/**\n * @module Core/data/stm/Props.js\n * @internal\n */\n\nexport const STATE_PROP             = Symbol('STATE_PROP');\nexport const STORES_PROP            = Symbol('STORES_PROP');\nexport const QUEUE_PROP             = Symbol('QUEUE_PROP');\nexport const POS_PROP               = Symbol('POS_PROP');\nexport const TRANSACTION_PROP       = Symbol('TRANSACTION_PROP');\nexport const TRANSACTION_TIMER_PROP = Symbol('TRANSACTION_TIMER_PROP');\nexport const AUTO_RECORD_PROP       = Symbol('AUTO_RECORD_PROP');\nexport const IS_APPLYING_STASH      = Symbol('IS_APPLYING_STASH');\nexport const PROPS                  = Object.freeze([\n    STATE_PROP,\n    STORES_PROP,\n    QUEUE_PROP,\n    POS_PROP,\n    TRANSACTION_PROP,\n    TRANSACTION_TIMER_PROP,\n    AUTO_RECORD_PROP,\n    IS_APPLYING_STASH\n]);\n", "import StateBase from './StateBase.js';\n\n/**\n * @module Core/data/stm/state/Registry\n *\n * Provides map of registered STM states.\n *\n * Needed to remove states circular dependency.\n *\n * @internal\n */\nconst registry = new Map();\n\n/**\n * Registers STM state class with the given name.\n *\n * @private\n *\n * @param {String} name\n * @param {Core.data.stm.state.StateBase} state\n */\nexport const registerStmState = (name, state) => {\n    //<debug>\n    console.assert(\n        state instanceof StateBase,\n        `Can't register STM state ${name}, invalid state class provided!`\n    );\n    //</debug>\n\n    registry.set(name, state);\n};\n\n/**\n * Resolves STM state class with the given name.\n *\n * @private\n *\n * @param {String} name\n * @returns {Core.data.stm.state.StateBase} state\n */\nexport const resolveStmState = (state) => {\n    if (typeof state === 'string') {\n        state = registry.get(state);\n    }\n\n    //<debug>\n    console.assert(\n        state instanceof StateBase,\n        `Can't resolve STM state ${state}, state class hasn't been registered!`\n    );\n    //</debug>\n\n    return state;\n};\n\n// UMD/module compatible export\n// NOTE: the most compatible way of exporting is:\n//       import registry from './Registry.js';\n//       { registerStmState, resolveStmState } = registry;\n//          or\n//       registry.registerStmState(...);\nexport default {\n    registerStmState,\n    resolveStmState\n};\n", "import { QUEUE_PROP, POS_PROP } from './Props.js';\n\nexport const resetQueue = (stm, options) => {\n    const { undo, redo } = options;\n\n    let newProps;\n\n    if (undo && !redo) {\n        newProps = {\n            [QUEUE_PROP] : stm[QUEUE_PROP].slice(stm.position),\n            [POS_PROP]   : 0\n        };\n    }\n    else if (redo && !undo) {\n        newProps = {\n            [QUEUE_PROP] : stm[QUEUE_PROP].slice(0, stm.position)\n        };\n    }\n    else {\n        newProps = {\n            [QUEUE_PROP] : [],\n            [POS_PROP]   : 0\n        };\n    };\n\n    return [\n        newProps,\n        () => {\n            stm.notifyStoresAboutQueueReset(options);\n        }\n    ];\n};\n", "/**\n * @module Core/data/stm/state/DisabledState\n */\nimport StateBase, { throwInvalidMethodCall } from './StateBase.js';\nimport { AUTO_RECORD_PROP } from '../Props.js';\nimport Registry from './Registry.js';\nimport { resetQueue } from '../Helpers.js';\n\n/**\n * STM disabled state class.\n *\n * @internal\n */\nexport class DisabledStateClass extends StateBase {\n\n    canUndo() {\n        return false;\n    }\n\n    canRedo() {\n        return false;\n    }\n\n    onUndo() {\n        throwInvalidMethodCall();\n    }\n\n    onRedo() {\n        throwInvalidMethodCall();\n    }\n\n    onEnable(stm) {\n        return stm.autoRecord ? 'autoreadystate' : 'readystate';\n    }\n\n    onDisable() {\n        throwInvalidMethodCall();\n    }\n\n    onAutoRecordOn() {\n        return {\n            [AUTO_RECORD_PROP] : true\n        };\n    }\n\n    onAutoRecordOff() {\n        return {\n            [AUTO_RECORD_PROP] : false\n        };\n    }\n\n    onStartTransaction() {\n        throwInvalidMethodCall();\n    }\n\n    onStopTransaction()  {\n        throwInvalidMethodCall();\n    }\n\n    onStopTransactionDelayed() {\n        throwInvalidMethodCall();\n    }\n\n    onRejectTransaction() {\n        throwInvalidMethodCall();\n    }\n\n    onResetQueue(stm, options) {\n        return resetQueue(stm, options);\n    }\n\n    onModelUpdate()      {}\n    onModelInsertChild() {}\n    onModelRemoveChild() {}\n    onStoreModelAdd()    {}\n    onStoreModelInsert() {}\n    onStoreModelRemove() {}\n    onStoreRemoveAll()   {}\n}\n\n/**\n * STM disabled state.\n *\n * @internal\n */\nconst DisabledState = new DisabledStateClass();\nexport default DisabledState;\n\nRegistry.registerStmState('disabledstate', DisabledState);\n", "/**\n * @module Core/data/stm/Transaction\n */\nimport Base from '../../Base.js';\n\nconst ACTION_QUEUE_PROP = Symbol('ACTION_QUEUE_PROP');\n\n/**\n * STM transaction class, holds list of actions constituting a transaction.\n *\n * A transaction can be undone and redone. Upon undo all the actions being held\n * are undone in reverse order. Upon redo all the actions being held are redone\n * in forward order.\n */\nexport default class Transaction extends Base {\n\n    get defaultConfig() {\n        return {\n            /**\n             * Transaction title\n             *\n             * @config {String}\n             */\n            title : null\n        };\n    }\n\n    construct(...args) {\n        this[ACTION_QUEUE_PROP] = [];\n\n        super.construct(...args);\n    }\n\n    /**\n     * Gets transaction's actions queue\n     *\n     * @property {Core.data.stm.action.ActionBase[]}\n     */\n    get queue() {\n        return this[ACTION_QUEUE_PROP].slice(0);\n    }\n\n    /**\n     * Gets transaction's actions queue length\n     *\n     * @property {Number}\n     */\n    get length() {\n        return this[ACTION_QUEUE_PROP].length;\n    }\n\n    /**\n     * Adds an action to the transaction.\n     *\n     * @param {Core.data.stm.action.ActionBase|Object} action\n     */\n    addAction(action) {\n        //<debug>\n        console.assert(\n            action && typeof action.undo == 'function' && typeof action.redo == 'function',\n            \"Can't add action to a STM transaction, action must have `undo` and `redo` methods, inheriting from `ActionBase` might help!\"\n        );\n        //</debug>\n\n        this[ACTION_QUEUE_PROP].push(action);\n    }\n\n    /**\n     * Undoes actions held\n     */\n    undo() {\n        const queue = this[ACTION_QUEUE_PROP];\n\n        for (let i = queue.length - 1; i >= 0; --i) {\n            queue[i].undo();\n        }\n    }\n\n    /**\n     * Redoes actions held\n     */\n    redo() {\n        const queue = this[ACTION_QUEUE_PROP];\n\n        for (let i = 0, len = queue.length; i < len; ++i) {\n            queue[i].redo();\n        }\n    }\n}\n", "import StateBase, { throwInvalidMethodCall } from './StateBase.js';\nimport Transaction from '../Transaction.js';\nimport { STATE_PROP, QUEUE_PROP, POS_PROP, TRANSACTION_PROP, AUTO_RECORD_PROP } from '../Props.js';\nimport Registry from './Registry.js';\nimport { resetQueue } from '../Helpers.js';\n\n/**\n * @module Core/data/stm/state/ReadyState\n */\n\n/**\n * STM ready state class.\n *\n * @internal\n */\nexport class ReadyStateClass extends StateBase {\n\n    canUndo(stm) {\n        //      v\n        // |*|*|\n        return 0 < stm.position && stm.position <= stm.length;\n    }\n\n    canRedo(stm) {\n        //  v\n        // |*|*|\n        return 0 <= stm.position && stm.position < stm.length;\n    }\n\n    onUndo(stm, steps) {\n        let curPos = stm.position;\n\n        const\n            queue  = stm[QUEUE_PROP],\n            newPos = Math.max(0, curPos - steps),\n            next = () => {\n                stm.notifyStoresAboutStateRestoringStart();\n\n                const undoneTransactions = [];\n                while (curPos !== newPos) {\n                    const transaction = queue[--curPos];\n                    transaction.undo();\n                    undoneTransactions.push(transaction);\n                }\n\n                return [stm.autoRecord ? 'autoreadystate' : 'readystate', () => {\n                    stm.notifyStoresAboutStateRestoringStop({ cause : 'undo', transactions : undoneTransactions });\n                }];\n            };\n\n        return [{\n            [STATE_PROP] : 'restoringstate',\n            [POS_PROP]   : newPos\n        }, next];\n    }\n\n    onRedo(stm, steps) {\n        let curPos = stm.position;\n\n        const\n            queue  = stm[QUEUE_PROP],\n            newPos = Math.min(queue.length, curPos + steps);\n\n        const next = () => {\n            stm.notifyStoresAboutStateRestoringStart();\n\n            const redoneTransactions = [];\n            do {\n                const transaction = queue[curPos++];\n                transaction.redo();\n                redoneTransactions.push(transaction);\n            }\n            while (curPos !== newPos);\n\n            return [stm.autoRecord ? 'autoreadystate' : 'readystate', () => {\n                stm.notifyStoresAboutStateRestoringStop({ cause : 'redo', transactions : redoneTransactions });\n            }];\n        };\n\n        return [{\n            [STATE_PROP] : 'restoringstate',\n            [POS_PROP]   : newPos\n        }, next];\n    }\n\n    onEnable() {\n        throwInvalidMethodCall();\n    }\n\n    onDisable() {\n        return 'disabledstate';\n    }\n\n    onAutoRecordOn() {\n        return {\n            [STATE_PROP]       : 'autoreadystate',\n            [AUTO_RECORD_PROP] : true\n        };\n    }\n\n    onAutoRecordOff() {\n        throwInvalidMethodCall();\n    }\n\n    onStartTransaction(stm, title) {\n        const transaction = new Transaction({ title });\n\n        return [{\n            [STATE_PROP]       : 'recordingstate',\n            [TRANSACTION_PROP] : transaction\n        }, () => {\n            stm.notifyStoresAboutStateRecordingStart(transaction);\n        }];\n    }\n\n    onStopTransaction() {\n        throwInvalidMethodCall();\n    }\n\n    onStopTransactionDelayed() {\n        throwInvalidMethodCall();\n    }\n\n    onRejectTransaction() {\n        throwInvalidMethodCall();\n    }\n\n    onResetQueue(stm, options) {\n        return resetQueue(stm, options);\n    }\n\n    onModelUpdate()      {}\n    onModelInsertChild() {}\n    onModelRemoveChild() {}\n    onStoreModelAdd()    {}\n    onStoreModelInsert() {}\n    onStoreModelRemove() {}\n    onStoreRemoveAll()   {}\n}\n\n/**\n * STM ready state.\n *\n * @internal\n */\nconst ReadyState = new ReadyStateClass();\nexport default ReadyState;\n\nRegistry.registerStmState('readystate', ReadyState);\n", "/**\n * @module Core/data/stm/state/RecordingState\n */\nimport StateBase, { throwInvalidMethodCall } from './StateBase.js';\nimport { STATE_PROP, TRANSACTION_PROP, QUEUE_PROP, POS_PROP, AUTO_RECORD_PROP } from '../Props.js';\nimport Registry from './Registry.js';\nimport { resetQueue } from '../Helpers.js';\n\n/**\n * STM recording state class.\n *\n * @internal\n */\nexport class RecordingStateClass extends StateBase {\n\n    canUndo() {\n        return false;\n    }\n\n    canRedo() {\n        return false;\n    }\n\n    onEnable() {}\n\n    onDisable(stm) {\n        const transaction = stm[TRANSACTION_PROP];\n\n        stm.notifyStoresAboutStateRecordingStop(transaction, { disabled : true });\n\n        return {\n            [STATE_PROP]       : 'disabledstate',\n            [TRANSACTION_PROP] : null\n        };\n    }\n\n    onAutoRecordOn(stm) {\n        return [{\n            [STATE_PROP]       : 'autorecordingstate',\n            [AUTO_RECORD_PROP] : true\n        }, () => {\n            stm.stopTransactionDelayed();\n        }];\n    }\n\n    onAutoRecordOff() {\n        throwInvalidMethodCall();\n    }\n\n    onStartTransaction() {\n        throwInvalidMethodCall();\n    }\n\n    onStopTransaction(stm, title) {\n        const\n            transaction = stm[TRANSACTION_PROP],\n            queue       = stm[QUEUE_PROP];\n\n        let position = stm[POS_PROP];\n\n        if (transaction.length) {\n\n            if (!transaction.title && !title && stm.getTransactionTitle) {\n                transaction.title = stm.getTransactionTitle(transaction);\n            }\n            else if (title) {\n                transaction.title = title;\n            }\n\n            queue[position] = transaction;\n            queue.length    = ++position;\n        }\n\n        return [{\n            [STATE_PROP]       : 'readystate',\n            [POS_PROP]         : position,\n            [TRANSACTION_PROP] : null\n        }, () => {\n            stm.notifyStoresAboutStateRecordingStop(transaction, { stop : true });\n        }];\n    }\n\n    onRejectTransaction(stm) {\n        const transaction = stm[TRANSACTION_PROP];\n\n        return [{\n            [STATE_PROP]       : 'restoringstate',\n            [TRANSACTION_PROP] : null\n        }, () => {\n\n            if (transaction.length) {\n                transaction.undo();\n            }\n\n            return [\n                'readystate',\n                () => {\n                    stm.notifyStoresAboutStateRecordingStop(transaction, { rejected : true });\n                }\n            ];\n        }];\n    }\n\n    onStopTransactionDelayed() {\n        throwInvalidMethodCall();\n    }\n\n    onResetQueue(stm, options) {\n        return resetQueue(stm, options);\n    }\n\n    onModelUpdate(stm, model, newData, oldData, isInitialUserAction) {\n        const transaction = stm[TRANSACTION_PROP];\n        transaction.addAction(stm.makeModelUpdateAction(model, newData, oldData, isInitialUserAction));\n    }\n\n    onModelInsertChild(stm, parentModel, index, childModel, previousParent, previousIndex) {\n        const transaction = stm[TRANSACTION_PROP];\n        transaction.addAction(stm.makeModelInsertChildAction(parentModel, index, childModel, previousParent, previousIndex));\n    }\n\n    onModelRemoveChild(stm, parentModel, childModels, context) {\n        const transaction = stm[TRANSACTION_PROP];\n        transaction.addAction(stm.makeModelRemoveChildAction(parentModel, childModels, context));\n    }\n\n    onStoreModelAdd(stm, store, models, silent)    {\n        const transaction = stm[TRANSACTION_PROP];\n        transaction.addAction(stm.makeStoreModelAddAction(store, models, silent));\n    }\n\n    onStoreModelInsert(stm, store, index, models, context, silent) {\n        const transaction = stm[TRANSACTION_PROP];\n        transaction.addAction(stm.makeStoreModelInsertAction(store, index, models, context, silent));\n    }\n\n    onStoreModelRemove(stm, store, models, context, silent) {\n        const transaction = stm[TRANSACTION_PROP];\n        transaction.addAction(stm.makeStoreModelRemoveAction(store, models, context, silent));\n    }\n\n    onStoreRemoveAll(stm, store, allRecords, silent)   {\n        const transaction = stm[TRANSACTION_PROP];\n        transaction.addAction(stm.makeStoreRemoveAllAction(store, allRecords, silent));\n    }\n}\n\n/**\n * STM recording state.\n *\n * @internal\n */\nconst RecordingState = new RecordingStateClass();\nexport default RecordingState;\n\nRegistry.registerStmState('recordingstate', RecordingState);\n", "/**\n * @module Core/data/stm/state/RestoringState\n */\nimport StateBase, { throwInvalidMethodCall } from './StateBase.js';\nimport { AUTO_RECORD_PROP } from '../Props.js';\nimport Registry from './Registry.js';\n\n/**\n * STM restoring state class.\n *\n * @internal\n */\nexport class RestoringStateClass extends StateBase {\n    static get $name() {\n        return 'RestoringStateClass';\n    }\n\n    canUndo() {\n        return false;\n    }\n\n    canRedo() {\n        return false;\n    }\n\n    onUndo() {\n        throwInvalidMethodCall();\n    }\n\n    onRedo() {\n        throwInvalidMethodCall();\n    }\n\n    onEnable() {\n        throwInvalidMethodCall();\n    }\n\n    onDisable() {\n        throwInvalidMethodCall();\n    }\n\n    onAutoRecordOn() {\n        return {\n            [AUTO_RECORD_PROP] : true\n        };\n    }\n\n    onAutoRecordOff() {\n        return {\n            [AUTO_RECORD_PROP] : false\n        };\n    }\n\n    onStartTransaction() {\n        throwInvalidMethodCall();\n    }\n\n    onStopTransaction()  {\n        throwInvalidMethodCall();\n    }\n\n    onStopTransactionDelayed() {\n        throwInvalidMethodCall();\n    }\n\n    onRejectTransaction() {\n        throwInvalidMethodCall();\n    }\n\n    onQueueReset() {\n        throwInvalidMethodCall();\n    }\n\n    onModelUpdate()      {}\n    onModelInsertChild() {}\n    onModelRemoveChild() {}\n    onStoreModelAdd()    {}\n    onStoreModelInsert() {}\n    onStoreModelRemove() {}\n    onStoreRemoveAll()   {}\n}\n\n/**\n * STM restoring state.\n *\n * @internal\n */\nconst RestoringState = new RestoringStateClass();\nexport default RestoringState;\n\nRegistry.registerStmState('restoringstate', RestoringState);\n", "import { throwInvalidMethodCall } from './StateBase.js';\nimport Transaction from '../Transaction.js';\nimport { ReadyStateClass } from './ReadyState.js';\nimport { STATE_PROP, TRANSACTION_PROP, AUTO_RECORD_PROP } from '../Props.js';\nimport Registry from './Registry.js';\n\n/**\n * @module Core/data/stm/state/AutoReadyState\n */\n\n/**\n * STM transaction autostart ready state class.\n *\n * @internal\n */\nexport class AutoReadyStateClass extends ReadyStateClass {\n\n    onAutoRecordOn() {\n        throwInvalidMethodCall();\n    }\n\n    onAutoRecordOff() {\n        return {\n            [STATE_PROP]       : 'readystate',\n            [AUTO_RECORD_PROP] : false\n        };\n    }\n\n    onStartTransaction(stm, title) {\n        const transaction = new Transaction({ title });\n\n        return [{\n            [STATE_PROP]       : 'autorecordingstate',\n            [TRANSACTION_PROP] : transaction\n        }, () => {\n            stm.notifyStoresAboutStateRecordingStart(transaction);\n            stm.stopTransactionDelayed();\n        }];\n    }\n\n    onModelUpdate(stm, model, newData, oldData) {\n        stm.startTransaction();\n        stm.onModelUpdate(model, newData, oldData);\n    }\n\n    onModelInsertChild(stm, parentModel, index, childModels, context) {\n        stm.startTransaction();\n        stm.onModelInsertChild(parentModel, index, childModels, context);\n    }\n\n    onModelRemoveChild(stm, parentModel, childModels, context) {\n        stm.startTransaction();\n        stm.onModelRemoveChild(parentModel, childModels, context);\n    }\n\n    onStoreModelAdd(stm, store, models, silent) {\n        stm.startTransaction();\n        stm.onStoreModelAdd(store, models, silent);\n    }\n\n    onStoreModelInsert(stm, store, index, models, context, silent) {\n        stm.startTransaction();\n        stm.onStoreModelInsert(store, index, models, context, silent);\n    }\n\n    onStoreModelRemove(stm, store, models, context, silent) {\n        stm.startTransaction();\n        stm.onStoreModelRemove(store, models, context, silent);\n    }\n\n    onStoreRemoveAll(stm, store, allRecords, silent) {\n        stm.startTransaction();\n        stm.onStoreRemoveAll(store, allRecords, silent);\n    }\n}\n\n/**\n * STM transaction autostart ready state.\n *\n * @internal\n */\nconst AutoReadyState = new AutoReadyStateClass();\nexport default AutoReadyState;\n\nRegistry.registerStmState('autoreadystate', AutoReadyState);\n", "/**\n * @module Core/data/stm/state/AutoRecordingState\n */\nimport Delayable from '../../../mixin/Delayable.js';\nimport { throwInvalidMethodCall } from './StateBase.js';\nimport { RecordingStateClass } from './RecordingState.js';\nimport { STATE_PROP, TRANSACTION_PROP, TRANSACTION_TIMER_PROP, QUEUE_PROP, POS_PROP, AUTO_RECORD_PROP } from '../Props.js';\nimport Registry from './Registry.js';\nimport { resetQueue } from '../Helpers.js';\n\n/**\n * STM recording state class.\n *\n * @internal\n */\nexport class AutoRecordingStateClass extends RecordingStateClass.mixin(Delayable) {\n\n    onDisable(stm) {\n        const\n            transaction = stm[TRANSACTION_PROP],\n            timer       = stm[TRANSACTION_TIMER_PROP];\n\n        if (timer) {\n            this.clearTimeout(timer);\n        }\n\n        stm.notifyStoresAboutStateRecordingStop(transaction, { disabled : true });\n\n        return {\n            [STATE_PROP]             : 'disabledstate',\n            [TRANSACTION_PROP]       : null,\n            [TRANSACTION_TIMER_PROP] : null\n        };\n    }\n\n    onAutoRecordOn(stm) {\n        throwInvalidMethodCall();\n    }\n\n    onAutoRecordOff(stm) {\n        const timer       = stm[TRANSACTION_TIMER_PROP];\n\n        if (timer) {\n            this.clearTimeout(timer);\n        }\n\n        return {\n            [STATE_PROP]             : 'recordingstate',\n            [AUTO_RECORD_PROP]       : false,\n            [TRANSACTION_TIMER_PROP] : null\n        };\n    }\n\n    onStopTransaction(stm, title) {\n        const\n            transaction = stm[TRANSACTION_PROP],\n            timer       = stm[TRANSACTION_TIMER_PROP],\n            queue       = stm[QUEUE_PROP];\n\n        let position = stm[POS_PROP];\n\n        if (timer) {\n            this.clearTimeout(timer);\n        }\n\n        if (transaction.length) {\n\n            if (!transaction.title && !title && stm.getTransactionTitle) {\n                transaction.title = stm.getTransactionTitle(transaction);\n            }\n            else if (title) {\n                transaction.title = title;\n            }\n\n            queue[position] = transaction;\n            queue.length    = ++position;\n        }\n\n        return [{\n            [STATE_PROP]             : 'autoreadystate',\n            [POS_PROP]               : position,\n            [TRANSACTION_PROP]       : null,\n            [TRANSACTION_TIMER_PROP] : null\n        }, () => {\n            stm.notifyStoresAboutStateRecordingStop(transaction, { stop : true });\n        }];\n    }\n\n    onStopTransactionDelayed(stm) {\n        let timer = stm[TRANSACTION_TIMER_PROP];\n\n        if (timer) {\n            this.clearTimeout(timer);\n        }\n\n        timer = this.setTimeout(\n            () => {\n                stm.stopTransaction();\n            },\n            stm.autoRecordTransactionStopTimeout\n        );\n\n        return {\n            [STATE_PROP]             : AutoRecordingState,\n            [TRANSACTION_TIMER_PROP] : timer\n        };\n    }\n\n    onResetQueue(stm, options) {\n        return resetQueue(stm, options);\n    }\n\n    onRejectTransaction(stm) {\n        const\n            transaction = stm[TRANSACTION_PROP],\n            timer = stm[TRANSACTION_TIMER_PROP];\n\n        if (timer) {\n            this.clearTimeout(timer);\n        }\n\n        return [{\n            [STATE_PROP]             : 'restoringstate',\n            [TRANSACTION_PROP]       : null,\n            [TRANSACTION_TIMER_PROP] : null\n        }, () => {\n\n            if (transaction.length) {\n                transaction.undo();\n            }\n\n            return [\n                'autoreadystate',\n                () => {\n                    stm.notifyStoresAboutStateRecordingStop(transaction, { rejected : true });\n                }\n            ];\n        }];\n    }\n\n    onModelUpdate(stm, ...rest) {\n        super.onModelUpdate(stm, ...rest);\n        stm.stopTransactionDelayed();\n    }\n\n    onModelInsertChild(stm, ...rest) {\n        super.onModelInsertChild(stm, ...rest);\n        stm.stopTransactionDelayed();\n    }\n\n    onModelRemoveChild(stm, ...rest) {\n        super.onModelRemoveChild(stm, ...rest);\n        stm.stopTransactionDelayed();\n    }\n\n    onStoreModelAdd(stm, ...rest)    {\n        super.onStoreModelAdd(stm, ...rest);\n        stm.stopTransactionDelayed();\n    }\n\n    onStoreModelInsert(stm, ...rest) {\n        super.onStoreModelInsert(stm, ...rest);\n        stm.stopTransactionDelayed();\n    }\n\n    onStoreModelRemove(stm, ...rest) {\n        super.onStoreModelRemove(stm, ...rest);\n        stm.stopTransactionDelayed();\n    }\n\n    onStoreRemoveAll(stm, ...rest)   {\n        super.onStoreRemoveAll(stm, ...rest);\n        stm.stopTransactionDelayed();\n    }\n}\n\n/**\n * STM recording state.\n *\n * @internal\n */\nconst AutoRecordingState = new AutoRecordingStateClass();\nexport default AutoRecordingState;\n\nRegistry.registerStmState('autorecordingstate', AutoRecordingState);\n", "/**\n * @module Core/data/stm/action/UpdateAction\n */\nimport ActionBase from './ActionBase.js';\n\nconst\n    MODEL_PROP    = Symbol('MODEL_PROP'),\n    NEW_DATA_PROP = Symbol('NEW_DATA_PROP'),\n    OLD_DATA_PROP = Symbol('OLD_DATA_PROP');\n\n/**\n * Action to record the fact that a model has been updated.\n * @extends Core/data/stm/action/ActionBase\n */\nexport default class UpdateAction extends ActionBase {\n\n    static get defaultConfig() {\n        return {\n            /**\n             * Reference to a model which has been updated.\n             *\n             * @config {Core.data.Model}\n             * @default\n             */\n            model : undefined,\n\n            /**\n             * Map of updated properties with new values.\n             *\n             * @config {Object}\n             * @default\n             */\n            newData : undefined,\n\n            /**\n             * Map of updated properties with old values.\n             *\n             * @config {Object}\n             * @default\n             */\n            oldData : undefined,\n\n            isInitialUserAction : false\n        };\n    }\n\n    get type() {\n        return 'UpdateAction';\n    }\n\n    //<debug>\n    afterConfig() {\n        super.afterConfig();\n\n        console.assert(\n            this.model.isModel && typeof this.newData == 'object' && typeof this.oldData == 'object',\n            \"Can't create action, bad configuration!\"\n        );\n    }\n    //</debug>\n\n    get model() {\n        return this[MODEL_PROP];\n    }\n\n    set model(value) {\n        //<debug>\n        console.assert(\n            !this[MODEL_PROP] && value.isModel,\n            \"Can't set model, model should be instanceof `Model` class and can be set only once!\"\n        );\n        //</debug>\n        this[MODEL_PROP] = value;\n    }\n\n    get newData() {\n        return this[NEW_DATA_PROP];\n    }\n\n    set newData(value) {\n        //<debug>\n        console.assert(\n            !this[NEW_DATA_PROP] && value && typeof value == 'object',\n            \"Can't set new data, new data should be an object and can be set only once!\"\n        );\n        //</debug>\n        this[NEW_DATA_PROP] = { ...value };\n    }\n\n    get oldData() {\n        return this[OLD_DATA_PROP];\n    }\n\n    set oldData(value) {\n        //<debug>\n        console.assert(\n            !this[OLD_DATA_PROP] && value && typeof value == 'object',\n            \"Can't set old data, old data should be an object and can be set only once!\"\n        );\n        //</debug>\n        this[OLD_DATA_PROP] = { ...value };\n    }\n\n    undo() {\n        const { model, oldData } = this;\n\n        // engine needs the setters to be activated, since there's some additional logic (for example, invalidate\n        // dispatcher)\n        if (model.$) {\n            Object.assign(model, oldData);\n        }\n\n        // it seems STM has to use `model.set()` because of `model.inSet` overrides or smth\n        // w/o this call, just with `Object.assign()` above, the view is not refreshed\n        // Since invoking accessor will just forward change to the engine, we need to pass `skipAccessors = true`\n        // to this call to make this change on data level.\n        // Covered by TaskEdit.t `autoSync` subtest\n\n        // but it seems, bypassing the setters puts the change in the `data` property and does not\n        // modify the engine-like caches, that Core uses\n        // this may lead to change being lost, overwritten by some other change, which does\n        model.set(oldData, null, null, null, Boolean(model.$));\n    }\n\n    redo() {\n        const { model, newData } = this;\n\n        // see comments above\n        if (model.$) {\n            Object.assign(model, newData);\n        }\n\n        model.set(newData, null, null, null, Boolean(model.$));\n    }\n}\n", "/**\n * @module Core/data/stm/action/InsertChildAction\n */\nimport ActionBase from './ActionBase.js';\n\nconst\n    PARENT_MODEL_PROP = Symbol('PARENT_MODEL_PROP'),\n    CHILD_MODELS_PROP = Symbol('CHILD_MODELS_PROP'),\n    INSERT_INDEX_PROP = Symbol('INSERT_INDEX_PROP'),\n    CONTEXT_PROP      = Symbol('CONTEXT_PROP');\n\n/**\n * Action to record the fact of adding a children models into a parent model.\n * @extends Core/data/stm/action/ActionBase\n */\nexport default class InsertChildAction extends ActionBase {\n\n    static get defaultConfig() {\n        return {\n            /**\n             * Reference to a parent model a child model has been added to.\n             *\n             * @config {Core.data.Model}\n             * @default\n             */\n            parentModel : undefined,\n\n            /**\n             * Children models inserted.\n             *\n             * @config {Core.data.Model[]}\n             * @default\n             */\n            childModels : undefined,\n\n            /**\n             * Index a children models are inserted at\n             *\n             * @config {Number}\n             * @default\n             */\n            insertIndex : undefined,\n\n            /**\n             * Map having children models as keys and values containing previous parent\n             * of each model and index at the previous parent.\n             *\n             * @config {Object}\n             * @default\n             */\n            context : undefined\n        };\n    }\n\n    get type() {\n        return 'InsertChildAction';\n    }\n\n    //<debug>\n    afterConfig() {\n        super.afterConfig();\n\n        console.assert(\n            this.parentModel.isModel &&\n            Array.isArray(this.childModels) &&\n            this.childModels.every(m => m.isModel) &&\n            this.insertIndex !== undefined &&\n            this.context instanceof Map,\n            \"Can't create action, bad configuration!\"\n        );\n    }\n    //</debug>\n\n    get parentModel() {\n        return this[PARENT_MODEL_PROP];\n    }\n\n    set parentModel(model) {\n        //<debug>\n        console.assert(\n            !this[PARENT_MODEL_PROP] && model,\n            \"Can't set parent model, model is required and can be set only once!\"\n        );\n        //</debug>\n\n        this[PARENT_MODEL_PROP] = model;\n    }\n\n    get childModels() {\n        return this[CHILD_MODELS_PROP];\n    }\n\n    set childModels(models) {\n        //<debug>\n        console.assert(\n            !this[CHILD_MODELS_PROP] &&\n            Array.isArray(models) &&\n            models.every(m => m.isModel),\n            \"Can't set child models, models are required, it should be array of Model class and can be set only once!\"\n        );\n        //</debug>\n\n        this[CHILD_MODELS_PROP] = models.slice(0);\n    }\n\n    get insertIndex() {\n        return this[INSERT_INDEX_PROP];\n    }\n\n    set insertIndex(index) {\n        //<debug>\n        console.assert(\n            this[INSERT_INDEX_PROP] === undefined && index !== undefined,\n            \"Can't set insert index, the value is required and can be set only once!\"\n        );\n        //</debug>\n\n        this[INSERT_INDEX_PROP] = index;\n    }\n\n    get context() {\n        return this[CONTEXT_PROP];\n    }\n\n    set context(ctx) {\n        //<debug>\n        console.assert(\n            !this[CONTEXT_PROP] &&\n            ctx instanceof Map &&\n            Array.from(ctx.entries()).every(([k, v]) => {\n                return k.isModel && typeof v == 'object' && v && Object.prototype.hasOwnProperty.call(v, 'parent') && Object.prototype.hasOwnProperty.call(v, 'index');\n            }),\n            \"Can't set context, the value is required it should be Map keyed by inserted models with object values containing `parent` and `index` properties, and it can be set only once!\"\n        );\n        //</debug>\n\n        this[CONTEXT_PROP] = ctx;\n    }\n\n    undo() {\n        const\n            { parentModel, context, childModels } = this,\n            byFromParent = new Map(),\n            newlyAdded = new Set();\n\n        for (const childModel of childModels) {\n            const ctx = context.get(childModel);\n\n            if (!ctx) {\n                newlyAdded.add(childModel);\n            }\n            else {\n                let undoTaskData = byFromParent.get(ctx.parent);\n\n                if (!undoTaskData) {\n                    undoTaskData = { moveRight : [], moveLeft : [], moveFromAnotherParent : [] };\n                    byFromParent.set(ctx.parent, undoTaskData);\n                }\n\n                if (ctx.parent === parentModel) {\n                    if (ctx.index > childModel.parentIndex) {\n                        undoTaskData.moveRight.push({ parent : ctx.parent, model : childModel, index : ctx.index + 1 });\n                    }\n                    else {\n                        undoTaskData.moveLeft.push({ parent : ctx.parent, model : childModel, index : ctx.index });\n                    }\n                }\n                else {\n                    undoTaskData.moveFromAnotherParent.push({ parent : ctx.parent, model : childModel, index : ctx.index });\n                }\n            }\n        }\n\n        for (const undoTaskData of byFromParent.values()) {\n            const { moveRight, moveLeft } = undoTaskData;\n\n            moveLeft.sort((a, b) => a.index - b.index);\n            moveRight.sort((a, b) => b.index - a.index);\n        }\n\n        newlyAdded.forEach(model => model.parent.removeChild(model));\n\n        for (const undoTaskData of byFromParent.values()) {\n            const { moveRight, moveLeft, moveFromAnotherParent } = undoTaskData;\n\n            moveLeft.forEach(task => {\n                task.parent.insertChild(task.model, task.index);\n            });\n            moveRight.forEach(task => {\n                task.parent.insertChild(task.model, task.index);\n            });\n            moveFromAnotherParent.forEach(task => {\n                task.parent.insertChild(task.model, task.index);\n            });\n        }\n    }\n\n    redo() {\n        const\n            { parentModel, insertIndex, childModels } = this,\n            insertBefore = parentModel.children[insertIndex];\n\n        parentModel.insertChild(childModels, insertBefore, false, {\n            orderedBeforeNode : insertBefore?.previousSibling?.nextOrderedSibling\n        });\n    }\n}\n", "/**\n * @module Core/data/stm/action/RemoveChildAction\n */\nimport ActionBase from './ActionBase.js';\n\nconst\n    PARENT_MODEL_PROP = Symbol('PARENT_MODEL_PROP'),\n    CHILD_MODELS_PROP = Symbol('CHILD_MODELS_PROP'),\n    CONTEXT_PROP      = Symbol('CONTEXT_PROP');\n\n/**\n * Action to record store remove child operation.\n * @extends Core/data/stm/action/ActionBase\n */\nexport default class RemoveChildAction extends ActionBase {\n\n    static get defaultConfig() {\n        return {\n            /**\n             * Reference to a parent model a child model has been removed to.\n             *\n             * @config {Core.data.Model}\n             * @default\n             */\n            parentModel : undefined,\n\n            /**\n             * Children models removed.\n             *\n             * @config {Core.data.Model[]}\n             * @default\n             */\n            childModels : undefined,\n\n            /**\n             * Map having children models as keys and values containing previous parent\n             * index at the parent.\n             *\n             * @config {Object}\n             * @default\n             */\n            context : undefined\n        };\n    }\n\n    get type() {\n        return 'RemoveChildAction';\n    }\n\n    //<debug>\n    afterConfig() {\n        super.afterConfig();\n\n        console.assert(\n            this.parentModel.isModel &&\n            Array.isArray(this.childModels) &&\n            this.childModels.every(m => m.isModel) &&\n            this.context instanceof Map,\n            \"Can't create action, bad configuration!\"\n        );\n    }\n    //</debug>\n\n    get parentModel() {\n        return this[PARENT_MODEL_PROP];\n    }\n\n    set parentModel(model) {\n        //<debug>\n        console.assert(\n            !this[PARENT_MODEL_PROP] && model,\n            \"Can't set parent model, model is required and can be set only once!\"\n        );\n        //</debug>\n\n        this[PARENT_MODEL_PROP] = model;\n    }\n\n    get childModels() {\n        return this[CHILD_MODELS_PROP];\n    }\n\n    set childModels(models) {\n        //<debug>\n        console.assert(\n            !this[CHILD_MODELS_PROP] &&\n            Array.isArray(models) &&\n            models.every(m => m.isModel),\n            \"Can't set child models, models are required, it should be array of Model class and can be set only once!\"\n        );\n        //</debug>\n\n        this[CHILD_MODELS_PROP] = models.slice(0);\n    }\n\n    get context() {\n        return this[CONTEXT_PROP];\n    }\n\n    set context(ctx) {\n        //<debug>\n        console.assert(\n            !this[CONTEXT_PROP] &&\n            ctx instanceof Map &&\n            Array.from(ctx.entries()).every(([k, v]) => {\n                return k.isModel && typeof v === 'object' && typeof v.parentIndex === 'number' && typeof v.orderedParentIndex === 'number';\n            }),\n            \"Can't set context, the value is required it should be Map keyed by inserted models with `index` values, and it can be set only once!\"\n        );\n        //</debug>\n\n        this[CONTEXT_PROP] = ctx;\n    }\n\n    undo() {\n        const { parentModel, context, childModels } = this;\n\n        // Let's sort models by parent index such that models with lesser index\n        // were inserted back first, thus making valid parent index of models following.\n\n        childModels.sort((lhs, rhs) => {\n            const\n                lhsIndex = context.get(lhs),\n                rhsIndex = context.get(rhs);\n\n            return (lhsIndex - rhsIndex);\n        });\n\n        // Now let's re-insert records back to where they were\n        childModels.forEach(m => {\n            const ctx = context.get(m);\n\n            parentModel.insertChild(m, ctx.parentIndex, undefined, { orderedParentIndex : ctx.orderedParentIndex });\n        });\n    }\n\n    redo() {\n        this.parentModel.removeChild(this.childModels);\n    }\n}\n", "import ActionBase from './ActionBase.js';\nimport Store from '../../Store.js';\n\n/**\n * @module Core/data/stm/action/AddAction\n */\nconst\n    STORE_PROP      = Symbol('STORE_PROP'),\n    MODEL_LIST_PROP = Symbol('MODEL_LIST_PROP');\n\n/**\n * Action to record the fact of models adding to a store.\n * @extends Core/data/stm/action/ActionBase\n */\nexport default class AddAction extends ActionBase {\n\n    static get defaultConfig() {\n        return {\n            /**\n             * Reference to a store models have been added into.\n             *\n             * @config {Core.data.Store}\n             * @default\n             */\n            store : undefined,\n\n            /**\n             * List of models added into the store.\n             *\n             * @config {Core.data.Model[]}\n             * @default\n             */\n            modelList : undefined,\n\n            /**\n             * Flag showing if undo/redo should be done silently i.e. with events suppressed\n             *\n             * @config {Boolean}\n             * @default\n             */\n            silent : false\n        };\n    }\n\n    get type() {\n        return 'AddAction';\n    }\n\n    //<debug>\n    afterConfig() {\n        super.afterConfig();\n\n        console.assert(\n            this.store instanceof Store &&\n            Array.isArray(this.modelList) &&\n            this.modelList.length &&\n            this.modelList.every(m => m.isModel),\n            \"Can't create action, bad configuration!\"\n        );\n    }\n    //</debug>\n\n    get store() {\n        return this[STORE_PROP];\n    }\n\n    set store(store) {\n        //<debug>\n        console.assert(\n            !this[STORE_PROP] && store && store instanceof Store,\n            \"Can't set store, store is required and can be set only once!\"\n        );\n        //</debug>\n\n        this[STORE_PROP] = store;\n    }\n\n    get modelList() {\n        return this[MODEL_LIST_PROP];\n    }\n\n    set modelList(list) {\n        //<debug>\n        console.assert(\n            !this[MODEL_LIST_PROP] &&\n            Array.isArray(list) &&\n            list.length,\n            list.every(m => m.isModel),\n            \"Can't set model list, model list is required it should be array of Models and it can be set only once!\"\n        );\n        //</debug>\n\n        this[MODEL_LIST_PROP] = list.slice(0);\n    }\n\n    undo() {\n        this.store.remove(this.modelList, this.silent);\n    }\n\n    redo() {\n        this.store.add(this.modelList, this.silent);\n    }\n}\n", "import ActionBase from './ActionBase.js';\nimport Store from '../../Store.js';\n\n/**\n * @module Core/data/stm/action/InsertAction\n */\n\nconst\n    STORE_PROP        = Symbol('STORE_PROP'),\n    MODEL_LIST_PROP   = Symbol('MODEL_LIST_PROP'),\n    INSERT_INDEX_PROP = Symbol('INSERT_INDEX_PROP'),\n    CONTEXT_PROP      = Symbol('CONTEXT_PROP');\n\n/**\n * Action to record the fact of models inserting into a store.\n * @extends Core/data/stm/action/ActionBase\n */\nexport default class InsertAction extends ActionBase {\n\n    static get defaultConfig() {\n        return {\n            /**\n             * Reference to a store models have been inserted into.\n             *\n             * @config {Core.data.Store}\n             * @default\n             */\n            store : undefined,\n\n            /**\n             * List of models inserted into the store.\n             *\n             * @config {Core.data.Model[]}\n             * @default\n             */\n            modelList : undefined,\n\n            /**\n             * Index the models have been inserted at.\n             *\n             * @config {Number}\n             * @default\n             */\n            insertIndex : undefined,\n\n            /**\n             * Models move context (if models has been moved), if any.\n             * Map this {@link Core/data/Model} instances as keys and their\n             * previous index as values\n             *\n             * @config {Map}\n             * @default\n             */\n            context : undefined,\n\n            /**\n             * Flag showing if undo/redo should be done silently i.e. with events suppressed\n             *\n             * @config {Boolean}\n             * @default\n             */\n            silent : false\n        };\n    }\n\n    get type() {\n        return 'InsertAction';\n    }\n\n    //<debug>\n    afterConfig() {\n        super.afterConfig();\n\n        console.assert(\n            this.store instanceof Store &&\n            Array.isArray(this.modelList) &&\n            this.modelList.length &&\n            this.modelList.every(m => m.isModel) &&\n            this.insertIndex !== undefined &&\n            this.context instanceof Map,\n            \"Can't create action, bad configuration!\"\n        );\n    }\n    //</debug>\n\n    get store() {\n        return this[STORE_PROP];\n    }\n\n    set store(store) {\n        //<debug>\n        console.assert(\n            !this[STORE_PROP] && store && store instanceof Store,\n            \"Can't set store, store is required and can be set only once!\"\n        );\n        //</debug>\n\n        this[STORE_PROP] = store;\n    }\n\n    get modelList() {\n        return this[MODEL_LIST_PROP];\n    }\n\n    set modelList(list) {\n        //<debug>\n        console.assert(\n            !this[MODEL_LIST_PROP] &&\n            Array.isArray(list) &&\n            list.length &&\n            list.every(m => m.isModel),\n            \"Can't set model list, model list is required, it should be array of Models and it can be set only once!\"\n        );\n        //</debug>\n\n        this[MODEL_LIST_PROP] = list.slice(0);\n    }\n\n    get insertIndex() {\n        return this[INSERT_INDEX_PROP];\n    }\n\n    set insertIndex(index) {\n        //<debug>\n        console.assert(\n            this[INSERT_INDEX_PROP] === undefined && index !== undefined,\n            \"Can't set insert index, the value is required and can be set only once!\"\n        );\n        //</debug>\n\n        this[INSERT_INDEX_PROP] = index;\n    }\n\n    get context() {\n        return this[CONTEXT_PROP];\n    }\n\n    set context(context) {\n        //<debug>\n        console.assert(\n            !this[CONTEXT_PROP] &&\n            context instanceof Map &&\n            Array.from(context.entries()).every(([k, v]) => k.isModel && v !== undefined),\n            \"Can't set move context, context is required, it should be Map with keys set to Model instances and numeric values, and it can be set only once!\"\n        );\n        //</debug>\n\n        this[CONTEXT_PROP] = context;\n    }\n\n    undo() {\n        const { store, modelList, context, silent } = this;\n\n        // Let's sort models by index such that models with lesser index\n        // were inserted back first, thus making valid index of models following.\n\n        modelList.sort((lhs, rhs) => {\n            const\n                lhsIndex = context.get(lhs),\n                rhsIndex = context.get(rhs);\n\n            return lhsIndex !== undefined && rhsIndex !== undefined ? lhsIndex - rhsIndex : 0;\n        });\n\n        modelList.forEach(m => {\n            const index = context.get(m);\n\n            // Flag the inserted record that we undo to skip adding it to \"store.removed\"\n            m._undoingInsertion = true;\n\n            if (index !== undefined) {\n                // Insert at previous index\n                store.insert(index, m, silent);\n            }\n            else {\n                // Just remove\n                store.remove(m, silent);\n            }\n\n            m._undoingInsertion = false;\n        });\n    }\n\n    redo() {\n        const me = this;\n        me.store.insert(me.insertIndex, me.modelList, me.silent);\n    }\n}\n", "/**\n * @module Core/data/stm/action/RemoveAction\n */\nimport ActionBase from './ActionBase.js';\nimport Store from '../../Store.js';\n\nconst\n    STORE_PROP      = Symbol('STORE_PROP'),\n    MODEL_LIST_PROP = Symbol('MODEL_LIST_PROP'),\n    CONTEXT_PROP    = Symbol('CONTEXT_PROP');\n\n/**\n * Action to record the fact of models removed from a store.\n * @extends Core/data/stm/action/ActionBase\n */\nexport default class RemoveAction extends ActionBase {\n\n    static get defaultConfig() {\n        return {\n            /**\n             * Reference to a store models have been removed from.\n             *\n             * @config {Core.data.Store}\n             * @default\n             */\n            store : undefined,\n\n            /**\n             * List of models removed from the store.\n             *\n             * @config {Core.data.Model[]}\n             * @default\n             */\n            modelList : undefined,\n\n            /**\n             * Models removing context.\n             *\n             * @config {Object}\n             * @default\n             */\n            context : undefined,\n\n            /**\n             * Flag showing if undo/redo should be done silently i.e. with events suppressed\n             *\n             * @config {Boolean}\n             * @default\n             */\n            silent : false\n        };\n    }\n\n    get type() {\n        return 'RemoveAction';\n    }\n\n    //<debug>\n    afterConfig() {\n        super.afterConfig();\n\n        console.assert(\n            this.store instanceof Store &&\n            Array.isArray(this.modelList) &&\n            this.modelList.length &&\n            this.modelList.every(m => m.isModel) &&\n            \"Can't create action, bad configuration!\"\n        );\n    }\n    //</debug>\n\n    get store() {\n        return this[STORE_PROP];\n    }\n\n    set store(store) {\n        //<debug>\n        console.assert(\n            !this[STORE_PROP] && store && store instanceof Store,\n            \"Can't set store, store is required and can be set only once!\"\n        );\n        //</debug>\n\n        this[STORE_PROP] = store;\n    }\n\n    get modelList() {\n        return this[MODEL_LIST_PROP];\n    }\n\n    set modelList(list) {\n        //<debug>\n        console.assert(\n            !this[MODEL_LIST_PROP] &&\n            Array.isArray(list) &&\n            list.length &&\n            list.every(m => m.isModel),\n            \"Can't set model list, model list is required, it should be array of Models and it can be set only once!\"\n        );\n        //</debug>\n\n        this[MODEL_LIST_PROP] = list.slice(0);\n    }\n\n    get context() {\n        return this[CONTEXT_PROP];\n    }\n\n    set context(context) {\n        //<debug>\n        console.assert(\n            !this[CONTEXT_PROP] &&\n            context instanceof Map &&\n            Array.from(context.entries()).every(([k, v]) => k.isModel && typeof v === 'number'),\n            \"Can't set removal context, removal context is required, it should be Map with Model instances as keys and numeric values, and it can be set only once!\"\n        );\n        //</debug>\n\n        this[CONTEXT_PROP] = context;\n    }\n\n    undo() {\n        const { store, context, modelList, silent } = this;\n\n        // Let's sort models by index such that models with lesser index\n        // were inserted back first, thus making valid index of models following.\n        modelList.sort((lhs, rhs) => {\n            const\n                lhsIndex = context.get(lhs),\n                rhsIndex = context.get(rhs);\n\n            // Here, in contrast to InsertAction, index is always present\n            return lhsIndex - rhsIndex;\n        });\n\n        modelList.forEach(m => {\n            const index = context.get(m);\n\n            // Insert at previous index\n            store.insert(index, m, silent);\n        });\n    }\n\n    redo() {\n        this.store.remove(this.modelList, this.silent);\n    }\n}\n", "/**\n * @module Core/data/stm/action/RemoveAllAction\n */\nimport ActionBase from './ActionBase.js';\nimport Store from '../../Store.js';\n\nconst\n    STORE_PROP       = Symbol('STORE_PROP'),\n    ALL_RECORDS_PROP = Symbol('ALL_RECORDS_PROP');\n\n/**\n * Action to record store remove all operation.\n * @extends Core/data/stm/action/ActionBase\n */\nexport default class RemoveAllAction extends ActionBase {\n\n    static get defaultConfig() {\n        return {\n            /**\n             * Reference to a store cleared.\n             *\n             * @config {Core.data.Store}\n             * @default\n             */\n            store : undefined,\n\n            /**\n             * All store records removed\n             *\n             * @config {Core.data.Model[]}\n             * @default\n             */\n            allRecords : undefined,\n\n            /**\n             * Flag showing if undo/redo should be done silently i.e. with events suppressed\n             *\n             * @config {Boolean}\n             * @default\n             */\n            silent : false\n        };\n    }\n\n    get type() {\n        return 'RemoveAllAction';\n    }\n\n    //<debug>\n    afterConfig() {\n        super.afterConfig();\n\n        console.assert(\n            this.store instanceof Store,\n            Array.isArray(this.allRecords) &&\n            this.allRecords.length &&\n            this.allRecords.every(m => m.isModel),\n            \"Can't create action, bad configuration!\"\n        );\n    }\n    //</debug>\n\n    get store() {\n        return this[STORE_PROP];\n    }\n\n    set store(store) {\n        //<debug>\n        console.assert(\n            !this[STORE_PROP] && store && store instanceof Store,\n            \"Can't set store, store is required and can be set only once!\"\n        );\n        //</debug>\n\n        this[STORE_PROP] = store;\n    }\n\n    get allRecords() {\n        return this[ALL_RECORDS_PROP];\n    }\n\n    set allRecords(records) {\n        //<debug>\n        console.assert(\n            !this[ALL_RECORDS_PROP] &&\n            Array.isArray(records) &&\n            records.length,\n            records.every(m => m.isModel),\n            \"Can't all records list, all records list is required it should be array of Models and it can be set only once!\"\n        );\n        //</debug>\n\n        this[ALL_RECORDS_PROP] = records.slice(0);\n    }\n\n    undo() {\n        const { store, allRecords, silent } = this;\n        store.add(allRecords, silent);\n    }\n\n    redo() {\n        this.store.removeAll(this.silent);\n    }\n}\n", "/**\n * @module Core/data/stm/StateTrackingManager\n */\nimport Base from '../../Base.js';\nimport IdHelper from '../../helper/IdHelper.js';\nimport Events from '../../mixin/Events.js';\nimport StateBase from './state/StateBase.js';\nimport DisabledState from './state/DisabledState.js';\nimport ReadyState from './state/ReadyState.js';\nimport RecordingState from './state/RecordingState.js';\nimport RestoringState from './state/RestoringState.js';\nimport AutoReadyState from './state/AutoReadyState.js';\nimport AutoRecordingState from './state/AutoRecordingState.js';\nimport Registry from './state/Registry.js';\nimport UpdateAction from './action/UpdateAction.js';\nimport InsertChildAction from './action/InsertChildAction.js';\nimport RemoveChildAction from './action/RemoveChildAction.js';\nimport AddAction from './action/AddAction.js';\nimport InsertAction from './action/InsertAction.js';\nimport RemoveAction from './action/RemoveAction.js';\nimport RemoveAllAction from './action/RemoveAllAction.js';\nimport { STATE_PROP, STORES_PROP, QUEUE_PROP, POS_PROP, TRANSACTION_PROP, TRANSACTION_TIMER_PROP, AUTO_RECORD_PROP, IS_APPLYING_STASH } from './Props.js';\n\nexport const makeModelUpdateAction = (model, newData, oldData, isInitialUserAction) => {\n    return new UpdateAction({\n        model,\n        newData,\n        oldData,\n        isInitialUserAction\n    });\n};\n\nexport const makeModelInsertChildAction = (parentModel, insertIndex, childModels, context) => {\n    return new InsertChildAction({\n        parentModel,\n        childModels,\n        insertIndex,\n        context\n    });\n};\n\nexport const makeModelRemoveChildAction = (parentModel, childModels, context) => {\n    return new RemoveChildAction({\n        parentModel,\n        childModels,\n        context\n    });\n};\n\nexport const makeStoreModelAddAction = (store, modelList, silent) => {\n    return new AddAction({\n        store,\n        modelList,\n        silent\n    });\n};\n\nexport const makeStoreModelInsertAction = (store, insertIndex, modelList, context, silent) => {\n    return new InsertAction({\n        store,\n        insertIndex,\n        modelList,\n        context,\n        silent\n    });\n};\n\nexport const makeStoreModelRemoveAction = (store, modelList, context, silent) => {\n    return new RemoveAction({\n        store,\n        modelList,\n        context,\n        silent\n    });\n};\n\nexport const makeStoreRemoveAllAction = (store, allRecords, silent) => {\n    return new RemoveAllAction({\n        store,\n        allRecords,\n        silent\n    });\n};\n\nconst stateTransition = (stm, event, ...args) => {\n    const\n        oldState = stm.state,\n        newState = event.call(stm[STATE_PROP], stm, ...args);\n\n    if (typeof newState === 'string') {\n        stm[STATE_PROP] = Registry.resolveStmState(newState);\n    }\n    else if (newState instanceof StateBase) {\n        stm[STATE_PROP] = newState;\n    }\n    else if (Array.isArray(newState)) {\n        const [state, next] = newState;\n\n        if (typeof state === 'string') {\n            stm[STATE_PROP] = Registry.resolveStmState(state);\n        }\n        else if (state instanceof StateBase) {\n            stm[STATE_PROP] = state;\n        }\n        else if (state && typeof state === 'object') {\n            stm = Object.assign(stm, state);\n            stm[STATE_PROP] = Registry.resolveStmState(stm[STATE_PROP]);\n        }\n\n        if (typeof next === 'function') {\n            stateTransition(stm, next, ...args);\n        }\n    }\n    else if (newState && typeof newState === 'object') {\n        stm = Object.assign(stm, newState);\n        stm[STATE_PROP] = Registry.resolveStmState(stm[STATE_PROP]);\n    }\n\n    if (oldState !== ReadyState && oldState !== AutoReadyState && (newState !== ReadyState && newState !== AutoReadyState)) {\n        stm.trigger('ready');\n    }\n};\n\n/**\n * Tracks the state of every store registered via {@link #function-addStore}. It is {@link #config-disabled} by default\n * so remember to call {@link #function-enable} when your stores are registered and initial dataset is loaded.\n * Use {@link #function-undo} / {@link #function-redo} method calls to restore state to a particular\n * point in time\n *\n * ```javascript\n * stm = new StateTrackingManager({\n *     autoRecord : true,\n *     listeners  : {\n *        'recordingstop' : () => {\n *            // your custom code to update undo/redo GUI controls\n *            updateUndoRedoControls();\n *        },\n *        'restoringstop' : ({ stm }) => {\n *            // your custom code to update undo/redo GUI controls\n *            updateUndoRedoControls();\n *        },\n *        'disabled' : () => {\n *            // in Gantt, Scheduler and other scheduling products,\n *            // also need to update the undo/redo controls on `disabled`\n *            // event, due to implementation details\n *            updateUndoRedoControls();\n *        }\n *    },\n *    getTransactionTitle : (transaction) => {\n *        // your custom code to analyze the transaction and return custom transaction title\n *        const lastAction = transaction.queue[transaction.queue.length - 1];\n *\n *        if (lastAction instanceof AddAction) {\n *            let title = 'Add new record';\n *        }\n *\n *        return title;\n *    }\n * });\n *\n * stm.addStore(userStore);\n * stm.addStore(companyStore);\n * stm.addStore(otherStore);\n *\n * stm.enable();\n * ```\n *\n * **Note:** STM currently does not support undoing server side added and saved records.\n * Therefore it's recommended to {@link #function-resetQueue reset the queue}\n * each time a tracked store(s) loads from or saves its changes to the server.\n * If Crud Manager is used it can be done like this:\n *\n * ```javascript\n * crudManager.on({\n *     requestDone() {\n *         stm.resetQueue();\n *     }\n * });\n * ```\n *\n * and in case individual stores are used:\n *\n * ```javascript\n * ajaxStore.on({\n *     afterRequest({ exception }) {\n *         if (!exception) {\n *             stm.resetQueue();\n *         }\n *     }\n * });\n * ```\n *\n * @mixes Core/mixin/Events\n * @extends Core/Base\n */\nexport default class StateTrackingManager extends Events(Base) {\n\n    static get defaultConfig() {\n        return {\n            /**\n             * Default manager disabled state\n             *\n             * @config {Boolean}\n             * @default\n             */\n            disabled : true,\n\n            /**\n             * Whether to start transaction recording automatically in case the Manager is enabled.\n             *\n             * In the auto recording mode, the manager waits for the first change in any store being managed and starts a transaction, i.e.\n             * records any changes in its monitored stores. The transaction lasts for {@link #config-autoRecordTransactionStopTimeout} and\n             * afterwards creates one undo/redo step, including all changes in the stores during that period of time.\n             *\n             * In non auto recording mode you have to call {@link #function-startTransaction} / {@link #function-stopTransaction} to start and end\n             * a transaction.\n             *\n             * @config {Boolean}\n             * @default\n             */\n            autoRecord : false,\n\n            /**\n             * The transaction duration (in ms) for the auto recording mode {@link #config-autoRecord}\n             *\n             * @config {Number}\n             * @default\n             */\n            autoRecordTransactionStopTimeout : 100,\n\n            /**\n             * Store model update action factory\n             *\n             * @config {Function}\n             * @default\n             * @private\n             */\n            makeModelUpdateAction,\n\n            /**\n             * Store insert child model action factory.\n             *\n             * @config {Function}\n             * @default\n             * @private\n             */\n            makeModelInsertChildAction,\n\n            /**\n             * Store remove child model action factory.\n             *\n             * @config {Function}\n             * @default\n             * @private\n             */\n            makeModelRemoveChildAction,\n\n            /**\n             * Store add model action factory.\n             *\n             * @config {Function}\n             * @default\n             * @private\n             */\n            makeStoreModelAddAction,\n\n            /**\n             * Store insert model action factory.\n             *\n             * @config {Function}\n             * @default\n             * @private\n             */\n            makeStoreModelInsertAction,\n\n            /**\n             * Store remove model action factory.\n             *\n             * @config {Function}\n             * @default\n             * @private\n             */\n            makeStoreModelRemoveAction,\n\n            /**\n             * Store remove all models action factory.\n             *\n             * @config {Function}\n             * @default\n             * @private\n             */\n            makeStoreRemoveAllAction,\n\n            /**\n             * Function to create a transaction title if none is provided.\n             *\n             * The function receives a transaction and should return a title.\n             *\n             * @config {Function}\n             * @default\n             */\n            getTransactionTitle : null\n        };\n    }\n\n    construct(...args) {\n        Object.assign(this, {\n            [STATE_PROP]             : ReadyState,\n            [STORES_PROP]            : [],\n            [QUEUE_PROP]             : [],\n            [POS_PROP]               : 0,\n            [TRANSACTION_PROP]       : null,\n            [TRANSACTION_TIMER_PROP] : null,\n            [AUTO_RECORD_PROP]       : false,\n            [IS_APPLYING_STASH]      : false,\n            stashedTransactions      : {}\n        });\n\n        super.construct(...args);\n    }\n\n    // <remove-on-release>\n    // TODO: This destroys the current state, which makes successive tests fail. Not sure what should be done\n    // doDestroy() {\n    //     super.doDestroy();\n    //     this.destroyProperties(STATE_PROP);\n    // }\n    // </remove-on-release>\n\n    /**\n     * Gets current state of the manager\n     *\n     * @property {Core.data.stm.state.StateBase}\n     */\n    get state() {\n        return this[STATE_PROP];\n    }\n\n    /**\n     * Gets current undo/redo queue position\n     *\n     * @property {Number}\n     */\n    get position() {\n        return this[POS_PROP];\n    }\n\n    /**\n     * Gets current undo/redo queue length\n     *\n     * @property {Number}\n     */\n    get length() {\n        return this[QUEUE_PROP].length;\n    }\n\n    /**\n     * Gets all the stores registered in STM\n     *\n     * @property {Core.data.Store[]}\n     */\n    get stores() {\n        return Array.from(this[STORES_PROP]);\n    }\n\n    /**\n     * Checks if a store has been added to the manager\n     *\n     * @param  {Core.data.Store} store\n     * @returns {Boolean}\n     */\n    hasStore(store) {\n        return this[STORES_PROP].includes(store);\n    }\n\n    /**\n     * Adds a store to the manager\n     *\n     * @param {Core.data.Store} store\n     */\n    addStore(store) {\n        //<debug>\n        console.assert(\n            !this.hasStore(store),\n            'Can\\'t add store to the STM manager, store is already added into the STM manager!'\n        );\n        //</debug>\n\n        if (!this.hasStore(store)) {\n\n            this[STORES_PROP].push(store);\n\n            store.stm = this;\n\n            store.forEach(model => model.stm = this);\n        }\n    }\n\n    /**\n     * Removes a store from the manager\n     *\n     * @param {Core.data.Store} store\n     */\n    removeStore(store) {\n        //<debug>\n        console.assert(\n            this.hasStore(store),\n            'Can\\'t remove store from the STM manager, store isn\\'t registered in the STM manager!'\n        );\n        //</debug>\n\n        if (this.hasStore(store)) {\n            this[STORES_PROP] = this[STORES_PROP].filter(s => s !== store);\n\n            store.stm = null;\n\n            store.forEach(model => model.stm = null);\n        }\n    }\n\n    /**\n     * Calls `fn` for each store registered in STM.\n     *\n     * @param {Function} fn (store, id) => ...\n     */\n    forEachStore(fn) {\n        this[STORES_PROP].forEach(s => fn(s, s.id));\n    }\n\n    //#region Disabled state\n\n    /**\n     * Get/set manager disabled state\n     *\n     * @property {Boolean}\n     */\n    get disabled() {\n        return this.state === DisabledState;\n    }\n\n    set disabled(val) {\n        const me = this;\n\n        if (me.disabled !== val) {\n            if (val) {\n                stateTransition(me, me.state.onDisable, me);\n            }\n            else {\n                stateTransition(me, me.state.onEnable, me);\n            }\n\n            me.trigger('stmDisabled', { disabled : val });\n\n            /**\n             * Fired when the disabled state of the STM changes\n             *\n             * @event disabled\n             * @param {Core.data.stm.StateTrackingManager} source\n             * @param {Boolean} disabled The current disabled state of the STM\n             */\n            me.trigger('disabled', { disabled : val });\n        }\n    }\n\n    get enabled() {\n        return !this.disabled;\n    }\n\n    /**\n     * Enables manager\n     */\n    enable() {\n        this.disabled = false;\n    }\n\n    /**\n     * Disables manager\n     */\n    disable() {\n        this.disabled = true;\n    }\n\n    //#endregion\n\n    /**\n     * Checks manager ready state\n     * @readonly\n     * @property {Boolean}\n     */\n    get isReady() {\n        return this.state === ReadyState || this.state === AutoReadyState;\n    }\n\n    waitForReadiness() {\n        return this.await('ready', false);\n    }\n\n    /**\n     * Checks manager recording state\n     * @readonly\n     * @property {Boolean}\n     */\n    get isRecording() {\n        return this.state === RecordingState || this.state === AutoRecordingState;\n    }\n\n    /**\n     * Checks if STM is restoring a stash\n     * @readonly\n     * @property {Boolean}\n     * @internal\n     */\n    get isApplyingStash() {\n        return this[IS_APPLYING_STASH];\n    }\n\n    /**\n     * Gets/sets manager auto record option\n     *\n     * @property {Boolean}\n     */\n    get autoRecord() {\n        return this[AUTO_RECORD_PROP];\n    }\n\n    set autoRecord(value) {\n        const me = this;\n\n        if (me.autoRecord != value) {\n            if (value) {\n                stateTransition(me, me.state.onAutoRecordOn, me);\n            }\n            else {\n                stateTransition(me, me.state.onAutoRecordOff, me);\n            }\n        }\n    }\n\n    /**\n     * Starts undo/redo recording transaction.\n     *\n     * @param {String} [title]\n     */\n    startTransaction(title = null) {\n        stateTransition(this, this.state.onStartTransaction, title);\n    }\n\n    /**\n     * Stops undo/redo recording transaction\n     *\n     * @param {String} [title]\n     */\n    stopTransaction(title = null) {\n        stateTransition(this, this.state.onStopTransaction, title);\n    }\n\n    /**\n     * Stops undo/redo recording transaction after {@link #config-autoRecordTransactionStopTimeout} delay.\n     *\n     * @private\n     */\n    stopTransactionDelayed() {\n        stateTransition(this, this.state.onStopTransactionDelayed);\n    }\n\n    /**\n     * Rejects currently recorded transaction.\n     */\n    rejectTransaction() {\n        stateTransition(this, this.state.onRejectTransaction);\n    }\n\n    /**\n     * Gets currently recording STM transaction.\n     * @readonly\n     * @property {Core.data.stm.Transaction}\n     */\n    get transaction() {\n        return this[TRANSACTION_PROP];\n    }\n\n    /**\n     * Gets titles of all recorded undo/redo transactions\n     * @readonly\n     * @property {String[]}\n     */\n    get queue() {\n        return this[QUEUE_PROP].map((t) => t.title);\n    }\n\n    get rawQueue() {\n        return this[QUEUE_PROP];\n    }\n\n    /**\n     * Gets manager restoring state.\n     * @readonly\n     * @property {Boolean}\n     */\n    get isRestoring() {\n        return this.state === RestoringState || this.isApplyingStash;\n    }\n\n    /**\n     * Checks if the manager can undo.\n     *\n     * @property {Boolean}\n     */\n    get canUndo() {\n        return this.state.canUndo(this);\n    }\n\n    /**\n     * Checks if the manager can redo.\n     *\n     * @property {Boolean}\n     */\n    get canRedo() {\n        return this.state.canRedo(this);\n    }\n\n    /**\n     * Undoes current undo/redo transaction.\n     * @param {Number} [steps=1]\n     * @returns {Promise} A promise which is resolved when undo action has been performed\n     */\n    async undo(steps = 1) {\n        if (!this.isReady) {\n            await this.waitForReadiness();\n        }\n        stateTransition(this, this.state.onUndo, steps);\n    }\n\n    /**\n     * Undoes all transactions.\n     * @returns {Promise} A promise which is resolved when undo actions has been performed\n     */\n    async undoAll() {\n        if (!this.isReady) {\n            await this.waitForReadiness();\n        }\n        this.undo(this.length);\n    }\n\n    /**\n     * Redoes current undo/redo transaction.\n     *\n     * @param {Number} [steps=1]\n     * @returns {Promise} A promise which is resolved when redo action has been performed\n     */\n    async redo(steps = 1) {\n        if (!this.isReady) {\n            await this.waitForReadiness();\n        }\n        stateTransition(this, this.state.onRedo, steps);\n    }\n\n    /**\n     * Redoes all transactions.\n     * @returns {Promise} A promise which is resolved when redo actions has been performed\n     */\n    async redoAll() {\n        if (!this.isReady) {\n            await this.waitForReadiness();\n        }\n        this.redo(this.length);\n    }\n\n    /**\n     * Resets undo/redo queue.\n     */\n    resetQueue(/* private */options = { undo : true, redo : true }) {\n        stateTransition(this, this.state.onResetQueue, options);\n    }\n\n    /**\n     * Resets undo queue.\n     */\n    resetUndoQueue() {\n        this.resetQueue({ undo : true });\n    }\n\n    /**\n     * Resets redo queue.\n     */\n    resetRedoQueue() {\n        this.resetQueue({ redo : true });\n    }\n\n    notifyStoresAboutStateRecordingStart(transaction) {\n        this.forEachStore((store) => store.onStmRecordingStart?.(this, transaction));\n\n        /**\n         * Fired upon state recording operation starts.\n         *\n         * @event recordingStart\n         * @param {Core.data.stm.StateTrackingManager} stm\n         * @param {Core.data.stm.Transaction} transaction\n         */\n        this.trigger('recordingStart', { stm : this, transaction });\n    }\n\n    notifyStoresAboutStateRecordingStop(transaction, reason) {\n        this.forEachStore((store) => store.onStmRecordingStop?.(this, transaction, reason));\n\n        /**\n         * Fired upon state recording operation stops.\n         *\n         * @event recordingStop\n         * @param {Core.data.stm.StateTrackingManager} stm\n         * @param {Core.data.stm.Transaction} transaction\n         * @param {Object} reason Transaction stop reason\n         * @param {Boolean} reason.stop Transaction recording has been stopped in a normal way.\n         * @param {Boolean} reason.disabled Transaction recording has been stopped due to STM has been disabled.\n         * @param {Boolean} reason.rejected Transaction recording has been stopped due to transaction has been rejected.\n         */\n        this.trigger('recordingStop', { stm : this, transaction, reason });\n    }\n\n    notifyStoresAboutStateRestoringStart() {\n        this.forEachStore((store) => store.onStmRestoringStart?.(this));\n\n        /**\n         * Fired upon state restoration operation starts.\n         *\n         * @event restoringStart\n         * @param {Core.data.stm.StateTrackingManager} stm\n         */\n        this.trigger('restoringStart', { stm : this });\n    }\n\n    /**\n     * @param {'undo'|'redo'} cause The cause of the restore, if applicable\n     * @internal\n     */\n    notifyStoresAboutStateRestoringStop({ cause, transactions }) {\n        this.forEachStore((store) => store.onStmRestoringStop?.(this));\n\n        /**\n         * Fired upon state restoration operation stops.\n         *\n         * @event restoringStop\n         * @param {Core.data.stm.StateTrackingManager} stm\n         */\n        this.trigger('restoringStop', { stm : this, cause, transactions });\n    }\n\n    notifyStoresAboutQueueReset(options) {\n        this.forEachStore((store) => store.onStmQueueReset?.(this, options));\n\n        /**\n         * Fired upon state undo/redo queue reset.\n         *\n         * @event queueReset\n         * @param {Core.data.stm.StateTrackingManager} stm\n         */\n        this.trigger('queueReset', { stm : this, options });\n    }\n\n    /**\n     * Method to call from model STM mixin upon model update\n     *\n     * @param {Core.data.Model} model\n     * @param {Object} newData\n     * @param {Object} oldData\n     *\n     * @private\n     */\n    onModelUpdate(model, newData, oldData, isInitialUserAction) {\n        stateTransition(this, this.state.onModelUpdate, model, newData, oldData, isInitialUserAction);\n    }\n\n    /**\n     * Method to call from model STM mixin upon tree model child insertion\n     *\n     * @param {Core.data.Model} parentModel Parent model\n     * @param {Number} index Insertion index\n     * @param {Core.data.Model[]} childModels Array of models inserted\n     * @param {Map} context Map with inserted models as keys and objects with previous parent,\n     *                      and index at previous parent.\n     *\n     * @private\n     */\n    onModelInsertChild(parentModel, index, childModels, context) {\n        stateTransition(this, this.state.onModelInsertChild, parentModel, index, childModels, context);\n    }\n\n    /**\n     * Method to call from model STM mixin upon tree model child removal\n     *\n     * @param {Core.data.Model} parentModel\n     * @param {Core.data.Model[]} childModels\n     * @param {Map} context\n     *\n     * @private\n     */\n    onModelRemoveChild(parentModel, childModels, context) {\n        stateTransition(this, this.state.onModelRemoveChild, parentModel, childModels, context);\n    }\n\n    /**\n     * Method to call from store STM mixin upon store models adding\n     *\n     * @param {Core.data.Store} store\n     * @param {Core.data.Model[]} models\n     * @param {Boolean} silent\n     *\n     * @private\n     */\n    onStoreModelAdd(store, models, silent) {\n        stateTransition(this, this.state.onStoreModelAdd, store, models, silent);\n    }\n\n    /**\n     * Method to call from store STM mixin upon store models insertion\n     *\n     * @param {Core.data.Store} store\n     * @param {Number} index\n     * @param {Core.data.Model[]} models\n     * @param {Map} context\n     * @param {Boolean} silent\n     *\n     * @private\n     */\n    onStoreModelInsert(store, index, models, context, silent) {\n        stateTransition(this, this.state.onStoreModelInsert, store, index, models, context, silent);\n    }\n\n    /**\n     * Method to call from store STM mixin upon store models removal\n     *\n     * @param {Core.data.Store} store\n     * @param {Core.data.Model[]} models\n     * @param {Object} context\n     * @param {Boolean} silent\n     *\n     * @private\n     */\n    onStoreModelRemove(store, models, context, silent) {\n        stateTransition(this, this.state.onStoreModelRemove, store, models, context, silent);\n    }\n\n    /**\n     * Method to call from store STM mixin upon store clear\n     *\n     * @param {Core.data.Store} store\n     * @param {Core.data.Model[]} allRecords\n     * @param {Boolean} silent\n     *\n     * @private\n     */\n    onStoreRemoveAll(store, allRecords, silent) {\n        stateTransition(this, this.state.onStoreRemoveAll, store, allRecords, silent);\n    }\n\n    // UI key event handling\n    onUndoKeyPress(event) {\n        const me = this;\n\n        if (me.enabled) {\n            if (event.shiftKey) {\n                if (me.canRedo) {\n                    event.preventDefault();\n                    me.redo();\n                }\n            }\n            else if (me.canUndo) {\n                event.preventDefault();\n                me.undo();\n            }\n        }\n    }\n\n    stash() {\n        const me = this;\n\n        if (this.transaction) {\n            const id = IdHelper.generateId('_stashedTransactionGeneratedId_');\n\n            me.stashedTransactions[id] = me.transaction;\n\n            me.rejectTransaction();\n\n            return id;\n        }\n    }\n\n    applyStash(id) {\n        const\n            me          = this,\n            transaction = me.stashedTransactions[id];\n\n        me[IS_APPLYING_STASH] = true;\n\n        if (transaction) {\n            me.startTransaction(transaction.title);\n\n            transaction.redo();\n\n            delete me.stashedTransactions[id];\n        }\n\n        me[IS_APPLYING_STASH] = false;\n    }\n}\n", "import Base from '../Base.js';\n\n/**\n * @module Core/mixin/Finalizable\n */\n\n/**\n * This mixin provides an asynchronous completion mechanism. This allows a process to coordinate its async actions\n * (such as Ajax requests or user interaction) with cleanup.\n *\n * Consider a context tracking helper class, for example:\n *\n * ```javascript\n *  class Context extends Base.mixin(Finalizable) {\n *      // ...\n *\n *      async finish() {\n *          this.owner.trigger('finish', {\n *              context : this\n *          });\n *\n *          // Wait for any scheduled finalizer to run...\n *          await this.finalize();\n *      }\n *\n *      doFinalize() {\n *          this.destroy();\n *      }\n *  }\n * ```\n *\n * When the `finish` event is processed, the receiver can register a promise for whatever processing it would like to\n * perform:\n *\n * ```javascript\n *  class Foo {\n *      onFinish({ context }) {\n *          context.finalizer = this.askUser(context);\n *      }\n *\n *      async askUser(context) {\n *          //\n *      }\n *  }\n * ```\n *\n * @mixin\n * @internal\n */\nexport default Target => class Finalizable extends (Target || Base) {\n    static get $name() {\n        return 'Finalizable';\n    }\n\n    construct(...args) {\n        super.construct(...args);\n\n        /**\n         * This property can be set any time prior to calling {@link #function-finalize} (i.e., when the\n         * {@link #property-isFinalizing} property goes to `true`). When set, this instance will `await` this\n         * promise before completing the finalization process by calling {@link #function-doFinalize}.\n         * @member {Promise} finalizer\n         */\n        this.finalizer = null;\n\n        /**\n         * This property holds the `Promise` that will resolve when {@link #function-finalize} has completed. It is\n         * set when {@link #function-finalize} is called and cleared on return.\n         * @member {Boolean} finalizing\n         * @readonly\n         * @private\n         */\n        this.finalizing = null;\n\n        /**\n         * This property is `true` once the instance completes the {@link #function-finalize} method.\n         * @member {Boolean} isFinalized\n         * @readonly\n         */\n        this.isFinalized = false;\n\n        /**\n         * This property is set to `true` when {@link #function-finalize} is called.\n         * @member {Boolean} isFinalizing\n         * @readonly\n         */\n        this.isFinalizing = false;\n    }\n\n    /**\n     * This template method is called at the end of {@link #function-finalize}. By default it calls `destroy()`, but\n     * can be replaced by the derived class. This can be useful if it is not the `Finalizable` instance that awaits\n     * the {@link #function-finalize} method.\n     */\n    doFinalize() {\n        this.destroy();\n    }\n\n    /**\n     * This method is called (typically by this instance or its owner) to cleanup this instance while possibly first\n     * waiting for the {@link #property-finalizer} promise to settle. Once settled, the {@link #function-doFinalize}\n     * method is called.\n     * @async\n     */\n    finalize() {\n        const me = this;\n\n        let ret = me.finalizing;\n\n        if (!ret && !me.isFinalized) {\n            me.isFinalizing = true;  // note: we never clear this flag (use isFinalized to know if we're done)\n            // If we are called during finalization, we want to return the same promise, so we cache it away.\n            me.finalizing = ret = me._awaitFinalizer();\n        }\n\n        return ret;\n    }\n\n    async _awaitFinalizer() {\n        const me = this;\n\n        try {\n            await me.finalizer;\n        }\n        finally {\n            // be sure we clean up even if an exception is thrown by the finalizer...\n\n            me.finalizing = null;\n            me.isFinalized = true;\n\n            me.doFinalize();\n        }\n    }\n};\n", "import Base from '../../Base.js';\nimport DomHelper from '../../helper/DomHelper.js';\nimport EventHelper from '../../helper/EventHelper.js';\nimport Delayable from '../../mixin/Delayable.js';\nimport Finalizable from '../../mixin/Finalizable.js';\nimport Identifiable from '../../mixin/Identifiable.js';\nimport DomDataStore from '../../data/DomDataStore.js';\nimport Objects from '../../helper/util/Objects.js';\n\n/**\n * @module Core/util/drag/DragContext\n */\n\nconst\n    ABORTED  = Symbol('dragAbort'), // Drag has been aborted\n    INIT     = Symbol('dragInit'),  // Button is down but insufficient movement to start the drag\n    DRAGGING = Symbol('dragDrag'),  // Button is down and movement has started a drag\n    DROPPED  = Symbol('dragDrop'),  // Button has been released and drop has occurred\n    lockDirections = {\n        x : 'horizontal',\n        y : 'vertical'\n    };\n\n/**\n * This class is created during drag operations of {@link Core/mixin/Draggable}. It holds the state of an ongoing drag\n * operation.\n * @extends Core/Base\n * @internal\n */\nexport default class DragContext extends Base.mixin(Finalizable, Delayable, Identifiable) {\n\n    static $name = 'DragContext';\n\n    static get configurable() {\n        return {\n            /**\n             * The element that will have the {@link Core.mixin.Draggable#property-draggingItemCls}. This element is\n             * determined by the {@link Core.mixin.Draggable#config-dragItemSelector}.\n             * @config {HTMLElement}\n             */\n            itemElement : null,\n\n            /**\n             * The `ScrollManager` instance to use for scrolling while dragging.\n             * @config {Core.util.ScrollManager}\n             * @private\n             */\n            scrollManager : null,\n\n            /**\n             * Config for `startMonitoring` call.\n             * @config {Object}\n             * @private\n             */\n            monitoringConfig : null,\n\n            /**\n             * The source of the drag operation.\n             * @config {Core.mixin.Draggable}\n             * @default\n             * @readonly\n             */\n            source : null,\n\n            /**\n             * The current target of the drag.\n             * @member {Core.mixin.Droppable}\n             * @readonly\n             */\n            target : null,\n\n            /**\n             * The current target element of the drag.\n             * @member {HTMLElement}\n             * @private\n             */\n            targetElement : null,\n\n            /**\n             * The minimum distance from the touchstart/mousedown/pointerdown that must be moved to actually start a\n             * drag operation.\n             * @config {Number}\n             * @default\n             * @readonly\n             */\n            threshold : 5,\n\n            /**\n             * The minimum amount of time a touch must be maintained before it will initiate a drag. Movement prior to\n             * this time will cancel the drag in order to allow touch scrolling.\n             * @config {Number}\n             * @default\n             */\n            touchStartDelay : 300\n        };\n    }\n\n    static get identifiable() {\n        return {};\n    }\n\n    /**\n     * The current DOM event being processed.\n     * @member {Event} event\n     * @readonly\n     */\n\n    construct(...args) {\n        super.construct(...args);\n\n        const\n            me = this,\n            { event } = me;\n\n        Object.assign(me, {\n            /**\n             * This property holds the `altKey` state of the most recent event.\n             * @member {Boolean}\n             */\n            altKey : null,\n\n            /**\n             * An array of functions to call when cleaning up the context instance.\n             * @member {Function[]}\n             * @private\n             */\n            cleaners : [],\n\n            /**\n             * This property holds the `ctrlKey` state of the most recent event.\n             * @member {Boolean}\n             */\n            ctrlKey : null,\n\n            /**\n             * Container for data associated with the drag. Data items are added by the {@link Core.mixin.Draggable}\n             * when the drag starts.\n             * @member {Map}\n             * @private\n             */\n            data : new Map(),\n\n            /**\n             * The element from which the drag operation started.\n             * @member {HTMLElement}\n             * @readonly\n             */\n            element : event.target,\n\n            /**\n             * The event that completed the drag (a `mouseup`, `pointerup` or `touchend`).\n             * @member {Event}\n             * @readonly\n             */\n            endEvent : null,\n\n            /**\n             * The most recent `mousemove`, `pointermove` or `touchmove` event.\n             * @member {Event}\n             * @private\n             */\n            lastMoveEvent : null,\n\n            /**\n             * This property holds the `metaKey` state of the most recent event.\n             * @member {Boolean}\n             */\n            metaKey : null,\n\n            /**\n             * The previous {@link #property-target} of the drag.\n             * @member {Core.mixin.Droppable}\n             * @readonly\n             */\n            previousTarget : null,\n\n            /**\n             * The scroll actions reported by the {@link #config-scrollManager}.\n             * @member {Object}\n             * @private\n             */\n            scrollerAction : null,\n\n            /**\n             * This property holds the `shiftKey` state of the most recent event.\n             * @member {Boolean}\n             */\n            shiftKey : null,\n\n            /**\n             * This property holds the current state of the drag process.\n             *\n             * This will be one of the following values:\n             *\n             *  - `DragContext.STATE.INIT` - The button is down but there is insufficient movement to start the drag.\n             *  - `DragContext.STATE.DRAGGING` - The button is down and movement has started the drag.\n             *  - `DragContext.STATE.DROPPED` - The button has been released and drop has occurred.\n             *  - `DragContext.STATE.ABORTED` - The drag has been aborted (this happens if the user presses the `ESC`\n             *    key or if the {@link #function-abort} method is called).\n             *\n             * @member {Symbol}\n             * @readonly\n             * @internal\n             */\n            state : INIT,\n\n            /**\n             * The event that started the drag operation.\n             * @member {Event}\n             * @readonly\n             */\n            startEvent : event,\n\n            /**\n             * The timer that fires when a touch pointermove is allowed to start the drag. A touch pointermove event\n             * prior to this will `abort()` the drag to allow touch scrolling.\n             * @member {Number}\n             * @private\n             */\n            touchStartTimer : null,\n\n            /**\n             * Stores the value from writes to the {@link #property-valid} property.\n             * @member {Boolean}\n             * @private\n             */\n            _valid : true\n        });\n\n        if (('touches' in event) && me.touchStartDelay) {\n            me.touchStartTimer = me.setTimeout(() => me.touchStartTimer = null, me.touchStartDelay, 'touchStartDelay');\n        }\n\n        EventHelper.on({\n            element : globalThis,\n            blur    : 'onWindowBlur',\n            thisObj : me\n        });\n    }\n\n    doDestroy() {\n        const\n            me = this,\n            { source, target } = me;\n\n        me.cleanup();\n\n        if (target?.dropping === me) {\n            target.dropping = null;\n        }\n\n        if (source?.dragging === me) {\n            source.dragging = null;\n        }\n\n        super.doDestroy();\n    }\n\n    onWindowBlur() {\n        if (this.started) {\n            this.abort();\n        }\n    }\n\n    /**\n     * This property is `true` if the {@link #function-abort} method was called and `false` otherwise. This\n     * is typically because the user pressed the ESC key, however, a drag can be aborted for other reasons.\n     * @property {Boolean}\n     * @readonly\n     */\n    get aborted() {\n        return this.state === ABORTED;\n    }\n\n    /**\n     * Returns `true` if the drag has completed either by mouse/pointerup or the {@link #function-abort} method.\n     * @property {Boolean}\n     * @readonly\n     */\n    get completed() {\n        return this.isDestroying || this.aborted || this.endEvent !== null;\n    }\n\n    /**\n     * This property is `true` if the drag {@link #config-threshold} has not yet been reached.\n     * @property {Boolean}\n     * @readonly\n     */\n    get pending() {\n        return this.state === INIT;\n    }\n\n    /**\n     * This property is `true` if the drag {@link #config-threshold} has been reached and the drag operation is active.\n     * @property {Boolean}\n     * @readonly\n     */\n    get started() {\n        return this.state !== INIT && !this.aborted;\n    }\n\n    /**\n     * This property is `true` when the drag is in a valid drop state. This can be set to `false` to indicate the drop\n     * is invalid. Setting to `true` does not ensure that the property will be `true` when next read due to other factors\n     * that are required to make the drop valid. For example, setting `valid = true` will still return `false` if called\n     * before the drag {@link #config-threshold} has not been reached or if the {@link #function-abort} method has been\n     * called.\n     * @property {Boolean}\n     */\n    get valid() {\n        return this.started && this.targetElement != null && this._valid;\n    }\n\n    set valid(v) {\n        this._valid = v;\n    }\n\n    //region Data Access\n\n    /**\n     * Retrieves a data item from the drag source. This method can only be called after the drag has completed.\n     * @param {String|String[]} name The name of the data item.\n     * @returns {*}\n     */\n    async get(name) {\n        if (this.aborted) {\n            throw new Error('Data is not available on aborted drag');\n        }\n        if (!this.completed) {\n            throw new Error('Data is not available until drag completion');\n        }\n\n        if (Array.isArray(name)) {\n            return Promise.all(name.map(s => this.get(s)));\n        }\n\n        let value = this.data.get(name);\n\n        if (typeof value === 'function') {\n            value = await value();\n\n            this.data.set(name, value);\n        }\n\n        return value;\n    }\n\n    /**\n     * Returns `true` if the named data item is present.\n     * @param {String} name The name of the data item.\n     * @returns {Boolean}\n     */\n    has(name) {\n        return this.data.has(name);\n    }\n\n    /**\n     * Retrieves a data item from the drag source if it is available. This will return `true` for an item that was\n     * {@link #function-set} using a renderer function.\n     * @param {String|String[]} name The name of the data item.\n     * @returns {*}\n     */\n    peek(name) {\n        if (this.aborted) {\n            throw new Error('Data is not available on aborted drag');\n        }\n\n        if (Array.isArray(name)) {\n            return name.map(s => this.peek(s));\n        }\n\n        let value = this.data.get(name);\n\n        if (typeof value === 'function') {\n            value = true;\n        }\n\n        return value;\n    }\n\n    /**\n     * Sets a data item for the drag. If a function is passed, it is called to render the data only if that data is\n     * actually requested via the {@link #function-get} method. A data renderer function can be `async`.\n     * @param {String} name The name of the data item.\n     * @param {*} value The value of the data item.\n     */\n    set(name, value) {\n        this.data.set(name, value);\n    }\n\n    //endregion\n    //region Configs\n\n    changeTarget(target, was) {\n        if (target !== was) {\n            const me = this;\n\n            me._target = target;\n            me.previousTarget = was;\n\n            if (was) {\n                was.dropping = null;\n            }\n\n            if (target) {\n                target.dropping = me;  // calls dragEnter/Leave on the target\n\n                if (target.dropping !== me) {  // if (target did not accept us)\n                    target = null;\n\n                    me.valid = false;\n                }\n            }\n\n            me._target = was;\n        }\n\n        return target;\n    }\n\n    updateTarget(target, was) {\n        const me = this;\n\n        if (was) {\n            me.source.dragLeaveTarget(me, was);\n        }\n\n        if (target) {\n            me.valid = true;\n\n            // Always give the target an initial dragMove since feedback/indicators will need to update on move and\n            // the lack of a move on entry will just make that a special case.\n            target.dragMove(me);\n\n            me.source.dragEnterTarget(me);\n        }\n    }\n\n    updateTargetElement(targetElement) {\n        let droppable,\n            droppables,\n            droppableSelector,\n            i,\n            t;\n\n        // We interrogate all encapsulating DOM elements to see if we are in a Droppable's element.\n        // If we find an element which has Droppables registered for it, we attempt to set each as\n        // our target, and go with the first one that accepts us.\n        // changeTarget sets target.dropping to this Context, and the target's dragEnter implementation\n        // may reject it by returning false.\n        for (t = targetElement; t; t = t.parentElement) {\n            droppables = DomDataStore.get(t, 'droppables');\n\n            if (droppables) {\n                for (i = 0; i < droppables.length; ++i) {\n                    droppable = droppables[i];\n\n                    // If the event target is *inside* the Droppable's root, we can ask the Droppable\n                    // to accept this DragContext.\n                    // Otherwise we can get a hit on borders.\n                    if (droppable.dropRootElement.contains(targetElement)) {\n                        droppableSelector = droppable.droppableSelector;\n\n                        // If the target element is not inside the Droppable's selector, give up.\n                        if (!droppableSelector || targetElement.closest(`#${DomHelper.getId(droppable.dropRootElement)} ${droppableSelector}`)) {\n                            this.target = droppable;\n\n                            // The found Droppable accepted this DragContext, so we're done -\n                            // we are using this Droppable.\n                            if (this.target === droppable) {\n                                return;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    //endregion\n    //region Operations\n\n    /**\n     * Aborts the drag. After calling this method, {@link #property-aborted} will be `true`, {@link #property-valid}\n     * will be `false` and {@link #property-completed} will be `true`.\n     */\n    abort() {\n        const\n            me = this,\n            { element, source } = me;\n\n        // Force a synchronous layout so that transitions from this point will work.\n        element?.getBoundingClientRect();\n\n        if (me.state !== DROPPED) {\n            me.state = ABORTED;\n            me.cleanup();\n        }\n\n        source?.endDrag(me);\n    }\n\n    begin() {\n        const\n            me = this,\n            { source } = me,\n            ret = source.beforeDrag(me);\n\n        if (ret !== false) {\n            source.dragging = me;\n        }\n\n        return ret;\n    }\n\n    cleanup() {\n        let cleaner;\n\n        while ((cleaner = this.cleaners.pop())) {\n            cleaner();\n        }\n    }\n\n    end(event) {\n        const\n            me = this,\n            { lastMoveEvent : lastEvent, target } = me,\n            { dragSwallowClickTime } = me.source;\n\n        me.event = me.endEvent = event;\n        me.syncFlags();\n\n        if (me.started) {\n            if (lastEvent?.clientX !== event.clientX || lastEvent?.clientY !== event.clientY ||\n                lastEvent?.target !== event.target) {\n                // Make sure the drop event is preceded by a move to the final position...\n                me.track();\n            }\n\n            if (dragSwallowClickTime) {\n                // Prevent the impending document click from the mouseup event from propagating\n                // into a click on our element.\n                EventHelper.on({\n                    element : document,\n                    capture : true,\n                    expires : dragSwallowClickTime, // In case a click did not ensue, remove the listener\n                    once    : true,\n                    click(event) {\n                        event.stopPropagation();\n                    }\n                });\n            }\n\n            me.state = DROPPED;\n\n            if (target !== me.source) {\n                // If we are the target and not also the source, we need to call dragDrop() now. If we are\n                // the source, dragDrop() will be called by Draggable.\n                target?.dragDrop(me);\n            }\n        }\n    }\n\n    fakeKey(event, down) {\n        const\n            me = this,\n            { lastMoveEvent } = me;\n\n        if (lastMoveEvent && me.element) {\n            let changed;\n\n            // Indicate that this is a 'fake' mousemove event as a result of the keydown\n            lastMoveEvent.isKey = true;\n\n            if (event.key === 'Alt') {\n                if (me.altKey !== down) {\n                    me.altKey = down;\n                    changed = true;\n                }\n            }\n            else if (event.key === 'Control') {\n                if (me.ctrlKey !== down) {\n                    me.ctrlKey = down;\n                    changed = true;\n                }\n            }\n\n            if (changed) {\n                me.event = lastMoveEvent;\n\n                me.track();\n            }\n        }\n    }\n\n    keyDown(event) {\n        if (!this.completed) {\n            if (event.key === 'Escape') {\n                this.abort();\n            }\n            else if (this.isDragToggleKey(event.key)) {\n                this.fakeKey(event, true);\n            }\n        }\n    }\n\n    keyUp(event) {\n        if (!this.completed && this.isDragToggleKey(event.key)) {\n            this.fakeKey(event, false);\n        }\n    }\n\n    getDistance(event) {\n        return EventHelper.getDistanceBetween(this.startEvent, event);\n    }\n\n    isDragToggleKey(key) {\n        return key === 'Control' || key === 'Alt';\n    }\n\n    move(event) {\n        const\n            me = this,\n            { target } = event,\n            distance = me.getDistance(event),\n            significant = distance >= me.threshold;\n\n        me.syncFlags();\n\n        if (me.touchStartTimer) {\n            if (significant) {\n                me.abort();\n            }\n            return;\n        }\n\n        if (target && target.nodeType === Node.ELEMENT_NODE) {\n            if (significant && !me.started) {\n                me.event = event;\n\n                // triggers beforeDragStart, dragStart. returning false from beforeDragStart aborts drag\n                if (me.start() === false) {\n                    me.abort();\n                    return;\n                }\n            }\n\n            // With resize observer polyfill scroll event might fire after drop is completed but before listener is\n            // removed\n            if (me.started && !me.completed) {\n                me.lastMoveEvent = me.event = event;\n\n                // to prevent view drag (scroll) on ipad\n                if (event.type === 'touchmove') {\n                    event.preventDefault();\n                    event.stopImmediatePropagation();\n                }\n\n                me.track();\n            }\n        }\n    }\n\n    start() {\n        const\n            me = this,\n            { scrollManager, monitoringConfig, source } = me,\n            { draggingBodyCls : activeCls, dragLock } = source,\n            element = /* source.dragWithin || */ source.dragRootElement;\n\n        me.state = DRAGGING;\n\n        // Now that the drag drop is confirmed to be starting, activate the configured scrollManager if present\n        if (scrollManager) {\n            const detacher = scrollManager.startMonitoring(Objects.merge({\n                scrollables : [{\n                    element\n                }],\n                direction : lockDirections[dragLock] || dragLock || 'both',\n                callback(scrollerAction) {\n                    const { lastMoveEvent } = me;\n\n                    if (lastMoveEvent && me.element) {\n                        // Indicate that this is a 'fake' mousemove event as a result of the scrolling\n                        lastMoveEvent.isScroll = true;\n\n                        me.event = lastMoveEvent;\n                        me.scrollerAction = scrollerAction;\n\n                        me.track();\n\n                        me.scrollerAction = null;\n                    }\n                }\n            }, monitoringConfig));\n\n            me.cleaners.push(detacher);\n        }\n\n        // Global informational class for when DragHelper is dragging\n        const rootEl = source.dragRootElement.closest('.b-outer') || document.body;\n        rootEl.classList.add(activeCls);\n\n        me.cleaners.push(() => rootEl.classList.remove(activeCls));\n\n        if (source.startDrag(me) === false) {\n            me.cleanup();\n\n            return false;\n        }\n    }\n\n    syncFlags() {\n        const\n            me = this,\n            { event } = me;\n\n        me.altKey = event.altKey;\n\n        // Our EventHelper events are \"unfixed\" after processing, so the meta->ctrl\n        // modifier mapping will not persist. We must do the mapping here.\n        me.ctrlKey = event.ctrlKey || event.metaKey;\n        me.metaKey = event.metaKey;\n        me.shiftKey = event.shiftKey;\n    }\n\n    track() {\n        const\n            me = this,\n            { event, source, target } = me;\n\n        let targetElement = event.target,\n            touch;\n\n        // NOTE: we cannot syncFlags here since we are called to pass along keydown events as movement updates\n\n        // \"pointer-events:none\" touchmove has no effect for the touchmove event target, meaning we cannot know\n        // what's under the cursor as easily in touch devices\n        if (event.type === 'touchmove') {\n            touch = event.changedTouches[0];\n\n            // From MDN:\n            //  * clientX/Y - the coordinates of the touch point relative to the left/top edge of the browser viewport,\n            //    not including any scroll offset.\n            //  * The elementFromPoint() method returns the topmost Element at the specified coordinates (relative to\n            //    the viewport).\n            targetElement = DomHelper.elementFromPoint(touch.clientX, touch.clientY);\n        }\n\n        me.targetElement = targetElement;  // when we change elements, update me.target\n\n        if (target === me.target) {\n            // if we have a target and that did not change due to setting targetElement, we need to inform the target\n            // of the drag move\n            target?.dragMove(me);\n        }\n\n        source.trackDrag(me);\n    }\n\n    //endregion\n}\n\nDragContext.prototype.STATE = DragContext.STATE = Object.freeze({\n    ABORTED,\n    INIT,\n    DRAGGING,\n    DROPPED\n});\n", "import Base from '../../Base.js';\nimport Factoryable from '../../mixin/Factoryable.js';\n\n/**\n * @module Core/util/drag/DragProxy\n */\n\n/**\n * Drag proxies are helper classes that represent the object being dragged in some visual way. This is an abstract\n * base with which particular drag proxy classes (such as, {@link Core.util.drag.DragTipProxy} are registered.\n *\n * Derived classes the various template methods of this class to manage their particular form of visual feedback.\n * @extends Core/Base\n * @internal\n */\nexport default class DragProxy extends Base.mixin(Factoryable) {\n    static get type() {\n        return 'default';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * The currently active `DragContext`. This context will be active prior to be passed to the proxy. This\n             * config is set by {@link #function-dragStart} and cleared by {@link #function-dragEnd}.\n             * @config {Core.util.drag.DragContext}\n             */\n            dragging : null\n        };\n    }\n\n    static get factoryable() {\n        return {\n            defaultType : DragProxy\n        };\n    }\n\n    /**\n     * The `Draggable` instance that owns this drag proxy.\n     * @member {Core.mixin.Draggable} owner\n     * @readonly\n     */\n\n    //region Configs\n\n    updateDragging(drag, was) {\n        if (was) {\n            this.close(was);\n        }\n\n        if (drag) {\n            this.open(drag);\n        }\n    }\n\n    //endregion\n\n    //region Operations\n\n    /**\n     * This template method is called when {@link #config-dragging} is reset to `null`.\n     * @param {Core.util.drag.DragContext} drag The drag instance.\n     */\n    close(drag) {\n        // template\n    }\n\n    /**\n     * This template method is called when {@link #config-dragging} is set to a non-`null` value.\n     * @param {Core.util.drag.DragContext} drag The drag instance.\n     */\n    open(drag) {\n        // template\n    }\n\n    //endregion\n\n    //region Drag Processing\n\n    /**\n     * This template method is called by the `Draggable` instance when the drag officially starts.\n\n     * This sets the {@link #config-dragging} config to `drag`, which triggers the call to {@link #function-open}.\n     * @param {Core.util.drag.DragContext} drag The drag instance.\n     */\n    dragStart(drag) {\n        this.dragging = drag;\n    }\n\n    /**\n     * This template method is called by the `Draggable` instance as drag movement occurs.\n     * @param {Core.util.drag.DragContext} drag The drag instance.\n     */\n    dragMove(drag) {\n        // template\n    }\n\n    /**\n     * This template method is called by the `Draggable` instance when the drag completes.\n     *\n     * This sets the {@link #config-dragging} config to `null`, which triggers the call to {@link #function-close}.\n     * @param {Core.util.drag.DragContext} drag The drag instance.\n     */\n    dragEnd(drag) {\n        this.dragging = null;\n    }\n\n    //endregion\n}\n\nDragProxy.initClass();\n", "import Base from '../Base.js';\nimport EventHelper from '../helper/EventHelper.js';\nimport ObjectHelper from '../helper/ObjectHelper.js';\n\nimport DragContext from '../util/drag/DragContext.js';\nimport DragProxy from '../util/drag/DragProxy.js';\n\n/**\n * @module Core/mixin/Draggable\n */\n\n/**\n * Mix this into another class to enable drag/drop support.\n *\n * To use a draggable, it must be associated with an element that contains draggable content:\n *\n * ```javascript\n *  let draggable = new MyDraggable({\n *      dragRootElement : someElement\n *  });\n * ```\n *\n * Once the `dragRootElement` is assigned, any element inside that root is a candidate for dragging. To limit the\n * allowed element, set the {@link #config-dragSelector} config.\n *\n * ```javascript\n *  let draggable = new MyDraggable({\n *      dragRootElement : someElement,\n *      dragSelector    : '.drag-this'\n *  });\n * ```\n *\n * @mixin\n * @internal\n */\nexport default Target => class Draggable extends (Target || Base) {\n    static get $name() {\n        return 'Draggable';\n    }\n\n    //region Configs\n\n    static get configurable() {\n        return {\n            /**\n             * The current `DragContext`. This is created immediately on pointerdown but does not become active until\n             * some movement occurs. This {@link #config-dragThreshold threshold} is configurable.\n             * @member {Core.util.drag.DragContext}\n             * @readonly\n             */\n            dragging : {\n                $config : 'nullify',\n                value   : null\n            },\n\n            /**\n             * A CSS selector to use to ascend from the {@link #config-dragRootElement} to find the element that will\n             * gain the {@link #property-draggingCls} and {@link #property-draggingStartedCls} CSS classes.\n             * @config {String}\n             */\n            draggingClsSelector : null,\n\n            /**\n             * The listeners to add to the `document` during a drag.\n             * @config {Object}\n             * @private\n             */\n            dragDocumentListeners : {\n                element : document,\n                keydown : 'onDragKeyDown',\n                keyup   : 'onDragKeyUp',\n\n                // On mobile, a long-press will (sometimes) trigger a context menu, so we suppress it:\n                contextmenu : 'onDragContextMenu',\n\n                // We don't use pointermove/up because they get snared in the \"touch-action\" vs \"pan-x/y\" trap and we\n                // cannot prevent panning (aka scrolling) in response to move events if we go that way:\n                mousemove : 'onDragPointerMove',\n                mouseup   : 'onDragPointerUp',\n\n                // Touch desktops don't fire touchend event when touch has ended, instead pointerup is fired. iOS does\n                // fire touchend:\n                pointerup : 'onDragPointerUp',\n                touchend  : 'onDragPointerUp',\n                touchmove : {\n                    handler : 'onDragPointerMove',\n                    passive : false // We need to be able to preventDefault on the touchmove\n                }\n            },\n\n            /**\n             * A CSS selector to use to ascend from the drag element to find the element that will gain the\n             * {@link #property-draggingItemCls} CSS class. If not supplied, the drag element will gain this CSS\n             * class.\n             * @config {String}\n             */\n            dragItemSelector : null,\n\n            /**\n             * A CSS class to add to items identified by the {@link #config-dragItemSelector} when the mouse\n             * enters.\n             * @config {String}\n             */\n            dragItemOverCls : null,\n\n            /**\n             * A function to call when the pointer enters a {@link #config-dragItemSelector}.\n             * @config {Function} onDragItemMouseEnter\n             */\n\n            /**\n             * A function to call when the pointer moves inside a {@link #config-dragItemSelector}.\n             * @config {Function} onDragItemMouseMove\n             */\n\n            /**\n             * A function to call when the pointer leaves a {@link #config-dragItemSelector}.\n             * @config {Function} onDragItemMouseLeave\n             */\n\n            /**\n             * Configure as `'x'` to lock dragging to the `X` axis (the drag will only move horizontally) or `'y'`\n             * to lock dragging to the `Y` axis (the drag will only move vertically).\n             * @config {'x'|'y'|null}\n             */\n            dragLock : null,\n\n            /**\n             * The minimum distance a drag must move to be considered a drop and not\n             * {@link Core.util.drag.DragContext#property-aborted}.\n             * @config {Number}\n             * @default\n             */\n            dragMinDistance : 1,\n\n            /**\n             * The {@link Core.util.drag.DragProxy drag proxy} is a helper object that can be used to display feedback\n             * during a drag.\n             * @config {DragProxyConfig|Core.util.drag.DragProxy}\n             */\n            dragProxy : {\n                $config : ['lazy', 'nullify'],\n\n                value : null\n            },\n\n            /**\n             * The outer element where dragging will operate (attach events to it and use as root limit when looking\n             * for ancestors).\n             * @config {HTMLElement}\n             */\n            dragRootElement : {\n                $config : 'nullify',\n\n                value : null\n            },\n\n            /**\n             * Set to `true` to allow a drag to drop on to the same element from which the drag started.\n             * @config {Boolean}\n             * @default\n             */\n            dragSameTargetDrop : false,\n\n            /**\n             * A CSS selector used to determine which element(s) can be dragged.\n             * @config {String}\n             * @default\n             */\n            dragSelector : null,\n\n            /**\n             * A CSS selector used to identify child element(s) that should not trigger drag.\n             * @config {String}\n             */\n            ignoreSelector : null,\n\n            /**\n             * The number of milliseconds after a pointerup to ignore click events on the document. This\n             * is used to avoid the \"up\" event itself generating a `click` on the target.\n             * @config {Number}\n             * @default\n             */\n            dragSwallowClickTime : 50,\n\n            /**\n             * The amount of pixels to move pointer/mouse before it counts as a drag operation.\n             * @config {Number}\n             * @default\n             */\n            dragThreshold : 5,\n\n            /**\n             * The number of milliseconds that must elapse after a `touchstart` event before it is considered a drag. If\n             * movement occurs before this time, the drag is aborted. This is to allow touch swipes and scroll gestures.\n             * @config {Number}\n             * @default\n             */\n            dragTouchStartDelay : 300,\n\n            /**\n             * The CSS selector to use to identify the closest valid target from the event target.\n             * @config {String}\n             */\n            dropTargetSelector : null,\n\n            /**\n             * The {@link #config-dragSelector} item the mouse is currently over.\n             * @member {HTMLElement} overItem\n             * @readonly\n             */\n            overItem : null,\n\n            testConfig : {\n                dragSwallowClickTime : 50\n            }\n        };\n    }\n\n    static get properties() {\n        return {\n            /**\n             * The CSS class to add to the {@link #config-dragRootElement} (or {@link #config-draggingClsSelector} from\n             * there) as soon as the pointerdown event occurs.\n             * @member {String}\n             * @readonly\n             */\n            draggingCls : 'b-draggable-active',\n\n            /**\n             * The CSS class to add to the `body` element as soon as the {@link #config-dragThreshold} is reached and\n             * an actual drag is in progress.\n             * @member {String}\n             * @readonly\n             */\n            draggingBodyCls : 'b-draghelper-active',  // match DragHelper since we need the same treatment\n\n            /**\n             * The CSS class to add to the element being dragged as soon as the pointerdown event occurs.\n             * @member {String}\n             * @readonly\n             */\n            draggingItemCls : 'b-dragging-item',\n\n            /**\n             * The CSS class to add to the {@link #config-dragRootElement} (or {@link #config-draggingClsSelector} from\n             * there) as soon as the {@link #config-dragThreshold} is reached and an actual drag is in progress.\n             * @member {String}\n             * @readonly\n             */\n            draggingStartedCls : 'b-draggable-started',\n\n            /**\n             * The CSS class that is added to the {@link #config-dragRootElement}, i.e., `'b-draggable'`.\n             * @property {String}\n             * @readonly\n             */\n            draggableCls : 'b-draggable'\n        };\n    }\n\n    //endregion\n\n    //region Drag Processing\n    // These template methods are implemented by derived classes as desired. There is only one overlap with Droppable's\n    // template methods (dragDrop) so that a class can easily mixin both Draggable and Droppable and always distinguish\n    // whether it is acting as the source, the target, or both.\n\n    /**\n     * This template method is called when the mousedown of a potential drag operation occurs. This happens before the\n     * gesture is known to be a drag, meaning the {@link #config-dragThreshold} has not been reached. This method\n     * should initialize the {@link Core.util.drag.DragContext} using the {@link Core.util.drag.DragContext#function-set}\n     * method. Alternatively, this method may return `false` to prevent the drag operation.\n     *\n     * *Important:* Because no drag has occurred at the time this method is called, only minimal processing should be\n     * done (such as initializing the {@link Core.util.drag.DragContext}). Anything more should be done in the\n     * {@link #function-dragStart} method or in response to the {@link #event-dragStart} event which happen only if\n     * the user drags the mouse before releasing the mouse button.\n     * @param {Core.util.drag.DragContext} drag\n     */\n    beforeDrag(drag) {\n        const\n            { dragRootElement, dragSelector, ignoreSelector } = this,\n            target = dragSelector && drag.element.closest(dragSelector);\n\n        return !dragSelector || Boolean(target &&\n            target === dragRootElement ||\n            (dragRootElement.contains(target) && (!ignoreSelector || !drag.element.matches(ignoreSelector)))\n        );\n    }\n\n    /**\n     * This template method is called when the drag operation starts. This occurs when the {@link #config-dragThreshold}\n     * has been reached.\n     * Your implementation may return `false` to prevent the startup of the drag operation.\n     * @param {Core.util.drag.DragContext} drag\n     */\n    dragStart(drag) {\n        // template\n    }\n\n    /**\n     * This template method is called as the drag moves. This occurs on each mouse/pointer/touchmove event.\n     * @param {Core.util.drag.DragContext} drag\n     */\n    dragOver(drag) {\n        // template\n    }\n\n    /**\n     * This template method is called when the drag enters a {@link Core.mixin.Droppable target}.\n     * @param {Core.util.drag.DragContext} drag\n     */\n    dragEnterTarget(drag) {\n        // template\n    }\n\n    /**\n     * This template method is called when the drag leaves a {@link Core.mixin.Droppable target}.\n     * @param {Core.util.drag.DragContext} drag\n     * @param {Core.mixin.Droppable} oldTarget The previous value of `drag.target`.\n     */\n    dragLeaveTarget(drag, oldTarget) {\n        // template\n    }\n\n    /**\n     * This template method is called when the drag operation completes. This occurs on the pointerup event.\n     *\n     * This method is not called if the drag is {@link Core.util.drag.DragContext#property-aborted}.\n     * @param {Core.util.drag.DragContext} drag\n     */\n    dragDrop(drag) {\n        // template\n    }\n\n    /**\n     * This template method is called when the drag operation completes. This occurs on the pointerup event or perhaps\n     * a keypress event.\n     *\n     * This method is always called, even if the drag is {@link Core.util.drag.DragContext#property-aborted}.\n     * @param {Core.util.drag.DragContext} drag\n     */\n    dragEnd(drag) {\n        // template\n    }\n\n    //endregion\n\n    //region Drag Management\n    // These methods are called by the DragContext and generally manage element updates (adding/removing classes) or\n    // event firing. In most cases these methods then call a corresponding Drag Processing template method intended\n    // for derived classes to implement.\n\n    get activeDrag() {\n        const { dragging : drag } = this;\n\n        return (drag?.started && !drag.completed) ? drag : null;\n    }\n\n    /**\n     * Return the `Events` instance from which drag events are fired.\n     * @internal\n     * @property {Core.mixin.Events}\n     */\n    get dragEventer() {\n        return this.trigger ? this : null;  // simple Events feature detector\n    }\n\n    get draggingClassElement() {\n        const { draggingClsSelector, dragRootElement } = this;\n\n        return draggingClsSelector ? dragRootElement?.closest(draggingClsSelector) : dragRootElement;\n    }\n\n    beginDrag(drag) {\n        const { draggingCls, draggingClassElement } = this;\n\n        if (draggingCls && draggingClassElement) {\n            draggingClassElement.classList.add(draggingCls);\n            drag.cleaners.push(() => draggingClassElement.classList.remove(draggingCls));\n        }\n    }\n\n    async endDrag(drag) {\n        const\n            me = this,\n            { dragEventer, dragProxy } = me;\n\n        if (drag.valid) {\n            // The implementation may be async. If so, any Promise must always be\n            // propagated back to a point which may have to await it\n            await me.dragDrop(drag);\n        }\n\n        if (me.isDestroyed) {\n            return;\n        }\n\n        if (drag.pending) {\n            drag.destroy();\n        }\n        else {\n            me.dragEnd(drag);\n            dragProxy?.dragEnd(drag);\n\n            /**\n             * This event is fired when a drag gesture is completed due to the user aborting it (with the `ESC` key) or\n             * if the {@link Core.util.drag.DragContext#function-abort} method was called.\n             * @event dragCancel\n             * @param {Core.mixin.Draggable} source The draggable instance that fired the event.\n             * @param {Core.util.drag.DragContext} drag The drag context.\n             * @param {Event} event The browser event.\n             */\n            /**\n             * This event is fired when a drag gesture is completed successfully.\n             *\n             * This event is **not** fired if the drag was aborted by the user pressing the `ESC` key or if the\n             * {@link Core.util.drag.DragContext#function-abort} method was called.\n             * @event drop\n             * @param {Core.mixin.Draggable} source The draggable instance that fired the event.\n             * @param {Core.util.drag.DragContext} drag The drag context.\n             * @param {Event} event The browser event.\n             */\n            dragEventer?.trigger(drag.valid ? 'drop' : 'dragCancel', { drag, event : drag.event });\n\n            // The drag context could have registered finalizers added by the above methods or event. If so, we need to\n            // wait for finalization of the drag before we clear our \"dragging\" config.\n            me.finalizeDrag(drag);\n        }\n    }\n\n    async finalizeDrag(drag) {\n        await drag.finalize?.();\n\n        // The doFinalize() method of DragContext is called by the above await... which nulls our \"dragging\" config\n    }\n\n    moveDrag(drag) {\n        if (this.dragOver(drag) !== false) {\n            const { dragEventer, dragProxy } = this;\n\n            dragProxy?.dragMove(drag);\n\n            /**\n             * This event is fired as a drag gesture progresses due to cursor movement.\n             * @event drag\n             * @param {Core.mixin.Draggable} source The draggable instance that fired the event.\n             * @param {Core.util.drag.DragContext} drag The drag context.\n             * @param {Event} event The browser event.\n             */\n            dragEventer?.trigger('drag', { drag, event : drag.event });\n        }\n    }\n\n    setupDragContext(event) {\n        const\n            me = this,\n            { dragItemSelector, id } = me,\n            { target } = event;\n\n        return {\n            event,\n            id              : id ? `${id}-drag-${me._nextDragId = (me._nextDragId || 0) + 1}` : null,\n            itemElement     : dragItemSelector ? target.closest(dragItemSelector) : target,\n            touchStartDelay : me.dragTouchStartDelay,\n            source          : me,\n            threshold       : me.dragThreshold\n        };\n    }\n\n    startDrag(drag) {\n        const\n            { draggingStartedCls, draggingClassElement, draggingItemCls, dragEventer, dragProxy } = this,\n            { itemElement } = drag;\n\n        /**\n         * This event is fired prior to starting a drag gesture. This does not occur immediately after the user\n         * performs the pointer/mousedown/touchstart but only after the {@link #config-dragThreshold} amount of\n         * movement has taken place.\n         *\n         * The drag is canceled if a listener returns `false`.\n         * @event beforeDragStart\n         * @param {Core.mixin.Draggable} source The draggable instance that fired the event.\n         * @param {Core.util.drag.DragContext} drag The drag context.\n         * @param {Event} event The browser event.\n         * @preventable\n         */\n        if (dragEventer?.trigger('beforeDragStart', { drag, event : drag.event }) === false) {\n            return false;\n        }\n\n        if (draggingStartedCls && draggingClassElement) {\n            draggingClassElement.classList.add(draggingStartedCls);\n            drag.cleaners.push(() => draggingClassElement.classList.remove(draggingStartedCls));\n        }\n\n        if (draggingItemCls && itemElement) {\n            itemElement.classList.add(draggingItemCls);\n            drag.cleaners.push(() => itemElement.classList.remove(draggingItemCls));\n        }\n\n        dragProxy?.dragStart(drag);\n\n        const result = this.dragStart(drag);\n\n        if (result !== false) {\n            /**\n             * This event is fired when a drag gesture has started. This does not occur immediately after the user\n             * performs the pointer/mousedown/touchstart but only after the {@link #config-dragThreshold} amount of\n             * movement has taken place.\n             * @event dragStart\n             * @param {Core.mixin.Draggable} source The draggable instance that fired the event.\n             * @param {Core.util.drag.DragContext} drag The drag context.\n             * @param {Event} event The browser event.\n             */\n            dragEventer?.trigger('dragStart', { drag, event : drag.event });\n        }\n\n        return result;\n    }\n\n    trackDrag(drag) {\n        const { dropTargetSelector } = this;\n\n        drag.valid = !(dropTargetSelector && !drag.targetElement?.closest(dropTargetSelector));\n\n        this.moveDrag(drag);\n    }\n\n    //endregion\n\n    //region Configs\n\n    configureListeners(drag) {\n        const\n            me = this,\n            listeners = ObjectHelper.assign({\n                thisObj : me\n            }, me.dragDocumentListeners);\n\n        // Only listen for the events related to how the drag was initiated:\n        if ('touches' in drag.startEvent) {\n            delete listeners.mousemove;\n            delete listeners.mouseup;\n        }\n        else {\n            delete listeners.contextmenu;\n            delete listeners.touchmove;\n            delete listeners.touchend;\n            delete listeners.pointerup;\n        }\n\n        return listeners;\n    }\n\n    //endregion\n\n    //region Configs\n\n    updateDragging(drag, old) {\n        const me = this;\n\n        if (drag) {\n            const listeners = me.configureListeners(drag);\n\n            drag.cleaners.push(EventHelper.on(listeners));\n\n            me.beginDrag(drag);\n        }\n        else if (old) {\n            old.destroy();\n        }\n    }\n\n    changeDragProxy(config, existing) {\n        return DragProxy.reconfigure(existing, config, {\n            owner : this,\n\n            defaults : {\n                owner : this\n            }\n        });\n    }\n\n    updateDragRootElement(rootEl, was) {\n        const\n            me = this,\n            {\n                draggableCls,\n                dragItemSelector,\n                onDragItemMouseMove\n            }  = me;\n\n        was?.classList.remove(draggableCls);\n        me._dragRootDetacher?.();\n\n        if (rootEl) {\n            const listeners = {\n                thisObj    : me,\n                element    : rootEl,\n                mousedown  : 'onDragMouseDown',\n                // We have touchstart listener in place since Siesta/Chrome can send these events even on non-touch\n                // devices:\n                touchstart : 'onDragTouchStart',\n\n                // On iOS, because we use pointerup to represent the drop gesture,\n                // the initiating pointerdown event is captured, and its target is\n                // the original start target. We must always release pointer capture.\n                // https://github.com/bryntum/support/issues/4111\n                pointerdown : e => e.pointerId && e.target.releasePointerCapture?.(e.pointerId)\n            };\n\n            if (onDragItemMouseMove) {\n                listeners.mousemove = {\n                    delegate : dragItemSelector,\n                    handler  : 'onDragItemMouseMove'\n                };\n            }\n\n            if (me.dragItemOverCls || onDragItemMouseMove || me.onDragItemMouseEnter || me.onDragItemMouseLeave) {\n                Object.assign(listeners, {\n                    mouseover : {\n                        delegate : dragItemSelector,\n                        handler  : 'onDragItemMouseOver'\n                    },\n                    mouseout : {\n                        delegate : dragItemSelector,\n                        handler  : 'onDragItemMouseOut'\n                    }\n                });\n            }\n\n            rootEl.classList.add(draggableCls);\n            me._dragRootDetacher = EventHelper.on(listeners);\n        }\n    }\n\n    //endregion\n\n    //region Events\n\n    onDragItemMouseOver(event) {\n        this.overItem = event;\n    }\n\n    onDragItemMouseOut(event) {\n        if (!this.dragging) {\n            this.overItem = event;\n        }\n    }\n\n    changeOverItem(event) {\n        this.enterLeaveEvent = event;\n\n        if (event.type === 'mouseout') {\n            // Must return null, not undefined to unset the overItem property\n            return event.relatedTarget?.closest(this.dragItemSelector) || null;\n        }\n        else {\n            return event.target.closest(this.dragItemSelector);\n        }\n    }\n\n    updateOverItem(overItem, oldOverItem) {\n        const\n            me                  = this,\n            { dragItemOverCls } = me;\n\n        if (oldOverItem) {\n            dragItemOverCls && oldOverItem.classList.remove(dragItemOverCls);\n            me.onDragItemMouseLeave?.(me.enterLeaveEvent, oldOverItem);\n        }\n\n        if (overItem) {\n            dragItemOverCls && overItem.classList.add(dragItemOverCls);\n            me.onDragItemMouseEnter?.(me.enterLeaveEvent, overItem);\n        }\n    }\n\n    onDragContextMenu(event) {\n        event.preventDefault();\n    }\n\n    onDragKeyDown(event) {\n        this.dragging.keyDown(event);\n    }\n\n    onDragKeyUp(event) {\n        this.dragging.keyUp(event);\n    }\n\n    /**\n     * Grab draggable element on mouse down.\n     * @param {Event} event\n     * @private\n     */\n    onDragMouseDown(event) {\n        // only dragging with left mouse button\n        if (event.button === 0) {\n            this.onDragPointerDown(event);\n        }\n    }\n\n    /**\n     * Grab draggable element on pointerdown.\n     * @param {Event} event\n     * @private\n     */\n    onDragPointerDown(event) {\n        let { dragging : drag } = this;\n\n        // If a drag is ongoing already, finalize it and don't proceed with new drag (happens if user does pointerup\n        // outside browser window). Also handles the edge case of trying to start a new drag while previous is awaiting\n        // finalization, in which case it just bails out.\n        if (!drag) {\n            drag = this.setupDragContext(event);\n\n            // The DragContext consults our beforeDrag handler, and if that succeeds, the Context injects itself into\n            // this instance as our draggable (\"this.dragging\").\n            // NOTE: This is not yet an actual drag. At this stage, the context is used to detect movement prior to\n            // mouseup (aka \"a drag\"). Should the requisite amount of movement occur, the drag will be started.\n            if (drag) {\n                drag = new DragContext(drag);\n\n                if (drag.begin() === false) {\n                    drag.destroy();\n                }\n            }\n        }\n        else if (!drag.isFinalizing) {\n            drag.abort();\n        }\n    }\n\n    // Set by the DragContext in its begin method, and auto-nullified at destruction.\n    changeDragging(value, was) {\n        was?.destroy();\n        return value;\n    }\n\n    onDragPointerMove(event) {\n        const { dragging : drag } = this;\n\n        if (drag && !drag.completed) {\n            drag?.move(event);\n        }\n    }\n\n    onDragPointerUp(event) {\n        const { dragging : drag } = this;\n\n        if (drag && !drag.completed) {\n            drag.end(event);\n\n            this.endDrag(drag);\n        }\n    }\n\n    /**\n     * @param {Event} event\n     * @private\n     */\n    onDragTouchStart(event) {\n        // only allowing one finger for now...\n        if (event.touches.length === 1) {\n            this.onDragPointerDown(event);\n        }\n    }\n\n    //endregion\n};\n", "import Base from '../Base.js';\nimport DomDataStore from '../data/DomDataStore.js';\n\n/**\n * @module Core/mixin/Droppable\n */\n\n/**\n * Mix this into another class to enable drop support and receive drops from {@link Core.mixin.Draggable draggables}.\n *\n * There are 4 basic methods that a droppable implements. These methods are called as drag operations occur:\n *\n * ```javascript\n *  class MyDroppable extends Base.mixin(Droppable) {\n *      dragEnter(drag) {\n *          // a drag has entered the drop zone... create some type of drop indicator perhaps\n *      }\n *\n *      dragMove(drag) {\n *          // a drag has changed position... update drop indicators\n *      }\n *\n *      dragDrop(drag) {\n *          // drop has occurred... process data from the drag context\n *      }\n *\n *      dragLeave(drag) {\n *          // the drag has left the drop zone... cleanup indicators\n *      }\n *  }\n * ```\n *\n * Instances of `Droppable` are associated with an element to receive drag operations:\n *\n * ```javascript\n *  let target = new MyDroppable({\n *      dropRootElement : someElement\n *  });\n * ```\n *\n * @mixin\n * @internal\n */\nexport default Target => class Droppable extends (Target || Base) {\n    static get $name() {\n        return 'Droppable';\n    }\n\n    //region Configs\n\n    static get configurable() {\n        return {\n            /**\n             * A selector, which, if specified, narrows the dropability to child elements of the\n             * {@link #config-dropRootElement} which match this selector.\n             * @config {String}\n             */\n            droppableSelector : null,\n\n            /**\n             * The current `DragContext`. This is set when a drag enters this target. Changing this config causes the\n             * {@link #function-dragEnter} and {@link #function-dragLeave} methods to be called. If `dragEnter` returns\n             * `false` for a drag, this value will be set to `null`.\n             * @member {Core.util.drag.DragContext}\n             * @readonly\n             */\n            dropping : null,\n\n            /**\n             * Set this config to the element where drops should be received. When set, the `b-droppable` CSS class is\n             * added to the element and the `Droppable` instance is associated with that element so that it can be\n             * found by {@link Core.mixin.Draggable draggables}.\n             * @config {HTMLElement}\n             */\n            dropRootElement : {\n                $config : 'nullify',\n\n                value : null\n            }\n        };\n    }\n\n    /**\n     * Return the `Events` instance from which drop events are fired.\n     * @internal\n     * @property {Core.mixin.Events}\n     */\n    get dropEventer() {\n        return this.trigger ? this : null;  // simple Events feature detector\n    }\n\n    /**\n     * Returns the CSS class that is added to the {@link #config-dropRootElement}, i.e., `'b-droppable'`.\n     * @property {String}\n     * @readonly\n     */\n    get droppableCls() {\n        return 'b-droppable';\n    }\n\n    //endregion\n    //region Drop Management\n\n    /**\n     * This method is called when a drag enters this droppable's `dropRootElement`. In many cases, this method is used\n     * to create some sort of drop indicator to provide user feedback.\n     *\n     * If this method does not return `false`, the {@link #property-dropping} config will retain the given `drag` context\n     * which was set prior to this method being called.\n     *\n     * If this method returns `false`, the drop will not be accepted. Neither {@link #function-dragDrop} nor\n     * {@link #function-dragLeave} will be called for this drop. If the drag leaves this target and re-enters, this\n     * method will be called again. While `dropping` will already be updated before this method is called, it will be\n     * reset to `null` in this case.\n     *\n     * The base class implementation of this method fires the {@link #event-dragEnter} event.\n     * @param {Core.util.drag.DragContext} drag\n     * @returns {Boolean}\n     */\n    dragEnter(drag) {\n        /**\n         * This event is fired when a drag enters this droppable's `dropRootElement`. It is fired by the droppable's\n         * {@link #function-dragEnter} method.\n         * @event dragEnter\n         * @param {Core.mixin.Draggable} source The draggable instance that fired the event.\n         * @param {Core.util.drag.DragContext} drag The drag context.\n         * @param {Event} event The browser event.\n         */\n        return this.dropEventer?.trigger('dragEnter', { drag, event : drag.event });\n    }\n\n    /**\n     * This method is called when the drag that was previously announced via {@link #function-dragEnter} moves to a new\n     * position. This is typically where drop indicators are updated to reflect the new position.\n     *\n     * The base class implementation of this method fires the {@link #event-dragMove} event.\n     * @param {Core.util.drag.DragContext} drag\n     */\n    dragMove(drag) {\n        /**\n         * This event is fired when the drag that was previously announced via {@link #event-dragEnter} moves to a new\n         * position. It is fired by the droppable's {@link #function-dragMove} method.\n         * @event dragMove\n         * @param {Core.mixin.Draggable} source The draggable instance that fired the event.\n         * @param {Core.util.drag.DragContext} drag The drag context.\n         * @param {Event} event The browser event.\n         */\n        return this.dropEventer?.trigger('dragMove', { drag, event : drag.event });\n    }\n\n    /**\n     * This method is called when the drag that was previously announced via {@link #function-dragEnter} has ended with\n     * a drop. In addition to any cleanup (since {@link #function-dragLeave} will not be called), this method handles\n     * any updates associated with the data from the drag context and the position of the drop.\n     *\n     * The base class implementation of this method fires the {@link #event-drop} event.\n     * @param {Core.util.drag.DragContext} drag\n     */\n    dragDrop(drag) {\n        /**\n         * This event is fired when the drag that was previously announced via {@link #event-dragEnter} has ended with\n         * a drop. It is fired by the droppable's {@link #function-dragDrop} method.\n         *\n         * This event is **not** fired when a drag gesture is aborted by the user pressing the `ESC` key or if the\n         * {@link Core.util.drag.DragContext#function-abort} method is called.\n         * @event drop\n         * @param {Core.mixin.Draggable} source The draggable instance that fired the event.\n         * @param {Core.util.drag.DragContext} drag The drag context.\n         * @param {Event} event The browser event.\n         */\n        return this.dropEventer?.trigger('drop', { drag, event : drag.event });\n    }\n\n    /**\n     * This method is called when the drag that was previously announced via {@link #function-dragEnter} leaves this\n     * droppable's `dropRootElement`, or the drag is {@link Core.util.drag.DragContext#property-aborted} by the user\n     * pressing the `ESC` key, or the {@link Core.util.drag.DragContext#function-abort} method is called.\n     *\n     * This is the time to cleanup anything created by `dragEnter`.\n     *\n     * The base class implementation of this method fires the {@link #event-dragLeave} event.\n     * @param {Core.util.drag.DragContext} drag\n     */\n    dragLeave(drag) {\n        /**\n         * This event is fired when the drag that was previously announced via {@link #event-dragEnter} leaves this\n         * droppable's `dropRootElement`. It is fired by the droppable's {@link #function-dragLeave} method.\n         * @event dragLeave\n         * @param {Core.mixin.Draggable} source The draggable instance that fired the event.\n         * @param {Core.util.drag.DragContext} drag The drag context.\n         * @param {Event} event The browser event.\n         */\n        return this.dropEventer?.trigger('dragLeave', { drag, event : drag.event });\n    }\n\n    //endregion\n    //region Configs\n\n    changeDropping(dropping, was) {\n        if (dropping !== was) {\n            const me = this;\n\n            if (was) {\n                if (was.aborted || !was.completed) {\n                    me.dragLeave(was);\n                }\n            }\n\n            if (dropping) {\n                me._dropping = dropping;  // update config value early in case dragEnter et al refer to it\n\n                if (me.dragEnter(dropping) === false) {\n                    dropping = null;\n                }\n\n                me._dropping = was;  // restore the value so that updateDropping is called as it should be\n            }\n        }\n\n        return dropping;\n    }\n\n    updateDropRootElement(rootEl, was) {\n        const\n            me = this,\n            { droppableCls } = me;\n\n        let droppables, i, removeCls;\n\n        if (was) {\n            droppables = DomDataStore.get(was, 'droppables');\n            removeCls = true;\n\n            if (Array.isArray(droppables) && (i = droppables.indexOf(me)) > -1) {\n                if (droppables.length < 2) {\n                    DomDataStore.remove(was, 'droppables');\n                }\n                else {\n                    droppables.splice(i, 1);\n                    droppables.forEach(d => {\n                        if (droppableCls === d.droppableCls) {\n                            removeCls = false;  // our droppableCls may need to stay\n                        }\n                    });\n                }\n            }\n\n            removeCls && was.classList.remove(droppableCls);\n        }\n\n        if (rootEl) {\n            droppables = DomDataStore.get(rootEl, 'droppables');\n\n            if (droppables) {\n                droppables.push(me);\n            }\n            else {\n                DomDataStore.set(rootEl, 'droppables', [me]);\n            }\n\n            rootEl.classList.add(droppableCls);\n        }\n    }\n\n    //endregion\n};\n", "import Combo from './Combo.js';\nimport './ColorPicker.js';\n\n/**\n * @module Core/widget/ColorField\n */\n\n/**\n * Field that displays a CSS color and lets the user select from a pre-defined\n * {@link #config-colors range of CSS colors}.\n *\n * {@inlineexample Core/widget/ColorField.js}\n *\n * This field can be used as an {@link Grid.column.Column#config-editor} for the {@link Grid.column.Column}.\n *\n * This widget may be operated using the keyboard. `ArrowDown` opens the color picker, which itself is keyboard\n * navigable.\n *\n * ```javascript\n * let colorField = new ColorField({\n *   field: 'color'\n * });\n * ```\n *\n * @extends Core/widget/PickerField\n * @classType colorfield\n * @inputfield\n */\nexport default class ColorField extends Combo {\n    static $name = 'ColorField';\n\n    static type = 'colorfield';\n\n    static configurable = {\n\n        /*\n         * @hideconfigs text,color,editable,picker\n         */\n\n        displayField : 'text',\n        valueField   : 'color',\n        editable     : false,\n        picker       : {\n            type  : 'colorpicker',\n            align : {\n                align     : 't100-b100',\n                matchSize : false\n            }\n        },\n        showBoxForNoColor : true,\n\n        /**\n         * Array of CSS color strings to be able to chose from. This will override the\n         * {@link Core.widget.ColorPicker#config-colors pickers default colors}.\n         *\n         * Provide an array of string CSS colors:\n         * ```javascript\n         * new ColorField({\n         *     colors : ['#00FFFF', '#F0FFFF', '#89CFF0', '#0000FF', '#7393B3']\n         * });\n         * ```\n         *\n         * @prp {String[]}\n         */\n        colors : null,\n\n        /**\n         * Adds an option in the picker to set no background color\n         * @prp {Boolean}\n         */\n        addNoColorItem : true\n    };\n\n    configure(config) {\n        const pickerCfg = config.picker ?? {};\n\n        if (config.colors) {\n            pickerCfg.colors = config.colors;\n        }\n\n        if ('addNoColorItem' in config) {\n            pickerCfg.addNoColorItem = config.addNoColorItem;\n        }\n\n        config.picker = pickerCfg;\n\n        super.configure(config);\n    }\n\n    updatePicker(picker) {\n        if (picker) {\n            this.items = picker.store.records;\n        }\n    }\n\n    updateColors(colors) {\n        if (!this.isConfiguring) {\n            this.picker.colors = colors;\n        }\n    }\n\n    updateAddNoColorItem(addNoColorItem) {\n        if (!this.isConfiguring) {\n            this.picker.addNoColorItem = addNoColorItem;\n        }\n    }\n\n    set value(value) {\n        if (!this.store) {\n            this.items = [];\n            this.store = this.picker.store;\n        }\n\n        if (!value) {\n            value = this.store.findRecord('color', null);\n        }\n\n        super.value = value;\n    }\n\n    showPicker() {\n        // Not happy about this. Previously selected value doesn't trigger refresh\n        this.picker.refresh();\n        super.showPicker(...arguments);\n    }\n\n    get value() {\n        return super.value;\n    }\n\n    syncInputFieldValue(...args) {\n        const\n            me        = this,\n            { value } = me;\n\n        let className = me.picker?.getColorClassName(value);\n\n        if (!className) {\n            me.colorBox.style.color = value;\n        }\n\n        className = 'b-colorbox ' + className;\n\n        me.colorBox.className = className;\n\n        if (!me.showBoxForNoColor) {\n            me.element.classList.toggle('b-colorless', !value);\n        }\n\n        super.syncInputFieldValue(...args);\n    }\n\n    get innerElements() {\n        return [\n            {\n                reference : 'colorBox',\n                className : 'b-colorbox'\n            },\n            ...super.innerElements\n        ];\n    }\n}\n\n// Register this widget type with its Factory\nColorField.initClass();\n", "import Checkbox from './Checkbox.js';\n\n/**\n * @module Core/widget/SlideToggle\n */\n\n/**\n * SlideToggle field is a variation of {@link Core.widget.Checkbox} with a sliding toggle instead of box with check mark.\n * It wraps <code>&lt;input type=\"checkbox\"&gt;</code>.\n * Color can be specified and you can optionally configure {@link #config-text} to display in a label to the right of\n * the toggle in addition to a standard field {@link #config-label}.\n *\n * {@inlineexample Core/widget/SlideToggle.js vertical}\n *\n * This field can be used as an {@link Grid.column.Column#config-editor} for the {@link Grid.column.Column}.\n *\n * @extends Core/widget/Checkbox\n * @classType slidetoggle\n * @inputfield\n */\nexport default class SlideToggle extends Checkbox {\n    static get $name() {\n        return 'SlideToggle';\n    }\n\n    static get type() {\n        return 'slidetoggle';\n    }\n\n    static get properties() {\n        return {\n            toggledCls : 'b-slidetoggle-checked'\n        };\n    }\n\n    construct(config) {\n        if (config?.checked) {\n            config.cls = (config.cls || '') + ' ' + this.constructor.properties.toggledCls;\n        }\n\n        super.construct(config);\n    }\n\n    get innerElements() {\n        const innerEls = super.innerElements;\n\n        innerEls.splice(1, 0, this.toggleElement);\n\n        if (this.text) {\n            innerEls[innerEls.length - 1].class = 'b-slidetoggle-label';\n        }\n        else {\n            // Remove label, not used\n            innerEls.pop();\n        }\n        return innerEls;\n    }\n\n    get toggleElement() {\n        return {\n            class     : 'b-slidetoggle-toggle',\n            reference : 'slideToggle',\n            children  : [\n                {\n                    class     : 'b-slidetoggle-thumb',\n                    reference : 'slideThumb'\n                }\n            ]\n        };\n    }\n\n    internalOnChange() {\n        super.internalOnChange();\n\n        this.element.classList[this.value ? 'add' : 'remove'](this.toggledCls);\n    }\n}\n\nSlideToggle.initClass();\n", "import Base from '../../Base.js';\nimport DomHelper from '../../helper/DomHelper.js';\nimport EventHelper from '../../helper/EventHelper.js';\nimport Tooltip from '../../widget/Tooltip.js';\nimport StringHelper from '../../helper/StringHelper.js';\n\n/**\n * @module Core/widget/util/AvatarRendering\n */\n\n/**\n * An object that describes properties of an avatar.\n *\n * @typedef {Object} AvatarConfig\n * @property {String} initials Resource initials\n * @property {String} color Background color for initials\n * @property {String} iconCls Icon cls\n * @property {String} imageUrl Image url\n * @property {String} defaultImageUrl Default image url, fallback if image fails to load or there is none\n * specified. Leave out to show initials instead.\n * @property {Object} [dataset] Dataset to apply to the resulting element\n * @property {String} [alt] Image description\n */\n\n/**\n * A utility class providing rendering of avatars / resource initials.\n *\n * {@inlineexample Core/widget/AvatarRendering.js}\n * @extends Core/Base\n */\nexport default class AvatarRendering extends Base {\n    static get $name() {\n        return 'AvatarRendering';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * Element used to listen for load errors. Normally the owning widgets own element.\n             * @config {HTMLElement}\n             */\n            element : null,\n\n            /**\n             * Prefix prepended to a supplied color to create a CSS class applied when showing initials.\n             * @config {String}\n             * @default\n             */\n            colorPrefix : 'b-sch-',\n\n            /**\n             * A tooltip config object to enable using a custom tooltip for the avatars. Listen for `beforeShow` and set\n             * your html there.\n             * @config {TooltipConfig}\n             */\n            tooltip : null,\n\n            size : null\n        };\n    }\n\n    doDestroy() {\n        this.tooltip?.destroy();\n\n        super.doDestroy();\n    }\n\n    updateElement(element) {\n        // Error listener\n        EventHelper.on({\n            element,\n            delegate : '.b-resource-image',\n            error    : 'onImageErrorEvent',\n            thisObj  : this,\n            capture  : true\n        });\n    }\n\n    changeTooltip(config) {\n        return Tooltip.new({\n            forElement  : this.element,\n            forSelector : '.b-resource-avatar',\n            cls         : 'b-resource-avatar-tooltip'\n        }, config);\n    }\n\n    static get failedUrls() {\n        if (!this._failedUrls) {\n            this._failedUrls = new Set();\n        }\n        return this._failedUrls;\n    }\n\n    /**\n     * Returns a DOM config object containing a resource avatar, icon or resource initials. Display priority in that\n     * order.\n     * @param {AvatarConfig|AvatarConfig[]} options A single avatar config object or an array of the same.\n     * @returns {DomConfig}\n     */\n    getResourceAvatar(options) {\n        if (Array.isArray(options)) {\n            return options.map(item => this.getResourceAvatar(item));\n        }\n\n        const\n            { initials, color, iconCls, imageUrl, defaultImageUrl, dataset = {}, resourceRecord, alt = StringHelper.encodeHtml(resourceRecord?.name) } = options,\n            config = this.getImageConfig(initials, color, imageUrl, defaultImageUrl, dataset, alt) ||\n                this.getIconConfig(iconCls, dataset) ||\n                this.getResourceInitialsConfig(initials, color, dataset),\n            { size } = this;\n\n        Object.assign(config.style, {\n            ...(size ? { height : size, width : size } : undefined)\n        });\n\n        return config;\n    }\n\n    getImageConfig(initials, color, imageUrl, defaultImageUrl, dataset, alt) {\n        // Fall back to defaultImageUrl if imageUrl is known to fail\n        imageUrl = AvatarRendering.failedUrls.has(imageUrl) ? defaultImageUrl : (imageUrl  || defaultImageUrl);\n\n        if (imageUrl) {\n            return {\n                tag       : 'img',\n                draggable : 'false',\n                loading   : 'lazy',\n                class     : {\n                    'b-resource-avatar' : 1,\n                    'b-resource-image'  : 1\n                },\n                style       : {},\n                alt,\n                elementData : {\n                    defaultImageUrl,\n                    imageUrl,\n                    initials,\n                    color,\n                    dataset\n                },\n                src : imageUrl,\n                dataset\n            };\n        }\n    }\n\n    getIconConfig(iconCls, dataset) {\n        if (iconCls) {\n            return iconCls && {\n                tag   : 'i',\n                style : {},\n                class : {\n                    'b-resource-avatar' : 1,\n                    'b-resource-icon'   : 1,\n                    [iconCls]           : 1\n                },\n                dataset\n            };\n        }\n    }\n\n    getResourceInitialsConfig(initials, color, dataset) {\n        const\n            // eventColor = #FF5555, apply as background-color\n            namedColor = DomHelper.isNamedColor(color) && color,\n            // eventColor = red, add b-sch-red cls\n            hexColor   = !namedColor && color,\n            { size }   = this;\n\n        return {\n            tag   : 'div',\n            class : {\n                'b-resource-avatar'                  : 1,\n                'b-resource-initials'                : 1,\n                [`${this.colorPrefix}${namedColor}`] : namedColor\n            },\n            style : {\n                backgroundColor : hexColor || null,\n                ...(size ? { height : size, width : size } : undefined)\n            },\n            children : [initials],\n            dataset\n        };\n    }\n\n    onImageErrorEvent({ target }) {\n        if (!target.matches('.b-resource-avatar')) {\n            return;\n        }\n\n        const { defaultImageUrl, initials, color, imageUrl, dataset } = target.elementData;\n\n        if (defaultImageUrl && !target.src.endsWith(defaultImageUrl.replace(/^[./]*/gm, ''))) {\n            target.src = defaultImageUrl;\n        }\n        else {\n            const initialsEl = DomHelper.createElement(this.getResourceInitialsConfig(initials, color, dataset));\n            initialsEl.elementData = target.elementData;\n            target.parentElement.replaceChild(initialsEl, target);\n        }\n\n        // Remember failed urls, to avoid trying to load them again next time\n        AvatarRendering.failedUrls.add(imageUrl);\n    }\n}\n"],
  "mappings": "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",
  "names": ["throwAbstractMethodCall", "Error", "ActionBase", "Base", "type", "constructor", "name", "undo", "redo", "_$name", "throwInvalidMethodCall", "StateBase", "canUndo", "stm", "canRedo", "onUndo", "onRedo", "onStartTransaction", "onStopTransaction", "onStopTransactionDelayed", "onRejectTransaction", "onEnable", "onDisable", "onAutoRecordOn", "onAutoRecordOff", "onResetQueue", "onModelUpdate", "onStoreModelAdd", "onStoreModelInsert", "onStoreModelRemove", "onStoreModelRemoveAll", "onModelInsertChild", "onModelRemoveChild", "STATE_PROP", "Symbol", "STORES_PROP", "QUEUE_PROP", "POS_PROP", "TRANSACTION_PROP", "TRANSACTION_TIMER_PROP", "AUTO_RECORD_PROP", "IS_APPLYING_STASH", "Object", "freeze", "registry", "Map", "registerStmState", "state", "set", "resolveStmState", "get", "Registry", "resetQueue", "options", "newProps", "slice", "position", "notifyStoresAboutQueueReset", "DisabledStateClass", "autoRecord", "onStoreRemoveAll", "DisabledState", "ACTION_QUEUE_PROP", "Transaction", "defaultConfig", "title", "construct", "args", "queue", "length", "addAction", "action", "push", "i", "len", "ReadyStateClass", "steps", "curPos", "newPos", "Math", "max", "next", "notifyStoresAboutStateRestoringStart", "undoneTransactions", "transaction", "notifyStoresAboutStateRestoringStop", "cause", "transactions", "min", "redoneTransactions", "notifyStoresAboutStateRecordingStart", "ReadyState", "RecordingStateClass", "notifyStoresAboutStateRecordingStop", "disabled", "stopTransactionDelayed", "getTransactionTitle", "stop", "rejected", "model", "newData", "oldData", "isInitialUserAction", "makeModelUpdateAction", "parentModel", "index", "childModel", "previousParent", "previousIndex", "makeModelInsertChildAction", "childModels", "context", "makeModelRemoveChildAction", "store", "models", "silent", "makeStoreModelAddAction", "makeStoreModelInsertAction", "makeStoreModelRemoveAction", "allRecords", "makeStoreRemoveAllAction", "RecordingState", "RestoringStateClass", "$name", "onQueueReset", "RestoringState", "AutoReadyStateClass", "startTransaction", "AutoReadyState", "AutoRecordingStateClass", "mixin", "Delayable", "timer", "clearTimeout", "setTimeout", "stopTransaction", "autoRecordTransactionStopTimeout", "AutoRecordingState", "rest", "MODEL_PROP", "NEW_DATA_PROP", "OLD_DATA_PROP", "UpdateAction", "undefined", "value", "$", "assign", "Boolean", "PARENT_MODEL_PROP", "CHILD_MODELS_PROP", "INSERT_INDEX_PROP", "CONTEXT_PROP", "InsertChildAction", "insertIndex", "ctx", "byFromParent", "newlyAdded", "Set", "add", "undoTaskData", "parent", "moveRight", "moveLeft", "moveFromAnotherParent", "parentIndex", "values", "sort", "a", "b", "forEach", "removeChild", "task", "insertChild", "_insertBefore$previou", "insertBefore", "children", "orderedBeforeNode", "previousSibling", "nextOrderedSibling", "RemoveChildAction", "lhs", "rhs", "lhsIndex", "rhsIndex", "m", "orderedParentIndex", "STORE_PROP", "MODEL_LIST_PROP", "AddAction", "modelList", "list", "remove", "InsertAction", "_undoingInsertion", "insert", "me", "RemoveAction", "ALL_RECORDS_PROP", "RemoveAllAction", "records", "removeAll", "stateTransition", "event", "oldState", "newState", "call", "Array", "isArray", "trigger", "StateTrackingManager", "Events", "stashedTransactions", "stores", "from", "hasStore", "includes", "addStore", "removeStore", "filter", "s", "forEachStore", "fn", "id", "val", "enabled", "enable", "disable", "isReady", "waitForReadiness", "await", "isRecording", "isApplyingStash", "rejectTransaction", "map", "t", "rawQueue", "isRestoring", "undoAll", "redoAll", "resetUndoQueue", "resetRedoQueue", "_store$onStmRecording", "onStmRecordingStart", "reason", "_store$onStmRecording2", "onStmRecordingStop", "_store$onStmRestoring", "onStmRestoringStart", "_store$onStmRestoring2", "onStmRestoringStop", "_store$onStmQueueRese", "onStmQueueReset", "onUndoKeyPress", "shiftKey", "preventDefault", "stash", "IdHelper", "generateId", "applyStash", "Finalizable", "Target", "finalizer", "finalizing", "isFinalized", "isFinalizing", "doFinalize", "destroy", "finalize", "ret", "_awaitFinalizer", "ABORTED", "INIT", "DRAGGING", "DROPPED", "lockDirections", "x", "y", "DragContext", "Identifiable", "configurable", "itemElement", "scrollManager", "monitoringConfig", "source", "target", "targetElement", "threshold", "touchStartDelay", "identifiable", "altKey", "cleaners", "ctrlKey", "data", "element", "endEvent", "lastMoveEvent", "metaKey", "previousTarget", "scrollerAction", "startEvent", "touchStartTimer", "_valid", "EventHelper", "on", "globalThis", "blur", "thisObj", "doDestroy", "cleanup", "dropping", "dragging", "onWindowBlur", "started", "abort", "aborted", "completed", "isDestroying", "pending", "valid", "v", "Promise", "all", "has", "peek", "changeTarget", "was", "_target", "updateTarget", "dragLeaveTarget", "dragMove", "dragEnterTarget", "updateTargetElement", "droppable", "droppables", "droppableSelector", "parentElement", "DomDataStore", "dropRootElement", "contains", "closest", "DomHelper", "getId", "getBoundingClientRect", "endDrag", "begin", "beforeDrag", "cleaner", "pop", "end", "lastEvent", "dragSwallowClickTime", "syncFlags", "clientX", "clientY", "track", "document", "capture", "expires", "once", "click", "stopPropagation", "dragDrop", "fakeKey", "down", "changed", "isKey", "key", "keyDown", "isDragToggleKey", "keyUp", "getDistance", "getDistanceBetween", "move", "distance", "significant", "nodeType", "Node", "ELEMENT_NODE", "start", "stopImmediatePropagation", "draggingBodyCls", "activeCls", "dragLock", "dragRootElement", "detacher", "startMonitoring", "Objects", "merge", "scrollables", "direction", "callback", "isScroll", "rootEl", "body", "classList", "startDrag", "touch", "changedTouches", "elementFromPoint", "trackDrag", "__publicField", "prototype", "STATE", "DragProxy", "Factoryable", "factoryable", "defaultType", "updateDragging", "drag", "close", "open", "dragStart", "dragEnd", "initClass", "Draggable", "$config", "draggingClsSelector", "dragDocumentListeners", "keydown", "keyup", "contextmenu", "mousemove", "mouseup", "pointerup", "touchend", "touchmove", "handler", "passive", "dragItemSelector", "dragItemOverCls", "dragMinDistance", "dragProxy", "dragSameTargetDrop", "dragSelector", "ignoreSelector", "dragThreshold", "dragTouchStartDelay", "dropTargetSelector", "overItem", "testConfig", "properties", "draggingCls", "draggingItemCls", "draggingStartedCls", "draggableCls", "matches", "dragOver", "oldTarget", "activeDrag", "dragEventer", "draggingClassElement", "beginDrag", "isDestroyed", "finalizeDrag", "_drag$finalize", "moveDrag", "setupDragContext", "_nextDragId", "result", "_drag$targetElement", "configureListeners", "listeners", "ObjectHelper", "old", "changeDragProxy", "config", "existing", "reconfigure", "owner", "defaults", "updateDragRootElement", "_me$_dragRootDetacher", "onDragItemMouseMove", "_dragRootDetacher", "mousedown", "touchstart", "pointerdown", "e", "_e$target$releasePoin", "_e$target", "pointerId", "releasePointerCapture", "delegate", "onDragItemMouseEnter", "onDragItemMouseLeave", "mouseover", "mouseout", "onDragItemMouseOver", "onDragItemMouseOut", "changeOverItem", "enterLeaveEvent", "_event$relatedTarget", "relatedTarget", "updateOverItem", "oldOverItem", "_me$onDragItemMouseLe", "_me$onDragItemMouseEn", "onDragContextMenu", "onDragKeyDown", "onDragKeyUp", "onDragMouseDown", "button", "onDragPointerDown", "changeDragging", "onDragPointerMove", "onDragPointerUp", "onDragTouchStart", "touches", "Droppable", "dropEventer", "droppableCls", "dragEnter", "_this$dropEventer", "_this$dropEventer2", "_this$dropEventer3", "dragLeave", "_this$dropEventer4", "changeDropping", "_dropping", "updateDropRootElement", "removeCls", "indexOf", "splice", "d", "ColorField", "Combo", "configure", "pickerCfg", "picker", "colors", "addNoColorItem", "updatePicker", "items", "updateColors", "isConfiguring", "updateAddNoColorItem", "findRecord", "showPicker", "refresh", "arguments", "syncInputFieldValue", "_me$picker", "className", "getColorClassName", "colorBox", "style", "color", "showBoxForNoColor", "toggle", "innerElements", "reference", "displayField", "valueField", "editable", "align", "matchSize", "SlideToggle", "Checkbox", "toggledCls", "checked", "cls", "innerEls", "toggleElement", "text", "class", "internalOnChange", "AvatarRendering", "colorPrefix", "tooltip", "size", "_this$tooltip", "updateElement", "error", "changeTooltip", "Tooltip", "new", "forElement", "forSelector", "failedUrls", "_failedUrls", "getResourceAvatar", "item", "initials", "iconCls", "imageUrl", "defaultImageUrl", "dataset", "resourceRecord", "alt", "StringHelper", "encodeHtml", "getImageConfig", "getIconConfig", "getResourceInitialsConfig", "height", "width", "tag", "draggable", "loading", "elementData", "src", "namedColor", "isNamedColor", "hexColor", "backgroundColor", "onImageErrorEvent", "endsWith", "replace", "initialsEl", "createElement", "replaceChild"]
}
