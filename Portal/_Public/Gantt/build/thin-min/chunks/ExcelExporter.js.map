{
  "version": 3,
  "sources": ["../../../../Grid/lib/Grid/column/ColorColumn.js", "../../../../Grid/lib/Grid/feature/GroupSummary.js", "../../../../Grid/lib/Grid/feature/Split.js", "../../../../Grid/lib/Grid/util/TableExporter.js", "../../../../Grid/lib/Grid/util/BooleanUnicodeSymbol.js", "../../../../Grid/lib/Grid/feature/experimental/ExcelExporter.js"],
  "sourcesContent": ["import Menu from '../../Core/widget/Menu.js';\nimport Column from './Column.js';\nimport  '../../Core/widget/ColorPicker.js';\nimport ColumnStore from '../data/ColumnStore.js';\n\n/**\n * @module Grid/column/ColorColumn\n */\n\n/**\n * A column that displays color values (built-in color classes or CSS colors) as a colored element similar to\n * the {@link Core.widget.ColorField}. When the user clicks the element, a {@link Core.widget.ColorPicker} lets the user\n * select from a range of colors.\n *\n * {@inlineexample Grid/column/ColorColumn.js}\n *\n * ```javascript\n * new Grid({\n *    columns : [\n *       {\n *          type   : 'color',\n *          field  : 'color',\n *          text   : 'Color'\n *       }\n *    ]\n * });\n * ```\n *\n * @extends Grid/column/Column\n * @classType color\n */\nexport default class ColorColumn extends Column {\n    static $name = 'ColorColumn';\n\n    static type = 'color';\n\n    static fields = [\n        { name : 'colorEditorType', defaultValue : 'colorpicker' },\n\n        /**\n         * Array of CSS color strings to be able to chose from. This will override the\n         * {@link Core.widget.ColorPicker#config-colors pickers default colors}.\n         *\n         * Provide an array of string CSS colors:\n         * ```javascript\n         * new Grid({\n         *    columns : [\n         *       {\n         *          type   : 'color',\n         *          field  : 'color',\n         *          text   : 'Color',\n         *          colors : ['#00FFFF', '#F0FFFF', '#89CFF0', '#0000FF', '#7393B3']\n         *       }\n         *    ]\n         * });\n         * ```\n         * @prp {String[]}\n         */\n        'colors',\n\n        /**\n         * Adds an option in the picker to set no background color\n         * @prp {Boolean}\n         * @default true\n         */\n        { name : 'addNoColorItem', defaultValue : true }\n    ];\n\n    static defaults = {\n        align  : 'center',\n        editor : null\n    };\n\n    construct() {\n        super.construct(...arguments);\n\n        const\n            me       = this,\n            { grid } = me;\n\n        me.menu = new Menu({\n            owner             : grid,\n            rootElement       : grid.rootElement,\n            autoShow          : false,\n            align             : 't50-b50',\n            anchor            : true,\n            internalListeners : {\n                hide() {\n                    me.picker.navigator.activeItem = null;\n                    delete me._editingRecord;\n                }\n            },\n            items : [\n                Object.assign({\n                    type           : me.colorEditorType,\n                    ref            : 'list',\n                    addNoColorItem : me.addNoColorItem,\n                    colorSelected({ color }) {\n                        me._editingRecord?.set(me.field, color);\n                        me.menu.hide();\n                    }\n                }, me.colors?.length ? { colors : me.colors } : {})\n            ]\n        });\n    }\n\n    applyValue(useProp, field, value) {\n        if (!this.isConstructing) {\n            const { picker } = this;\n\n            if (field === 'colors') {\n                picker.colors = value;\n            }\n            else if (field === 'addNoColorItem') {\n                picker.addNoColorItem = value;\n            }\n        }\n\n        super.applyValue(...arguments);\n    }\n\n    get picker() {\n        return this.menu.widgetMap.list;\n    }\n\n    renderer({ value }) {\n        let colorClass      = 'b-empty',\n            backgroundColor = value;\n\n        if (value) {\n            const colorClassName = this.picker.getColorClassName(value);\n\n            if (colorClassName) {\n                colorClass      = colorClassName;\n                backgroundColor = null;\n            }\n            else {\n                colorClass = '';\n            }\n        }\n\n        return {\n            className : 'b-color-cell-inner ' + colorClass,\n            style     : {\n                backgroundColor\n            },\n            'data-btip' : value\n        };\n    }\n\n    onCellClick({ grid, record, target }) {\n        if (target.classList.contains('b-color-cell-inner') && !this.readOnly &&\n            !grid.readOnly && !record.isSpecialRow && !record.readOnly\n        ) {\n            const\n                { picker, menu } = this,\n                value            = record.get(this.field);\n\n            this._editingRecord = record;\n\n            picker.deselectAll();\n            picker.select(value);\n            picker.refresh();\n            menu.showBy(target);\n        }\n    }\n}\n\nColumnStore.registerColumnType(ColorColumn);\n", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport SummaryFormatter from './mixin/SummaryFormatter.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\n\n/**\n * @module Grid/feature/GroupSummary\n */\n\n/**\n * Displays a summary row as a group footer in a grouped grid. Uses same configuration options on columns as\n * {@link Grid.feature.Summary}.\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * ```javascript\n * features : {\n *     group        : 'city',\n *     groupSummary : true\n * }\n * ```\n *\n * @extends Core/mixin/InstancePlugin\n *\n * @demo Grid/groupsummary\n * @classtype groupSummary\n * @feature\n *\n * @inlineexample Grid/feature/GroupSummary.js\n */\nexport default class GroupSummary extends SummaryFormatter(InstancePlugin) {\n    //region Init\n\n    static get $name() {\n        return 'GroupSummary';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * Set to `true` to have group summaries rendered in the group header when a group is collapsed.\n             *\n             * Only applies when {@link #config-target} is `'footer'` (the default).\n             *\n             * @member {Boolean} collapseToHeader\n             */\n            /**\n             * Configure as `true` to have group summaries rendered in the group header when a group is collapsed.\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *    features : {\n             *        groupSummary : {\n             *            collapseToHeader : true\n             *        }\n             *    }\n             * });\n             * ```\n             *\n             * Only applies when {@link #config-target} is `'footer'` (the default).\n             *\n             * @config {Boolean}\n             */\n            collapseToHeader : null,\n\n            /**\n             * Where to render the group summaries to, either `header` to display them in the group header or `footer`\n             * to display them in the group footer (the default).\n             *\n             * @member {'header'|'footer'} target\n             */\n            /**\n             * Where to render the group summaries to, either `header` to display them in the group header or `footer`\n             * to display them in the group footer (the default).\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *    features : {\n             *        groupSummary : {\n             *            target : 'header'\n             *        }\n             *    }\n             * });\n             * ```\n             *\n             * @config {'header'|'footer'}\n             * @default\n             */\n            target : 'footer'\n        };\n    }\n\n    construct(grid, config) {\n        this.grid = grid;\n\n        super.construct(grid, config);\n\n        if (!grid.features.group) {\n            throw new Error('Requires Group feature to work, please enable');\n        }\n\n        this.bindStore(grid.store);\n\n        grid.rowManager.ion({\n            beforeRenderRow : 'onBeforeRenderRow',\n            renderCell      : 'renderCell',\n\n            // The feature gets to see cells being rendered after the Group feature\n            // because the Group feature injects header content into group header rows\n            // and adds rendering info to the cells renderData which we must comply with.\n            // In particular, it calculates the isFirstColumn flag which it adds to\n            // the cell renderData which we interrogate.\n            prio    : 1000,\n            thisObj : this\n        });\n    }\n\n    bindStore(store) {\n        this.detachListeners('store');\n\n        store.ion({\n            name    : 'store',\n            update  : 'onStoreUpdate',\n            // need to run before grids listener, to flag for full refresh\n            prio    : 1,\n            thisObj : this\n        });\n    }\n\n    get store() {\n        return this.grid.store;\n    }\n\n    doDisable(disable) {\n        // Toggle footers if needed\n        this.updateTarget(this.target);\n\n        super.doDisable(disable);\n    }\n\n    changeTarget(target) {\n        ObjectHelper.assertString(target, 'target');\n\n        return target;\n    }\n\n    updateTarget(target) {\n        // Flag that will make the Store insert rows for group footers\n        this.store.useGroupFooters = !this.disabled && target === 'footer';\n\n        // Refresh groups to show/hide footers\n        if (!this.isConfiguring) {\n            this.store.group();\n        }\n    }\n\n    changeCollapseToHeader(collapseToHeader) {\n        ObjectHelper.assertBoolean(collapseToHeader, 'collapseToHeader');\n\n        return collapseToHeader;\n    }\n\n    updateCollapseToHeader() {\n        if (!this.isConfiguring) {\n            this.store.group();\n        }\n    }\n\n    //endregion\n\n    //region Plugin config\n\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['bindStore']\n        };\n    }\n\n    //endregion\n\n    //region Render\n\n    /**\n     * Called before rendering row contents, used to reset rows no longer used as group summary rows\n     * @private\n     */\n    onBeforeRenderRow({ row, record }) {\n        if (row.isGroupFooter && !('groupFooterFor' in record.meta)) {\n            // not a group row.\n            row.isGroupFooter = false;\n            // force full \"redraw\" when rendering cells\n            row.forceInnerHTML = true;\n        }\n        else if (row.isGroupHeader && !record.meta.collapsed) {\n            // remove any summary elements\n            row.eachElement(this.removeSummaryElements);\n        }\n    }\n\n    removeSummaryElements(rowEl) {}\n\n    /**\n     * Called when a cell is rendered, styles the group rows first cell.\n     * @private\n     */\n    renderCell({ column, cellElement, row, record, size, isFirstColumn }) {\n        const\n            me            = this,\n            { meta }      = record,\n            { rowHeight } = me.grid,\n            isGroupHeader = 'groupRowFor' in meta,\n            isGroupFooter = 'groupFooterFor' in meta,\n            targetsHeader = me.target === 'header',\n            rowClasses    = {\n                'b-group-footer'   : 0,\n                'b-header-summary' : 0\n            },\n            isSummaryTarget =\n                // Header cell should have summary content if we are targeting the header or if the group is collapsed\n                // and we are configured with collapseToHeader, excluding the first column which holds the group title\n                (isGroupHeader && (targetsHeader || me.collapseToHeader && meta.collapsed) && !isFirstColumn) ||\n                // Footer cell should have summary content if we are targeting the footer (won't render if collapsed)\n                (isGroupFooter && !targetsHeader);\n\n        // Needed to restore height when summary is no longer displayed\n        if (isGroupHeader || isGroupFooter) {\n            size.height = isGroupHeader ? (size.height || rowHeight) : rowHeight;\n        }\n\n        if (me.store.isGrouped && isSummaryTarget && !me.disabled) {\n            // clear cell before add any HTML in it. if the cell contained widgets, they will be properly destroyed.\n            column.clearCell(cellElement);\n\n            const groupRecord = isGroupHeader ? record : meta.groupRecord;\n\n            row.isGroupFooter = isGroupFooter;\n            row.isGroupHeader = isGroupHeader;\n\n            // This is a group footer row, add css\n            if (isGroupFooter) {\n                rowClasses['b-group-footer'] = 1;\n            }\n            // This is a group header row, add css\n            else {\n                rowClasses['b-header-summary'] = 1;\n            }\n\n            // returns height config or count. config format is { height, count }. where `height is in px and should be\n            // added to value calculated from `count\n            const\n                heightSetting = me.updateSummaryHtml(cellElement, column, groupRecord),\n                count         = typeof heightSetting === 'number' ? heightSetting : heightSetting.count;\n\n            // number of summaries returned, use to calculate cell height\n            if (count > 1) {\n                size.height += (meta.collapsed && !targetsHeader ? 0 : count * rowHeight * 0.1);\n            }\n\n            // height config with height specified, added to cell height\n            if (heightSetting.height) {\n                size.height += heightSetting.height;\n            }\n        }\n\n        // Sync row's classes with its status as a group header or footer.\n        row.assignCls(rowClasses);\n    }\n\n    updateSummaryHtml(cellElement, column, groupRecord) {\n        const records = groupRecord.groupChildren.slice();\n\n        // Group footers should not be included in summary calculations\n        if (records[records.length - 1].isGroupFooter) {\n            records.pop();\n        }\n\n        const html = this.generateHtml(column, records, 'b-grid-group-summary', groupRecord, groupRecord.meta.groupField, groupRecord.meta.groupRowFor);\n\n        // First time, set table\n        if (!cellElement.children.length) {\n            cellElement.innerHTML = html;\n        }\n        // Following times, sync changes\n        else {\n            DomHelper.sync(html, cellElement.firstElementChild);\n        }\n\n        // return summary \"count\", used to set row height\n        return column.summaries ? column.summaries.length : column.sum ? 1 : 0;\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * Updates summaries on store changes (except record update, handled below)\n     * @private\n     */\n    onStoreUpdate({ source : store, changes }) {\n        if (!this.disabled && store.isGrouped) {\n            // If a grouping field is among the changes, StoreGroup#onDataChanged will\n            // take care of the update by re-sorting.\n            if (changes && store.groupers.find(grouper => grouper.field in changes)) {\n                return;\n            }\n            // only update summary when a field that affects summary is changed\n            // <remove-on-release>\n            // TODO: this should maybe be removed, another column might depend on the value for its summary?\n            // </remove-on-release>\n            const shouldUpdate = Object.keys(changes).some(field => {\n                const colField = this.grid.columns.get(field);\n                // check existence, since a field not used in a column might have changed\n                return Boolean(colField) && (Boolean(colField.sum) || Boolean(colField.summaries));\n            });\n\n            if (shouldUpdate) {\n                this.grid.forceFullRefresh = true;\n            }\n        }\n    }\n\n    //endregion\n\n    /**\n     * Refreshes the summaries\n     */\n    refresh() {\n        this.grid.columns.visibleColumns.forEach(column => {\n            if (this.hasSummary(column)) {\n                this.grid.refreshColumn(column);\n            }\n        });\n    }\n\n    hasSummary(column) {\n        return column.sum || column.summaries;\n    }\n}\n\nGroupSummary.featureClass = 'b-group-summary';\n\nGridFeatureManager.registerFeature(GroupSummary);\n", "import ArrayHelper from '../../Core/helper/ArrayHelper.js';\nimport AsyncHelper from '../../Core/helper/AsyncHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport Splitter from '../../Core/widget/Splitter.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from './GridFeatureManager.js';\n\n/**\n * @module Grid/feature/Split\n */\n\nconst\n    startScrollOptions = Object.freeze({\n        animate : false,\n        block   : 'start'\n    }),\n    endScrollOptions = Object.freeze({\n        animate : false,\n        block   : 'end'\n    }),\n    splitterWidth = 7,\n    // Listeners for these events should not be added to splits\n    ignoreListeners     = {\n        split   : 1,\n        unsplit : 1\n    };\n;\n\n/**\n * This feature allows splitting the Grid into multiple views, either by using the cell context menu, or\n * programmatically by calling {@link #function-split split()}.\n *\n * {@inlineexample Grid/feature/Split.js}\n *\n * It handles splitting in 3 \"directions\":\n *\n * - `'horizontal'` - Splitting the grid into 2 sub-views, one above the other.\n * - `'vertical'` - Splitting the grid into 2 sub-views, one to the left of the other.\n * - `'both'` - Splitting the grid into 4 sub-views, one in each corner.\n *\n * Or, by supplying a record and/or a column to split by.\n *\n * The first sub-view (top, left or top-left depending on split direction) is the original grid, and the others are\n * clones of the original. The clones share the same store, columns and selection.\n *\n * Sub-views in the same column sync their scrolling horizontally, and sub-views in the same row sync their scrolling\n * vertically.\n *\n * Sub-views are separated by splitters, that can be dragged to resize the views.\n *\n * Splitting a multi-region grid (two regions supported) only includes the region in which the split was performed in\n * the split view.\n *\n * Splitting works best on grids that use fixed column widths, since flexed columns will resize when the grid is split.\n *\n * ## Splitting programmatically\n *\n * The split feature assigns two methods to the owning grid:\n *\n * - {@link #function-split split()} - Splits the grid into sub-views.\n * - {@link #function-unsplit unsplit()} - Re-joins the sub-views into a single grid.\n *\n * Use them to split programmatically in your app.\n *\n * ```javascript\n * // Split horizontally (eg. at the row in the center of the grid)\n * await grid.split({ direction : 'horizontal' });\n *\n * // Split both ways by a specific column and record\n * await grid.split({\n *    atRecord : grid.store.getById(10),\n *    atColumn : grid.columns.get('city')\n * });\n *\n * // Remove splits, returning to a single grid\n * grid.unsplit();\n * ```\n *\n * ## Splitting using the cell context menu\n *\n * The feature also adds a new sub-menu to the cell context menu, allowing the user to split (or un-split) the grid. See\n * the API documentation for the {@link Grid/feature/CellMenu} feature for more information on how to customize the\n * sub-menu.\n *\n * ## Accessing a sub-view\n * The sub-views are accessed by index. The original grid is at index 0, and the others are as shown below.\n * For 'horizontal' splits:\n *\n * <div style=\"font-size: 0.8em\">\n *     <div style=\"border: 1px solid #ccc; border-bottom: 2px solid #999; padding: 1em; width: 13em\">0 - Original</div>\n *     <div style=\"border: 1px solid #ccc; border-top: none; padding: 1em; width: 13em\">1 - Sub-view</div>\n * </div>\n *\n * For 'vertical' splits:\n *\n * <div style=\"display: flex; flex-direction: row;font-size: 0.8em\">\n *     <div style=\"border: 1px solid #ccc; border-right: 2px solid #999; padding: 1em; width: 13em\">0 - Original</div>\n *     <div style=\"border: 1px solid #ccc; border-left: none; padding: 1em; width: 13em\">1 - Sub-view</div>\n * </div>\n *\n * For 'both' splits:\n *\n * <div style=\"display: flex; flex-flow: row wrap; width : 27em;font-size: 0.8em\">\n *     <div style=\"border: 1px solid #ccc; border-right: 2px solid #999; border-bottom: 2px solid #999; padding: 1em; width: 13em\">0 - Original</div>\n *     <div style=\"border: 1px solid #ccc; border-left: none; border-bottom: 2px solid #999; padding: 1em; width: 13em\">1 - Sub-view</div>\n *     <div style=\"border: 1px solid #ccc; border-right: 2px solid #999;border-top: none; padding: 1em; width: 13em\">2 - Sub-view</div>\n *     <div style=\"border: 1px solid #ccc; border-top: none; border-left: none; padding: 1em; width: 13em\">3 - Sub-view</div>\n * </div>\n *\n * The {@link #property-subViews} property returns an array containing all sub-views, including the original. Note that\n * the property is also exposed on the owning Grid. Access a specific sub-view by index (see illustrations above). For\n * example to access the bottom right sub-view in a 'both' split:\n *\n * ```javascript\n * await grid.split({ direction : 'both' });\n * const bottomRight = grid.subViews[3];\n * await bottomRight.scrollRowIntoView(100);\n * ```\n *\n * ## Troubleshooting\n *\n * The splits are inserted into a container element (which has the `.b-split-container` CSS class), replacing the\n * original grid. If it does not render correctly out of the box, you should make sure that any CSS rules you have that\n * apply size to the grid also applies to the container element.\n *\n * For example if you use a CSS flex rule to size the grid:\n *\n * ```css\n * .b-grid {\n *     // Size grid using flex\n *     flex : 3;\n * }\n * ```\n *\n * Then you should also apply the same rule to the container element:\n *\n * ```css\n * .b-grid,\n * .b-split-container {\n *     flex : 3;\n * }\n * ```\n *\n * {@note}\n * Note that configuration changes at runtime, when already split, are not automatically propagated to the sub-views. If\n * you need to change a config at runtime, either first unsplit the grid, or change it on each sub-view individually. A\n * notable exception from this is that enabling / disabling features at runtime is reflected in the sub-views.\n * {/@note}\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype split\n * @feature\n */\nexport default class Split extends InstancePlugin {\n    static $name = 'Split';\n\n    static featureClass = '';\n\n    static configurable = {\n\n        /**\n         * An array of sub-views. The first sub-view is the original grid, and the others are clones of the original.\n         * See the \"Accessing a sub-view\" section above for more information.\n         *\n         * ```javascript\n         * await grid.split('vertical');\n         * const bottom = grid.subViews[1];\n         * await bottom.scrollRowIntoView(100);\n         * ```\n         *\n         * Note that this property is accessible directly on the grid instance.\n         *\n         * @member {Grid.view.Grid[]} subViews\n         * @on-owner\n         * @readonly\n         * @category Common\n         */\n        subViews : [], // Not a config, but still defined in configurable to allow assigning it in pluginConfig,\n\n        /**\n         * Properties whose changes should be relayed to sub-views at runtime.\n         *\n         * Supply an object with property names as keys, and a truthy value to relay the change, or a falsy value to not\n         * relay it. The object will be merged with the default values.\n         *\n         * By default, these properties are relayed:\n         * * {@link Grid/view/Grid#property-readOnly}\n         * * {@link Grid/view/Grid#property-rowHeight}\n         *\n         * Example of supplying a custom set of properties to relay:\n         * ```javascript\n         * const grid = new Grid({\n         *     features : {\n         *         split : {\n         *             relayProperties : {\n         *                 readOnly : false, // Do not relay readOnly changes\n         *                 myConfig : true   // Relay changes to the myConfig property\n         *             }\n         *         }\n         *     }\n         * }\n         * ```\n         * @config {Object<String,Boolean>}\n         */\n        relayProperties : {\n            value : {\n                readOnly  : 1,\n                rowHeight : 1\n            },\n            $config : {\n                merge : 'merge'\n            }\n        }\n    };\n\n    static pluginConfig = {\n        chain  : ['populateCellMenu', 'afterConfigChange', 'afterAddListener', 'afterRemoveListener'],\n        assign : ['split', 'unsplit', 'subViews', 'syncSplits']\n    };\n\n    // Flag used to ignore column changes that arise from syncing columns\n    #ignoreColumnChanges = false;\n\n    restorers = [];\n\n    doDestroy() {\n        this.unsplit(true);\n\n        super.doDestroy();\n    }\n\n    doDisable(disable) {\n        const me = this;\n\n        if (!me.isConfiguring) {\n            if (disable) {\n                me._disabledSplitOptions = me._splitOptions;\n                me.unsplit();\n            }\n            else if (me._disabledSplitOptions) {\n                me.split(me._disabledSplitOptions);\n                me._disabledSplitOptions = null;\n            }\n        }\n    }\n\n    //region Split / unsplit\n\n    get isSplit() {\n        return Boolean(this.widgets?.length);\n    }\n\n    getClientConfig(appendTo, order, options, config = {}) {\n        const\n            { client }            = this,\n            { subGrids, regions } = client,\n            columns                = client.columns.records.slice(),\n            subGridConfigs         = ObjectHelper.assign({}, client.subGridConfigs);\n\n        // Match current sub-grid sizes\n        client.eachSubGrid(subGrid => {\n            const config = subGridConfigs[subGrid.region];\n            if (subGrid.flex) {\n                config.flex = subGrid.flex;\n            }\n            else {\n                config.width = subGrid.element.style.width;\n            }\n        });\n\n        if (options.atColumn && regions.length > 1 && order > 0) {\n            // Exclude regions to the left of the split\n            const subGridIndex = regions.indexOf(options.atColumn.region);\n\n            for (let i = 0; i < subGridIndex; i++) {\n                const subGrid = subGrids[regions[i]];\n\n                ArrayHelper.remove(columns, ...subGrid.columns.records);\n\n                delete subGridConfigs[regions[i]];\n            }\n        }\n\n        const clientConfig = ObjectHelper.assign({}, client.initialConfig, {\n            appendTo,\n            insertFirst  : null,\n            insertBefore : null,\n            splitFrom    : client,\n            owner        : client.owner,\n            // Use no toolbar or fake empty toolbar for things to line up nicely\n            tbar         : client.initialConfig.tbar && order === 1 ? {\n                height : client.tbar.height,\n                items  : [' ']\n            } : null,\n            // Share store & selection\n            store                    : client.store,\n            selectedRecordCollection : client.selectedRecordCollection,\n            subGridConfigs,\n            // Cannot directly share columns, since there is a 1-1 mapping between column and it's header\n            columns                  : this.cloneColumns(columns),\n            minHeight                : 0,\n            minWidth                 : 0\n        }, config);\n\n        // Listeners are removed from initialConfig during initialization, use non-internal current listeners\n        const appListeners = {};\n        for (const name in client.listeners) {\n            if (!ignoreListeners[name]) {\n                const [listener] = client.listeners[name];\n                if (!listener.$internal) {\n                    appListeners[name] = listener;\n                }\n            }\n        }\n\n        // Not internalListeners on purpose, these are app listeners\n        clientConfig.listeners = appListeners;\n\n        // Hide headers for bottom clone in horizontal split\n        if (options.direction === 'horizontal') {\n            clientConfig.hideHeaders = true;\n        }\n        // Hide headers for bottom clones in both split\n        else if (options.direction === 'both' && order !== 1) {\n            clientConfig.hideHeaders = true;\n        }\n\n        delete clientConfig.data;\n\n        return clientConfig;\n    }\n\n    cloneColumns(source) {\n        return source.flatMap(col => {\n            // Do not clone selection column, it will be injected by GridSelection.\n            // Ditto for the row expander column\n            if (col.meta.isSelectionColumn || col.field === 'expanderActionColumn') {\n                return [];\n            }\n\n            const data = { ...col.data };\n\n            if (col.children) {\n                data.children = col.children.map(child => ({ ...child.data }));\n            }\n\n            // RowNumberColumn \"pollutes\" headerRenderer, will create infinite loop if not cleaned up\n            delete data.headerRenderer;\n            delete data.parentId;\n\n            return data;\n        });\n    }\n\n    cloneClient(appendTo, order, options, config) {\n        const\n            clientConfig = this.getClientConfig(appendTo, order, options, config),\n            clone        = new this.client.constructor(clientConfig);\n\n        clone.element.classList.add('b-split-clone');\n\n        return clone;\n    }\n\n    // Process options, deducing direction, atRecord, etc.\n    processOptions(options) {\n        const\n            { client }                        = this,\n            { atRecord, atColumn, direction } = options;\n\n        if (!direction) {\n            // Infer direction from record & column\n            if (atRecord && atColumn) {\n                options.direction = 'both';\n            }\n            else if (atColumn) {\n                options.direction = 'vertical';\n            }\n            else {\n                options.direction = 'horizontal';\n            }\n        }\n        else {\n            // Only given a direction, cut roughly in half\n            if (direction !== 'vertical' && !atRecord && client.store.count) {\n                const\n                    centerY   = client._bodyRectangle.height / 2 + client.scrollable.y,\n                    centerRow = client.rowManager.getRowAt(centerY, true) ?? client.rowManager.rows[Math.ceil(client.rowManager.rows.length / 2)];\n\n                options.atRecord = client.store.getById(centerRow.id);\n            }\n\n            if (direction !== 'horizontal' && !atColumn) {\n                const bounds = Rectangle.from(client.element);\n\n                // Figure out subgrid intersecting center of grid\n                let centerX = bounds.center.x - bounds.x,\n                    subGrid = client.subGrids[client.regions[0]],\n                    i       = 0,\n                    column  = null;\n\n                while (centerX > subGrid.width) {\n                    centerX -= subGrid.width;\n                    subGrid = client.subGrids[client.regions[++i]];\n                }\n\n                // We want the center column in view, but iteration below is over all columns\n                centerX += subGrid.scrollable.x;\n\n                // Figure out column in the subgrid\n                const { visibleColumns } = subGrid.columns;\n                let x = 0, j = 0;\n                while (x < centerX && j < visibleColumns.length) {\n                    column = visibleColumns[j++];\n                    x += column.element.offsetWidth;\n                }\n\n                options.atColumn = column;\n            }\n        }\n\n        return options;\n    }\n\n    // Create element to contain the splits, it \"both\" mode it will hold a top container and a bottom container.\n    // In single mode, it will hold the splits + splitters directly.\n    createSplitContainer({ direction }) {\n        const\n            { client }  = this,\n            { element } = client;\n\n        return this.splitContainer = DomHelper.createElement({\n            parent    : element.parentElement,\n            className : {\n                'b-split-container'      : 1,\n                [`b-split-${direction}`] : 1,\n                'b-rtl'                  : client.rtl\n            },\n            style : {\n                width  : element.style.width,\n                height : element.style.height\n            },\n            children : [\n                // Split in one dir, use original as first child\n                direction !== 'both' && element,\n                // Split in both directions, make two sub-containers and put original in first\n                direction === 'both' && {\n                    className : 'b-split-top',\n                    children  : [\n                        element\n                    ]\n                },\n                direction === 'both' && {\n                    className : 'b-split-bottom'\n                }\n            ]\n        });\n    }\n\n    // Make the headers of all splits same height. Since headers shrinkwrap, they might differ depending on which\n    // subgrids was cloned to each split\n    syncHeaderHeights() {\n        let maxHeaderHeight = 0;\n\n        // Find tallest header\n        for (const split of this.subViews) {\n            split.eachSubGrid(subGrid => {\n                if (subGrid.header.height > maxHeaderHeight) {\n                    maxHeaderHeight = subGrid.header.height;\n                }\n            });\n        }\n\n        // Apply its height to all headers\n        for (const split of this.subViews) {\n            split.eachSubGrid(subGrid => {\n                subGrid.header.height = maxHeaderHeight;\n            });\n        }\n    }\n\n    // Clones can be created with correct subgrids, in the original we might instead need to hide some when splitting\n    // in a region that is not the last one (locked for example)\n    toggleOriginalSubGrids(options) {\n        const\n            me          = this,\n            { client }  = me,\n            { regions } = client;\n\n        // Split at a column with multiple regions\n        if (options.atColumn && regions.length > 1) {\n            const\n                subGridIndex = regions.indexOf(options.atColumn.region),\n                // Always process the original\n                splits = [client];\n\n            // And the bottom left one in a four way split\n            if (options.direction === 'both') {\n                splits.push(me.subViews[2]);\n            }\n\n            for (const split of splits) {\n                // Hide regions to the right of the split in the original\n                if (subGridIndex + 1 < regions.length) {\n                    const isOriginal = split === client;\n\n                    // Leftmost subgrid to keep visible\n                    const subGrid = split.subGrids[regions[subGridIndex]];\n\n                    // It won't need a splitter when succeeding subgrids are hidden\n                    subGrid.hideSplitter();\n                    isOriginal && me.restorers.push(() => subGrid.showSplitter());\n\n                    // Force flex to fill space left by hiding succeeding subgrids\n                    if (!subGrid.flex) {\n                        // Don't affect other splits\n                        client.inForEachOther = true;\n                        subGrid.flex = 1;\n                        client.inForEachOther = false;\n\n                        isOriginal && me.restorers.push(() => {\n                            subGrid.flex = null;\n                            subGrid.width = subGrid._initialWidth;\n                        });\n                    }\n\n                    // Hide succeeding subgrids\n                    for (let i = subGridIndex + 1; i < regions.length; i++) {\n                        const subGrid = split.subGrids[regions[i]];\n                        subGrid.hide();\n\n                        isOriginal && me.restorers.push(() => {\n                            subGrid.show();\n                        });\n                    }\n\n                    // Only one subgrid remains visible, use its width as splits width\n                    if (regions.length === 2) {\n                        split._initialWidth = split.element.style.width;\n                        split._initialFlex = split.flex;\n\n                        split.width = subGrid._initialWidth;\n\n                        isOriginal && me.restorers.push(() => {\n                            if (split._initialFlex !== null) {\n                                split.flex = split._initialFlex;\n                            }\n                            else if (split._initialWidth !== null) {\n                                split.width = split._initialWidth;\n                            }\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Split the grid into two or four parts.\n     *\n     * - Splits into two when passed `direction : 'vertical'`, `direction : 'horizontal'` or `atColumn` or `atRecord`.\n     * - Splits into four when passed `direction : 'both'` or `atColumn` and `atRecord`.\n     *\n     * ```javascript\n     * // Split horizontally (at the row in the center of the grid)\n     * await grid.split({ direction : 'horizontal' });\n     *\n     * // Split both ways by a specific column and record\n     * await grid.split({\n     *    atRecord : grid.store.getById(10),\n     *    atColumn : grid.columns.get('city')\n     * });\n     * ```\n     *\n     * To return to a single grid, call {@link #function-unsplit}.\n     *\n     * Note that this function is callable directly on the grid instance.\n     *\n     * @param {Object} [options] Split options\n     * @param {'vertical'|'horizontal'|'both'} [options.direction] Split direction, 'vertical', 'horizontal' or 'both'.\n     * Not needed when passing `atColumn` or `atRecord`.\n     * @param {Grid.column.Column} [options.atColumn] Column to split at\n     * @param {Core.data.Model} [options.atRecord] Record to split at\n     * @returns {Promise} Resolves when split is complete, and subviews are scrolled to the correct position.\n     * @async\n     * @on-owner\n     * @category Common\n     */\n    async split(options = {}) {\n        const\n            me         = this,\n            { client } = me;\n\n        // Can't split a split\n        if (client.splitFrom) {\n            return;\n        }\n\n        if (me.isSplit) {\n            await me.unsplit(true);\n        }\n\n        const\n            { rtl }                           = client,\n            { atRecord, atColumn, direction } = me.processOptions(options);\n\n        let { splitX, remainingWidth } = options,\n            splitY                     = null,\n            remainingHeight            = null;\n\n        if (atRecord) {\n            await client.scrollRowIntoView(atRecord);\n\n            const row = client.getRowFor(atRecord);\n            if (!row) {\n                throw new Error(`Could not find row for record ${atRecord.id}`);\n            }\n\n            splitY = Rectangle.from(row.cells[0], client.element).bottom;\n            remainingHeight = Rectangle.from(client.element).height - splitY;\n        }\n\n        if (atColumn && !splitX) {\n            splitX = Rectangle.from(atColumn.element, client.element).getEnd(rtl);\n            remainingWidth = Rectangle.from(client.element).width - splitX - DomHelper.scrollBarWidth;\n\n            if (rtl) {\n                const x = splitX;\n                splitX = remainingWidth + DomHelper.scrollBarWidth;\n                remainingWidth = x - DomHelper.scrollBarWidth;\n            }\n        }\n\n        const\n            scrollPromises        = [],\n            splitContainer        = me.createSplitContainer(options),\n            { visibleColumns }    = client.columns,\n            nextColumn            = atColumn ? visibleColumns[visibleColumns.indexOf(atColumn) + 1] : null,\n            nextRecord            = atRecord ? client.store.getNext(atRecord) : null;\n\n        client.eachSubGrid(subGrid => subGrid._initialWidth = subGrid.width);\n\n        if (direction !== 'both') {\n            const cloneConfig = {\n                flex   : `0 0 ${(splitY != null ? remainingHeight : remainingWidth) - splitterWidth}px`,\n                height : null\n            };\n\n            // Horizontal or vertical, only needs one splitter and one clone\n            const [, clone] = me.widgets = [\n                new Splitter({ appendTo : splitContainer }),\n                me.cloneClient(splitContainer, direction === 'vertical' ? 1 : 0, options, cloneConfig)\n            ];\n\n            if (splitX != null) {\n                // It does not like being thrown around in DOM and resized when scrolled, fix up\n                client.renderRows();\n\n                // Don't bother scrolling here if given a date, Schedulers feature handles that\n                if (!options.atDate) {\n                    scrollPromises.push(client.scrollColumnIntoView(atColumn, endScrollOptions));\n                    nextColumn && scrollPromises.push(clone.scrollColumnIntoView(nextColumn, startScrollOptions));\n                }\n            }\n\n            if (splitY != null) {\n                // Always have an atRecord to split at\n                scrollPromises.push(clone.scrollRowIntoView(nextRecord, startScrollOptions));\n            }\n\n            client.element.classList.add('b-split-start');\n            clone.element.classList.add('b-split-end');\n\n            // Sync scrolling\n            client.scrollable.addPartner(clone.scrollable, {\n                x : direction === 'horizontal',\n                y : direction !== 'horizontal'\n            });\n        }\n        else {\n            const rightConfig = {\n                flex : `0 0 ${remainingWidth - splitterWidth}px`\n            };\n\n            splitContainer.lastElementChild.style.flex = `0 0 ${remainingHeight - splitterWidth}px`;\n\n            // Both directions, 3 splitters (one horizontal with full span, two vertical halves) and 3 clones\n            me.widgets = [\n                new Splitter({ insertBefore : splitContainer.lastElementChild }), // Full horizontal\n                me.topSplitter = new Splitter({ appendTo : splitContainer.firstElementChild }), // Top vertical\n                me.cloneClient(splitContainer.firstElementChild, 1, options, rightConfig), // Top right\n                me.cloneClient(splitContainer.lastElementChild, 0, options), // Bottom left\n                me.bottomSplitter = new Splitter({ appendTo : splitContainer.lastElementChild }), // Bottom vertical\n                me.cloneClient(splitContainer.lastElementChild, 2, options, rightConfig) // Bottom right\n            ];\n\n            const\n                topLeft     = client,\n                topRight    = me.widgets[2],\n                bottomLeft  = me.widgets[3],\n                bottomRight = me.widgets[5];\n\n            topLeft.element.classList.add('b-split-top-start');\n            topRight.element.classList.add('b-split-top-end');\n            bottomLeft.element.classList.add('b-split-bottom-start');\n            bottomRight.element.classList.add('b-split-bottom-end');\n\n            if (splitX != null) {\n                // It does not like being thrown around in DOM and resized when scrolled, fix up\n                topLeft.renderRows();\n                bottomLeft.renderRows();\n\n                // Don't bother scrolling here if given a date, Schedulers feature handles that\n                if (atColumn && !options.atDate) {\n                    scrollPromises.push(client.scrollColumnIntoView(atColumn, endScrollOptions));\n                    nextColumn && scrollPromises.push(topRight.scrollColumnIntoView(nextColumn, startScrollOptions));\n                }\n            }\n            if (splitY != null) {\n                scrollPromises.push(\n                    bottomLeft.scrollRowIntoView(nextRecord, startScrollOptions),\n                    bottomRight.scrollRowIntoView(nextRecord, startScrollOptions)\n                );\n            }\n\n            // Sync scrolling\n            topLeft.scrollable.addPartner(topRight.scrollable, 'y');\n            topLeft.scrollable.addPartner(bottomLeft.scrollable, 'x');\n            topRight.scrollable.addPartner(bottomRight.scrollable, 'x');\n            bottomLeft.scrollable.addPartner(bottomRight.scrollable, 'y');\n\n            // Set up vertical splitter sync\n            me.topSplitter.ion({\n                splitterMouseDown : 'onSplitterMouseDown',\n                drag              : 'onSplitterDrag',\n                drop              : 'onSplitterDrop',\n                thisObj           : me\n            });\n\n            me.bottomSplitter.ion({\n                splitterMouseDown : 'onSplitterMouseDown',\n                drag              : 'onSplitterDrag',\n                drop              : 'onSplitterDrop',\n                thisObj           : me\n            });\n        }\n\n        me.subViews = [client, ...me.widgets.filter(w => w.isGridBase)];\n\n        me.toggleOriginalSubGrids(options);\n\n        me.syncHeaderHeights();\n\n        me._splitOptions = options;\n\n        await Promise.all(scrollPromises);\n\n        // Moving in DOM does not seem to trigger resize, do it manually\n        const bounds = Rectangle.from(client.element);\n        client.onInternalResize(client.element, bounds.width, bounds.height);\n\n        client.eachSubGrid(subGrid => {\n            const subGridBounds = Rectangle.from(subGrid.element);\n            subGrid.onInternalResize(subGrid.element, subGridBounds.width, subGridBounds.height);\n        });\n\n        // If scrolled, the original element gets out of sync when moved around in DOM\n        client.scrollable.x += 0.5;\n        client.scrollable.y += 0.5;\n\n        me.startSyncingColumns();\n\n        /**\n         * Fires when splitting the Grid.\n         * @event split\n         * @param {Grid.view.GridBase[]} subViews The sub views created by the split\n         * @param {Object} options The options passed to the split call\n         * @param {'horizontal'|'vertical'|'both'} options.direction The direction of the split\n         * @param {Grid.column.Column} options.atColumn The column to split at\n         * @param {Core.data.Model} options.atRecord The record to split at\n         * @on-owner\n         */\n        client.trigger('split', { subViews : me.subViews, options });\n\n        return me.subViews;\n    }\n\n    /**\n     * Remove splits, returning to a single grid.\n     *\n     * Note that this function is callable directly on the grid instance.\n     *\n     * @on-owner\n     * @async\n     * @category Common\n     */\n    async unsplit(silent = false) {\n        const\n            me          = this,\n            { client }  = me,\n            { element } = client;\n\n        if (me.isSplit) {\n            me.stopSyncingColumns();\n\n            me.widgets?.forEach(split => split.destroy());\n            me.widgets = null;\n\n            // Safari & FF looses scroll position when moving elements around in DOM,\n            // but reading it here fixes it\n            client.eachSubGrid(subGrid => subGrid.scrollable.x);\n            client.scrollable.y;\n\n            me.splitContainer.parentElement.appendChild(element);\n            me.splitContainer.remove();\n            me.splitContainer = null;\n\n            // Reset any size applied by splitter\n            element.style.flexBasis = element.style.flexGrow = '';\n            element.classList.remove('b-split-top-start', 'b-split-start');\n\n            me.subViews.length = 0;\n\n            if (!me.isDestroying) {\n                // We have been pretty violent with the DOM, so force a repaint of rows\n                client.renderRows();\n\n                me.unsplitCleanup();\n\n                for (const restorer of me.restorers) {\n                    restorer();\n                }\n\n                me.restorers.length = 0;\n\n                // Ugly, but FF needs a couple of frames to not lose scroll position if we are splitting again\n                await AsyncHelper.animationFrame();\n                await AsyncHelper.animationFrame();\n\n                if (me.isDestroyed) {\n                    return;\n                }\n\n                /**\n                 * Fires when un-splitting the Grid.\n                 * @event unsplit\n                 * @on-owner\n                 */\n                !silent && client.trigger('unsplit');\n\n                me._splitOptions = null;\n            }\n        }\n    }\n\n    unsplitCleanup() {}\n\n    //endregion\n\n    //region Context menu\n\n    populateCellMenu({ record, column, items }) {\n        const\n            me            = this,\n            { isSplit }   = me,\n            { splitFrom } = me.client;\n\n        if (!me.disabled) {\n            items.splitGrid = {\n                text        : 'L{split}',\n                localeClass : me,\n                icon        : 'b-icon b-icon-split-vertical',\n                weight      : 500,\n                separator   : true,\n                hidden      : isSplit || splitFrom,\n                menu        : {\n                    splitHorizontally : {\n                        text        : 'L{horizontally}',\n                        icon        : 'b-icon b-icon-split-horizontal',\n                        localeClass : me,\n                        weight      : 100,\n                        onItem() {\n                            me.split({ atRecord : record });\n                        }\n                    },\n                    splitVertically : {\n                        text        : 'L{vertically}',\n                        icon        : 'b-icon b-icon-split-vertical',\n                        localeClass : me,\n                        weight      : 200,\n                        onItem() {\n                            me.split({ atColumn : column });\n                        }\n                    },\n                    splitBoth : {\n                        text        : 'L{both}',\n                        icon        : 'b-icon b-icon-split-both',\n                        localeClass : me,\n                        weight      : 300,\n                        onItem() {\n                            me.split({ atColumn : column, atRecord : record });\n                        }\n                    }\n                }\n            };\n\n            items.unsplitGrid = {\n                text        : 'L{unsplit}',\n                localeClass : me,\n                icon        : 'b-icon b-icon-clear',\n                hidden      : !(isSplit || splitFrom),\n                weight      : 400,\n                separator   : true,\n                onItem() {\n                    (splitFrom || me).unsplit();\n                }\n            };\n        }\n    }\n\n    //endregion\n\n    //region Syncing columns\n\n    startSyncingColumns() {\n        for (const subView of this.subViews) {\n            subView.columns.ion({\n                name    : 'columns',\n                change  : 'onColumnsChange',\n                thisObj : this\n            });\n        }\n    }\n\n    stopSyncingColumns() {\n        this.detachListeners('columns');\n    }\n\n    onColumnsChange({ source, isMove, action, /*index, */parent, records, changes }) {\n        const me = this;\n\n        if (!me.#ignoreColumnChanges) {\n            me.#ignoreColumnChanges = true;\n\n            for (const clone of me.subViews) {\n                const { columns } = clone;\n\n                if (source !== columns) {\n                    // Special handling for column moved from subgrid not in split to subgrid in split\n                    if (action === 'update' && changes.region && Object.keys(changes).length === 1) {\n                        // Move from non-existing to existing, add\n                        if (!columns.getById(records[0].id)) {\n                            const\n                                [column]     = records,\n                                targetParent = columns.getById(me.$before.parent.id) ?? columns.rootNode,\n                                targetBefore = me.$before.id !== null && columns.getById(me.$before.id);\n\n                            targetParent.insertChild(column.data, targetBefore);\n                        }\n                        // Vice versa, remove\n                        else {\n                            columns.remove(records[0].id);\n                        }\n\n                        me.$before = null;\n                    }\n                    else if (!isMove?.[records[0].id]) {\n                        if (action === 'add') {\n                            // Only add columns that are in a subgrid that is visible in the clone\n                            const relevantColumns = records.filter(column => clone.getSubGridFromColumn(column));\n                            columns.add(me.cloneColumns(relevantColumns));\n                        }\n                        else {\n                            columns.applyChangesFromStore(source);\n                        }\n                    }\n                    // We have to handle move separately, since it does not leave the column store modified (in any\n                    // meaningful way)\n                    else if (action === 'add') {\n                        const\n                            sourceColumn = records[0],\n                            sourceBefore = sourceColumn.nextSibling,\n                            targetColumn = columns.getById(sourceColumn.id); //columns.allRecords.find(r => r.id === sourceColumn.id);\n\n                        // When splitting a multi-region grid, not all columns are present in all splits. But, it might\n                        // be moved from locked to normal (etc.) in original, but split is not showing source region. In\n                        // that case, we handle it on the region update - and must store details here\n                        if (!targetColumn) {\n                            me.$before = {\n                                id : sourceBefore?.id,\n                                parent\n                            };\n                            me.#ignoreColumnChanges = false;\n                            return;\n                        }\n\n                        if (sourceColumn.meta.isSelectionColumn) {\n                            me.#ignoreColumnChanges = false;\n                            return;\n                        }\n                        const\n                            targetParent = columns.getById(parent.id) ?? columns.rootNode,\n                            targetBefore = sourceBefore && columns.getById(sourceBefore.id);\n\n                        targetParent.insertChild(targetColumn, targetBefore);\n                    }\n\n                    columns.commit();\n                }\n            }\n\n            source.commit();\n\n            me.#ignoreColumnChanges = false;\n        }\n    }\n\n    //endregion\n\n    //region Syncing splitters\n\n    getOtherSplitter(splitter) {\n        return splitter === this.topSplitter ? this.bottomSplitter : this.topSplitter;\n    }\n\n    onSplitterMouseDown({ source, event }) {\n        if (!event.handled) {\n            event.handled = true;\n            this.getOtherSplitter(source).onMouseDown(event);\n        }\n    }\n\n    onSplitterDrag({ source, event }) {\n        if (!event.handled) {\n            event.handled = true;\n            this.getOtherSplitter(source).onMouseMove(event);\n        }\n    }\n\n    onSplitterDrop({ source, event }) {\n        if (!event.handled) {\n            event.handled = true;\n            this.getOtherSplitter(source).onMouseUp(event);\n        }\n    }\n\n    //endregion\n\n    //region Relaying property changes & events\n\n    // Relay relevant config changes to other splits\n    afterConfigChange({ name, value }) {\n        if (this.isSplit && this.relayProperties[name]) {\n            this.syncSplits(split => {\n                split[name] = value;\n            });\n        }\n    }\n\n    // Sync listeners added at runtime to other splits\n    afterAddListener(eventName, listener) {\n        if (this.isSplit && !listener.$internal && !ignoreListeners[eventName]) {\n            // Not using `ion()` on purpose, these are app listeners\n            // eslint-disable-next-line bryntum/no-on-in-lib\n            this.syncSplits(split => split.on(eventName, listener));\n        }\n    }\n\n    afterRemoveListener(eventName, listener) {\n        if (!listener.$internal) {\n            this.syncSplits(split => split.un(eventName, listener));\n        }\n    }\n\n    //endregion\n\n    //region Util\n\n    // Call a fn for all splits except the on this fn is called on\n    forEachOther(fn) {\n        const original = this.client.splitFrom || this.client;\n\n        if (original.features.split.enabled && !original.inForEachOther) {\n            // Protect against infinite recursion by being called from the fn\n            original.inForEachOther = true;\n\n            for (const view of original.subViews) {\n                if (view !== this.client) {\n                    fn(view);\n                }\n            }\n\n            original.inForEachOther = false;\n        }\n    }\n\n    syncSplits(fn) {\n        this.forEachOther(fn);\n    }\n\n    //endregion\n}\n\nGridFeatureManager.registerFeature(Split, false);\n", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport Base from '../../Core/Base.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\n\n/**\n * @module Grid/util/TableExporter\n */\n\n/**\n * This class transforms grid component into two arrays: rows and columns. Columns array contains objects with\n * meta information about column: field name, column name, width and type of the rendered value, rows array contains\n * arrays of cell values.\n *\n * ```javascript\n * const exporter = new TableExporter({ target : grid });\n * exporter.export()\n *\n * // Output\n * {\n *     columns : [\n *         { field : 'name',     value : 'First name', type : 'string',  width : 100 },\n *         { field : 'surname',  value : 'Last name',  type : 'string',  width : 100 },\n *         { field : 'age',      value : 'Age',        type : 'number',  width : 50  },\n *         { field : 'married',  value : 'Married',    type : 'boolean', width : 50  },\n *         { field : 'children', value : 'Children',   type : 'object',  width : 100 }\n *     ],\n *     rows : [\n *         ['Michael', 'Scott',   40, false, []],\n *         ['Jim',     'Halpert', 30, true,  [...]]\n *     ]\n * }\n * ```\n *\n * ## How data is exported\n *\n * Exporter iterates over store records and processes each record for each column being exported. Exporter uses same\n * approach to retrieve data as column: reading record field, configured on the column, or calling renderer function\n * if one is provided. This means data can be of any type: primitives or objects. So children array in the above code\n * snippet may contain instances of child record class.\n *\n * ## Column renderers\n *\n * Column renderers are commonly used to style the cell, or even render more HTML into it, like {@link Grid.column.WidgetColumn}\n * does. This is not applicable in case of export. Also, given grid uses virtual rendering (only renders visible rows) and\n * exporter iterates over all records, not just visible ones, we cannot provide all data necessary to the renderer. Some\n * arguments, like cellElement and row, wouldn't exist. Thus renderer is called with as much data we have: value,\n * record, column, grid, other {@link Grid.column.Column#config-renderer documented arguments} would be undefined.\n *\n * Exporter adds one more flag for renderer function: isExport. When renderer receives this flag it knows\n * data is being exported and can skip DOM work to return simpler value. Below snippet shows simplified code of the\n * widget column handling export:\n *\n * ```javascript\n * renderer({ isExport }) {\n *     if (isExport) {\n *         return null;\n *     }\n *     else {\n *         // widget rendering routine\n *         ...\n *     }\n * }\n * ```\n *\n * ## Column types\n *\n * Column types are not actually a complete list of JavaScript types (you can get actual type of the cell using typeof) it\n * is a simple and helpful meta information.\n *\n * Available column types are:\n *  * string\n *  * number\n *  * boolean\n *  * date\n *  * object\n *\n * Everything which is not primitive like string/number/bool (or a date) is considered an object. This includes null, undefined,\n * arrays, classes, functions etc.\n *\n * ## Getting column type\n *\n * If existing grid column is used, column type first would be checked with {@link Grid.column.Column#config-exportedType exportedType}\n * config. If exportedType is undefined or column does not exist in grid, type is read from a record field definition.\n * If the field is not defined, object type is used.\n *\n * Configuring exported type:\n *\n * ```javascript\n * new Grid({\n *     columns : [\n *         {\n *             name         : 'Name',\n *             field        : 'name',\n *             exportedType : 'object',\n *             renderer     : ({ value, isExport }) => {\n *                 if (isExport) {\n *                     return { value }; // return value wrapped into object\n *                 }\n *             }\n *     ]\n * })\n * ```\n *\n * @extends Core/Base\n */\nexport default class TableExporter extends Base {\n    static get defaultConfig() {\n        return {\n            /**\n             * Target grid instance to export data from\n             * @config {Grid.view.Grid} target\n             */\n            target : null,\n\n            /**\n             * Specifies a default column width if no width specified\n             * @config {Number} defaultColumnWidth\n             * @default\n             */\n            defaultColumnWidth : 100,\n\n            /**\n             * Set to false to export date as it is displayed by Date column formatter\n             * @config {Boolean}\n             * @default\n             */\n            exportDateAsInstance : true,\n\n            /**\n             * If true and the grid is grouped, shows the grouped value in the first column. True by default.\n             * @config {Boolean} showGroupHeader\n             * @default\n             */\n            showGroupHeader : true,\n\n            /**\n             * An array of column configuration objects used to specify column widths, header text, and data fields to get the data from.\n             * 'field' config is required. If 'text' is missing, it will read it from the grid column or the 'field' config.\n             * If 'width' is missing, it will try to get it retrieved from the grid column or {@link #config-defaultColumnWidth} config.\n             * If no columns provided the config will be generated from the grid columns.\n             *\n             * For example:\n             * ```javascript\n             * columns : [\n             *     'firstName', // field\n             *     'age', // field\n             *     { text : 'Starts', field : 'start', width : 140 },\n             *     { text : 'Ends', field : 'finish', width : 140 }\n             * ]\n             * ```\n             *\n             * @config {String[]|Object[]} columns\n             * @default\n             */\n            columns : null,\n\n            /**\n             * When true and tree is being exported, node names are indented with {@link #config-indentationSymbol}\n             * @config {Boolean}\n             * @default\n             */\n            indent : true,\n\n            /**\n             * This symbol (four spaces by default) is used to indent node names when {@link #config-indent} is true\n             * @config {String}\n             * @default\n             */\n            indentationSymbol : '\\u00A0\\u00A0\\u00A0\\u00A0'\n        };\n    }\n\n    /**\n     * Exports grid data according to provided config\n     * @param {Object} config\n     * @returns {{ rows : Object[][], columns : Object[] }}\n     */\n    export(config = {}) {\n        const me = this;\n\n        config = ObjectHelper.assign({}, me.config, config);\n\n        me.normalizeColumns(config);\n\n        return me.generateExportData(config);\n    }\n\n    generateExportData(config) {\n        const\n            me      = this,\n            columns = me.generateColumns(config),\n            rows    = me.generateRows(config);\n\n        return { rows, columns };\n    }\n\n    normalizeColumns(config) {\n        // In case columns are provided we need to use normalized config. If those are not provided, we are going\n        // to use real columns, possible invoking renderers (we need to pass column instance to the renderer to\n        // avoid breaking API too much)\n        const columns = config.columns || this.target.columns.visibleColumns.filter(rec => rec.exportable !== false);\n\n        config.columns = columns.map(col => {\n            if (typeof col === 'string') {\n                return this.target.columns.find(column => column.field === col) || { field : col };\n            }\n            else {\n                return col;\n            }\n        });\n    }\n\n    generateColumns(config) {\n        return config.columns.map(col => this.processColumn(col, config));\n    }\n\n    generateRows(config) {\n        const { columns, rows } = config;\n\n        if (columns.length === 0 || rows?.length === 0) {\n            return [];\n        }\n\n        const\n            me         = this,\n            { target } = me;\n\n        return (rows || target.store)\n            // although columns are taken from config, it is convenient to provide them as a separate argument\n            // because that allows to override set of columns to process\n            .map(record => me.processRecord(record, columns, config))\n            // filter out empty rows\n            .filter(cells => cells?.length);\n    }\n\n    getColumnType(column, store = this.target.store) {\n        let result = column.exportedType || 'object';\n\n        if (column.exportedType === undefined) {\n            if (column.field) {\n                const fieldDefinition = store.modelClass.getFieldDefinition(column.field);\n\n                if (fieldDefinition && fieldDefinition.type !== 'auto') {\n                    result = fieldDefinition.type;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Extracts export data from the column instance\n     * @param {Grid.column.Column} column\n     * @param {Object} config\n     * @private\n     * @returns {Object}\n     */\n    processColumn(column, config) {\n        const\n            me                     = this,\n            { target }             = me,\n            { defaultColumnWidth } = config;\n\n        let { field, text : value, width, minWidth } = column;\n\n        // If column is not configured with field, field is generated (see Column.js around line 514).\n        // In export we want empty string there\n        if (!(field in target.store.modelClass.fieldMap)) {\n            field = '';\n        }\n\n        // If name or width is missing try to retrieve them from the grid column and the field, or use default values.\n        if (!value || !width) {\n            const gridColumn = target.columns.find(col => col.field === field);\n\n            if (!value) {\n                value = gridColumn && gridColumn.text || field;\n            }\n\n            // null or undefined\n            if (width == null) {\n                width = gridColumn && gridColumn.width || defaultColumnWidth;\n            }\n        }\n\n        width = Math.max(width || defaultColumnWidth, minWidth || defaultColumnWidth);\n\n        return { field, value, width, type : me.getColumnType(column) };\n    }\n\n    /**\n     * Extracts export data from the record instance reading supplied column configs\n     * @param {Core.data.Model|null} record If null is passed, all columns will be filled with empty strings\n     * @param {Grid.column.Column[]} columns\n     * @param {Object} config\n     * @private\n     * @returns {Object[]}\n     */\n    processRecord(record, columns, config) {\n        const\n            { target } = this,\n            {\n                showGroupHeader,\n                indent,\n                indentationSymbol\n            }  = config;\n\n        let cells;\n\n        if (!record) {\n            cells = columns.map(() => '');\n        }\n        else if (record.isSpecialRow) {\n            if (showGroupHeader && record.meta.groupRowFor) {\n                cells = columns.map(column => {\n                    return target.features.group.buildGroupHeader({\n                        // Create dummy element to get html from\n                        cellElement : DomHelper.createElement(),\n                        grid        : target,\n                        record,\n                        column\n                    });\n                });\n            }\n        }\n        else {\n            cells = columns.map(column => {\n                let value = record.getValue(column.field);\n                const useRenderer = column.renderer || column.defaultRenderer;\n\n                if (useRenderer && !(value && column.isDateColumn && config.exportDateAsInstance)) {\n                    value = useRenderer.call(column, {\n                        value,\n                        record,\n                        column,\n                        grid     : target,\n                        isExport : true\n                    });\n                }\n\n                if (indent && column.tree) {\n                    value = `${indentationSymbol.repeat(record.childLevel)}${value}`;\n                }\n\n                return value;\n            });\n        }\n\n        return cells;\n    }\n}\n", "export default class BooleanUnicodeSymbol {\n    constructor(value) {\n        this._value = value;\n    }\n\n    get value() {\n        return this._value;\n    }\n\n    toString() {\n        return Boolean(this.value) ? '✓' : '';\n    }\n}\n", "import GridFeatureManager from '../GridFeatureManager.js';\nimport InstancePlugin from '../../../Core/mixin/InstancePlugin.js';\nimport TableExporter from '../../util/TableExporter.js';\nimport BooleanUnicodeSymbol from '../../util/BooleanUnicodeSymbol.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n\n/**\n * @module Grid/feature/experimental/ExcelExporter\n */\n\n/**\n * **NOTE**: This class requires a 3rd party library to operate.\n *\n * A feature that allows exporting Grid data to Excel without involving the server. It uses {@link Grid.util.TableExporter}\n * class as data provider, [zipcelx library](https://www.npmjs.com/package/zipcelx)\n * forked and adjusted to support [column width config](https://github.com/bryntum/zipcelx/tree/column-width-build)\n * and [Microsoft XML specification](https://msdn.microsoft.com/en-us/library/office/documentformat.openxml.spreadsheet.aspx).\n * Zipcelx should be either in global scope (window) or can be provided with {@link #config-zipcelx} config.\n *\n * ```html\n * // Global scope\n * <script src=\"zipcelx.js\"></script>\n * ```\n *\n * ```javascript\n * // importing from package\n * import zipcelx from 'zipcelx';\n *\n * const grid = new Grid({\n *     features : {\n *         excelExporter : {\n *             zipcelx\n *         }\n *     }\n * })\n * ```\n *\n * Here is an example of how to add the feature:\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         excelExporter : {\n *             // Choose the date format for date fields\n *             dateFormat : 'YYYY-MM-DD HH:mm',\n *\n *             exporterConfig : {\n *                 // Choose the columns to include in the exported file\n *                 columns : ['name', 'role'],\n *                 // Optional, export only selected rows\n *                 rows    : grid.selectedRecords\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * And how to call it:\n *\n * ```javascript\n * grid.features.excelExporter.export({\n *     filename : 'Export',\n *     exporterConfig : {\n *         columns : [\n *             { text : 'First Name', field : 'firstName', width : 90 },\n *             { text : 'Age', field : 'age', width : 40 },\n *             { text : 'Starts', field : 'start', width : 140 },\n *             { text : 'Ends', field : 'finish', width : 140 }\n *         ]\n *     }\n * })\n * ```\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Grid/exporttoexcel\n * @classtype excelExporter\n * @feature\n */\nexport default class ExcelExporter extends InstancePlugin {\n    static get $name() {\n        return 'ExcelExporter';\n    }\n\n    static get defaultConfig() {\n        return {\n            /**\n             * Name of the exported file\n             * @config {String} filename\n             * @default\n             */\n            filename : null,\n\n            /**\n             * Defines how dates in a cell will be formatted\n             * @config {String} dateFormat\n             * @default\n             */\n            dateFormat : 'YYYY-MM-DD',\n\n            /**\n             * Exporter class to use as a data provider. {@link Grid.util.TableExporter} by default.\n             * @config {Grid.util.TableExporter}\n             * @typings {typeof TableExporter}\n             * @default\n             */\n            exporterClass : TableExporter,\n\n            /**\n             * Configuration object for {@link #config-exporterClass exporter class}.\n             * @config {Object}\n             */\n            exporterConfig : null,\n\n            /**\n             * Reference to zipcelx library. If not provided, exporter will look in the global scope.\n             * @config {Object}\n             */\n            zipcelx : null,\n\n            /**\n             * If this config is true, exporter will convert all empty values to ''. Empty values are:\n             * * undefined, null, NaN\n             * * Objects/class instances that do not have toString method defined and are stringified to [object Object]\n             * * functions\n             * @config {Boolean}\n             */\n            convertEmptyValueToEmptyString : true\n        };\n    }\n\n    processValue(value) {\n        if (\n            value === undefined ||\n            value === null ||\n            Number.isNaN(value) ||\n            typeof value === 'function' ||\n            (typeof value === 'object' && String(value) === '[object Object]')\n        ) {\n            return '';\n        }\n        else {\n            return value;\n        }\n    }\n\n    generateExportData(config) {\n        const\n            me                = this,\n            { rows, columns } = me.exporter.export(config.exporterConfig);\n\n        return {\n            rows : rows.map(row => {\n                return row.map((value, index) => {\n                    if (value instanceof Date) {\n                        value = DateHelper.format(value, config.dateFormat);\n                    }\n                    else if (typeof value === 'boolean') {\n                        value = new BooleanUnicodeSymbol(value);\n                    }\n\n                    if (me.convertEmptyValueToEmptyString) {\n                        value = me.processValue(value);\n                    }\n\n                    const type = columns[index]?.type === 'number' ? 'number' : 'string';\n\n                    return { value, type };\n                });\n            }),\n            columns : columns.map(col => {\n                let { field, value, width, type } = col;\n\n                // when number column is exported with zipcelx, excel warns that sheet is broken and asks for repair\n                // repair works, but having error on open doesn't look acceptable\n                // type = type === 'number' ? 'number' : 'string';\n                type = 'string';\n\n                return { field, value, width, type };\n            })\n        };\n    }\n\n    /**\n     * Generate and download an Excel file (.xslx).\n     * @param {Object} config Optional configuration object, which overrides initial settings of the feature/exporter.\n     * @param {String} [config.filename] Name of the exported file\n     * @param {String} [config.dateFormat] Defines how dates in a cell will be formatted\n     * @param {String[]|Object[]} [config.columns] An array of column configuration objects\n     * @param {Core.data.Model[]} [config.rows] An array of records to export\n     * @returns {Promise} Promise that resolves when the export is completed\n     */\n    export(config = {}) {\n        const\n            me      = this,\n            zipcelx = me.zipcelx || globalThis.zipcelx;\n\n        if (!zipcelx) {\n            throw new Error('ExcelExporter: \"zipcelx\" library is required');\n        }\n\n        if (me.disabled) {\n            return;\n        }\n\n        config = ObjectHelper.assign({}, me.config, config);\n\n        if (!config.filename) {\n            config.filename = me.client.$$name;\n        }\n\n        const\n            { filename }      = config,\n            { rows, columns } = me.generateExportData(config);\n\n        return zipcelx({\n            filename,\n            sheet : {\n                data : [columns].concat(rows),\n                cols : columns\n            }\n        });\n    }\n\n    construct(grid, config) {\n        super.construct(grid, config);\n\n        if (!this.zipcelx) {\n            if (typeof zipcelx !== 'undefined') {\n                this.zipcelx = globalThis.zipcelx;\n            }\n        }\n    }\n\n    get exporter() {\n        const me = this;\n\n        return me._exporter || (me._exporter = me.exporterClass.new({ target : me.client }, me.exporterConfig));\n    }\n}\n\nGridFeatureManager.registerFeature(ExcelExporter, false, 'Grid');\n"],
  "mappings": "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",
  "names": ["ColorColumn", "Column", "construct", "_me$colors", "arguments", "me", "grid", "menu", "Menu", "owner", "rootElement", "autoShow", "align", "anchor", "internalListeners", "hide", "picker", "navigator", "activeItem", "_editingRecord", "items", "Object", "assign", "type", "colorEditorType", "ref", "addNoColorItem", "colorSelected", "color", "_me$_editingRecord", "set", "field", "colors", "length", "applyValue", "useProp", "value", "isConstructing", "widgetMap", "list", "renderer", "colorClass", "backgroundColor", "colorClassName", "getColorClassName", "className", "style", "onCellClick", "record", "target", "classList", "contains", "readOnly", "isSpecialRow", "get", "deselectAll", "select", "refresh", "showBy", "__publicField", "$name", "fields", "name", "defaultValue", "defaults", "editor", "ColumnStore", "registerColumnType", "_$name", "GroupSummary", "SummaryFormatter", "InstancePlugin", "configurable", "collapseToHeader", "config", "features", "group", "Error", "bindStore", "store", "rowManager", "ion", "beforeRenderRow", "renderCell", "prio", "thisObj", "detachListeners", "update", "doDisable", "disable", "updateTarget", "changeTarget", "ObjectHelper", "assertString", "useGroupFooters", "disabled", "isConfiguring", "changeCollapseToHeader", "assertBoolean", "updateCollapseToHeader", "pluginConfig", "chain", "onBeforeRenderRow", "row", "isGroupFooter", "meta", "forceInnerHTML", "isGroupHeader", "collapsed", "eachElement", "removeSummaryElements", "rowEl", "column", "cellElement", "size", "isFirstColumn", "rowHeight", "targetsHeader", "rowClasses", "isSummaryTarget", "height", "isGrouped", "clearCell", "groupRecord", "heightSetting", "updateSummaryHtml", "count", "assignCls", "records", "groupChildren", "slice", "pop", "html", "generateHtml", "groupField", "groupRowFor", "children", "DomHelper", "sync", "firstElementChild", "innerHTML", "summaries", "sum", "onStoreUpdate", "source", "changes", "groupers", "find", "grouper", "keys", "some", "colField", "columns", "Boolean", "forceFullRefresh", "visibleColumns", "forEach", "hasSummary", "refreshColumn", "featureClass", "GridFeatureManager", "registerFeature", "startScrollOptions", "freeze", "animate", "block", "endScrollOptions", "splitterWidth", "ignoreListeners", "split", "unsplit", "Split", "__privateAdd", "_ignoreColumnChanges", "restorers", "doDestroy", "_disabledSplitOptions", "_splitOptions", "isSplit", "_this$widgets", "widgets", "getClientConfig", "appendTo", "order", "options", "client", "subGrids", "regions", "subGridConfigs", "eachSubGrid", "subGrid", "region", "flex", "width", "element", "atColumn", "subGridIndex", "indexOf", "i", "ArrayHelper", "remove", "clientConfig", "initialConfig", "insertFirst", "insertBefore", "splitFrom", "tbar", "selectedRecordCollection", "cloneColumns", "minHeight", "minWidth", "appListeners", "listeners", "listener", "$internal", "direction", "hideHeaders", "data", "flatMap", "col", "isSelectionColumn", "map", "child", "headerRenderer", "parentId", "cloneClient", "clone", "constructor", "add", "processOptions", "atRecord", "centerY", "_bodyRectangle", "scrollable", "y", "centerRow", "getRowAt", "rows", "Math", "ceil", "getById", "id", "bounds", "Rectangle", "from", "centerX", "center", "x", "j", "offsetWidth", "createSplitContainer", "splitContainer", "createElement", "parent", "parentElement", "rtl", "syncHeaderHeights", "maxHeaderHeight", "subViews", "header", "toggleOriginalSubGrids", "splits", "push", "isOriginal", "hideSplitter", "showSplitter", "inForEachOther", "_initialWidth", "show", "_initialFlex", "splitX", "remainingWidth", "splitY", "remainingHeight", "scrollRowIntoView", "getRowFor", "cells", "bottom", "getEnd", "scrollBarWidth", "scrollPromises", "nextColumn", "nextRecord", "getNext", "cloneConfig", "Splitter", "renderRows", "atDate", "scrollColumnIntoView", "addPartner", "rightConfig", "lastElementChild", "topSplitter", "bottomSplitter", "topLeft", "topRight", "bottomLeft", "bottomRight", "splitterMouseDown", "drag", "drop", "filter", "w", "isGridBase", "Promise", "all", "onInternalResize", "subGridBounds", "startSyncingColumns", "trigger", "silent", "_me$widgets", "stopSyncingColumns", "destroy", "appendChild", "flexBasis", "flexGrow", "isDestroying", "unsplitCleanup", "restorer", "AsyncHelper", "animationFrame", "isDestroyed", "populateCellMenu", "splitGrid", "text", "localeClass", "icon", "weight", "separator", "hidden", "splitHorizontally", "onItem", "splitVertically", "splitBoth", "unsplitGrid", "subView", "change", "onColumnsChange", "isMove", "action", "targetParent", "$before", "rootNode", "targetBefore", "insertChild", "sourceColumn", "sourceBefore", "nextSibling", "targetColumn", "relevantColumns", "getSubGridFromColumn", "applyChangesFromStore", "commit", "getOtherSplitter", "splitter", "onSplitterMouseDown", "event", "handled", "onMouseDown", "onSplitterDrag", "onMouseMove", "onSplitterDrop", "onMouseUp", "afterConfigChange", "relayProperties", "syncSplits", "afterAddListener", "eventName", "on", "afterRemoveListener", "un", "forEachOther", "fn", "original", "enabled", "view", "$config", "merge", "TableExporter", "Base", "defaultConfig", "defaultColumnWidth", "exportDateAsInstance", "showGroupHeader", "indent", "indentationSymbol", "export", "normalizeColumns", "generateExportData", "generateColumns", "generateRows", "rec", "exportable", "processColumn", "processRecord", "getColumnType", "result", "exportedType", "undefined", "fieldDefinition", "modelClass", "getFieldDefinition", "fieldMap", "gridColumn", "max", "buildGroupHeader", "getValue", "useRenderer", "defaultRenderer", "isDateColumn", "call", "isExport", "tree", "repeat", "childLevel", "BooleanUnicodeSymbol", "_value", "toString", "ExcelExporter", "filename", "dateFormat", "exporterClass", "exporterConfig", "zipcelx", "convertEmptyValueToEmptyString", "processValue", "Number", "isNaN", "String", "exporter", "index", "_columns$index", "Date", "DateHelper", "format", "globalThis", "$$name", "sheet", "concat", "cols", "_exporter", "new"]
}
