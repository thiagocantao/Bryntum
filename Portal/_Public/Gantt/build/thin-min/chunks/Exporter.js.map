{
  "version": 3,
  "sources": ["../../../../Grid/lib/Grid/feature/export/Utils.js", "../../../../Grid/lib/Grid/feature/export/exporter/Exporter.js"],
  "sourcesContent": ["\nexport const RowsRange = {\n    all     : 'all',\n    visible : 'visible'\n};\n\nexport const PaperFormat = {\n    A6 : {\n        width  : 4.11,\n        height : 5.81\n    },\n    A5 : {\n        width  : 5.81,\n        height : 8.25\n    },\n    A4 : {\n        width  : 8.25,\n        height : 11.69\n    },\n    A3 : {\n        width  : 11.69,\n        height : 16.49\n    },\n    Legal : {\n        width  : 8.5,\n        height : 14\n    },\n    Letter : {\n        width  : 8.5,\n        height : 11\n    }\n};\n\nexport const Orientation = {\n    portrait  : 'portrait',\n    landscape : 'landscape'\n};\n\nexport const FileFormat = {\n    pdf : 'pdf',\n    png : 'png'\n};\n\nexport const FileMIMEType = {\n    pdf : 'application/pdf',\n    png : 'image/png'\n};\n", "import DomSync from '../../../../Core/helper/DomSync.js';\nimport TemplateHelper from '../../../../Core/helper/TemplateHelper.js';\nimport BrowserHelper from '../../../../Core/helper/BrowserHelper.js';\nimport Base from '../../../../Core/Base.js';\nimport Localizable from '../../../../Core/localization/Localizable.js';\nimport IdHelper from '../../../../Core/helper/IdHelper.js';\nimport DomHelper from '../../../../Core/helper/DomHelper.js';\nimport { RowsRange } from '../Utils.js';\nimport Events from '../../../../Core/mixin/Events.js';\nimport Delayable from '../../../../Core/mixin/Delayable.js';\n\n/**\n * @module Grid/feature/export/exporter/Exporter\n */\n\n/**\n * Base class for all exporters\n * @mixes Core/localization/Localizable\n * @mixes Core/mixin/Events\n */\nexport default class Exporter extends Delayable(Events(Localizable(Base))) {\n    static get defaultConfig() {\n        return {\n            /**\n             * `True` to replace all linked CSS files URLs to absolute before passing HTML to the server.\n             * When passing a string the current origin of the CSS files URLS will be replaced by the passed origin.\n             *\n             * For example: css files pointing to /app.css will be translated from current origin to {translateURLsToAbsolute}/app.css\n             * @config {Boolean|String}\n             * @default\n             */\n            translateURLsToAbsolute : true,\n\n            /**\n             * When true links are converted to absolute by combining current window location (with replaced origin) with\n             * resource link.\n             * When false links are converted by combining new origin with resource link (for angular)\n             * @config {Boolean}\n             * @default\n             */\n            keepPathName : true,\n\n            /**\n             * This method accepts all stylesheets (link and style tags) which are supposed to be put on the page. Use this\n             * hook method to filter or modify them.\n             *\n             * ```javascript\n             * new Grid({\n             *     features: {\n             *         pdfExport: {\n             *             // filter out inline styles and bootstrap.css\n             *             filterStyles: styles => styles.filter(item => !/(link|bootstrap.css)/.test(item))\n             *         }\n             *     }\n             * });\n             * ```\n             * @param {String[]} styles\n             * @returns {String[]} List of stylesheets to put on the exported page\n             */\n            filterStyles : styles => styles\n        };\n    }\n\n    /**\n     * Template of an extracted page.\n     * @param {Object} data Data for the page template\n     * @returns {String}\n     */\n    pageTpl(data) {\n        const\n            {\n                title,\n                header,\n                footer,\n                styles,\n                htmlClasses,\n                bodyStyle,\n                bodyClasses = [],\n                paperHeight,\n                paperWidth,\n                html\n            } = data;\n\n        bodyClasses.push(`b-${this.constructor.type}`);\n\n        // Other classes needed on outer element.\n        // <remove-on-release>\n        // TODO: use the new static Widget.outerCls property when merged with master\n        // </remove-on-release>\n        if (DomHelper.scrollBarWidth) {\n            bodyClasses.push('b-visible-scrollbar');\n        }\n        else {\n            bodyClasses.push('b-overlay-scrollbar');\n        }\n        if (BrowserHelper.isChrome) {\n            bodyClasses.push('b-chrome');\n        }\n        else if (BrowserHelper.isSafari) {\n            bodyClasses.push('b-safari');\n        }\n        else if (BrowserHelper.isFirefox) {\n            bodyClasses.push('b-firefox');\n        }\n\n        return TemplateHelper.tpl`\n            <!DOCTYPE html>\n            <html class=\"${htmlClasses}\" style=\"width: ${paperWidth}in; height: ${paperHeight}in;\">\n                <head>\n                    <meta content=\"text/html; charset=UTF-8\" http-equiv=\"Content-Type\" />\n                    <title>${title}</title>\n                    ${styles.join('')}\n                </head>\n                <body class=\"b-export ${bodyClasses.join(' ')}\" style=\"width: ${paperWidth}in; height: ${paperHeight}in; ${bodyStyle}\">\n                    <div class=\"b-export-content\">\n                        ${header && `<div class=\"b-export-header\" style=\"width: 100%\">${header}</div>`}\n                        <div class=\"b-export-body\"><div class=\"b-export-viewport\">${html}</div></div>\n                        ${footer && `<div class=\"b-export-footer\" style=\"width: 100%\">${footer}</div>`}\n                    </div>\n                </body>\n            </html>`;\n    }\n\n    /**\n     * Returns all style-related tags: `<style>` and `<link rel=\"stylesheet\">`\n     * @property {String[]}\n     * @readonly\n     */\n    get stylesheets() {\n        const me = this;\n\n        if (me._stylesheets) {\n            return me._stylesheets;\n        }\n\n        const\n            translate       = me.translateURLsToAbsolute,\n            origin          = globalThis.origin,\n            styleSheetNodes = Array.from(document.querySelectorAll('link[rel=\"stylesheet\"], style')),\n            styles          = [];\n\n        styleSheetNodes.forEach(node => {\n            node = node.cloneNode(true);\n\n            // put absolute URL to node `href` attribute\n            if (translate && node.href) {\n                let result;\n\n                if (translate === true) {\n                    result = node.href;\n                }\n                // translate is truthy if we are here, which means it is string now\n                else if (this.keepPathName) {\n                    result = node.href.replace(origin, translate);\n                }\n                else {\n                    result = new URL(node.getAttribute('href'), translate);\n                }\n\n                node.setAttribute('href', result);\n            }\n\n            let styleText = node.outerHTML;\n\n            if (translate && /style/i.test(node.tagName)) {\n                const converter = me.getStyleTagURLConverter(translate);\n                styleText = styleText.replace(/url\\(['\"]?(.+?)['\"]?\\)/g, converter);\n            }\n\n            styles.push(styleText);\n        });\n\n        styles.push(\n            `<style>\n                body, html {\n                    overflow: auto;\n                }\n\n                body {\n                    position: relative;\n                    margin: 0;\n                }\n            </style>`);\n\n        return me._stylesheets = me.filterStyles(styles);\n    }\n\n    set stylesheets(value) {\n        this._stylesheets = value ? this.filterStyles(value) : value;\n    }\n\n    getStyleTagURLConverter(translate) {\n        return function(match, url) {\n            let result;\n\n            try {\n                let base;\n\n                // Filter out local references, e.g. to svg marker\n                if (/^#/.test(url)) {\n                    result = match;\n                }\n                else {\n                    if (translate === true) {\n                        base = globalThis.location.href;\n                    }\n                    // translate is truthy if we are here, which means it is string now\n                    else if (this.keepPathName) {\n                        base = globalThis.location.href.replace(globalThis.location.origin, translate);\n                    }\n                    else {\n                        base = translate;\n                    }\n\n                    result = `url('${new URL(url, base).href}')`;\n                }\n            }\n            catch (e) {\n                result = match;\n            }\n\n            return result;\n        }.bind(this);\n    }\n\n    saveState({ client }) {\n        this.state = client.state;\n    }\n\n    async restoreState({ client }) {\n        const\n            promises  = [],\n            detachers = new Set();\n\n        detachers.add(\n            client.scrollable.ion({\n                scroll() {\n                    promises.push(client.scrollable.await('scrollEnd'));\n                }\n            })\n        );\n\n        client.eachSubGrid(({ header, scrollable }) => {\n            detachers.add(\n                scrollable.ion({\n                    scroll() {\n                        promises.push(scrollable.await('scrollEnd'));\n                    }\n                })\n            );\n\n            detachers.add(\n                header.scrollable.ion({\n                    scroll() {\n                        promises.push(header.scrollable.await('scrollEnd'));\n                    }\n                })\n            );\n        });\n\n        client.state = this.state;\n\n        await Promise.all(promises);\n\n        detachers.forEach(fn => fn());\n    }\n\n    beforeExport() {\n        // Into this element we will put HTML for export\n        this.element = document.createElement('div');\n    }\n\n    //region DOM helpers\n\n    cloneElement(element, target = this.element, clear = true) {\n        if (clear) {\n            target.innerHTML = '';\n        }\n\n        target.appendChild(element.cloneNode(true));\n\n        DomHelper.removeEachSelector(target, '.b-grid-row,.b-grid-merged-cells-container');\n\n        const maskEl = target.querySelector('.b-gridbase > .b-mask');\n\n        if (maskEl) {\n            maskEl.remove();\n        }\n    }\n\n    createPlaceholder(el, clear = true, config = {}) {\n        if (clear) {\n            el.innerHTML = '';\n        }\n\n        return DomHelper.createElement(Object.assign({\n            parent : el,\n            id     : IdHelper.generateId('export')\n        }, config));\n    }\n\n    prepareElement({ client }) {\n        const { tbar, bbar } = client;\n\n        if (tbar) {\n            this.element.querySelector(`#${tbar.id}`).remove();\n        }\n\n        if (bbar) {\n            this.element.querySelector(`#${bbar.id}`).remove();\n        }\n    }\n\n    /**\n     * Appends generated header/footer element to the document body to measure their height\n     * @param html\n     * @returns {Number}\n     * @private\n     */\n    measureElement(html = '') {\n        if (html instanceof HTMLElement) {\n            html = html.outerHTML;\n        }\n\n        const target = DomHelper.createElement({\n            parent : document.body,\n            style  : {\n                visibility : 'hidden',\n                position   : 'absolute'\n            },\n            // Add html to measure to a div between two other divs to take margin into account\n            html : `<div style=\"height: 1px\"></div>${html}<div style=\"height: 1px\"></div>`\n        });\n\n        const result = target.offsetHeight - 2;\n\n        target.remove();\n\n        return result;\n    }\n\n    // Converts local urls to absolute\n    prepareHTML(html) {\n        if (html instanceof HTMLElement) {\n            html = html.outerHTML;\n        }\n\n        const target = DomHelper.createElement({\n            parent : document.body,\n            style  : {\n                visibility : 'hidden',\n                position   : 'absolute'\n            },\n            html\n        });\n\n        const elements = target.querySelectorAll('img');\n\n        for (let i = 0, l = elements.length; i < l; i++) {\n            elements[i].setAttribute('src', elements[i].src);\n        }\n\n        const result = target.innerHTML;\n\n        target.remove();\n\n        return result;\n    }\n\n    getVirtualScrollerHeight(client) {\n        let result = 0;\n\n        // If overlay scroll is enabled, this will return 0\n        // when disabled, it will report proper virtualScrollers element height\n        client.eachSubGrid(subGrid => {\n            if (subGrid.overflowingHorizontally) {\n                result = DomHelper.scrollBarWidth;\n            }\n        });\n\n        // If there's a visible scrollbar, need to also take border height into account\n        return result === 0 ? result : (result + 1);\n    }\n\n    //endregion\n\n    inchToPx(value) {\n        // 1in = 96px for screens\n        // https://developer.mozilla.org/en-US/docs/Web/CSS/length#Absolute_length_units\n        return value * 96;\n    }\n\n    getScaleValue(base, value) {\n        return Math.floor((base * 10000 / value)) / 10000;\n    }\n\n    getVisibleRowsCount(client) {\n        const\n            rowManager = client.rowManager,\n            // We cannot rely on `visibleRowCount` property, it is a mere estimate\n            firstVisibleIndex = rowManager.rows.indexOf(rowManager.firstVisibleRow),\n            lastVisibleIndex  = rowManager.rows.indexOf(rowManager.lastVisibleRow);\n\n        let result;\n\n        // first index could be negative only if there are no rendered rows, in which case we return store count\n        if (firstVisibleIndex !== -1) {\n            // last visible index could be negative if last actually visible row doesn't reach view bottom, i.e.\n            // view is not completely filled with rows\n            if (lastVisibleIndex === -1) {\n                result = client.store.count - firstVisibleIndex;\n            }\n            else {\n                // for a zero-based index we need to add 1 to the result\n                result = lastVisibleIndex - firstVisibleIndex + 1;\n            }\n        }\n        else {\n            result = client.store.count;\n        }\n\n        return result;\n    }\n\n    async export(config) {\n        const me = this;\n\n        let pages;\n\n        me.beforeExport();\n\n        me.saveState(config);\n\n        await me.prepareComponent(config);\n\n        try {\n            pages = await me.getPages(config);\n        }\n        finally {\n            await me.restoreComponent(config);\n\n            me.stylesheets = null;\n\n            // https://app.assembla.com/spaces/bryntum/tickets/9400-scrollrowintoview-promise-is-not-reliable/details\n            // Restoring scroll might trigger rows repaint on next animation frame. We are\n            // waiting for next animation frame in such case. Covered in SinglePage.t.js\n            await new Promise(resolve => me.requestAnimationFrame(resolve));\n\n            await me.restoreState(config);\n        }\n\n        return pages;\n    }\n\n    async getPages(config) {\n        const\n            generator = this.pagesExtractor(config),\n            pages     = [];\n\n        let step;\n\n        while ((step = await generator.next()) && !step.done) {\n            pages.push(step.value);\n        }\n\n        return pages;\n    }\n\n    // Row buffer has to be adjusted to render complete row set per exported page. See virtual scrolling section in README\n    // for more details\n    adjustRowBuffer(client) {\n        const\n            { contentHeight } = this.exportMeta,\n            { rowManager }    = client;\n\n        this.oldRowManagerConfig = {\n            prependRowBuffer : rowManager.prependRowBuffer,\n            appendRowBuffer  : rowManager.appendRowBuffer\n        };\n\n        // render 3 times more rows to get enough to fill exported page\n        const adjustedRowBuffer = Math.ceil(contentHeight / rowManager.rowOffsetHeight);\n\n        rowManager.prependRowBuffer = adjustedRowBuffer;\n        rowManager.appendRowBuffer  = adjustedRowBuffer;\n\n        client.renderRows();\n\n        // In case we are at the bottom of the view and we are increasing buffer, rowmanager might return to the top row\n        // In this case we need to force it to render rows at the current scroll position\n        client.rowManager.jumpToPosition(client.scrollable.y);\n    }\n\n    restoreRowBuffer(client) {\n        client.rowManager.prependRowBuffer = this.oldRowManagerConfig.prependRowBuffer;\n        client.rowManager.appendRowBuffer  = this.oldRowManagerConfig.appendRowBuffer;\n\n        // There is no need to force rendering rows here, those would be updated during applyState call on a grid.\n        // More precisely - during setRowHeight method.\n    }\n\n    async prepareComponent(config) {\n        const\n            me          = this,\n            {\n                client,\n                columns,\n                rowsRange,\n                keepRegionSizes,\n                enableDirectRendering\n            } = config,\n            { rowManager } = client,\n            exportMeta  = me.exportMeta = {\n                enableDirectRendering,\n                totalWidth  : 0,\n                totalHeight : 0 - (enableDirectRendering ? 0 : me.getVirtualScrollerHeight(client)),\n                subGrids    : {}\n            };\n\n        client.columns.forEach(column => {\n            if (columns.includes(column.id)) {\n                column.show();\n            }\n            else {\n                column.hide();\n            }\n        });\n\n        // Wait for animation frame to catch optional resize event which may occur after hiding columns. Scroll\n        // stretcher should be synced before we proceed.\n        // Covered by export/Columns.t\n        await new Promise(resolve => client.requestAnimationFrame(resolve));\n\n        if (client.rowManager.rowCount > 0) {\n            if (rowsRange === RowsRange.all) {\n                exportMeta.firstVisibleDataIndex = rowManager.rows[0].dataIndex;\n            }\n            else {\n                exportMeta.firstVisibleDataIndex = rowManager.firstVisibleRow.dataIndex;\n\n                config.alignRows = true;\n            }\n\n            if (!enableDirectRendering) {\n                await client.scrollRowIntoView(client.store.getAt(exportMeta.firstVisibleDataIndex), { block : 'start' });\n            }\n        }\n\n        const { element } = me;\n\n        // clone whole grid element to the detached container\n        me.cloneElement(client.element);\n\n        me.prepareElement(config);\n\n        let fakeRow;\n\n        // Create fake row, we will use it to render stuff\n        if (enableDirectRendering) {\n            exportMeta.fakeRow = fakeRow = client.rowManager.rowClass.new({\n                cls        : client.rowCls,\n                rowManager : client.rowManager,\n                grid       : client,\n                // use fake indices, they aren't really required\n                index      : -10,\n                dataIndex  : -10\n            });\n        }\n\n        client.eachSubGrid(subGrid => {\n            // Call private listener to create actual DOM nodes\n            if (fakeRow) {\n                subGrid.onAddRow({ rows : [fakeRow], isExport : true });\n\n                // Trick inline widgets to think they're rendered into component (in fact they are)\n                // This is required to remove `Widget.outerCls` classes from the widget\n                fakeRow.element.dataset.ownerCmp = client.id;\n            }\n\n            const placeHolder = me.createPlaceholder(element.querySelector(`[id=\"${subGrid.id}\"]`), false);\n\n            let width;\n\n            if (keepRegionSizes?.[subGrid.region]) {\n                width = subGrid.element.offsetWidth;\n            }\n            else {\n                width = subGrid.columns.visibleColumns.reduce((result, column) => {\n                    if (typeof column.width === 'number') {\n                        result += column.width;\n                    }\n                    else {\n                        result += (client.hideHeaders ? client.rowManager.rows[0].getCell(column.id) : column.element).offsetWidth;\n                    }\n                    return result;\n                }, 0);\n            }\n\n            exportMeta.totalWidth += width;\n\n            const splitterWidth = subGrid.splitterElement?.offsetWidth || 0;\n\n            exportMeta.totalWidth += splitterWidth;\n\n            exportMeta.subGrids[subGrid.region] = {\n                id       : subGrid.id,\n                headerId : subGrid.header?.id || null,\n                footerId : subGrid.footer?.id || null,\n                rows     : [],\n                splitterWidth,\n                placeHolder,\n                width\n            };\n        });\n    }\n\n    prepareExportElement() {\n        const\n            me = this,\n            { element, exportMeta } = me;\n\n        // Exporters may change subGrid width, e.g. when specific date range is exported\n        Object.values(exportMeta.subGrids).forEach(({ width, id, headerId, footerId }) => {\n            [id, headerId, footerId].forEach(id => {\n                if (id) {\n                    const childElement = element.querySelector(`[id=\"${id}\"]`);\n                    // SubGrid now always have header & footer, but not always in DOM\n                    if (childElement) {\n                        childElement.style.width = `${width}px`;\n                        childElement.style.flex = '';\n                    }\n                }\n            });\n        });\n\n        return element.innerHTML;\n    }\n\n    async restoreComponent(config) {\n        if (this.exportMeta.fakeRow) {\n            this.exportMeta.fakeRow.destroy();\n            delete this.exportMeta.fakeRow;\n        }\n    }\n\n    async scrollRowIntoView(client, index) {\n        await client.scrollRowIntoView(client.store.getAt(index), { block : 'start' });\n\n        // #9400 - scrollRowIntoView promise is not reliable\n        await new Promise(resolve => this.requestAnimationFrame(resolve));\n    }\n\n    collectRow(row) {\n        const\n            subGrids = this.exportMeta.subGrids,\n            re       = /data-owner-cmp=\".+?\"/;\n\n        Object.entries(row.elements).forEach(([key, value]) => {\n            subGrids[key].rows.push([\n                value.outerHTML.replace(re, ''),\n                row.top,\n                row.offsetHeight,\n                new Map() // This one is used to collect events (or in general additional row content)\n            ]);\n        });\n    }\n\n    renderMergedCells(config, fromIndex, toIndex, rows) {\n        const\n            me           = this,\n            { client }   = config,\n            { subGrids } = me.exportMeta,\n            // Generate config for merged cells\n            domConfigMap = client.features.mergeCells.buildMergedCellsConfig(fromIndex, toIndex, rows);\n\n        for (const subGridName in subGrids) {\n            const\n                subGrid = subGrids[subGridName],\n                target  = document.createElement('div');\n\n            // Render config into temporary element\n            DomSync.sync({\n                targetElement : target,\n                domConfig     : {\n                    children : domConfigMap[subGridName].children\n                }\n            });\n\n            if (target.childNodes.length) {\n                // mergeCells feature uses dependency injection, so in order to get rendered cell content we\n                // need to get the cell element matching the range\n                target.childNodes.forEach(child => {\n                    const\n                        { syncId } = child.dataset,\n                        range      = client.features.mergeCells.mergedRanges\n                            .find(range => range.cellElement?.parentNode.dataset.syncId === syncId);\n\n                    if (range) {\n                        // Replace cell content if range is found (it might not be found if there's only one cell)\n                        child.innerHTML = range.cellElement.outerHTML;\n                    }\n                });\n\n                subGrid.mergedCellsHtml = [target.innerHTML];\n            }\n        }\n    }\n}\n\n// HACK: terser/obfuscator doesn't yet support async generators, when processing code it converts async generator to regular async\n// function.\n/**\n * Pages generator. Value should be string with exported HTML\n * @param {Object} config\n * @returns {AsyncIterableIterator<{value: String, done: Boolean}>}\n * @private\n */\nExporter.prototype.pagesExtractor = async function * pagesExtractor() {\n    throw new Error('Implement this method in a subclass');\n};\n"],
  "mappings": "gKAAO,MAAMA,EAAY,CACrBC,IAAU,MACVC,QAAU,SACd,EACaC,EAAc,CACvBC,GAAK,CACDC,MAAS,KACTC,OAAS,MAEbC,GAAK,CACDF,MAAS,KACTC,OAAS,MAEbE,GAAK,CACDH,MAAS,KACTC,OAAS,OAEbG,GAAK,CACDJ,MAAS,MACTC,OAAS,OAEbI,MAAQ,CACJL,MAAS,IACTC,OAAS,IAEbK,OAAS,CACLN,MAAS,IACTC,OAAS,EACb,CACJ,EACaM,EAAc,CACvBC,SAAY,WACZC,UAAY,WAChB,EACaC,EAAa,CACtBC,IAAM,MACNC,IAAM,KACV,EACaC,EAAe,CACxBF,IAAM,kBACNC,IAAM,WACV,ECvBe,MAAME,UAAiBC,EAAUC,EAAOC,EAAYC,CAAI,CAAC,CAAC,CAAE,CACvE,WAAWC,eAAgB,CACvB,MAAO,CASHC,wBAA0B,GAQ1BC,aAAe,GAkBfC,aAAeC,GAAUA,EAEjC,CAMAC,QAAQC,EAAM,CACV,KACI,CACIC,MAAAA,EACAC,OAAAA,EACAC,OAAAA,EACAL,OAAAA,EACAM,YAAAA,EACAC,UAAAA,EACAC,YAAAA,EAAc,CAAA,EACdC,YAAAA,EACAC,WAAAA,EACAC,KAAAA,CACJ,EAAIT,EACRM,OAAAA,EAAYI,KAAM,KAAI,KAAKC,YAAYC,MAAM,EAEzCC,EAAUC,eACVR,EAAYI,KAAK,qBAAqB,EAGtCJ,EAAYI,KAAK,qBAAqB,EAEtCK,EAAcC,SACdV,EAAYI,KAAK,UAAU,EAEtBK,EAAcE,SACnBX,EAAYI,KAAK,UAAU,EAEtBK,EAAcG,WACnBZ,EAAYI,KAAK,WAAW,EAEzBS,EAAeC;;2BAEHhB,oBAA8BI,gBAAyBD;;;6BAGrDN;sBACPH,EAAOuB,KAAK,EAAE;;wCAEIf,EAAYe,KAAK,GAAG,oBAAoBb,gBAAyBD,QAAkBF;;0BAEjGH,GAAW,oDAAmDA;oFACJO;0BAC1DN,GAAW,oDAAmDA;;;oBAIpF,CAMA,IAAImB,aAAc,CACd,MAAMC,EAAK,KACX,GAAIA,EAAGC,aACH,OAAOD,EAAGC,aAEd,MACIC,EAAkBF,EAAG5B,wBACrB+B,EAAkBC,WAAWD,OAC7BE,EAAkBC,MAAMC,KAAKC,SAASC,iBAAiB,+BAA+B,CAAC,EACvFlC,EAAkB,CAAA,EACtB8B,OAAAA,EAAgBK,QAAQC,GAAQ,CAG5B,GAFAA,EAAOA,EAAKC,UAAU,EAAI,EAEtBV,GAAaS,EAAKE,KAAM,CACxB,IAAIC,EACAZ,IAAc,GACdY,EAASH,EAAKE,KAGT,KAAKxC,aACVyC,EAASH,EAAKE,KAAKE,QAAQZ,EAAQD,CAAS,EAG5CY,EAAS,IAAIE,IAAIL,EAAKM,aAAa,MAAM,EAAGf,CAAS,EAEzDS,EAAKO,aAAa,OAAQJ,CAAM,EAEpC,IAAIK,EAAYR,EAAKS,UACrB,GAAIlB,GAAa,SAASmB,KAAKV,EAAKW,OAAO,EAAG,CAC1C,MAAMC,EAAYvB,EAAGwB,wBAAwBtB,CAAS,EACtDiB,EAAYA,EAAUJ,QAAQ,0BAA2BQ,CAAS,EAEtEhD,EAAOY,KAAKgC,CAAS,CACzB,CAAC,EACD5C,EAAOY,KACF;;;;;;;;qBAQQ,EACNa,EAAGC,aAAeD,EAAG1B,aAAaC,CAAM,CACnD,CACA,IAAIwB,YAAY0B,EAAO,CACnB,KAAKxB,aAAewB,GAAQ,KAAKnD,aAAamD,CAAK,CACvD,CACAD,wBAAwBtB,EAAW,CAC/B,OAAO,SAASwB,EAAOC,EAAK,CACxB,IAAIb,EACJ,GAAI,CACA,IAAIc,EAEA,KAAKP,KAAKM,CAAG,EACbb,EAASY,GAGLxB,IAAc,GACd0B,EAAOxB,WAAWyB,SAAShB,KAGtB,KAAKxC,aACVuD,EAAOxB,WAAWyB,SAAShB,KAAKE,QAAQX,WAAWyB,SAAS1B,OAAQD,CAAS,EAG7E0B,EAAO1B,EAEXY,EAAU,QAAO,IAAIE,IAAIW,EAAKC,CAAI,EAAEf,gBAGrCiB,EAAP,CACIhB,EAASY,CACb,CACA,OAAOZ,CACX,EAAEiB,KAAK,IAAI,CACf,CACAC,UAAU,CAAEC,OAAAA,CAAO,EAAG,CAClB,KAAKC,MAAQD,EAAOC,KACxB,CACA,MAAMC,aAAa,CAAEF,OAAAA,CAAO,EAAG,CAC3B,MACIG,EAAY,CAAA,EACZC,EAAY,IAAIC,IACpBD,EAAUE,IACNN,EAAOO,WAAWC,IAAI,CAClBC,QAAS,CACLN,EAASjD,KAAK8C,EAAOO,WAAWG,MAAM,WAAW,CAAC,CACtD,CACJ,CAAC,CACL,EACAV,EAAOW,YAAY,CAAC,CAAEjE,OAAAA,EAAQ6D,WAAAA,CAAW,IAAM,CAC3CH,EAAUE,IACNC,EAAWC,IAAI,CACXC,QAAS,CACLN,EAASjD,KAAKqD,EAAWG,MAAM,WAAW,CAAC,CAC/C,CACJ,CAAC,CACL,EACAN,EAAUE,IACN5D,EAAO6D,WAAWC,IAAI,CAClBC,QAAS,CACLN,EAASjD,KAAKR,EAAO6D,WAAWG,MAAM,WAAW,CAAC,CACtD,CACJ,CAAC,CACL,CACJ,CAAC,EACDV,EAAOC,MAAQ,KAAKA,MACpB,MAAMW,QAAQjG,IAAIwF,CAAQ,EAC1BC,EAAU3B,QAAQoC,GAAMA,EAAE,CAAE,CAChC,CACAC,cAAe,CAEX,KAAKC,QAAUxC,SAASyC,cAAc,KAAK,CAC/C,CAEAC,aAAaF,EAASG,EAAS,KAAKH,QAASI,EAAQ,GAAM,CACnDA,IACAD,EAAOE,UAAY,IAEvBF,EAAOG,YAAYN,EAAQpC,UAAU,EAAI,CAAC,EAC1CtB,EAAUiE,mBAAmBJ,EAAQ,4CAA4C,EACjF,MAAMK,EAASL,EAAOM,cAAc,uBAAuB,EACvDD,GACAA,EAAOE,OAAM,CAErB,CACAC,kBAAkBC,EAAIR,EAAQ,GAAMS,EAAS,CAAA,EAAI,CAC7C,OAAIT,IACAQ,EAAGP,UAAY,IAEZ/D,EAAU2D,cAAca,OAAOC,OAAO,CACzCC,OAASJ,EACTK,GAASC,EAASC,WAAW,QAAQ,GACtCN,CAAM,CAAC,CACd,CACAO,eAAe,CAAEnC,OAAAA,CAAO,EAAG,CACvB,KAAM,CAAEoC,KAAAA,EAAMC,KAAAA,CAAK,EAAIrC,EACnBoC,GACA,KAAKrB,QAAQS,cAAe,IAAGY,EAAKJ,IAAI,EAAEP,OAAM,EAEhDY,GACA,KAAKtB,QAAQS,cAAe,IAAGa,EAAKL,IAAI,EAAEP,OAAM,CAExD,CAOAa,eAAerF,EAAO,GAAI,CAClBA,aAAgBsF,cAChBtF,EAAOA,EAAKkC,WAEhB,MAAM+B,EAAS7D,EAAU2D,cAAc,CACnCe,OAASxD,SAASiE,KAClBC,MAAS,CACLC,WAAa,SACbC,SAAa,YAGjB1F,KAAQ,kCAAiCA,kCAC7C,CAAC,EACK4B,EAASqC,EAAO0B,aAAe,EACrC1B,OAAAA,EAAOO,OAAM,EACN5C,CACX,CAEAgE,YAAY5F,EAAM,CACVA,aAAgBsF,cAChBtF,EAAOA,EAAKkC,WAEhB,MAAM+B,EAAS7D,EAAU2D,cAAc,CACnCe,OAASxD,SAASiE,KAClBC,MAAS,CACLC,WAAa,SACbC,SAAa,YAEjB1F,KAAAA,CACJ,CAAC,EACK6F,EAAW5B,EAAO1C,iBAAiB,KAAK,EAC9C,QAASuE,EAAI,EAAGC,EAAIF,EAASG,OAAQF,EAAIC,EAAGD,IACxCD,EAASC,CAAC,EAAE9D,aAAa,MAAO6D,EAASC,CAAC,EAAEG,GAAG,EAEnD,MAAMrE,EAASqC,EAAOE,UACtBF,OAAAA,EAAOO,OAAM,EACN5C,CACX,CACAsE,yBAAyBnD,EAAQ,CAC7B,IAAInB,EAAS,EAGbmB,OAAAA,EAAOW,YAAYyC,GAAW,CACtBA,EAAQC,0BACRxE,EAASxB,EAAUC,eAE3B,CAAC,EAEMuB,IAAW,EAAIA,EAAUA,EAAS,CAC7C,CAEAyE,SAAS9D,EAAO,CAGZ,OAAOA,EAAQ,EACnB,CACA+D,cAAc5D,EAAMH,EAAO,CACvB,OAAOgE,KAAKC,MAAO9D,EAAO,IAAQH,CAAM,EAAI,GAChD,CACAkE,oBAAoB1D,EAAQ,CACxB,MACI2D,EAAa3D,EAAO2D,WAEpBC,EAAoBD,EAAWE,KAAKC,QAAQH,EAAWI,eAAe,EACtEC,EAAoBL,EAAWE,KAAKC,QAAQH,EAAWM,cAAc,EACzE,IAAIpF,EAEJ,OAAI+E,IAAsB,GAGlBI,IAAqB,GACrBnF,EAASmB,EAAOkE,MAAMC,MAAQP,EAI9B/E,EAASmF,EAAmBJ,EAAoB,EAIpD/E,EAASmB,EAAOkE,MAAMC,MAEnBtF,CACX,CACA,MAAMuF,OAAOxC,EAAQ,CACjB,MAAM7D,EAAK,KACX,IAAIsG,EACJtG,EAAG+C,aAAY,EACf/C,EAAGgC,UAAU6B,CAAM,EACnB,MAAM7D,EAAGuG,iBAAiB1C,CAAM,EAChC,GAAI,CACAyC,EAAQ,MAAMtG,EAAGwG,SAAS3C,CAAM,CACpC,QAAC,CAEG,MAAM7D,EAAGyG,iBAAiB5C,CAAM,EAChC7D,EAAGD,YAAc,KAIjB,MAAM,IAAI8C,QAAQ6D,GAAW1G,EAAG2G,sBAAsBD,CAAO,CAAC,EAC9D,MAAM1G,EAAGmC,aAAa0B,CAAM,CAChC,CACA,OAAOyC,CACX,CACA,MAAME,SAAS3C,EAAQ,CACnB,MACI+C,EAAY,KAAKC,eAAehD,CAAM,EACtCyC,EAAY,CAAA,EAChB,IAAIQ,EACJ,MAAQA,EAAO,MAAMF,EAAUG,KAAI,IAAO,CAACD,EAAKE,MAC5CV,EAAMnH,KAAK2H,EAAKrF,KAAK,EAEzB,OAAO6E,CACX,CAGAW,gBAAgBhF,EAAQ,CACpB,KACI,CAAEiF,cAAAA,GAAkB,KAAKC,WACzB,CAAEvB,WAAAA,CAAW,EAAO3D,EACxB,KAAKmF,oBAAsB,CACvBC,iBAAmBzB,EAAWyB,iBAC9BC,gBAAmB1B,EAAW0B,iBAGlC,MAAMC,EAAoB9B,KAAK+B,KAAKN,EAAgBtB,EAAW6B,eAAe,EAC9E7B,EAAWyB,iBAAmBE,EAC9B3B,EAAW0B,gBAAmBC,EAC9BtF,EAAOyF,WAAU,EAGjBzF,EAAO2D,WAAW+B,eAAe1F,EAAOO,WAAWoF,CAAC,CACxD,CACAC,iBAAiB5F,EAAQ,CACrBA,EAAO2D,WAAWyB,iBAAmB,KAAKD,oBAAoBC,iBAC9DpF,EAAO2D,WAAW0B,gBAAmB,KAAKF,oBAAoBE,eAGlE,CACA,MAAMf,iBAAiB1C,EAAQ,CAC3B,MACI7D,EAAc,KACd,CACIiC,OAAAA,EACA6F,QAAAA,EACAC,UAAAA,EACAC,gBAAAA,EACAC,sBAAAA,CACJ,EAAIpE,EACJ,CAAE+B,WAAAA,CAAW,EAAI3D,EACjBkF,EAAcnH,EAAGmH,WAAa,CAC1Bc,sBAAAA,EACAC,WAAc,EACdC,YAAc,GAAKF,EAAwB,EAAIjI,EAAGoF,yBAAyBnD,CAAM,GACjFmG,SAAc,CAAA,GAEtBnG,EAAO6F,QAAQpH,QAAQ2H,GAAU,CACzBP,EAAQQ,SAASD,EAAOpE,EAAE,EAC1BoE,EAAOE,KAAI,EAGXF,EAAOG,KAAI,CAEnB,CAAC,EAID,MAAM,IAAI3F,QAAQ6D,GAAWzE,EAAO0E,sBAAsBD,CAAO,CAAC,EAC9DzE,EAAO2D,WAAW6C,SAAW,IACzBV,IAAcpL,EAAUC,IACxBuK,EAAWuB,sBAAwB9C,EAAWE,KAAK,CAAC,EAAE6C,WAGtDxB,EAAWuB,sBAAwB9C,EAAWI,gBAAgB2C,UAC9D9E,EAAO+E,UAAY,IAElBX,GACD,MAAMhG,EAAO4G,kBAAkB5G,EAAOkE,MAAM2C,MAAM3B,EAAWuB,qBAAqB,EAAG,CAAEK,MAAQ,OAAQ,CAAC,GAGhH,KAAM,CAAE/F,QAAAA,CAAQ,EAAIhD,EAEpBA,EAAGkD,aAAajB,EAAOe,OAAO,EAC9BhD,EAAGoE,eAAeP,CAAM,EACxB,IAAImF,EAEAf,IACAd,EAAW6B,QAAUA,EAAU/G,EAAO2D,WAAWqD,SAASC,IAAI,CAC1DC,IAAalH,EAAOmH,OACpBxD,WAAa3D,EAAO2D,WACpByD,KAAapH,EAEbqH,MAAa,IACbX,UAAa,GACjB,CAAC,GAEL1G,EAAOW,YAAYyC,GAAW,CAAA,IAAAkE,EAAAC,EAAAC,EAEtBT,IACA3D,EAAQqE,SAAS,CAAE5D,KAAO,CAACkD,CAAO,EAAGW,SAAW,EAAK,CAAC,EAGtDX,EAAQhG,QAAQ4G,QAAQC,SAAW5H,EAAOgC,IAE9C,MAAM6F,EAAc9J,EAAG2D,kBAAkBX,EAAQS,cAAe,QAAO4B,EAAQpB,MAAM,EAAG,EAAK,EAC7F,IAAIjH,EACAgL,GAAAA,MAAAA,EAAkB3C,EAAQ0E,MAAM,EAChC/M,EAAQqI,EAAQrC,QAAQgH,YAGxBhN,EAAQqI,EAAQyC,QAAQmC,eAAeC,OAAO,CAACpJ,EAAQuH,KAC/C,OAAOA,EAAOrL,OAAU,SACxB8D,GAAUuH,EAAOrL,MAGjB8D,IAAWmB,EAAOkI,YAAclI,EAAO2D,WAAWE,KAAK,CAAC,EAAEsE,QAAQ/B,EAAOpE,EAAE,EAAIoE,EAAOrF,SAASgH,YAE5FlJ,GACR,CAAC,EAERqG,EAAWe,YAAclL,EACzB,MAAMqN,IAAgBd,EAAAlE,EAAQiF,mBAAe,MAAAf,IAAvBA,OAAAA,OAAAA,EAAyBS,cAAe,EAC9D7C,EAAWe,YAAcmC,EACzBlD,EAAWiB,SAAS/C,EAAQ0E,MAAM,EAAI,CAClC9F,GAAWoB,EAAQpB,GACnBsG,WAAWf,EAAAnE,EAAQ1G,UAAM6K,MAAAA,IAAdA,OAAAA,OAAAA,EAAgBvF,KAAM,KACjCuG,WAAWf,EAAApE,EAAQzG,UAAM6K,MAAAA,IAAdA,OAAAA,OAAAA,EAAgBxF,KAAM,KACjC6B,KAAW,CAAA,EACXuE,cAAAA,EACAP,YAAAA,EACA9M,MAAAA,EAER,CAAC,CACL,CACAyN,sBAAuB,CACnB,MACIzK,EAAK,KACL,CAAEgD,QAAAA,EAASmE,WAAAA,CAAW,EAAInH,EAE9B8D,cAAO4G,OAAOvD,EAAWiB,QAAQ,EAAE1H,QAAQ,CAAC,CAAE1D,MAAAA,EAAOiH,GAAAA,EAAIsG,SAAAA,EAAUC,SAAAA,CAAS,IAAM,CAC9E,CAACvG,EAAIsG,EAAUC,CAAQ,EAAE9J,QAAQuD,GAAM,CACnC,GAAIA,EAAI,CACJ,MAAM0G,EAAe3H,EAAQS,cAAe,QAAOQ,KAAM,EAErD0G,IACAA,EAAajG,MAAM1H,MAAS,GAAEA,MAC9B2N,EAAajG,MAAMkG,KAAO,IAGtC,CAAC,CACL,CAAC,EACM5H,EAAQK,SACnB,CACA,MAAMoD,iBAAiB5C,EAAQ,CACvB,KAAKsD,WAAW6B,UAChB,KAAK7B,WAAW6B,QAAQ6B,QAAO,EAC/B,OAAO,KAAK1D,WAAW6B,QAE/B,CACA,MAAMH,kBAAkB5G,EAAQqH,EAAO,CACnC,MAAMrH,EAAO4G,kBAAkB5G,EAAOkE,MAAM2C,MAAMQ,CAAK,EAAG,CAAEP,MAAQ,OAAQ,CAAC,EAE7E,MAAM,IAAIlG,QAAQ6D,GAAW,KAAKC,sBAAsBD,CAAO,CAAC,CACpE,CACAoE,WAAWC,EAAK,CACZ,MACI3C,EAAW,KAAKjB,WAAWiB,SAC3B4C,EAAW,uBACflH,OAAOmH,QAAQF,EAAIhG,QAAQ,EAAErE,QAAQ,CAAC,CAACwK,EAAKzJ,CAAK,IAAM,CACnD2G,EAAS8C,CAAG,EAAEpF,KAAK3G,KAAK,CACpBsC,EAAML,UAAUL,QAAQiK,EAAI,EAAE,EAC9BD,EAAII,IACJJ,EAAIlG,aACJ,IAAIuG,GAAM,CACb,CACL,CAAC,CACL,CACAC,kBAAkBxH,EAAQyH,EAAWC,EAASzF,EAAM,CAChD,MACI9F,EAAe,KACf,CAAEiC,OAAAA,CAAO,EAAM4B,EACf,CAAEuE,SAAAA,GAAapI,EAAGmH,WAElBqE,EAAevJ,EAAOwJ,SAASC,WAAWC,uBAAuBL,EAAWC,EAASzF,CAAI,EAC7F,UAAW8F,KAAexD,EAAU,CAChC,MACI/C,EAAU+C,EAASwD,CAAW,EAC9BzI,EAAU3C,SAASyC,cAAc,KAAK,EAE1C4I,EAAQC,KAAK,CACTC,cAAgB5I,EAChB6I,UAAgB,CACZC,SAAWT,EAAaI,CAAW,EAAEK,QACzC,CACJ,CAAC,EACG9I,EAAO+I,WAAWhH,SAGlB/B,EAAO+I,WAAWxL,QAAQyL,GAAS,CAC/B,KACI,CAAEC,OAAAA,GAAWD,EAAMvC,QACnByC,EAAapK,EAAOwJ,SAASC,WAAWY,aACnCC,KAAKF,GAAK,CAAA,IAAAG,EAAA,QAAIA,EAAAH,EAAMI,eAAWD,MAAAA,IAAjBA,OAAAA,OAAAA,EAAmBE,WAAW9C,QAAQwC,UAAWA,EAAO,EAC3EC,IAEAF,EAAM9I,UAAYgJ,EAAMI,YAAYrL,UAE5C,CAAC,EACDiE,EAAQsH,gBAAkB,CAACxJ,EAAOE,SAAS,GAGvD,CACJ,CASAvF,EAAS8O,UAAU/F,eAAiB,iBAAkC,CAClE,MAAM,IAAIgG,MAAM,qCAAqC,CACzD,EACA/O,EAASgP,OAAS",
  "names": ["RowsRange", "all", "visible", "PaperFormat", "A6", "width", "height", "A5", "A4", "A3", "Legal", "Letter", "Orientation", "portrait", "landscape", "FileFormat", "pdf", "png", "FileMIMEType", "Exporter", "Delayable", "Events", "Localizable", "Base", "defaultConfig", "translateURLsToAbsolute", "keepPathName", "filterStyles", "styles", "pageTpl", "data", "title", "header", "footer", "htmlClasses", "bodyStyle", "bodyClasses", "paperHeight", "paperWidth", "html", "push", "constructor", "type", "DomHelper", "scrollBarWidth", "BrowserHelper", "isChrome", "isSafari", "isFirefox", "TemplateHelper", "tpl", "join", "stylesheets", "me", "_stylesheets", "translate", "origin", "globalThis", "styleSheetNodes", "Array", "from", "document", "querySelectorAll", "forEach", "node", "cloneNode", "href", "result", "replace", "URL", "getAttribute", "setAttribute", "styleText", "outerHTML", "test", "tagName", "converter", "getStyleTagURLConverter", "value", "match", "url", "base", "location", "e", "bind", "saveState", "client", "state", "restoreState", "promises", "detachers", "Set", "add", "scrollable", "ion", "scroll", "await", "eachSubGrid", "Promise", "fn", "beforeExport", "element", "createElement", "cloneElement", "target", "clear", "innerHTML", "appendChild", "removeEachSelector", "maskEl", "querySelector", "remove", "createPlaceholder", "el", "config", "Object", "assign", "parent", "id", "IdHelper", "generateId", "prepareElement", "tbar", "bbar", "measureElement", "HTMLElement", "body", "style", "visibility", "position", "offsetHeight", "prepareHTML", "elements", "i", "l", "length", "src", "getVirtualScrollerHeight", "subGrid", "overflowingHorizontally", "inchToPx", "getScaleValue", "Math", "floor", "getVisibleRowsCount", "rowManager", "firstVisibleIndex", "rows", "indexOf", "firstVisibleRow", "lastVisibleIndex", "lastVisibleRow", "store", "count", "export", "pages", "prepareComponent", "getPages", "restoreComponent", "resolve", "requestAnimationFrame", "generator", "pagesExtractor", "step", "next", "done", "adjustRowBuffer", "contentHeight", "exportMeta", "oldRowManagerConfig", "prependRowBuffer", "appendRowBuffer", "adjustedRowBuffer", "ceil", "rowOffsetHeight", "renderRows", "jumpToPosition", "y", "restoreRowBuffer", "columns", "rowsRange", "keepRegionSizes", "enableDirectRendering", "totalWidth", "totalHeight", "subGrids", "column", "includes", "show", "hide", "rowCount", "firstVisibleDataIndex", "dataIndex", "alignRows", "scrollRowIntoView", "getAt", "block", "fakeRow", "rowClass", "new", "cls", "rowCls", "grid", "index", "_subGrid$splitterElem", "_subGrid$header", "_subGrid$footer", "onAddRow", "isExport", "dataset", "ownerCmp", "placeHolder", "region", "offsetWidth", "visibleColumns", "reduce", "hideHeaders", "getCell", "splitterWidth", "splitterElement", "headerId", "footerId", "prepareExportElement", "values", "childElement", "flex", "destroy", "collectRow", "row", "re", "entries", "key", "top", "Map", "renderMergedCells", "fromIndex", "toIndex", "domConfigMap", "features", "mergeCells", "buildMergedCellsConfig", "subGridName", "DomSync", "sync", "targetElement", "domConfig", "children", "childNodes", "child", "syncId", "range", "mergedRanges", "find", "_range$cellElement", "cellElement", "parentNode", "mergedCellsHtml", "prototype", "Error", "_$name"]
}
