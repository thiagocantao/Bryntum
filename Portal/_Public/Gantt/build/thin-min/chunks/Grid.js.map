{
  "version": 3,
  "sources": ["../../../../Grid/lib/Grid/feature/ColumnAutoWidth.js", "../../../../Grid/lib/Grid/feature/RowCopyPaste.js", "../../../../Grid/lib/Grid/view/Grid.js"],
  "sourcesContent": ["import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\n\nconst storeListenerName = 'store';\n\n/**\n * @module Grid/feature/ColumnAutoWidth\n */\n\n/**\n * Enables the {@link Grid.column.Column#config-autoWidth} config for a grid's columns.\n *\n * This feature is <strong>enabled</strong> by default.\n *\n * @extends Core/mixin/InstancePlugin\n * @mixes Core/mixin/Delayable\n * @classtype columnAutoWidth\n * @feature\n */\nexport default class ColumnAutoWidth extends Delayable(InstancePlugin) {\n    static $name = 'ColumnAutoWidth';\n\n    //region Config\n\n    static configurable = {\n        /**\n         * The default `autoWidth` option for columns with `autoWidth: true`. This can\n         * be a single number for the minimum column width, or an array of two numbers\n         * for the `[minWidth, maxWidth]`.\n         * @config {Number|Number[]}\n         */\n        default : null,\n\n        /**\n         * The amount of time (in milliseconds) to delay after a store modification\n         * before synchronizing `autoWidth` columns.\n         * @config {Number}\n         * @default\n         */\n        delay : 0\n    };\n\n    //endregion\n\n    //region Internals\n\n    static get pluginConfig() {\n        return {\n            after : {\n                bindStore        : 'bindStore',\n                unbindStore      : 'unbindStore',\n                renderRows       : 'syncAutoWidthColumns',\n                onInternalResize : 'onInternalResize'\n            },\n\n            assign : [\n                'columnAutoWidthPending',\n                'syncAutoWidthColumns'\n            ]\n        };\n    }\n\n    construct(config) {\n        super.construct(config);\n\n        const { store } = this.client;\n\n        // The initial bindStore can come super early such that our hooks won't catch it:\n        store && this.bindStore(store);\n    }\n\n    doDestroy() {\n        this.unbindStore();\n\n        super.doDestroy();\n    }\n\n    bindStore(store) {\n        this.lastSync = null;\n\n        store.ion({\n            name : storeListenerName,\n\n            [`change${this.client.asyncEventSuffix}`] : 'onStoreChange',\n\n            thisObj : this\n        });\n    }\n\n    unbindStore() {\n        this.detachListeners(storeListenerName);\n    }\n\n    get columnAutoWidthPending() {\n        return this.lastSync === null || this.hasTimeout('syncAutoWidthColumns');\n    }\n\n    onStoreChange({ action }) {\n        if (action !== 'move') {\n            const\n                me           = this,\n                { cellEdit } = me.client.features;\n\n            ++me.storeGeneration;\n\n            // If we are editing, sync right away so cell editing can align correctly to next cell\n            // unless editing is finished/canceled by tapping outside of grid body\n            if (cellEdit?.isEditing && !cellEdit.editingStoppedByTapOutside) {\n                me.syncAutoWidthColumns();\n            }\n            else if (!me.hasTimeout('syncAutoWidthColumns')) {\n                me.setTimeout('syncAutoWidthColumns', me.delay);\n            }\n        }\n    }\n\n    // Handle scenario with Grid being inside DIV with display none, and no width. Sync column widths after being shown\n    onInternalResize(element, newWidth, newHeight, oldWidth) {\n        if (oldWidth === 0) {\n            // Force remeasure after we get a width\n            this.lastSync = null;\n            this.syncAutoWidthColumns();\n        }\n    }\n\n    syncAutoWidthColumns() {\n        const\n            me = this,\n            {\n                client,\n                storeGeneration\n            }  = me;\n\n        // No point in measuring if we are a split controlled by an original grid\n        if (client.splitFrom) {\n            return;\n        }\n\n        if (me.lastSync !== storeGeneration) {\n            me.lastSync = storeGeneration;\n\n            let autoWidth, resizingColumns;\n\n            for (const column of client.columns.visibleColumns) {\n                autoWidth = column.autoWidth;\n\n                if (autoWidth) {\n                    if (autoWidth === true) {\n                        autoWidth = me.default;\n                    }\n\n                    client.resizingColumns = resizingColumns = true;\n                    column.resizeToFitContent(autoWidth);\n                }\n            }\n\n            if (resizingColumns) {\n                client.resizingColumns = false;\n                client.afterColumnsResized();\n            }\n        }\n\n        if (me.hasTimeout('syncAutoWidthColumns')) {\n            me.clearTimeout('syncAutoWidthColumns');\n        }\n    }\n\n    //endregion\n}\n\nColumnAutoWidth.prototype.storeGeneration = 0;\n\nGridFeatureManager.registerFeature(ColumnAutoWidth, true);\n", "import GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport CopyPasteBase from './base/CopyPasteBase.js';\nimport Location from '../util/Location.js';\n\n/**\n * @module Grid/feature/RowCopyPaste\n */\n\n/**\n * Allow using [Ctrl/CMD + C/X] and [Ctrl/CMD + V] to copy/cut and paste rows. Also makes cut, copy and paste actions\n * available via the cell context menu.\n *\n * You can configure how a newly pasted record is named using {@link #function-generateNewName}\n *\n * This feature is **enabled** by default\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         rowCopyPaste : true\n *     }\n * });\n * ```\n *\n * {@inlineexample Grid/feature/RowCopyPaste.js}\n *\n * This feature will work alongside with CellCopyPaste but there is differences on functionality.\n * * When used together, context menu options will be detailed so the user will know to copy the cell or the row.\n * * They will also detect what type of selection is present at the moment. If there is only rows selected, only row\n *   alternatives are shown in the context menu and the keyboard shortcuts will be processed by RowCopyPaste.\n * * If there is only cells selected, there will be context menu options for both row and cell but keyboard shortcuts\n *   will be handled by CellCopyPaste.\n * * They do share clipboard, even if internal clipboard is used, so it is not possible to have rows and cells copied or\n *   cut at the same time.\n *\n * ## Keyboard shortcuts\n * The feature has the following default keyboard shortcuts:\n *\n * | Keys       | Action  | Weight ¹ | Action description                                                                      |\n * |------------|---------|:--------:|-----------------------------------------------------------------------------------------|\n * | `Ctrl`+`C` | *copy*  | 10       | Calls {@link #function-copyRows} which copies selected row(s) into the clipboard.       |\n * | `Ctrl`+`X` | *cut*   | 10       | Calls {@link #function-copyRows} which cuts out selected row(s) and saves in clipboard. |\n * | `Ctrl`+`V` | *paste* | 10       | Calls {@link #function-pasteRows} which inserts copied or cut row(s) from the clipboard.|\n *\n * **¹** Customization of keyboard shortcuts that has a `weight` can affect other features that also uses that\n * particular keyboard shortcut. Read more in [our guide](#Grid/guides/customization/keymap.md).\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#Grid/guides/customization/keymap.md).\n *\n * @extends Grid/feature/base/CopyPasteBase\n * @classtype rowCopyPaste\n * @feature\n */\nexport default class RowCopyPaste extends CopyPasteBase {\n\n    static $name = 'RowCopyPaste';\n    static type  = 'rowCopyPaste';\n\n    static pluginConfig = {\n        assign : [\n            'copyRows',\n            'pasteRows'\n        ],\n        chain : [\n            'populateCellMenu'\n        ]\n    };\n\n    static configurable = {\n        /**\n         * The field to use as the name field when updating the name of copied records\n         * @config {String}\n         * @default\n         */\n        nameField : 'name',\n\n        keyMap : {\n            // Weight to give CellCopyPaste priority\n            'Ctrl+C' : { weight : 10, handler : 'copy' },\n            'Ctrl+X' : { weight : 10, handler : 'cut' },\n            'Ctrl+V' : { weight : 10, handler : 'paste' }\n        },\n\n        copyRecordText         : 'L{copyRecord}',\n        cutRecordText          : 'L{cutRecord}',\n        pasteRecordText        : 'L{pasteRecord}',\n        rowSpecifierText       : 'L{row}',\n        rowSpecifierTextPlural : 'L{rows}',\n        localizableProperties  : [\n            'copyRecordText',\n            'cutRecordText',\n            'pasteRecordText',\n            'rowSpecifierText',\n            'rowSpecifierTextPlural'\n        ],\n\n        /**\n         * Adds `Cut (row)`, `Copy (row)` and `Paste (row)` options when opening a context menu on a selected cell when\n         * {@link Grid.view.mixin.GridSelection#config-selectionMode cellSelection} and\n         * {@link Grid.feature.CellCopyPaste} is active. Default behaviour will only provide row copy/paste actions on a\n         * selected row.\n         * @config {Boolean}\n         * @default\n         */\n        rowOptionsOnCellContextMenu : false\n\n    };\n\n    construct(grid, config) {\n        super.construct(grid, config);\n\n        grid.rowManager.ion({\n            beforeRenderRow : 'onBeforeRenderRow',\n            thisObj         : this\n        });\n\n        this.grid = grid;\n    }\n\n    // Used in events to separate events from different features from each other\n    entityName = 'row';\n\n    onBeforeRenderRow({ row, record }) {\n        row.cls['b-cut-row'] = this.isCut && this.cutData?.includes(record);\n    }\n\n    isActionAvailable({ key, action, event }) {\n        const\n            { grid }     = this,\n            { cellEdit } = grid.features,\n            { target }   = event;\n        // No action if\n        // 1. there is selected text on the page\n        // 2. cell editing is active\n        // 3. cursor is not in the grid (filter bar etc)\n        return !this.disabled &&\n            globalThis.getSelection().toString().length === 0 &&\n            (!cellEdit || !cellEdit.isEditing) &&\n            (action === 'copy' || !this.copyOnly) && // Do not allow cut or paste if copyOnly flag is set\n            grid.selectedRecords?.length > 0 && // No key action when no selected records\n            (!target || Boolean(target.closest('.b-gridbase:not(.b-schedulerbase) .b-grid-subgrid,.b-grid-subgrid:not(.b-timeaxissubgrid)')));\n    }\n\n    async copy() {\n        await this.copyRows();\n    }\n\n    async cut() {\n        await this.copyRows(true);\n    }\n\n    paste(referenceRecord) {\n        return this.pasteRows(referenceRecord?.isModel ? referenceRecord : null);\n    }\n\n    /**\n     * Copy or cut rows to clipboard to paste later\n     *\n     * @fires beforeCopy\n     * @fires copy\n     * @param {Boolean} [isCut] Copies by default, pass `true` to cut\n     * @category Common\n     * @on-owner\n     * @async\n     */\n    async copyRows(isCut = false) {\n        const\n            { client, entityName } = this,\n            // Don't cut readOnly records\n            records                = this.selectedRecords.filter(r => !r.readOnly || !isCut);\n\n        if (!records.length || client.readOnly) {\n            return;\n        }\n\n        await this.writeToClipboard(records, isCut);\n\n        /**\n         * Fires on the owning Grid after a copy action is performed.\n         * @event copy\n         * @on-owner\n         * @param {Grid.view.Grid} source Owner grid\n         * @param {Core.data.Model[]} records The records that were copied\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'row' to distinguish this event from other copy events\n         */\n        client.trigger('copy', { records, isCut, entityName });\n    }\n\n    // Called from Clipboardable when cutData changes\n    setIsCut(record, isCut) {\n        this.grid.rowManager.getRowById(record)?.toggleCls('b-cut-row', isCut);\n        record.meta.isCut = isCut;\n    }\n\n    // Called from Clipboardable when cutData changes\n    handleCutData({ source }) {\n        if (source !== this && this.cutData?.length) {\n            this.grid.store.remove(this.cutData);\n        }\n    }\n\n    /**\n     * Called from Clipboardable after writing a non-string value to the clipboard\n     * @param eventRecords\n     * @returns {String}\n     * @private\n     */\n    stringConverter(records) {\n        return this.cellsToString(\n            records.flatMap(r => this.grid.rowManager.getRowById(r)?.cells.map(c => new Location(c))));\n    }\n\n    // Called from Clipboardable before writing to the clipboard\n    async beforeCopy({ data, isCut }) {\n        /**\n         * Fires on the owning Grid before a copy action is performed, return `false` to prevent the action\n         * @event beforeCopy\n         * @preventable\n         * @on-owner\n         * @async\n         * @param {Grid.view.Grid} source Owner grid\n         * @param {Core.data.Model[]} records The records about to be copied\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'row' to distinguish this event from other beforeCopy events\n         */\n        return await this.client.trigger('beforeCopy', { records : data, isCut, entityName : this.entityName });\n    }\n\n    /**\n     * Paste rows below selected or passed record\n     *\n     * @fires beforePaste\n     * @param {Core.data.Model} [record] Paste below this record, or currently selected record if left out\n     * @category Common\n     * @on-owner\n     */\n    async pasteRows(record) {\n        const\n            me                            = this,\n            { client, isCut, entityName } = me,\n            referenceRecord               = record || client.selectedRecord;\n\n        if (client.readOnly || client.isTreeGrouped) {\n            return [];\n        }\n\n        const\n            records = await me.readFromClipboard({ referenceRecord }, true),\n            isOwn   = me.clipboardData === records;\n\n        if (!Array.isArray(records) || !records?.length ||\n            (client.store.tree && isCut && records.some(rec => rec.contains(referenceRecord, true)))\n        ) {\n            return [];\n        }\n\n        // sort selected to move records to make sure it will be added in correct order independent of how it was selected.\n        // Should be done with real records in the clipboard, after records are copied, all indexes will be changed\n        me.sortByIndex(records);\n\n        const\n            idMap            = {},\n            // We need to go over selected records, find all top level nodes and reassemble the tree\n            recordsToProcess = me.extractParents(records, idMap, isOwn);\n\n        await me.insertCopiedRecords(recordsToProcess, referenceRecord);\n\n        if (client.isDestroying) {\n            return;\n        }\n\n        if (isCut) {\n            // reset clipboard\n            await me.clearClipboard();\n        }\n        else {\n            client.selectedRecords = recordsToProcess;\n        }\n\n        /**\n         * Fires on the owning Grid after a paste action is performed.\n         * @event paste\n         * @on-owner\n         * @param {Grid.view.Grid} source Owner grid\n         * @param {Core.data.Model} referenceRecord The reference record, below which the records were pasted\n         * @param {Core.data.Model[]} records Pasted records\n         * @param {Core.data.Model[]} originalRecords For a copy action, these are the records that were copied.\n         * For cut action, this is same as the `records` param.\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'row' to distinguish this event from other paste events\n         */\n        client.trigger('paste', {\n            records         : recordsToProcess,\n            originalRecords : records,\n            referenceRecord,\n            isCut,\n            entityName\n        });\n        me.clipboard.triggerPaste(me);\n\n        // Focus first cell of last copied or cut row\n        client.getRowFor(recordsToProcess[recordsToProcess.length - 1])?.cells?.[0]?.focus();\n\n        return recordsToProcess;\n    }\n\n    // Called from Clipboardable before finishing the internal clipboard read\n    async beforePaste({ referenceRecord, data, text, isCut }) {\n        const records = data !== text ? data : [];\n\n        /**\n         * Fires on the owning Grid before a paste action is performed, return `false` to prevent the action\n         * @event beforePaste\n         * @preventable\n         * @on-owner\n         * @async\n         * @param {Grid.view.Grid} source Owner grid\n         * @param {Core.data.Model} referenceRecord The reference record, the clipboard event records will\n         * be pasted above this record\n         * @param {Core.data.Model[]} records The records about to be pasted\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'row' to distinguish this event from other beforePaste events\n         */\n        return await this.client.trigger('beforePaste', {\n            records, referenceRecord, isCut, entityName : this.entityName, data\n        });\n    }\n\n    /**\n     * Called from Clipboardable after reading from clipboard, and it is determined that the clipboard data is\n     * \"external\"\n     * @param json\n     * @private\n     */\n    stringParser(clipboardData) {\n        return this.setFromStringData(clipboardData, true).modifiedRecords;\n    }\n\n    /**\n     * A method used to generate the name for a copy-pasted record. By defaults appends \"- 2\", \"- 3\" as a suffix. Override\n     * it to provide your own naming of pasted records.\n     *\n     * @param {Core.data.Model} record The new record being pasted\n     * @returns {String}\n     */\n    generateNewName(record) {\n        const originalName = record.getValue(this.nameField);\n        let counter = 2;\n\n        while (this.client.store.findRecord(this.nameField, `${originalName} - ${counter}`)) {\n            counter++;\n        }\n\n        return `${originalName} - ${counter}`;\n    }\n\n    insertCopiedRecords(toInsert, recordReference) {\n        const\n            { store } = this.client,\n            insertAt  = store.indexOf(recordReference) + 1;\n\n        if (store.tree) {\n            return recordReference.parent.insertChild(toInsert, recordReference.nextSibling, false, {\n                // Specify node to insert before in the ordered tree. It allows to paste to a\n                // correct place both ordered and visual.\n                // Covered by TaskOrderedWbs.t.js\n                orderedBeforeNode : recordReference.nextOrderedSibling\n            });\n        }\n        else {\n            return store.insert(insertAt, toInsert);\n        }\n    }\n\n    get selectedRecords() {\n        const records = [...this.client.selectedRecords];\n\n        // Add eventual selected cells records\n        this.client.selectedCells.forEach(cell => {\n            if (!records.includes(cell.record)) {\n                records.push(cell.record);\n            }\n        });\n\n        return records;\n    }\n\n    getMenuItemText(action, addRowSpecifier = false) {\n        const me = this;\n        let text = me[action + 'RecordText'];\n\n        // If cellCopyPaste is enabled and there is selected cells, add a row specifier text to menu options\n        if (addRowSpecifier) {\n            text += ` (${me.selectedRecords.length > 1 ? me.rowSpecifierTextPlural : me.rowSpecifierText})`;\n        }\n\n        return text;\n    }\n\n    populateCellMenu({ record, items, cellSelector }) {\n        const\n            me           = this,\n            {\n                client,\n                rowOptionsOnCellContextMenu\n            }            = me,\n            cellCopyPaste = client.features.cellCopyPaste?.enabled === true,\n            // If cellCopyPaste is active and contextmenu originates from a selected cell\n            targetIsCell = cellCopyPaste && client.isCellSelected(cellSelector);\n\n        if (!client.readOnly &&\n            !client.isTreeGrouped &&\n            record?.isSpecialRow === false &&\n            (cellCopyPaste ? client.selectedRows.length : client.selectedRecords.length) &&\n            (!targetIsCell || me.rowOptionsOnCellContextMenu)\n        ) {\n            if (!me.copyOnly) {\n                items.cut = {\n                    text        : me.getMenuItemText('cut', targetIsCell && rowOptionsOnCellContextMenu),\n                    localeClass : me,\n                    icon        : 'b-icon b-icon-cut',\n                    weight      : 135,\n                    disabled    : record.readOnly,\n                    onItem      : () => me.cut()\n                };\n\n                items.paste = {\n                    text        : me.getMenuItemText('paste', targetIsCell && rowOptionsOnCellContextMenu),\n                    localeClass : me,\n                    icon        : 'b-icon b-icon-paste',\n                    weight      : 140,\n                    onItem      : () => me.paste(record),\n                    disabled    : me.hasClipboardData() === false\n                };\n            }\n\n            items.copy = {\n                text        : me.getMenuItemText('copy', targetIsCell && rowOptionsOnCellContextMenu),\n                localeClass : me,\n                cls         : 'b-separator',\n                icon        : 'b-icon b-icon-copy',\n                weight      : 120,\n                onItem      : () => me.copy()\n            };\n\n        }\n    }\n\n    /**\n     * Sort array of records ASC by its indexes stored in indexPath\n     * @param {Core.data.Model[]} array array to sort\n     * @private\n     */\n    sortByIndex(array) {\n        const { store } = this.client;\n\n        return array.sort((rec1, rec2) => {\n            const\n                idx1 = rec1.indexPath,\n                idx2 = rec2.indexPath;\n\n            // When a record is copied without its parent, its index in the visible tree should be used\n            if (!array.includes(rec1.parent) && !array.includes(rec2.parent)) {\n                // For row copy-paste feature both records are normally in store. Unless someone wants\n                // to include invisible records. Which does not happen yet.\n                return store.indexOf(rec1) - store.indexOf(rec2);\n            }\n\n            if (idx1.length === idx2.length) {\n                for (let i = 0; i < idx1.length; i++) {\n                    if (idx1[i] < idx2[i]) {\n                        return -1;\n                    }\n                    if (idx1[i] > idx2[i]) {\n                        return 1;\n                    }\n                }\n                return 0;\n            }\n            else {\n                return idx1.length - idx2.length;\n            }\n        });\n    }\n\n    /**\n     * Iterates over passed pre-sorted list of records and reassembles hierarchy of records.\n     * @param {Core.data.Model[]} taskRecords array of records to extract parents from\n     * @param {Object} idMap Empty object which will contain map linking original id with copied record\n     * @returns {Core.data.Model[]} Returns array of new top-level nodes with children filled\n     * @private\n     */\n    extractParents(taskRecords, idMap, generateNames = true) {\n        const\n            me        = this,\n            { store } = me.client;\n\n        // Unwrap children to pass them all through `generateNewName` function\n        if (store.tree) {\n            taskRecords.forEach(node => {\n                node.traverse(n => {\n                    const parents = n.getTopParent(true);\n                    if (!taskRecords.includes(n) && (!me.isCut || !taskRecords.some(rec => parents.includes(rec)))) {\n                        taskRecords.push(n);\n                    }\n                });\n            });\n        }\n\n        const result = taskRecords.reduce((parents, node) => {\n            let copy;\n            // Fallback is for when the node was removed from the tree\n            const parentId = node.parentId || node.meta.modified;\n\n            if (me.isCut) {\n                copy = node;\n\n                // reset record cut state\n                copy.meta.isCut = false;\n            }\n            else {\n                copy               = node.copy();\n                if (generateNames) {\n                    copy[me.nameField] = me.generateNewName(copy);\n                }\n\n                // Ensure initial expanded state in new node matches state that the client's\n                // store has for source node.\n                copy.data.expanded = node.isExpanded(me.client.store);\n            }\n\n            idMap[node.id] = copy;\n\n            // If we're copying top level node, add it directly\n            if (node.parent === store.rootNode) {\n                parents.push(copy);\n            }\n            // If node parent is also copied, append copy to the copied parent. Parents\n            // are always at the beginning of the array, so we know if there is a parent\n            // it was already copied\n            else if (parentId in idMap) {\n                idMap[parentId].appendChild(copy, true); // Silent to not cause redraws\n            }\n            // If parent is not copied and record is not top level, then append it as a\n            // sibling.\n            else {\n                parents.push(copy);\n            }\n            return parents;\n        }, []);\n\n        // Now when tree is assembled we want to restore ordered tree. Traverse the tree, sort children\n        // by previous value of `orderedParentIndex`\n        result.forEach(parent => {\n            parent.sortOrderedChildren(true, true);\n        });\n\n        return result;\n    }\n\n};\n\nRowCopyPaste.featureClass = 'b-row-copypaste';\n\nGridFeatureManager.registerFeature(RowCopyPaste, true, 'Grid');\nGridFeatureManager.registerFeature(RowCopyPaste, false, 'Gantt');\nGridFeatureManager.registerFeature(RowCopyPaste, false, 'SchedulerPro');\nGridFeatureManager.registerFeature(RowCopyPaste, false, 'ResourceHistogram');\n", "//region Import\n\nimport GridBase from './GridBase.js';\n\n// import default features (might be able to skip this when draft on dynamic import is implemented)\nimport '../feature/CellEdit.js';\nimport '../feature/CellMenu.js';\nimport '../feature/ColumnAutoWidth.js';\nimport '../feature/ColumnDragToolbar.js';\nimport '../feature/ColumnPicker.js';\nimport '../feature/ColumnReorder.js';\nimport '../feature/ColumnResize.js';\nimport '../feature/Filter.js';\nimport '../feature/FilterBar.js';\nimport '../feature/Group.js';\nimport '../feature/HeaderMenu.js';\nimport '../feature/RowCopyPaste.js';\nimport '../feature/Sort.js';\nimport '../feature/Stripe.js';\n\n// To enable using checkbox selection mode, moved here to not be dragged into GridBase automatically\nimport '../column/CheckColumn.js';\n\n//endregion\n\n/**\n * @module Grid/view/Grid\n */\n\n/**\n * The Grid component is a very powerful and performant UI component that shows tabular data (or tree data using the\n * {@link Grid.view.TreeGrid}).\n *\n * <h2>Intro</h2>\n * The Grid widget has a wide range of features and a large API to allow users to work with data efficiently in the\n * browser. The two most important configs are {@link #config-store} and {@link #config-columns}. With the store config,\n * you decide which data to load into the grid. You can work with both in-memory arrays or load data using ajax. See the\n * {@link Core.data.Store} class to learn more about loading data into stores.\n *\n * The columns config accepts an array of {@link Grid.column.Column Column} descriptors defining which fields that will\n * be displayed in the grid. The {@link Grid.column.Column#config-field} property in the column descriptor maps to a\n * field in your dataset. The simplest grid configured with inline data and two columns would look like this:\n *\n * {@frameworktabs}\n * {@js}\n *\n *  ```javascript\n *  const grid = new Grid({\n *       appendTo : document.body,\n *\n *       columns: [\n *           { field: 'name', text: 'Name' },\n *           { field: 'job', text: 'Job', renderer: ({value}) => value || 'Unemployed' }\n *       ],\n *\n *       data: [\n *           { name: 'Bill', job: 'Retired' },\n *           { name: 'Elon', job: 'Visionary' },\n *           { name: 'Me' }\n *       ]\n * });\n * ```\n *\n * {@endjs}\n * {@react}\n *\n * ```jsx\n * const App = props => {\n *     const [columns, setColumns] = useState([\n *          { field: 'name', text: 'Name' },\n *          { field: 'job', text: 'Job', renderer: ({value}) => value || 'Unemployed' }\n *     ]);\n *\n *     const [data, setData] = useState([\n *          { name: 'Bill', job: 'Retired' },\n *          { name: 'Elon', job: 'Visionary' },\n *          { name: 'Me' }\n *     ]);\n *\n *     return <BryntumGrid column={columns} data={data} />\n * }\n * ```\n *\n * {@endreact}\n * {@vue}\n *\n *  ```html\n * <bryntum-grid :columns=\"columns\" :data=\"data\" />\n * ```\n *\n * ```javascript\n * export default {\n *    setup() {\n *      return {\n *        columns : [\n *          { field: 'name', text: 'Name' },\n *          { field: 'job', text: 'Job', renderer: ({value}) => value || 'Unemployed' }\n *        ]\n *        data : reactive([\n *          { name: 'Bill', job: 'Retired' },\n *          { name: 'Elon', job: 'Visionary' },\n *          { name: 'Me' }\n *        ])\n *      };\n *    }\n * }\n * ```\n *\n * {@endvue}\n * {@angular}\n * ```html\n * <bryntum-grid [columns]=\"columns\" [data]=\"data\"></bryntum-grid>\n * ```\n *\n * ```typescript\n * export class AppComponent {\n *      columns = [\n *          { field: 'name', text: 'Name' },\n *          { field: 'job', text: 'Job', renderer: ({value}) => value || 'Unemployed' }\n *      ]\n *\n *      data = [\n *          { name: 'Bill', job: 'Retired' },\n *          { name: 'Elon', job: 'Visionary' },\n *          { name: 'Me' }\n *      ]\n *  }\n * ```\n *\n * {@endangular}\n * {@endframeworktabs}\n *\n * {@inlineexample Grid/view/Grid.js}\n *\n * <h2>Features</h2>\n * To avoid the Grid core being bloated, its main features are implemented in separate `feature` classes. These can be\n * turned on and off based on your requirements. To configure (or disable) a feature, use the {@link #config-features}\n * object to provide your desired configuration for the features you want to use. Each feature has an ´id´ that you use\n * as a key in the features object:\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         cellEdit     : false,\n *         regionResize : true,\n *         cellTooltip  : {\n *             tooltipRenderer : (data) => {\n *             }\n *         },\n *         ...\n *     }\n * });\n * ```\n *\n * {@region Column configuration options}\n * A grid contains a number of columns that control how your data is rendered. The simplest option is to simply point a\n * Column to a field in your dataset, or define a custom {@link Grid.column.Column#config-renderer}. The renderer\n * function receives one object parameter containing rendering data for the current cell being rendered.\n *\n * ```javascript\n * const grid = new Grid({\n *     columns: [\n *         {\n *             field: 'task',\n *             text: 'Task',\n *             renderer(renderData) {\n *                 const record = renderData.record;\n *\n *                 if (record.percentDone === 100) {\n *                     renderData.cellElement.classList.add('taskDone');\n *                     renderData.cellElement.style.background = 'green';\n *                 }\n *\n *                 return renderData.value;\n *             }\n *         }\n *     ]\n * });\n * ```\n *\n * {@endregion}\n * {@region Grid sections (aka \"locked\" or \"frozen\" columns)}\n * The grid can be divided horizontally into individually scrollable sections. This is great if you have lots of columns\n * that don't fit the available width of the screen. To enable this feature, simply mark the columns you want to `lock`.\n * Locked columns are then displayed in their own section to the left of the other columns:\n *\n * ```javascript\n * const grid = new Grid({\n *     width    : 500,\n *     subGridConfigs : {\n *         // set a fixed locked section width if desired\n *         locked : { width: 300 }\n *     },\n *     columns : [\n *         { field : 'name', text : 'Name', width : 200, locked : true },\n *         { field : 'firstName', text : 'First name', width : 100, locked : true },\n *         { field : 'surName', text : 'Last name', width : 100, locked : true },\n *         { field : 'city', text : 'City', width : 100 },\n *         { type : 'number', field : 'age', text : 'Age', width : 200 },\n *         { field : 'food', text : 'Food', width : 200 }\n *     ]\n * });\n * ```\n *\n * {@inlineexample Grid/view/LockedGrid.js}\n * You can also move columns between sections by using drag and drop, or use the built-in header context menu. If you\n * want to be able to resize the locked grid section, enable the {@link Grid.feature.RegionResize} feature.\n * {@endregion}\n * {@region Filtering}\n * One important requirement of a good Grid component is the ability to filter large datasets to quickly find what you\n * are looking for. To enable filtering (through the context menu), add the {@link Grid.feature.Filter} feature:\n *\n * ```javascript\n * const grid = new Grid({\n *     features: {\n *         filter: true\n *     }\n * });\n * ```\n *\n * Or activate a default filter at initial rendering:\n *\n * ```javascript\n * const grid = new Grid({\n *     features: {\n *         filter: { property : 'city', value : 'New York' }\n *     }\n * });\n * ```\n *\n * {@inlineexample Grid/feature/Filter.js}\n * {@endregion}\n * {@region Tooltips}\n * If you have a data models with many fields, and you want to show\n * additional data when hovering over a cell, use the {@link Grid.feature.CellTooltip} feature. To show a\n * tooltip for all cells:\n *\n * ```javascript\n * const grid = new Grid({\n *     features: {\n *         cellTooltip: ({value}) => value\n *     }\n * });\n * ```\n *\n * {@inlineexample Grid/feature/CellTooltip.js}\n * {@endregion}\n * {@region Inline Editing (default <strong>on</strong>)}\n * To enable inline cell editing in the grid, simply add the {@link Grid.feature.CellEdit} feature:\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         cellEdit : true\n *     },\n *     columns: [\n *         {\n *             field: 'task',\n *             text: 'Task'\n *         }\n *     ]\n * });\n * ```\n *\n * {@inlineexample Grid/feature/CellEdit.js}\n * {@endregion}\n * {@region Context Menu}\n * Use {@link Grid.feature.CellMenu} and {@link Grid.feature.HeaderMenu} features if you want your users to be able to\n * interact with the data through the context menu:\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         headerMenu : {\n *             items : {\n *                 showInfo : {\n *                     text   : 'Show info',\n *                     icon   : 'fa fa-info-circle',\n *                     weight : 200,\n *                     onItem : ({ item }) => console.log(item.text)\n *                 }\n *             }\n *         },\n *         cellMenu :  {\n *             items : {\n *                 showOptions : {\n *                     text   : 'Show options',\n *                     icon   : 'fa fa-gear',\n *                     weight : 200\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * {@inlineexample Grid/feature/CellMenu.js}\n * {@endregion}\n * {@region Grouping}\n * To group rows by a field in your dataset, use the {@link Grid.feature.Group} feature.\n * {@inlineexample Grid/feature/Group.js}\n * {@endregion}\n * {@region Searching}\n * When working with lots of data, a quick alternative to filtering is the {@link Grid.feature.Search} feature.\n * It highlights matching values in the grid as you type.\n * {@inlineexample Grid/feature/Search2.js}\n * {@endregion}\n * {@region Loading and saving data}\n * The grid keeps all its data in a {@link Core.data.Store}, which is essentially an Array of {@link Core.data.Model}\n * items. You define your own Model representing your data entities and use the Model API to get and set values.\n *\n * ```javascript\n * class Person extends Model {}\n *\n * const person = new Person({\n *     name: 'Steve',\n *     age: 38\n * });\n *\n * person.name = 'Linda'; // person object is now `dirty`\n *\n * const store = new Store({\n *     data : [\n *         { name : 'Don', age : 40 }\n *     ]\n * });\n *\n * store.add(person);\n *\n * console.log(store.count()); // === 2\n *\n * store.remove(person); // Remove from store\n * ```\n *\n * When you update a record in a store, it's considered dirty, until you call {@link Core.data.mixin.StoreCRUD#function-commit}\n * on the containing Store. You can also configure your Store to commit automatically (like Google docs). If you use an\n * AjaxStore, it will send changes to your server when commit is called.\n *\n * Any changes you make to the Store or its records are immediately reflected in the Grid, so there is no need to tell\n * it to refresh manually.\n *\n * To create a custom load mask, subscribe to the grid's store events and {@link Core.widget.Widget#config-masked mask}\n * on {@link Core.data.AjaxStore#event-beforeRequest} and unmask on {@link Core.data.AjaxStore#event-afterRequest}. The\n * mask can also be used to display error messages if an {@link Core.data.AjaxStore#event-exception} occurs.\n *\n * ```javascript\n *  const grid = new Grid({\n *      loadMask : null\n *  });\n *\n *  grid.store.on({\n *      beforeRequest() {\n *          grid.masked = {\n *              text : 'Data is loading...'\n *          };\n *      },\n *      afterRequest() {\n *          grid.masked = null;\n *      },\n *      exception({ response }) {\n *          grid.masked.error = response.message || 'Load failed';\n *      }\n *  });\n *\n *  store.load();\n * ```\n *\n * To learn more about loading and saving data, please refer to [this guide](#Grid/guides/data/displayingdata.md).\n * {@endregion}\n * {@region Default configs}\n * There is a myriad of configs and features available for Grid, some of them on by default and some of them requiring\n * extra configuration. The code below tries to illustrate the major things that are used by default:\n *\n * ```javascript\n * const grid = new Grid({\n *    // The following features are enabled by default:\n *    features : {\n *        cellEdit      : true,\n *        columnPicker  : true,\n *        columnReorder : true,\n *        columnResize  : true,\n *        cellMenu      : true,\n *        headerMenu    : true,\n *        group         : true,\n *        rowCopyPaste  : true, // Allow using [Ctrl/CMD + C/X] and [Ctrl/CMD + V] to copy/cut and paste rows\n *        sort          : true\n *    },\n *\n *    animateRemovingRows       : true,  // Rows will slide out on removal\n *    autoHeight                : false, // Grid needs to have a height supplied through CSS (strongly recommended) or by specifying `height`\n *    columnLines               : true,  // Themes might override it to hide lines anyway\n *    emptyText                 : 'No rows to display',\n *    enableTextSelection       : false, // Not allowed to select text in cells by default,\n *    fillLastColumn            : true,  // By default the last column is stretched to fill the grid\n *    fullRowRefresh            : true,  // Refreshes entire row when a cell value changes\n *    loadMask                  : 'Loading...',\n *    resizeToFitIncludesHeader : true,  // Also measure header when auto resizing columns\n *    responsiveLevels : {\n *      small : 400,\n *      medium : 600,\n *      large : '*'\n *    },\n *    rowHeight                  : null,  // Determined using CSS, it will measure rowHeight\n *    showDirty                  : false, // No indicator for changed cells\n * });\n * ```\n *\n * {@endregion}\n * {@region Keyboard shortcuts}\n * Grid has the following default keyboard shortcuts:\n * <div class=\"compact\">\n *\n * | Keys                 | Action                 | Weight ¹ | Action description                                                                                 |\n * |----------------------|------------------------|:--------:|----------------------------------------------------------------------------------------------------|\n * | `ArrowUp`            | *navigateUp*           | 10       | Focuses the cell above currently focused cell.                                                     |\n * | `ArrowRight`         | *navigateRight*        | 10       | Focuses the cell to the right of currently focused cell                                            |\n * | `ArrowDown`          | *navigateDown*         | 10       | Focuses the cell below currently focused cell                                                      |\n * | `ArrowLeft`          | *navigateLeft*         | 10       | Focuses the cell to the left of currently focused cell                                             |\n * | `Shift`+`ArrowUp`    | *extendSelectionUp*    |          | Extends the selection one row up from currently focused cell                                       |\n * | `Shift`+`ArrowRight` | *extendSelectionRight* |          | Extends the selection one column to the right from currently focused cell                          |\n * | `Shift`+`ArrowDown`  | *extendSelectionDown*  |          | Extends the selection one row down from currently focused cell                                     |\n * | `Shift`+`ArrowLeft`  | *extendSelectionLeft*  |          | Extends the selection one column to the left from currently focused cell                           |\n * | `Space`              | *toggleSelection*      | 10       | Toggles selection of currently focused cell if selectionMode.selectOnKeyboardNavigation is `false` |\n * | `Ctrl`+`Home`        | *navigateFirstCell*    |          | Focuses the first cell at the first row (including header)                                         |\n * | `Home`               | *navigateFirstColumn*  |          | Focuses the first cell of current focused row                                                      |\n * | `Ctrl`+`End`         | *navigateLastCell*     |          | Focuses the last cell of the last row                                                              |\n * | `End`                | *navigateLastColumn*   |          | Focuses the last cell of current focused row                                                       |\n * | `PageUp`             | *navigatePrevPage*     |          | Displays previous page                                                                             |\n * | `PageDown`           | *navigateNextPage*     |          | Displays next page                                                                                 |\n * | `Enter`              | *activateHeader*       |          | Equals to a header click                                                                           |\n * | `Space`              | *clickCellByKey*       | 1000     | Equals to a cell click                                                                             |\n * | `Ctrl`+`Z`           | *undoRedoKeyPress*     |          | Undo/redo (when using {@link Core.data.stm.StateTrackingManager})                                  |\n * | `Ctrl`+`Shift`+`Z`   | *undoRedoKeyPress*     |          | Undo/redo (when using {@link Core.data.stm.StateTrackingManager})                                  |\n *\n * **¹** Customization of keyboard shortcuts that has a `weight` can affect other features that also uses that\n * particular keyboard shortcut. Read more in [our guide](#Grid/guides/customization/keymap.md).\n *\n *</div>\n *\n * <div class=\"note\" style=\"font-size: 0.9em\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * The following Grid features has their own keyboard shortcuts. Follow the links for details.\n * * {@link Grid.feature.CellCopyPaste#keyboard-shortcuts CellCopyPaste}\n * * {@link Grid.feature.CellEdit#keyboard-shortcuts CellEdit}\n * * {@link Grid.feature.CellMenu#keyboard-shortcuts CellMenu}\n * * {@link Grid.feature.ColumnRename#keyboard-shortcuts ColumnRename}\n * * {@link Grid.feature.Filter#keyboard-shortcuts Filter}\n * * {@link Grid.feature.Group#keyboard-shortcuts Group}\n * * {@link Grid.feature.HeaderMenu#keyboard-shortcuts HeaderMenu}\n * * {@link Grid.feature.QuickFind#keyboard-shortcuts QuickFind}\n * * {@link Grid.feature.RowCopyPaste#keyboard-shortcuts RowCopyPaste}\n * * {@link Grid.feature.Search#keyboard-shortcuts Search}\n * * {@link Grid.feature.Tree#keyboard-shortcuts Tree}\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#Grid/guides/customization/keymap.md)\n *\n * {@endregion}\n * {@region Performance}\n * In general the Grid widget has very good performance and you can try loading any amount of data in the\n * <a target=\"_blank\" href=\"../examples/bigdataset/\">bigdataset</a> demo.\n * The overall rendering performance is naturally affected by many other things than the data volume. Other important\n * factors that can impact performance: number of columns, complex cell renderers, locked columns, the number of\n * features enabled and of course the browser (Chrome fastest).\n * {@endregion}\n * {@region Accessibility}\n * As far as possible, the grid is accessible to WAI-ARIA standards. Every cell, including column header cells is\n * visitable. The arrow keys navigate, and if a cell contains focusable content, navigating to that cell focuses the\n * content. `Escape` will exit from that and focus the encapsulating cell.\n *\n * When tabbing back into a grid that has previously been entered, focus moves to the last focused cell.\n *\n * The column menu is invoked using the `Space` key when focused on a column header.\n *\n * The cell menu is invoked using the `Space` key when focused on a data cell.\n * {@endregion}\n *\n * @extends Grid/view/GridBase\n * @classType grid\n * @widget\n */\nexport default class Grid extends GridBase {\n    static get $name() {\n        return 'Grid';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'grid';\n    }\n}\n\n// Register this widget type with its Factory\nGrid.initClass();\n"],
  "mappings": "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",
  "names": ["storeListenerName", "ColumnAutoWidth", "Delayable", "InstancePlugin", "pluginConfig", "after", "bindStore", "unbindStore", "renderRows", "onInternalResize", "assign", "construct", "config", "store", "client", "doDestroy", "lastSync", "ion", "name", "asyncEventSuffix", "thisObj", "detachListeners", "columnAutoWidthPending", "hasTimeout", "onStoreChange", "action", "me", "cellEdit", "features", "storeGeneration", "isEditing", "editingStoppedByTapOutside", "syncAutoWidthColumns", "setTimeout", "delay", "element", "newWidth", "newHeight", "oldWidth", "splitFrom", "autoWidth", "resizingColumns", "column", "columns", "visibleColumns", "default", "resizeToFitContent", "afterColumnsResized", "clearTimeout", "__publicField", "$name", "configurable", "prototype", "_$name", "GridFeatureManager", "registerFeature", "RowCopyPaste", "CopyPasteBase", "entityName", "grid", "rowManager", "beforeRenderRow", "onBeforeRenderRow", "row", "record", "_this$cutData", "cls", "isCut", "cutData", "includes", "isActionAvailable", "key", "event", "_grid$selectedRecords", "target", "disabled", "globalThis", "getSelection", "toString", "length", "copyOnly", "selectedRecords", "Boolean", "closest", "copy", "copyRows", "cut", "paste", "referenceRecord", "pasteRows", "isModel", "records", "filter", "r", "readOnly", "writeToClipboard", "trigger", "setIsCut", "_this$grid$rowManager", "getRowById", "toggleCls", "meta", "handleCutData", "source", "_this$cutData2", "remove", "stringConverter", "cellsToString", "flatMap", "_this$grid$rowManager2", "cells", "map", "c", "Location", "beforeCopy", "data", "_client$getRowFor", "_client$getRowFor$cel", "_client$getRowFor$cel2", "selectedRecord", "isTreeGrouped", "readFromClipboard", "isOwn", "clipboardData", "Array", "isArray", "tree", "some", "rec", "contains", "sortByIndex", "idMap", "recordsToProcess", "extractParents", "insertCopiedRecords", "isDestroying", "clearClipboard", "originalRecords", "clipboard", "triggerPaste", "getRowFor", "focus", "beforePaste", "text", "stringParser", "setFromStringData", "modifiedRecords", "generateNewName", "originalName", "getValue", "nameField", "counter", "findRecord", "toInsert", "recordReference", "insertAt", "indexOf", "parent", "insertChild", "nextSibling", "orderedBeforeNode", "nextOrderedSibling", "insert", "selectedCells", "forEach", "cell", "push", "getMenuItemText", "addRowSpecifier", "rowSpecifierTextPlural", "rowSpecifierText", "populateCellMenu", "items", "cellSelector", "_client$features$cell", "rowOptionsOnCellContextMenu", "cellCopyPaste", "enabled", "targetIsCell", "isCellSelected", "isSpecialRow", "selectedRows", "localeClass", "icon", "weight", "onItem", "hasClipboardData", "array", "sort", "rec1", "rec2", "idx1", "indexPath", "idx2", "i", "taskRecords", "generateNames", "node", "traverse", "n", "parents", "getTopParent", "result", "reduce", "parentId", "modified", "expanded", "isExpanded", "id", "rootNode", "appendChild", "sortOrderedChildren", "type", "chain", "keyMap", "handler", "copyRecordText", "cutRecordText", "pasteRecordText", "localizableProperties", "featureClass", "Grid", "GridBase", "initClass"]
}
