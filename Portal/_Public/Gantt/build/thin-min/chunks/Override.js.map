{
  "version": 3,
  "sources": ["../../../../Core/lib/Core/mixin/Override.js"],
  "sourcesContent": ["import VersionHelper from '../helper/VersionHelper.js';\n\n/**\n * @module Core/mixin/Override\n */\n\nconst excludedPropNames = {\n    constructor : 1,\n    prototype   : 1,\n    name        : 1,\n    length      : 1,\n    arguments   : 1,\n    caller      : 1,\n    callee      : 1,\n    __proto__   : 1\n};\n\n/**\n * Simplifies overriding class methods by allowing methods from another class to be used as overrides.\n * Overrides are defined as own classes. They must at a minimum contain a static getter named targetClass, which\n * should return the class to override. Apply the override by calling {@link #function-apply-static apply()}.\n *\n * @example\n * class TemplateColumnOverride {\n *     static get target() {\n *         return {\n *             class      : TemplateColumn,\n *             product    : 'grid',\n *             minVersion : '1.0',\n *             maxVersion : '1.5'\n *         }\n *     }\n *\n *     renderer(renderData) {\n *         // call overridden function (optional)\n *         const value = this._overridden.renderer.call(this, renderData);\n *\n *         return 'HELLO' + value;\n *     }\n * }\n * Override.apply(TemplateColumnOverride);\n */\nexport default class Override {\n    /**\n     * Apply override. We strongly suggest that you at least specify a maxVersion for your overrides.\n     * ```\n     * class OriginalOverride {\n     *     static get target() {\n     *         return {\n     *             class      : Original,\n     *             product    : 'grid',\n     *             minVersion : '1.0',\n     *             maxVersion : '1.5'\n     *         }\n     *     }\n     * }\n     * ```\n     * @param {Object} override An override class definition\n     */\n    static apply(override) {\n        if (!override.target) throw new Error('Override must specify what it overrides, using static getter target');\n        if (!override.target.class) throw new Error('Override must specify which class it overrides, using target.class');\n\n        if (!this.shouldApplyOverride(override)) return false;\n\n        const staticKeys   = Object.getOwnPropertyNames(override),\n            instanceKeys = Object.getOwnPropertyNames(override.prototype);\n\n        staticKeys.splice(staticKeys.indexOf('target'), 1);\n\n        this.internalOverrideAll(override.target.class, staticKeys, override);\n        this.internalOverrideAll(override.target.class.prototype, instanceKeys, override.prototype);\n\n        return true;\n    }\n\n    static internalOverrideAll(targetClass, properties, overrideDefinition) {\n        Reflect.ownKeys(overrideDefinition).forEach(key => {\n            if (properties.includes(key) && !excludedPropNames[key]) {\n                const desc = Object.getOwnPropertyDescriptor(overrideDefinition, key);\n                let currentTargetClass = targetClass;\n\n                let targetProperty = null;\n\n                // Walk up the prototype chain to find fn, needed for mixin overrides applied to class that has them\n                // mixed in\n                while (!targetProperty && currentTargetClass) {\n                    targetProperty = Object.getOwnPropertyDescriptor(currentTargetClass, key);\n                    if (!targetProperty) {\n                        currentTargetClass = Object.getPrototypeOf(currentTargetClass);\n                    }\n                }\n\n                if (targetProperty) {\n                    this.internalOverride(currentTargetClass, key, desc, targetProperty);\n                }\n            }\n        });\n    }\n\n    static internalOverride(target, key, desc, targetDesc) {\n        const overrides = target._overridden = target._overridden || {};\n\n        overrides[key] = target[key];\n\n        if (targetDesc.get) {\n            Object.defineProperty(target, key, {\n                enumerable   : false,\n                configurable : true,\n                get          : desc.get\n            });\n        }\n        else {\n            target[key] = desc.value;\n        }\n    }\n\n    /**\n     * Checks versions if an override should be applied. Specify version in your overrides target config\n     * @param override\n     * @returns {Boolean}\n     * @example\n     * class OriginalOverride {\n     *     static get target() {\n     *         return {\n     *             class      : Original,\n     *             product    : 'grid',\n     *             minVersion : '1.0',\n     *             maxVersion : '1.5'\n     *         }\n     *     }\n     * }\n     * @private\n     */\n    static shouldApplyOverride(override) {\n        const config = override.target;\n        // not using versioning, allow override\n        if (!config.maxVersion && !config.minVersion) return true;\n\n        // must specify product to be able to lookup versions\n        if (!config.product) throw new Error('Override must specify product when using versioning');\n\n        // override is for older version, disallow\n        if (config.maxVersion && VersionHelper[config.product].isNewerThan(config.maxVersion)) {\n            //<debug>\n            console.log(`Override ${override.name} for class ${config.class.name} is for an older version of ${config.product} and will not be applied`);\n            //</debug>\n            return false;\n        }\n\n        // override is for newer version, disallow\n        if (config.minVersion && VersionHelper[config.product].isOlderThan(config.minVersion)) {\n            //<debug>\n            console.log(`Override ${override.name} for class ${config.class.name} is for a newer version of ${config.product} and will not be applied`);\n            //</debug>\n            return false;\n        }\n\n        // override is for current version, allow\n        return true;\n    }\n}\n"],
  "mappings": "4CAIA,MAAMA,EAAoB,CACtBC,YAAc,EACdC,UAAc,EACdC,KAAc,EACdC,OAAc,EACdC,UAAc,EACdC,OAAc,EACdC,OAAc,EACdC,UAAc,CAClB,EA0Be,MAAMC,CAAS,CAiB1B,OAAOC,MAAMC,EAAU,CACnB,GAAI,CAACA,EAASC,OAAQ,MAAM,IAAIC,MAAM,qEAAqE,EAC3G,GAAI,CAACF,EAASC,OAAOE,MAAO,MAAM,IAAID,MAAM,oEAAoE,EAChH,GAAI,CAAC,KAAKE,oBAAoBJ,CAAQ,EAAG,MAAO,GAChD,MAAMK,EAAeC,OAAOC,oBAAoBP,CAAQ,EACpDQ,EAAeF,OAAOC,oBAAoBP,EAAST,SAAS,EAChEc,OAAAA,EAAWI,OAAOJ,EAAWK,QAAQ,QAAQ,EAAG,CAAC,EACjD,KAAKC,oBAAoBX,EAASC,OAAOE,MAAOE,EAAYL,CAAQ,EACpE,KAAKW,oBAAoBX,EAASC,OAAOE,MAAMZ,UAAWiB,EAAcR,EAAST,SAAS,EACnF,EACX,CACA,OAAOoB,oBAAoBC,EAAaC,EAAYC,EAAoB,CACpEC,QAAQC,QAAQF,CAAkB,EAAEG,QAAQC,GAAO,CAC/C,GAAIL,EAAWM,SAASD,CAAG,GAAK,CAAC7B,EAAkB6B,CAAG,EAAG,CACrD,MAAME,EAAOd,OAAOe,yBAAyBP,EAAoBI,CAAG,EACpE,IAAII,EAAqBV,EACrBW,EAAiB,KAGrB,KAAO,CAACA,GAAkBD,GACtBC,EAAiBjB,OAAOe,yBAAyBC,EAAoBJ,CAAG,EACnEK,IACDD,EAAqBhB,OAAOkB,eAAeF,CAAkB,GAGjEC,GACA,KAAKE,iBAAiBH,EAAoBJ,EAAKE,EAAMG,CAAc,EAG/E,CAAC,CACL,CACA,OAAOE,iBAAiBxB,EAAQiB,EAAKE,EAAMM,EAAY,CACnD,MAAMC,EAAY1B,EAAO2B,YAAc3B,EAAO2B,aAAe,CAAA,EAC7DD,EAAUT,CAAG,EAAIjB,EAAOiB,CAAG,EACvBQ,EAAWG,IACXvB,OAAOwB,eAAe7B,EAAQiB,EAAK,CAC/Ba,WAAe,GACfC,aAAe,GACfH,IAAeT,EAAKS,GACxB,CAAC,EAGD5B,EAAOiB,CAAG,EAAIE,EAAKa,KAE3B,CAkBA,OAAO7B,oBAAoBJ,EAAU,CACjC,MAAMkC,EAASlC,EAASC,OAExB,GAAI,CAACiC,EAAOC,YAAc,CAACD,EAAOE,WAAY,MAAO,GAErD,GAAI,CAACF,EAAOG,QAAS,MAAM,IAAInC,MAAM,qDAAqD,EAM1F,MAJIgC,EAAAA,EAAOC,YAAcG,EAAcJ,EAAOG,OAAO,EAAEE,YAAYL,EAAOC,UAAU,GAIhFD,EAAOE,YAAcE,EAAcJ,EAAOG,OAAO,EAAEG,YAAYN,EAAOE,UAAU,EAKxF,CACJ,CACAtC,EAAS2C,OAAS",
  "names": ["excludedPropNames", "constructor", "prototype", "name", "length", "arguments", "caller", "callee", "__proto__", "Override", "apply", "override", "target", "Error", "class", "shouldApplyOverride", "staticKeys", "Object", "getOwnPropertyNames", "instanceKeys", "splice", "indexOf", "internalOverrideAll", "targetClass", "properties", "overrideDefinition", "Reflect", "ownKeys", "forEach", "key", "includes", "desc", "getOwnPropertyDescriptor", "currentTargetClass", "targetProperty", "getPrototypeOf", "internalOverride", "targetDesc", "overrides", "_overridden", "get", "defineProperty", "enumerable", "configurable", "value", "config", "maxVersion", "minVersion", "product", "VersionHelper", "isNewerThan", "isOlderThan", "_$name"]
}
