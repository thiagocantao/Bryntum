{
  "version": 3,
  "sources": ["../../../../Grid/lib/Grid/feature/mixin/SummaryFormatter.js", "../../../../Grid/lib/Grid/feature/RowReorder.js", "../../../../Grid/lib/Grid/feature/Summary.js", "../../../../Grid/lib/Grid/view/export/field/ExportRowsCombo.js", "../../../../Grid/lib/Grid/view/export/field/ExportOrientationCombo.js", "../../../../Grid/lib/Grid/view/export/ExportDialog.js", "../../../../Grid/lib/Grid/feature/export/exporter/MultiPageExporter.js", "../../../../Grid/lib/Grid/feature/export/exporter/MultiPageVerticalExporter.js", "../../../../Grid/lib/Grid/feature/export/exporter/SinglePageExporter.js", "../../../../Grid/lib/Grid/feature/export/PdfExport.js"],
  "sourcesContent": ["import Base from '../../../Core/Base.js';\n\n/**\n * @module Grid/feature/mixin/SummaryFormatter\n */\n\n/**\n * Mixin for Summary and GroupSummary that handles formatting sums.\n * @mixin\n * @private\n */\nexport default Target => class SummaryFormatter extends (Target || Base) {\n    static get $name() {\n        return 'SummaryFormatter';\n    }\n\n    /**\n     * Calculates sums and returns as a html table\n     * @param {Grid.column.Column} column Column to calculate sum for\n     * @param {Core.data.Model[]} records Records to include in calculation\n     * @param {String} cls CSS class to apply to summary table\n     * @param {Core.data.Model} groupRecord current group row record\n     * @param {String} groupField Current groups field name\n     * @param {String} groupValue Current groups value\n     * @returns {String} html content\n     */\n    generateHtml(column, records, cls, groupRecord, groupField, groupValue) {\n        const\n            store = this.store,\n            summaries = column.summaries ||\n                  (column.sum ? [{ sum : column.sum, renderer : column.summaryRenderer }] : []);\n\n        let html = `<table class=\"${cls}\">`;\n\n        summaries.forEach(config => {\n            let type = config.sum,\n                sum  = null;\n\n            if (type === true) type = 'sum';\n\n            switch (type) {\n                case 'sum':\n                case 'add':\n                    sum = store.sum(column.field, records);\n                    break;\n                case 'max':\n                    sum = store.max(column.field, records);\n                    break;\n                case 'min':\n                    sum = store.min(column.field, records);\n                    break;\n                case 'average':\n                case 'avg':\n                    sum = store.average(column.field, records);\n                    break;\n                case 'count':\n                    sum = records.length;\n                    break;\n                case 'countNotEmpty':\n                    sum = records.reduce((sum, record) => {\n                        const value = record.getValue(column.field);\n                        return sum + (value != null ? 1 : 0);\n                    }, 0);\n                    break;\n            }\n\n            if (typeof type === 'function') {\n                sum = records.reduce(type, 'seed' in config ? config.seed : 0);\n            }\n\n            if (sum !== null) {\n                const\n                    valueCls  = 'b-grid-summary-value',\n                    // optional label\n                    labelHtml = config.label\n                        ? `<td class=\"b-grid-summary-label\">${config.label}</td>`\n                        : '';\n\n                // value to display, either using renderer or as is\n                let valueHtml = config.renderer\n                        ? config.renderer({ config, sum })\n                        : sum,\n                    summaryHtml;\n\n                if (valueHtml == null) {\n                    valueHtml = '';\n                }\n\n                // no <td>s in html, wrap it (always the case when not using renderer)\n                if (!String(valueHtml).includes('<td>')) {\n                    summaryHtml = labelHtml\n                        // has label, use returned html as value cell\n                        ? `${labelHtml}<td class=\"${valueCls}\">${valueHtml}</td>`\n                        // no label, span entire table\n                        : `<td colspan=\"2\" class=\"${valueCls}\">${valueHtml}</td>`;\n                }\n                // user is in charge of giving correct formatting\n                else {\n                    summaryHtml = valueHtml;\n                }\n\n                html += `<tr>${summaryHtml}</tr>`;\n            }\n        });\n\n        return html + '</table>';\n    }\n};\n", "/**\n * @module Grid/feature/RowReorder\n */\n\nimport GridFeatureManager from './GridFeatureManager.js';\nimport DragHelper from '../../Core/helper/DragHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\n\n/**\n * Object with information about a tree position\n * @typedef {Object} RecordPositionContext\n * @property {Core.data.Model} record Tree node\n * @property {Number} parentIndex Index among parents children\n * @property {String|Number} parentId Parent node's id\n */\n\n/**\n * Allows user to reorder rows by dragging them. To get notified about row reorder listen to `change` event\n * on the grid {@link Core.data.Store store}.\n *\n * This feature is **off** by default. For info on enabling it, see {@link Grid.view.mixin.GridFeatures}.\n * This feature is **enabled** by default for Gantt.\n *\n * {@inlineexample Grid/feature/RowReorder.js}\n *\n * If the grid is set to {@link Grid.view.Grid#config-readOnly}, reordering is disabled. Inside all event listeners you\n * have access a `context` object which has a `record` property (the dragged record).\n *\n * ## Validation\n * You can validate the drag drop flow by listening to the `gridrowdrag` event. Inside this listener you have access to\n * the `index` property which is the target drop position. For trees you get access to the `parent` record and `index`,\n * where index means the child index inside the parent.\n *\n * You can also have an async finalization step using the {@link #event-gridRowBeforeDropFinalize}, for showing a\n * confirmation dialog or making a network request to decide if drag operation is valid (see code snippet below)\n *\n * ```javascript\n * features : {\n *     rowReorder : {\n *         showGrip : true\n *     },\n *     listeners : {\n *        gridRowDrag : ({ context }) => {\n *           // Here you have access to context.insertBefore, and additionally context.parent for trees\n *        },\n *\n *        gridRowBeforeDropFinalize : async ({ context }) => {\n *           const result = await MessageDialog.confirm({\n *               title   : 'Please confirm',\n *               message : 'Did you want the row here?'\n *           });\n *\n *           // true to accept the drop or false to reject\n *           return result === MessageDialog.yesButton;\n *        }\n *    }\n * }\n * ```\n *\n * Note, that this feature uses the concept of \"insert before\" when choosing a drop point in the data. So the dropped\n * record's position is *before the visual next record's position*.\n *\n * This may look like a pointless distinction, but consider the case when a Store is filtered. The record *above* the\n * drop point may have several filtered out records below it. When unfiltered, the dropped record will be *below* these\n * because of the \"insert before\" behaviour.\n *\n * ## Behavior with multiple subgrids\n *\n * For grids with multiple subgrids, row reordering is only enabled for the first subgrid.\n *\n * NOTE: This feature cannot be used simultaneously with the `enableTextSelection` config.\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Grid/rowreordering\n * @classtype rowReorder\n * @feature\n */\nexport default class RowReorder extends Delayable(InstancePlugin) {\n    //region Events\n    /**\n     * Fired before dragging starts, return false to prevent the drag operation.\n     * @preventable\n     * @event gridRowBeforeDragStart\n     * @param {Core.helper.DragHelper} source\n     * @param {Object} context\n     * @param {Core.data.Model[]} context.records The dragged row records\n     * @param {MouseEvent|TouchEvent} event\n     * @on-owner\n     */\n\n    /**\n     * Fired when dragging starts.\n     * @event gridRowDragStart\n     * @param {Core.helper.DragHelper} source\n     * @param {Object} context\n     * @param {Core.data.Model[]} context.records The dragged row records\n     * @param {MouseEvent|TouchEvent} event\n     * @on-owner\n     */\n\n    /**\n     * Fired while the row is being dragged, in the listener function you have access to `context.insertBefore` a grid /\n     * tree record, and additionally `context.parent` (a TreeNode) for trees. You can signal that the drop position is\n     * valid or invalid by setting `context.valid = false;`\n     * @event gridRowDrag\n     * @param {Core.helper.DragHelper} source\n     * @param {Object} context\n     * @param {Boolean} context.valid Set this to true or false to indicate whether the drop position is valid.\n     * @param {Core.data.Model} context.insertBefore The record to insert before (`null` if inserting at last position of a parent node)\n     * @param {Core.data.Model} context.parent The parent record of the current drop position (only applicable for trees)\n     * @param {Core.data.Model[]} context.records The dragged row records\n     * @param {MouseEvent} event\n     * @on-owner\n     */\n\n    /**\n     * Fired before the row drop operation is finalized. You can return false to abort the drop operation, or a\n     * Promise yielding `true` / `false` which allows for asynchronous abort (e.g. first show user a confirmation dialog).\n     * @event gridRowBeforeDropFinalize\n     * @preventable\n     * @async\n     * @param {Core.helper.DragHelper} source\n     * @param {Object} context\n     * @param {Boolean} context.valid Set this to true or false to indicate whether the drop position is valid\n     * @param {Core.data.Model} context.insertBefore The record to insert before (`null` if inserting at last position of a parent node)\n     * @param {Core.data.Model} context.parent The parent record of the current drop position (only applicable for trees)\n     * @param {Core.data.Model[]} context.records The dragged row records\n     * @param {RecordPositionContext[]} context.oldPositionContext An array of objects with information about the previous tree position.\n     * Objects contain the `record`, and its original `parentIndex` and `parentId` values\n     * @param {MouseEvent} event\n     * @on-owner\n     */\n\n    /**\n     * Fired after the row drop operation has completed, regardless of validity\n     * @event gridRowDrop\n     * @param {Core.helper.DragHelper} source\n     * @param {Object} context\n     * @param {Boolean} context.valid true or false depending on whether the drop position was valid\n     * @param {Core.data.Model} context.insertBefore The record to insert before (`null` if inserting at last position of a parent node)\n     * @param {Core.data.Model} context.parent The parent record of the current drop position (only applicable for trees)\n     * @param {Core.data.Model} context.record [DEPRECATED] The dragged row record\n     * @param {Core.data.Model[]} context.records The dragged row records\n     * @param {RecordPositionContext[]} context.oldPositionContext An array of objects with information about the previous tree position.\n     * Objects contain the record, and its original `parentIndex` and `parentId` values\n     * @param {MouseEvent} event\n     * @on-owner\n     */\n\n    /**\n     * Fired when a row drag operation is aborted\n     * @event gridRowAbort\n     * @param {Core.helper.DragHelper} source\n     * @param {Object} context\n     * @param {MouseEvent} event\n     * @on-owner\n     */\n\n    //endregion\n\n    //region Init\n\n    static $name = 'RowReorder';\n\n    static configurable = {\n        /**\n         * Set to `true` to show a grip icon on the left side of each row.\n         * @config {Boolean}\n         */\n        showGrip : null,\n\n        /**\n         * Set to `true` to only allow reordering by the {@link #config-showGrip} config\n         * @config {Boolean}\n         */\n        gripOnly : null,\n\n        /**\n         * If hovering over a parent node for this period of a time in a tree, the node will expand\n         * @config {Number}\n         */\n        hoverExpandTimeout : 1000,\n\n        /**\n         * The amount of milliseconds to wait after a touchstart, before a drag gesture will be allowed to start.\n         * @config {Number}\n         * @default\n         */\n        touchStartDelay : 300,\n\n        /**\n         * Enables creation of parents by dragging a row and dropping it onto a leaf row. Only works in a Grid with\n         * a tree store.\n         * @config {Boolean}\n         */\n        dropOnLeaf : false,\n\n        /**\n         * An object used to configure the internal {@link Core.helper.DragHelper} class\n         * @config {DragHelperConfig}\n         */\n        dragHelperConfig : null\n\n    };\n\n    static get deprecatedEvents() {\n        return {\n            gridRowBeforeDragStart : {\n                product            : 'Grid',\n                invalidAsOfVersion : '6.0.0',\n                message            : '`gridRowBeforeDragStart` event is deprecated, listen on this event on the Grid instead.'\n            },\n            gridRowDragStart : {\n                product            : 'Grid',\n                invalidAsOfVersion : '6.0.0',\n                message            : '`gridRowDragStart` event is deprecated, listen on this event on the Grid instead.'\n            },\n            gridRowDrag : {\n                product            : 'Grid',\n                invalidAsOfVersion : '6.0.0',\n                message            : '`gridRowDrag` event is deprecated, listen on this event on the Grid instead.'\n            },\n            gridRowBeforeDropFinalize : {\n                product            : 'Grid',\n                invalidAsOfVersion : '6.0.0',\n                message            : '`gridRowBeforeDropFinalize` event is deprecated, listen on this event on the Grid instead.'\n            },\n            gridRowDrop : {\n                product            : 'Grid',\n                invalidAsOfVersion : '6.0.0',\n                message            : '`gridRowDrop` event is deprecated, listen on this event on the Grid instead.'\n            },\n            gridRowAbort : {\n                product            : 'Grid',\n                invalidAsOfVersion : '6.0.0',\n                message            : '`gridRowAbort` event is deprecated, listen on this event on the Grid instead.'\n            }\n        };\n    }\n\n    construct(grid, config) {\n        this.grid = grid;\n\n        super.construct(...arguments);\n    }\n\n    doDestroy() {\n        this.dragHelper?.destroy();\n\n        super.doDestroy();\n    }\n\n    /**\n     * Initialize drag & drop (called on first paint)\n     * @private\n     */\n    init() {\n        const\n            me       = this,\n            { grid } = me;\n\n        me.dragHelper = DragHelper.new({\n            name               : 'rowReorder',\n            cloneTarget        : true,\n            dragThreshold      : 10,\n            proxyTopOffset     : 10,\n            targetSelector     : '.b-grid-row',\n            lockX              : true,\n            dragWithin         : grid.bodyContainer,\n            allowDropOutside   : true,\n            scrollManager      : grid.scrollManager,\n            outerElement       : me.targetSubGridElement,\n            touchStartDelay    : me.touchStartDelay,\n            isElementDraggable : me.isElementDraggable.bind(me),\n            monitoringConfig   : {\n                scrollables : [\n                    {\n                        element   : grid.scrollable.element,\n                        direction : 'vertical'\n                    }\n                ]\n            },\n            setXY(element, x, y) {\n                const { context } = this;\n\n                if (!context.started) {\n                    const\n                        elementRect       = Rectangle.from(context.element, this.dragWithin),\n                        pointerDownOffset = context.startPageY - globalThis.pageYOffset - context.element.getBoundingClientRect().top;\n\n                    // manually position the row a bit below the cursor\n                    y = elementRect.top + pointerDownOffset + this.proxyTopOffset;\n                }\n                DomHelper.setTranslateXY(element, x, y);\n            },\n            // Since parent nodes can expand after hovering, meaning original drag start position now refers to a different point in the tree\n            ignoreSamePositionDrop : false,\n            createProxy(element) {\n                const\n                    clone     = element.cloneNode(true),\n                    container = document.createElement('div');\n\n                container.classList.add('b-row-reorder-proxy');\n\n                clone.removeAttribute('id');\n                // The containing element will be positioned instead, and sized using CSS\n                clone.style.transform = '';\n                clone.style.width = '';\n\n                container.appendChild(clone);\n\n                if (grid.selectedRecords.length > 1) {\n                    const clone2 = clone.cloneNode(true);\n\n                    clone2.classList.add('b-row-dragging-multiple');\n\n                    container.appendChild(clone2);\n                }\n\n                DomHelper.removeClsGlobally(container, 'b-selected', 'b-hover', 'b-focused');\n\n                return container;\n            },\n\n            internalListeners : {\n                beforedragstart : 'onBeforeDragStart',\n                dragstart       : 'onDragStart',\n                drag            : 'onDrag',\n                drop            : 'onDrop',\n                abort           : 'onAbort',\n                reset           : 'onReset',\n                prio            : 10000, // To ensure our listener is run before the relayed listeners (for the outside world)\n                thisObj         : me\n            }\n        }, me.dragHelperConfig);\n\n        // Remove in 6.0\n        me.relayEvents(me.dragHelper, ['beforeDragStart', 'dragStart', 'drag', 'abort'], 'gridRow');\n\n        grid.relayEvents(me.dragHelper, ['beforeDragStart', 'dragStart', 'drag', 'abort'], 'gridRow');\n\n        me.dropIndicator = DomHelper.createElement({\n            className : 'b-row-drop-indicator'\n        });\n\n        me.dropOverTargetCls = ['b-row-reordering-target', 'b-hover'];\n    }\n\n    //endregion\n\n    //region Plugin config\n\n    static pluginConfig = {\n        after : ['onPaint']\n    };\n\n    get targetSubGridElement() {\n        const targetSubGrid = this.grid.regions[0];\n\n        return this.grid.subGrids[targetSubGrid].element;\n    }\n\n    //endregion\n\n    //region Events (drop)\n\n    isElementDraggable(el, event) {\n        if (!el.closest('.b-grid-cell .b-widget')) {\n            if (this.gripOnly) {\n                const firstCell = el.closest('.b-grid-cell:first-child');\n\n                // Event is in the first cell. Now check if it's on the handle\n                if (firstCell) {\n                    const\n                        gripperStyle = getComputedStyle(firstCell, ':before'),\n                        offsetX      = this.grid.rtl ? firstCell.getBoundingClientRect().width - event.borderOffsetX : event.borderOffsetX,\n                        onGrip       = DomHelper.roundPx(offsetX) <= DomHelper.roundPx(parseFloat(gripperStyle.width));\n\n                    // Prevent drag select if mousedown on grip, would collide with reordering\n                    // (reset by GridSelection)\n                    if (onGrip) {\n                        this.client.preventDragSelect = true;\n                    }\n\n                    return onGrip;\n                }\n            }\n            else {\n                return true;\n            }\n        }\n    }\n\n    onBeforeDragStart({ event, source, context }) {\n        const\n            me        = this,\n            { grid }  = me,\n            subGridEl = me.targetSubGridElement;\n\n        // Only dragging enabled in the leftmost grid section\n        if (me.disabled || grid.readOnly || grid.isTreeGrouped || !subGridEl.contains(context.element)) {\n            return false;\n        }\n\n        const startRecord = context.startRecord = grid.getRecordFromElement(context.element);\n\n        // Don't allow starting drag on a readOnly record nor on special rows\n        if (startRecord.readOnly || startRecord.isSpecialRow) {\n            return false;\n        }\n\n        context.originalRowTop = grid.rowManager.getRowFor(startRecord).top;\n\n        // Don't select row if checkboxOnly is set\n        if (!grid.selectionMode.checkboxOnly) {\n            if (source.startEvent.pointerType === 'touch') {\n                // Touchstart doesn't focus/navigate on its own, so we do it at the last moment before drag start\n                if (!grid.isSelected(startRecord)) {\n                    grid.selectRow({\n                        record         : startRecord,\n                        addToSelection : false\n                    });\n                }\n            }\n            else if (!grid.isSelected(startRecord) && !event.shiftKey && !event.ctrlKey) {\n                // If record is not selected and shift/ctrl is not pressed then select single row\n                grid.selectRow({\n                    record : startRecord\n                });\n            }\n        }\n\n        // Read-only records will not be moved\n        const selectedRecords = grid.selectedRecords.filter(r => !r.readOnly);\n        context.records       = [startRecord];\n\n        // If clicked record is selected, move all selected records\n        if (selectedRecords.includes(startRecord)) {\n            context.records.push(...selectedRecords.filter(r => r !== startRecord));\n            context.records.sort((r1, r2) => grid.store.indexOf(r1) - grid.store.indexOf(r2));\n        }\n\n        return true;\n    }\n\n    onDragStart({ context }) {\n        const\n            me                                 = this,\n            { grid }                           = me,\n            { cellEdit, cellMenu, headerMenu } = grid.features;\n\n        if (cellEdit) {\n            me.cellEditDisabledState = cellEdit.disabled;\n            cellEdit.disabled        = true; // prevent editing from being started through keystroke during row reordering\n        }\n\n        cellMenu?.hideContextMenu?.(false);\n        headerMenu?.hideContextMenu?.(false);\n\n        grid.element.classList.add('b-row-reordering');\n\n        const focusedCell = context.element.querySelector('.b-focused');\n        focusedCell?.classList.remove('b-focused');\n\n        context.element.firstElementChild.classList.remove('b-selected', 'b-hover');\n\n        grid.bodyContainer.appendChild(me.dropIndicator);\n    }\n\n    onDrag({ context, event }) {\n        const\n            me                    = this,\n            { grid }              = me,\n            { store, rowManager } = grid,\n            { clientY }           = event;\n\n        let valid = true,\n            row   = rowManager.getRowAt(clientY),\n            overRecord,\n            dataIndex,\n            after,\n            over,\n            insertBefore;\n\n        if (row) {\n            const\n                rowTop        = row.top + grid.scrollable.element.getBoundingClientRect().top - grid.scrollable.y,\n                quarter       = row.height / 4,\n                topQuarter    = rowTop + quarter,\n                middleY       = rowTop + row.height / 2,\n                bottomQuarter = rowTop + quarter * 3;\n\n            dataIndex  = row.dataIndex;\n            overRecord = store.getAt(dataIndex);\n\n            // If Tree and pointer is in quarter 2 and 3, add as child of hovered row\n            if (store.tree) {\n                over = (overRecord.isParent || me.dropOnLeaf) && clientY > topQuarter && clientY < bottomQuarter;\n            }\n            else if (store.isGrouped) {\n                over = overRecord.isGroupHeader && overRecord.meta.collapsed;\n            }\n\n            // Else, drop after row below if mouse is in bottom half of hovered row\n            after = !over && event.clientY >= middleY;\n        }\n        // User dragged below last row or above the top row.\n        else {\n            if (event.pageY < grid._bodyRectangle.y) {\n                dataIndex  = 0;\n                overRecord = store.first;\n                after      = false;\n            }\n            else {\n                dataIndex  = store.count - 1;\n                overRecord = store.last;\n                after      = true;\n            }\n            row = grid.rowManager.getRow(dataIndex);\n        }\n\n        if (overRecord === me.overRecord && me.after === after && me.over === over) {\n            context.valid = me.reorderValid;\n            // nothing's changed\n            return;\n        }\n\n        if (me.overRecord !== overRecord) {\n            rowManager.getRowById(me.overRecord)?.removeCls(me.dropOverTargetCls);\n        }\n\n        me.overRecord = overRecord;\n        me.after      = after;\n        me.over       = over;\n\n        if (\n            // Hovering the dragged record. This is a no-op.\n            // But still gather the contextual data.\n            overRecord === context.startRecord ||\n            // Not allowed to drop above topmost group header or below a collapsed header\n            (!after && !over && dataIndex === 0 && store.isGrouped) ||\n            // Not allowed to drop after last collapsed group\n            (after && overRecord.isGroupHeader && overRecord.meta.collapsed && store.indexOf(overRecord) === store.count - 1)\n        ) {\n            valid = false;\n        }\n\n        if (store.tree) {\n            insertBefore = after ? overRecord.nextSibling : overRecord;\n\n            // For trees, prevent moving a parent into its own hierarchy\n            if (context.records.some(rec => rec.contains(overRecord))) {\n                valid = false;\n            }\n\n            context.parent = valid && over ? overRecord : overRecord.parent;\n\n            me.clearTimeout(me.hoverTimer);\n\n            if (overRecord && overRecord.isParent && !overRecord.isExpanded(store)) {\n                me.hoverTimer = me.setTimeout(() => grid.expand(overRecord), me.hoverExpandTimeout);\n            }\n        }\n        else {\n            insertBefore = after ? store.getAt(dataIndex + 1) : overRecord;\n        }\n\n        row.toggleCls(me.dropOverTargetCls, valid && over);\n\n        // If hovering results in same dataIndex, regardless of what row is hovered, and parent has not changed\n        if (!over && dataIndex === store.indexOf(context.startRecord) + (after ? -1 : 1) &&\n            context.parent && context.startRecord.parent === context.parent) {\n            valid = false;\n        }\n\n        // Provide visual clue to user of the drop position\n        // In FF (in tests) it might not have had time to redraw rows after scroll before getting here\n        row && DomHelper.setTranslateY(me.dropIndicator, Math.max(row.top + (after ? row.element.getBoundingClientRect().height : 0), 1));\n\n        // Don't show dropIndicator if holding over a row\n        me.dropIndicator.style.visibility = over ? 'hidden' : 'visible';\n        me.dropIndicator.classList.toggle('b-drag-invalid', !valid);\n\n        // Public property used for validation\n        context.insertBefore = insertBefore;\n\n        context.valid = me.reorderValid = valid;\n    }\n\n    /**\n     * Handle drop\n     * @private\n     */\n    async onDrop(event) {\n        const\n            me          = this,\n            { client }  = me,\n            { context } = event;\n\n        context.valid = context.valid && me.reorderValid;\n\n        if (context.valid) {\n            context.async = true;\n\n            if (client.store.tree) {\n                // For tree scenario, add context about previous positions of dragged tree nodes\n                context.oldPositionContext = context.records.map((record) => ({\n                    record,\n                    parentId    : record.parent?.id,\n                    parentIndex : record.parentIndex\n                }));\n            }\n\n            // Remove for 6.0\n            let result = await me.trigger('gridRowBeforeDropFinalize', event);\n\n            if (result === false) {\n                context.valid = false;\n            }\n\n            // Outside world provided us one or more Promises to wait for\n            result = await client.trigger('gridRowBeforeDropFinalize', event);\n\n            if (result === false) {\n                context.valid = false;\n            }\n\n            await me.dragHelper.animateProxyTo(me.dropIndicator, { align : 'l0-l0' });\n\n            await me.finalizeReorder(context);\n        }\n\n        // already dropped the node, don't have to expand any node hovered anymore\n        // (cancelling expand action after timeout)\n        me.clearTimeout(me.hoverTimer);\n\n        me.overRecord = me.after = me.over = null;\n\n        me.trigger('gridRowDrop', event);\n        client.trigger('gridRowDrop', event);\n    }\n\n    onAbort(event) {\n        this.client.trigger('gridRowDragAbort', event);\n    }\n\n    async finalizeReorder(context) {\n        const\n            me                     = this,\n            { grid }               = me,\n            { store, focusedCell } = grid;\n\n        let { records } = context;\n\n        context.valid = context.valid && !records.some(rec => !store.includes(rec));\n\n        if (context.valid) {\n            let result;\n\n            if (store.tree) {\n                // Remove any selected child records of parent nodes\n                records = records.filter(record => !record.parent || record.bubbleWhile(parent => !records.includes(parent), true));\n\n                result = await context.parent.tryInsertChild(records, me.over ? context.parent.children?.[0] : context.insertBefore);\n                // remove reorder cls from preview parent element dropped\n                grid.rowManager.forEach(r => r.removeCls(me.dropOverTargetCls));\n\n                // If parent wasn't expanded, expand it if it now has children\n                if (!context.parent.isExpanded() && context.parent.children?.length) {\n                    grid.expand(context.parent);\n                }\n\n                context.valid = result !== false;\n            }\n            else if (store.isGrouped && me.over) {\n                store.move(records, store.getAt(store.indexOf(context.insertBefore) + 1));\n            }\n            else {\n                // When dragging multiple rows, ensure the insertBefore reference is not one of the selected records\n                if (records.length > 1) {\n                    while (context.insertBefore && records.includes(context.insertBefore)) {\n                        context.insertBefore = store.getNext(context.insertBefore, false, true);\n                    }\n                }\n                store.move(records, context.insertBefore);\n            }\n\n            if (focusedCell?._rowIndex >= 0) {\n                grid._focusedCell = null;\n                // Refresh focused cell\n                grid.focusCell({\n                    grid,\n                    record   : focusedCell.record,\n                    columnId : focusedCell.columnId\n                });\n            }\n\n            store.clearSorters();\n        }\n\n        context.finalize(context.valid);\n\n        grid.element.classList.remove('b-row-reordering');\n    }\n\n    /**\n     * Clean up on reset\n     * @private\n     */\n    onReset() {\n        const\n            me       = this,\n            { grid } = me,\n            cellEdit = grid.features.cellEdit;\n\n        grid.element.classList.remove('b-row-reordering');\n\n        if (cellEdit) {\n            cellEdit.disabled = me.cellEditDisabledState;\n        }\n\n        me.dropIndicator.remove();\n\n        DomHelper.removeClsGlobally(\n            grid.element,\n            ...me.dropOverTargetCls\n        );\n    }\n\n    //endregion\n\n    //region Render\n\n    onPaint({ firstPaint }) {\n        // columns shown, hidden or reordered\n        if (firstPaint) {\n            this.init();\n        }\n    }\n\n    //endregion\n\n    updateShowGrip(show) {\n        this.grid.element.classList.toggle('b-row-reorder-with-grip', show);\n    }\n\n    get isDragging() {\n        return this.dragHelper.isDragging;\n    }\n}\n\nRowReorder.featureClass = '';\n\nGridFeatureManager.registerFeature(RowReorder, false);\n", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport SummaryFormatter from './mixin/SummaryFormatter.js';\n\n/**\n * @module Grid/feature/Summary\n */\n\n/**\n * @typedef {Object} ColumnSummaryConfig\n * @property {'sum'|'add'|'count'|'countNotEmpty'|'average'|Function} sum Summary type, see\n * {@link Grid/column/Column#config-sum} for details\n * @property {Function} renderer Renderer function for summary, see\n * {@link Grid/column/Column#config-summaryRenderer} for details\n * @property {*} seed Initial value when using a function as `sum`\n */\n\n/**\n * Displays a summary row in the grid footer.\n *\n * {@inlineexample Grid/feature/Summary.js}\n *\n * Specify type of summary on columns, available types are:\n * <dl class=\"wide\">\n * <dt>sum <dd>Sum of all values in the column\n * <dt>add <dd>Alias for sum\n * <dt>count <dd>Number of rows\n * <dt>countNotEmpty <dd>Number of rows containing a value\n * <dt>average <dd>Average of all values in the column\n * <dt>function <dd>A custom function, used with store.reduce. Should take arguments (sum, record)\n * </dl>\n * Columns can also specify a summaryRenderer to format the calculated sum.\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * ```javascript\n * { text : 'Score', data : 'score', width : 80, sum : 'sum' }\n * { text : 'Rank', data : 'rank', width : 80, sum : 'average', summaryRenderer: ({ sum }) => return 'Average rank ' + sum }\n * ```\n *\n * Also, it is possible to set up multiple summaries as array of summary configs:\n * ```javascript\n * { text : 'Rank', data : 'rank', summaries : [{ sum : 'average', label : 'Average' }, { sum : 'count', label : 'Count' }] }\n * ```\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Grid/features\n * @classtype summary\n * @feature\n */\nexport default class Summary extends SummaryFormatter(InstancePlugin) {\n    //region Config\n    static get configurable() {\n        return {\n            /**\n             * Set to `true` to sum values of selected row records\n             * @config {Boolean}\n             */\n            selectedOnly : null,\n\n            hideFooters : false\n        };\n    }\n\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['renderRows', 'bindStore']\n        };\n    }\n\n    //endregion\n\n    //region Init\n\n    static get $name() {\n        return 'Summary';\n    }\n\n    construct(grid, config) {\n        this.grid = grid;\n\n        super.construct(grid, config);\n\n        this.bindStore(grid.store);\n\n        grid.hideFooters = this.hideFooters;\n    }\n\n    bindStore(store) {\n        this.detachListeners('store');\n\n        store.ion({\n            name    : 'store',\n            change  : 'onStoreChange',\n            thisObj : this\n        });\n    }\n\n    get store() {\n        return this.grid.store;\n    }\n\n    doDestroy() {\n        super.doDestroy();\n    }\n\n    doDisable(disable) {\n        super.doDisable(disable);\n\n        const { client } = this;\n\n        if (disable) {\n            client.element.classList.add('b-summary-disabled');\n        }\n        else {\n            this.updateSummaries();\n            client.element.classList.remove('b-summary-disabled');\n            client.eachSubGrid(subGrid => subGrid.scrollable.syncPartners());\n        }\n    }\n\n    //endregion\n\n    //region Render\n\n    renderRows() {\n        this.updateSummaries();\n    }\n\n    /**\n     * Updates summaries. Summaries are displayed as tables in footer (styling left out to keep brief):\n     * ```\n     * <table>\n     *     <tr><td colspan=\"2\">0</td></tr> // { sum : 'min' } Only a calculation, span entire table\n     *     <tr><td>Max</td><td>10</td></tr> // { sum : 'max', label: 'Max' } Label + calculation\n     *     <tr><td>Max</td><td>10</td></tr> // { sum : 'sum', label: 'Max' } Label + calculation\n     * </table>\n     * ```\n     * @private\n     */\n    updateSummaries() {\n        const\n            me              = this,\n            { grid, store } = me,\n            cells           = DomHelper.children(grid.element, '.b-grid-footer'),\n            selectedOnly    = me.selectedOnly && grid.selectedRecords.length > 0,\n            records         = (store.isFiltered ? store.storage.values : store.allRecords).filter(r => !r.isSpecialRow && (!selectedOnly || grid.isSelected(r)));\n\n        // reset seeds, to not have ever increasing sums :)\n        grid.columns.forEach(column => {\n            column.summaries?.forEach(config => {\n                if ('seed' in config) {\n                    if (!('initialSeed' in config)) {\n                        config.initialSeed = config.seed;\n                    }\n\n                    if (['number', 'string', 'date'].includes(typeof config.initialSeed)) {\n                        config.seed = config.initialSeed;\n                    }\n                    else {\n                        // create shallow copy\n                        config.seed = Object.assign({}, config.initialSeed);\n                    }\n                }\n            });\n        });\n\n        cells.forEach(cellElement => {\n            // Skip for special columns like checkbox selection\n            if (!cellElement.dataset.column) {\n                return;\n            }\n\n            const\n                column = grid.columns.get(cellElement.dataset.column),\n                html   = me.generateHtml(column, records, 'b-grid-footer-summary');\n\n            if (column.summaries ? column.summaries.length : column.sum ? 1 : 0) {\n                // First time, set table\n                if (!cellElement.children.length) {\n                    cellElement.innerHTML = html;\n                }\n                // Following times, sync changes\n                else {\n                    DomHelper.sync(html, cellElement.firstElementChild);\n                }\n            }\n        });\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * Updates summaries on store changes (except record update, handled below)\n     * @private\n     */\n    onStoreChange({ action, changes }) {\n        let shouldUpdate = true;\n\n        if (this.disabled) {\n            return;\n        }\n\n        if (action === 'update') {\n            // only update summary when a field that affects summary is changed\n            // <remove-on-release>\n            // TODO: this should maybe be removed, another column might depend on the value for its summary?\n            // </remove-on-release>\n            shouldUpdate = Object.keys(changes).some(field => {\n                const colField = this.grid.columns.get(field);\n                // check existence, since a field not used in a column might have changed\n                return Boolean(colField) && (Boolean(colField.sum) || Boolean(colField.summaries));\n            });\n        }\n\n        if (shouldUpdate) {\n            this.updateSummaries();\n        }\n    }\n\n    //endregion\n\n    updateSelectedOnly(value) {\n        const me = this;\n        me.detachListeners('selectionChange');\n\n        if (value) {\n            me.grid.ion({\n                name            : 'selectionChange',\n                selectionChange : me.refresh,\n                thisObj         : me\n            });\n        }\n        me.refresh();\n    }\n\n    /**\n     * Refreshes the summaries\n     */\n    refresh() {\n        this.updateSummaries();\n    }\n}\n\nSummary.featureClass = 'b-summary';\n\nGridFeatureManager.registerFeature(Summary);\n", "import { RowsRange } from '../../../feature/export/Utils.js';\nimport Combo from '../../../../Core/widget/Combo.js';\n\nexport default class ExportRowsCombo extends Combo {\n\n    //region Config\n\n    static get $name() {\n        return 'ExportRowsCombo';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'exportrowscombo';\n    }\n\n    static get defaultConfig() {\n        return {\n            editable : false\n        };\n    }\n\n    //endregion\n\n    buildItems() {\n        const me = this;\n\n        return [\n            { id : RowsRange.all, text : me.L('L{all}') },\n            { id : RowsRange.visible, text : me.L('L{visible}') }\n        ];\n    }\n}\n\n// Register this widget type with its Factory\nExportRowsCombo.initClass();\n", "import { Orientation } from '../../../feature/export/Utils.js';\nimport Combo from '../../../../Core/widget/Combo.js';\n\nexport default class ExportOrientationCombo extends Combo {\n\n    //region Config\n\n    static get $name() {\n        return 'ExportOrientationCombo';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'exportorientationcombo';\n    }\n\n    static get defaultConfig() {\n        return {\n            editable : false\n        };\n    }\n\n    //endregion\n\n    buildItems() {\n        const me = this;\n\n        return [\n            { id : Orientation.portrait, text : me.L('L{portrait}') },\n            { id : Orientation.landscape, text : me.L('L{landscape}') }\n        ];\n    }\n}\n\n// Register this widget type with its Factory\nExportOrientationCombo.initClass();\n", "import Popup from '../../../Core/widget/Popup.js';\nimport LocaleManager from '../../../Core/localization/LocaleManager.js';\nimport './field/ExportRowsCombo.js';\nimport './field/ExportOrientationCombo.js';\nimport { FileFormat, PaperFormat } from '../../feature/export/Utils.js';\nimport Checkbox from '../../../Core/widget/Checkbox.js';\nimport Field from '../../../Core/widget/Field.js';\n\nfunction buildComboItems(obj, fn = x => x) {\n    return Object.keys(obj).map(key => ({ id : key, text : fn(key) }));\n}\n\n/**\n * @module Grid/view/export/ExportDialog\n */\n\n/**\n * Dialog window used by the {@link Grid/feature/export/PdfExport PDF export feature}. It allows users to select export\n * options like paper format and columns to export. This dialog contains a number of predefined\n * {@link Core/widget/Field fields} which you can access through the popup's {@link #property-widgetMap}.\n *\n * ## Default widgets\n *\n * The default widgets of this dialog are:\n *\n * | Widget ref             | Type                         | Weight | Description                                          |\n * |------------------------|------------------------------|--------|----------------------------------------------------- |\n * | `columnsField`         | {@link Core/widget/Combo}    | 100    | Choose columns to export                             |\n * | `rowsRangeField`       | {@link Core/widget/Combo}    | 200    | Choose which rows to export                          |\n * | `exporterTypeField`    | {@link Core/widget/Combo}    | 300    | Type of the exporter to use                          |\n * | `alignRowsField`       | {@link Core/widget/Checkbox} | 400    | Align row top to the page top on every exported page |\n * | `repeatHeaderField`    | {@link Core/widget/Checkbox} | 500    | Toggle repeating headers on / off                    |\n * | `fileFormatField`      | {@link Core/widget/Combo}    | 600    | Choose file format                                   |\n * | `paperFormatField`     | {@link Core/widget/Combo}    | 700    | Choose paper format                                  |\n * | `orientationField`     | {@link Core/widget/Combo}    | 800    | Choose orientation                                   |\n *\n * The default buttons are:\n *\n * | Widget ref             | Type                       | Weight | Description                                          |\n * |------------------------|----------------------------|--------|------------------------------------------------------|\n * | `exportButton`         | {@link Core/widget/Button} | 100    | Triggers export                                      |\n * | `cancelButton`         | {@link Core/widget/Button} | 200    | Cancel export                                        |\n *\n * Bottom buttons may be customized using `bbar` config passed to `exportDialog`:\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         pdfExport : {\n *             editorConfig : {\n *                 bbar : {\n *                     items : {\n *                         exportButton : { text : 'Go!' }\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n * ## Configuring default widgets\n *\n * Widgets can be customized with {@link Grid/feature/export/PdfExport#config-exportDialog} config:\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         pdfExport : {\n *             exportDialog : {\n *                 items : {\n *                     // hide the field\n *                     orientationField  : { hidden : true },\n *\n *                     // reorder fields\n *                     exporterTypeField : { weight : 150 },\n *\n *                     // change default format in exporter\n *                     fileFormatField   : { value : 'png' }\n *                 }\n *             }\n *         }\n *     }\n * });\n *\n * grid.features.pdfExport.showExportDialog();\n * ```\n *\n * ## Configuring default columns\n *\n * By default all visible columns are selected in the export dialog. This is managed by the\n * {@link #config-autoSelectVisibleColumns} config. To change default selected columns you should disable this config\n * and set field value. Value should be an array of valid column ids (or column instances). This way you can\n * preselect hidden columns:\n *\n * ```javascript\n * const grid = new Grid({\n *     columns : [\n *         { id : 'name', text : 'Name', field : 'name' },\n *         { id : 'age', text : 'Age', field : 'age' },\n *         { id : 'city', text : 'City', field : 'city', hidden : true }\n *     ],\n *     features : {\n *         pdfExport : {\n *             exportDialog : {\n *                 autoSelectVisibleColumns : false,\n *                 items : {\n *                     columnsField : { value : ['name', 'city'] }\n *                 }\n *             }\n *         }\n *     }\n * })\n *\n * // This will show export dialog with Name and City columns selected\n * // even though City column is hidden in the UI\n * grid.features.pdfExport.showExportDialog();\n * ```\n *\n * ## Adding fields\n *\n * You can add your own fields to the export dialog. To make such field value acessible to the feature it should follow\n * a specific naming pattern - it should have `ref` config ending with `Field`, see other fields for reference -\n * `orientationField`, `columnsField`, etc. Fields not matching this pattern are ignored. When values are collected from\n * the dialog, `Field` part of the widget reference is removed, so `orientationField` becomes `orientation`, `fooField`\n * becomes `foo`, etc.\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         pdfExport : {\n *             exportDialog : {\n *                 items : {\n *                     // This field gets into export config\n *                     fooField : {\n *                         type : 'text',\n *                         label : 'Foo',\n *                         value : 'FOO'\n *                     },\n *\n *                     // This one does not, because name doesn't end with `Field`\n *                     bar : {\n *                         type : 'text',\n *                         label : 'Bar',\n *                         value : 'BAR'\n *                     },\n *\n *                     // Add a container widget to wrap some fields together\n *                     myContainer : {\n *                         type : 'container',\n *                         items : {\n *                             // This one gets into config too despite the nesting level\n *                             bazField : {\n *                                 type : 'text',\n *                                 label : 'Baz',\n *                                 value : 'BAZ'\n *                             }\n *                         }\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * });\n *\n * // Assuming export dialog is opened and export triggered with default values\n * // you can receive custom field values here\n * grid.on({\n *     beforePdfExport({ config }) {\n *         console.log(config.foo) // 'FOO'\n *         console.log(config.bar) // undefined\n *         console.log(config.baz) // 'BAZ'\n *     }\n * });\n * ```\n *\n * ## Configuring widgets at runtime\n *\n * If you don't know column ids before grid instantiation or you want a flexible config, you can change widget values\n * before dialog pops up:\n *\n * ```javascript\n * const grid = new Grid({\n *     columns : [\n *         { id : 'name', text : 'Name', field : 'name' },\n *         { id : 'age', text : 'Age', field : 'age' },\n *         { id : 'city', text : 'City', field : 'city', hidden : true }\n *     ],\n *     features : {\n *         pdfExport : true\n *     }\n * });\n *\n * // Such listener would ignore autoSelectVisibleColumns config. Similar to the snippet\n * // above this will show Name and City columns\n * grid.features.pdfExport.exportDialog.on({\n *     beforeShow() {\n *         this.widgetMap.columnsField.value = ['age', 'city']\n *     }\n * });\n * ```\n *\n * @extends Core/widget/Popup\n */\nexport default class ExportDialog extends Popup {\n\n    //region Config\n\n    static get $name() {\n        return 'ExportDialog';\n    }\n\n    static get type() {\n        return 'exportdialog';\n    }\n\n    static get configurable() {\n        return {\n            autoShow  : false,\n            autoClose : false,\n            closable  : true,\n            centered  : true,\n\n            /**\n             * Returns map of values of dialog fields.\n             * @member {Object<String,Object>} values\n             * @readonly\n             */\n\n            /**\n             * Grid instance to build export dialog for\n             * @config {Grid.view.Grid}\n             */\n            client : null,\n\n            /**\n             * Set to `false` to not preselect all visible columns when the dialog is shown\n             * @config {Boolean}\n             */\n            autoSelectVisibleColumns : true,\n\n            /**\n             * Set to `false` to allow using PNG + Multipage config in export dialog\n             * @config {Boolean}\n             */\n            hidePNGMultipageOption : true,\n\n            title : 'L{exportSettings}',\n\n            maxHeight : '80%',\n\n            scrollable : {\n                overflowY : true\n            },\n            defaults : {\n                localeClass : this\n            },\n            items : {\n                columnsField : {\n                    type         : 'combo',\n                    label        : 'L{ExportDialog.columns}',\n                    store        : {},\n                    valueField   : 'id',\n                    displayField : 'text',\n                    multiSelect  : true,\n                    weight       : 100,\n                    maxHeight    : 100\n                },\n                rowsRangeField : {\n                    type   : 'exportrowscombo',\n                    label  : 'L{ExportDialog.rows}',\n                    value  : 'all',\n                    weight : 200\n                },\n                exporterTypeField : {\n                    type         : 'combo',\n                    label        : 'L{ExportDialog.exporterType}',\n                    editable     : false,\n                    value        : 'singlepage',\n                    displayField : 'text',\n                    buildItems() {\n                        const dialog = this.parent;\n\n                        return dialog.exporters.map(exporter => ({\n                            id   : exporter.type,\n                            text : dialog.optionalL(exporter.title, this)\n                        }));\n                    },\n                    onChange({ value }) {\n                        this.owner.widgetMap.alignRowsField.hidden    = value === 'singlepage';\n                        this.owner.widgetMap.repeatHeaderField.hidden = value !== 'multipagevertical';\n                    },\n                    weight : 300\n                },\n                alignRowsField : {\n                    type    : 'checkbox',\n                    label   : 'L{ExportDialog.alignRows}',\n                    checked : false,\n                    hidden  : true,\n                    weight  : 400\n                },\n                repeatHeaderField : {\n                    type        : 'checkbox',\n                    label       : 'L{ExportDialog.repeatHeader}',\n                    localeClass : this,\n                    hidden      : true,\n                    weight      : 500\n                },\n                fileFormatField : {\n                    type        : 'combo',\n                    label       : 'L{ExportDialog.fileFormat}',\n                    localeClass : this,\n                    editable    : false,\n                    value       : 'pdf',\n                    items       : [],\n                    onChange({ value, oldValue }) {\n                        const dialog = this.parent;\n                        if (dialog.hidePNGMultipageOption) {\n                            const\n                                exporterField = dialog.widgetMap.exporterTypeField,\n                                exporter      = exporterField.store.find(r => r.id === 'singlepage');\n\n                            if (value === FileFormat.png && exporter) {\n                                this._previousDisabled = exporterField.disabled;\n                                exporterField.disabled = true;\n\n                                this._previousValue = exporterField.value;\n                                exporterField.value = 'singlepage';\n                            }\n                            else if (oldValue === FileFormat.png && this._previousValue) {\n                                exporterField.disabled = this._previousDisabled;\n                                exporterField.value    = this._previousValue;\n                            }\n                        }\n                    },\n                    weight : 600\n                },\n                paperFormatField : {\n                    type     : 'combo',\n                    label    : 'L{ExportDialog.paperFormat}',\n                    editable : false,\n                    value    : 'A4',\n                    items    : [],\n                    weight   : 700\n                },\n                orientationField : {\n                    type   : 'exportorientationcombo',\n                    label  : 'L{ExportDialog.orientation}',\n                    value  : 'portrait',\n                    weight : 800\n                }\n            },\n            bbar : {\n                defaults : {\n                    localeClass : this\n                },\n                items : {\n                    exportButton : {\n                        color   : 'b-green',\n                        text    : 'L{ExportDialog.export}',\n                        weight  : 100,\n                        onClick : 'up.onExportClick'\n                    },\n                    cancelButton : {\n                        color   : 'b-gray',\n                        text    : 'L{ExportDialog.cancel}',\n                        weight  : 200,\n                        onClick : 'up.onCancelClick'\n                    }\n                }\n            }\n        };\n    }\n\n    //endregion\n\n    construct(config = {}) {\n        const\n            me         = this,\n            { client } = config;\n\n        if (!client) {\n            throw new Error('`client` config is required');\n        }\n\n        me.columnsStore = client.columns.chain(column => column.isLeaf && column.exportable, null, { excludeCollapsedRecords : false });\n\n        me.applyInitialValues(config);\n\n        super.construct(config);\n\n        LocaleManager.ion({\n            locale  : 'onLocaleChange',\n            prio    : -1,\n            thisObj : me\n        });\n    }\n\n    applyInitialValues(config) {\n        const\n            me    = this,\n            items = config.items = config.items || {};\n\n        config.width               = config.width || me.L('L{width}');\n        config.defaults            = config.defaults || {};\n        config.defaults.labelWidth = config.defaults.labelWidth || me.L('L{ExportDialog.labelWidth}');\n\n        items.columnsField     = items.columnsField || {};\n        items.fileFormatField  = items.fileFormatField || {};\n        items.paperFormatField = items.paperFormatField || {};\n\n        items.fileFormatField.items  = buildComboItems(FileFormat, value => value.toUpperCase());\n        items.paperFormatField.items = buildComboItems(PaperFormat);\n\n        items.columnsField.store = me.columnsStore;\n    }\n\n    onBeforeShow() {\n        const { columnsField, alignRowsField, exporterTypeField, repeatHeaderField } = this.widgetMap;\n\n        if (this.autoSelectVisibleColumns) {\n            columnsField.value = this.columnsStore.query(c => !c.hidden);\n        }\n        alignRowsField.hidden    = exporterTypeField.value === 'singlepage';\n        repeatHeaderField.hidden = exporterTypeField.value !== 'multipagevertical';\n\n        super.onBeforeShow?.(...arguments);\n    }\n\n    onLocaleChange() {\n        const\n            labelWidth = this.L('L{labelWidth}');\n\n        this.width = this.L('L{width}');\n\n        this.eachWidget(widget => {\n            if (widget instanceof Field) {\n                widget.labelWidth = labelWidth;\n            }\n        });\n    }\n\n    onExportClick() {\n        const values = this.values;\n\n        /**\n         * Fires when export button is clicked\n         * @event export\n         * @param {Object} values Object containing config for {@link Grid.feature.export.PdfExport#function-export export()} method\n         * @category Export\n         */\n        this.trigger('export', { values });\n    }\n\n    onCancelClick() {\n        /**\n         * Fires when cancel button is clicked. Popup will hide itself.\n         * @event cancel\n         * @category Export\n         */\n        this.trigger('cancel');\n        this.hide();\n    }\n\n    get values() {\n        const\n            fieldRe = /field/i,\n            result  = {};\n\n        this.eachWidget(widget => {\n            if (fieldRe.test(widget.ref)) {\n                result[widget.ref.replace(fieldRe, '')] = widget instanceof Checkbox ? widget.checked : widget.value;\n            }\n        });\n\n        return result;\n    }\n}\n\nExportDialog.initClass();\n", "import Exporter from './Exporter.js';\nimport { Orientation, PaperFormat, RowsRange } from '../Utils.js';\n\n/**\n * @module Grid/feature/export/exporter/MultiPageExporter\n */\n\n/**\n * A multiple page exporter. Used by the {@link Grid.feature.export.PdfExport} feature to export to multiple pages. You\n * do not need to use this class directly.\n *\n * ### Extending exporter\n *\n * ```javascript\n * class MyMultiPageExporter extends MultiPageExporter {\n *     // type is required for exporter\n *     static get type() {\n *         return 'mymultipageexporter';\n *     }\n *\n *     get stylesheets() {\n *         const stylesheets = super.stylesheets;\n *\n *         stylesheets.forEach(styleNodeOrLinkTag => doSmth(styleNodeOrLinkTag))\n *\n *         return stylesheets;\n *     }\n * }\n *\n * const grid = new Grid({\n *     features : {\n *         pdfExport : {\n *             // this export feature is configured with only one exporter\n *             exporters : [MyMultiPageExporter]\n *         }\n *     }\n * });\n *\n * // run export with the new exporter\n * grid.features.pdfExport.export({ exporter : 'mymultipageexporter' });\n * ```\n *\n * @classType multipage\n * @feature\n * @extends Grid/feature/export/exporter/Exporter\n */\nexport default class MultiPageExporter extends Exporter {\n\n    static get $name() {\n        return 'MultiPageExporter';\n    }\n\n    static get type() {\n        return 'multipage';\n    }\n\n    static get title() {\n        // In case locale is missing exporter is still distinguishable\n        return this.L('L{multipage}');\n    }\n\n    static get exportingPageText() {\n        return 'L{exportingPage}';\n    }\n\n    //region State management\n\n    async stateNextPage({ client, rowsRange, enableDirectRendering }) {\n        const { exportMeta } = this;\n\n        ++exportMeta.currentPage;\n        ++exportMeta.verticalPosition;\n\n        delete exportMeta.lastExportedRowBottom;\n\n        // If current vertical position is greater than max vertical pages, switch to next column\n        if (exportMeta.verticalPosition >= exportMeta.verticalPages) {\n            Object.assign(exportMeta, {\n                verticalPosition     : 0,\n                horizontalPosition   : exportMeta.horizontalPosition + 1,\n                currentPageTopMargin : 0,\n                lastTop              : 0,\n                lastRowIndex         : rowsRange === RowsRange.visible ? client.rowManager.firstVisibleRow.dataIndex : 0\n            });\n\n            delete exportMeta.lastRowDataIndex;\n\n            if (!enableDirectRendering) {\n                await this.scrollRowIntoView(client, exportMeta.firstVisibleDataIndex, { block : 'start' });\n            }\n        }\n    }\n\n    //endregion\n\n    //region Preparation\n\n    async prepareComponent(config) {\n        await super.prepareComponent(config);\n\n        const\n            me              = this,\n            { exportMeta }  = me,\n            {\n                client,\n                headerTpl,\n                footerTpl,\n                alignRows,\n                rowsRange,\n                enableDirectRendering\n            }               = config,\n            paperFormat     = PaperFormat[config.paperFormat],\n            isPortrait      = config.orientation === Orientation.portrait,\n            paperWidth      = isPortrait ? paperFormat.width : paperFormat.height,\n            paperHeight     = isPortrait ? paperFormat.height : paperFormat.width,\n            pageWidth       = me.inchToPx(paperWidth),\n            pageHeight      = me.inchToPx(paperHeight),\n            onlyVisibleRows = rowsRange === RowsRange.visible,\n            horizontalPages = Math.ceil(exportMeta.totalWidth / pageWidth);\n\n        // To estimate amount of pages correctly we need to know height of the header/footer on every page\n        let contentHeight = pageHeight;\n\n        if (headerTpl) {\n            contentHeight -= me.measureElement(headerTpl({\n                totalWidth  : exportMeta.totalWidth,\n                totalPages  : -1,\n                currentPage : -1\n            }));\n        }\n\n        if (footerTpl) {\n            contentHeight -= me.measureElement(footerTpl({\n                totalWidth  : exportMeta.totalWidth,\n                totalPages  : -1,\n                currentPage : -1\n            }));\n        }\n\n        let totalHeight, verticalPages, totalRows = client.store.count;\n\n        if (onlyVisibleRows) {\n            totalRows = me.getVisibleRowsCount(client);\n\n            totalHeight = exportMeta.totalHeight + client.headerHeight + client.footerHeight + client.bodyHeight;\n        }\n        else {\n            totalHeight = exportMeta.totalHeight + client.headerHeight + client.footerHeight + client.scrollable.scrollHeight;\n        }\n\n        // alignRows config specifies if rows should be always fully visible. E.g. if row doesn't fit on the page, it goes\n        // to the top of the next page\n        if (alignRows && !onlyVisibleRows) {\n            // we need to estimate amount of vertical pages for case when we only put row on the page if it fits\n            // first we need to know how much rows would fit one page, keeping in mind first page also contains header\n            // This estimation is loose, because row height might differ much between pages\n            const\n                rowHeight       = client.rowManager.rowOffsetHeight,\n                rowsOnFirstPage = Math.floor((contentHeight - client.headerHeight) / rowHeight),\n                rowsPerPage     = Math.floor(contentHeight / rowHeight),\n                remainingRows   = totalRows - rowsOnFirstPage;\n\n            verticalPages = 1 + Math.ceil(remainingRows / rowsPerPage);\n        }\n        else {\n            verticalPages = Math.ceil(totalHeight / contentHeight);\n        }\n\n        Object.assign(exportMeta, {\n            paperWidth,\n            paperHeight,\n            pageWidth,\n            pageHeight,\n            horizontalPages,\n            verticalPages,\n            totalHeight,\n            contentHeight,\n            totalRows,\n            totalPages           : horizontalPages * verticalPages,\n            currentPage          : 0,\n            verticalPosition     : 0,\n            horizontalPosition   : 0,\n            currentPageTopMargin : 0,\n            lastTop              : 0,\n            lastRowIndex         : onlyVisibleRows ? client.rowManager.firstVisibleRow.dataIndex : 0\n        });\n\n        if (!enableDirectRendering) {\n            this.adjustRowBuffer(client);\n        }\n    }\n\n    async restoreComponent(config) {\n        await super.restoreComponent(config);\n\n        if (!config.enableDirectRendering) {\n            this.restoreRowBuffer(config.client);\n        }\n    }\n\n    //endregion\n\n    async collectRows(config) {\n        const\n            me             = this,\n            { exportMeta } = me,\n            {\n                client,\n                alignRows,\n                rowsRange\n            }              = config,\n            {\n                subGrids,\n                currentPageTopMargin,\n                verticalPosition,\n                contentHeight,\n                totalRows,\n                lastRowDataIndex\n            }              = exportMeta,\n            { rowManager } = client,\n            { rows }       = rowManager,\n            onlyVisible    = rowsRange === RowsRange.visible,\n            hasMergeCells  = client.hasActiveFeature('mergeCells');\n\n        let remainingHeight, index;\n\n        if (onlyVisible && lastRowDataIndex != null) {\n            if (lastRowDataIndex === rows[rows.length - 1].dataIndex) {\n                index = rows.length - 1;\n            }\n            else {\n                index = rows.findIndex(r => r.dataIndex === lastRowDataIndex);\n            }\n        }\n        else {\n            index = onlyVisible\n                ? rows.findIndex(r => r.bottom > Math.ceil(client.scrollable.y))\n                : rows.findIndex(r => r.bottom + currentPageTopMargin + client.headerHeight > 0);\n        }\n\n        const\n            firstRowIndex     = index,\n            // This is a portion of the row which is not visible, which means it shouldn't affect remaining height\n            // Don't calculate for the first page\n            overflowingHeight = (onlyVisible || verticalPosition === 0) ? 0 : rows[index].top + currentPageTopMargin + client.headerHeight;\n\n        // Calculate remaining height to fill with rows\n        // remainingHeight is height of the page content region to fill. When next row is exported, this heights gets\n        // reduced. Since top rows may be partially visible, it would lead to increasing error and eventually to incorrect\n        // exported rows for the page\n        remainingHeight = contentHeight - overflowingHeight;\n\n        // first exported page container header\n        if (verticalPosition === 0) {\n            remainingHeight -= client.headerHeight;\n        }\n\n        // data index of the last collected row\n        let lastDataIndex,\n            offset = 0;\n\n        while (remainingHeight > 0) {\n            const row = rows[index];\n\n            if (alignRows && remainingHeight < row.offsetHeight) {\n                offset = -remainingHeight;\n                remainingHeight = 0;\n                // If we skip a row save its bottom to meta data in order to align canvases height\n                // properly\n                me.exportMeta.lastExportedRowBottom = rows[index - 1].bottom;\n            }\n            else {\n                me.collectRow(row);\n\n                remainingHeight -= row.offsetHeight;\n\n                lastDataIndex = row.dataIndex;\n\n                // Last row is processed, still need to fill the view\n                if (++index === rows.length && remainingHeight > 0) {\n                    remainingHeight = 0;\n                }\n                else if (onlyVisible && (index - firstRowIndex) === totalRows) {\n                    remainingHeight = 0;\n                }\n            }\n        }\n\n        // Collect merged cells per subgrid\n        if (hasMergeCells) {\n            for (const subGridName in subGrids) {\n                const\n                    subGrid     = subGrids[subGridName],\n                    mergedCells = client.subGrids[subGridName].element.querySelectorAll(`.b-grid-merged-cells`);\n\n                subGrid.mergedCellsHtml = [];\n\n                for (const mergedCell of mergedCells) {\n                    subGrid.mergedCellsHtml.push(mergedCell.outerHTML);\n                }\n            }\n        }\n\n        const lastRow = rows[index - 1];\n\n        if (lastRow) {\n            // Calculate exact grid height according to the last exported row\n            exportMeta.exactGridHeight = lastRow.bottom + client.footerContainer.offsetHeight + client.headerContainer.offsetHeight;\n            exportMeta.lastRowDataIndex = lastRow.dataIndex + 1;\n        }\n\n        await me.onRowsCollected(rows.slice(firstRowIndex, index), config);\n\n        // No scrolling required if we are only exporting currently visible rows\n        if (onlyVisible) {\n            exportMeta.exactGridHeight -= exportMeta.scrollableTopMargin = client.scrollable.y;\n        }\n        else {\n            // With variable row height row manager might relayout rows to fix position, moving them up or down.\n            const detacher = rowManager.ion({ offsetRows : ({ offset : value }) => offset += value });\n\n            await me.scrollRowIntoView(client, lastDataIndex + 1);\n\n            detacher();\n        }\n\n        return offset;\n    }\n\n    async renderRows(config) {\n        const\n            me              = this,\n            { exportMeta }  = me,\n            {\n                client,\n                alignRows,\n                rowsRange\n            }               = config,\n            {\n                currentPageTopMargin,\n                verticalPosition,\n                contentHeight,\n                totalRows,\n                lastRowIndex,\n                fakeRow\n            }               = exportMeta,\n            { store }       = client,\n            hasMergeCells   = client.hasActiveFeature('mergeCells'),\n            onlyVisibleRows = rowsRange === RowsRange.visible;\n\n        let index       = lastRowIndex,\n            { lastTop } = exportMeta,\n            remainingHeight;\n\n        const\n            firstRowIndex     = index,\n            // This is a portion of the row which is not visible, which means it shouldn't affect remaining height\n            // Don't calculate for the first page\n            overflowingHeight = (onlyVisibleRows || verticalPosition === 0) ? 0 : lastTop + currentPageTopMargin + client.headerHeight,\n            rows              = [];\n\n        // Calculate remaining height to fill with rows\n        // remainingHeight is height of the page content region to fill. When next row is exported, this heights gets\n        // reduced. Since top rows may be partially visible, it would lead to increasing error and eventually to incorrect\n        // exported rows for the page\n        remainingHeight = contentHeight - overflowingHeight;\n\n        // first exported page contains header\n        if (verticalPosition === 0) {\n            remainingHeight -= client.headerHeight;\n        }\n\n        // data index of the last collected row\n        let lastDataIndex, previousTop,\n            offset = 0;\n\n        while (remainingHeight > 0) {\n            fakeRow.render(index, store.getAt(index), true, false, true);\n\n            if (alignRows && remainingHeight < fakeRow.offsetHeight) {\n                offset = -remainingHeight;\n                remainingHeight = 0;\n                // If we skip a row save its bottom to meta data in order to align canvases height\n                // properly\n                me.exportMeta.lastExportedRowBottom = lastTop;\n            }\n            else {\n                previousTop = lastTop;\n                lastDataIndex = index;\n\n                lastTop = fakeRow.translate(lastTop);\n                remainingHeight -= fakeRow.offsetHeight;\n\n                me.collectRow(fakeRow);\n\n                // Push an object with data required to build merged cell\n                rows.push({\n                    top          : fakeRow.top,\n                    bottom       : fakeRow.bottom,\n                    offsetHeight : fakeRow.offsetHeight,\n                    dataIndex    : fakeRow.dataIndex\n                });\n\n                // Last row is processed, still need to fill the view\n                if (++index === store.count && remainingHeight > 0) {\n                    remainingHeight = 0;\n                }\n                else if (onlyVisibleRows && (index - firstRowIndex) === totalRows) {\n                    remainingHeight = 0;\n                }\n            }\n        }\n\n        if (hasMergeCells) {\n            me.renderMergedCells(config, firstRowIndex, index, rows);\n        }\n\n        // Store next to last row index and top position so we could proceed on the next page.\n        // In fact, when we take full control of row rendering we don't even need to do this. It is only required\n        // to be compatible with current exporters. When we get rid of scrolling, we can just start rendering rows\n        // on each page from 0 (adjusted by overflow of the previous row)\n        exportMeta.lastRowIndex = alignRows ? index : lastDataIndex;\n        exportMeta.lastTop = alignRows ? lastTop : previousTop;\n\n        if (fakeRow) {\n            // Calculate exact grid height according to the last exported row\n            exportMeta.exactGridHeight = fakeRow.bottom + client.footerContainer.offsetHeight + client.headerContainer.offsetHeight;\n        }\n\n        await me.onRowsCollected(rows, config);\n\n        return offset;\n    }\n\n    async buildPage(config) {\n        const\n            me             = this,\n            { exportMeta } = me,\n            {\n                client,\n                headerTpl,\n                footerTpl,\n                enableDirectRendering\n            }              = config,\n            {\n                totalWidth,\n                totalPages,\n                currentPage,\n                subGrids\n            }              = exportMeta;\n\n        // Rows are stored in shared state object, need to clean it before exporting next page\n        Object.values(subGrids).forEach(subGrid => subGrid.rows = []);\n\n        // With variable row height total height might change after scroll, update it\n        // to show content completely on the last page\n        if (config.rowsRange === RowsRange.all) {\n            exportMeta.totalHeight = client.height - client.bodyHeight + client.scrollable.scrollHeight - me.getVirtualScrollerHeight(client);\n        }\n\n        let header, footer;\n\n        // Measure header and footer height\n        if (headerTpl) {\n            header = me.prepareHTML(headerTpl({\n                totalWidth,\n                totalPages,\n                currentPage\n            }));\n        }\n\n        if (footerTpl) {\n            footer = me.prepareHTML(footerTpl({\n                totalWidth,\n                totalPages,\n                currentPage\n            }));\n        }\n\n        let offset;\n\n        if (enableDirectRendering) {\n            offset = await me.renderRows(config);\n        }\n        else {\n            offset = await me.collectRows(config);\n        }\n\n        const html = me.buildPageHtml(config);\n\n        return { html, header, footer, offset };\n    }\n\n    async onRowsCollected() {}\n\n    buildPageHtml() {\n        const\n            me           = this,\n            { subGrids } = me.exportMeta;\n\n        // Now when rows are collected, we need to add them to exported grid\n        let html = me.prepareExportElement();\n\n        Object.values(subGrids).forEach(({ placeHolder, rows, mergedCellsHtml }) => {\n            const placeHolderText = placeHolder.outerHTML;\n\n            let contentHtml = rows.reduce((result, row) => {\n                result += row[0];\n\n                return result;\n            }, '');\n\n            if (mergedCellsHtml?.length) {\n                contentHtml += `<div class=\"b-grid-merged-cells-container\">${mergedCellsHtml.join('')}</div>`;\n            }\n\n            html = html.replace(placeHolderText, contentHtml);\n        });\n\n        return html;\n    }\n\n    prepareExportElement() {\n        const\n            me = this,\n            { element, exportMeta } = me;\n\n        if (exportMeta.scrollableTopMargin) {\n            element.querySelector('.b-grid-vertical-scroller').style.marginTop = `-${exportMeta.scrollableTopMargin}px`;\n        }\n\n        return super.prepareExportElement();\n    }\n}\n\n// HACK: terser/obfuscator doesn't yet support async generators, when processing code it converts async generator to regular async\n// function.\nMultiPageExporter.prototype.pagesExtractor = async function * pagesExtractor(config) {\n    const\n        me = this,\n        {\n            exportMeta,\n            stylesheets\n        }  = me,\n        {\n            totalWidth,\n            totalPages,\n            paperWidth,\n            paperHeight,\n            contentHeight\n        }  = exportMeta;\n\n    let currentPage;\n\n    while ((currentPage = exportMeta.currentPage) < totalPages) {\n        me.trigger('exportStep', { text : me.L(MultiPageExporter.exportingPageText, { currentPage, totalPages }), progress : Math.round(((currentPage + 1) / totalPages) * 90) });\n\n        const { html, header, footer, offset } = await me.buildPage(config);\n\n        // TotalHeight might change in case of variable row heights\n        // Move exported content in the visible frame\n        const styles = [\n            ...stylesheets,\n            `\n                <style>\n                    #${config.client.id} {\n                        height: ${exportMeta.exactGridHeight}px !important;\n                        width: ${totalWidth}px !important;\n                    }\n                    \n                    .b-export-body .b-export-viewport {\n                        margin-inline-start : ${-paperWidth * exportMeta.horizontalPosition}in;\n                        margin-top  : ${exportMeta.currentPageTopMargin}px;\n                    }\n                </style>\n            `];\n\n        // when aligning rows, offset gets accumulated, so we need to take it into account\n        exportMeta.currentPageTopMargin -= contentHeight + offset;\n\n        await me.stateNextPage(config);\n\n        yield {\n            html : me.pageTpl({\n                html,\n                header,\n                footer,\n                styles,\n                paperWidth,\n                paperHeight\n            })\n        };\n    }\n};\n", "import Exporter from './Exporter.js';\nimport { Orientation, PaperFormat, RowsRange } from '../Utils.js';\n\n/**\n * @module Grid/feature/export/exporter/MultiPageVerticalExporter\n */\n\n/**\n * A vertical multiple page exporter. Used by the {@link Grid.feature.export.PdfExport} feature to export to multiple\n * pages. Content will be scaled in a horizontal direction to fit the page.\n *\n * You do not need to use this class directly.\n *\n * ### Extending exporter\n *\n * ```javascript\n * class MyMultiPageVerticalExporter extends MultiPageVerticalExporter {\n *     // type is required for exporter\n *     static get type() {\n *         return 'mymultipageverticalexporter';\n *     }\n *\n *     get stylesheets() {\n *         const stylesheets = super.stylesheets;\n *\n *         stylesheets.forEach(styleNodeOrLinkTag => doSmth(styleNodeOrLinkTag))\n *\n *         return stylesheets;\n *     }\n * }\n *\n * const grid = new Grid({\n *     features : {\n *         pdfExport : {\n *             // this export feature is configured with only one exporter\n *             exporters : [MyMultiPageVerticalExporter]\n *         }\n *     }\n * });\n *\n * // run export with the new exporter\n * grid.features.pdfExport.export({ exporter : 'mymultipageverticalexporter' });\n * ```\n *\n * @classType multipagevertical\n * @feature\n * @extends Grid/feature/export/exporter/Exporter\n */\nexport default class MultiPageVerticalExporter extends Exporter {\n\n    static get $name() {\n        return 'MultiPageVerticalExporter';\n    }\n\n    static get type() {\n        return 'multipagevertical';\n    }\n\n    static get title() {\n        // In case locale is missing exporter is still distinguishable\n        return this.L('L{multipagevertical}');\n    }\n\n    static get exportingPageText() {\n        return 'L{exportingPage}';\n    }\n\n    //region State management\n\n    async stateNextPage({ client }) {\n        const\n            { exportMeta } = this,\n            {\n                totalRows,\n                processedRows,\n                totalPages\n            } = exportMeta;\n\n        ++exportMeta.currentPage;\n        ++exportMeta.verticalPosition;\n\n        // With variable row heights it is possible that initial pages estimation is wrong. If we're out but there are\n        // more rows to process - continue exporting\n        if (exportMeta.currentPage === totalPages && processedRows.size !== totalRows) {\n            ++exportMeta.totalPages;\n            ++exportMeta.verticalPages;\n        }\n    }\n\n    //endregion\n\n    estimateTotalPages(config) {\n        const\n            me             = this,\n            { exportMeta } = me,\n            {\n                client,\n                headerTpl,\n                footerTpl,\n                alignRows,\n                rowsRange,\n                repeatHeader,\n                enableDirectRendering\n            }              = config,\n            {\n                pageWidth,\n                pageHeight,\n                totalWidth\n            }              = exportMeta,\n            scale          = me.getScaleValue(pageWidth, totalWidth);\n\n        // To estimate amount of pages correctly we need to know height of the header/footer on every page\n        let\n            // bodyHeight does not always report correct value, read it from the DOM element instead, we don't care\n            // about forced reflow at this stage\n            totalHeight   = 0 - me.getVirtualScrollerHeight(client) + client.height - client.bodyElement.offsetHeight + client.scrollable.scrollHeight,\n            // We will be scaling content horizontally, need to adjust content height accordingly\n            contentHeight = pageHeight / scale,\n            totalRows     = client.store.count,\n            initialScroll = 0,\n            rowsHeight    = totalHeight,\n            verticalPages;\n\n        if (headerTpl) {\n            contentHeight -= me.measureElement(headerTpl({\n                totalWidth,\n                totalPages  : -1,\n                currentPage : -1\n            }));\n        }\n\n        if (footerTpl) {\n            contentHeight -= me.measureElement(footerTpl({\n                totalWidth,\n                totalPages  : -1,\n                currentPage : -1\n            }));\n        }\n\n        // If we are repeating header on every page we have smaller contentHeight\n        if (repeatHeader) {\n            contentHeight -= client.headerHeight + client.footerHeight;\n            totalHeight -= client.headerHeight + client.footerHeight;\n        }\n\n        if (rowsRange === RowsRange.visible) {\n            const\n                rowManager = client.rowManager,\n                firstRow = rowManager.firstVisibleRow,\n                lastRow  = rowManager.lastVisibleRow;\n\n            // With direct rendering we start rendering from 0, no need to adjust anything\n            if (!enableDirectRendering) {\n                initialScroll = firstRow.top;\n            }\n\n            totalRows = me.getVisibleRowsCount(client);\n\n            if (enableDirectRendering) {\n                totalHeight = client.headerHeight + client.footerHeight + lastRow.bottom - firstRow.top;\n                rowsHeight = lastRow.bottom - firstRow.top;\n            }\n            else {\n                rowsHeight = totalHeight = totalHeight - client.scrollable.scrollHeight + lastRow.bottom - firstRow.top;\n            }\n\n            exportMeta.lastRowIndex = firstRow.dataIndex;\n            exportMeta.finishRowIndex = lastRow.dataIndex;\n        }\n        else {\n            exportMeta.finishRowIndex = client.store.count - 1;\n        }\n\n        // alignRows config specifies if rows should be always fully visible. E.g. if row doesn't fit on the page, it goes\n        // to the top of the next page\n        if (alignRows && !repeatHeader && rowsRange !== RowsRange.visible) {\n            // we need to estimate amount of vertical pages for case when we only put row on the page if it fits\n            // first we need to know how much rows would fit one page, keeping in mind first page also contains header\n            // This estimation is loose, because row height might differ much between pages\n            const\n                rowHeight       = client.rowManager.rowOffsetHeight,\n                rowsOnFirstPage = Math.floor((contentHeight - client.headerHeight) / rowHeight),\n                rowsPerPage     = Math.floor(contentHeight / rowHeight),\n                remainingRows   = totalRows - rowsOnFirstPage;\n\n            verticalPages = 1 + Math.ceil(remainingRows / rowsPerPage);\n        }\n        else {\n            verticalPages = Math.ceil(rowsHeight / contentHeight);\n        }\n\n        Object.assign(exportMeta, {\n            scale,\n            contentHeight,\n            totalRows,\n            totalHeight,\n            verticalPages,\n            initialScroll,\n            horizontalPages : 1,\n            totalPages      : verticalPages\n        });\n    }\n\n    async prepareComponent(config) {\n        await super.prepareComponent(config);\n\n        const\n            me              = this,\n            { exportMeta }  = me,\n            { client }      = config,\n            paperFormat     = PaperFormat[config.paperFormat],\n            isPortrait      = config.orientation === Orientation.portrait,\n            paperWidth      = isPortrait ? paperFormat.width : paperFormat.height,\n            paperHeight     = isPortrait ? paperFormat.height : paperFormat.width,\n            pageWidth       = me.inchToPx(paperWidth),\n            pageHeight      = me.inchToPx(paperHeight),\n            horizontalPages = 1;\n\n        Object.assign(exportMeta, {\n            paperWidth,\n            paperHeight,\n            pageWidth,\n            pageHeight,\n            horizontalPages,\n            currentPage          : 0,\n            verticalPosition     : 0,\n            horizontalPosition   : 0,\n            currentPageTopMargin : 0,\n            lastTop              : 0,\n            lastRowIndex         : 0,\n            processedRows        : new Set()\n        });\n\n        me.estimateTotalPages(config);\n\n        if (!config.enableDirectRendering) {\n            me.adjustRowBuffer(client);\n        }\n    }\n\n    async restoreComponent(config) {\n        await super.restoreComponent(config);\n\n        if (!config.enableDirectRendering) {\n            this.restoreRowBuffer(config.client);\n        }\n    }\n\n    async collectRows(config) {\n        const\n            me                 = this,\n            { exportMeta }     = me,\n            {\n                client,\n                alignRows,\n                repeatHeader\n            }                  = config,\n            {\n                subGrids,\n                currentPageTopMargin,\n                verticalPosition,\n                totalRows,\n                contentHeight\n            }                  = exportMeta,\n            // If we are repeating header we've already took header height into account when setting content height\n            clientHeaderHeight = repeatHeader ? 0 : client.headerHeight,\n            { rowManager }     = client,\n            { rows }           = rowManager,\n            onlyVisibleRows    = config.rowsRange === RowsRange.visible,\n            hasMergeCells      = client.hasActiveFeature('mergeCells');\n\n        let index = onlyVisibleRows\n                ? rows.findIndex(r => r.bottom > client.scrollable.y)\n                : rows.findIndex(r => r.bottom + currentPageTopMargin + clientHeaderHeight > 0),\n            remainingHeight;\n\n        const\n            firstRowIndex     = index,\n            // This is a portion of the row which is not visible, which means it shouldn't affect remaining height\n            // Don't calculate for the first page\n            overflowingHeight = verticalPosition === 0 ? 0 : rows[index].top + currentPageTopMargin + clientHeaderHeight;\n\n        // Calculate remaining height to fill with rows\n        // remainingHeight is height of the page content region to fill. When next row is exported, this heights gets\n        // reduced. Since top rows may be partially visible, it would lead to increasing error and eventually to incorrect\n        // exported rows for the page\n        remainingHeight = contentHeight - overflowingHeight;\n\n        // first exported page container header\n        if (verticalPosition === 0) {\n            remainingHeight -= clientHeaderHeight;\n        }\n\n        // data index of the last collected row\n        let lastDataIndex,\n            offset = 0;\n\n        while (remainingHeight > 0) {\n            const row = rows[index];\n\n            if (alignRows && remainingHeight < row.offsetHeight) {\n                offset = -remainingHeight;\n                remainingHeight = 0;\n            }\n            else {\n                me.collectRow(row);\n\n                remainingHeight -= row.offsetHeight;\n\n                // only mark row as processed if it fitted without overflow\n                if (remainingHeight > 0) {\n                    // We cannot use simple counter here because some rows appear on 2 pages. Need to track unique identifier\n                    exportMeta.processedRows.add(row.dataIndex);\n                }\n\n                lastDataIndex = row.dataIndex;\n\n                // Last row is processed, still need to fill the view\n                if (++index === rows.length && remainingHeight > 0) {\n                    remainingHeight = 0;\n                }\n                else if (onlyVisibleRows && (index - firstRowIndex) === totalRows) {\n                    remainingHeight = 0;\n                }\n            }\n        }\n\n        // Collect merged cells per subgrid\n        if (hasMergeCells) {\n            for (const subGridName in subGrids) {\n                const\n                    subGrid     = subGrids[subGridName],\n                    mergedCells = client.subGrids[subGridName].element.querySelectorAll(`.b-grid-merged-cells`);\n\n                subGrid.mergedCellsHtml = [];\n\n                for (const mergedCell of mergedCells) {\n                    subGrid.mergedCellsHtml.push(mergedCell.outerHTML);\n                }\n            }\n        }\n\n        const lastRow = rows[index - 1];\n\n        if (lastRow) {\n            // Calculate exact grid height according to the last exported row\n            exportMeta.exactGridHeight = lastRow.bottom + client.footerContainer.offsetHeight + client.headerContainer.offsetHeight;\n        }\n\n        await me.onRowsCollected(rows.slice(firstRowIndex, index), config);\n\n        // No scrolling required if we are only exporting currently visible rows\n        if (onlyVisibleRows) {\n            exportMeta.scrollableTopMargin = client.scrollable.y;\n        }\n        else {\n            // With variable row height row manager might relayout rows to fix position, moving them up or down.\n            const detacher = rowManager.ion({ offsetRows : ({ offset : value }) => offset += value });\n\n            await me.scrollRowIntoView(client, lastDataIndex + 1);\n\n            detacher();\n        }\n\n        return offset;\n    }\n\n    async renderRows(config) {\n        const\n            me                    = this,\n            { exportMeta }        = me,\n            {\n                client,\n                alignRows,\n                repeatHeader\n            }                     = config,\n            {\n                currentPageTopMargin,\n                verticalPosition,\n                totalRows,\n                contentHeight,\n                lastRowIndex,\n                finishRowIndex,\n                fakeRow\n            }                     = exportMeta,\n            // If we are repeating header we've already took header height into account when setting content height\n            clientHeaderHeight    = repeatHeader ? 0 : client.headerHeight,\n            { store }             = client,\n            hasMergeCells         = client.hasActiveFeature('mergeCells'),\n            onlyVisibleRows       = config.rowsRange === RowsRange.visible;\n\n        let index       = lastRowIndex,\n            { lastTop } = exportMeta,\n            remainingHeight;\n\n        const\n            firstRowIndex     = index,\n            // This is a portion of the row which is not visible, which means it shouldn't affect remaining height\n            // Don't calculate for the first page\n            overflowingHeight = verticalPosition === 0 ? 0 : lastTop + currentPageTopMargin + clientHeaderHeight,\n            rows              = [];\n\n        // Calculate remaining height to fill with rows\n        // remainingHeight is height of the page content region to fill. When next row is exported, this heights gets\n        // reduced. Since top rows may be partially visible, it would lead to increasing error and eventually to incorrect\n        // exported rows for the page\n        remainingHeight = contentHeight - overflowingHeight;\n\n        // first exported page container header\n        if (verticalPosition === 0) {\n            remainingHeight -= clientHeaderHeight;\n        }\n\n        // data index of the last collected row\n        let lastDataIndex,\n            nextPageTop,\n            offset = 0;\n\n        while (remainingHeight > 0) {\n            fakeRow.render(index, store.getAt(index), true, false, true);\n\n            if (alignRows && remainingHeight < fakeRow.offsetHeight) {\n                offset = -remainingHeight;\n                remainingHeight = 0;\n            }\n            else {\n                nextPageTop = lastTop;\n                lastDataIndex = index;\n\n                lastTop = fakeRow.translate(lastTop);\n                remainingHeight -= fakeRow.offsetHeight;\n\n                me.collectRow(fakeRow);\n\n                // Push an object with data required to build merged cell\n                rows.push({\n                    top          : fakeRow.top,\n                    bottom       : fakeRow.bottom,\n                    offsetHeight : fakeRow.offsetHeight,\n                    dataIndex    : fakeRow.dataIndex\n                });\n\n                // only mark row as processed if it fitted without overflow\n                if (remainingHeight > 0) {\n                    // We cannot use simple counter here because some rows appear on 2 pages. Need to track unique identifier\n                    exportMeta.processedRows.add(index);\n                }\n\n                // Last row is processed, still need to fill the view\n                if (index === finishRowIndex) {\n                    remainingHeight = 0;\n                }\n                else if ((++index - firstRowIndex) === totalRows && onlyVisibleRows) {\n                    remainingHeight = 0;\n                }\n            }\n        }\n\n        if (hasMergeCells) {\n            me.renderMergedCells(config, firstRowIndex, index, rows);\n        }\n\n        // Store next to last row index and top position so we could proceed on the next page.\n        // In fact, when we take full control of row rendering we don't even need to do this. It is only required\n        // to be compatible with current exporters. When we get rid of scrolling, we can just start rendering rows\n        // on each page from 0 (adjusted by overflow of the previous row)\n        exportMeta.lastRowIndex = lastDataIndex;\n        exportMeta.lastTop = nextPageTop;\n\n        if (fakeRow) {\n            // Calculate exact grid height according to the last exported row to constrain column lines to the last\n            // row\n            exportMeta.exactGridHeight = fakeRow.bottom + client.footerContainer.offsetHeight + client.headerContainer.offsetHeight;\n        }\n\n        await me.onRowsCollected(rows, config);\n\n        return offset;\n    }\n\n    async buildPage(config) {\n        const\n            me             = this,\n            { exportMeta } = me,\n            {\n                client,\n                headerTpl,\n                footerTpl,\n                enableDirectRendering\n            }              = config,\n            {\n                totalWidth,\n                totalPages,\n                currentPage,\n                subGrids\n            }              = exportMeta;\n\n        // Rows are stored in shared state object, need to clean it before exporting next page\n        Object.values(subGrids).forEach(subGrid => subGrid.rows = []);\n\n        // With variable row height total height might change after scroll, update it\n        // to show content completely on the last page\n        if (config.rowsRange === RowsRange.all) {\n            exportMeta.totalHeight = client.headerHeight + client.footerHeight + client.scrollable.scrollHeight;\n\n            if (!enableDirectRendering) {\n                exportMeta.totalHeight -= me.getVirtualScrollerHeight(client);\n            }\n        }\n\n        let header, footer, offset;\n\n        // Measure header and footer height\n        if (headerTpl) {\n            header = me.prepareHTML(headerTpl({\n                totalWidth,\n                totalPages,\n                currentPage\n            }));\n        }\n\n        if (footerTpl) {\n            footer = me.prepareHTML(footerTpl({\n                totalWidth,\n                totalPages,\n                currentPage\n            }));\n        }\n\n        if (enableDirectRendering) {\n            offset = await me.renderRows(config);\n        }\n        else {\n            offset = await me.collectRows(config);\n        }\n\n        const html = me.buildPageHtml(config);\n\n        return { html, header, footer, offset };\n    }\n\n    async onRowsCollected() {}\n\n    buildPageHtml() {\n        const\n            me           = this,\n            { subGrids } = me.exportMeta;\n\n        // Now when rows are collected, we need to add them to exported grid\n        let html = me.prepareExportElement();\n\n        Object.values(subGrids).forEach(({ placeHolder, rows, mergedCellsHtml }) => {\n            const placeHolderText = placeHolder.outerHTML;\n\n            let contentHtml = rows.reduce((result, row) => {\n                result += row[0];\n\n                return result;\n            }, '');\n\n            if (mergedCellsHtml?.length) {\n                contentHtml += `<div class=\"b-grid-merged-cells-container\">${mergedCellsHtml.join('')}</div>`;\n            }\n\n            html = html.replace(placeHolderText, contentHtml);\n        });\n\n        return html;\n    }\n}\n\n// HACK: terser/obfuscator doesn't yet support async generators, when processing code it converts async generator to regular async\n// function.\nMultiPageVerticalExporter.prototype.pagesExtractor = async function * pagesExtractor(config) {\n    const\n        me = this,\n        {\n            exportMeta,\n            stylesheets\n        }  = me,\n        {\n            totalWidth,\n            paperWidth,\n            paperHeight,\n            contentHeight,\n            scale,\n            initialScroll\n        }  = exportMeta;\n\n    let\n        { totalPages } = exportMeta,\n        currentPage;\n\n    while ((currentPage = exportMeta.currentPage) < totalPages) {\n        me.trigger('exportStep', {\n            text     : me.L(MultiPageVerticalExporter.exportingPageText, { currentPage, totalPages }),\n            progress : Math.round(((currentPage + 1) / totalPages) * 90)\n        });\n\n        const { html, header, footer, offset } = await me.buildPage(config);\n\n        // TotalHeight might change in case of variable row heights\n        // Move exported content in the visible frame\n        const styles = [\n            ...stylesheets,\n            `\n                <style>\n                    #${config.client.id} {\n                        width: ${totalWidth}px !important;\n                    }\n                    \n                    .b-export .b-export-content {\n                        transform: scale(${scale});\n                        transform-origin: top left;\n                        height: auto;\n                    }\n                </style>\n            `\n        ];\n\n        if (config.repeatHeader) {\n            const gridHeight = exportMeta.exactGridHeight ? `${exportMeta.exactGridHeight + exportMeta.currentPageTopMargin}px` : '100%';\n\n            styles.push(\n                `\n                <style>\n                    #${config.client.id} {\n                        height: ${gridHeight} !important;\n                    }\n                    \n                    .b-export .b-export-content {\n                        height: ${100 / scale}%;\n                    }\n                    \n                    .b-export-body {\n                        height: 100%;\n                        display: flex;\n                    }\n                \n                    .b-export-viewport {\n                        height: 100%;\n                    }\n                    \n                    .b-grid-vertical-scroller {\n                        margin-top: ${exportMeta.currentPageTopMargin - initialScroll}px;\n                    }\n                </style>\n                `\n            );\n        }\n        else {\n            const gridHeight = exportMeta.exactGridHeight || (contentHeight - exportMeta.currentPageTopMargin);\n\n            styles.push(\n                `\n                <style>\n                    #${config.client.id} {\n                        height: ${gridHeight}px !important;\n                    }\n                    \n                    .b-export-body {\n                        overflow: hidden;\n                    }\n                    \n                    .b-export .b-export-content {\n                        height: ${100 / scale}%;\n                    }\n                    \n                    .b-export-body .b-export-viewport {\n                        margin-top: ${exportMeta.currentPageTopMargin}px;\n                    }\n                    \n                    .b-grid-vertical-scroller {\n                        margin-top: -${initialScroll}px;\n                    }\n                </style>\n                `\n            );\n        }\n\n        // when aligning rows, offset gets accumulated, so we need to take it into account\n        exportMeta.currentPageTopMargin -= contentHeight + offset;\n\n        await me.stateNextPage(config);\n\n        ({ totalPages } = exportMeta);\n\n        yield {\n            html : me.pageTpl({\n                html,\n                header,\n                footer,\n                styles,\n                paperWidth,\n                paperHeight\n            })\n        };\n    }\n};\n", "import BrowserHelper from '../../../../Core/helper/BrowserHelper.js';\nimport Exporter from './Exporter.js';\nimport { Orientation, PaperFormat, RowsRange } from '../Utils.js';\n\n/**\n * @module Grid/feature/export/exporter/SinglePageExporter\n */\n\n/**\n * A single page exporter. Used by the {@link Grid.feature.export.PdfExport} feature to export to single page. Content\n * will be scaled in both directions to fit the page.\n *\n * You do not need to use this class directly.\n *\n * ### Extending exporter\n *\n * ```javascript\n * class MySinglePageExporter extends SinglePageExporter {\n *     // type is required for exporter\n *     static get type() {\n *         return 'mysinglepageexporter';\n *     }\n *\n *     get stylesheets() {\n *         const stylesheets = super.stylesheets;\n *\n *         stylesheets.forEach(styleNodeOrLinkTag => doSmth(styleNodeOrLinkTag))\n *\n *         return stylesheets;\n *     }\n * }\n *\n * const grid = new Grid({\n *     features : {\n *         pdfExport : {\n *             // this export feature is configured with only one exporter\n *             exporters : [MySinglePageExporter]\n *         }\n *     }\n * });\n *\n * // run export with the new exporter\n * grid.features.pdfExport.export({ exporter : 'mysinglepageexporter' });\n * ```\n *\n * @classType singlepage\n * @feature\n * @extends Grid/feature/export/exporter/Exporter\n */\nexport default class SinglePageExporter extends Exporter {\n\n    static get $name() {\n        return 'SinglePageExporter';\n    }\n\n    static get type() {\n        return 'singlepage';\n    }\n\n    static get title() {\n        // In case locale is missing exporter is still distinguishable\n        return this.localize('L{singlepage}');\n    }\n\n    static get defaultConfig() {\n        return {\n            /**\n             * Set to true to center content horizontally on the page\n             * @config {Boolean}\n             */\n            centerContentHorizontally : false\n        };\n    }\n\n    async prepareComponent(config) {\n        await super.prepareComponent(config);\n\n        Object.assign(this.exportMeta, {\n            verticalPages      : 1,\n            horizontalPages    : 1,\n            totalPages         : 1,\n            currentPage        : 0,\n            verticalPosition   : 0,\n            horizontalPosition : 0\n        });\n    }\n\n    async onRowsCollected() {}\n\n    positionRows(rows, config) {\n        if (config.enableDirectRendering) {\n            return rows.map(r => r[0]);\n        }\n        else {\n            let currentTop = 0;\n\n            // In case of variable row height row vertical position is not guaranteed to increase\n            // monotonously. Position row manually instead\n            return rows.map(([html, , height]) => {\n                const result = html.replace(/translate\\(\\d+px, \\d+px\\)/, `translate(0px, ${currentTop}px)`);\n\n                currentTop += height;\n\n                return result;\n            });\n        }\n    }\n\n    async collectRows(config) {\n        const\n            me                    = this,\n            { client }            = config,\n            { rowManager, store } = client,\n            hasMergeCells         = client.hasActiveFeature('mergeCells'),\n            { subGrids }          = me.exportMeta,\n            totalRows             = config.rowsRange === RowsRange.visible && store.count\n                // visibleRowCount is a projection of how much rows will fit the view, which should be\n                // maximum amount of exported rows. and there can be less\n                ? me.getVisibleRowsCount(client)\n                : store.count;\n\n        let { totalHeight } = me.exportMeta,\n            processedRows   = 0,\n            lastDataIndex   = -1;\n\n        if (rowManager.rows.length > 0) {\n            if (config.rowsRange === RowsRange.visible) {\n                lastDataIndex = rowManager.firstVisibleRow.dataIndex - 1;\n            }\n\n            if (hasMergeCells) {\n                for (const subGrid of Object.values(subGrids)) {\n                    subGrid.mergedCellsHtml = [];\n                }\n            }\n\n            // Collecting rows\n            while (processedRows < totalRows) {\n                const\n                    rows    = rowManager.rows,\n                    lastRow = rows[rows.length - 1],\n                    lastProcessedRowIndex = processedRows;\n\n                rows.forEach(row => {\n                    // When we are scrolling rows will be duplicated even with disabled buffers (e.g. when we are trying to\n                    // scroll last record into view). So we store last processed row dataIndex (which is always growing\n                    // sequence) and filter all rows with lower/same dataIndex\n                    if (row.dataIndex > lastDataIndex && processedRows < totalRows) {\n                        ++processedRows;\n                        totalHeight += row.offsetHeight;\n                        me.collectRow(row);\n                    }\n                });\n\n                // Collect merged cells per subgrid\n                if (hasMergeCells) {\n                    for (const subGridName in subGrids) {\n                        const\n                            subGrid     = subGrids[subGridName],\n                            mergedCells = client.subGrids[subGridName].element.querySelectorAll(`.b-grid-merged-cells`);\n\n                        for (const mergedCell of mergedCells) {\n                            subGrid.mergedCellsHtml.push(mergedCell.outerHTML);\n                        }\n                    }\n                }\n\n                // Calculate new rows processed in this iteration e.g. to collect events\n                const\n                    firstNewRowIndex = rows.findIndex(r => r.dataIndex === lastDataIndex + 1),\n                    lastNewRowIndex  = firstNewRowIndex + (processedRows - lastProcessedRowIndex);\n\n                await me.onRowsCollected(rows.slice(firstNewRowIndex, lastNewRowIndex), config);\n\n                if (processedRows < totalRows) {\n                    lastDataIndex = lastRow.dataIndex;\n                    await me.scrollRowIntoView(client, lastDataIndex + 1);\n                }\n            }\n        }\n\n        return totalHeight;\n    }\n\n    async renderRows(config) {\n        const\n            me                    = this,\n            { client, rowsRange } = config,\n            { rowManager, store } = client,\n            hasMergeCells         = client.hasActiveFeature('mergeCells'),\n            onlyVisibleRows       = rowsRange === RowsRange.visible;\n\n        let { totalHeight } = me.exportMeta;\n\n        if (store.count) {\n            const\n                { fakeRow }         = me.exportMeta,\n                { firstVisibleRow } = rowManager,\n                fromIndex           = onlyVisibleRows ? firstVisibleRow.dataIndex : 0,\n                toIndex             = onlyVisibleRows ? rowManager.lastVisibleRow.dataIndex : store.count - 1,\n                rows                = [];\n\n            let top = 0;\n\n            // Fake row might not have cells if there are no columns\n            if (fakeRow.cells.length) {\n                for (let i = fromIndex; i <= toIndex; i++) {\n                    fakeRow.render(i, store.getAt(i), true, false, true);\n\n                    top = fakeRow.translate(top);\n\n                    me.collectRow(fakeRow);\n\n                    // Push an object with data required to build merged cell\n                    rows.push({\n                        top          : fakeRow.top,\n                        bottom       : fakeRow.bottom,\n                        offsetHeight : fakeRow.offsetHeight,\n                        dataIndex    : fakeRow.dataIndex\n                    });\n                }\n\n                await me.onRowsCollected(rows, config);\n            }\n\n            totalHeight += top;\n\n            if (hasMergeCells) {\n                me.renderMergedCells(config, fromIndex, toIndex, rows);\n            }\n        }\n\n        return totalHeight;\n    }\n\n    buildPageHtml(config) {\n        const\n            me           = this,\n            { subGrids } = me.exportMeta;\n\n        // Now when rows are collected, we need to add them to exported grid\n        let html = me.prepareExportElement();\n\n        Object.values(subGrids).forEach(({ placeHolder, rows, mergedCellsHtml }) => {\n            const placeHolderText = placeHolder.outerHTML;\n            let contentHtml =  me.positionRows(rows, config).join('');\n\n            if (mergedCellsHtml?.length) {\n                contentHtml += `<div class=\"b-grid-merged-cells-container\">${mergedCellsHtml.join('')}</div>`;\n            }\n\n            html = html.replace(placeHolderText, contentHtml);\n        });\n\n        return html;\n    }\n}\n\n// HACK: terser/obfuscator doesn't yet support async generators, when processing code it converts async generator to regular async\n// function.\nSinglePageExporter.prototype.pagesExtractor = async function * pagesExtractor(config) {\n    // When we prepared grid we stretched it horizontally, now we need to gather all rows\n    // There are two ways:\n    // 1. set component height to scrollable.scrollHeight value to render all rows at once (maybe a bit more complex\n    // if rows have variable height)\n    // 2. iterate over rows, scrolling new portion into view once in a while\n    // #1 sounds simpler, but that might require too much rendering, let's scroll rows instead\n\n    const\n        me             = this,\n        { client }     = config,\n        { totalWidth } = me.exportMeta,\n        styles         = me.stylesheets,\n        portrait       = config.orientation === Orientation.portrait,\n        paperFormat    = PaperFormat[config.paperFormat],\n        paperWidth     = portrait ? paperFormat.width : paperFormat.height,\n        paperHeight    = portrait ? paperFormat.height : paperFormat.width;\n\n    let totalHeight, header, footer;\n\n    if (config.enableDirectRendering) {\n        totalHeight = await me.renderRows(config);\n\n        totalHeight += client.headerHeight + client.footerHeight;\n    }\n    else {\n        totalHeight = await me.collectRows(config);\n\n        totalHeight += client.height - client.bodyHeight;\n    }\n\n    const html = me.buildPageHtml(config);\n\n    const totalClientHeight = totalHeight;\n\n    // Measure header and footer height\n    if (config.headerTpl) {\n        header = me.prepareHTML(config.headerTpl({ totalWidth }));\n        const height = me.measureElement(header);\n        totalHeight += height;\n    }\n\n    if (config.footerTpl) {\n        footer = me.prepareHTML(config.footerTpl({ totalWidth }));\n        const height = me.measureElement(footer);\n        totalHeight += height;\n    }\n\n    const\n        widthScale  = Math.min(1, me.getScaleValue(me.inchToPx(paperWidth), totalWidth)),\n        heightScale = Math.min(1, me.getScaleValue(me.inchToPx(paperHeight), totalHeight)),\n        scale       = Math.min(widthScale, heightScale);\n\n    // Now add style to stretch grid vertically\n    styles.push(\n        `<style>\n                #${client.id} {\n                    height: ${totalClientHeight}px !important;\n                    width: ${totalWidth}px !important;\n                }\n                \n                .b-export-content {\n                    ${me.centerContentHorizontally ? 'left: 50%;' : ''}\n                    transform: scale(${scale}) ${me.centerContentHorizontally ? 'translateX(-50%)' : ''};\n                    transform-origin: top left;\n                    height: ${scale === 1 ? 'inherit' : 'auto !important'};\n                }\n            </style>`\n    );\n\n    if (BrowserHelper.isIE11) {\n        styles.push(\n        `<style>\n                .b-export-body {\n                   min-height: ${totalClientHeight}px !important;\n                }\n         </style>`\n        );\n    }\n\n    // This is a single page exporter so we only yield one page\n    yield {\n        html : me.pageTpl({\n            html,\n            header,\n            footer,\n            styles,\n            paperWidth,\n            paperHeight\n        })\n    };\n};\n", "import AjaxHelper from '../../../Core/helper/AjaxHelper.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\nimport VersionHelper from '../../../Core/helper/VersionHelper.js';\nimport InstancePlugin from '../../../Core/mixin/InstancePlugin.js';\nimport MultiPageExporter from './exporter/MultiPageExporter.js';\nimport MultiPageVerticalExporter from './exporter/MultiPageVerticalExporter.js';\nimport SinglePageExporter from './exporter/SinglePageExporter.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport ExportDialog from '../../view/export/ExportDialog.js';\nimport GridFeatureManager from '../GridFeatureManager.js';\nimport Toast from '../../../Core/widget/Toast.js';\nimport { FileMIMEType } from './Utils.js';\n\n/**\n * @module Grid/feature/export/PdfExport\n */\n\n/**\n * Generates PDF/PNG files from the Grid component.\n *\n * **NOTE:** Server side is required to make export work!\n *\n * Check out PDF Export Server documentation and installation steps [here](https://github.com/bryntum/pdf-export-server#pdf-export-server)\n *\n * When your server is up and running, it listens to requests. The Export feature sends a request to the specified URL\n * with the HTML fragments. The server generates a PDF (or PNG) file and returns a download link (or binary, depending\n * on {@link #config-sendAsBinary} config). Then the Export feature opens the link in a new tab and the file is\n * automatically downloaded by your browser. This is configurable, see {@link #config-openAfterExport} config.\n *\n * The {@link #config-exportServer} URL must be configured. The URL can be localhost if you start the server locally,\n * or your remote server address.\n *\n * ## Usage\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         pdfExport : {\n *             exportServer : 'http://localhost:8080' // Required\n *         }\n *     }\n * })\n *\n * // Opens popup allowing to customize export settings\n * grid.features.pdfExport.showExportDialog();\n *\n * // Simple export\n * grid.features.pdfExport.export({\n *     // Required, set list of column ids to export\n *     columns : grid.columns.map(c => c.id)\n * }).then(result => {\n *     // Response instance and response content in JSON\n *     let { response } = result;\n * });\n * ```\n *\n * ## Exporters\n *\n * There are three exporters available by default: `singlepage`, `multipage` and `multipagevertical`:\n *  * `singlepage` -  generates single page with content scaled to fit the provided {@link #config-paperFormat}\n *  * `multipage` - generates as many pages as required to fit all requested content, unscaled\n *  * `multipagevertical` - a combination of two above: it scales content horizontally to fit into page width and then\n *  puts overflowing content on vertical pages. Like a scroll.\n *\n * ## Loading resources\n *\n * If you face a problem with loading resources when exporting, the cause might be that the application and the export server are hosted on different servers.\n * This is due to [Cross-Origin Resource Sharing](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) (CORS). There are 2 options how to handle this:\n * - Allow cross-origin requests from the server where your export is hosted to the server where your application is hosted;\n * - Copy all resources keeping the folder hierarchy from the server where your application is hosted to the server where your export is hosted\n * and setup paths using {@link #config-translateURLsToAbsolute} config and configure the export server to give access to the path:\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         pdfExport : {\n *             exportServer : 'http://localhost:8080',\n *             // '/resources' is hardcoded in WebServer implementation\n *             translateURLsToAbsolute : 'http://localhost:8080/resources'\n *         }\n *     }\n * })\n * ```\n *\n * ```javascript\n * // Following path would be served by this address: http://localhost:8080/resources/\n * node ./src/server.js -h 8080 -r web/application/styles\n * ```\n *\n * where `web/application/styles` is a physical root location of the copied resources, for example:\n *\n * <img src=\"Grid/export-server-resources.png\" style=\"max-width : 500px\" alt=\"Export server structure with copied resources\" />\n *\n * @extends Core/mixin/InstancePlugin\n *\n * @demo Grid/export\n * @classtype pdfExport\n * @feature\n */\nexport default class PdfExport extends InstancePlugin {\n    static get $name() {\n        return 'PdfExport';\n    }\n\n    static get configurable() {\n        return {\n            dialogClass  : ExportDialog,\n            /**\n             * URL of the print server.\n             * @config {String}\n             */\n            exportServer : undefined,\n\n            /**\n             * Returns the instantiated export dialog widget as configured by {@link #config-exportDialog}\n             * @member {Grid.view.export.ExportDialog} exportDialog\n             */\n            /**\n             * A config object to apply to the {@link Grid.view.export.ExportDialog} widget.\n             * @config {ExportDialogConfig}\n             */\n            exportDialog : {\n                value : true,\n\n                $config : ['lazy']\n            },\n\n            /**\n             * Name of the exported file.\n             * @config {String}\n             */\n            fileName : null,\n\n            /**\n             * Format of the exported file, either `pdf` or `png`.\n             * @config {'pdf'|'png'}\n             * @default\n             * @category Export file config\n             */\n            fileFormat : 'pdf',\n\n            /**\n             * Export server will navigate to this url first and then will change page content to whatever client sent.\n             * This option is useful with react dev server, which uses a strict CORS policy.\n             * @config {String}\n             */\n            clientURL : null,\n\n            /**\n             * Export paper format. Available options are A1...A5, Legal, Letter.\n             * @config {'A1'|'A2'|'A3'|'A4'|'A5'|'Legal'|'Letter'}\n             * @default\n             * @category Export file config\n             */\n            paperFormat : 'A4',\n\n            /**\n             * Orientation. Options are `portrait` and `landscape`.\n             * @config {'portrait'|'landscape'}\n             * @default\n             * @category Export file config\n             */\n            orientation : 'portrait',\n\n            /**\n             * Specifies which rows to export. `all` for complete set of rows, `visible` for only rows currently visible.\n             * @config {'all'|'visible'}\n             * @category Export file config\n             * @default\n             */\n            rowsRange : 'all',\n\n            /**\n             * Set to true to align row top to the page top on every exported page. Only applied to multipage export.\n             * @config {Boolean}\n             * @default\n             */\n            alignRows : false,\n\n            /**\n             * Set to true to show column headers on every page. This will also set {@link #config-alignRows} to true.\n             * Only applies to MultiPageVertical exporter.\n             * @config {Boolean}\n             * @default\n             */\n            repeatHeader : false,\n\n            /**\n             * By default, subGrid width is changed to fit all exported columns. To keep certain subGrid size specify it\n             * in the following form:\n             * ```javascript\n             * keepRegionSizes : {\n             *     locked : true\n             * }\n             * ```\n             * @config {Object<String,Boolean>}\n             * @default\n             */\n            keepRegionSizes : null,\n\n            /**\n             * When exporting large views (hundreds of pages) stringified HTML may exceed browser or server request\n             * length limit. This config allows to specify how many pages to send to server in one request.\n             * @config {Number}\n             * @default\n             * @private\n             */\n            pagesPerRequest : 0,\n\n            /**\n             * Config for exporter.\n             * @config {Object}\n             * @private\n             */\n            exporterConfig : null,\n\n            /**\n             * Type of the exporter to use. Should be one of the configured {@link #config-exporters}\n             * @config {String}\n             * @default\n             */\n            exporterType : 'singlepage',\n\n            /**\n             * List of exporter classes to use in export feature\n             * @config {Grid.feature.export.exporter.Exporter[]}\n             * @default\n             */\n            exporters : [SinglePageExporter, MultiPageExporter, MultiPageVerticalExporter],\n\n            /**\n             * `True` to replace all linked CSS files URLs to absolute before passing HTML to the server.\n             * When passing a string the current origin of the CSS files URLS will be replaced by the passed origin.\n             *\n             * For example: css files pointing to /app.css will be translated from current origin to {translateURLsToAbsolute}/app.css\n             * @config {Boolean|String}\n             * @default\n             */\n            translateURLsToAbsolute : true,\n\n            /**\n             * When true links are converted to absolute by combining current window location (with replaced origin) with\n             * resource link.\n             * When false links are converted by combining new origin with resource link (for angular)\n             * @config {Boolean}\n             * @default\n             */\n            keepPathName : true,\n\n            /**\n             * When true, page will attempt to download generated file.\n             * @config {Boolean}\n             * @default\n             */\n            openAfterExport : true,\n\n            /**\n             * Set to true to receive binary file from the server instead of download link.\n             * @config {Boolean}\n             * @default\n             */\n            sendAsBinary : false,\n\n            /**\n             * False to open in the current tab, true - in a new tab\n             * @config {Boolean}\n             * @default\n             */\n            openInNewTab : false,\n\n            /**\n             * A template function used to generate a page header. It is passed an object with currentPage and `totalPages properties.\n             *\n             * ```javascript\n             * let grid = new Grid({\n             *     appendTo   : 'container',\n             *     features : {\n             *         pdfExport : {\n             *             exportServer : 'http://localhost:8080/',\n             *             headerTpl : ({ currentPage, totalPages }) => `\n             *                 <div class=\"demo-export-header\">\n             *                     <img src=\"coolcorp-logo.png\"/>\n             *                     <dl>\n             *                         <dt>Date: ${DateHelper.format(new Date(), 'll LT')}</dt>\n             *                         <dd>${totalPages ? `Page: ${currentPage + 1}/${totalPages}` : ''}</dd>\n             *                     </dl>\n             *                 </div>`\n             *          }\n             *     }\n             * });\n             * ```\n             * @config {Function}\n             */\n            headerTpl : null,\n\n            /**\n             * A template function used to generate a page footer. It is passed an object with currentPage and `totalPages properties.\n             *\n             * ```javascript\n             * let grid = new Grid({\n             *      appendTo   : 'container',\n             *      features : {\n             *          pdfExport : {\n             *              exportServer : 'http://localhost:8080/',\n             *              footerTpl    : () => '<div class=\"demo-export-footer\"><h3> 2020 CoolCorp Inc</h3></div>'\n             *          }\n             *      }\n             * });\n             * ```\n             * @config {Function}\n             */\n            footerTpl : null,\n\n            /**\n             * An object containing the Fetch options to pass to the export server request. Use this to control if\n             * credentials are sent and other options, read more at\n             * [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch).\n             * @config {FetchOptions}\n             */\n            fetchOptions : null,\n\n            /**\n             * A message to be shown when Export feature is performing export.\n             * @config {String}\n             * @default \"Generating pages...\"\n             */\n            exportMask : 'L{Generating pages}',\n\n            /**\n             * A message to be shown when export is almost done.\n             * @config {String}\n             * @default \"Waiting for response from server...\"\n             */\n            exportProgressMask : 'L{Waiting for response from server}',\n\n            /**\n             * Set to `false` to not show Toast message on export error.\n             * @config {Boolean}\n             * @default\n             */\n            showErrorToast : true,\n\n            localizableProperties : ['exportMask', 'exportProgressMask'],\n\n            /**\n             * This method accepts all stylesheets (link and style tags) which are supposed to be put on the page. Use\n             * this hook method to filter or modify them.\n             *\n             * ```javascript\n             * new Grid({\n             *     features: {\n             *         pdfExport: {\n             *             // filter out inline styles and bootstrap.css\n             *             filterStyles: styles => styles.filter(item => !/(link|bootstrap.css)/.test(item))\n             *         }\n             *     }\n             * });\n             * ```\n             * @param {String[]} styles\n             * @returns {String[]} List of stylesheets to put on the exported page\n             */\n            filterStyles : styles => styles,\n\n            /**\n             * Enables direct rendering of the component content which significantly improves performance. To enable\n             * old export mode set this flag to false.\n             * @config {Boolean}\n             * @default\n             */\n            enableDirectRendering : true\n        };\n    }\n\n    updateEnableDirectRendering(value) {\n        if (!value) {\n            VersionHelper.deprecate('Grid', '6.0.0', 'Indirect rendering is deprecated');\n        }\n    }\n\n    doDestroy() {\n        this.exportDialog?.destroy();\n\n        this.exportersMap.forEach(exporter => exporter.destroy());\n\n        super.doDestroy();\n    }\n\n    /**\n     * When export is started from GUI ({@link Grid.view.export.ExportDialog}), export promise can be accessed via\n     * this property.\n     * @property {Promise|null}\n     */\n    get currentExportPromise() {\n        return this._currentExportPromise;\n    }\n\n    set currentExportPromise(value) {\n        this._currentExportPromise = value;\n    }\n\n    get exportersMap() {\n        return this._exportersMap || (this._exportersMap = new Map());\n    }\n\n    getExporter(config = {}) {\n        const\n            me               = this,\n            { exportersMap } = me,\n            { type }         = config;\n\n        let exporter;\n\n        if (exportersMap.has(type)) {\n            exporter = exportersMap.get(type);\n\n            Object.assign(exporter, config);\n        }\n        else {\n            const exporterClass = this.exporters.find(cls => cls.type === type);\n\n            if (!exporterClass) {\n                throw new Error(`Exporter type ${type} is not found. Make sure you've configured it`);\n            }\n\n            config = ObjectHelper.clone(config);\n            delete config.type;\n\n            exporter = new exporterClass(config);\n\n            exporter.relayAll(me);\n\n            exportersMap.set(type, exporter);\n        }\n\n        return exporter;\n    }\n\n    buildExportConfig(config = {}) {\n        const\n            me = this,\n            {\n                client,\n                exportServer,\n                clientURL,\n                fileFormat,\n                fileName,\n                paperFormat,\n                rowsRange,\n                alignRows,\n                repeatHeader,\n                keepRegionSizes,\n                orientation,\n                translateURLsToAbsolute,\n                keepPathName,\n                sendAsBinary,\n                headerTpl,\n                footerTpl,\n                filterStyles,\n                enableDirectRendering\n            }  = me;\n\n        if (!config.columns) {\n            config.columns = client.columns.visibleColumns.filter(column => column.exportable).map(column => column.id);\n        }\n\n        const result = ObjectHelper.assign({\n            client,\n            exportServer,\n            clientURL,\n            fileFormat,\n            paperFormat,\n            rowsRange,\n            alignRows,\n            repeatHeader,\n            keepRegionSizes,\n            orientation,\n            translateURLsToAbsolute,\n            keepPathName,\n            sendAsBinary,\n            headerTpl,\n            footerTpl,\n            enableDirectRendering,\n            exporterType : me.exporterType,\n            fileName     : fileName || client.$$name\n        }, config);\n\n        // slice columns array to not modify it during export\n        result.columns = config.columns.slice();\n\n        // Only vertical exporter is supported\n        if (result.exporterType !== 'multipagevertical') {\n            result.repeatHeader = false;\n        }\n\n        // Align rows by default\n        if (!('alignRows' in config) && config.repeatHeader) {\n            result.alignRows = true;\n        }\n\n        result.exporterConfig = ObjectHelper.assign({\n            type                    : result.exporterType,\n            translateURLsToAbsolute : result.translateURLsToAbsolute,\n            keepPathName            : result.keepPathName,\n            filterStyles\n        }, result.exporterConfig || {});\n\n        delete result.exporterType;\n        delete result.translateURLsToAbsolute;\n        delete result.keepPathName;\n\n        return result;\n    }\n\n    /**\n     * Starts the export process. Accepts a config object which overrides any default configs.\n     * **NOTE**. Component should not be interacted with when export is in progress\n     *\n     * @param {Object} config\n     * @param {String[]} config.columns (required) List of column ids to export. E.g.\n     *\n     * ```javascript\n     * grid.features.pdfExport.export({ columns : grid.columns.map(c => c.id) })\n     * ```\n     * @returns {Promise} Object of the following structure\n     * ```\n     * {\n     *     response // Response instance\n     * }\n     * ```\n     */\n    async export(config = {}) {\n        const\n            me = this,\n            {\n                client,\n                pagesPerRequest\n            }  = me;\n\n        config = me.buildExportConfig(config);\n\n        let result;\n\n        /**\n         * Fires on the owning Grid before export started. Return `false` to cancel the export.\n         * @event beforePdfExport\n         * @preventable\n         * @on-owner\n         * @param {Object} config Export config\n         */\n        if (client.trigger('beforePdfExport', { config }) !== false) {\n            client.isExporting = true;\n\n            // This mask should be always visible to protect grid from changes even if the mask message is not visible\n            // due to the export dialog which is rendered above the grid's mask. The dialog has its own mask which shares the export message.\n            client.mask(me.exportMask);\n\n            try {\n                const exporter = me.getExporter(config.exporterConfig);\n\n                if (pagesPerRequest === 0) {\n                    const pages = await exporter.export(config);\n\n                    if (me.isDestroying) {\n                        return;\n                    }\n\n                    // Hide dialog\n                    me.exportDialog?.close();\n\n                    // We can unmask early\n                    client.unmask();\n\n                    /**\n                     * Fires when export progress changes\n                     * @event exportStep\n                     * @param {Number} progress Current progress, 0-100\n                     * @param {String} text Optional text to show\n                     */\n                    me.trigger('exportStep', { progress : 90, text : me.exportProgressMask, contentGenerated : true });\n\n                    const responsePromise = me.receiveExportContent(pages, config);\n\n                    // Show toast message indicating we're waiting for the server response\n                    me.toast = me.showLoadingToast(responsePromise);\n\n                    const response = await responsePromise;\n\n                    result = { response };\n\n                    await me.processExportContent(response, config);\n                }\n            }\n            catch (error) {\n                if (error instanceof Response) {\n                    result = { response : error };\n                }\n                else {\n                    result = { error };\n                }\n\n                throw error;\n            }\n            finally {\n                if (me.toast && !me.toast.isDestroying) {\n                    // Hide would also destroy the toast\n                    me.toast.hide();\n                }\n\n                if (!me.isDestroying) {\n                    // Close dialog on exception\n                    me.exportDialog?.close();\n                    client.unmask();\n\n                    if (me.showErrorToast) {\n                        // Do not show warning if user has cancelled request\n                        if (result.error) {\n                            if (result.error.name !== 'AbortError') {\n                                Toast.show({\n                                    html        : me.L('L{Export failed}'),\n                                    rootElement : me.rootElement\n                                });\n                            }\n                        }\n                        else if (!result.response.ok) {\n                            Toast.show({\n                                html        : me.L('L{Server error}'),\n                                rootElement : me.rootElement\n                            });\n                        }\n                    }\n\n                    /**\n                     * Fires on the owning Grid when export has finished\n                     * @event pdfExport\n                     * @on-owner\n                     * @param {Response} [response] Optional response, if received\n                     * @param {Error} [error] Optional error, if exception occurred\n                     */\n                    client.trigger('pdfExport', result);\n\n                    client.isExporting = false;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Sends request to the export server and returns Response instance. This promise can be cancelled by the user\n     * by clicking on the toast message. When the user clicks on the toast, `abort` method is called on the promise\n     * returned by this method. If you override this method you can implement `abort` method like in the snippet\n     * below to cancel the request.\n     *\n     * ```javascript\n     * class MyPdfExport extends PdfExport {\n     *     receiveExportContent(pages, config) {\n     *         let controller;\n     *\n     *         const promise = new Promise(resolve => {\n     *             controller = new AbortController();\n     *             const signal = controller.signal;\n     *\n     *             fetch(url, { signal })\n     *                 .then(response => resolve(response));\n     *         });\n     *\n     *         // This method will be called when user clicks on the toast message to cancel the request\n     *         promise.abort = () => controller.abort();\n     *\n     *         return promise;\n     *     }\n     * }\n     *\n     * const grid = new Grid({ features: { myPdfExport : {...} } });\n     *\n     * grid.features.myPdfExport.export().catch(e => {\n     *     // In case of aborted request do nothing\n     *     if (e.name !== 'AbortError') {\n     *         // handle other exceptions\n     *     }\n     * });\n     * ```\n     * @param {Object[]} pages Array of exported pages.\n     * @param {String} pages[].html pages HTML of the exported page.\n     * @param {Object} config Export config\n     * @param {String} config.exportServer URL of the export server.\n     * @param {String} config.orientation Page orientation. portrait/landscape.\n     * @param {String} config.paperFormat Paper format as supported by puppeteer. A4/A3/...\n     * @param {String} config.fileFormat File format. PDF/PNG.\n     * @param {String} config.fileName Name to use for the saved file.\n     * @param {String} config.clientURL URL to navigate before export. See {@link #config-clientURL}.\n     * @param {String} config.sendAsBinary Tells server whether to return binary file instead of download link.\n     * @returns {Promise} Returns Response instance\n     */\n    receiveExportContent(pages, config) {\n        return AjaxHelper.fetch(\n            config.exportServer,\n            Object.assign({\n                method      : 'POST',\n                credentials : 'omit',\n                headers     : { 'Content-Type' : 'application/json' },\n                body        : JSON.stringify({\n                    html         : pages,\n                    orientation  : config.orientation,\n                    format       : config.paperFormat,\n                    fileFormat   : config.fileFormat,\n                    fileName     : config.fileName,\n                    clientURL    : config.clientURL,\n                    sendAsBinary : config.sendAsBinary\n                })\n            }, this.fetchOptions)\n        );\n    }\n\n    /**\n     * Handles output of the {@link #function-receiveExportContent}. Server response can be of two different types depending\n     * on {@link #config-sendAsBinary} config:\n     * - `application/json` In this case JSON response contains url of the file to download\n     * - `application/octet-stream` In this case response contains stream of file binary data\n     *\n     * If {@link #config-openAfterExport} is true, this method will try to download content.\n     * @param {Response} response\n     * @param {Object} config Export config\n     * @param {String} config.exportServer URL of the export server.\n     * @param {String} config.orientation Page orientation. portrait/landscape.\n     * @param {String} config.paperFormat Paper format as supported by puppeteer. A4/A3/...\n     * @param {String} config.fileFormat File format. PDF/PNG.\n     * @param {String} config.fileName Name to use for the saved file.\n     * @param {String} config.clientURL URL to navigate before export. See {@link #config-clientURL}.\n     * @param {String} config.sendAsBinary Tells server whether to return binary file instead of download link. See {@link #config-sendAsBinary}\n     */\n    async processExportContent(response, config) {\n        const me = this;\n\n        if (response.ok && me.openAfterExport) {\n            // Clone Response to not block response stream\n            response = response.clone();\n\n            const contentType = response.headers.get('content-type');\n\n            if (contentType.match(/application\\/octet-stream/)) {\n                const\n                    MIMEType  = FileMIMEType[config.fileFormat],\n                    objectURL = await me.responseBlobToObjectURL(response, MIMEType),\n                    link      = me.getDownloadLink(config.fileName, objectURL);\n\n                link.click();\n            }\n            else if (contentType.match(/application\\/json/)) {\n                const responseJSON = await response.json();\n\n                if (responseJSON.success) {\n                    const link = me.getDownloadLink(config.fileName, responseJSON.url);\n\n                    link.click();\n                }\n                else {\n                    Toast.show({\n                        html        : responseJSON.msg,\n                        rootElement : this.rootElement\n                    });\n                }\n            }\n        }\n    }\n\n    /**\n     * Creates object URL from response content with given mimeType\n     * @param {Response} response Response instance\n     * @param {String} mimeType\n     * @returns {Promise} Returns string object URL\n     * @private\n     */\n    async responseBlobToObjectURL(response, mimeType) {\n        const blob = await response.blob();\n\n        return URL.createObjectURL(blob.slice(0, blob.size, mimeType));\n    }\n\n    /**\n     * Creates link to download the file.\n     * @param {String} name File name\n     * @param {String} href URL of the resource\n     * @returns {HTMLElement} HTMLAnchorElement\n     * @private\n     */\n    getDownloadLink(name, href) {\n        const link = document.createElement('a');\n\n        link.download = name;\n        link.href = href;\n\n        if (this.openInNewTab) {\n            link.target = '_blank';\n        }\n\n        return link;\n    }\n\n    get defaultExportDialogConfig() {\n        return ObjectHelper.copyProperties({}, this, [\n            'client',\n            'exporters',\n            'exporterType',\n            'orientation',\n            'fileFormat',\n            'paperFormat',\n            'alignRows',\n            'rowsRange',\n            'repeatHeader'\n        ]);\n    }\n\n    changeExportDialog(exportDialog, oldExportDialog) {\n        const me = this;\n\n        oldExportDialog?.destroy();\n\n        if (exportDialog) {\n            const config = me.dialogClass.mergeConfigs({\n                rootElement : me.rootElement,\n                client      : me.client,\n                items       : {\n                    rowsRangeField : {\n                        value : me.rowsRange\n                    },\n\n                    exporterTypeField : {\n                        value : me.exporterType\n                    },\n\n                    orientationField : {\n                        value : me.orientation\n                    },\n\n                    paperFormatField : {\n                        value : me.paperFormat\n                    },\n\n                    repeatHeaderField : {\n                        value : me.repeatHeader\n                    },\n\n                    fileFormatField : {\n                        value : me.fileFormat\n                    },\n\n                    alignRowsField : {\n                        checked : me.alignRows\n                    }\n                }\n            }, me.defaultExportDialogConfig, exportDialog);\n\n            exportDialog = me.dialogClass.new(config);\n\n            exportDialog.ion({\n                export  : me.onExportButtonClick,\n                thisObj : me\n            });\n        }\n\n        return exportDialog;\n    }\n\n    /**\n     * Shows {@link Grid.view.export.ExportDialog export dialog}\n     */\n    async showExportDialog() {\n        return this.exportDialog.show();\n    }\n\n    onExportButtonClick({ values }) {\n        const\n            me         = this,\n            dialogMask = me.exportDialog.mask({\n                progress    : 0,\n                maxProgress : 100,\n                text        : me.exportMask\n            });\n\n        const detacher = me.ion({\n            exportstep({ progress, text, contentGenerated }) {\n                if (contentGenerated) {\n                    me.exportDialog.unmask();\n                    detacher();\n                }\n                else {\n                    dialogMask.progress = progress;\n\n                    if (text != null) {\n                        dialogMask.text = text;\n                    }\n                }\n            }\n        });\n\n        me.currentExportPromise = me.export(values);\n\n        // Clear current export promise\n        me.currentExportPromise.catch(() => {}).finally(() => {\n            detacher();\n            me.exportDialog?.unmask();\n            me.currentExportPromise = null;\n        });\n    }\n\n    showLoadingToast(exportPromise) {\n        const toast = Toast.show({\n            timeout      : 0,\n            showProgress : false,\n            rootElement  : this.rootElement,\n            html         : `\n    <span class=\"b-mask-icon b-icon b-icon-spinner\"></span>\n    <span>${this.exportProgressMask}</span>\n    <button class=\"b-button\">${this.L('L{Click to abort}')}</button>`\n        });\n\n        EventHelper.on({\n            element : toast.element,\n            click() {\n                exportPromise.abort?.();\n            }\n        });\n\n        return toast;\n    }\n}\n\nGridFeatureManager.registerFeature(PdfExport, false, 'Grid');\n\n// Format expected by export server\n// const pageFormat = {\n//     html       : '',\n//     column     : 1,\n//     number     : 1,\n//     row        : 1,\n//     rowsHeight : 1\n// };\n//\n// const format = {\n//     fileFormat  : 'pdf',\n//     format      : 'A4',\n//     orientation : 'portrait',\n//     range       : 'complete',\n//     html        : { array : JSON.stringify(pageFormat) }\n// };\n"],
  "mappings": "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",
  "names": ["SummaryFormatter", "Target", "Base", "$name", "generateHtml", "column", "records", "cls", "groupRecord", "groupField", "groupValue", "store", "summaries", "sum", "renderer", "summaryRenderer", "html", "forEach", "config", "type", "field", "max", "min", "average", "length", "reduce", "record", "value", "getValue", "seed", "valueCls", "labelHtml", "label", "valueHtml", "summaryHtml", "String", "includes", "RowReorder", "Delayable", "InstancePlugin", "deprecatedEvents", "gridRowBeforeDragStart", "product", "invalidAsOfVersion", "message", "gridRowDragStart", "gridRowDrag", "gridRowBeforeDropFinalize", "gridRowDrop", "gridRowAbort", "construct", "grid", "arguments", "doDestroy", "_this$dragHelper", "dragHelper", "destroy", "init", "me", "DragHelper", "new", "name", "cloneTarget", "dragThreshold", "proxyTopOffset", "targetSelector", "lockX", "dragWithin", "bodyContainer", "allowDropOutside", "scrollManager", "outerElement", "targetSubGridElement", "touchStartDelay", "isElementDraggable", "bind", "monitoringConfig", "scrollables", "element", "scrollable", "direction", "setXY", "x", "y", "context", "started", "elementRect", "Rectangle", "from", "pointerDownOffset", "startPageY", "globalThis", "pageYOffset", "getBoundingClientRect", "top", "DomHelper", "setTranslateXY", "ignoreSamePositionDrop", "createProxy", "clone", "cloneNode", "container", "document", "createElement", "classList", "add", "removeAttribute", "style", "transform", "width", "appendChild", "selectedRecords", "clone2", "removeClsGlobally", "internalListeners", "beforedragstart", "dragstart", "drag", "drop", "abort", "reset", "prio", "thisObj", "dragHelperConfig", "relayEvents", "dropIndicator", "className", "dropOverTargetCls", "targetSubGrid", "regions", "subGrids", "el", "event", "closest", "gripOnly", "firstCell", "gripperStyle", "getComputedStyle", "offsetX", "rtl", "borderOffsetX", "onGrip", "roundPx", "parseFloat", "client", "preventDragSelect", "onBeforeDragStart", "source", "subGridEl", "disabled", "readOnly", "isTreeGrouped", "contains", "startRecord", "getRecordFromElement", "isSpecialRow", "originalRowTop", "rowManager", "getRowFor", "selectionMode", "checkboxOnly", "startEvent", "pointerType", "isSelected", "selectRow", "addToSelection", "shiftKey", "ctrlKey", "filter", "r", "push", "sort", "r1", "r2", "indexOf", "onDragStart", "_cellMenu$hideContext", "_headerMenu$hideConte", "cellEdit", "cellMenu", "headerMenu", "features", "cellEditDisabledState", "hideContextMenu", "call", "focusedCell", "querySelector", "remove", "firstElementChild", "onDrag", "clientY", "valid", "row", "getRowAt", "overRecord", "dataIndex", "after", "over", "insertBefore", "rowTop", "quarter", "height", "topQuarter", "middleY", "bottomQuarter", "getAt", "tree", "isParent", "dropOnLeaf", "isGrouped", "isGroupHeader", "meta", "collapsed", "pageY", "_bodyRectangle", "first", "count", "last", "getRow", "reorderValid", "_rowManager$getRowByI", "getRowById", "removeCls", "nextSibling", "some", "rec", "parent", "clearTimeout", "hoverTimer", "isExpanded", "setTimeout", "expand", "hoverExpandTimeout", "toggleCls", "setTranslateY", "Math", "visibility", "toggle", "onDrop", "async", "oldPositionContext", "map", "_record$parent", "parentId", "id", "parentIndex", "result", "trigger", "animateProxyTo", "align", "finalizeReorder", "onAbort", "_context$parent$child", "_context$parent$child2", "bubbleWhile", "tryInsertChild", "children", "move", "getNext", "_rowIndex", "_focusedCell", "focusCell", "columnId", "clearSorters", "finalize", "onReset", "onPaint", "firstPaint", "updateShowGrip", "show", "isDragging", "__publicField", "configurable", "showGrip", "pluginConfig", "featureClass", "_$name", "GridFeatureManager", "registerFeature", "Summary", "selectedOnly", "hideFooters", "chain", "bindStore", "detachListeners", "ion", "change", "doDisable", "disable", "updateSummaries", "eachSubGrid", "subGrid", "syncPartners", "renderRows", "cells", "isFiltered", "storage", "values", "allRecords", "columns", "_column$summaries", "initialSeed", "Object", "assign", "cellElement", "dataset", "get", "sync", "innerHTML", "onStoreChange", "action", "changes", "shouldUpdate", "keys", "colField", "Boolean", "updateSelectedOnly", "selectionChange", "refresh", "ExportRowsCombo", "Combo", "defaultConfig", "editable", "buildItems", "RowsRange", "all", "text", "L", "visible", "initClass", "ExportOrientationCombo", "Orientation", "portrait", "landscape", "buildComboItems", "obj", "fn", "key", "ExportDialog", "Popup", "autoShow", "autoClose", "closable", "centered", "autoSelectVisibleColumns", "hidePNGMultipageOption", "title", "maxHeight", "overflowY", "defaults", "localeClass", "items", "columnsField", "valueField", "displayField", "multiSelect", "weight", "rowsRangeField", "exporterTypeField", "dialog", "exporters", "exporter", "optionalL", "onChange", "owner", "widgetMap", "alignRowsField", "hidden", "repeatHeaderField", "checked", "fileFormatField", "oldValue", "exporterField", "find", "FileFormat", "png", "_previousDisabled", "_previousValue", "paperFormatField", "orientationField", "bbar", "exportButton", "color", "onClick", "cancelButton", "Error", "columnsStore", "isLeaf", "exportable", "excludeCollapsedRecords", "applyInitialValues", "LocaleManager", "locale", "labelWidth", "toUpperCase", "PaperFormat", "onBeforeShow", "_super$onBeforeShow", "query", "c", "onLocaleChange", "eachWidget", "widget", "Field", "onExportClick", "onCancelClick", "hide", "fieldRe", "test", "ref", "replace", "Checkbox", "MultiPageExporter", "Exporter", "exportingPageText", "stateNextPage", "rowsRange", "enableDirectRendering", "exportMeta", "currentPage", "verticalPosition", "lastExportedRowBottom", "verticalPages", "horizontalPosition", "currentPageTopMargin", "lastTop", "lastRowIndex", "firstVisibleRow", "lastRowDataIndex", "scrollRowIntoView", "firstVisibleDataIndex", "block", "prepareComponent", "headerTpl", "footerTpl", "alignRows", "paperFormat", "isPortrait", "orientation", "paperWidth", "paperHeight", "pageWidth", "inchToPx", "pageHeight", "onlyVisibleRows", "horizontalPages", "ceil", "totalWidth", "contentHeight", "measureElement", "totalPages", "totalHeight", "totalRows", "getVisibleRowsCount", "headerHeight", "footerHeight", "bodyHeight", "scrollHeight", "rowHeight", "rowOffsetHeight", "rowsOnFirstPage", "floor", "rowsPerPage", "remainingRows", "adjustRowBuffer", "restoreComponent", "restoreRowBuffer", "collectRows", "rows", "onlyVisible", "hasMergeCells", "hasActiveFeature", "remainingHeight", "index", "findIndex", "bottom", "firstRowIndex", "overflowingHeight", "lastDataIndex", "offset", "offsetHeight", "collectRow", "subGridName", "mergedCells", "querySelectorAll", "mergedCellsHtml", "mergedCell", "outerHTML", "lastRow", "exactGridHeight", "footerContainer", "headerContainer", "onRowsCollected", "slice", "scrollableTopMargin", "detacher", "offsetRows", "fakeRow", "previousTop", "render", "translate", "renderMergedCells", "buildPage", "getVirtualScrollerHeight", "header", "footer", "prepareHTML", "buildPageHtml", "prepareExportElement", "placeHolder", "placeHolderText", "contentHtml", "join", "marginTop", "prototype", "pagesExtractor", "stylesheets", "progress", "round", "styles", "pageTpl", "MultiPageVerticalExporter", "processedRows", "size", "estimateTotalPages", "repeatHeader", "scale", "getScaleValue", "bodyElement", "initialScroll", "rowsHeight", "firstRow", "lastVisibleRow", "finishRowIndex", "Set", "clientHeaderHeight", "nextPageTop", "gridHeight", "SinglePageExporter", "localize", "centerContentHorizontally", "positionRows", "currentTop", "lastProcessedRowIndex", "firstNewRowIndex", "lastNewRowIndex", "fromIndex", "toIndex", "i", "totalClientHeight", "widthScale", "heightScale", "BrowserHelper", "isIE11", "PdfExport", "dialogClass", "exportServer", "undefined", "exportDialog", "$config", "fileName", "fileFormat", "clientURL", "keepRegionSizes", "pagesPerRequest", "exporterConfig", "exporterType", "translateURLsToAbsolute", "keepPathName", "openAfterExport", "sendAsBinary", "openInNewTab", "fetchOptions", "exportMask", "exportProgressMask", "showErrorToast", "localizableProperties", "filterStyles", "updateEnableDirectRendering", "VersionHelper", "deprecate", "_this$exportDialog", "exportersMap", "currentExportPromise", "_currentExportPromise", "_exportersMap", "Map", "getExporter", "has", "exporterClass", "ObjectHelper", "relayAll", "set", "buildExportConfig", "visibleColumns", "$$name", "export", "isExporting", "mask", "_me$exportDialog", "pages", "isDestroying", "close", "unmask", "contentGenerated", "responsePromise", "receiveExportContent", "toast", "showLoadingToast", "response", "processExportContent", "error", "Response", "_me$exportDialog2", "Toast", "rootElement", "ok", "AjaxHelper", "fetch", "method", "credentials", "headers", "body", "JSON", "stringify", "format", "contentType", "match", "MIMEType", "FileMIMEType", "objectURL", "responseBlobToObjectURL", "getDownloadLink", "click", "responseJSON", "json", "success", "url", "msg", "mimeType", "blob", "URL", "createObjectURL", "href", "link", "download", "target", "defaultExportDialogConfig", "copyProperties", "changeExportDialog", "oldExportDialog", "mergeConfigs", "onExportButtonClick", "showExportDialog", "dialogMask", "maxProgress", "exportstep", "catch", "finally", "_me$exportDialog3", "exportPromise", "timeout", "showProgress", "EventHelper", "on", "_exportPromise$abort"]
}
