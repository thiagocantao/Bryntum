{
  "version": 3,
  "sources": ["../../../../Core/lib/Core/mixin/Featureable.js", "../../../../Core/lib/Core/mixin/Fencible.js", "../../../../Core/lib/Core/widget/FilterField.js", "../../../../Core/lib/Core/widget/mixin/Responsive.js"],
  "sourcesContent": ["import Base from '../Base.js';\nimport DynamicObject from '../util/DynamicObject.js';\n\n/**\n * @module Core/mixin/Featureable\n */\n\n/**\n * This mixin provides management of a set of features that can be manipulated via the `features` config.\n *\n * The first step in using `Featureable` is to define the family of features using `Factoryable` to declare a base\n * class for features to extend:\n *\n * ```javascript\n *  class SuperWidgetFeature extends InstancePlugin.mixin(Factoryable) {\n *      static get factoryable() {\n *          //\n *      }\n *  }\n * ```\n *\n * The various feature classes extend the `SuperWidgetFeature` base class and call `initClass()` to register themselves:\n *\n * ```javascript\n *  export default class AmazingSuperWidgetFeature extends SuperWidgetFeature {\n *      static get type() {\n *          return 'amazing';\n *      }\n *  }\n *\n *  AmazingSuperWidgetFeature.initClass();\n * ```\n *\n * A class that supports these features via `Featureable` is declared like so:\n *\n * ```javascript\n *  class SuperWidget extends Widget.mixin(Featureable) {\n *      static get featureable() {\n *          return {\n *              factory : SuperWidgetFeature\n *          };\n *      }\n *\n *      static get configurable() {\n *          return {\n *              // Declare the default features. These can be disabled by setting them to a falsy value. Using\n *              // configurable(), the value defined by this class is merged with values defined by derived classes\n *              // and ultimately the instance.\n *              features : {\n *                  amazing : {\n *                      ...\n *                  }\n *              }\n *          };\n *      }\n *  }\n *```\n * @mixin\n * @internal\n */\nexport default Target => class Featureable extends (Target || Base) {\n    static get $name() {\n        return 'Featureable';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * Specifies the features to create and associate with the instance. The keys of this object are the names\n             * of features. The values are config objects for those feature instances.\n             *\n             * After construction, this property can be used to access the feature instances and even reconfigure them.\n             *\n             * For example:\n             * ```\n             *  instance.features.amazing = {\n             *      // reconfigure this feature\n             *  }\n             * ```\n             * This can also be done in bulk:\n             * ```\n             *  instance.features = {\n             *      amazing : {\n             *          // reconfigure this feature\n             *      },\n             *      // reconfigure other features\n             *  }\n             * ```\n             * @config {Object}\n             */\n            features : null\n        };\n    }\n\n    static get declarable() {\n        return [\n            /**\n             * This property getter returns options that control feature management for the derived class. This\n             * property getter must be defined by the class that mixes in `Featureable` in order to initialize the\n             * class properly.\n             * ```\n             *  class SuperWidget extends Widget.mixin(Featureable) {\n             *      static get featureable() {\n             *          return {\n             *              factory : SuperWidgetFeature\n             *          };\n             *      }\n             *      ...\n             *  }\n             * ```\n             * @static\n             * @member {Object} featureable\n             * @property {Core.mixin.Factoryable} featureable.factory The factoryable class (not one of its instances)\n             * that will be used to create feature instances.\n             * @property {String} [featureable.ownerName='client'] The config or property to assign on each feature as\n             * a reference to its creator, the `Featureable` instance.\n             * @internal\n             */\n            'featureable'\n        ];\n    }\n\n    static setupFeatureable(cls) {\n        const featureable = {\n            ownerName : 'client',\n            ...cls.featureable\n        };\n\n        featureable.factory.initClass();\n\n        // Replace the class/static getter with a new one that returns the complete featureable object:\n        Reflect.defineProperty(cls, 'featureable', {\n            get() {\n                return featureable;\n            }\n        });\n    }\n\n    doDestroy() {\n        const features = this.features;\n\n        super.doDestroy();\n\n        for (const name in features) {\n            const feature = features[name];\n            // Feature might be false or destroyed already by Grid (EventList mixes in CalendarMixin which has this mixin)\n            feature.destroy?.();\n        }\n    }\n\n    /**\n     * Returns `true` if the specified feature is active for this instance and `false` otherwise.\n     * @param {String} name The feature name\n     * @returns {Boolean}\n     */\n    hasFeature(name) {\n        return Boolean(this.features?.[name]);\n    }\n\n    changeFeatures(features, was) {\n        if (this.isDestroying) {\n            return;\n        }\n\n        const\n            me = this,\n            { featureable } = me.constructor,\n            manager = me.$features || (me.$features = new DynamicObject({\n                configName : 'features',\n                factory    : featureable.factory,\n                owner      : me,\n                ownerName  : featureable.ownerName\n            }));\n\n        manager.update(features);\n\n        if (!was) {\n            // Only return the target once. Further calls are processed above so we need to return undefined to ensure\n            // onConfigChange is called. By returning the same target on 2nd+ call, it passes the === test and won't\n            // trigger onConfigChange.\n            return manager.target;\n        }\n    }\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n\n    getCurrentConfig(options) {\n        const\n            result       = super.getCurrentConfig(options),\n            { features } = result;\n\n        if (features) {\n            // Replace empty configs with `true`\n            for (const featureName in features) {\n                if (Object.keys(features[featureName]).length === 0) {\n                    features[featureName] = true;\n                }\n            }\n        }\n\n        return result;\n    }\n};\n", "import ObjectHelper from '../helper/ObjectHelper.js';\nimport StringHelper from '../helper/StringHelper.js';\nimport Base from '../Base.js';\n\n/**\n * @module Core/mixin/Fencible\n */\n\nconst\n    { defineProperty } = Object,\n    { hasOwn }         = ObjectHelper,\n    fencibleSymbol     = Symbol('fencible'),\n    NONE               = [],\n    distinct           = array => Array.from(new Set(array)),\n    parseNames         = names => names ? distinct(StringHelper.split(names)) : NONE,\n\n    fenceMethod = (target, name, options) => {\n        if (options === true) {\n            options = name;\n        }\n\n        if (!ObjectHelper.isObject(options)) {\n            options = {\n                all : options\n            };\n        }\n\n        let any = parseNames(options.any);\n\n        const\n            all      = parseNames(options.all),\n            lock     = options.lock ? parseNames(options.lock) : distinct(all.concat(any)),\n            implName = name + 'Impl',\n            fence    = function(...params) {  // cannot use => since we need to receive \"this\" from the caller\n                const\n                    me = this,\n                    // For static methods we have to be careful to use hasOwn to check the \"point of entry\" (i.e., the\n                    // class reference used to call the method) since \".\" will climb the constructor's __proto__ chain\n                    // to find properties from a super class. This does not happen to instances since we never put our\n                    // fences object on the prototype chain.\n                    fences = hasOwn(me, fencibleSymbol) ? me[fencibleSymbol] : (me[fencibleSymbol] = {}),\n                    isFree = key => !fences[key];\n\n                if (all.every(isFree) && (!any || any.some(isFree))) {\n                    try {\n                        lock.forEach(key => (fences[key] = (fences[key] || 0) + 1));\n\n                        return me[implName](...params);\n                    }\n                    finally {\n                        lock.forEach(key => --fences[key]);\n                    }\n                }\n            };\n\n        any = any.length ? any : null;  // [].some(f) is always false, but [].every(f) is always true\n\n        !target[implName] && defineProperty(target, implName, {\n            configurable : true,\n            value        : target[name]\n        });\n\n        defineProperty(target, name, {\n            configurable : true,\n            value        : fence\n        });\n    };\n\n/**\n * A description of how to protect a method from reentry.\n *\n * A value of `true` is transformed using the key as the `all` value. For example, this:\n *\n * ```javascript\n *  class Foo extends Base.mixin(Fencible) {\n *      static fenced = {\n *          foo : true\n *      };\n * ```\n *\n * Is equivalent to this:\n *\n * ```javascript\n *  class Foo extends Base.mixin(Fencible) {\n *      static fenced = {\n *          foo : {\n *              all : ['foo']\n *          }\n *      };\n * ```\n *\n * Strings are split on spaces to produce the `all` array. For example, this:\n *\n * ```javascript\n *  class Foo extends Base.mixin(Fencible) {\n *      static fenced = {\n *          foo : 'foo bar'\n *      };\n * ```\n *\n * Is equivalent to this:\n *\n * ```javascript\n *  class Foo extends Base.mixin(Fencible) {\n *      static fenced = {\n *          foo : {\n *              all : ['foo', 'bar']\n *          }\n *      };\n * ```\n *\n * This indicates that `foo()` cannot be reentered if `foo()` or `bar()` are already executing. On entry to `foo()`,\n * both `foo()` and `bar()` will be fenced (prevented from entering).\n *\n * @typedef {Object} MethodFence\n * @property {String|String[]} [all] One or more keys that must all be currently unlocked to allow entry to the fenced\n * method. String values are converted to an array by splitting on spaces.\n * @property {String|String[]} [any] One or more keys of which at least one must be currently unlocked to allow entry\n * to the fenced method. String values are converted to an array by splitting on spaces.\n * @property {String|String[]} [lock] One or more keys that will be locked on entry to the fenced method and released\n * on exit. String values are converted to an array by splitting on spaces. By default, this array includes all keys\n * in `all` and `any`.\n */\n\n/**\n * This mixin is used to apply reentrancy barriers to methods. For details, see\n * {@link Core.mixin.Fencible#property-fenced-static}.\n * @mixin\n * @internal\n */\nexport default Target => class Fencible extends (Target || Base) {\n    static $name = 'Fencible';\n\n    static declarable = [\n        /**\n         * This class property returns an object that specifies methods to be wrapped to prevent reentrancy.\n         *\n         * It is used like so:\n         * ```javascript\n         *  class Foo extends Base.mixin(Fencible) {\n         *      static fenced = {\n         *          reentrantMethod : true\n         *      };\n         *\n         *      reentrantMethod() {\n         *          // things() may cause reentrantMethod() to be called...\n         *          // but we won't be allowed to reenter this method since we are already inside it\n         *          this.things();\n         *      }\n         *  }\n         * ```\n         *\n         * This can also be used to protect mutually reentrant method groups:\n         *\n         * ```javascript\n         *  class Foo extends Base.mixin(Fencible) {\n         *      static fenced = {\n         *          foo : 'foobar'\n         *          bar : 'foobar'\n         *      };\n         *\n         *      foo() {\n         *          console.log('foo');\n         *          this.bar();\n         *      }\n         *\n         *      bar() {\n         *          console.log('bar');\n         *          this.foo();\n         *      }\n         *  }\n         *\n         *  instance = new Foo();\n         *  instance.foo();\n         *  >> foo\n         *  instance.bar();\n         *  >> bar\n         * ```\n         *\n         * The value for a fenced method value can be `true`, a string, an array of strings, or a\n         * {@link #typedef-MethodFence} options object.\n         *\n         * Internally these methods are protected by assigning a wrapper function in their place. The original function\n         * is moved to a new named property by appending 'Impl' to the original name. For example, in the above code,\n         * `foo` and `bar` are wrapper functions that apply reentrancy protection and call `fooImpl` and `barImpl`,\n         * respectively. This is important for inheritance and `super` calling because the new name must be used in\n         * order to retain the guard function implementations.\n         *\n         * @static\n         * @member {Object} fenced\n         * @internal\n         */\n        'fenced'\n    ];\n\n    static setupFenced(cls) {\n        let { fenced } = cls;\n        const\n            statics = fenced.static,\n            pairs = [];\n\n        if (statics) {\n            fenced = { ...fenced };\n            delete fenced.static;\n\n            pairs.push([statics, cls]);\n        }\n\n        pairs.push([fenced, cls.prototype]);\n\n        for (const [methods, target] of pairs) {\n            for (const methodName in methods) {\n                fenceMethod(target, methodName, methods[methodName]);\n            }\n        }\n    }\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import TextField from '../../Core/widget/TextField.js';\n\n/**\n * @module Core/widget/FilterField\n */\n\n/**\n * A simple text field for filtering a store.\n *\n * Allows filtering by {@link #config-field field}:\n *\n * ```javascript\n * const filterField = new FilterField({\n *    store : eventStore,\n *    field : 'name'\n * });\n * ```\n *\n * Or by using a {@link #config-filterFunction filter function} for greater control/custom logic:\n *\n * ```javascript\n * const filterField = new FilterField({\n *    store          : eventStore,\n *    filterFunction : (record, value) => record.name.includes(value)\n * });\n * ```\n *\n * @extends Core/widget/TextField\n * @classType filterfield\n * @widget\n */\nexport default class FilterField extends TextField {\n    static get $name() {\n        return 'FilterField';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'filterfield';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * The model field name to filter by. Can optionally be replaced by {@link #config-filterFunction}\n             * @config {String}\n             * @category Filtering\n             */\n            field : null,\n\n            /**\n             * The store to filter.\n             * @config {Core.data.Store}\n             * @category Filtering\n             */\n            store : null,\n\n            /**\n             * Optional filter function to be called with record and value as parameters for store filtering.\n             * ```javascript\n             * {\n             *     type           : 'filterfield',\n             *     store          : myStore,\n             *     filterFunction : (record, value)  => {\n             *        return record.text.includes(value);\n             *     }\n             * }\n             * ```\n             * @param {Core.data.Model} record Record for comparison\n             * @param {String} value Value to compare with\n             * @returns {Boolean} Return true if record matches comparison requirements\n             * @config {Function}\n             * @category Filtering\n             */\n            filterFunction : null,\n\n            clearable            : true,\n            revertOnEscape       : true,\n            keyStrokeChangeDelay : 100,\n\n            onChange({ value }) {\n                const { store, field, filterFunction } = this;\n\n                if (store) {\n                    const filterId = `${field || this.id}-Filter`;\n\n                    if (value.length === 0) {\n                        store.removeFilter(filterId);\n                    }\n                    else {\n                        let filterBy;\n\n                        if (filterFunction) {\n                            filterBy = record => filterFunction(record, value);\n                        }\n                        else {\n                            // We filter using a RegExp, so quote significant characters\n                            value = value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\n                            filterBy = record => record.getValue(field)?.match(new RegExp(value, 'i'));\n                        }\n\n                        // A filter with an id replaces any previous filter with that id.\n                        // Leave any other filters which may be in use in place.\n                        store.filter({\n                            id : filterId,\n                            filterBy\n                        });\n                    }\n                }\n            }\n        };\n    }\n\n    updateValue(value, old) {\n        super.updateValue(value, old);\n\n        // Initial value, apply it\n        if (value && this.isConfiguring) {\n            this.onChange({ value });\n        }\n    }\n};\n\nFilterField.initClass();\n", "import Base from '../../Base.js';\nimport BrowserHelper from '../../helper/BrowserHelper.js';\nimport FunctionHelper from '../../helper/FunctionHelper.js';\nimport ObjectHelper from '../../helper/ObjectHelper.js';\nimport Delayable from '../../mixin/Delayable.js';\nimport Fencible from '../../mixin/Fencible.js';\n\n/**\n * @module Core/widget/mixin/Responsive\n */\n\nconst\n    EMPTY = [],\n    isStateName = name => name[0] !== '*',\n    pop = (object, key) => {\n        const ret = object[key] || null;\n        delete object[key];\n        return ret;\n    },\n    responsiveRootFn = widget => widget.responsiveRoot,\n    scoring = {\n        number : threshold => ({ width }) => width <= threshold && threshold\n    },\n    splitConfigs = configs => {\n        delete configs.once;\n\n        return {\n            callback : pop(configs, 'callback'),\n            configs,\n            when     : pop(configs, 'when')\n        };\n    },\n    // We cheat a bit and leave \"once\", \"when\" and \"callback\" in the config object for the merge.\n    splitMergedConfigs = (cls, ...parts) => {\n        const\n            once = parts.flatMap(p => p?.once || EMPTY), // onces are not arrays, so are unchanged; ==> filter().map()\n            configs = cls.mergeConfigs(...parts),\n            ret = splitConfigs(configs);\n\n        ret.once = once.length ? splitConfigs(cls.mergeConfigs(...once)) : null;\n\n        return ret;\n    },\n    // Allow responsiveTarget to be a DOM element? (see git history for wrapElement impl)\n    wrapWidget = (widget, handler) => {\n        let triggers,\n            desc = Proxy.revocable(widget, {\n                get(o, name) {\n                    if (triggers) {\n                        triggers[name] = true;\n                    }\n\n                    return widget[name];\n                }\n            }),\n            detacher = FunctionHelper.after(widget, 'onConfigChange', (ignore, { name }) => {\n                if (triggers?.[name]) {\n                    handler();\n                }\n            }),\n            resizer = widget.ion({\n                resize : () => {\n                    handler();\n                }\n            });\n\n        widget.monitorResize = true;\n\n        return {\n            widget,\n\n            get object() {\n                return desc?.proxy;\n            },\n\n            destroy() {\n                if (desc) {\n                    desc.revoke();\n                    detacher();\n                    resizer();\n\n                    desc = detacher = resizer = null;\n                }\n            },\n\n            reset() {\n                triggers = Object.create(null);\n            }\n        };\n    };\n\n/**\n * A state definition object used by the {@link Core.widget.mixin.Responsive#config-responsive} config property.\n *\n * ```javascript\n *  {\n *      responsive : {\n *          small : {\n *              // a ResponsiveState object\n *              when : 400,\n *\n *              callback() {\n *                  console.log('Applied small not first time');\n *              },\n *\n *              once : {\n *                  mode : 'full',\n *\n *                  callback() {\n *                      console.log('Applied small first time');\n *                  }\n *              }\n *\n *              // All other properties are configs to apply when\n *              // the state is active\n *              text  : null,\n *              color : 'b-blue'\n *          }\n *      }\n *  }\n * ```\n *\n * See {@link Core.widget.mixin.Responsive} for more details.\n *\n * @typedef ResponsiveState\n * @property {ResponsiveState} once A `ResponsiveState` object applied only one time when a state is first activated. It\n * is not valid to specify a `when` or `once` property on these `ResponsiveState` objects. It is valid to supply a\n * `callback`, and if done, this callback will be called instead of the `callback` on the parent `ResponsiveState`\n * object on first activation.\n * @property {Function|Number} when A two argument function to return the score for the state, or a number for both the\n * width threshold and score. The arguments passed are as follows:\n *  - `widget` The {@link Core.widget.mixin.Responsive#config-responsiveTarget widget} whose properties should determine\n *  the state's score\n *  - `browserHelper` The {@link Core.helper.BrowserHelper} singleton object\n * @property {Function} [callback] An optional callback, called when the state is activated. This function receives an\n * object with the following properties:\n *  - `source` The instance whose state is being activated (typically a {@link Core.widget.Widget})\n *  - `target` The {@link Core.widget.Widget} identified as the {@link Core.widget.mixin.Responsive#config-responsiveTarget}\n *  - `state` The name of the newly active responsive state\n *  - `oldState` The name of the previously active responsive state\n */\n\n/**\n * A breakpoint definition. Used when defining breakpoints, see {@link #config-breakpoints}.\n *\n * ```javascript\n * {\n *     name    : 'Small',\n *     configs : {\n *         text  : null,\n *         color : 'b-blue'\n *     },\n *     callback() {\n *         console.log('Applied small');\n *     }\n * }\n * ```\n *\n * @typedef Breakpoint\n * @property {String} name Name of the breakpoint\n * @property {Object} [configs] An optional configuration object to apply to the widget when the breakpoint is activated\n * @property {Function} [callback] An optional callback, called when the breakpoint is activated\n * @deprecated 5.0 Breakpoints have been replaced by {@link Core.widget.mixin.Responsive#config-responsive}.\n */\n\n/**\n * This mixin provides management of a named set of {@link #typedef-ResponsiveState} objects that are conditionally\n * applied in response to the widget's size or other platform details. The names of the {@link #typedef-ResponsiveState}\n * objects are the keys of the {@link #config-responsive} config object. For example:\n *\n * ```javascript\n *  class ResponsiveButton extends Button.mixin(Responsive) {\n *      static configurable = {\n *          responsive : {\n *              small : {\n *                  // this is a ResponsiveState object named \"small\"\n *                  text : 'S'\n *              },\n *              medium : {\n *                  text : 'M'\n *              }\n *              large : {\n *                  text : 'L'\n *              }\n *          }\n *      };\n *  }\n * ```\n *\n * When the conditions are right for the button to be in the `'small'` responsive state, the `text` config will be set\n * to `'S'`.\n *\n * Any desired configs can be present in a {@link #typedef-ResponsiveState} object, however, the `when` and `callback`\n * properties have special meaning to this mixin and are reserved.\n *\n * ## Selecting the Responsive State\n *\n * To determine the current responsive state, the `when` property is consulted for each candidate state.\n *\n * If `when` is a number, it is understood to be a width threshold and, if the widget's `width` is equal or less than\n * that value, the score is that value. For example, a value of 400 would produce a score of 400 if the widget's width\n * were less than or equal to 400. If the widget's width is greater than 400, the state would be skipped.\n *\n * If `when` is a function, it is called with two parameters: a readonly reference to the widget and the\n * {@link Core.helper.BrowserHelper} singleton object. The function should return the numeric score if the state is\n * applicable, or `null` or `false` if the state should be skipped.\n *\n * The state that has the minimum score is selected as the responsive state for the widget.\n *\n * Consider the default responsive states and their `when` values:\n *\n * ```javascript\n *  responsive : {\n *      small : {\n *          when : 400\n *      },\n *\n *      medium : {\n *          when : 800\n *      },\n *\n *      large : {\n *          when : () => Infinity\n *      },\n *\n *      '*' : {}\n *  },\n * ```\n *\n * For example, if the width of the widget is 300: the score for the `small` responsive state is 400, the score for\n * the `medium` responsive state is 800, and the score for `large` is infinity. In effect, the `large` state is always\n * a candidate, but will also always lose to other candidate states. In this case, the `small` state has the minimum\n * score and is selected as the responsive state.\n *\n * If the width of the widget is 600: the `small` state would be skipped, while the `medium` and `large` states would\n * produce the same scores resulting in `medium` being the responsive state.\n *\n * The `when` functions have access to any properties of the widget instance in the first argument, but are also passed\n * the {@link Core.helper.BrowserHelper} singleton as a second argument. This can be used as shown in the following,\n * over-simplified example:\n *\n * ```javascript\n *  class ResponsiveWidget extends Widget.mixin(Responsive) {\n *      static configurable = {\n *          responsive : {\n *              small : {\n *                  when : ({ width }, { isMobileSafari }) => isMobileSafari && width <= 600 && 10\n *                  text : 'iPhone'\n *              },\n *              medium : {\n *                  when : ({ width }, { isMobileSafari }) => isMobileSafari && width <= 1024 && 20\n *                  text : 'iPad'\n *              }\n *              large : {\n *                  text : 'Desktop'\n *              }\n *          }\n *      };\n *  }\n * ```\n *\n * It is best to avoid mixing `when` threshold values and `when` functions as the resulting scores can be confusing.\n * @mixin\n */\nexport default Target => class Responsive extends (Target || Base).mixin(Delayable, Fencible) {\n    static $name = 'Responsive';\n\n    static configurable = {\n        /**\n         * Specifies the various responsive state objects keyed by their name. Each key (except `'*'`, see below) in\n         * this object is a state name (see {@link #config-responsiveState}) and its corresponding value is the\n         * associated {@link #typedef-ResponsiveState} object.\n         *\n         * Some properties of a `ResponsiveState` object are special, for example `when` and `callback`. All other\n         * properties of the state object are config properties to apply when that state is active.\n         *\n         * The `when` property can be a function that computes the score for the state. The state whose `when` function\n         * returns the lowest score is selected and its non-special properties will be assigned to the instance. If\n         * `when` is a number, it will be converted into a scoring function (see below).\n         *\n         * A `when` function accepts two readonly parameters and returns either a numeric score if the state should be\n         * considered, or `false` or `null` if the state should be ignored (i.e., it does match with the current state).\n         *\n         * The first parameter is a readonly proxy for the {@link #config-responsiveTarget widget} whose size and other\n         * properties determine the state's score. The proxy tracks property access to that widget in order to update\n         * the responsive state should any of those properties change.\n         *\n         * The second argument to a `when` function is the {@link Core.helper.BrowserHelper} singleton. This allows\n         * a `when` function to conveniently test platform and browser information.\n         *\n         * The state whose `when` function returns the lowest score is selected as the new\n         * {@link #config-responsiveState} and its config object (minus the `when` function and other special\n         * properties) is applied to the instance.\n         *\n         * If `when` is a number, it is converted to function. The following two snippets produce the same `when`\n         * scoring:\n         *\n         * ```javascript\n         *      small : {\n         *          when : 400,\n         *          ...\n         *      }\n         * ```\n         *\n         * The above converted to:\n         *\n         * ```javascript\n         *      small : {\n         *          when : ({ width }) => width <= 400 && 400,\n         *          ...\n         *      }\n         * ```\n         * Selecting the lowest score as the winner allows for the simple conversion of width threshold to score value,\n         * such that the state with the smallest matching width is selected.\n         *\n         * If the `responsive` config object has an asterisk key (`'*'`), its value is used as the default set of config\n         * properties to apply all other states. This will be the only config properties to apply if no `when` function\n         * returns a score. In this way, this special state object acts as a default state as well as a set of\n         * default values for other states to share. This state object has no `when` function.\n         *\n         * The default for this config is:\n         * ```javascript\n         *  {\n         *      small : {\n         *          when : 400\n         *      },\n         *\n         *      medium : {\n         *          when : 800\n         *      },\n         *\n         *      large : {\n         *          when : () => Infinity\n         *      },\n         *\n         *      '*' : {}\n         *  }\n         * ```\n         *\n         * A derived class (or instance) can use these states by populating other config properties, define\n         * additional states, and/or adjust the `when` properties to use different size thresholds.\n         *\n         * @config {Object}\n         */\n        responsive : {\n            $config : {\n                lazy : 'paint'\n            },\n\n            value : null\n        },\n\n        /**\n         * The defaults for the {@link #config-responsive} config. These are separated so that the act of setting the\n         * {@link #config-responsive} config is what triggers additional processing.\n         * @config {Object}\n         * @internal\n         * @default\n         */\n        responsiveDefaults : {\n            small : {\n                when : 400\n            },\n\n            medium : {\n                when : 800\n            },\n\n            large : {\n                when : () => Infinity\n            },\n\n            '*' : {}\n        },\n\n        /**\n         * Set to `true` to mark this instance as the default {@link #config-responsiveTarget} for descendants that do\n         * not specify an explicit {@link #config-responsiveTarget} of their own.\n         * @config {Boolean}\n         * @default false\n         */\n        responsiveRoot : null,\n\n        /**\n         * The name of the active state of the {@link #config-responsive} config. This is assigned internally\n         * and should not be assigned directly.\n         *\n         * @config {String}\n         * @readonly\n         */\n        responsiveState : null,\n\n        /**\n         * The widget whose size and other properties drive this object's responsive behavior. If this config is not\n         * specified, the closest ancestor that specified {@link #config-responsiveRoot responsiveRoot=true} will be\n         * used. If there is no such ancestor, then the instance using this mixin is used.\n         *\n         * If this value is set to `'@'`, then this instance is used even if there is a {@link #config-responsiveRoot}\n         * ancestor.\n         *\n         * If this config is a string that starts with `'@'`, the text following the first character is the name of the\n         * property on this instance that holds the target to use. For example, `'@owner'` to use the value of the\n         * `owner` property as the responsive target.\n         *\n         * If this config is a string that does not start with `'@'`, that string is passed to\n         * {@link Core.widget.Widget#function-up} to find the closest matching ancestor.\n         *\n         * If another widget is used as the `responsiveTarget` and if this instance does not specify any explicit `when`\n         * properties in its {@link #config-responsive} config, then the `when` definitions of the `responsiveTarget`\n         * will be used for this instance.\n         * @config {String|Core.widget.Widget}\n         */\n        responsiveTarget : {\n            value   : null,\n            $config : {\n                lazy : 'paint'\n            }\n        },\n\n        responsiveWidget : {\n            value   : null,\n            $config : {\n                nullify : true\n            }\n        },\n\n        /**\n         * Defines responsive breakpoints, based on max-width or max-height.\n         *\n         * When the widget is resized, the defined breakpoints are queried to find the closest larger or equal\n         * breakpoint for both width and height. If the found breakpoint differs from the currently applied, it is\n         * applied.\n         *\n         * Applying a breakpoint triggers an event that applications can catch to react to the change. It also\n         * optionally applies a set of configs and calls a configured callback.\n         *\n         * ```javascript\n         * breakpoints : {\n         *     width : {\n         *         50 : { name : 'small', configs : { text : 'Small', ... } }\n         *         100 : { name : 'medium', configs : { text : 'Medium', ... } },\n         *         '*' : { name : 'large', configs : { text : 'Large', ... } }\n         *     }\n         * }\n         * ```\n         *\n         * @config {Object}\n         * @param {Object} width Max-width breakpoints, with keys as numerical widths (or '*' for larger widths than the\n         * largest defined one) and the value as a {@link #typedef-Breakpoint breakpoint definition}\n         * @param {Object} height Max-height breakpoints, with keys as numerical heights (or '*' for larger widths than\n         * the largest defined one) and the value as a {@link #typedef-Breakpoint breakpoint definition}\n         * @deprecated 5.0 Use {@link #config-responsive} instead.\n         */\n        breakpoints : null\n    };\n\n    static delayable = {\n        responsiveUpdate : 'raf'\n    };\n\n    static fenced = {\n        syncResponsiveWidget : true\n    };\n\n    static prototypeProperties = {\n        responsiveStateChanges : 0,\n        responsiveUpdateCount  : 0\n    };\n\n    get isResponsivePending() {\n        return this.responsiveUpdateCount === 0 && this.hasConfig('responsive');\n    }\n\n    get isResponsiveUpdating() {\n        return this._responsiveUpdating || this.responsiveWidget?._responsiveUpdating;\n    }\n\n    // responsive\n\n    updateResponsive(responsive) {\n        const\n            me  = this,\n            cls = me.constructor,\n            { responsiveDefaults } = me,\n            stateNames = Array.from(\n                new Set(ObjectHelper.keys(responsive).concat(ObjectHelper.keys(responsiveDefaults)))).filter(isStateName);\n\n        let states = null,\n            hasWhen, name, state, when;\n\n        if (responsive) {\n            states = {\n                '*' : splitMergedConfigs(cls, responsiveDefaults['*'], responsive['*'])\n            };\n\n            for (name of stateNames) {\n                state = responsive[name];\n\n                if (state !== null && state !== false) {\n                    // Track whether any state has an explicit \"when\" property\n                    hasWhen = hasWhen || (state && 'when' in state);\n\n                    states[name] = splitMergedConfigs(cls,\n                        responsiveDefaults['*'], responsiveDefaults[name], responsive['*'], state);\n\n                    when = states[name].when;\n                    states[name].when = scoring[typeof when]?.(when) || when;  // convert numbers to fns based on width\n                }\n            }\n        }\n\n        me.$responsiveStates = states;\n        me.$responsiveWhen = hasWhen;\n        me.syncResponsiveWidget();\n    }\n\n    // responsiveState\n\n    updateResponsiveState(state, oldState) {\n        const\n            me = this,\n            { $responsiveStates : states } = me,\n            initial = ++me.responsiveStateChanges === 1,\n            classList = me.element?.classList,\n            defaults = states['*'],\n            def = states[state] || defaults,\n            once = initial && (def.once || defaults.once),\n            isStateful = initial && me.isStateful,\n            target = me.responsiveWidget;\n\n        let config = def.configs,\n            otherConfigs = once?.configs;\n\n        if (otherConfigs) {\n            // overlay \":once\" configs on normal configs (the mergeConfigs method clones the first parameter before\n            // merging it with other values)\n            config = config ? me.constructor.mergeConfigs(config, otherConfigs) : otherConfigs;\n        }\n\n        oldState && classList?.remove(`b-responsive-${oldState.toLowerCase()}`);\n        state && classList?.add(`b-responsive-${state.toLowerCase()}`);\n\n        if (isStateful) {\n            // our responsiveState is munged with the stateId to retrieve state info for this responsiveState (to track\n            // state by small/medium/large/etc). If we don't load the state on each call here we would end up smashing\n            // the values saved in state with those defined by the developer in the responsive config.\n            otherConfigs = me.loadStatefulData();\n\n            if (otherConfigs) {\n                // if there is stateful data for this responsiveState, it takes priority over our config object\n                config = config ? me.constructor.mergeConfigs(config, otherConfigs) : otherConfigs;\n            }\n\n            // We don't want responsive changes to configs to trigger state save:\n            me.suspendStateful();\n        }\n\n        me._responsiveUpdating = true;\n\n        try {\n            /**\n             * Triggered before a new {@link #config-responsiveState} is applied.\n             * @event beforeResponsiveStateChange\n             * @param {Core.widget.Widget} source The widget whose `responsiveState` is to be changed\n             * @param {String} state The new value for the widget's `responsiveState`\n             * @param {String} oldState The previous value for the widget's `responsiveState`\n             */\n            me.trigger?.('beforeResponsiveStateChange', { state, oldState, target });\n\n            config && me.setConfig(config);\n\n            def.callback?.({ source : me, state, oldState, target, initial });\n            once?.callback?.({ source : me, state, oldState, target, initial });\n\n            /**\n             * Triggered when a new {@link #config-responsiveState} is applied.\n             * @event responsiveStateChange\n             * @param {Core.widget.Widget} source The widget whose `responsiveState` has changed\n             * @param {String} state The new value for the widget's `responsiveState`\n             * @param {String} oldState The previous value for the widget's `responsiveState`\n             */\n            me.trigger?.('responsiveStateChange', { state, oldState, target });\n            // we normally would check for !me.isConstructing or !me.isConfiguring but this event needs to be fired\n            // during that time to allow the app to receive the initial responsive state since it is dynamic (i.e.,\n            // not something the app has configured into the widget)\n        }\n        finally {\n            // Be sure to reset these even if an exception occurs\n            me._responsiveUpdating = false;\n            isStateful && me.resumeStateful();\n        }\n    }\n\n    // responsiveTarget\n\n    get responsiveTarget() {\n        return this.responsiveWidget || this._responsiveTarget;\n    }\n\n    updateResponsiveTarget() {\n        this.syncResponsiveWidget();\n    }\n\n    // responsiveWidget\n\n    updateResponsiveWidget(target) {\n        const\n            me = this,\n            // being a delayable raf method effectively auto-bind's our this pointer\n            responsiveUpdate = target && me.responsiveUpdate;\n\n        me.$responsiveWrapper?.destroy();\n        me.$responsiveWrapper = target && wrapWidget(target, responsiveUpdate);\n\n        responsiveUpdate?.now();\n    }\n\n    // Support methods\n\n    responsiveUpdate() {\n        const\n            me = this,\n            { $responsiveStates : states, $responsiveWrapper : wrapper } = me,\n            responsiveTarget = wrapper?.widget;\n\n        if (states && wrapper) {\n            let best = null,\n                bestScore = 0,  // 0 doesn't get used (since !best) but data flow warnings arise w/o assignment\n                fromWhen = states,\n                score, state;\n\n            // If this instance has a responsiveWidget (via responsiveTarget being set to a widget), and that widget\n            // is not this instance, and if this instance did not specify any explicit \"when\" properties in its own\n            // \"responsive\" config, use those of the target\n            if (responsiveTarget && responsiveTarget !== me && !me.$responsiveWhen) {\n                responsiveTarget.getConfig('responsive');  // make sure the config has been evaluated\n                fromWhen = responsiveTarget.$responsiveStates || fromWhen;\n            }\n\n            wrapper.reset();\n\n            for (state in states) {\n                if (state !== '*') {\n                    score = fromWhen[state].when(wrapper.object, BrowserHelper);\n\n                    if (score != null && score !== false && (!best || score < bestScore)) {\n                        best = state;\n                        bestScore = score;\n                    }\n                }\n            }\n\n            ++me.responsiveUpdateCount; // this unlocks statefulId() getter in State mixin\n\n            me.responsiveState = best;\n        }\n    }\n\n    syncResponsiveWidget() {\n        const me = this;\n\n        let widget = null,\n            responsiveTarget;\n\n        if (!me.isDestroying && me.responsive) {\n            responsiveTarget = me.responsiveTarget;\n\n            if (!(widget = responsiveTarget)) {\n                widget = (!me.responsiveRoot && me.up?.(responsiveRootFn)) || me;\n            }\n            else if (typeof responsiveTarget === 'string') {\n                widget = responsiveTarget === '@' ? me : (\n                    responsiveTarget[0] === '@' ? me[responsiveTarget.substring(1)] : me.up(responsiveTarget)\n                );\n\n                if (!widget) {\n                    throw new Error(`No match for responsiveTarget=\"${responsiveTarget}\"`);\n                }\n            }\n\n            if (!widget.isWidget) {\n                throw new Error(`${widget.constructor.$$name} is not a widget and cannot be a responsiveTarget`);\n            }\n        }\n\n        me.responsiveWidget = widget;\n\n        return widget;\n    }\n\n    // <remove-on-release>\n    // TODO: Remove breakpoints in 6.0\n    // </remove-on-release>\n\n    changeBreakpoints(breakpoints) {\n        ObjectHelper.assertObject(breakpoints, 'breakpoints');\n\n        // Normalize breakpoints\n        if (breakpoints?.width) {\n            Object.keys(breakpoints.width).forEach(key => {\n                breakpoints.width[key].maxWidth = key;\n            });\n        }\n\n        if (breakpoints?.height) {\n            Object.keys(breakpoints.height).forEach(key => {\n                breakpoints.height[key].maxHeight = key;\n            });\n        }\n\n        return breakpoints;\n    }\n\n    updateBreakpoints(breakpoints) {\n        if (breakpoints) {\n            this.monitorResize = true;\n        }\n    }\n\n    // Get a width/height breakpoint for the supplied dimension\n    getBreakpoint(levels, dimension) {\n        const\n            // Breakpoints as reverse sorted array of numerical widths [NaN for *, 50, 100]\n            ascendingLevels = Object.keys(levels).map(l => parseInt(l)).sort(),\n            // Find first one larger than current width\n            breakpoint     = ascendingLevels.find(bp => dimension <= bp);\n\n        // Return matched breakpoint or * if available and none matched\n        return levels[breakpoint ?? (levels['*'] && '*')];\n    }\n\n    // Apply a breakpoints configs, trigger event and call any callback\n    activateBreakpoint(orientation, breakpoint) {\n        const\n            me             = this,\n            prevBreakpoint = me[`current${orientation}Breakpoint`];\n\n        if (breakpoint !== prevBreakpoint) {\n            me[`current${orientation}Breakpoint`] = breakpoint;\n\n            me.setConfig(breakpoint.configs);\n\n            prevBreakpoint && me.element.classList.remove(`b-breakpoint-${prevBreakpoint.name.toLowerCase()}`);\n            me.element.classList.add(`b-breakpoint-${breakpoint.name.toLowerCase()}`);\n\n            /**\n             * Triggered when a new max-width based breakpoint is applied.\n             * @event responsiveWidthChange\n             * @param {Core.widget.Widget} source The widget\n             * @param {Breakpoint} breakpoint The applied breakpoint\n             * @param {Breakpoint} prevBreakpoint The previously applied breakpoint\n             * @deprecated 5.0 This event is associated with {@link #config-breakpoints} which is deprecated in favor of\n             * {@link #config-responsive}.\n             */\n            /**\n             * Triggered when a new max-height based breakpoint is applied.\n             * @event responsiveHeightChange\n             * @param {Core.widget.Widget} source The widget\n             * @param {Breakpoint} breakpoint The applied breakpoint\n             * @param {Breakpoint} prevBreakpoint The previously applied breakpoint\n             * @deprecated 5.0 This event is associated with {@link #config-breakpoints} which is deprecated in favor of\n             * {@link #config-responsive}.\n             */\n\n            me.trigger(`responsive${orientation}Change`, { breakpoint, prevBreakpoint });\n\n            breakpoint.callback?.({ source : me, breakpoint, prevBreakpoint });\n\n            me.recompose?.();\n        }\n    }\n\n    // Called on resize to pick and apply a breakpoint, if size changed enough\n    applyResponsiveBreakpoints(width, height) {\n        const\n            me = this,\n            {\n                width  : widths,\n                height : heights\n            }  = me.breakpoints ?? {};\n\n        if (widths) {\n            const breakpoint = me.getBreakpoint(widths, width);\n            me.activateBreakpoint('Width', breakpoint);\n        }\n\n        if (heights) {\n            const breakpoint = me.getBreakpoint(heights, height);\n            me.activateBreakpoint('Height', breakpoint);\n        }\n    }\n\n    onInternalResize(element, width, height, oldWidth, oldHeight) {\n        super.onInternalResize(element, width, height, oldWidth, oldHeight);\n\n        this.applyResponsiveBreakpoints(width, height);\n    }\n};\n"],
  "mappings": "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",
  "names": ["Featureable", "Target", "Base", "$name", "configurable", "features", "declarable", "setupFeatureable", "cls", "featureable", "ownerName", "factory", "initClass", "Reflect", "defineProperty", "get", "doDestroy", "name", "_feature$destroy", "feature", "destroy", "call", "hasFeature", "_this$features", "Boolean", "changeFeatures", "was", "isDestroying", "me", "constructor", "manager", "$features", "DynamicObject", "configName", "owner", "update", "target", "widgetClass", "getCurrentConfig", "options", "result", "featureName", "Object", "keys", "length", "hasOwn", "ObjectHelper", "fencibleSymbol", "Symbol", "NONE", "distinct", "array", "Array", "from", "Set", "parseNames", "names", "StringHelper", "split", "fenceMethod", "isObject", "all", "any", "lock", "concat", "implName", "fence", "params", "fences", "isFree", "key", "every", "some", "forEach", "value", "Fencible", "_a", "setupFenced", "fenced", "statics", "static", "pairs", "push", "prototype", "methods", "methodName", "__publicField", "FilterField", "TextField", "type", "field", "store", "filterFunction", "clearable", "revertOnEscape", "keyStrokeChangeDelay", "onChange", "filterId", "id", "removeFilter", "filterBy", "record", "replace", "_record$getValue", "getValue", "match", "RegExp", "filter", "updateValue", "old", "isConfiguring", "_$name", "EMPTY", "isStateName", "pop", "object", "ret", "responsiveRootFn", "widget", "responsiveRoot", "scoring", "number", "threshold", "width", "splitConfigs", "configs", "once", "callback", "when", "splitMergedConfigs", "parts", "flatMap", "p", "mergeConfigs", "wrapWidget", "handler", "triggers", "desc", "Proxy", "revocable", "o", "detacher", "FunctionHelper", "after", "ignore", "_triggers", "resizer", "ion", "resize", "monitorResize", "_desc", "proxy", "revoke", "reset", "create", "Responsive", "mixin", "Delayable", "isResponsivePending", "responsiveUpdateCount", "hasConfig", "isResponsiveUpdating", "_this$responsiveWidge", "_responsiveUpdating", "responsiveWidget", "updateResponsive", "responsive", "responsiveDefaults", "stateNames", "states", "hasWhen", "state", "_scoring$when", "$responsiveStates", "$responsiveWhen", "syncResponsiveWidget", "updateResponsiveState", "oldState", "_me$element", "initial", "responsiveStateChanges", "classList", "element", "defaults", "def", "isStateful", "config", "otherConfigs", "remove", "toLowerCase", "add", "loadStatefulData", "suspendStateful", "_me$trigger", "_def$callback", "_once$callback", "_me$trigger2", "trigger", "setConfig", "source", "resumeStateful", "responsiveTarget", "_responsiveTarget", "updateResponsiveTarget", "updateResponsiveWidget", "_me$$responsiveWrappe", "responsiveUpdate", "$responsiveWrapper", "now", "wrapper", "best", "bestScore", "fromWhen", "score", "getConfig", "BrowserHelper", "responsiveState", "substring", "up", "Error", "_me$up", "isWidget", "$$name", "changeBreakpoints", "breakpoints", "assertObject", "maxWidth", "height", "maxHeight", "updateBreakpoints", "getBreakpoint", "levels", "dimension", "ascendingLevels", "map", "l", "parseInt", "sort", "breakpoint", "find", "bp", "activateBreakpoint", "orientation", "prevBreakpoint", "_breakpoint$callback", "_me$recompose", "recompose", "applyResponsiveBreakpoints", "widths", "heights", "onInternalResize", "oldWidth", "oldHeight", "$config", "lazy", "small", "medium", "large", "Infinity", "nullify", "delayable", "prototypeProperties"]
}
