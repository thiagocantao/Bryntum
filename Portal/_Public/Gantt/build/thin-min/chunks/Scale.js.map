{
  "version": 3,
  "sources": ["../../../../Core/lib/Core/widget/graph/Histogram.js", "../../../../Core/lib/Core/widget/graph/Scale.js"],
  "sourcesContent": ["import Widget from '../Widget.js';\nimport StringHelper from '../../helper/StringHelper.js';\nimport DomSync from '../../helper/DomSync.js';\nimport Tooltip from '../Tooltip.js';\nimport Objects from '../../helper/util/Objects.js';\n\n/**\n * @module Core/widget/graph/Histogram\n */\nconst\n    ns = 'http://www.w3.org/2000/svg',\n    // Outline series must overlay bars\n    typePrio = {\n        bar     : 1,\n        outline : 2,\n        text    : 3\n    },\n    byOrder = (l, r) => parseInt(l.order, 10) - parseInt(r.order, 10),\n    byDatasetOrder = (l, r) => parseInt(l.dataset.order, 10) - parseInt(r.dataset.order, 10),\n    getField = s => s.field,\n    returnFalse = () => false,\n    classesDelimiter = /\\s+/;\n\n/**\n * An object representing a series settings.\n *\n * @typedef {Object} HistogramSeries\n * @property {'bar'|'outline'} type The series type specifying how it is rendered, as solid bars or outlines.\n * @property {String} [field] The name of the property to to read value from. By default matches the series\n * identifier.\n * @property {Boolean} [stretch=false] Provide `true` to stretch the series bars to take the whole vertical space\n * Applicable to `bar` type series only.\n * @property {String} [id] The series identifier. When configuring the series this value is automatically taken from\n * the key name the series is provided. For example in the bellow code the series `id` will be set to `salary`:\n * ```javascript\n * series : {\n *     salary : {\n *         type : 'bar'\n *     },\n *     ...\n * }\n * ```\n */\n\n/**\n * Displays a simple bar histogram based upon an array of data objects passed in the {@link #config-data} config.\n * @extends Core/widget/Widget\n * @classtype histogram\n */\nexport default class Histogram extends Widget {\n    //region Config\n\n    static type = 'histogram';\n\n    static $name = 'Histogram';\n\n    static get configurable() {\n        return {\n            /**\n             * An array of data objects used to drive the histogram. The property/properties used\n             * are defined in the {@link #config-series} option.\n             * @config {Object[]}\n             * @default\n             */\n            data : null,\n\n            /**\n             * The values to represent in bar form.\n             * @config {Number[]}\n             */\n            values : null,\n\n            /**\n             * Object enumerating data series for the histogram.\n             * The object keys are treated as series identifiers and values are objects that\n             * can contain the following properties:\n             *  - `type` A String, either `'bar'` or `'outline'`\n             *  - `field` A String, the name of the property to use from the data objects in the {@link #config-data} option.\n             * If the value is omitted the series identifier is used as the property name.\n             * @config {Object<String, HistogramSeries>}\n             */\n            series : null,\n\n            /**\n             * By default, the bars are scaled based upon the detected max value across all the series.\n             * A specific top value to represent the 100% height may be configured.\n             * @config {Number}\n             */\n            topValue : null,\n\n            element : {\n                children : [{\n                    ns,\n                    tag                 : 'svg',\n                    reference           : 'svgElement',\n                    width               : '100%',\n                    height              : '100%',\n                    preserveAspectRatio : 'none',\n                    children            : [{\n                        ns,\n                        tag       : 'g',\n                        reference : 'scaledSvgGroup'\n                    }, {\n                        ns,\n                        tag       : 'g',\n                        reference : 'unscaledSvgGroup'\n                    }]\n                }]\n            },\n\n            /**\n             * By default, all bars are rendered, even those with zero height. Configure this as `true`\n             * to omit zero height bars.\n             * @config {Boolean}\n             * @default\n             */\n            omitZeroHeightBars : false,\n\n            /**\n             * By default, the histogram calls {@link #config-getBarText} once per each datum.\n             * So the function is supposed to output all the series values the way it needs.\n             * Configure this as `false` to call the function for each series value\n             * if you need to display the values separately or having different styling.\n             * @config {Boolean}\n             * @default\n             */\n            singleTextForAllBars : true,\n\n            monitorResize : true,\n\n            /**\n             * A Function which returns a CSS class name to add to a rectangle element.\n             * The following parameters are passed:\n             * @param {HistogramSeries} series The series being rendered\n             * @param {Object} rectConfig The rectangle configuration object\n             * @param {Object} datum The datum being rendered\n             * @param {Number} index The index of the datum being rendered\n             * @returns {String} CSS class name of the rectangle element\n             * @config {Function}\n             */\n            getRectClass(series, rectConfig, datum, index) {\n                return '';\n            },\n\n            /**\n             * A Function which returns a CSS class name to add to a path element\n             * built for an `outline` type series.\n             * The following parameters are passed:\n             * @param {HistogramSeries} series The series being rendered\n             * @param {Object[]} data The series data\n             * @returns {String} CSS class name of the path element\n             * @config {Function}\n             */\n            getOutlineClass(series, data) {\n                return '';\n            },\n\n            /**\n             * A Function which returns the tooltip text to display when hovering a bar.\n             * The following parameters are passed:\n             * @param {HistogramSeries} series The series being rendered\n             * @param {Object} rectConfig The rectangle configuration object\n             * @param {Object} datum The datum being rendered\n             * @param {Number} index The index of the datum being rendered\n             * @config {Function}\n             */\n            getBarTip(series, rectConfig, datum, index) {},\n\n            /**\n             * A Function which returns the text to render inside a bar.\n             * The following parameters are passed:\n             * @param {Object} datum The datum being rendered\n             * @param {Number} index The index of the datum being rendered\n             * @param {HistogramSeries} [series] The series (provided if {@link #config-singleTextForAllBars}\n             * is `false`)\n             * @returns {String} Text to render in the bar.\n             * @config {Function}\n             */\n            getBarText(datum, index, series) {\n                return '';\n            },\n\n            getRectConfig : null,\n\n            getBarTextRenderData(renderData, datum, index, series) {\n                return renderData;\n            },\n\n            getBarTextTip(renderData, datum, index, series) {}\n        };\n    }\n\n    static properties = {\n        refreshSuspended : 0\n    };\n\n    //endregion\n\n    //region Init\n\n    construct(config) {\n        const me = this;\n        super.construct(config);\n        me.scheduleRefresh = me.createOnFrame(me.refresh, [], me, true);\n        me.refresh();\n    }\n\n    set tip(tip) {\n        const me = this;\n\n        me.tip?.destroy();\n\n        if (tip) {\n            me._tip = Tooltip.new({\n                owner             : me,\n                forElement        : me.svgElement,\n                forSelector       : 'rect',\n                internalListeners : {\n                    beforeShow : 'up.onBeforeTipShow'\n                }\n            }, tip);\n        }\n        else {\n            me._tip = null;\n        }\n    }\n\n    onElementResize() {\n        super.onElementResize(...arguments);\n\n        const svgRect = this.svgElement.getBoundingClientRect();\n\n        this.scaledSvgGroup.setAttribute('transform', `scale(${svgRect.width} ${svgRect.height})`);\n    }\n\n    onBeforeTipShow({ source : tip }) {\n        const index = parseInt(tip.activeTarget.dataset.index);\n\n        tip.html = tip.contentTemplate({\n            histogram : this,\n            index\n        });\n    }\n\n    updateSeries(value) {\n        const\n            me     = this,\n            series = me._series = {};\n\n        let\n            index = 0,\n            barSeriesCount = 0;\n\n        for (const id in value) {\n            // Providing\n            //\n            // \"series\" : {\n            //     \"foo\" : false\n            //     ...\n            //\n            // disables the \"foo\" series (that could be defined on a prototype level for example)\n\n            if (value[id] !== false) {\n                const data = series[id] = Objects.merge({}, value[id]);\n\n                // default field name is series identifier\n                if (!data.field) {\n                    data.field = id;\n                }\n\n                // default type is \"bar\"\n                if (!data.type) {\n                    data.type = 'bar';\n                }\n\n                if (!('order' in data)) {\n                    data.order = typePrio[data.type] * 10 + index;\n                }\n\n                if (!('index' in data)) {\n                    data.index = index;\n                }\n\n                if (data.type === 'bar') {\n                    data.index = barSeriesCount++;\n                }\n\n                data.id = id;\n                index++;\n            }\n        }\n\n        // Calculate the top value from all the series\n        if (!me.topValue && me._data) {\n            me.topValue = me.getDataTopValue(me._data);\n        }\n\n        if (!me.refreshSuspended) {\n            me.scheduleRefresh();\n        }\n    }\n\n    getDataTopValue(data, series) {\n        const fields   = Object.values(series || this.series).map(getField);\n\n        let result = 0, datum;\n\n        for (let i = 0, { length } = data; i < length; i++) {\n            datum = data[i];\n            for (let j = 0, { length } = fields; j < length; j++) {\n                result = Math.max(result, datum[fields[j]]);\n            }\n        }\n\n        return result;\n    }\n\n    updateData(data) {\n        const me = this;\n\n        me._data = data;\n\n        // Calculate the top value from all the series\n        if (!me.topValue && me._data && me._series) {\n            me.topValue = me.getDataTopValue(data);\n        }\n\n        if (!me.refreshSuspended) {\n            me.scheduleRefresh();\n        }\n    }\n\n    updateTopValue(value) {\n        const me = this;\n\n        me._topValue = value;\n\n        // Calculate the top value from all the series\n        if (!value && me._data) {\n            me._topValue = me.getDataTopValue(me._data);\n        }\n\n        if (!me.refreshSuspended) {\n            me.scheduleRefresh();\n        }\n    }\n\n    // Must exist from the start because configuration setters call it.\n    // Once configured, will be replaced with a function which schedules a refresh for the next animation frame.\n    scheduleRefresh() {\n\n    }\n\n    suspendRefresh() {\n        this.refreshSuspended++;\n    }\n\n    resumeRefresh() {\n        if (this.refreshSuspended) {\n            this.refreshSuspended--;\n        }\n    }\n\n    refresh(params) {\n        const\n            me             = this,\n            {\n                series,\n                _tip,\n                topValue,\n                singleTextForAllBars\n            }              = me,\n            // extra arguments to pass through\n            extraArgs = params?.args || [],\n            histogramElements = [],\n            textElements = [];\n\n        // bail out if there is no series provided\n        if (!series) {\n            return;\n        }\n\n        for (const data of Object.values(series).sort(byOrder)) {\n            const elConfig = me[`draw${StringHelper.capitalize(data.type)}`](data, ...extraArgs);\n\n            if (Array.isArray(elConfig)) {\n                histogramElements.push.apply(histogramElements, elConfig);\n            }\n            else {\n                histogramElements.push(elConfig);\n            }\n\n            // if it's told we should have separate texts for bars\n            if (!singleTextForAllBars && data.type === 'bar') {\n                textElements.push(...me.drawText(data, ...extraArgs));\n            }\n        }\n\n        // sort again since user could change order in a hook\n        histogramElements.sort(byDatasetOrder);\n\n        if (singleTextForAllBars) {\n            textElements.push(...me.drawText(null, ...extraArgs));\n        }\n        else {\n            textElements.sort(byDatasetOrder);\n        }\n\n        DomSync.sync({\n            domConfig : {\n                width               : '100%',\n                height              : '100%',\n                preserveAspectRatio : 'none',\n                dataset             : {\n                    topValue\n                },\n                children : [\n                    {\n                        ns,\n                        tag       : 'g',\n                        reference : 'scaledSvgGroup',\n                        children  : histogramElements\n                    },\n                    {\n                        ns,\n                        tag       : 'g',\n                        reference : 'unscaledSvgGroup',\n                        children  : textElements\n                    }\n                ]\n            },\n            configEquality : returnFalse,\n            targetElement  : me.svgElement\n        });\n\n        if (_tip && _tip.isVisible) {\n            me.onBeforeTipShow({ source : _tip });\n        }\n    }\n\n    drawBar(series, ...args) {\n        const\n            me           = this,\n            {\n                topValue,\n                data,\n                omitZeroHeightBars,\n                barStyle\n            }            = me,\n            {\n                field,\n                order,\n                stretch\n            }            = series,\n            { length }   = data,\n            defaultWidth = 1 / length,\n            children     = [],\n            seriesId     = StringHelper.createId(series.id),\n            seriesIndex  = series.index,\n            forceHeight  = stretch ? 1 : undefined;\n\n        let width;\n\n        for (let index = 0, x = 0, { length } = data; index < length; index++, x += width) {\n            const datum = data[index];\n\n            let rectConfig = (datum.rectConfig = {\n                ns,\n                tag     : 'rect',\n                dataset : {}\n            });\n\n            const\n                value = datum[field],\n                // limit height with topValue otherwise the histogram looks fine\n                // yet the bar tooltip picks wrong Y-coordinate and there is an empty space between it and the bar\n                height = value ? forceHeight || datum.height || (value > topValue ? topValue : value) / topValue : 0,\n                y = 1 - height,\n                barTip = me.callback('getBarTip', me, [series, rectConfig, datum, index, ...args]);\n\n            // use either provided width or the calculated value\n            width = datum.width || defaultWidth;\n\n            if (barStyle) {\n                rectConfig.style = barStyle;\n            }\n            else {\n                delete rectConfig.style;\n            }\n\n            Object.assign(rectConfig.dataset, {\n                index,\n                order,\n                series : seriesId\n            });\n\n            const\n                rectClass = {\n                    [`b-series-${seriesId}`]          : 1,\n                    [`b-series-index-${seriesIndex}`] : 1\n                },\n                classes = me.callback('getRectClass', me, [series, rectConfig, datum, index, ...args]);\n\n            if (classes) {\n                classes.split(classesDelimiter).forEach(cls => rectClass[cls] = 1);\n            }\n\n            Object.assign(rectConfig, {\n                x,\n                y,\n                width,\n                height,\n                class : rectClass\n            });\n\n            if (barTip) {\n                rectConfig.dataset.btip = barTip;\n            }\n            else {\n                delete rectConfig.dataset.btip;\n            }\n\n            if (me.getRectConfig) {\n                rectConfig = me.getRectConfig(rectConfig, datum, index, series, ...args);\n            }\n\n            if (rectConfig && (rectConfig.height || !omitZeroHeightBars)) {\n                children.push(rectConfig);\n            }\n        }\n        return children;\n    }\n\n    changeGetRectConfig(fn) {\n        return fn ? this.bindCallback(fn) : null;\n    }\n\n    drawOutline(series, ...args) {\n        const\n            me           = this,\n            {\n                topValue,\n                data\n            }            = me,\n            {\n                field,\n                order,\n                id\n            }            = series,\n            defaultWidth = 1 / data.length,\n            coords       = ['M 0,1'],\n            result       = {\n                ns,\n                tag     : 'path',\n                dataset : {\n                    order,\n                    id\n                }\n            };\n\n        let\n            barWidth,\n            command1 = 'M',\n            command2 = 'L';\n\n        for (let i = 0, x = 0, { length } = data; i < length; i++) {\n            const barHeight = 1 - data[i][field] / topValue;\n\n            // use either provided with or the calculated value\n            barWidth = data[i].width || defaultWidth;\n\n            coords.push(`${command1} ${x},${barHeight} ${command2} ${x += barWidth},${barHeight}`);\n            command1 = command2 = '';\n        }\n        // coords.push('1,1');\n\n        result.class = `b-series-${series.id} b-series-index-${series.index} ` +\n            me.callback('getOutlineClass', me, [series, data, ...args]);\n\n        result.d = coords.join(' ');\n\n        return result;\n    }\n\n    drawText(series, ...args) {\n        const\n            me                = this,\n            { data }          = me,\n            defaultWidth      = 1 / data.length,\n            defaultY          = '100%',\n            unscaledSvgGroups = [];\n\n        for (let index = 0, width, x = 0, { length } = data; index < length; index++, x += width) {\n            width = data[index].width || defaultWidth;\n\n            const barText = me.callback('getBarText', me, [data[index], index, series, ...args]);\n\n            if (barText) {\n\n                const renderData = me.callback('getBarTextRenderData', me, [{\n                    ns,\n                    tag       : 'text',\n                    className : 'b-bar-legend',\n                    html      : barText,\n                    left      : x,\n                    width,\n                    x         : `${(x + width / 2) * 100}%`,\n                    y         : data[index].y !== undefined ? data[index].y : defaultY,\n                    dataset   : {\n                        index,\n                        series\n                    }\n                }, data[index], index, series, ...args]);\n\n                const barTip = me.callback('getBarTextTip', me, [renderData, data[index], index, series, ...args]);\n                if (barTip) {\n                    renderData.dataset.btip = barTip;\n                }\n                else {\n                    delete renderData.dataset.btip;\n                }\n\n                unscaledSvgGroups.push(renderData);\n            }\n        }\n\n        return unscaledSvgGroups;\n    }\n\n    //endregion\n}\n\nHistogram.initClass();\n", "import Widget from '../Widget.js';\nimport DomSync from '../../helper/DomSync.js';\n\n/**\n * @module Core/widget/graph/Scale\n */\nconst\n    ns = 'http://www.w3.org/2000/svg';\n\n/**\n * Displays a scale with ticks and labels.\n * @extends Core/widget/Widget\n * @classtype scale\n */\nexport default class Scale extends Widget {\n    //region Config\n\n    static get type() {\n        return 'scale';\n    }\n\n    static get $name() {\n        return 'Scale';\n    }\n\n    static get configurable() {\n        return {\n            scalePoints : null,\n\n            // Padding after the max scale point.\n            // Expressed as the share of the height.\n            scaleMaxPadding : 0.1,\n\n            /**\n             * Configure as `true` to create a horizontal scale. Scales are vertical by default.\n             * @config {Boolean}\n             */\n            horizontal : false,\n\n            /**\n             * Side to align the scale to. Defaults to `bottom` for {@link #config-horizontal} Scales\n             * and `right` for vertical Scales.\n             * @config {String}\n             */\n            align : {\n                value   : false,\n                $config : {\n                    merge : 'replace'\n                }\n            },\n\n            element : {\n                children : [{\n                    ns,\n                    tag                 : 'svg',\n                    reference           : 'svgElement',\n                    width               : '100%',\n                    height              : '100%',\n                    preserveAspectRatio : 'none',\n                    children            : [{\n                        ns,\n                        tag       : 'g',\n                        reference : 'scaledSvgGroup',\n                        children  : [{\n                            ns,\n                            tag       : 'path',\n                            reference : 'pathElement'\n                        }]\n                    }, {\n                        ns,\n                        tag       : 'g',\n                        reference : 'unscaledSvgGroup'\n                    }]\n                }]\n            },\n\n            monitorResize : true\n        };\n    }\n\n    //endregion\n\n    //region Init\n\n    construct(config) {\n        super.construct(config);\n        this.scheduleRefresh = this.createOnFrame(this.refresh, [], this, true);\n        this.refresh();\n    }\n\n    changeAlign(align) {\n        if (!align) {\n            align = this.horizontal ? 'bottom' : 'right';\n        }\n        return align;\n    }\n\n    updateAlign(align, oldAlign) {\n        this.element.classList.remove(`b-align-${oldAlign}`);\n        this.element.classList.add(`b-align-${align}`);\n    }\n\n    updateHorizontal(horizontal, oldHorizontal) {\n        this.element.classList.remove(`b-scale-${oldHorizontal ? 'horizontal' : 'vertical'}`);\n        this.element.classList.add(`b-scale-${horizontal ? 'horizontal' : 'vertical'}`);\n    }\n\n    onElementResize() {\n        super.onElementResize(...arguments);\n        this.scheduleRefresh();\n    }\n\n    // Must exist from the start because configuration setters call it.\n    // Once configured, will be replaced with a function which schedules a refresh for the next animation frame.\n    scheduleRefresh() {\n\n    }\n\n    refresh() {\n        if (!this.scalePoints) {\n            return;\n        }\n\n        const\n            me             = this,\n            {\n                horizontal,\n                width,\n                height,\n                align,\n                scalePoints,\n                scaleMaxPadding\n            }                  = me,\n            scaleMax           = scalePoints[scalePoints.length - 1]?.value,\n            path               = [],\n            labels             = [];\n\n        const posFactor = 1 / (scaleMax + scaleMaxPadding * scaleMax);\n\n        me.scaledSvgGroup.setAttribute('transform', `scale(${horizontal ? width : 1} ${horizontal ? 1 : height})`);\n\n        for (const point of scalePoints) {\n            const isLabelStep = Boolean(point.text),\n                pos = posFactor * point.value;\n\n            if (isLabelStep) {\n                const label = {\n                    ns,\n                    tag       : 'text',\n                    className : 'b-scale-tick-label',\n                    html      : point.text,\n                    dataset   : {\n                        tick : point.value\n                    }\n                };\n\n                if (horizontal) {\n                    label.x = `${pos * 100}%`;\n                    label.y = align === 'top' ? '1.6em' : height - 12;\n                }\n                else {\n                    label.x = align === 'left' ? '12' : `${width - 12}`;\n                    label.y = `${(1 - pos) * 100}%`;\n                }\n                labels.push(label);\n            }\n\n            if (horizontal) {\n                if (align === 'top') {\n                    path.push(`M${pos},0 L${pos},${isLabelStep ? 10 : 5}`);\n                }\n                else {\n                    path.push(`M${pos},${height} L${pos},${height - (isLabelStep ? 10 : 5)}`);\n                }\n            }\n            else {\n                if (align === 'left') {\n                    path.push(`M0,${1 - pos} L${isLabelStep ? 10 : 5},${1 - pos}`);\n                }\n                else {\n                    path.push(`M${width},${1 - pos} L${width - (isLabelStep ? 10 : 5)},${1 - pos}`);\n                }\n            }\n        }\n        me.pathElement.setAttribute('d', path.join(''));\n        DomSync.syncChildren({\n            domConfig : { children : labels }\n        }, me.unscaledSvgGroup);\n    }\n\n    //endregion\n}\nScale.initClass();\n"],
  "mappings": "sQAQA,MACIA,EAAK,6BAELC,EAAW,CACPC,IAAU,EACVC,QAAU,EACVC,KAAU,GAEdC,EAAUA,CAACC,EAAGC,IAAMC,SAASF,EAAEG,MAAO,EAAE,EAAID,SAASD,EAAEE,MAAO,EAAE,EAChEC,EAAiBA,CAACJ,EAAGC,IAAMC,SAASF,EAAEK,QAAQF,MAAO,EAAE,EAAID,SAASD,EAAEI,QAAQF,MAAO,EAAE,EACvFG,EAAWC,GAAKA,EAAEC,MAClBC,EAAcA,IAAM,GACpBC,EAAmB,MA0BR,MAAMC,UAAkBC,CAAO,CAI1C,WAAWC,cAAe,CACtB,MAAO,CAOHC,KAAO,KAKPC,OAAS,KAUTC,OAAS,KAMTC,SAAW,KACXC,QAAU,CACNC,SAAW,CAAC,IACRzB,EACA0B,IAAsB,MACtBC,UAAsB,aACtBC,MAAsB,OACtBC,OAAsB,OACtBC,oBAAsB,OACtBL,SAAsB,CAAC,IACnBzB,EACA0B,IAAY,IACZC,UAAY,gBAChB,EAAG,IACC3B,EACA0B,IAAY,IACZC,UAAY,mBACf,EACJ,GAQLI,mBAAqB,GASrBC,qBAAuB,GACvBC,cAAgB,GAWhBC,aAAaZ,EAAQa,EAAYC,EAAOC,EAAO,CAC3C,MAAO,IAWXC,gBAAgBhB,EAAQF,EAAM,CAC1B,MAAO,IAWXmB,UAAUjB,EAAQa,EAAYC,EAAOC,EAAO,CAAA,EAW5CG,WAAWJ,EAAOC,EAAOf,EAAQ,CAC7B,MAAO,IAEXmB,cAAgB,KAChBC,qBAAqBC,EAAYP,EAAOC,EAAOf,EAAQ,CACnD,OAAOqB,GAEXC,cAAcD,EAAYP,EAAOC,EAAOf,EAAQ,CAAA,EAExD,CAMAuB,UAAUC,EAAQ,CACd,MAAMC,EAAK,KACX,MAAMF,UAAUC,CAAM,EACtBC,EAAGC,gBAAkBD,EAAGE,cAAcF,EAAGG,QAAS,CAAA,EAAIH,EAAI,EAAI,EAC9DA,EAAGG,QAAO,CACd,CACA,IAAIC,IAAIA,EAAK,CAAA,IAAAC,EACT,MAAML,EAAK,MACXK,EAAAL,EAAGI,OAAG,MAAAC,IAAA,QAANA,EAAQC,QAAO,EACXF,EACAJ,EAAGO,KAAOC,EAAQC,IAAI,CAClBC,MAAoBV,EACpBW,WAAoBX,EAAGY,WACvBC,YAAoB,OACpBC,kBAAoB,CAChBC,WAAa,oBACjB,GACDX,CAAG,EAGNJ,EAAGO,KAAO,IAElB,CACAS,iBAAkB,CACd,MAAMA,gBAAgB,GAAGC,SAAS,EAClC,MAAMC,EAAU,KAAKN,WAAWO,sBAAqB,EACrD,KAAKC,eAAeC,aAAa,YAAc,SAAQH,EAAQrC,SAASqC,EAAQpC,SAAS,CAC7F,CACAwC,gBAAgB,CAAEC,OAASnB,CAAI,EAAG,CAC9B,MAAMd,EAAQ7B,SAAS2C,EAAIoB,aAAa5D,QAAQ0B,KAAK,EACrDc,EAAIqB,KAAOrB,EAAIsB,gBAAgB,CAC3BC,UAAY,KACZrC,MAAAA,CACJ,CAAC,CACL,CACAsC,aAAaC,EAAO,CAChB,MACI7B,EAAS,KACTzB,EAASyB,EAAG8B,QAAU,CAAA,EAC1B,IACIxC,EAAQ,EACRyC,EAAiB,EACrB,UAAWC,KAAMH,EAQb,GAAIA,EAAMG,CAAE,IAAM,GAAO,CACrB,MAAM3D,EAAOE,EAAOyD,CAAE,EAAIC,EAAQC,MAAM,CAAA,EAAIL,EAAMG,CAAE,CAAC,EAEhD3D,EAAKN,QACNM,EAAKN,MAAQiE,GAGZ3D,EAAK8D,OACN9D,EAAK8D,KAAO,OAEV,UAAW9D,IACbA,EAAKX,MAAQR,EAASmB,EAAK8D,IAAI,EAAI,GAAK7C,GAEtC,UAAWjB,IACbA,EAAKiB,MAAQA,GAEbjB,EAAK8D,OAAS,QACd9D,EAAKiB,MAAQyC,KAEjB1D,EAAK2D,GAAKA,EACV1C,IAIJ,CAACU,EAAGxB,UAAYwB,EAAGoC,QACnBpC,EAAGxB,SAAWwB,EAAGqC,gBAAgBrC,EAAGoC,KAAK,GAExCpC,EAAGsC,kBACJtC,EAAGC,gBAAe,CAE1B,CACAoC,gBAAgBhE,EAAME,EAAQ,CAC1B,MAAMgE,EAAWC,OAAOlE,OAAOC,GAAU,KAAKA,MAAM,EAAEkE,IAAI5E,CAAQ,EAClE,IAAI6E,EAAS,EAAGrD,EAChB,QAASsD,EAAI,EAAG,CAAEC,OAAAA,GAAWvE,EAAMsE,EAAIC,EAAQD,IAAK,CAChDtD,EAAQhB,EAAKsE,CAAC,EACd,QAASE,EAAI,EAAG,CAAED,OAAAA,GAAWL,EAAQM,EAAID,EAAQC,IAC7CH,EAASI,KAAKC,IAAIL,EAAQrD,EAAMkD,EAAOM,CAAC,CAAC,CAAC,EAGlD,OAAOH,CACX,CACAM,WAAW3E,EAAM,CACb,MAAM2B,EAAK,KACXA,EAAGoC,MAAQ/D,EAEP,CAAC2B,EAAGxB,UAAYwB,EAAGoC,OAASpC,EAAG8B,UAC/B9B,EAAGxB,SAAWwB,EAAGqC,gBAAgBhE,CAAI,GAEpC2B,EAAGsC,kBACJtC,EAAGC,gBAAe,CAE1B,CACAgD,eAAepB,EAAO,CAClB,MAAM7B,EAAK,KACXA,EAAGkD,UAAYrB,EAEX,CAACA,GAAS7B,EAAGoC,QACbpC,EAAGkD,UAAYlD,EAAGqC,gBAAgBrC,EAAGoC,KAAK,GAEzCpC,EAAGsC,kBACJtC,EAAGC,gBAAe,CAE1B,CAGAA,iBAAkB,CAAA,CAElBkD,gBAAiB,CACb,KAAKb,kBACT,CACAc,eAAgB,CACR,KAAKd,kBACL,KAAKA,kBAEb,CACAnC,QAAQkD,EAAQ,CACZ,MACIrD,EAAiB,KACjB,CACIzB,OAAAA,EACAgC,KAAAA,EACA/B,SAAAA,EACAS,qBAAAA,CACJ,EAAiBe,EAEjBsD,GAAYD,GAAAA,KAAM,OAANA,EAAQE,OAAQ,CAAA,EAC5BC,EAAoB,CAAA,EACpBC,EAAe,CAAA,EAEnB,GAAKlF,EAGL,WAAWF,KAAQmE,OAAOlE,OAAOC,CAAM,EAAEmF,KAAKpG,CAAO,EAAG,CACpD,MAAMqG,EAAW3D,EAAI,OAAM4D,EAAaC,WAAWxF,EAAK8D,IAAI,GAAG,EAAE9D,EAAM,GAAGiF,CAAS,EAC/EQ,MAAMC,QAAQJ,CAAQ,EACtBH,EAAkBQ,KAAKC,MAAMT,EAAmBG,CAAQ,EAGxDH,EAAkBQ,KAAKL,CAAQ,EAG/B,CAAC1E,GAAwBZ,EAAK8D,OAAS,OACvCsB,EAAaO,KAAK,GAAGhE,EAAGkE,SAAS7F,EAAM,GAAGiF,CAAS,CAAC,EAI5DE,EAAkBE,KAAK/F,CAAc,EACjCsB,EACAwE,EAAaO,KAAK,GAAGhE,EAAGkE,SAAS,KAAM,GAAGZ,CAAS,CAAC,EAGpDG,EAAaC,KAAK/F,CAAc,EAEpCwG,EAAQC,KAAK,CACTC,UAAY,CACRxF,MAAsB,OACtBC,OAAsB,OACtBC,oBAAsB,OACtBnB,QAAsB,CAClBY,SAAAA,GAEJE,SAAW,CACP,IACIzB,EACA0B,IAAY,IACZC,UAAY,iBACZF,SAAY8E,CAChB,EACA,IACIvG,EACA0B,IAAY,IACZC,UAAY,mBACZF,SAAY+E,EACf,GAGTa,eAAiBtG,EACjBuG,cAAiBvE,EAAGY,UACxB,CAAC,EACGL,GAAQA,EAAKiE,WACbxE,EAAGsB,gBAAgB,CAAEC,OAAShB,CAAK,CAAC,EAE5C,CACAkE,QAAQlG,KAAWgF,EAAM,CACrB,MACIvD,EAAe,KACf,CACIxB,SAAAA,EACAH,KAAAA,EACAW,mBAAAA,EACA0F,SAAAA,CACJ,EAAe1E,EACf,CACIjC,MAAAA,EACAL,MAAAA,EACAiH,QAAAA,CACJ,EAAepG,EACf,CAAEqE,OAAAA,CAAO,EAAMvE,EACfuG,EAAe,EAAIhC,EACnBlE,EAAe,CAAA,EACfmG,EAAejB,EAAakB,SAASvG,EAAOyD,EAAE,EAC9C+C,EAAexG,EAAOe,MACtB0F,EAAeL,EAAU,EAAIM,OACjC,IAAIpG,EACJ,QAASS,EAAQ,EAAG4F,EAAI,EAAG,CAAEtC,OAAAA,CAAO,EAAIvE,EAAMiB,EAAQsD,EAAQtD,IAAS4F,GAAKrG,EAAO,CAC/E,MAAMQ,EAAQhB,EAAKiB,CAAK,EACxB,IAAIF,EAAcC,EAAMD,WAAa,IACjCnC,EACA0B,IAAU,OACVf,QAAU,CAAA,GAEd,MACIiE,EAAQxC,EAAMtB,CAAK,EAGnBe,EAAS+C,EAAQmD,GAAe3F,EAAMP,SAAW+C,EAAQrD,EAAWA,EAAWqD,GAASrD,EAAW,EACnG2G,EAAI,EAAIrG,EACRsG,EAASpF,EAAGqF,SAAS,YAAarF,EAAI,CAACzB,EAAQa,EAAYC,EAAOC,EAAO,GAAGiE,CAAI,CAAC,EAErF1E,EAAQQ,EAAMR,OAAS+F,EACnBF,EACAtF,EAAWkG,MAAQZ,EAGnB,OAAOtF,EAAWkG,MAEtB9C,OAAO+C,OAAOnG,EAAWxB,QAAS,CAC9B0B,MAAAA,EACA5B,MAAAA,EACAa,OAASsG,CACb,CAAC,EACD,MACIW,EAAY,CACR,CAAE,YAAWX,GAAU,EAAa,EACpC,CAAE,kBAAiBE,GAAa,EAAI,GAExCU,EAAUzF,EAAGqF,SAAS,eAAgBrF,EAAI,CAACzB,EAAQa,EAAYC,EAAOC,EAAO,GAAGiE,CAAI,CAAC,EACrFkC,GACAA,EAAQC,MAAMzH,CAAgB,EAAE0H,QAAQC,GAAOJ,EAAUI,CAAG,EAAI,CAAC,EAErEpD,OAAO+C,OAAOnG,EAAY,CACtB8F,EAAAA,EACAC,EAAAA,EACAtG,MAAAA,EACAC,OAAAA,EACA+G,MAAQL,CACZ,CAAC,EACGJ,EACAhG,EAAWxB,QAAQkI,KAAOV,EAG1B,OAAOhG,EAAWxB,QAAQkI,KAE1B9F,EAAGN,gBACHN,EAAaY,EAAGN,cAAcN,EAAYC,EAAOC,EAAOf,EAAQ,GAAGgF,CAAI,GAEvEnE,IAAeA,EAAWN,QAAU,CAACE,IACrCN,EAASsF,KAAK5E,CAAU,EAGhC,OAAOV,CACX,CACAqH,oBAAoBC,EAAI,CACpB,OAAOA,EAAK,KAAKC,aAAaD,CAAE,EAAI,IACxC,CACAE,YAAY3H,KAAWgF,EAAM,CACzB,MACIvD,EAAe,KACf,CACIxB,SAAAA,EACAH,KAAAA,CACJ,EAAe2B,EACf,CACIjC,MAAAA,EACAL,MAAAA,EACAsE,GAAAA,CACJ,EAAezD,EACfqG,EAAe,EAAIvG,EAAKuE,OACxBuD,EAAe,CAAC,OAAO,EACvBzD,EAAe,IACXzF,EACA0B,IAAU,OACVf,QAAU,CACNF,MAAAA,EACAsE,GAAAA,CACJ,GAER,IACIoE,EACAC,EAAW,IACXC,EAAW,IACf,QAAS3D,EAAI,EAAGuC,EAAI,EAAG,CAAEtC,OAAAA,GAAWvE,EAAMsE,EAAIC,EAAQD,IAAK,CACvD,MAAM4D,EAAY,EAAIlI,EAAKsE,CAAC,EAAE5E,CAAK,EAAIS,EAEvC4H,EAAW/H,EAAKsE,CAAC,EAAE9D,OAAS+F,EAC5BuB,EAAOnC,KAAM,GAAEqC,KAAYnB,KAAKqB,KAAaD,KAAYpB,GAAKkB,KAAYG,GAAW,EACrFF,EAAWC,EAAW,GAG1B5D,OAAAA,EAAOmD,MAAS,YAAWtH,EAAOyD,qBAAqBzD,EAAOe,SAC1DU,EAAGqF,SAAS,kBAAmBrF,EAAI,CAACzB,EAAQF,EAAM,GAAGkF,CAAI,CAAC,EAC9Db,EAAO8D,EAAIL,EAAOM,KAAK,GAAG,EACnB/D,CACX,CACAwB,SAAS3F,KAAWgF,EAAM,CACtB,MACIvD,EAAoB,KACpB,CAAE3B,KAAAA,CAAK,EAAa2B,EACpB4E,EAAoB,EAAIvG,EAAKuE,OAC7B8D,EAAoB,OACpBC,EAAoB,CAAA,EACxB,QAASrH,EAAQ,EAAGT,EAAOqG,EAAI,EAAG,CAAEtC,OAAAA,CAAO,EAAIvE,EAAMiB,EAAQsD,EAAQtD,IAAS4F,GAAKrG,EAAO,CACtFA,EAAQR,EAAKiB,CAAK,EAAET,OAAS+F,EAC7B,MAAMgC,EAAU5G,EAAGqF,SAAS,aAAcrF,EAAI,CAAC3B,EAAKiB,CAAK,EAAGA,EAAOf,EAAQ,GAAGgF,CAAI,CAAC,EACnF,GAAIqD,EAAS,CACT,MAAMhH,EAAaI,EAAGqF,SAAS,uBAAwBrF,EAAI,CAAC,IACxD/C,EACA0B,IAAY,OACZkI,UAAY,eACZpF,KAAYmF,EACZE,KAAY5B,EACZrG,MAAAA,EACAqG,EAAa,IAAGA,EAAIrG,EAAQ,GAAK,OACjCsG,EAAY9G,EAAKiB,CAAK,EAAE6F,IAAMF,OAAY5G,EAAKiB,CAAK,EAAE6F,EAAIuB,EAC1D9I,QAAY,CACR0B,MAAAA,EACAf,OAAAA,CACJ,CACJ,EAAGF,EAAKiB,CAAK,EAAGA,EAAOf,EAAQ,GAAGgF,CAAI,CAAC,EACjC6B,EAASpF,EAAGqF,SAAS,gBAAiBrF,EAAI,CAACJ,EAAYvB,EAAKiB,CAAK,EAAGA,EAAOf,EAAQ,GAAGgF,CAAI,CAAC,EAC7F6B,EACAxF,EAAWhC,QAAQkI,KAAOV,EAG1B,OAAOxF,EAAWhC,QAAQkI,KAE9Ba,EAAkB3C,KAAKpE,CAAU,GAGzC,OAAO+G,CACX,CAEJ,CAjeII,EAFiB7I,EAEViE,OAAO,aACd4E,EAHiB7I,EAGV8I,QAAQ,aA0HfD,EA7HiB7I,EA6HV+I,aAAa,CAChB3E,iBAAmB,IAsW3BpE,EAAUgJ,UAAS,EACnBhJ,EAAUiJ,OAAS,YC9gBnB,MACIlK,EAAK,6BAMM,MAAMmK,UAAcjJ,CAAO,CAEtC,WAAWgE,MAAO,CACd,MAAO,OACX,CACA,WAAW6E,OAAQ,CACf,MAAO,OACX,CACA,WAAW5I,cAAe,CACtB,MAAO,CACHiJ,YAAc,KAGdC,gBAAkB,GAKlBC,WAAa,GAMbC,MAAQ,CACJ3F,MAAU,GACV4F,QAAU,CACNvF,MAAQ,SACZ,GAEJzD,QAAU,CACNC,SAAW,CAAC,CACRzB,GAAAA,EACA0B,IAAsB,MACtBC,UAAsB,aACtBC,MAAsB,OACtBC,OAAsB,OACtBC,oBAAsB,OACtBL,SAAsB,CAAC,CACnBzB,GAAAA,EACA0B,IAAY,IACZC,UAAY,iBACZF,SAAY,CAAC,CACTzB,GAAAA,EACA0B,IAAY,OACZC,UAAY,cACf,CACL,EAAG,CACC3B,GAAAA,EACA0B,IAAY,IACZC,UAAY,mBACf,EACJ,GAELM,cAAgB,GAExB,CAGAY,UAAUC,EAAQ,CACd,MAAMD,UAAUC,CAAM,EACtB,KAAKE,gBAAkB,KAAKC,cAAc,KAAKC,QAAS,CAAA,EAAI,KAAM,EAAI,EACtE,KAAKA,QAAO,CAChB,CACAuH,YAAYF,EAAO,CACf,OAAKA,IACDA,EAAQ,KAAKD,WAAa,SAAW,SAElCC,CACX,CACAG,YAAYH,EAAOI,EAAU,CACzB,KAAKnJ,QAAQoJ,UAAUC,OAAQ,WAAUF,GAAU,EACnD,KAAKnJ,QAAQoJ,UAAUE,IAAK,WAAUP,GAAO,CACjD,CACAQ,iBAAiBT,EAAYU,EAAe,CACxC,KAAKxJ,QAAQoJ,UAAUC,OAAQ,WAAUG,EAAgB,aAAe,YAAY,EACpF,KAAKxJ,QAAQoJ,UAAUE,IAAK,WAAUR,EAAa,aAAe,YAAY,CAClF,CACAvG,iBAAkB,CACd,MAAMA,gBAAgB,GAAGC,SAAS,EAClC,KAAKhB,gBAAe,CACxB,CAGAA,iBAAkB,CAAA,CAElBE,SAAU,CAAA,IAAA+H,EACN,GAAI,CAAC,KAAKb,YACN,OAEJ,MACIrH,EAAiB,KACjB,CACIuH,WAAAA,EACA1I,MAAAA,EACAC,OAAAA,EACA0I,MAAAA,EACAH,YAAAA,EACAC,gBAAAA,CACJ,EAAqBtH,EACrBmI,GAAQD,EAAab,EAAYA,EAAYzE,OAAS,CAAC,KAACsF,MAAAA,IAAnCA,OAAAA,OAAAA,EAAqCrG,MAC1DuG,EAAqB,CAAA,EACrBC,EAAqB,CAAA,EACnBC,EAAY,GAAKH,EAAWb,EAAkBa,GACpDnI,EAAGoB,eAAeC,aAAa,YAAc,SAAQkG,EAAa1I,EAAQ,KAAK0I,EAAa,EAAIzI,IAAS,EACzG,UAAWyJ,KAASlB,EAAa,CAC7B,MAAMmB,EAAcC,EAAQF,EAAMlL,KAC9BqL,EAAMJ,EAAYC,EAAM1G,MAC5B,GAAI2G,EAAa,CACb,MAAMG,EAAQ,CACV1L,GAAAA,EACA0B,IAAY,OACZkI,UAAY,qBACZpF,KAAY8G,EAAMlL,KAClBO,QAAY,CACRgL,KAAOL,EAAM1G,KACjB,GAEA0F,GACAoB,EAAMzD,EAAK,GAAEwD,EAAM,OACnBC,EAAMxD,EAAIqC,IAAU,MAAQ,QAAU1I,EAAS,KAG/C6J,EAAMzD,EAAIsC,IAAU,OAAS,KAAQ,GAAE3I,EAAQ,KAC/C8J,EAAMxD,EAAK,IAAG,EAAIuD,GAAO,QAE7BL,EAAOrE,KAAK2E,CAAK,EAEjBpB,EACIC,IAAU,MACVY,EAAKpE,KAAM,IAAG0E,QAAUA,KAAOF,EAAc,GAAK,GAAG,EAGrDJ,EAAKpE,KAAM,IAAG0E,KAAO5J,MAAW4J,KAAO5J,GAAU0J,EAAc,GAAK,IAAI,EAIxEhB,IAAU,OACVY,EAAKpE,KAAM,MAAK,EAAI0E,MAAQF,EAAc,GAAK,KAAK,EAAIE,GAAK,EAG7DN,EAAKpE,KAAM,IAAGnF,KAAS,EAAI6J,MAAQ7J,GAAS2J,EAAc,GAAK,MAAM,EAAIE,GAAK,EAI1F1I,EAAG6I,YAAYxH,aAAa,IAAK+G,EAAK3B,KAAK,EAAE,CAAC,EAC9CtC,EAAQ2E,aAAa,CACjBzE,UAAY,CAAE3F,SAAW2J,CAAO,CACpC,EAAGrI,EAAG+I,gBAAgB,CAC1B,CAEJ,CACA3B,EAAMF,UAAS,EACfE,EAAMD,OAAS",
  "names": ["ns", "typePrio", "bar", "outline", "text", "byOrder", "l", "r", "parseInt", "order", "byDatasetOrder", "dataset", "getField", "s", "field", "returnFalse", "classesDelimiter", "Histogram", "Widget", "configurable", "data", "values", "series", "topValue", "element", "children", "tag", "reference", "width", "height", "preserveAspectRatio", "omitZeroHeightBars", "singleTextForAllBars", "monitorResize", "getRectClass", "rectConfig", "datum", "index", "getOutlineClass", "getBarTip", "getBarText", "getRectConfig", "getBarTextRenderData", "renderData", "getBarTextTip", "construct", "config", "me", "scheduleRefresh", "createOnFrame", "refresh", "tip", "_me$tip", "destroy", "_tip", "Tooltip", "new", "owner", "forElement", "svgElement", "forSelector", "internalListeners", "beforeShow", "onElementResize", "arguments", "svgRect", "getBoundingClientRect", "scaledSvgGroup", "setAttribute", "onBeforeTipShow", "source", "activeTarget", "html", "contentTemplate", "histogram", "updateSeries", "value", "_series", "barSeriesCount", "id", "Objects", "merge", "type", "_data", "getDataTopValue", "refreshSuspended", "fields", "Object", "map", "result", "i", "length", "j", "Math", "max", "updateData", "updateTopValue", "_topValue", "suspendRefresh", "resumeRefresh", "params", "extraArgs", "args", "histogramElements", "textElements", "sort", "elConfig", "StringHelper", "capitalize", "Array", "isArray", "push", "apply", "drawText", "DomSync", "sync", "domConfig", "configEquality", "targetElement", "isVisible", "drawBar", "barStyle", "stretch", "defaultWidth", "seriesId", "createId", "seriesIndex", "forceHeight", "undefined", "x", "y", "barTip", "callback", "style", "assign", "rectClass", "classes", "split", "forEach", "cls", "class", "btip", "changeGetRectConfig", "fn", "bindCallback", "drawOutline", "coords", "barWidth", "command1", "command2", "barHeight", "d", "join", "defaultY", "unscaledSvgGroups", "barText", "className", "left", "__publicField", "$name", "properties", "initClass", "_$name", "Scale", "scalePoints", "scaleMaxPadding", "horizontal", "align", "$config", "changeAlign", "updateAlign", "oldAlign", "classList", "remove", "add", "updateHorizontal", "oldHorizontal", "_scalePoints", "scaleMax", "path", "labels", "posFactor", "point", "isLabelStep", "Boolean", "pos", "label", "tick", "pathElement", "syncChildren", "unscaledSvgGroup"]
}
