{
  "version": 3,
  "sources": ["../../../../Core/lib/Core/widget/Splitter.js"],
  "sourcesContent": ["import Widget from './Widget.js';\nimport DomHelper from '../helper/DomHelper.js';\nimport EventHelper from '../helper/EventHelper.js';\nimport BrowserHelper from '../helper/BrowserHelper.js';\n\n/**\n * @module Core/widget/Splitter\n */\n\nconst\n    classesHV = ['b-horizontal', 'b-vertical'],\n    hasFlex = el => DomHelper.getStyleValue(el.parentElement, 'display') === 'flex' &&\n        (parseInt(DomHelper.getStyleValue(el, 'flex-basis'), 10) || parseInt(DomHelper.getStyleValue(el, 'flex-grow'), 10)),\n    verticality = {\n        horizontal : false,\n        vertical   : true\n    };\n\n/**\n * A simple splitter widget that resizes the elements next to it or above/below it depending on orientation.\n *\n * @extends Core/widget/Widget\n * @classType splitter\n * @inlineexample Core/widget/Splitter.js\n * @widget\n */\nexport default class Splitter extends Widget {\n    //region Config\n\n    static get $name() {\n        return 'Splitter';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'splitter';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * Fired when a drag starts\n             * @event dragStart\n             * @param {Core.widget.Splitter} source The Splitter\n             * @param {MouseEvent|TouchEvent} event The DOM event\n             */\n\n            /**\n             * Fired while dragging\n             * @event drag\n             * @param {Core.widget.Splitter} source The Splitter\n             * @param {MouseEvent|TouchEvent} event The DOM event\n             */\n\n            /**\n             * Fired after a drop\n             * @event drop\n             * @param {Core.widget.Splitter} source The Splitter\n             * @param {MouseEvent|TouchEvent} event The DOM event\n             */\n\n            /**\n             * Splitter orientation, see {@link #config-orientation}. When set to 'auto' then actually used orientation\n             * can be retrieved using {@link #property-currentOrientation}.\n             * @member {'auto'|'horizontal'|'vertical'} orientation\n             * @readonly\n             */\n            /**\n             * The splitter's orientation, configurable with 'auto', 'horizontal' or 'vertical'.\n             *\n             * 'auto' tries to determine the orientation by either checking the `flex-direction` of the parent element\n             * or by comparing the positions of the closest sibling elements to the splitter. If they are above and\n             * below 'horizontal' is used, if not it uses 'vertical'.\n             *\n             * ```\n             * new Splitter({\n             *    orientation : 'horizontal'\n             * });\n             * ```\n             *\n             * To receive the actually used orientation when configured with 'auto', see\n             * {@link #property-currentOrientation}.\n             *\n             * @config {'auto'|'horizontal'|'vertical'}\n             * @default\n             */\n            orientation : 'auto',\n\n            vertical : null,\n\n            containerElement : {\n                $config : 'nullify',\n                value   : null\n            },\n\n            nextNeighbor : {\n                $config : 'nullify',\n                value   : null\n            },\n\n            previousNeighbor : {\n                $config : 'nullify',\n                value   : null\n            }\n        };\n    }\n\n    static get delayable() {\n        return {\n            syncState : 'raf'\n        };\n    }\n\n    //endregion\n\n    //region Init & destroy\n\n    doDestroy() {\n        this.mouseDetacher?.();\n\n        super.doDestroy();\n    }\n\n    //endregion\n\n    //region Template & element\n\n    compose() {\n        return {\n            class : {\n                'b-splitter' : 1\n            },\n\n            // eslint-disable-next-line bryntum/no-listeners-in-lib\n            listeners : {\n                pointerdown : 'onMouseDown',\n                mouseenter  : 'syncState',\n\n                ...(!BrowserHelper.supportsPointerEvents && {\n                    mousedown  : 'onMouseDown',\n                    touchstart : 'onMouseDown'\n                })\n            }\n        };\n    }\n\n    //endregion\n\n    //region Orientation\n\n    /**\n     * Get actually used orientation, which is either the configured value for `orientation` or if configured with\n     * 'auto' the currently used orientation.\n     * @property {String}\n     * @readonly\n     */\n    get currentOrientation() {\n        return this.vertical ? 'vertical' : 'horizontal';\n    }\n\n    getSibling(next = true) {\n        let { element } = this,\n            result;\n\n        while (!result && (element = element[`${next ? 'next' : 'previous'}ElementSibling`])) {\n            if (!element.isConnected || DomHelper.isVisible(element)) {\n                result = element;\n            }\n        }\n\n        return result;\n    }\n\n    get nextWidget() {\n        let { element } = this,\n            result;\n\n        while (!result && (element = element.nextElementSibling)) {\n            // Second arg used to be 1, but when used inside elements inside another widget (FiddlePanel), nextWidget &\n            // previousWidget would both return the outer widget\n            result = Widget.fromElement(element, this.element.parentElement);\n        }\n\n        return result;\n    }\n\n    get previousWidget() {\n        let { element } = this,\n            result;\n\n        while (!result && (element = element.previousElementSibling)) {\n            result = Widget.fromElement(element, this.element.parentElement);\n        }\n\n        return result;\n    }\n\n    updateContainerElement(containerElement) {\n        const me = this;\n\n        me.stateDetector = me.stateDetector?.disconnect();\n\n        if (containerElement) {\n            me.stateDetector = new MutationObserver(() => me.syncState());  // syncState runs on next raf\n\n            me.stateDetector.observe(containerElement, {\n                attributes : true,  // in case style changes flip our orientation (when == 'auto')\n                childList  : true   // watch for our neighbors to render (so we can disable on hidden/collapsed state)\n            });\n        }\n    }\n\n    updateNextNeighbor(next) {\n        this.watchNeighbor(next, 'next');\n    }\n\n    updatePreviousNeighbor(previous) {\n        this.watchNeighbor(previous, 'previous');\n    }\n\n    watchNeighbor(neighbor, name) {\n        this.detachListeners(name);\n\n        neighbor?.ion({\n            name,\n            thisObj  : this,\n            collapse : 'syncState',\n            expand   : 'syncState',\n            hide     : 'syncState',\n            show     : 'syncState'\n        });\n    }\n\n    updateOrientation() {\n        this.syncState.now();\n    }\n\n    updateVertical(vertical) {\n        const classList = this.element?.classList;\n\n        classList?.add(classesHV[vertical ? 1 : 0]);\n        classList?.remove(classesHV[vertical ? 0 : 1]);\n    }\n\n    /**\n     * Determine orientation when set to `'auto'` and detects neighboring widgets to monitor their hidden/collapsed\n     * states.\n     * @private\n     */\n    syncState() {\n        const\n            me                                      = this,\n            { element, nextWidget, previousWidget } = me;\n\n        let vertical = verticality[me.orientation] ?? null;\n\n        me.nextNeighbor     = nextWidget;\n        me.previousNeighbor = previousWidget;\n\n        me.disabled = (\n            nextWidget && ((nextWidget.collapsible && nextWidget.collapsed) || nextWidget.hidden)\n        ) || (\n            previousWidget && ((previousWidget.collapsible && previousWidget.collapsed) || previousWidget.hidden)\n        );\n\n        if (vertical !== null && nextWidget && previousWidget) {\n            me.containerElement = null;\n        }\n        else {\n            // we'll need to monitor parent element child list changes until our neighbors are added to the DOM\n            me.containerElement = element.parentElement;\n\n            // Orientation auto and already rendered, determine orientation to use\n            if (me.rendered && element.offsetParent) {\n                const flexDirection = DomHelper.getStyleValue(element.parentElement, 'flex-direction');\n\n                // If used in a flex layout, determine orientation from flex-direction\n                if (flexDirection) {\n                    vertical = !flexDirection.startsWith('column');\n                }\n                // If used in some other layout, try to determine from sibling elements position\n                else {\n                    const\n                        previous = element.previousElementSibling,\n                        next = element.nextElementSibling;\n\n                    if (!previous || !next) {\n                        // To early in rendering, next sibling not rendered yet\n                        return;\n                    }\n\n                    const\n                        prevRect = previous.getBoundingClientRect(),\n                        nextRect = next.getBoundingClientRect(),\n                        topMost = prevRect.top < nextRect.top ? prevRect : nextRect,\n                        bottomMost = topMost === nextRect ? prevRect : nextRect;\n\n                    // orientation = topMost.top !== bottomMost.top ? 'horizontal' : 'vertical';\n                    vertical = topMost.top === bottomMost.top;\n                }\n            }\n        }\n\n        me.vertical = vertical;\n    }\n\n    //endregion\n\n    //region Events\n\n    onMouseDown(event) {\n        event.preventDefault();\n\n        if (event.touches) {\n            event = event.touches[0];\n        }\n\n        const\n            me          = this,\n            {\n                element,\n                nextNeighbor,\n                previousNeighbor\n            } = me,\n            prev        = previousNeighbor ? previousNeighbor.element : me.getSibling(false),\n            next        = nextNeighbor ? nextNeighbor.element : me.getSibling(),\n            prevHasFlex = hasFlex(prev),\n            nextHasFlex = hasFlex(next),\n            flexed      = [];\n\n        // First stop any ongoing drag operation, since we cannot trust that we always get the mouseup event\n        me.mouseDetacher?.();\n\n        // Remember flexed children, to enable maintaining their proportions on resize\n        for (const child of element.parentElement.children) {\n            if (hasFlex(child) && child !== element) {\n                flexed.push({\n                    element : child,\n                    width   : child.offsetWidth,\n                    height  : child.offsetHeight\n                });\n            }\n        }\n\n        me.context = {\n            startX     : event.pageX,\n            startY     : event.pageY,\n            prevWidth  : prev.offsetWidth,\n            prevHeight : prev.offsetHeight,\n            nextWidth  : next.offsetWidth,\n            nextHeight : next.offsetHeight,\n            prevHasFlex,\n            nextHasFlex,\n            flexed,\n            prev,\n            next\n        };\n\n        const events = {\n            element     : document,\n            pointermove : 'onMouseMove',\n            pointerup   : 'onMouseUp',\n            thisObj     : me\n        };\n\n        // <remove-on-release>\n        // TODO: Re-evaluate if this is needed in 2023, https://caniuse.com/pointer\n        // </remove-on-release>\n        if (!BrowserHelper.supportsPointerEvents) {\n            events.mousemove = events.touchmove = 'onMouseMove';\n            events.mouseup   = events.touchend  = 'onMouseUp';\n        }\n\n        element.classList.add('b-moving');\n        me.mouseDetacher = EventHelper.on(events);\n\n        me.trigger('splitterMouseDown', { event });\n    }\n\n    onMouseMove(event) {\n        const\n            me        = this,\n            {\n                context,\n                nextWidget,\n                previousWidget\n            }         = me,\n            prevStyle = context.prev.style,\n            nextStyle = context.next.style,\n            deltaX    = (event.pageX - context.startX) * (me.rtl ? -1 : 1),\n            deltaY    = event.pageY - context.startY;\n\n        event.preventDefault();\n\n        Object.assign(context, {\n            deltaX,\n            deltaY\n        });\n\n        if (!context.started) {\n            context.started = true;\n\n            me.trigger('dragStart', { context, event });\n\n            // Convert heights/widths to flex for flexed elements to maintain proportions\n            // 100px high -> flex-grow 100\n            context.flexed.forEach(flexed => {\n                flexed.element.style.flexGrow = me.vertical ? flexed.width : flexed.height;\n                //Remove flex-basis, since it interferes with resizing\n                flexed.element.style.flexBasis = '0';\n            });\n        }\n\n        // Adjust flex-grow or width/height for splitter's closest siblings\n        if (me.vertical) {\n            const\n                newPrevWidth = context.prevWidth + deltaX,\n                newNextWidth = context.nextWidth - deltaX;\n\n            if (context.prevHasFlex) {\n                prevStyle.flexGrow = newPrevWidth;\n            }\n            else if (previousWidget) {\n                previousWidget.width = newPrevWidth;\n            }\n            else {\n                prevStyle.width = `${newPrevWidth}px`;\n            }\n\n            if (context.nextHasFlex) {\n                nextStyle.flexGrow = newNextWidth;\n            }\n            else if (nextWidget) {\n                nextWidget.width = newNextWidth;\n            }\n            else {\n                nextStyle.width = `${newNextWidth}px`;\n            }\n        }\n        else {\n            const\n                newPrevHeight = context.prevHeight + deltaY,\n                newNextHeight = context.nextHeight - deltaY;\n\n            if (context.prevHasFlex) {\n                prevStyle.flexGrow = newPrevHeight;\n            }\n            else if (previousWidget) {\n                previousWidget.height = newPrevHeight;\n            }\n            else {\n                prevStyle.height = `${newPrevHeight}px`;\n            }\n\n            if (context.nextHasFlex) {\n                nextStyle.flexGrow = newNextHeight;\n            }\n            else if (nextWidget) {\n                nextWidget.height = newNextHeight;\n            }\n            else {\n                nextStyle.height = `${newNextHeight}px`;\n            }\n        }\n\n        me.trigger('drag', { context, event });\n    }\n\n    onMouseUp(event) {\n        const me = this;\n\n        me.mouseDetacher?.();\n        me.mouseDetacher = null;\n        me.element.classList.remove('b-moving');\n\n        if (me.context.started) {\n            me.trigger('drop', { context : me.context, event });\n        }\n\n        me.context = null;\n    }\n\n    //endregion\n\n    render() {\n        super.render(...arguments);\n\n        this.syncState.now();\n\n        if (this.vertical === null) {\n            this.syncState();  // try again on next raf\n        }\n    }\n}\n\n// Register this widget type with its Factory\nSplitter.initClass();\n"],
  "mappings": "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",
  "names": ["classesHV", "hasFlex", "el", "DomHelper", "getStyleValue", "parentElement", "parseInt", "verticality", "horizontal", "vertical", "Splitter", "Widget", "$name", "type", "configurable", "orientation", "containerElement", "$config", "value", "nextNeighbor", "previousNeighbor", "delayable", "syncState", "doDestroy", "_this$mouseDetacher", "mouseDetacher", "call", "compose", "class", "listeners", "pointerdown", "mouseenter", "BrowserHelper", "supportsPointerEvents", "mousedown", "touchstart", "currentOrientation", "getSibling", "next", "element", "result", "isConnected", "isVisible", "nextWidget", "nextElementSibling", "fromElement", "previousWidget", "previousElementSibling", "updateContainerElement", "_me$stateDetector", "me", "stateDetector", "disconnect", "MutationObserver", "observe", "attributes", "childList", "updateNextNeighbor", "watchNeighbor", "updatePreviousNeighbor", "previous", "neighbor", "name", "detachListeners", "ion", "thisObj", "collapse", "expand", "hide", "show", "updateOrientation", "now", "updateVertical", "_this$element", "classList", "add", "remove", "disabled", "collapsible", "collapsed", "hidden", "rendered", "offsetParent", "flexDirection", "startsWith", "prevRect", "getBoundingClientRect", "nextRect", "topMost", "top", "bottomMost", "onMouseDown", "event", "_me$mouseDetacher", "preventDefault", "touches", "prev", "prevHasFlex", "nextHasFlex", "flexed", "child", "children", "push", "width", "offsetWidth", "height", "offsetHeight", "context", "startX", "pageX", "startY", "pageY", "prevWidth", "prevHeight", "nextWidth", "nextHeight", "events", "document", "pointermove", "pointerup", "mousemove", "touchmove", "mouseup", "touchend", "EventHelper", "on", "trigger", "onMouseMove", "prevStyle", "style", "nextStyle", "deltaX", "rtl", "deltaY", "Object", "assign", "started", "forEach", "flexGrow", "flexBasis", "newPrevWidth", "newNextWidth", "newPrevHeight", "newNextHeight", "onMouseUp", "_me$mouseDetacher2", "render", "arguments", "initClass", "_$name"]
}
