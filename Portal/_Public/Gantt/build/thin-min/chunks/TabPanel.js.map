{
  "version": 3,
  "sources": ["../../../../Core/lib/Core/util/WebSocketManager.js", "../../../../Core/lib/Core/widget/FieldSet.js", "../../../../Core/lib/Core/widget/Radio.js", "../../../../Core/lib/Core/widget/RadioGroup.js", "../../../../Core/lib/Core/widget/Tab.js", "../../../../Core/lib/Core/widget/TabBar.js", "../../../../Core/lib/Core/widget/TabPanel.js"],
  "sourcesContent": ["import Base from '../Base.js';\nimport Events from '../mixin/Events.js';\n\n/**\n * @module Core/helper/WebSocketManager\n */\n\n/**\n * This class allows to send and receive messages from websocket server passing responses via events. This helper is\n * meant to be used with a demo websocket server. It sends messages that are JSON strings including \"command\" key and\n * arbitrary data keys. For example:\n *\n * ```javascript\n * // request string to notify other clients that new client is connected\n * \"{ \\\"command\\\": \\\"hello\\\", \\\"userName\\\": \\\"new user\\\" }\"\n *\n * // response message from the websocket server with list of connected users\n * \"{ \\\"command\\\": \\\"users\\\", \\\"users\\\": [\\\"new user\\\"] }\"\n * ```\n *\n * Usage:\n * ```javascript\n * connector = new WebSocketManager({\n *     address     : 'ws://localhost:8080',\n *     userName    : 'Test client',\n *     autoConnect : false\n * });\n *\n * const opened = await connector.open();\n *\n * if (!opened) {\n *     console.log('Could not open connection');\n * }\n *\n * connector.on({\n *     message({ data }) {\n *         console.log(data);\n *     }\n * });\n *\n * // Sends \"{ \\\"command\\\": \\\"hello\\\", \\\"userName\\\": \\\"mark\\\" }\" string to the websocket server\n * // When response arrives helper will log following message: \"{ command: 'users', users: ['mark'] }\"\n * connector.send('hello', { userName : 'mark' });\n * ```\n *\n * @class\n * @extends Core/Base\n * @mixes Core/mixin/Events\n * @private\n */\nexport default class WebSocketManager extends Events(Base) {\n    // This allows to hook into for testing purposes\n    static webSocketImplementation = typeof WebSocket === 'undefined' ? null : WebSocket;\n\n    static configurable = {\n        /**\n         * WebSocket server address\n         * @config {String}\n         */\n        address : '',\n\n        /**\n         * User name allowing to identify client\n         * @config {String}\n         */\n        userName : 'User',\n\n        /**\n         * Connect to websocket server immediately after instantiation\n         * @config {Boolean}\n         */\n        autoConnect : true\n    };\n\n    construct(config = {}) {\n        const me = this;\n\n        super.construct(config);\n\n        me.onWsOpen = me.onWsOpen.bind(me);\n        me.onWsClose = me.onWsClose.bind(me);\n        me.onWsMessage = me.onWsMessage.bind(me);\n        me.onWsError = me.onWsError.bind(me);\n\n        if (me.autoConnect && me.address) {\n            me.open();\n        }\n    }\n\n    doDestroy() {\n        const me = this;\n\n        if (me.connector) {\n            me.detachSocketListeners(me.connector);\n            me.connector.close();\n            me.connector = null;\n        }\n        super.doDestroy();\n    }\n\n    //#region Websocket state\n\n    get isConnecting() {\n        return this.connector?.readyState === this.constructor.webSocketImplementation.CONNECTING;\n    }\n\n    get isOpened() {\n        return this.connector?.readyState === this.constructor.webSocketImplementation.OPEN;\n    }\n\n    get isClosing() {\n        return this.connector?.readyState === this.constructor.webSocketImplementation.CLOSING;\n    }\n\n    get isClosed() {\n        return this.connector?.readyState === this.constructor.webSocketImplementation.CLOSED;\n    }\n\n    //#endregion\n\n    //#region Websocket init\n\n    createWebSocketConnector() {\n        const connector = this.connector = new this.constructor.webSocketImplementation(this.address);\n\n        this.attachSocketListeners(connector);\n    }\n\n    destroyWebSocketConnector() {\n        this.detachSocketListeners(this.connector);\n\n        this.connector.close();\n\n        this.connector = null;\n    }\n\n    attachSocketListeners(connector) {\n        const me = this;\n\n        connector.addEventListener('open', me.onWsOpen);\n        connector.addEventListener('close', me.onWsClose);\n        connector.addEventListener('message', me.onWsMessage);\n        connector.addEventListener('error', me.onWsError);\n    }\n\n    detachSocketListeners(connector) {\n        const me = this;\n\n        connector.removeEventListener('open', me.onWsOpen);\n        connector.removeEventListener('close', me.onWsClose);\n        connector.removeEventListener('message', me.onWsMessage);\n        connector.removeEventListener('error', me.onWsError);\n    }\n\n    //#endregion\n\n    //#region Websocket methods\n\n    /**\n     * Connect to the server and start listening for messages\n     * @returns {Promise} Returns true if connection was successful and false otherwise\n     */\n    async open() {\n        const me = this;\n\n        if (me._openPromise) {\n            return me._openPromise;\n        }\n\n        if (!me.address) {\n            console.warn('Server me.address cannot be empty');\n            return;\n        }\n\n        if (me.isOpened) {\n            return true;\n        }\n\n        me.createWebSocketConnector();\n\n        let detacher;\n\n        // Wait for `open` or `close` event\n        me._openPromise = new Promise(resolve => {\n            detacher = me.ion({\n                open() {\n                    resolve(true);\n                },\n                error() {\n                    resolve(false);\n                }\n            });\n        }).then(value => {\n            // Detach listeners\n            detacher();\n\n            // Cleanup the promise\n            me._openPromise = null;\n\n            // If quit early with a timeout then remove reference to the WebSocket instance\n            if (!value) {\n                me.destroyWebSocketConnector();\n            }\n\n            return value;\n        }).catch(() => {\n            me._openPromise = null;\n            me.destroyWebSocketConnector();\n        });\n\n        return me._openPromise;\n    }\n\n    /**\n     * Close socket and disconnect from the server\n     */\n    close() {\n        if (this.connector) {\n            this.destroyWebSocketConnector();\n            this.trigger('close');\n        }\n    }\n\n    /**\n     * Send data to the websocket server\n     * @param {String} command\n     * @param {*} data\n     */\n    send(command, data = {}) {\n        this.connector?.send(JSON.stringify({ command, ...data }));\n    }\n\n    //#endregion\n\n    //#region websocket event listeners\n\n    onWsOpen(event) {\n        this.trigger('open', { event });\n    }\n\n    onWsClose(event) {\n        this.trigger('close', { event });\n    }\n\n    onWsMessage(message) {\n        try {\n            const data = JSON.parse(message.data);\n            this.trigger('message', { data });\n        }\n        catch (error) {\n            this.trigger('error', { error });\n        }\n    }\n\n    onWsError(error) {\n        this.trigger('error', { error });\n    }\n\n    //#endregion\n}\n", "import Panel from './Panel.js';\nimport Labelable from './mixin/Labelable.js';\nimport DomHelper from '../helper/DomHelper.js';\n\n/**\n * @module Core/widget/FieldSet\n */\n\n/**\n * The `FieldSet` widget wraps an <code>&lt;fieldset&gt;</code> element. A fieldset is a specially styled\n * {@link Core.widget.Panel} intended to hold form fields.\n *\n * @extends Core/widget/Panel\n * @mixes Core/widget/mixin/Labelable\n * @classType fieldset\n * @widget\n */\nexport default class FieldSet extends Panel.mixin(Labelable) {\n    //region Config\n    static get $name() {\n        return 'FieldSet';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'fieldset';\n    }\n\n    static get configurable() {\n        return {\n            bodyTag   : 'fieldset',\n            focusable : false,\n\n            /**\n             * Setting this config to `true` assigns a horizontal box layout (`flex-flow: row`) to the items in this\n             * container, while `false` assigns a vertical box layout (`flex-flow: column`).\n             *\n             * By default, this value is automatically determined based on the {@link #config-label} and\n             * {@link #config-labelPosition} configs.\n             * @config {Boolean}\n             */\n            inline : null,\n\n            inlineInternal : null,\n\n            layout : {\n                type       : 'box',\n                horizontal : false\n            }\n        };\n    }\n\n    static get prototypeProperties() {\n        return {\n            flexRowCls : 'b-hbox',\n            flexColCls : 'b-vbox'\n        };\n    }\n\n    //endregion\n\n    //region Composition\n\n    get bodyConfig() {\n        const\n            result = super.bodyConfig,\n            { className } = result,\n            { inlineInternal: inline, hasLabel, title } = this;\n\n        delete result.html;\n\n        className['b-inline'] = inline;\n        className['b-fieldset-has-label'] = hasLabel;\n\n        if (title) {\n            result.children = {\n                // We render the <legend> element for a11y (not 100% sure it is needed)\n                legendElement : {\n                    tag   : 'legend',\n                    text  : title,\n                    class : {\n                        'b-fieldset-legend' : 1\n                    }\n                }\n            };\n        }\n\n        return result;\n    }\n\n    compose() {\n        const { inlineInternal: inline, label, labelCls, labelWidth } = this;\n\n        return {\n            class : {\n                'b-field' : label,\n                'b-vbox'  : !inline  // override panel\n            },\n            children : {\n                'labelElement > headerElement' : (label || null) && {\n                    tag   : 'label',\n                    html  : label,\n                    class : {\n                        'b-label'       : 1,\n                        'b-align-start' : 1,\n                        [labelCls]      : labelCls\n                    },\n                    style : {\n                        width : DomHelper.unitize('width', labelWidth)[1]\n                    }\n                }\n            }\n        };\n    }\n\n    //endregion\n\n    syncInlineInternal() {\n        this.inlineInternal = this.inline ?? (this.label != null && this.labelPosition === 'before');\n    }\n\n    updateDisabled(value, was) {\n        super.updateDisabled(value, was);\n\n        // Needs {}'s to avoid a \"return false\" that ends iteration\n        this.eachWidget(item => {\n            item.disabled = value;\n        }, /* deep = */false);\n    }\n\n    updateInline() {\n        this.syncInlineInternal();\n    }\n\n    updateInlineInternal(inline) {\n        this.layout.horizontal = inline;\n    }\n\n    updateLabel() {\n        this.syncInlineInternal();\n    }\n\n    updateLabelPosition() {\n        this.syncInlineInternal();\n    }\n}\n\n// Register this widget type with its Factory\nFieldSet.initClass();\n", "import Checkbox from './Checkbox.js';\n\n/**\n * @module Core/widget/Radio\n */\n\n/**\n * The `Radio` widget wraps an <code>&lt;input type=\"radio\"&gt;</code> element.\n *\n * Color can be specified and you can optionally configure {@link #config-text} to display in a label to the right of\n * the radio button instead of, or in addition to, a standard field {@link #config-label}.\n *\n * {@inlineexample Core/widget/Radio.js vertical}\n *\n * ## Nested Items\n * A radio button can also have a {@link #config-container} of additional {@link Core.widget.Container#config-items}.\n * These items can be displayed immediately following the field's label (which is the default when there is only one\n * item) or below the radio button. This can be controlled using the {@link #config-inline} config.\n *\n * In the demo below notice how additional fields are displayed for the checked radio button:\n *\n * {@inlineexample Core/widget/Radio-items.js vertical}\n *\n * For a simpler way to create a set of radio buttons, see the {@link Core.widget.RadioGroup} widget.\n *\n * @extends Core/widget/Checkbox\n * @classType radio\n * @widget\n */\nexport default class Radio extends Checkbox {\n    //region Config\n    static get $name() {\n        return 'Radio';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'radio';\n    }\n\n    // Factoryable type alias\n    static get alias() {\n        return 'radiobutton';\n    }\n\n    static get configurable() {\n        return {\n            inputType : 'radio',\n\n            /**\n             * Set this to `true` so that clicking a checked radio button will clear its checked state.\n             * @config {Boolean}\n             * @default false\n             */\n            clearable : null,\n\n            uncheckedValue : undefined  // won't store to Container#values when unchecked\n        };\n    }\n\n    //endregion\n\n    //region Init\n\n    get textLabelCls() {\n        return super.textLabelCls + ' b-radio-label';\n    }\n\n    //endregion\n\n    internalOnClick(info) {\n        if (super.internalOnClick(info) !== false) {\n            if (this.checked && this.clearable) {\n                this.checked = false;\n            }\n        }\n    }\n\n    updateName(name) {\n        this.toggleGroup = name;\n    }\n\n    // Empty override to get rid of clear trigger\n    updateClearable() {}\n}\n\n// Register this widget type with its Factory\nRadio.initClass();\n", "import ObjectHelper from '../helper/ObjectHelper.js';\nimport FieldSet from './FieldSet.js';\nimport Widget from './Widget.js';\n\nimport './Radio.js';\nimport './layout/Box.js';\n\n/**\n * @module Core/widget/RadioGroup\n */\n\n/**\n * The `RadioGroup` widget contains a set of related `{@link Core/widget/Radio}` button widgets.\n *\n * For example, to present three choices and have the user select one of them:\n *\n * ```javascript\n *  {\n *      type    : 'radiogroup',\n *      title   : 'Resolve Conflict',\n *      name    : 'resolution',\n *      value   : 'A',  // the default choice\n *      options : {\n *          A : 'Keep the original version',\n *          B : 'Use the new version',\n *          C : 'Reconcile individual conflicts'\n *      }\n *  }\n * ```\n *\n * {@inlineexample Core/widget/RadioGroup.js}\n *\n * The {@link #config-name} config is required for this widget and it will be assigned to all radio buttons created by\n * processing the {@link #config-options} config.\n *\n * ## Nested Items\n * Radio buttons can also have a {@link Core.widget.Radio#config-container} of additional\n * {@link Core.widget.Container#config-items}. These items can be displayed immediately following the field's label\n * (which is the default when there is only one item) or below the radio button. This can be controlled using the\n * {@link Core.widget.Radio#config-inline} config.\n *\n * In the demo below notice how additional fields are displayed for the checked radio button:\n *\n * {@inlineexample Core/widget/RadioGroupNested.js vertical}\n *\n * @extends Core/widget/FieldSet\n * @classType radiogroup\n * @widget\n */\nexport default class RadioGroup extends FieldSet {\n    //region Config\n    static get $name() {\n        return 'RadioGroup';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'radiogroup';\n    }\n\n    static get configurable() {\n        return {\n            defaultType : 'radio',\n\n            /**\n             * Set this to `true` so that clicking the currently checked radio button will clear the check from all\n             * radio buttons in the group.\n             * @config {Boolean}\n             * @default false\n             */\n            clearable : null,\n\n            /**\n             * The name by which this widget's {@link #property-value} is accessed using the parent container's\n             * {@link Core.widget.Container#property-values}.\n             *\n             * The config must be provided as it is used to set the {@link Core.widget.Radio#config-name} of the\n             * child {@link Core.widget.Radio radio buttons}.\n             * @config {String}\n             */\n            name : null,\n\n            /**\n             * The set of radio button options for this radio button group. This is a shorthand for defining these in\n             * the {@link Core.widget.Container#config-items}. The keys of this object hold the radio button's\n             * {@link Core.widget.Radio#config-checkedValue} while the object values are a string for the radio button's\n             * {@link Core.widget.Radio#config-text} or a config object for that radio button.\n             *\n             * The {@link #property-value} of this radio button group will be one of the keys in this object or `null`\n             * if no radio button is checked.\n             *\n             * For example, consider the following configuration:\n             * ```javascript\n             *  {\n             *      type    : 'radiogroup',\n             *      name    : 'resolution',\n             *      value   : 'A',\n             *      options : {\n             *          A : 'Keep the original version',\n             *          B : 'Use the new version',\n             *          C : 'Reconcile individual conflicts'\n             *      }\n             *  }\n             * ```\n             *\n             * The above is equivalent to this configuration below using {@link #config-items}:\n             * ```javascript\n             *  {\n             *      type  : 'radiogroup',\n             *      items : [{\n             *          text         : 'Keep the original version',\n             *          name         : 'resolution',\n             *          ref          : 'resolution_A',\n             *          checked      : true,\n             *          checkedValue : 'A'\n             *      }, {\n             *          text         : 'Use the new version',\n             *          name         : 'resolution',\n             *          ref          : 'resolution_B',\n             *          checkedValue : 'B'\n             *      }, {\n             *          text         : 'Reconcile individual conflicts',\n             *          name         : 'resolution',\n             *          ref          : 'resolution_C',\n             *          checkedValue : 'C'\n             *      }]\n             *  }\n             * ```\n             * @config {Object<String,String|RadioConfig>} options\n             */\n            options : {\n                value : null,\n\n                $config : {\n                    merge : 'items'\n                }\n            },\n\n            defaultBindProperty : 'value'\n        };\n    }\n\n    get existingOptions() {\n        const { name } = this;\n\n        return this.ensureItems().filter(c => c.name === name);\n    }\n\n    get refPrefix() {\n        return `${this.name || this.ref || this.id}_`;\n    }\n\n    get selected() {\n        return this.existingOptions.filter(c => c.input.checked)[0] || null;\n    }\n\n    /**\n     * This property corresponds to the {@link Core.widget.Radio#config-checkedValue} of the currently\n     * {@link Core.widget.Radio#property-checked} radio button.\n     * @property {String}\n     */\n    get value() {\n        const { selected } = this;\n\n        return selected ? selected.checkedValue : null;\n    }\n\n    set value(v) {\n        this.existingOptions.forEach(c => {\n            c.isConfiguring = this.isConfiguring;\n            c.checked = c.checkedValue === v;\n            c.isConfiguring = false;\n        });\n    }\n\n    ensureItems() {\n        this.getConfig('options');\n\n        return super.ensureItems();\n    }\n\n    changeOptions(options, was) {\n        if (!(options && was && ObjectHelper.isDeeplyEqual(was, options))) {\n            return options;\n        }\n    }\n\n    convertOption(key, option, existing) {\n        const\n            me       = this,\n            { name } = me,\n            ret      = {\n                name,\n                type         : 'radio',\n                value        : key === me.value,\n                ref          : `${me.refPrefix}${key}`,\n                checkedValue : key\n            };\n\n        if (typeof option === 'string') {\n            ret.text = option;\n        }\n        else {\n            ObjectHelper.assign(ret, option);\n        }\n\n        return existing ? Widget.reconfigure(existing, ret) : ret;\n    }\n\n    isOurRadio(item) {\n        // Radio groups could be nested using field containers, so we need isRadio and name equality check:\n        return item.isRadio && item.name === this.name;\n    }\n\n    isolateFieldChange(field) {\n        // if this is one of our radio buttons, swallow the field change:\n        return this.isOurRadio(field);\n    }\n\n    onChildAdd(item) {\n        super.onChildAdd(item);\n\n        if (this.isOurRadio(item)) {\n            item.ion({\n                name         : item.id,\n                beforeChange : 'onRadioItemBeforeChange',\n                change       : 'onRadioItemChange',\n                click        : 'onRadioClick',\n                thisObj      : this\n            });\n        }\n    }\n\n    onChildRemove(item) {\n        if (this.isOurRadio(item)) {\n            this.detachListeners(item.id);\n        }\n\n        super.onChildRemove(item);\n    }\n\n    onRadioClick(ev) {\n        const { source } = ev;\n\n        if (source.checked && this.clearable && source.clearable == null) {\n            source.checked = false;\n        }\n    }\n\n    onRadioItemBeforeChange(ev) {\n        if (ev.checked) {\n            const\n                me = this,\n                { lastValue } = me;\n\n            if (!me.reverting && me.trigger('beforeChange', me.wrapRadioEvent(ev)) === false) {\n                if (lastValue != null && lastValue !== me.value) {\n                    me.reverting = true;\n\n                    ev.source.uncheckToggleGroupMembers();\n                    me.value = lastValue;\n                    me.lastValue = lastValue;\n\n                    me.reverting = false;\n\n                    return false;\n                }\n            }\n        }\n    }\n\n    onRadioItemChange(ev) {\n        const me = this;\n\n        if (ev.checked && !me.reverting) {\n            me.triggerFieldChange(me.wrapRadioEvent(ev));\n            me.lastValue = me.value;\n        }\n    }\n\n    wrapRadioEvent(ev) {\n        return {\n            from       : ev,\n            item       : ev.source,\n            userAction : ev.userAction,\n            lastValue  : this.lastValue,\n            value      : this.value\n        };\n    }\n\n    updateOptions() {\n        const\n            me                     = this,\n            { options, refPrefix } = me,\n            existingOptions        = me.existingOptions.reduce((m, c) => {\n                m[c.ref.substring(refPrefix.length)] = c;\n                return m;\n            }, {});\n\n        let index = 0,\n            key, option;\n\n        if (options) {\n            for (key in options) {\n                option = me.convertOption(key, options[key], existingOptions[key]);\n\n                delete existingOptions[key];\n                me.insert(option, index++);\n            }\n        }\n\n        const existing = Object.values(existingOptions);\n\n        if (existing?.length) {\n            me.remove(existing);\n            existing.forEach(c => c.destroy());\n        }\n    }\n\n    //endregion\n}\n\n// Register this widget type with its Factory\nRadioGroup.initClass();\n", "import DomClassList from '../helper/util/DomClassList.js';\nimport FunctionHelper from '../helper/FunctionHelper.js';\nimport Button from './Button.js';\n\n/**\n * @module Core/widget/Tab\n */\n\n/**\n * This widget class is used to present items in a {@link Core.widget.TabPanel} on its {@link Core.widget.TabBar tabBar}.\n * A reference to this widget is stored via the {@link Core.widget.Widget#config-tab} config on the tab panel's items.\n *\n * ```javascript\n * let tabPanel = new TabPanel({\n *  items: [\n *      {\n *          title: 'Settings',\n *          // Tab configs\n *          tab : {\n *              // Show an icon in the tab\n *              icon : 'b-fa b-fa-cog'\n *          },\n *          items: [\n *              ...\n *          ]\n *      }\n *  ]\n * });\n * ```\n *\n * @extends Core/widget/Button\n * @classType tab\n */\nexport default class Tab extends Button {\n    //region Config\n    static get $name() {\n        return 'Tab';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'tab';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * This config is set to `true` when this tab represents the `activeTab` of a {@link Core.widget.TabPanel}. It\n             * is managed by the tab panel is not set directly.\n             * @config {Boolean} active\n             * @default false\n             */\n            active : null,\n\n            /**\n             * This config is set to the ordinal position of this tab in the {@link Core.widget.TabPanel}. It is managed\n             * by the tab panel is not set directly.\n             * @config {Number} index\n             */\n            index : null,\n\n            /**\n             * This config is set to `true` when this tab represents the first tab of a {@link Core.widget.TabPanel}. It\n             * is managed by the tab panel is not set directly.\n             * @config {Boolean} isFirst\n             */\n            isFirst : null,\n\n            /**\n             * This config is set to `true` when this tab represents the last tab of a {@link Core.widget.TabPanel}. It\n             * is managed by the tab panel is not set directly.\n             * @config {Boolean} isLast\n             */\n            isLast : null,\n\n            /**\n             * The {@link Core.widget.Widget} in the {@link Core.widget.TabPanel} corresponding to this tab. This is\n             * managed by the tab panel is not set directly.\n             * @config {Core.widget.Widget} item\n             */\n            item : {\n                value : null,\n\n                $config : 'nullify'\n            },\n\n            itemCls : null,\n\n            /**\n             * The tab panel that owns this tab.\n             * @config {Core.widget.TabPanel} tabPanel\n             */\n            tabPanel : null,\n\n            /**\n             * The config property on this tab that will be set to the value of the {@link #config-titleSource} property\n             * of this tab's {@link #config-item}.\n             *\n             * By default, the {@link #config-text} property of the tab is set to the {@link Core.widget.Widget#config-title}\n             * property of its {@link #config-item}.\n             * @config {String} titleProperty\n             * @default\n             */\n            titleProperty : 'text',\n\n            /**\n             * The config property on this tab's {@link #config-item} that is used to set the value of the\n             * {@link #config-titleProperty} of this tab.\n             *\n             * By default, the {@link #config-text} property of the tab is set to the {@link Core.widget.Widget#config-title}\n             * property of its {@link #config-item}.\n             * @config {String} titleSource\n             * @default\n             */\n            titleSource : 'title',\n\n            role : 'tab'\n        };\n    }\n\n    compose() {\n        const\n            { active, cls, index, isFirst, isLast } = this,\n            setSize = this.owner.visibleChildCount;\n\n        return {\n            tabindex : 0,\n\n            'aria-selected' : active,\n            'aria-setsize'  : setSize,\n            'aria-posinset' : index + 1,\n\n            class : {\n                'b-tabpanel-tab' : 1,\n                'b-active'       : active,\n                'b-tab-first'    : isFirst,\n                'b-tab-last'     : isLast,\n\n                ...cls   // cls is a DomClassList\n            },\n\n            dataset : {\n                index\n            }\n        };\n    }\n\n    //endregion\n\n    updateIndex(index) {\n        this.isFirst = !index;\n    }\n\n    updateItem(item, was) {\n        const me = this;\n\n        if (was?.tab === me) {\n            was.tab = null;\n        }\n\n        if (item) {\n            item.tab = me;\n\n            me[me.titleProperty] = item[me.titleSource];\n            me.itemCls = item.cls;\n            me.ariaElement.setAttribute('aria-controls', item.id);\n            item.role = 'tabpanel';\n        }\n\n        me.itemChangeDetacher?.();\n        me.itemChangeDetacher = item && FunctionHelper.after(item, 'onConfigChange', 'onItemConfigChange', me, {\n            return : false\n        });\n\n        me.itemHideDetacher?.();\n        me.itemHideDetacher = item?.ion({\n            beforeChangeHidden   : 'onItemBeforeChangeHidden',\n            beforeHide           : 'onItemBeforeHide',\n            beforeUpdateDisabled : 'onItemBeforeUpdateDisabled',\n            thisObj              : me,\n            prio                 : 1000 // We must know before the layout intercepts and activates a sibling\n        });\n\n        me.syncMinMax();\n    }\n\n    updateItemCls(cls, was) {\n        const\n            { element } = this,\n            classList = element && DomClassList.from(element?.classList, /* returnEmpty= */true);\n\n        if (element) {\n            classList.remove(was).add(cls);\n            element.className = classList.value;\n        }\n    }\n\n    updateRotate(rotate, was) {\n        if (!rotate !== !was) {\n            this.syncMinMax();\n        }\n    }\n\n    syncMinMax() {\n        const\n            me = this,\n            { rotate, tabPanel } = me;\n\n        // We have to read the configs directly since there are getters that read the DOM styles:\n        let { _minWidth : minWidth, _minHeight : minHeight, _maxWidth : maxWidth, _maxHeight : maxHeight } = me;\n\n        // When a tab rotation changes, we need to pivot the min/max width values with the height values\n        if (tabPanel) {\n            const { tabMinWidth, tabMaxWidth } = tabPanel;\n\n            if (tabMinWidth != null) {\n                if (rotate) {\n                    // if we were previously not rotated, the tabMinWidth may be effecting our minWidth:\n                    if (minWidth === tabMinWidth) {\n                        minWidth = null;\n                    }\n\n                    // noinspection JSSuspiciousNameCombination\n                    minHeight = tabMinWidth;\n                }\n                else {\n                    // if we were previously rotated, the tabMinWidth may be effecting our minHeight:\n                    if (minHeight === tabMinWidth) {\n                        minHeight = null;\n                    }\n\n                    minWidth = tabMinWidth;\n                }\n            }\n\n            if (tabMaxWidth != null) {\n                if (rotate) {\n                    if (maxWidth === tabMaxWidth) {\n                        maxWidth = null;\n                    }\n\n                    // noinspection JSSuspiciousNameCombination\n                    maxHeight = tabMaxWidth;\n                }\n                else {\n                    if (maxHeight === tabMaxWidth) {\n                        maxHeight = null;\n                    }\n\n                    maxWidth = tabMaxWidth;\n                }\n            }\n\n            me.minWidth = minWidth;\n            me.minHeight = minHeight;\n            me.maxWidth = maxWidth;\n            me.maxHeight = maxHeight;\n        }\n    }\n\n    onItemBeforeChangeHidden({ source : hidingChild, hidden }) {\n        // If it's a hide/show that is not part of the layout's deactivating/activating, we must hide/show the tab\n        if (!hidingChild.$isDeactivating && !hidingChild.$isActivating) {\n            const { tabPanel } = this;\n\n            this.hidden = hidden;\n\n            // if tab to hide is active, let's active previous visible and enabled tab\n            if (hidden && hidingChild === tabPanel.activeItem) {\n                tabPanel.activateAvailableTab(hidingChild);\n            }\n        }\n    }\n\n    onItemBeforeHide() {\n        // If it's a hide that is not part of the layout's deactivating, we hide the tab\n        if (!this.item.$isDeactivating) {\n            this.hide();\n        }\n    }\n\n    onItemBeforeUpdateDisabled({ source : disablingChild, disabled }) {\n        const { tabPanel } = this;\n\n        this.disabled = disabled;\n\n        // if tab to disable is active, let's active previous visible and enabled tab\n        if (disablingChild === tabPanel.activeItem) {\n            tabPanel.activateAvailableTab(disablingChild);\n        }\n    }\n\n    onItemConfigChange({ name, value }) {\n        if (name === this.titleSource) {\n            this[this.titleProperty] = value;\n        }\n    }\n}\n\n// Register this widget type with its Factory\nTab.initClass();\n", "import Toolbar from './Toolbar.js';\nimport ArrayHelper from '../helper/ArrayHelper.js';\n\nimport './Tab.js';\n\n/**\n * @module Core/widget/TabBar\n */\n\nconst isTab = t => t.isTab;\n\n/**\n * A special toolbar used by {@link Core.widget.TabPanel} to present {@link Core.widget.Tab tabs} for the container's\n * items.\n *\n * The {@link Core.widget.Container#config-items} of a tab bar are typically managed by the tab panel, however,\n * items can be added that do not correspond to items in the tab panel. The {@link Core.widget.Widget#config-weight}\n * config of each tab defaults to 0 or the weight of its corresponding item.\n *\n * @extends Core/widget/Toolbar\n * @classType tabbar\n */\nexport default class TabBar extends Toolbar {\n    static get $name() {\n        return 'TabBar';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'tabbar';\n    }\n\n    static get configurable() {\n        return {\n            defaultType : 'tab',\n\n            overflow : 'scroll',\n\n            role : 'tablist',\n\n            ignoreParentReadOnly : true\n        };\n    }\n\n    get firstTab() {\n        return this.tabAt(0);\n    }\n\n    get lastTab() {\n        return this.tabAt(-1);\n    }\n\n    get tabCount() {\n        return this._items.countOf(isTab);\n    }\n\n    get tabs() {\n        return ArrayHelper.from(this._items, isTab);\n    }\n\n    compose() {\n        return {\n            children : {\n                toolbarContent : {\n                    class : {\n                        'b-tabpanel-tabs' : 1\n                    }\n                }\n            }\n        };\n    }\n\n    indexOfTab(tab) {\n        return this._items.indexOf(tab, isTab);\n    }\n\n    onChildAdd(child) {\n        super.onChildAdd(child);\n\n        if (child.index == null) {\n            this.syncTabs();\n        }\n    }\n\n    onChildRemove(child) {\n        super.onChildRemove(child);\n\n        this.syncTabs();\n    }\n\n    onFocusIn() {\n        const { activeIndex } = this.owner;\n\n        // It must have a numeric active index set up\n        if (!isNaN(activeIndex)) {\n            this.tabs[activeIndex].focus();\n        }\n    }\n\n    syncTabs() {\n        const { tabs } = this;\n\n        for (let i = 0, n = tabs.length; i < n; ++i) {\n            tabs[i].index = i;\n            tabs[i].isFirst = !i;\n            tabs[i].isLast = i === n - 1;\n        }\n    }\n\n    tabAt(index) {\n        return this._items.find(isTab, index) || null;\n    }\n}\n\n// Register this widget type with its Factory\nTabBar.initClass();\n", "import ArrayHelper from '../helper/ArrayHelper.js';\nimport ObjectHelper from '../helper/ObjectHelper.js';\nimport Panel from './Panel.js';\nimport Tab from './Tab.js';\n\nimport './TabBar.js';\nimport './layout/Card.js';\nimport GlobalEvents from '../GlobalEvents.js';\n\n/**\n * @module Core/widget/TabPanel\n */\n\nconst isMaximized = w => w.maximized;\n\n/**\n * A tab panel widget which displays a collection of tabs, each of which can contain other widgets (or simple HTML). This\n * widget has a {@link Core.widget.TabBar tab bar} on top of its contents, and each {@link Core.widget.Tab tab} can be\n * customized using the {@link Core.widget.Tab#config-tab} config.\n *\n * @extends Core/widget/Container\n * @example\n * let tabPanel = new TabPanel({\n *  items: [\n *      {\n *          title: 'First',\n *          items: [\n *              { type: 'textfield', label: 'Name' },\n *              ...\n *          ]\n *      }, {\n *          title: 'Settings',\n *          tab : {\n *              // Show an icon in the tab\n *              icon : 'b-fa b-fa-cog'\n *          },\n *          items: [\n *              ...\n *          ]\n *      }\n *  ]\n * });\n *\n * The tab selector buttons are focusable elememts. `Enter` or `Space` activates a tab, and moves\n * focus into the newly visible tab item.\n *\n * @classType tabpanel\n * @inlineexample Core/widget/TabPanel.js\n * @widget\n */\nexport default class TabPanel extends Panel {\n    //region Config\n    static get $name() {\n        return 'TabPanel';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'tabpanel';\n    }\n\n    // Factoryable type alias\n    static get alias() {\n        return 'tabs';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * The index of the initially active tab.\n             * @member {Number} activeTab\n             */\n            /**\n             * The index of the initially active tab.\n             * @config {Number}\n             * @default\n             */\n            activeTab : 0,\n\n            /**\n             * Specifies whether to slide tabs in and out of visibility.\n             * @config {Boolean}\n             * @default\n             */\n            animateTabChange : true,\n\n            /**\n             * Set the height of all tabs to match the tab with the highest content.\n             * @config {Boolean}\n             * @default\n             */\n            autoHeight : false,\n\n            defaultType : 'container',\n\n            focusable : false,\n\n            itemCls : 'b-tabpanel-item',\n\n            layout : {\n                type : 'card'\n            },\n\n            // Prevent child panels from displaying a header unless explicitly configured with one\n            suppressChildHeaders : true,\n\n            tabBar : {\n                type   : 'tabbar',\n                weight : -2000\n            },\n\n            /**\n             * Min width of a tab title. 0 means no minimum width. This is default.\n             * @config {Number}\n             * @default\n             */\n            tabMinWidth : null,\n\n            /**\n             * Max width of a tab title. 0 means no maximum width. This is default.\n             * @config {Number}\n             * @default\n             */\n            tabMaxWidth : null\n        };\n    }\n\n    //endregion\n\n    //region Init\n\n    /**\n     * The active tab index. Setting must be done through {@link #property-activeTab}\n     * @property {Number}\n     * @readonly\n     */\n    get activeIndex() {\n        return this.layout.activeIndex;\n    }\n\n    /**\n     * The active child widget. Setting must be done through {@link #property-activeTab}\n     * @property {Core.widget.Widget}\n     * @readonly\n     */\n    get activeItem() {\n        return this.layout.activeItem;\n    }\n\n    get activeTabItemIndex() {\n        const { activeTab, items, tabBar } = this;\n\n        return items.indexOf(tabBar.tabs[activeTab]?.item);\n    }\n\n    get bodyConfig() {\n        return ObjectHelper.merge({\n            className : {\n                'b-tabpanel-body' : 1\n            }\n        }, super.bodyConfig);\n    }\n\n    get focusElement() {\n        const activeTab = this.items[this.activeTab || 0];\n\n        return activeTab?.focusElement || activeTab?.tab?.focusElement;\n    }\n\n    get tabPanelBody() {\n        return this.bodyElement;\n    }\n\n    finalizeInit() {\n        super.finalizeInit();\n\n        const\n            me                    = this,\n            { activeTab, layout } = me,\n            { activeIndex }       = layout,\n            { tabs }              = me.tabBar,\n            activeTabItemIndex    = activeTab >= 0 && activeTab < tabs.length && me.items.indexOf(tabs[activeTab].item);\n\n        if (tabs.length > 0 && (activeTabItemIndex === false || activeTabItemIndex < 0)) {\n            throw new Error(`Invalid activeTab ${activeTab} (${tabs.length} tabs)`);\n        }\n\n        if (activeTabItemIndex !== activeIndex) {\n            // Since we are responding to configuration, we need to sync activeIndex to activeTab as if it were the\n            // initial value of activeIndex. This cannot be done (reasonably) during initialization of the card layout\n            // because of the possibility of tabless items, so we wait until the dust settles on the items, the tabBar\n            // and all other configs, but we must do the tab change silently (since the initial active item is set\n            // without such ceremony) and without animation (to avoid the appearance of the initial tab animating in)\n            layout.setActiveItem(activeTabItemIndex, activeIndex, {\n                animation : false,\n                silent    : true\n            });\n        }\n\n        layout.animateCardChange = me.animateTabChange;\n    }\n\n    onChildAdd(child) {\n        // The layout will hide inactive new items.\n        // And we must add our beforeHide listener *after* call super.\n        super.onChildAdd(child);\n\n        if (!this.initialItems) {\n            const\n                me          = this,\n                { tabBar }  = me,\n                config      = me.makeTabConfig(child),\n                // if child.tab === false, config will be null... no tab for this one\n                firstTab    = config && tabBar?.firstTab,\n                // if there are no tabs yet, this will be the first so we can skip all the indexing...\n                tabBarItems = firstTab && tabBar._items,\n                // not all items have tabs but the new child won't have one yet:\n                tabItems    = firstTab && ArrayHelper.from(me._items, it => it.tab || it === child),\n                // non-tabs could be in the tabBar, but the tabs must be contiguous:\n                index       = firstTab ? tabItems.indexOf(child) + tabBarItems.indexOf(firstTab) : 0;\n\n            if (config && tabBar) {\n                if (firstTab && child.weight == null && index < tabBarItems.count - 1) {\n                    tabBar.insert(config, index);\n                }\n                else {\n                    tabBar.add(config);\n                }\n            }\n        }\n    }\n\n    onChildRemove(child) {\n        const\n            { tab }   = child,\n            { items } = this;\n\n        if (tab) {\n            this.tabBar.remove(tab);\n            tab.destroy();\n        }\n\n        // Removing the active item, then show a sibling if any are left\n        if (child === this.activeItem) {\n            this._activeTab = null;\n            if (items.length) {\n                this.activeTab = items[Math.min(this.activeIndex, items.length - 1)];\n            }\n        }\n\n        super.onChildRemove(child);\n    }\n\n    //endregion\n\n    //region Tabs\n\n    isDisabledOrHiddenTab(tabIndex) {\n        const\n            { tabs } = this.tabBar,\n            tab      = tabs?.[tabIndex];\n        return tab && (tab.disabled || tab.hidden);\n    }\n\n    findAvailableTab(item, delta = 1) {\n        const\n            { tabs }  = this.tabBar,\n            tabCount  = tabs.length,\n            itemIndex = Math.max(0, tabs.indexOf(item.tab));\n\n        if (itemIndex) {\n            delta = -delta;\n        }\n\n        let activeTab;\n\n        for (let n = 1; n <= tabCount; ++n) {\n            //  itemIndex=2, tabCount=5:\n            //               n : 1, 2, 3, 4, 5\n            //      delta =  1 : 3, 4, 0, 1, 2\n            //      delta = -1 : 1, 0, 4, 3, 2\n            activeTab = (itemIndex + ((delta < 0) ? tabCount : 0) + n * delta) % tabCount;\n            if (!this.isDisabledOrHiddenTab(activeTab)) {\n                break;\n            }\n        }\n        return activeTab;\n    }\n\n    activateAvailableTab(item, delta = 1) {\n        this.activeTab = this.findAvailableTab(item, delta);\n    }\n\n    changeActiveTab(activeTab, oldActiveTab) {\n        const\n            me           = this,\n            {\n                tabBar,\n                layout\n            }            = me,\n            { tabCount } = tabBar;\n\n        if (activeTab.isWidget || ObjectHelper.isObject(activeTab)) {\n            // Must be a child widget, so add if it's not already in our items.\n            if (me.items.indexOf(activeTab) === -1) {\n                activeTab = me.add(activeTab);\n            }\n\n            activeTab = tabBar.indexOfTab(activeTab.tab);\n        }\n        else {\n            activeTab = parseInt(activeTab, 10);\n        }\n\n        if (!me.initialItems && tabCount > 0 && (activeTab < -1 || activeTab >= tabCount)) {\n            throw new Error(`Invalid activeTab ${activeTab} (${tabCount} tabs)`);\n        }\n\n        if (me.isDisabledOrHiddenTab(activeTab)) {\n            activeTab = me.findAvailableTab(activeTab);\n        }\n\n        // If we are animating, we must wait until any animation is finished\n        // before we can go ahead and apply the change.\n        if (layout.animateCardChange && layout.cardChangeAnimation) {\n            layout.cardChangeAnimation.then(cardChange => {\n                // If the animation resulted in not where we want, update the activeTab\n                if (cardChange?.activeIndex !== activeTab) {\n                    me._activeTab = activeTab;\n                    me.updateActiveTab(activeTab, oldActiveTab);\n                }\n            });\n        }\n        else {\n            return activeTab;\n        }\n    }\n\n    async updateActiveTab(activeTab, was) {\n        if (!this.initialItems) {\n            const { activeTabItemIndex, layout } = this;\n\n            if (activeTabItemIndex > -1) {\n                const\n                    oldActiveItem = this.items[was],\n                    newActiveItem = this.items[activeTabItemIndex];\n\n                // Avoid no-change\n                if (layout.activeItem !== newActiveItem) {\n                    if (layout.animateCardChange) {\n                        await this.tabSelectionPromise;\n                    }\n\n                    // Focus the active tab's button in TabPanel first so that focus doesn't leave\n                    // the TabPanel when ths active tab hides.\n                    if (oldActiveItem?.containsFocus) {\n                        oldActiveItem.tab.focus();\n                    }\n                    this.tabSelectionPromise = layout.setActiveItem(newActiveItem)?.promise;\n                }\n            }\n        }\n    }\n\n    changeTabBar(bar) {\n        this.getConfig('strips');\n\n        this.strips = {\n            tabBar : bar\n        };\n\n        return this.strips.tabBar;\n    }\n\n    makeTabConfig(item) {\n        const\n            { tab } = item,\n            config  = {\n                item,\n\n                type              : 'tab',\n                tabPanel          : this,\n                disabled          : Boolean(item.disabled),\n                hidden            : item.initialConfig.hidden,\n                weight            : item.weight || 0,\n                internalListeners : {\n                    click   : 'onTabClick',\n                    thisObj : this\n                },\n                localizableProperties : {\n                    // our tabs copy their text from the item's title and so are not directly localized\n                    text : false\n                }\n            };\n\n        if (tab === false) {\n            return null;\n        }\n\n        return ObjectHelper.isObject(tab) ? Tab.mergeConfigs(config, tab) : config;\n    }\n\n    updateItems(items, was) {\n        const\n            me                          = this,\n            { activeTab, initialItems } = me;\n\n        let index = 0,\n            tabs;\n\n        super.updateItems(items, was);\n\n        if (initialItems) {\n            tabs = Array.from(items, it => me.makeTabConfig(it)).filter(it => {\n                if (it) {\n                    it.index = index++;\n                    return true;\n                }\n            });\n\n            if (index) {\n                tabs[0].isFirst = true;\n                tabs[index - 1].isLast = true;\n                tabs[activeTab].active = true;\n\n                me.tabBar.add(tabs);\n                me.activeTab = activeTab;  // now we can validate the activeTab value\n            }\n        }\n    }\n\n    updateTabMinWidth(tabMinWidth) {\n        this.tabBar?.items.forEach(tab => {\n            if (tab.isTab) {\n                tab.minWidth = tabMinWidth;\n            }\n        });\n    }\n\n    updateTabMaxWidth(tabMaxWidth) {\n        this.tabBar?.items.forEach(tab => {\n            if (tab.isTab) {\n                tab.maxWidth = tabMaxWidth;\n            }\n        });\n    }\n\n    //endregion\n\n    //region Auto height\n\n    updateAutoHeight(autoHeight) {\n        this.detachListeners('themeAutoHeight');\n\n        autoHeight && GlobalEvents.ion({\n            name    : 'themeAutoHeight',\n            theme   : 'internalOnThemeChange',\n            thisObj : this\n        });\n\n        this.$measureHeight = autoHeight;\n    }\n\n    applyAutoHeight() {\n        const\n            me                             = this,\n            { layout, activeTab, element } = me,\n            { animateCardChange }          = layout;\n\n        // stop animate to change tabs on back stage.\n        layout.animateCardChange = false;\n\n        // override any previously applied height when measuring\n        me.height = null;\n\n        // Only actually apply a measured height if we are not inside a maximized widget\n        if (!me.up(isMaximized)) {\n            // get the max height comparing all tabs and apply to the tab\n            me.height = Math.max(...me.items.map(tab => {\n                me.activeTab = tab;\n                return element.clientHeight;\n            })) + 1;\n        }\n\n        // Go back to initial configs\n        me.activeTab = activeTab;\n        layout.animateCardChange = animateCardChange;\n\n        me.$measureHeight = false;\n    }\n\n    internalOnThemeChange() {\n        if (this.isVisible) {\n            this.applyAutoHeight();\n        }\n        else {\n            this.$measureHeight = true;\n        }\n    }\n\n    //endregion\n\n    //region Events\n\n    // Called after beforeActiveItemChange has fired and not been vetoed before animation and activeItemChange\n    onBeginActiveItemChange(activeItemChangeEvent) {\n        const\n            tabs                           = this.tabBar.tabs,\n            { activeItem, prevActiveItem } = activeItemChangeEvent;\n\n        // Our UI changes immediately, our state must be accurate\n        this.activeTab = tabs.indexOf(activeItem?.tab);\n\n        // Deactivate previous active tab\n        if (prevActiveItem?.tab) {\n            prevActiveItem.tab.active = false;\n        }\n\n        if (activeItem?.tab) {\n            activeItem.tab.active = true;\n            activeItem.tab.show();\n        }\n    }\n\n    // Auto called because Card layout triggers the beforeActiveItemChange on its owner\n    onBeforeActiveItemChange(activeItemChangeEvent) {\n        /**\n         * The active tab is about to be changed. Return `false` to prevent this.\n         * @event beforeTabChange\n         * @preventable\n         * @param {Number} activeIndex - The new active index.\n         * @param {Core.widget.Widget} activeItem - The new active child widget.\n         * @param {Number} prevActiveIndex - The previous active index.\n         * @param {Core.widget.Widget} prevActiveItem - The previous active child widget.\n         */\n        return this.trigger('beforeTabChange', activeItemChangeEvent);\n    }\n\n    // Auto called because Card layout triggers the activeItemChange on its owner\n    onActiveItemChange(activeItemChangeEvent) {\n        /**\n         * The active tab has changed.\n         * @event tabChange\n         * @param {Number} activeIndex - The new active index.\n         * @param {Core.widget.Widget} activeItem - The new active child widget.\n         * @param {Number} prevActiveIndex - The previous active index.\n         * @param {Core.widget.Widget} prevActiveItem - The previous active child widget.\n         */\n        this.trigger('tabChange', activeItemChangeEvent);\n    }\n\n    onTabClick(event) {\n        this.activeTab = event.source.item;\n    }\n\n    onPaint() {\n        super.onPaint(...arguments);\n\n        // Measure tabs on first paint if configured to do so\n        if (this.$measureHeight) {\n            this.applyAutoHeight();\n        }\n    }\n\n    //endregion\n}\n\n// Register this widget type with its Factory\nTabPanel.initClass();\n"],
  "mappings": "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",
  "names": ["WebSocketManager", "Events", "Base", "construct", "config", "me", "onWsOpen", "bind", "onWsClose", "onWsMessage", "onWsError", "autoConnect", "address", "open", "doDestroy", "connector", "detachSocketListeners", "close", "isConnecting", "_this$connector", "readyState", "constructor", "webSocketImplementation", "CONNECTING", "isOpened", "_this$connector2", "OPEN", "isClosing", "_this$connector3", "CLOSING", "isClosed", "_this$connector4", "CLOSED", "createWebSocketConnector", "attachSocketListeners", "destroyWebSocketConnector", "addEventListener", "removeEventListener", "_openPromise", "console", "warn", "detacher", "Promise", "resolve", "ion", "error", "then", "value", "catch", "trigger", "send", "command", "data", "_this$connector5", "JSON", "stringify", "event", "message", "parse", "__publicField", "WebSocket", "configurable", "userName", "_$name", "FieldSet", "Panel", "mixin", "Labelable", "$name", "type", "bodyTag", "focusable", "inline", "inlineInternal", "layout", "horizontal", "prototypeProperties", "flexRowCls", "flexColCls", "bodyConfig", "result", "className", "hasLabel", "title", "html", "children", "legendElement", "tag", "text", "class", "compose", "label", "labelCls", "labelWidth", "style", "width", "DomHelper", "unitize", "syncInlineInternal", "_a", "labelPosition", "updateDisabled", "was", "eachWidget", "item", "disabled", "updateInline", "updateInlineInternal", "updateLabel", "updateLabelPosition", "initClass", "Radio", "Checkbox", "alias", "inputType", "clearable", "uncheckedValue", "undefined", "textLabelCls", "internalOnClick", "info", "checked", "updateName", "name", "toggleGroup", "updateClearable", "RadioGroup", "defaultType", "options", "$config", "merge", "defaultBindProperty", "existingOptions", "ensureItems", "filter", "c", "refPrefix", "ref", "id", "selected", "input", "checkedValue", "v", "forEach", "isConfiguring", "getConfig", "changeOptions", "ObjectHelper", "isDeeplyEqual", "convertOption", "key", "option", "existing", "ret", "assign", "Widget", "reconfigure", "isOurRadio", "isRadio", "isolateFieldChange", "field", "onChildAdd", "beforeChange", "change", "click", "thisObj", "onChildRemove", "detachListeners", "onRadioClick", "ev", "source", "onRadioItemBeforeChange", "lastValue", "reverting", "wrapRadioEvent", "uncheckToggleGroupMembers", "onRadioItemChange", "triggerFieldChange", "from", "userAction", "updateOptions", "reduce", "m", "substring", "length", "index", "insert", "Object", "values", "remove", "destroy", "Tab", "Button", "active", "isFirst", "isLast", "itemCls", "tabPanel", "titleProperty", "titleSource", "role", "cls", "setSize", "owner", "visibleChildCount", "tabindex", "dataset", "updateIndex", "updateItem", "_me$itemChangeDetache", "_me$itemHideDetacher", "tab", "ariaElement", "setAttribute", "itemChangeDetacher", "call", "FunctionHelper", "after", "return", "itemHideDetacher", "beforeChangeHidden", "beforeHide", "beforeUpdateDisabled", "prio", "syncMinMax", "updateItemCls", "element", "classList", "DomClassList", "add", "updateRotate", "rotate", "_minWidth", "minWidth", "_minHeight", "minHeight", "_maxWidth", "maxWidth", "_maxHeight", "maxHeight", "tabMinWidth", "tabMaxWidth", "onItemBeforeChangeHidden", "hidingChild", "hidden", "$isDeactivating", "$isActivating", "activeItem", "activateAvailableTab", "onItemBeforeHide", "hide", "onItemBeforeUpdateDisabled", "disablingChild", "onItemConfigChange", "isTab", "t", "TabBar", "Toolbar", "overflow", "ignoreParentReadOnly", "firstTab", "tabAt", "lastTab", "tabCount", "_items", "countOf", "tabs", "ArrayHelper", "toolbarContent", "indexOfTab", "indexOf", "child", "syncTabs", "onFocusIn", "activeIndex", "isNaN", "focus", "i", "n", "find", "isMaximized", "w", "maximized", "TabPanel", "activeTab", "animateTabChange", "autoHeight", "suppressChildHeaders", "tabBar", "weight", "activeTabItemIndex", "_tabBar$tabs$activeTa", "items", "focusElement", "_activeTab$tab", "tabPanelBody", "bodyElement", "finalizeInit", "Error", "setActiveItem", "animation", "silent", "animateCardChange", "initialItems", "makeTabConfig", "tabBarItems", "tabItems", "it", "count", "_activeTab", "Math", "min", "isDisabledOrHiddenTab", "tabIndex", "findAvailableTab", "delta", "itemIndex", "max", "changeActiveTab", "oldActiveTab", "isWidget", "isObject", "parseInt", "cardChangeAnimation", "cardChange", "updateActiveTab", "oldActiveItem", "newActiveItem", "_layout$setActiveItem", "tabSelectionPromise", "containsFocus", "promise", "changeTabBar", "bar", "strips", "Boolean", "initialConfig", "internalListeners", "localizableProperties", "mergeConfigs", "updateItems", "Array", "updateTabMinWidth", "_this$tabBar", "updateTabMaxWidth", "_this$tabBar2", "updateAutoHeight", "GlobalEvents", "theme", "$measureHeight", "applyAutoHeight", "height", "up", "map", "clientHeight", "internalOnThemeChange", "isVisible", "onBeginActiveItemChange", "activeItemChangeEvent", "prevActiveItem", "show", "onBeforeActiveItemChange", "onActiveItemChange", "onTabClick", "onPaint", "arguments"]
}
