{
  "version": 3,
  "sources": ["../../../../chronograph/src/class/Base.js", "../../../../Engine/lib/Engine/calendar/CalendarCacheIntervalMultiple.js", "../../../../Engine/lib/Engine/calendar/CalendarCacheMultiple.js", "../../../../Scheduler/lib/Scheduler/column/DurationColumn.js", "../../../../Scheduler/lib/Scheduler/feature/base/DragBase.js", "../../../../Scheduler/lib/Scheduler/feature/EventResize.js", "../../../../Scheduler/lib/Scheduler/feature/mixin/TaskEditTransactional.js", "../../../../Scheduler/lib/Scheduler/feature/mixin/TransactionalFeature.js", "../../../../Scheduler/lib/Scheduler/feature/base/DragCreateBase.js", "../../../../Scheduler/lib/Scheduler/feature/base/TooltipBase.js", "../../../../Scheduler/lib/Scheduler/feature/AbstractTimeRanges.js", "../../../../Scheduler/lib/Scheduler/feature/ColumnLines.js", "../../../../Scheduler/lib/Scheduler/feature/mixin/DependencyCreation.js", "../../../../Scheduler/lib/Scheduler/feature/mixin/DependencyGridCache.js", "../../../../Scheduler/lib/Scheduler/util/RectangularPathFinder.js", "../../../../Scheduler/lib/Scheduler/feature/mixin/DependencyLineGenerator.js", "../../../../Scheduler/lib/Scheduler/feature/mixin/DependencyTooltip.js", "../../../../Scheduler/lib/Scheduler/feature/Dependencies.js", "../../../../Scheduler/lib/Scheduler/feature/EventFilter.js", "../../../../Scheduler/lib/Scheduler/feature/mixin/NonWorkingTimeMixin.js", "../../../../Scheduler/lib/Scheduler/feature/NonWorkingTime.js", "../../../../Scheduler/lib/Scheduler/feature/ScheduleTooltip.js", "../../../../Scheduler/lib/Scheduler/feature/TimeAxisHeaderMenu.js"],
  "sourcesContent": ["//---------------------------------------------------------------------------------------------------------------------\n/**\n * This is a base class, providing the type-safe static constructor [[new]]. This is very convenient when using\n * [[Mixin|mixins]], as mixins can not have types in the constructors.\n */\nexport class Base {\n    /**\n     * This method applies its 1st argument (if any) to the current instance using `Object.assign()`.\n     *\n     * Supposed to be overridden in the subclasses to customize the instance creation process.\n     *\n     * @param props\n     */\n    initialize(props) {\n        props && Object.assign(this, props);\n    }\n    /**\n     * This is a type-safe static constructor method, accepting a single argument, with the object, corresponding to the\n     * class properties. It will generate a compilation error, if unknown property is provided.\n     *\n     * For example:\n     *\n     * ```ts\n     * class MyClass extends Base {\n     *     prop     : string\n     * }\n     *\n     * const instance : MyClass = MyClass.new({ prop : 'prop', wrong : 11 })\n     * ```\n     *\n     * will produce:\n     *\n     * ```plaintext\n     * TS2345: Argument of type '{ prop: string; wrong: number; }' is not assignable to parameter of type 'Partial<MyClass>'.\n     * Object literal may only specify known properties, and 'wrong' does not exist in type 'Partial<MyClass>'\n     * ```\n     *\n     * The only thing this constructor does is create an instance and call the [[initialize]] method on it, forwarding\n     * the first argument. The customization of instance is supposed to be performed in that method.\n     *\n     * @param props\n     */\n    static new(props) {\n        const instance = new this();\n        instance.initialize(props);\n        return instance;\n    }\n}\n", "import { stripDuplicates } from \"../util/StripDuplicates.js\";\nexport class CalendarCacheIntervalMultiple {\n    constructor(config) {\n        this.intervalGroups = [];\n        config && Object.assign(this, config);\n    }\n    combineWith(interval) {\n        const copy = this.intervalGroups.slice();\n        copy.push([interval.calendar, interval]);\n        return new CalendarCacheIntervalMultiple({ intervalGroups: copy });\n    }\n    getIsWorkingForEvery() {\n        if (this.isWorkingForEvery != null)\n            return this.isWorkingForEvery;\n        for (let [_calendar, intervals] of this.getGroups()) {\n            if (!intervals[0].isWorking)\n                return this.isWorkingForEvery = false;\n        }\n        return this.isWorkingForEvery = true;\n    }\n    getIsWorkingForSome() {\n        if (this.isWorkingForSome != null)\n            return this.isWorkingForSome;\n        for (let [_calendar, intervals] of this.getGroups()) {\n            if (intervals[0].isWorking)\n                return this.isWorkingForSome = true;\n        }\n        return this.isWorkingForSome = false;\n    }\n    getCalendars() {\n        this.getGroups();\n        return this.calendars;\n    }\n    isCalendarWorking(calendar) {\n        return this.getCalendarsWorkStatus().get(calendar);\n    }\n    getCalendarsWorkStatus() {\n        if (this.calendarsWorkStatus)\n            return this.calendarsWorkStatus;\n        const res = new Map();\n        for (let [calendar, intervals] of this.getGroups()) {\n            // <remove-on-release>\n            // TODO: fix types\n            // </remove-on-release>\n            res.set(calendar, intervals[0].isWorking);\n        }\n        return this.calendarsWorkStatus = res;\n    }\n    getCalendarsWorking() {\n        if (this.calendarsWorking)\n            return this.calendarsWorking;\n        const calendars = [];\n        for (let [calendar, intervals] of this.getGroups()) {\n            // <remove-on-release>\n            // TODO: fix types\n            // </remove-on-release>\n            if (intervals[0].isWorking)\n                calendars.push(calendar);\n        }\n        return this.calendarsWorking = calendars;\n    }\n    getCalendarsNonWorking() {\n        if (this.calendarsNonWorking)\n            return this.calendarsNonWorking;\n        const calendars = [];\n        for (let [calendar, intervals] of this.getGroups()) {\n            // <remove-on-release>\n            // TODO: fix types\n            // </remove-on-release>\n            if (!intervals[0].isWorking)\n                calendars.push(calendar);\n        }\n        return this.calendarsNonWorking = calendars;\n    }\n    getGroups() {\n        if (this.intervalsByCalendar)\n            return this.intervalsByCalendar;\n        const calendars = this.calendars = [];\n        const intervalsByCalendar = new Map();\n        this.intervalGroups.forEach(([calendar, interval]) => {\n            let data = intervalsByCalendar.get(calendar);\n            if (!data) {\n                calendars.push(calendar);\n                data = [];\n                intervalsByCalendar.set(calendar, data);\n            }\n            data.push.apply(data, interval.intervals);\n        });\n        intervalsByCalendar.forEach((intervals, calendar) => {\n            const unique = stripDuplicates(intervals);\n            unique.sort(\n            // sort in decreasing order\n            (interval1, interval2) => interval2.getPriorityField() - interval1.getPriorityField());\n            intervalsByCalendar.set(calendar, unique);\n        });\n        return this.intervalsByCalendar = intervalsByCalendar;\n    }\n}\n", "import { stripDuplicates } from \"../util/StripDuplicates.js\";\nimport { CalendarCache } from \"./CalendarCache.js\";\nimport { CalendarCacheIntervalMultiple } from \"./CalendarCacheIntervalMultiple.js\";\nimport { IntervalCache } from \"./IntervalCache.js\";\n/**\n * The calendar cache for combination of multiple calendars\n */\nexport class CalendarCacheMultiple extends CalendarCache {\n    constructor(config) {\n        super(config);\n        this.calendarCaches = stripDuplicates(this.calendarCaches);\n        this.intervalCache = new IntervalCache({\n            emptyInterval: new CalendarCacheIntervalMultiple(),\n            combineIntervalsFn: (interval1, interval2) => {\n                return interval1.combineWith(interval2);\n            }\n        });\n    }\n    fillCache(startDate, endDate) {\n        this.calendarCaches.forEach(calendarCache => {\n            calendarCache.fillCache(startDate, endDate);\n            this.includeWrappingRangeFrom(calendarCache, startDate, endDate);\n        });\n    }\n}\nconst COMBINED_CALENDARS_CACHE = new Map();\nexport const combineCalendars = (calendars) => {\n    const uniqueOnly = stripDuplicates(calendars);\n    if (uniqueOnly.length === 0)\n        throw new Error(\"No calendars to combine\");\n    uniqueOnly.sort((calendar1, calendar2) => {\n        if (calendar1.internalId < calendar2.internalId)\n            return -1;\n        else\n            return 1;\n    });\n    const hash = uniqueOnly.map(calendar => calendar.internalId + '/').join('');\n    const versionsHash = uniqueOnly.map(calendar => calendar.version + '/').join('');\n    let cached = COMBINED_CALENDARS_CACHE.get(hash);\n    let res;\n    if (cached && cached.versionsHash === versionsHash)\n        res = cached.cache;\n    else {\n        res = new CalendarCacheMultiple({ calendarCaches: uniqueOnly.map(calendar => calendar.calendarCache) });\n        // COMBINED_CALENDARS_CACHE.set(hash, {\n        //     versionsHash    : versionsHash,\n        //     cache           : res\n        // })\n    }\n    return res;\n};\n", "import ColumnStore from '../../Grid/data/ColumnStore.js';\nimport NumberColumn from '../../Grid/column/NumberColumn.js';\nimport Duration from '../../Core/data/Duration.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport '../../Core/widget/DurationField.js';\n\n/**\n * @module Scheduler/column/DurationColumn\n */\n\n/**\n * A column showing the task {@link Scheduler/model/TimeSpan#field-fullDuration duration}. Please note, this column\n * is preconfigured and expects its field to be of the {@link Core.data.Duration} type.\n *\n * The default editor is a {@link Core.widget.DurationField}. It parses time units, so you can enter \"4d\"\n * indicating 4 days duration, or \"4h\" indicating 4 hours, etc. The numeric magnitude can be either an integer or a\n * float value. Both \",\" and \".\" are valid decimal separators. For example, you can enter \"4.5d\" indicating 4.5 days\n * duration, or \"4,5h\" indicating 4.5 hours.\n *\n * {@inlineexample Scheduler/column/DurationColumn.js}\n * @extends Grid/column/NumberColumn\n * @classType duration\n * @column\n */\nexport default class DurationColumn extends NumberColumn {\n    compositeField = true;\n\n    //region Config\n\n    static get $name() {\n        return 'DurationColumn';\n    }\n\n    static get type() {\n        return 'duration';\n    }\n\n    static get isGanttColumn() {\n        return true;\n    }\n\n    static get fields() {\n        return [\n            /**\n             * Precision of displayed duration, defaults to use {@link Scheduler.view.Scheduler#config-durationDisplayPrecision}.\n             * Specify an integer value to override that setting, or `false` to use raw value\n             * @config {Number|Boolean} decimalPrecision\n             */\n            { name : 'decimalPrecision', defaultValue : 1 }\n        ];\n    }\n\n    static get defaults() {\n        return {\n            /**\n             * Min value\n             * @config {Number}\n             */\n            min : null,\n\n            /**\n             * Max value\n             * @config {Number}\n             */\n            max : null,\n\n            /**\n             * Step size for spin button clicks.\n             * @member {Number} step\n             */\n            /**\n             * Step size for spin button clicks. Also used when pressing up/down keys in the field.\n             * @config {Number}\n             * @default\n             */\n            step : 1,\n\n            /**\n             * Large step size, defaults to 10 * `step`. Applied when pressing SHIFT and stepping either by click or\n             * using keyboard.\n             * @config {Number}\n             * @default 10\n             */\n            largeStep : 0,\n\n            field         : 'fullDuration',\n            text          : 'L{Duration}',\n            instantUpdate : true,\n            // Undocumented, used by Filter feature to get type of the filter field\n            filterType    : 'duration',\n\n            sortable(durationEntity1, durationEntity2) {\n                const\n                    ms1 = durationEntity1.getValue(this.field),\n                    ms2 = durationEntity2.getValue(this.field);\n\n                return ms1 - ms2;\n            }\n        };\n    }\n\n    construct() {\n        super.construct(...arguments);\n\n        const sortFn = this.sortable;\n\n        this.sortable = (...args) => sortFn.call(this, ...args);\n    }\n\n    get defaultEditor() {\n        const { max, min, step, largeStep } = this;\n\n        // Remove any undefined configs, to allow config system to use default values instead\n        return ObjectHelper.cleanupProperties({\n            type : 'duration',\n            name : this.field,\n            max,\n            min,\n            step,\n            largeStep\n        });\n    }\n\n    //endregion\n\n    //region Internal\n\n    get durationUnitField() {\n        return `${this.field}Unit`;\n    }\n\n    roundValue(duration) {\n        const\n            nbrDecimals = typeof this.grid.durationDisplayPrecision === 'number' ? this.grid.durationDisplayPrecision : this.decimalPrecision,\n            multiplier  = Math.pow(10, nbrDecimals),\n            rounded     = Math.round(duration * multiplier) / multiplier;\n\n        return rounded;\n    }\n\n    formatValue(duration, durationUnit) {\n        if (duration instanceof Duration) {\n            durationUnit = duration.unit;\n            duration     = duration.magnitude;\n        }\n\n        duration = this.roundValue(duration);\n\n        return duration + ' ' + DateHelper.getLocalizedNameOfUnit(durationUnit, duration !== 1);\n    }\n\n    //endregion\n\n    //region Render\n\n    defaultRenderer({ value, record, isExport }) {\n        const\n            type          = typeof value,\n            durationValue = type === 'number' ? value : value?.magnitude,\n            durationUnit  = type === 'number' ? record.getValue(this.durationUnitField) : value?.unit;\n\n        // in case of bad input (for instance NaN, undefined or NULL value)\n        if (typeof durationValue !== 'number') {\n            return isExport ? '' : null;\n        }\n\n        return this.formatValue(durationValue, durationUnit);\n    }\n\n    //endregion\n\n    // Used with CellCopyPaste as fullDuration doesn't work via record.get\n    toClipboardString({ record }) {\n        return record.getValue(this.field).toString();\n    }\n\n    fromClipboardString({ string, record }) {\n        const duration = DateHelper.parseDuration(string, true, this.durationUnit);\n\n        if (duration && 'magnitude' in duration) {\n            return duration;\n        }\n\n        return record.fullDuration;\n    }\n\n    calculateFillValue({ value, record }) {\n        return this.fromClipboardString({ string : value, record });\n    }\n\n}\n\nColumnStore.registerColumnType(DurationColumn);\n", "import InstancePlugin from '../../../Core/mixin/InstancePlugin.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport DragHelper from '../../../Core/helper/DragHelper.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport ClockTemplate from '../../tooltip/ClockTemplate.js';\nimport Tooltip from '../../../Core/widget/Tooltip.js';\nimport Objects from '../../../Core/helper/util/Objects.js';\nimport Widget from '../../../Core/widget/Widget.js';\n\n/**\n * @module Scheduler/feature/base/DragBase\n */\n\n// <remove-on-release>\n// TODO: shift to copy\n// </remove-on-release>\n\n/**\n * Base class for EventDrag (Scheduler) and TaskDrag (Gantt) features. Contains shared code. Not to be used directly.\n *\n * @extends Core/mixin/InstancePlugin\n * @abstract\n */\nexport default class DragBase extends InstancePlugin {\n    //region Config\n\n    static get defaultConfig() {\n        return {\n            // documented on Schedulers EventDrag feature and Gantt's TaskDrag\n            tooltipTemplate : data => `\n                <div class=\"b-sch-tip-${data.valid ? 'valid' : 'invalid'}\">\n                    ${data.startClockHtml}\n                    ${data.endClockHtml}\n                    <div class=\"b-sch-tip-message\">${data.message}</div>\n                </div>\n            `,\n\n            /**\n             * Specifies whether or not to show tooltip while dragging event\n             * @config {Boolean}\n             * @default\n             */\n            showTooltip : true,\n\n            /**\n             * When enabled, the event being dragged always \"snaps\" to the exact start date that it will have after drop.\n             * @config {Boolean}\n             * @default\n             */\n            showExactDropPosition : false,\n\n            /*\n             * The store from which the dragged items are mapped to the UI.\n             * In Scheduler's implementation of this base class, this will be\n             * an EventStore, in Gantt's implementations, this will be a TaskStore.\n             * Because both derive from this base, we must refer to it as this.store.\n             * @private\n             */\n            store : null,\n\n            /**\n             * An object used to configure the internal {@link Core.helper.DragHelper} class\n             * @config {DragHelperConfig}\n             */\n            dragHelperConfig : null,\n\n            tooltipCls : 'b-eventdrag-tooltip'\n        };\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * Set to `false` to allow dragging tasks outside the client Scheduler.\n             * Useful when you want to drag tasks between multiple Scheduler instances\n             * @config {Boolean}\n             * @default\n             */\n            constrainDragToTimeline : true,\n\n            // documented on Schedulers EventDrag feature, not used for Gantt\n            constrainDragToResource : true,\n\n            constrainDragToTimeSlot : false,\n\n            /**\n             * Yields the {@link Core.widget.Tooltip} which tracks the event during a drag operation.\n             * @member {Core.widget.Tooltip} tip\n             */\n            /**\n             * A config object to allow customization of the {@link Core.widget.Tooltip} which tracks\n             * the event during a drag operation.\n             * @config {TooltipConfig}\n             */\n            tip : {\n                $config : ['lazy', 'nullify'],\n                value   : {\n                    align : {\n                        align          : 'b-t',\n                        allowTargetOut : true\n                    },\n                    autoShow                 : true,\n                    updateContentOnMouseMove : true\n                }\n            },\n\n            /**\n             * The `eventDrag`and `taskDrag` events are normally only triggered when the drag operation will lead to a\n             * change in date or assignment. By setting this config to `false`, that logic is bypassed to trigger events\n             * for each native mouse move event.\n             * @prp {Boolean}\n             */\n            throttleDragEvent : true\n        };\n    }\n\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['onPaint']\n        };\n    }\n\n    //endregion\n\n    //region Init\n\n    internalSnapToPosition(snapTo) {\n        const { dragData } = this;\n\n        this.snapToPosition?.({\n            assignmentRecord : dragData.assignmentRecord,\n            eventRecord      : dragData.eventRecord,\n            resourceRecord   : dragData.newResource || dragData.resourceRecord,\n            startDate        : dragData.startDate,\n            endDate          : dragData.endDate,\n            snapTo\n        });\n    }\n\n    buildDragHelperConfig() {\n        const\n            me                                  = this,\n            {\n                client,\n                constrainDragToTimeline,\n                constrainDragToResource,\n                constrainDragToTimeSlot,\n                dragHelperConfig = {}\n            }                                   = me,\n            { timeAxisViewModel, isHorizontal } = client,\n            lockY                               = isHorizontal ? constrainDragToResource : constrainDragToTimeSlot,\n            lockX                               = isHorizontal ? constrainDragToTimeSlot : constrainDragToResource;\n\n        // If implementer wants to allow users dragging outside the timeline element, setup the internal dropTargetSelector\n        if (me.externalDropTargetSelector) {\n            dragHelperConfig.dropTargetSelector = `.b-timeaxissubgrid,${me.externalDropTargetSelector}`;\n        }\n\n        return Objects.merge({\n            name                 : me.constructor.name, // useful when debugging with multiple draggers\n            positioning          : 'absolute',\n            lockX,\n            lockY,\n            minX                 : true, // Allows dropping with start before time axis\n            maxX                 : true, // Allows dropping with end after time axis\n            constrain            : false,\n            cloneTarget          : !constrainDragToTimeline,\n            // If we clone event dragged bars, we assume ownership upon drop so we can reuse the element and have animations\n            removeProxyAfterDrop : false,\n            dragWithin           : constrainDragToTimeline ? null : document.body,\n            hideOriginalElement  : true,\n            dropTargetSelector   : '.b-timelinebase',\n\n            // A CSS class added to drop target while dragging events\n            dropTargetCls : me.externalDropTargetSelector ? 'b-drop-target' : '',\n\n            outerElement   : client.timeAxisSubGridElement,\n            targetSelector : client.eventSelector,\n            scrollManager  : constrainDragToTimeline ? client.scrollManager : null,\n            createProxy    : el => me.createProxy(el),\n\n            snapCoordinates : ({ element, newX, newY }) => {\n                const { dragData } = me;\n                // Snapping not supported when dragging outside a scheduler\n                if (me.constrainDragToTimeline && !me.constrainDragToTimeSlot && (me.showExactDropPosition || timeAxisViewModel.snap)) {\n                    const\n                        draggedEventRecord = dragData.draggedEntities[0],\n                        coordinate         = me.getCoordinate(draggedEventRecord, element, [newX, newY]),\n                        snappedDate        = timeAxisViewModel.getDateFromPosition(coordinate, 'round'),\n                        { calendar }       = draggedEventRecord;\n\n                    if (!calendar || snappedDate && calendar.isWorkingTime(snappedDate, DateHelper.add(snappedDate, draggedEventRecord.fullDuration))) {\n                        const snappedPosition = snappedDate && timeAxisViewModel.getPositionFromDate(snappedDate);\n\n                        if (snappedDate && snappedDate >= client.startDate && snappedPosition != null) {\n                            if (isHorizontal) {\n                                newX = snappedPosition;\n                            }\n                            else {\n                                newY = snappedPosition;\n                            }\n                        }\n                    }\n                }\n\n                const snapTo = { x : newX, y : newY };\n\n                me.internalSnapToPosition(snapTo);\n\n                return snapTo;\n            },\n            internalListeners : {\n                beforedragstart : 'onBeforeDragStart',\n                dragstart       : 'onDragStart',\n                afterdragstart  : 'onAfterDragStart',\n                drag            : 'onDrag',\n                drop            : 'onDrop',\n                abort           : 'onDragAbort',\n                abortFinalized  : 'onDragAbortFinalized',\n                reset           : 'onDragReset',\n                thisObj         : me\n            }\n        }, dragHelperConfig, {\n            isElementDraggable : (el, event) => {\n                return (!dragHelperConfig || !dragHelperConfig.isElementDraggable || dragHelperConfig.isElementDraggable(el, event)) &&\n                    me.isElementDraggable(el, event);\n            }\n        });\n    }\n\n    /**\n     * Called when scheduler is rendered. Sets up drag and drop and hover tooltip.\n     * @private\n     */\n    onPaint({ firstPaint }) {\n        const\n            me         = this,\n            { client } = me;\n\n        me.drag?.destroy();\n\n        me.drag = DragHelper.new(me.buildDragHelperConfig());\n\n        if (firstPaint) {\n            client.rowManager.ion({\n                changeTotalHeight : () => me.updateYConstraint(me.dragData?.[`${client.scheduledEventName}Record`]),\n                thisObj           : me\n            });\n        }\n\n        if (me.showTooltip) {\n            me.clockTemplate = new ClockTemplate({\n                scheduler : client\n            });\n        }\n    }\n\n    doDestroy() {\n        this.drag?.destroy();\n        this.clockTemplate?.destroy();\n        this.tip?.destroy();\n        super.doDestroy();\n    }\n\n    get tipId() {\n        return `${this.client.id}-event-drag-tip`;\n    }\n\n    changeTip(tip, oldTip) {\n        const me = this;\n\n        if (tip) {\n            const result = Tooltip.reconfigure(oldTip, Tooltip.mergeConfigs({\n                forElement : me.element,\n                id         : me.tipId,\n                getHtml    : me.getTipHtml.bind(me),\n                cls        : me.tooltipCls,\n                owner      : me.client\n            }, tip), {\n                owner    : me.client,\n                defaults : {\n                    type : 'tooltip'\n                }\n            });\n\n            result.ion({ innerHtmlUpdate : 'updateDateIndicator', thisObj : me });\n\n            return result;\n        }\n        else {\n            oldTip?.destroy();\n        }\n    }\n\n    //endregion\n\n    //region Drag events\n\n    createProxy(element) {\n        const proxy = element.cloneNode(true);\n        delete proxy.id;\n\n        proxy.classList.add(`b-sch-${this.client.mode}`);\n        return proxy;\n    }\n\n    onBeforeDragStart({ context, event }) {\n        const\n            me             = this,\n            { client }     = me,\n            dragData       = me.getMinimalDragData(context, event),\n            eventRecord    = dragData?.[`${client.scheduledEventName}Record`],\n            resourceRecord = dragData.resourceRecord;\n\n        if (client.readOnly || me.disabled || !eventRecord || eventRecord.isDraggable === false || eventRecord.readOnly || resourceRecord?.readOnly) {\n            return false;\n        }\n\n        // Cache the date corresponding to the drag start point so that on drag, we can always\n        // perform the same calculation to then find the time delta without having to calculate\n        // the new start and end times from the position that the element is.\n        context.pointerStartDate = client.getDateFromXY([context.startClientX, context.startPageY], null, false);\n\n        const result = me.triggerBeforeEventDrag(\n            `before${client.capitalizedEventName}Drag`,\n            {\n                ...dragData,\n                event,\n                // to be deprecated\n                context : {\n                    ...context,\n                    ...dragData\n                }\n            }\n        ) !== false;\n\n        if (result) {\n            me.updateYConstraint(eventRecord, resourceRecord);\n\n            // Hook for features that need to react to drag starting, used by NestedEvents\n            client[`before${client.capitalizedEventName}DragStart`]?.(context, dragData);\n        }\n\n        return result;\n    }\n\n    onAfterDragStart({ context, event }) {}\n\n    /**\n     * Returns true if a drag operation is active\n     * @property {Boolean}\n     * @readonly\n     */\n    get isDragging() {\n        return this.drag?.isDragging;\n    }\n\n    // Checked by dependencies to determine if live redrawing is needed\n    get isActivelyDragging() {\n        return this.isDragging && !this.finalizing;\n    }\n\n    /**\n     * Triggered when dragging of an event starts. Initializes drag data associated with the event being dragged.\n     * @private\n     */\n    onDragStart({ context, event }) {\n        const\n            me     = this,\n            // When testing with Selenium, it simulates drag and drop with a single mousemove event, we might be over\n            // another client already\n            client = me.findClientFromTarget(event, context) ?? me.client;\n\n        me.currentOverClient = client;\n        me.drag.unifiedProxy = me.unifiedDrag;\n\n        me.onMouseOverNewTimeline(client, true);\n\n        const dragData = me.dragData = me.getDragData(context);\n\n        // Do not let DomSync reuse the element\n        me.suspendElementRedrawing(context.element);\n\n        if (me.showTooltip && me.tip) {\n            const tipTarget = dragData.context.dragProxy ? dragData.context.dragProxy.firstChild : context.element;\n\n            me.tip.showBy(tipTarget);\n        }\n\n        me.triggerDragStart(dragData);\n\n        // Hook for features that need to take action after drag starts\n        client[`after${client.capitalizedEventName}DragStart`]?.(context, dragData);\n\n        const\n            {\n                eventMenu,\n                taskMenu\n            }           = client.features,\n            menuFeature = eventMenu || taskMenu;\n\n        // If this is a touch action, hide the context menu which may have shown\n        menuFeature?.hideContextMenu?.(false);\n    }\n\n    updateDateIndicator() {\n        const\n            { startDate, endDate } = this.dragData,\n            { tip, clockTemplate } = this,\n            endDateElement         = tip.element.querySelector('.b-sch-tooltip-enddate');\n\n        clockTemplate.updateDateIndicator(tip.element, startDate);\n\n        endDateElement && clockTemplate.updateDateIndicator(endDateElement, endDate);\n    }\n\n    findClientFromTarget(event, context) {\n        let { target } = event;\n\n        // Can't detect target under a touch event\n        if (/^touch/.test(event.type)) {\n            const center = Rectangle.from(context.element, null, true).center;\n\n            target = DomHelper.elementFromPoint(center.x, center.y);\n        }\n\n        const client = Widget.fromElement(target, 'timelinebase');\n        // Do not allow drops on histogram widgets\n        return client?.isResourceHistogram ? null : client;\n    }\n\n    /**\n     * Triggered while dragging an event. Updates drag data, validation etc.\n     * @private\n     */\n    onDrag({ context, event }) {\n        const\n            me    = this,\n            dd    = me.dragData,\n            start = dd.startDate;\n\n        let client;\n\n        if (me.constrainDragToTimeline) {\n            client = me.client;\n        }\n        else {\n            client = me.findClientFromTarget(event, dd.context);\n        }\n\n        me.updateDragContext(context, event);\n\n        if (!client) {\n            return;\n        }\n\n        if (client !== me.currentOverClient) {\n            me.onMouseOverNewTimeline(client);\n        }\n\n        //this.checkShiftChange();\n\n        // Let product specific implementations trigger drag event (eventDrag, taskDrag)\n        if (dd.dirty || !me.throttleDragEvent) {\n            const valid = dd.valid;\n\n            me.triggerEventDrag(dd, start);\n\n            if (valid !== dd.valid) {\n                dd.context.valid = dd.externalDragValidity = dd.valid;\n            }\n        }\n\n        if (me.showTooltip && me.tip) {\n            // If we've an error message to show, force the tip to be visible\n            // even if the target is not in view.\n            me.tip.lastAlignSpec.allowTargetOut = !dd.valid;\n            me.tip.realign();\n        }\n    }\n\n    onMouseOverNewTimeline(newTimeline, initial) {\n        const\n            me                          = this,\n            { drag : { lockX, lockY } } = me,\n            scrollables                 = [];\n\n        me.currentOverClient.element.classList.remove('b-dragging-' + me.currentOverClient.scheduledEventName);\n\n        newTimeline.element.classList.add('b-dragging-' + newTimeline.scheduledEventName);\n\n        if (!initial) {\n            me.currentOverClient.scrollManager.stopMonitoring();\n        }\n\n        if (!lockX) {\n            scrollables.push({\n                element   : newTimeline.timeAxisSubGrid.scrollable.element,\n                direction : 'horizontal'\n            });\n        }\n\n        if (!lockY) {\n            scrollables.push({\n                element   : newTimeline.scrollable.element,\n                direction : 'vertical'\n            });\n        }\n\n        newTimeline.scrollManager.startMonitoring({\n            scrollables,\n            callback : me.drag.onScrollManagerScrollCallback\n        });\n\n        me.currentOverClient = newTimeline;\n    }\n\n    triggerBeforeEventDropFinalize(eventType, eventData, client) {\n        client.trigger(eventType, eventData);\n    }\n\n    /**\n     * Triggered when dropping an event. Finalizes the operation.\n     * @private\n     */\n    onDrop({ context, event }) {\n        const\n            me                    = this,\n            { currentOverClient, dragData } = me;\n\n        let modified = false;\n\n        // Stop monitoring early, to avoid scrolling during finalization\n        currentOverClient?.scrollManager.stopMonitoring();\n\n        me.tip?.hide();\n\n        context.valid = context.valid && me.isValidDrop(dragData);\n\n        // If dropping outside scheduler, we opt in on DragHelper removing the proxy element\n        me.drag.removeProxyAfterDrop = Boolean(dragData.externalDropTarget);\n\n        if (context.valid && dragData.startDate && dragData.endDate) {\n            let beforeDropTriggered = false;\n\n            dragData.finalize = async(valid) => {\n                if (beforeDropTriggered || dragData.async) {\n                    await me.finalize(valid);\n                }\n                else {\n                    // If user finalized operation synchronously in the beforeDropFinalize listener, just use\n                    // the valid param and carry on\n                    // but ignore it, if the context is already marked as invalid\n                    context.valid = context.valid && valid;\n                }\n            };\n\n            me.triggerBeforeEventDropFinalize(`before${currentOverClient.capitalizedEventName}DropFinalize`, {\n                context  : dragData,\n                domEvent : event\n            }, currentOverClient);\n\n            beforeDropTriggered = true;\n\n            // Allow implementer to take control of the flow, by returning false from this listener,\n            // to show a confirmation popup etc. This event is documented in EventDrag and TaskDrag\n            context.async = dragData.async;\n\n            // Internal validation, making sure all dragged records fit inside the view\n            if (!context.async && !dragData.externalDropTarget) {\n                modified = (dragData.startDate - dragData.origStart) !== 0 || dragData.newResource !== dragData.resourceRecord;\n            }\n        }\n\n        if (!context.async) {\n            me.finalize(dragData.valid && context.valid && modified);\n        }\n    }\n\n    onDragAbort({ context }) {\n        const me = this;\n\n        // Stop monitoring early, to avoid scrolling during finalization\n        me.currentOverClient?.scrollManager.stopMonitoring();\n\n        me.client.currentOrientation.onDragAbort({ context, dragData : me.dragData });\n\n        // otherwise the event disappears on next refresh (#62)\n        me.resetDraggedElements();\n\n        me.tip?.hide();\n\n        // Trigger eventDragAbort / taskDragAbort depending on product\n        me.triggerDragAbort(me.dragData);\n    }\n\n    // Fired after any abort animation has completed (the point where we want to trigger redraw of progress lines etc)\n    onDragAbortFinalized({ context }) {\n        const me = this;\n\n        me.triggerDragAbortFinalized(me.dragData);\n\n        // Hook for features that need to react on drag abort, used by NestedEvents\n        me.client[`after${me.client.capitalizedEventName}DragAbortFinalized`]?.(context, me.dragData);\n    }\n\n    // For the drag across multiple schedulers, tell all involved scroll managers to stop monitoring\n    onDragReset({ source : dragHelper }) {\n        const\n            me              = this,\n            currentTimeline = me.currentOverClient;\n\n        if (dragHelper.context?.started) {\n            me.resetDraggedElements();\n\n            currentTimeline.trigger(`${currentTimeline.scheduledEventName}DragReset`);\n        }\n\n        currentTimeline?.element.classList.remove(`b-dragging-${currentTimeline.scheduledEventName}`);\n        me.dragData = null;\n    }\n\n    resetDraggedElements() {\n        const\n            { dragData }                     = this,\n            { eventBarEls, draggedEntities } = dragData;\n\n        this.resumeRecordElementRedrawing(dragData.record);\n\n        draggedEntities.forEach((record, i) => {\n            this.resumeRecordElementRedrawing(record);\n\n            // <remove-on-release>\n            // TODO: why?\n            // </remove-on-release>\n            eventBarEls[i].classList.remove(this.drag.draggingCls);\n            eventBarEls[i].retainElement = false;\n        });\n\n        // Code expects 1:1 ratio between eventBarEls & dragged assignments, but when dragging an event of a linked\n        // resource that is not the case, and we need to clean up some more\n        dragData.context.element.retainElement = false;\n    }\n\n    /**\n     * Triggered internally on invalid drop.\n     * @private\n     */\n    onInternalInvalidDrop(abort) {\n        const\n            me          = this,\n            { context } = me.drag;\n\n        me.tip?.hide();\n\n        me.triggerAfterDrop(me.dragData, false);\n\n        context.valid = false;\n\n        if (abort) {\n            me.drag.abort();\n        }\n    }\n\n    //endregion\n\n    //region Finalization & validation\n\n    /**\n     * Called on drop to update the record of the event being dropped.\n     * @private\n     * @param {Boolean} updateRecords Specify true to update the record, false to treat as invalid\n     */\n    async finalize(updateRecords) {\n        const\n            me                              = this,\n            { dragData, currentOverClient } = me,\n            clientEventTipFeature           = currentOverClient.features.taskTooltip || currentOverClient.features.eventTooltip;\n\n        // Drag could've been aborted by window blur event. If it is aborted - we have nothing to finalize.\n        if (!dragData || me.finalizing) {\n            return;\n        }\n\n        const { context, draggedEntities, externalDropTarget } = dragData;\n\n        let result;\n\n        me.finalizing = true;\n\n        draggedEntities.forEach((record, i) => {\n            me.resumeRecordElementRedrawing(record);\n\n            // <remove-on-release>\n            // TODO: Why is this needed? EventResize.t.js fails without it\n            // </remove-on-release>\n            dragData.eventBarEls[i].classList.remove(me.drag.draggingCls);\n            dragData.eventBarEls[i].retainElement = false;\n        });\n\n        // Code expects 1:1 ratio between eventBarEls & dragged assignments, but when dragging an event of a linked\n        // resource that is not the case, and we need to clean up some more\n        context.element.retainElement = false;\n\n        if ((externalDropTarget && dragData.valid) || updateRecords) {\n            // updateRecords may or may not be async.\n            // We see if it returns a Promise.\n            result = me.updateRecords(dragData);\n\n            // If updateRecords is async, the calling DragHelper must know this and\n            // go into a awaitingFinalization state.\n            if (!externalDropTarget && Objects.isPromise(result)) {\n                context.async = true;\n                await result;\n            }\n\n            // If the finalize handler decided to change the dragData's validity...\n            if (!dragData.valid) {\n                me.onInternalInvalidDrop(true);\n            }\n            else {\n                if (context.async) {\n                    context.finalize();\n                }\n                if (externalDropTarget) {\n                    // Force a refresh early so that removed events will not temporary be visible while engine is\n                    // recalculating (the row below clears the 'b-hidden' CSS class of the original drag element)\n                    me.client.refreshRows(false);\n                }\n                me.triggerAfterDrop(dragData, true);\n            }\n        }\n        else {\n            me.onInternalInvalidDrop(context.async || dragData.async);\n        }\n\n        me.finalizing = false;\n\n        // Prevent event tooltip showing after a drag drop\n        if (clientEventTipFeature?.enabled) {\n            clientEventTipFeature.disabled = true;\n\n            currentOverClient.setTimeout(() => {\n                clientEventTipFeature.disabled = false;\n            }, 200);\n        }\n\n        return result;\n    }\n\n    //endregion\n\n    //region Drag data\n\n    /**\n     * Updates drag data's dates and validity (calls #validatorFn if specified)\n     * @private\n     */\n    updateDragContext(info, event) {\n        const\n            me                  = this,\n            { drag }            = me,\n            dd                  = me.dragData,\n            client              = me.currentOverClient,\n            { isHorizontal }    = client,\n            [record]            = dd.draggedEntities,\n            eventRecord         = record.isAssignment ? record.event : record,\n            lastDragStartDate   = dd.startDate,\n            constrainToTimeSlot = me.constrainDragToTimeSlot || (isHorizontal ? drag.lockX : drag.lockY);\n\n        dd.browserEvent = event;\n\n        // getProductDragContext may switch valid flag, need to keep it here\n        Object.assign(dd, me.getProductDragContext(dd));\n\n        if (constrainToTimeSlot) {\n            dd.timeDiff = 0;\n        }\n        else {\n            let timeDiff;\n\n            // Time diff is calculated differently for continuous and non-continuous time axis\n            if (client.timeAxis.isContinuous) {\n                const\n                    timeAxisPosition = client.isHorizontal ? info.pageX ?? info.startPageX : info.pageY ?? info.startPageY,\n                    // Use the localized coordinates to ask the TimeAxisViewModel what date the mouse is at.\n                    // Pass allowOutOfRange as true in case we have dragged out of either side of the timeline viewport.\n                    pointerDate      = client.getDateFromCoordinate(timeAxisPosition, null, false, true);\n\n                timeDiff = dd.timeDiff = pointerDate - info.pointerStartDate;\n            }\n            else {\n                const range = me.resolveStartEndDates(info.element);\n\n                // if dragging is out of timeAxis rect bounds, we will not be able to get dates\n                dd.valid = Boolean(range.startDate && range.endDate);\n\n                if (dd.valid) {\n                    timeDiff = range.startDate - dd.origStart;\n                }\n            }\n\n            // If we got a time diff, we calculate new dates the same way no matter if it's continuous or not.\n            // This prevents no-change drops in non-continuous time axis from being processed by updateAssignments()\n            if (timeDiff !== null) {\n                // calculate and round new startDate based on actual timeDiff\n                dd.startDate = me.adjustStartDate(dd.origStart, timeDiff);\n\n                dd.endDate = DateHelper.add(dd.startDate, eventRecord.fullDuration);\n\n                if (dd.valid) {\n                    dd.timeDiff = dd.startDate - dd.origStart;\n                }\n            }\n        }\n\n        const positionDirty = dd.dirty = dd.dirty || lastDragStartDate - dd.startDate !== 0;\n\n        if (dd.valid) {\n            // If it's fully outside, we don't allow them to drop it - the event would disappear from their control.\n            if (me.constrainDragToTimeline && (dd.endDate <= client.timeAxis.startDate || dd.startDate >= client.timeAxis.endDate)) {\n                dd.valid           = false;\n                dd.context.message = me.L('L{EventDrag.noDropOutsideTimeline}');\n            }\n            else if (positionDirty || dd.externalDropTarget) {\n                // Used to rely on faulty code above that would not be valid initially. With that changed we ignore\n                // checking validity here on drag start, which is detected by not having a pageX\n                const result = dd.externalDragValidity = !event || (info.pageX && me.checkDragValidity(dd, event));\n\n                if (!result || typeof result === 'boolean') {\n                    dd.valid           = result !== false;\n                    dd.context.message = '';\n                }\n                else {\n                    dd.valid           = result.valid !== false;\n                    dd.context.message = result.message;\n                }\n            }\n            else {\n                // Apply cached value from external drag validation\n                dd.valid = dd.externalDragValidity !== false && dd.externalDragValidity?.valid !== false;\n            }\n        }\n        else {\n            dd.valid = false;\n        }\n\n        dd.context.valid = dd.valid;\n    }\n\n    suspendRecordElementRedrawing(record, suspend = true) {\n        this.suspendElementRedrawing(this.getRecordElement(record), suspend);\n        // <remove-on-release>\n        // TODO: temporary get rid of retainElement joggling to check tests\n        // </remove-on-release>\n        record.instanceMeta(this.client).retainElement = suspend;\n    }\n\n    resumeRecordElementRedrawing(record) {\n        this.suspendRecordElementRedrawing(record, false);\n    }\n\n    suspendElementRedrawing(element, suspend = true) {\n        // <remove-on-release>\n        // TODO: temporary get rid of retainElement joggling to check tests\n        // </remove-on-release>\n        if (element) {\n            element.retainElement = suspend;\n        }\n    }\n\n    resumeElementRedrawing(element) {\n        this.suspendElementRedrawing(element, false);\n    }\n\n    /**\n     * Initializes drag data (dates, constraints, dragged events etc). Called when drag starts.\n     * @private\n     * @param info\n     * @returns {*}\n     */\n    getDragData(info) {\n        const\n            me                = this,\n            { client, drag }  = me,\n            productDragData   = me.setupProductDragData(info),\n            {\n                record,\n                eventBarEls,\n                draggedEntities\n            }                 = productDragData,\n            { startEvent }    = drag,\n            timespan          = record.isAssignment ? record.event : record,\n            origStart         = timespan.startDate,\n            origEnd           = timespan.endDate,\n            timeAxis          = client.timeAxis,\n            startsOutsideView = origStart < timeAxis.startDate,\n            endsOutsideView   = origEnd > timeAxis.endDate,\n            multiSelect       = client.isSchedulerBase ? client.multiEventSelect : client.selectionMode.multiSelect,\n            coordinate        = me.getCoordinate(timespan, info.element, [info.elementStartX, info.elementStartY]),\n            clientCoordinate  = me.getCoordinate(timespan, info.element, [info.startClientX, info.startClientY]);\n\n        me.suspendRecordElementRedrawing(record);\n\n        // prevent elements from being released when out of view\n        draggedEntities.forEach(record => me.suspendRecordElementRedrawing(record));\n\n        // Make sure the dragged event is selected (no-op for already selected)\n        // Preserve other selected events if ctrl/meta is pressed\n        if (record.isAssignment) {\n            client.selectAssignment(record, startEvent.ctrlKey && multiSelect);\n        }\n        else {\n            client.selectEvent(record, startEvent.ctrlKey && multiSelect);\n        }\n\n        const dragData = {\n            context : info,\n            ...productDragData,\n\n            sourceDate       : startsOutsideView ? origStart : client.getDateFromCoordinate(coordinate),\n            screenSourceDate : client.getDateFromCoordinate(clientCoordinate, null, false),\n\n            startDate : origStart,\n            endDate   : origEnd,\n            timeDiff  : 0,\n\n            origStart,\n            origEnd,\n            startsOutsideView,\n            endsOutsideView,\n\n            duration     : origEnd - origStart,\n            browserEvent : startEvent // So we can know if SHIFT/CTRL was pressed\n        };\n\n        eventBarEls.forEach(el => el.classList.remove('b-sch-event-hover', 'b-active'));\n\n        if (eventBarEls.length > 1) {\n            // RelatedElements are secondary elements moved by the same delta as the grabbed element\n            info.relatedElements = eventBarEls.slice(1);\n        }\n\n        return dragData;\n    }\n\n    //endregion\n\n    //region Constraints\n\n    // private\n    setupConstraints(constrainRegion, elRegion, tickSize, constrained) {\n        const\n            me        = this,\n            xTickSize = !me.showExactDropPosition && tickSize > 1 ? tickSize : 0,\n            yTickSize = 0;\n\n        // If `constrained` is false then we have no date constraints and should constrain mouse position to scheduling area\n        // else we have specified date constraints and so we should limit mouse position to smaller region inside of constrained region using offsets and width.\n        if (constrained) {\n            me.setXConstraint(constrainRegion.left, constrainRegion.right - elRegion.width, xTickSize);\n        }\n        // And if not constrained, release any constraints from the previous drag.\n        else {\n            // minX being true means allow the start to be before the time axis.\n            // maxX being true means allow the end to be after the time axis.\n            me.setXConstraint(true, true, xTickSize);\n        }\n        me.setYConstraint(constrainRegion.top, constrainRegion.bottom - elRegion.height, yTickSize);\n    }\n\n    updateYConstraint(eventRecord, resourceRecord) {\n        const\n            me          = this,\n            { client }  = me,\n            { context } = me.drag,\n            tickSize    = client.timeAxisViewModel.snapPixelAmount;\n\n        // If we're dragging when the vertical size is recalculated by the host grid,\n        // we must update our Y constraint unless we are locked in the Y axis.\n        if (context && !me.drag.lockY) {\n            let constrainRegion;\n\n            // This calculates a relative region which the DragHelper uses within its outerElement\n            if (me.constrainDragToTimeline) {\n                constrainRegion = client.getScheduleRegion(resourceRecord, eventRecord);\n            }\n            // Not constraining to timeline.\n            // Unusual configuration, but this must mean no Y constraining.\n            else {\n                me.setYConstraint(null, null, tickSize);\n                return;\n            }\n\n            me.setYConstraint(\n                constrainRegion.top,\n                constrainRegion.bottom - context.element.offsetHeight,\n                tickSize\n            );\n        }\n        else {\n            me.setYConstraint(null, null, tickSize);\n        }\n    }\n\n    setXConstraint(iLeft, iRight, iTickSize) {\n        const { drag } = this;\n\n        drag.minX = iLeft;\n        drag.maxX = iRight;\n    }\n\n    setYConstraint(iUp, iDown, iTickSize) {\n        const { drag } = this;\n\n        drag.minY = iUp;\n        drag.maxY = iDown;\n    }\n\n    //endregion\n\n    //region Other stuff\n\n    adjustStartDate(startDate, timeDiff) {\n        const rounded = this.client.timeAxis.roundDate(\n            new Date(startDate - 0 + timeDiff),\n            this.client.snapRelativeToEventStartDate ? startDate : false\n        );\n\n        return this.constrainStartDate(rounded);\n    }\n\n    resolveStartEndDates(draggedElement) {\n        const\n            timeline         = this.currentOverClient,\n            { timeAxis }     = timeline,\n            proxyRect        = Rectangle.from(draggedElement.querySelector(timeline.eventInnerSelector), timeline.timeAxisSubGridElement),\n            dd               = this.dragData,\n            [record]         = dd.draggedEntities,\n            eventRecord      = record.isAssignment ? record.event : record,\n            { fullDuration } = eventRecord,\n            fillSnap         = timeline.fillTicks && timeline.snapRelativeToEventStartDate;\n\n        // Non-continuous time axis will return null instead of date for a rectangle outside of the view unless\n        // told to estimate date.\n        // When using fillTicks, we need exact dates for calculations below\n        let {\n            start : startDate, end : endDate\n        } = timeline.getStartEndDatesFromRectangle(proxyRect, fillSnap ? null : 'round', fullDuration, true);\n\n        // if dragging is out of timeAxis rect bounds, we will not be able to get dates\n        if (startDate && endDate) {\n            // When filling ticks, proxy start does not represent actual start date.\n            // Need to compensate to get expected result\n            if (fillSnap) {\n                const\n                    // Events offset into the tick, in MS\n                    offsetMS = eventRecord.startDate - DateHelper.startOf(eventRecord.startDate, timeAxis.unit),\n                    // Proxy length in MS\n                    proxyMS  = endDate - startDate,\n                    // Part of proxy that is \"filled\" and needs to be removed\n                    offsetPx = (offsetMS / proxyMS) * proxyRect.width;\n\n                // Deflate top for vertical mode, left for horizontal mode\n                proxyRect.deflate(offsetPx, 0, 0, offsetPx);\n\n                const proxyStart = proxyRect.getStart(timeline.rtl, !timeline.isVertical);\n\n                // Get date from offset proxy start\n                startDate = timeline.getDateFromCoordinate(proxyStart, null, true);\n                // Snap relative to event start date\n                startDate = timeAxis.roundDate(startDate, eventRecord.startDate);\n            }\n\n            startDate = this.adjustStartDate(startDate, 0);\n\n            if (!dd.startsOutsideView) {\n                // Make sure we didn't target a start date that is filtered out, if we target last hour cell (e.g. 21:00) of\n                // the time axis, and the next tick is 08:00 following day. Trying to drop at end of 21:00 cell should target start of next cell\n                if (!timeAxis.dateInAxis(startDate, false)) {\n                    const tick = timeAxis.getTickFromDate(startDate);\n\n                    if (tick >= 0) {\n                        startDate = timeAxis.getDateFromTick(tick);\n                    }\n                }\n\n                endDate = startDate && DateHelper.add(startDate, fullDuration);\n            }\n            else if (!dd.endsOutsideView) {\n                startDate = endDate && DateHelper.add(endDate, -fullDuration);\n            }\n        }\n\n        return {\n            startDate,\n            endDate\n        };\n    }\n\n    //endregion\n\n    //region Dragtip\n\n    /**\n     * Gets html to display in tooltip while dragging event. Uses clockTemplate to display start & end dates.\n     */\n    getTipHtml() {\n        const\n            me                                      = this,\n            { dragData, client, tooltipTemplate }   = me,\n            { startDate, endDate, draggedEntities } = dragData,\n            startText                               = client.getFormattedDate(startDate),\n            endText                                 = client.getFormattedEndDate(endDate, startDate),\n            { valid, message, element, dragProxy }  = dragData.context,\n            tipTarget                               = dragProxy ? dragProxy.firstChild : element,\n            dragged                                 = draggedEntities[0],\n            // Scheduler always drags assignments\n            timeSpanRecord                          = dragged.isTask ? dragged : dragged.event;\n\n        // Keep align target up to date in case of derendering the target when\n        // dragged outside render window, and re-entry into the render window.\n        me.tip.lastAlignSpec.target = tipTarget;\n\n        return tooltipTemplate({\n            valid,\n            startDate,\n            endDate,\n            startText,\n            endText,\n            dragData,\n            message                                : message || '',\n            [client.scheduledEventName + 'Record'] : timeSpanRecord,\n            startClockHtml                         : me.clockTemplate.template({\n                date : startDate,\n                text : startText,\n                cls  : 'b-sch-tooltip-startdate'\n            }),\n            endClockHtml : timeSpanRecord.isMilestone\n                ? ''\n                : me.clockTemplate.template({\n                    date : endDate,\n                    text : endText,\n                    cls  : 'b-sch-tooltip-enddate'\n                })\n        });\n    }\n\n    //endregion\n\n    //region Configurable\n\n    // Constrain to time slot means lockX if we're horizontal, otherwise lockY\n    updateConstrainDragToTimeSlot(value) {\n        const axis = this.client.isHorizontal ? 'lockX' : 'lockY';\n\n        if (this.drag) {\n            this.drag[axis] = value;\n        }\n    }\n\n    // Constrain to resource means lockY if we're horizontal, otherwise lockX\n    updateConstrainDragToResource(constrainDragToResource) {\n        const me = this;\n\n        if (me.drag) {\n            const\n                { constrainDragToTimeSlot } = me,\n                { isHorizontal }            = me.client;\n\n            if (constrainDragToResource) {\n                me.constrainDragToTimeline = true;\n            }\n            me.drag.lockY = isHorizontal ? constrainDragToResource : constrainDragToTimeSlot;\n            me.drag.lockX = isHorizontal ? constrainDragToTimeSlot : constrainDragToResource;\n        }\n    }\n\n    updateConstrainDragToTimeline(constrainDragToTimeline) {\n        if (!this.isConfiguring) {\n            Object.assign(this.drag, {\n                cloneTarget   : !constrainDragToTimeline,\n                dragWithin    : constrainDragToTimeline ? null : document.body,\n                scrollManager : constrainDragToTimeline ? this.client.scrollManager : null\n            });\n        }\n    }\n\n    constrainStartDate(startDate) {\n        const\n            { dragData }        = this,\n            { dateConstraints } = dragData,\n            scheduleableRecord  = dragData.eventRecord || dragData.taskRecord || dragData.draggedEntities[0];\n\n        if (dateConstraints?.start) {\n            startDate = DateHelper.max(dateConstraints.start, startDate);\n        }\n\n        if (dateConstraints?.end) {\n            startDate = DateHelper.min(new Date(dateConstraints.end - scheduleableRecord.durationMS), startDate);\n        }\n\n        return startDate;\n    }\n\n    //endregion\n\n    //region Product specific, implemented in subclasses\n    getElementFromContext(context) {\n        return context.grabbed || context.dragProxy || context.element;\n    }\n\n    // Provide your custom implementation of this to allow additional selected records to be dragged together with the original one.\n    getRelatedRecords(record) {\n        return [];\n    }\n\n    getMinimalDragData(info, event) {\n        // Can be overridden in subclass\n        return {};\n    }\n\n    // Check if element can be dropped at desired location\n    isValidDrop(dragData) {\n        throw new Error('Implement in subclass');\n    }\n\n    // Similar to the fn above but also calls validatorFn\n    checkDragValidity(dragData) {\n        throw new Error('Implement in subclass');\n    }\n\n    // Update records being dragged\n    updateRecords(context) {\n        throw new Error('Implement in subclass');\n    }\n\n    // Determine if an element can be dragged\n    isElementDraggable(el, event) {\n        throw new Error('Implement in subclass');\n    }\n\n    // Get coordinate for correct axis\n    getCoordinate(record, element, coord) {\n        throw new Error('Implement in subclass');\n    }\n\n    // Product specific drag data\n    setupProductDragData(info) {\n        throw new Error('Implement in subclass');\n    }\n\n    // Product specific data in drag context\n    getProductDragContext(dd) {\n        throw new Error('Implement in subclass');\n    }\n\n    getRecordElement(record) {\n        throw new Error('Implement in subclass');\n    }\n\n    //endregion\n}\n", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport Draggable from '../../Core/mixin/Draggable.js';\nimport Droppable from '../../Core/mixin/Droppable.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\nimport ClockTemplate from '../tooltip/ClockTemplate.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport BrowserHelper from '../../Core/helper/BrowserHelper.js';\nimport TimeSpan from '../../Scheduler/model/TimeSpan.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\n\n/**\n * @module Scheduler/feature/EventResize\n */\n\nconst tipAlign = {\n    top    : 'b-t',\n    right  : 'b100-t100',\n    bottom : 't-b',\n    left   : 'b0-t0'\n};\n\n/**\n * Feature that allows resizing an event by dragging its end.\n *\n * By default it displays a tooltip with the new start and end dates, formatted using\n * {@link Scheduler/view/mixin/TimelineViewPresets#config-displayDateFormat}.\n *\n * ## Customizing the resize tooltip\n *\n * To show custom HTML in the tooltip, please see the {@link #config-tooltipTemplate} config. Example:\n *\n * ```javascript\n * eventResize : {\n *     // A minimal end date tooltip\n *     tooltipTemplate : ({ record, endDate }) => {\n *         return DateHelper.format(endDate, 'MMM D');\n *     }\n * }\n * ```\n *\n * This feature is **enabled** by default\n *\n * This feature is extended with a few overrides by the Gantt's `TaskResize` feature.\n *\n * This feature updates the event's `startDate` or `endDate` live in order to leverage the\n * rendering pathway to always yield a correct appearance. The changes are done in\n * {@link Core.data.Model#function-beginBatch batched} mode so that changes do not become\n * eligible for data synchronization or propagation until the operation is completed.\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Scheduler/basic\n * @inlineexample Scheduler/feature/EventResize.js\n * @classtype eventResize\n * @feature\n */\nexport default class EventResize extends InstancePlugin.mixin(Draggable, Droppable) {\n    //region Events\n\n    /**\n     * Fired on the owning Scheduler before resizing starts. Return `false` to prevent the action.\n     * @event beforeEventResize\n     * @on-owner\n     * @preventable\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel} eventRecord Event record being resized\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record the resize starts within\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Fires on the owning Scheduler when event resizing starts\n     * @event eventResizeStart\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel} eventRecord Event record being resized\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record the resize starts within\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Fires on the owning Scheduler on each resize move event\n     * @event eventPartialResize\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel} eventRecord Event record being resized\n     * @param {Date} startDate\n     * @param {Date} endDate\n     * @param {HTMLElement} element\n     */\n\n    /**\n     * Fired on the owning Scheduler to allow implementer to prevent immediate finalization by setting\n     * `data.context.async = true` in the listener, to show a confirmation popup etc\n     *\n     * ```javascript\n     *  scheduler.on('beforeeventresizefinalize', ({context}) => {\n     *      context.async = true;\n     *      setTimeout(() => {\n     *          // async code don't forget to call finalize\n     *          context.finalize();\n     *      }, 1000);\n     *  })\n     * ```\n     *\n     * @event beforeEventResizeFinalize\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Object} context\n     * @param {Scheduler.model.EventModel} context.eventRecord Event record being resized\n     * @param {Date} context.startDate New startDate (changed if resizing start side)\n     * @param {Date} context.endDate New endDate (changed if resizing end side)\n     * @param {Date} context.originalStartDate Start date before resize\n     * @param {Date} context.originalEndDate End date before resize\n     * @param {Boolean} context.async Set true to handle resize asynchronously (e.g. to wait for user confirmation)\n     * @param {Function} context.finalize Call this method to finalize resize. This method accepts one argument:\n     *                   pass `true` to update records, or `false`, to ignore changes\n     * @param {Event} event Browser event\n     */\n\n    /**\n     * Fires on the owning Scheduler after the resizing gesture has finished.\n     * @event eventResizeEnd\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Boolean} changed Shows if the record has been changed by the resize action\n     * @param {Scheduler.model.EventModel} eventRecord Event record being resized\n     */\n\n    //endregion\n\n    //region Config\n\n    static get $name() {\n        return 'EventResize';\n    }\n\n    static get configurable() {\n        return {\n            draggingItemCls : 'b-sch-event-wrap-resizing',\n\n            resizingItemInnerCls : 'b-sch-event-resizing',\n\n            /**\n             * Use left handle when resizing. Only applies when owning client's `direction` is 'horizontal'\n             * @config {Boolean}\n             * @default\n             */\n            leftHandle : true,\n\n            /**\n             * Use right handle when resizing. Only applies when owning client's `direction` is 'horizontal'\n             * @config {Boolean}\n             * @default\n             */\n            rightHandle : true,\n\n            /**\n             * Use top handle when resizing. Only applies when owning client's direction` is 'vertical'\n             * @config {Boolean}\n             * @default\n             */\n            topHandle : true,\n\n            /**\n             * Use bottom handle when resizing. Only applies when owning client's `direction` is 'vertical'\n             * @config {Boolean}\n             * @default\n             */\n            bottomHandle : true,\n\n            /**\n             * Resizing handle size to use instead of that determined by CSS\n             * @config {Number}\n             * @deprecated Since 5.2.7. The handle size is determined from responsive CSS. Will be removed in 6.0\n             */\n            handleSize : null,\n\n            /**\n             * Automatically shrink virtual handles when available space < handleSize. The virtual handles will\n             * decrease towards width/height 1, reserving space between opposite handles to for example leave room for\n             * dragging. To configure reserved space, see {@link #config-reservedSpace}.\n             * @config {Boolean}\n             * @default false\n             */\n            dynamicHandleSize : true,\n\n            /**\n             * Set to true to allow resizing to a zero-duration span\n             * @config {Boolean}\n             * @default false\n             */\n            allowResizeToZero : null,\n\n            /**\n             * Room in px to leave unoccupied by handles when shrinking them dynamically (see\n             * {@link #config-dynamicHandleSize}).\n             * @config {Number}\n             * @default\n             */\n            reservedSpace : 5,\n\n            /**\n             * Resizing handle size to use instead of that determined by CSS on touch devices\n             * @config {Number}\n             * @deprecated Since 5.2.7. The handle size is determined from responsive CSS. Will be removed in 6.0\n             */\n            touchHandleSize : null,\n\n            /**\n             * The amount of pixels to move pointer/mouse before it counts as a drag operation.\n             * @config {Number}\n             * @default\n             */\n            dragThreshold : 0,\n\n            dragTouchStartDelay : 0,\n\n            draggingClsSelector : '.b-timeline-base',\n\n            /**\n             * `false` to not show a tooltip while resizing\n             * @config {Boolean}\n             * @default\n             */\n            showTooltip : true,\n\n            /**\n             * true to see exact event length during resizing\n             * @config {Boolean}\n             * @default\n             */\n            showExactResizePosition : false,\n\n            /**\n             * An empty function by default, but provided so that you can perform custom validation on\n             * the item being resized. Return true if the new duration is valid, false to signal that it is not.\n             * @param {Object} context The resize context, contains the record & dates.\n             * @param {Scheduler.model.TimeSpan} context.record The record being resized.\n             * @param {Date} context.startDate The new start date.\n             * @param {Date} context.endDate The new start date.\n             * @param {Date} context.originalStartDate Start date before resize\n             * @param {Date} context.originalEndDate End date before resize\n             * @param {Event} event The browser Event object\n             * @returns {Boolean}\n             * @config {Function}\n             */\n            validatorFn : () => true,\n\n            /**\n             * `this` reference for the validatorFn\n             * @config {Object}\n             */\n            validatorFnThisObj : null,\n\n            /**\n             * Setting this property may change the configuration of the {@link #config-tip}, or\n             * cause it to be destroyed if `null` is passed.\n             *\n             * Reading this property returns the Tooltip instance.\n             * @member {Core.widget.Tooltip|TooltipConfig} tip\n             */\n            /**\n             * If a tooltip is required to illustrate the resize, specify this as `true`, or a config\n             * object for the {@link Core.widget.Tooltip}.\n             * @config {Core.widget.Tooltip|TooltipConfig}\n             */\n            tip : {\n                $config : ['lazy', 'nullify'],\n                value   : {\n                    autoShow                 : false,\n                    axisLock                 : true,\n                    trackMouse               : false,\n                    updateContentOnMouseMove : true,\n                    hideDelay                : 0\n                }\n            },\n\n            /**\n             * A template function returning the content to show during a resize operation.\n             * @param {Object} context A context object\n             * @param {Date} context.startDate New start date\n             * @param {Date} context.endDate New end date\n             * @param {Scheduler.model.TimeSpan} context.record The record being resized\n             * @config {Function} tooltipTemplate\n             */\n            tooltipTemplate : context => `\n                <div class=\"b-sch-tip-${context.valid ? 'valid' : 'invalid'}\">\n                    ${context.startClockHtml}\n                    ${context.endClockHtml}\n                    <div class=\"b-sch-tip-message\">${context.message}</div>\n                </div>\n            `,\n\n            ignoreSelector : '.b-sch-terminal',\n            dragActiveCls  : 'b-resizing-event'\n        };\n    }\n\n    static get pluginConfig() {\n        return {\n            chain : ['render', 'onEventDataGenerated', 'isEventElementDraggable']\n        };\n    }\n\n    //endregion\n\n    //region Init & destroy\n\n    doDestroy() {\n        super.doDestroy();\n\n        this.dragging?.destroy();\n    }\n\n    render() {\n        const\n            me         = this,\n            { client } = me;\n\n        // Only active when in these items\n        me.dragSelector = me.dragItemSelector = client.eventSelector;\n\n        // Set up elements and listeners\n        me.dragRootElement = me.dropRootElement = client.timeAxisSubGridElement;\n\n        // Drag only in time dimension\n        me.dragLock = client.isVertical ? 'y' : 'x';\n    }\n\n    // Prevent event dragging when it happens over a resize handle\n    isEventElementDraggable(eventElement, eventRecord, el, event) {\n        const\n            me = this,\n            eventResizable = eventRecord?.resizable;\n\n        // ALLOW event drag:\n        // - if resizing is disabled or event is not resizable\n        // - if it's a milestone Milestones cannot be resized\n        if (me.disabled || !eventResizable || eventRecord.isMilestone) {\n            return true;\n        }\n\n        // not over the event handles\n        return ((eventResizable !== true && eventResizable !== 'start') || !me.isOverStartHandle(event, eventElement)) &&\n            ((eventResizable !== true && eventResizable !== 'end') || !me.isOverEndHandle(event, eventElement));\n    }\n\n    // Called for each event during render, allows manipulation of render data.\n    onEventDataGenerated({ eventRecord, wrapperCls, cls }) {\n        if (eventRecord === this.dragging?.context?.eventRecord) {\n            wrapperCls['b-active'] =\n                wrapperCls[this.draggingItemCls] =\n                wrapperCls['b-over-resize-handle'] =\n                cls['b-resize-handle'] =\n                cls[this.resizingItemInnerCls] = 1;\n        }\n    }\n\n    // Sneak a first peek at the drag event to put necessary date values into the context\n    onDragPointerMove(event) {\n        const\n            {\n                client,\n                dragging\n            }          = this,\n            {\n                visibleDateRange,\n                isHorizontal\n            }          = client,\n            rtl        = isHorizontal && client.rtl,\n            dimension  = isHorizontal ? 'X' : 'Y',\n            pageScroll = globalThis[`page${dimension}Offset`],\n            coord      = event[`page${dimension}`] + (dragging.context?.offset || 0),\n            clientRect = Rectangle.from(client.timeAxisSubGridElement, null, true),\n            startCoord = clientRect.getStart(rtl, isHorizontal),\n            endCoord   = clientRect.getEnd(rtl, isHorizontal);\n\n        let date = client.getDateFromCoord({ coord, local : false });\n\n        if (rtl) {\n            // If we're dragging off the start side, fix at the visible startDate\n            if (coord - pageScroll > startCoord) {\n                date = visibleDateRange.startDate;\n            }\n            // If we're dragging off the end side, fix at the visible endDate\n            else if (coord < endCoord) {\n                date = visibleDateRange.endDate;\n            }\n        }\n        // If we're dragging off the start side, fix at the visible startDate\n        else if (coord - pageScroll < startCoord) {\n            date = visibleDateRange.startDate;\n        }\n        // If we're dragging off the end side, fix at the visible endDate\n        else if (coord - pageScroll > endCoord) {\n            date = visibleDateRange.endDate;\n        }\n\n        dragging.clientStartCoord = startCoord;\n        dragging.clientEndCoord = endCoord;\n        dragging.date = date;\n\n        super.onDragPointerMove(event);\n    }\n\n    /**\n     * Returns true if a resize operation is active\n     * @property {Boolean}\n     * @readonly\n     */\n    get isResizing() {\n        return Boolean(this.dragging);\n    }\n\n    beforeDrag(drag) {\n        const\n            { client }     = this,\n            eventRecord    = client.resolveTimeSpanRecord(drag.itemElement),\n            resourceRecord = !client.isGanttBase && client.resolveResourceRecord(client.isVertical ? drag.startEvent : drag.itemElement);\n\n        // Events not part of project are transient records in a Gantt display store and not meant to be modified\n        if (this.disabled || client.readOnly || resourceRecord?.readOnly ||\n            (eventRecord && (eventRecord.readOnly || !(eventRecord.project || eventRecord.isOccurrence))) ||\n            super.beforeDrag(drag) === false) {\n            return false;\n        }\n\n        drag.mousedownDate = drag.date = client.getDateFromCoordinate(drag.event[`page${client.isHorizontal ? 'X' : 'Y'}`], null, false);\n\n        // trigger beforeEventResize or beforeTaskResize depending on product\n        return this.triggerBeforeResize(drag);\n    }\n\n    dragStart(drag) {\n        const\n            me             = this,\n            {\n                client,\n                tip\n            }              = me,\n            {\n                startEvent,\n                itemElement\n            }              = drag,\n            name           = client.scheduledEventName,\n            eventRecord    = client.resolveEventRecord(itemElement),\n            {\n                isBatchUpdating,\n                wrapStartDate,\n                wrapEndDate\n            } = eventRecord,\n            useEventBuffer = client.features.eventBuffer?.enabled,\n            eventStartDate = isBatchUpdating ? eventRecord.get('startDate') : eventRecord.startDate,\n            eventEndDate   = isBatchUpdating ? eventRecord.get('endDate') : eventRecord.endDate,\n            horizontal     = me.dragLock === 'x',\n            rtl            = horizontal && client.rtl,\n            draggingEnd    = me.isOverEndHandle(startEvent, itemElement),\n            toSet          = draggingEnd ? 'endDate' : 'startDate',\n            wrapToSet      = !useEventBuffer ? null : draggingEnd ? 'wrapEndDate' : 'wrapStartDate',\n            otherEnd       = draggingEnd ? 'startDate' : 'endDate',\n            setMethod      = draggingEnd ? 'setEndDate' : 'setStartDate',\n            setOtherMethod = draggingEnd ? 'setStartDate' : 'setEndDate',\n            elRect         = Rectangle.from(itemElement),\n            startCoord     = horizontal ? startEvent.clientX : startEvent.clientY,\n            endCoord       = draggingEnd ? elRect.getEnd(rtl, horizontal) : elRect.getStart(rtl, horizontal),\n            context        = drag.context = {\n                eventRecord,\n                element        : itemElement,\n                timespanRecord : eventRecord,\n                taskRecord     : eventRecord,\n                owner          : me,\n                valid          : true,\n                oldValue       : draggingEnd ? eventEndDate : eventStartDate,\n                startDate      : eventStartDate,\n                endDate        : eventEndDate,\n                offset         : useEventBuffer ? 0 : endCoord - startCoord,\n                edge           : horizontal ? (draggingEnd ? 'right' : 'left') : (draggingEnd ? 'bottom' : 'top'),\n                finalize       : me.finalize,\n                event          : drag.event,\n\n                // these two are public\n                originalStartDate : eventStartDate,\n                originalEndDate   : eventEndDate,\n                wrapStartDate,\n                wrapEndDate,\n                draggingEnd,\n                toSet,\n                wrapToSet,\n                otherEnd,\n                setMethod,\n                setOtherMethod\n            };\n\n        // The record must know that it is being resized.\n        eventRecord.meta.isResizing = true;\n\n        client.element.classList.add(...me.dragActiveCls.split(' '));\n\n        // During this batch we want the client's UI to update itself using the proposed changes\n        // Only if startDrag has not already done it\n        if (!client.listenToBatchedUpdates) {\n            client.beginListeningForBatchedUpdates();\n        }\n\n        // No changes must get through to data.\n        // Only if startDrag has not already started the batch\n        if (!isBatchUpdating) {\n            me.beginEventRecordBatch(eventRecord);\n        }\n\n        // Let products do their specific stuff\n        me.setupProductResizeContext(context, startEvent);\n\n        // Trigger eventResizeStart or taskResizeStart depending on product\n        // Subclasses (like EventDragCreate) won't actually fire this event.\n        me.triggerEventResizeStart(`${name}ResizeStart`, {\n            [`${name}Record`] : eventRecord,\n            event             : startEvent,\n            ...me.getResizeStartParams(context)\n        }, context);\n\n        // Scheduler renders assignments, Gantt renders Tasks\n        context.resizedRecord = client.resolveAssignmentRecord?.(context.element) || eventRecord;\n\n        if (tip) {\n            // Tip needs to be shown first for getTooltipTarget to be able to measure anchor size\n            tip.show();\n            tip.align = tipAlign[context.edge];\n            tip.showBy(me.getTooltipTarget(drag));\n        }\n    }\n\n    // Subclasses may override this\n    triggerBeforeResize(drag) {\n        const\n            { client }  = this,\n            eventRecord = client.resolveTimeSpanRecord(drag.itemElement);\n\n        return client.trigger(\n            `before${client.capitalizedEventName}Resize`,\n            {\n                [`${client.scheduledEventName}Record`] : eventRecord,\n                event                                  : drag.event,\n                ...this.getBeforeResizeParams({ event : drag.startEvent, element : drag.itemElement })\n            }\n        );\n    }\n\n    // Subclasses may override this\n    triggerEventResizeStart(eventType, event, context) {\n        this.client.trigger(eventType, event);\n\n        // Hook for features that needs to react on resize start\n        this.client[`after${StringHelper.capitalize(eventType)}`]?.(context, event);\n    }\n\n    triggerEventResizeEnd(eventType, event) {\n        this.client.trigger(eventType, event);\n    }\n\n    triggerEventPartialResize(eventType, event) {\n        // Trigger eventPartialResize or taskPartialResize depending on product\n        this.client.trigger(eventType, event);\n    }\n\n    triggerBeforeEventResizeFinalize(eventType, event) {\n        this.client.trigger(eventType, event);\n    }\n\n    dragEnter(drag) {\n        // We only respond to our own DragContexts\n        return drag.context?.owner === this;\n    }\n\n    resizeEventPartiallyInternal(eventRecord, context) {\n        const\n            { client } = this,\n            // <debug>\n            { detectExcessiveRendering } = client,\n            // </debug>\n            { toSet } = context;\n\n        // <debug>\n        client.detectExcessiveRendering = false;\n        // </debug>\n\n        if (client.features.eventBuffer?.enabled) {\n            if (toSet === 'startDate') {\n                const diff = context.startDate.getTime() - context.originalStartDate.getTime();\n                eventRecord.wrapStartDate = new Date(context.wrapStartDate.getTime() + diff);\n            }\n\n            else if (toSet === 'endDate') {\n                const diff = context.endDate.getTime() - context.originalEndDate.getTime();\n                eventRecord.wrapEndDate = new Date(context.wrapEndDate.getTime() + diff);\n            }\n        }\n\n        eventRecord.set(toSet, context[toSet]);\n\n        // <debug>\n        client.detectExcessiveRendering = detectExcessiveRendering;\n        // </debug>\n    }\n\n    applyDateConstraints(date, eventRecord, context) {\n        const\n            minDate = context.dateConstraints?.start,\n            maxDate = context.dateConstraints?.end;\n\n        // Keep desired date within constraints\n        if (minDate || maxDate) {\n            date = DateHelper.constrain(date, minDate, maxDate);\n            context.snappedDate = DateHelper.constrain(context.snappedDate, minDate, maxDate);\n        }\n\n        return date;\n    }\n\n    // Override the draggable interface so that we can update the bar while dragging outside\n    // the Draggable's rootElement (by default it stops notifications when outside rootElement)\n    moveDrag(drag) {\n        const\n            me          = this,\n            {\n                client,\n                tip\n            }           = me,\n            horizontal  = me.dragLock === 'x',\n            dimension   = horizontal ? 'X' : 'Y',\n            name        = client.scheduledEventName,\n            {\n                visibleDateRange,\n                enableEventAnimations,\n                timeAxis,\n                weekStartDay\n            }           = client,\n            rtl         = horizontal && client.rtl,\n            {\n                resolutionUnit,\n                resolutionIncrement\n            }           = timeAxis,\n            {\n                event,\n                context\n            }           = drag,\n            {\n                eventRecord\n            }           = context,\n            offset      = context.offset * (rtl ? -1 : 1),\n            {\n                isOccurrence\n            }           = eventRecord,\n            eventStart  = eventRecord.get('startDate'),\n            eventEnd    = eventRecord.get('endDate'),\n            coord       = event[`client${dimension}`] + offset,\n            clientRect  = Rectangle.from(client.timeAxisSubGridElement, null, true),\n            startCoord  = clientRect.getStart(rtl, horizontal),\n            endCoord    = clientRect.getEnd(rtl, horizontal);\n\n        context.event = event;\n\n        // If this is the last move event recycled because of a scroll, refresh the date\n        if (event.isScroll) {\n            drag.date = client.getDateFromCoordinate(event[`page${dimension}`] + offset, null, false);\n        }\n\n        let crossedOver, avoidedZeroSize,\n            // Use the value set up in onDragPointerMove by default\n            { date } = drag,\n            {\n                toSet,\n                otherEnd,\n                draggingEnd\n            } = context;\n\n        if (rtl) {\n            // If we're dragging off the start side, fix at the visible startDate\n            if (coord > startCoord) {\n                date = drag.date = visibleDateRange.startDate;\n            }\n            // If we're dragging off the end side, fix at the visible endDate\n            else if (coord < endCoord) {\n                date = drag.date = visibleDateRange.endDate;\n            }\n\n        }\n        // If we're dragging off the start side, fix at the visible startDate\n        else if (coord < startCoord) {\n            date = drag.date = visibleDateRange.startDate;\n        }\n        // If we're dragging off the end side, fix at the visible endDate\n        else if (coord > endCoord) {\n            date = drag.date = visibleDateRange.endDate;\n        }\n\n        // Detect crossover which some subclasses might need to process\n        if (toSet === 'endDate') {\n            if (date < eventStart) {\n                crossedOver = -1;\n            }\n        }\n        else {\n            if (date > eventEnd) {\n                crossedOver = 1;\n            }\n        }\n\n        // If we dragged the dragged end over to the opposite side of the start end.\n        // Some subclasses allow this and need to respond. EventDragCreate does this.\n        if (crossedOver && me.onDragEndSwitch) {\n            me.onDragEndSwitch(context, date, crossedOver);\n            otherEnd = context.otherEnd;\n            toSet = context.toSet;\n        }\n\n        if (client.snapRelativeToEventStartDate) {\n            date = timeAxis.roundDate(date, context.oldValue);\n        }\n\n        // The displayed and eventual data value\n        context.snappedDate = DateHelper.round(date, timeAxis.resolution, null, weekStartDay);\n\n        const duration = DateHelper.diff(date, context[otherEnd], resolutionUnit) * (draggingEnd ? -1 : 1);\n\n        // Narrower than half resolutionIncrement will abort drag creation, set flag to have UI reflect this\n        if (me.isEventDragCreate) {\n            context.tooNarrow = duration < resolutionIncrement / 2;\n        }\n        // The mousepoint date means that the duration is less than resolutionIncrement resolutionUnits.\n        // Ensure that the dragged end is at least resolutionIncrement resolutionUnits from the other end.\n        else if (duration < resolutionIncrement) {\n            // Snap to zero if allowed\n            if (me.allowResizeToZero) {\n                context.snappedDate = date = context[otherEnd];\n            }\n            else {\n                const sign = otherEnd === 'startDate' ? 1 : -1;\n                context.snappedDate = date = timeAxis.roundDate(DateHelper.add(eventRecord.get(otherEnd), resolutionIncrement * sign, resolutionUnit));\n                avoidedZeroSize = true;\n            }\n        }\n\n        // take dateConstraints into account\n        date = me.applyDateConstraints(date, eventRecord, context);\n\n        // If the mouse move has changed the detected date\n        if (!context.date || date - context.date || avoidedZeroSize) {\n            context.date = date;\n\n            // The validityFn needs to see the proposed value.\n            // Consult our snap config to see if we should be dragging in snapped mode\n            context[toSet] = me.showExactResizePosition || client.timeAxisViewModel.snap ? context.snappedDate : date;\n\n            // Snapping would take it to zero size - this is not allowed in drag resizing.\n            context.valid = me.allowResizeToZero || context[toSet] - context[toSet === 'startDate' ? 'endDate' : 'startDate'] !== 0;\n\n            // If the date to push into the record is new...\n            if (eventRecord.get(toSet) - context[toSet]) {\n                context.valid = me.checkValidity(context, event);\n                context.message = '';\n\n                if (context.valid && typeof context.valid !== 'boolean') {\n                    context.message = context.valid.message;\n                    context.valid = context.valid.valid;\n                }\n\n                // If users returns nothing, that's interpreted as valid\n                context.valid = (context.valid !== false);\n\n                if (context.valid) {\n                    const partialResizeEvent = {\n                        [`${name}Record`] : eventRecord,\n                        startDate         : eventStart,\n                        endDate           : eventEnd,\n                        element           : drag.itemElement,\n                        context\n                    };\n\n                    // Update the event we are about to fire and the context *before* we update the record\n                    partialResizeEvent[toSet] = context[toSet];\n\n                    // Trigger eventPartialResize or taskPartialResize depending on product\n                    me.triggerEventPartialResize(`${name}PartialResize`, partialResizeEvent);\n\n                    // An occurrence must have a store to announce its batched changes through.\n                    // They must usually never have a store - they are transient, but we\n                    // need to update the UI.\n                    if (isOccurrence) {\n                        eventRecord.stores.push(client.eventStore);\n                    }\n\n                    // Update the eventRecord.\n                    // Use setter rather than accessor so that in a Project, the entity's\n                    // accessor doesn't propagate the change to the whole project.\n                    // Scheduler must not animate this.\n                    client.enableEventAnimations = false;\n\n                    this.resizeEventPartiallyInternal(eventRecord, context);\n\n                    client.enableEventAnimations = enableEventAnimations;\n\n                    if (isOccurrence) {\n                        eventRecord.stores.length = 0;\n                    }\n                }\n\n                // Flag drag created too narrow events as invalid late, want all code above to execute for them\n                // to get the proper size rendered\n                if (context.tooNarrow) {\n                    context.valid = false;\n                }\n            }\n        }\n\n        if (tip) {\n            // In case of edge flip (EventDragCreate), the align point may change\n            tip.align = tipAlign[context.edge];\n            tip.alignTo(me.getTooltipTarget(drag));\n        }\n\n        super.moveDrag(drag);\n    }\n\n    dragEnd(drag) {\n        const { context } = drag;\n\n        if (context) {\n            context.event = drag.event;\n        }\n\n        if (drag.aborted) {\n            context?.finalize(false);\n        }\n        // 062_resize.t.js specifies that if drag was not started but the mouse has moved,\n        // the eventresizestart and eventresizeend must fire\n        else if (!this.isEventDragCreate && !drag.started && !EventHelper.getPagePoint(drag.event).equals(EventHelper.getPagePoint(drag.startEvent))) {\n            this.dragStart(drag);\n            this.cleanup(drag.context, false);\n        }\n    }\n\n    async dragDrop({ context, event }) {\n        // Set the start/end date, whichever we were dragging\n        // to the correctly rounded value before updating.\n        context[context.toSet] = context.snappedDate;\n\n        const\n            {\n                client\n            } = this,\n            {\n                startDate,\n                endDate\n            } = context;\n\n        let modified;\n\n        this.tip?.hide();\n\n        context.valid = startDate && endDate && (this.allowResizeToZero || (endDate - startDate > 0)) && // Input sanity check\n            (context[context.toSet] - context.oldValue) && // Make sure dragged end changed\n            context.valid !== false;\n\n        if (context.valid) {\n            // Seems to be a valid resize operation, ask outside world if anyone wants to take control over the finalizing,\n            // to show a confirm dialog prior to applying the new values. Triggers beforeEventResizeFinalize or\n            // beforeTaskResizeFinalize depending on product\n            this.triggerBeforeEventResizeFinalize(`before${client.capitalizedEventName}ResizeFinalize`, { context, event, [`${client.scheduledEventName}Record`] : context.eventRecord });\n            modified = true;\n        }\n\n        // If a handler has set the async flag, it means that they are going to finalize\n        // the operation at some time in the future, so we should not call it.\n        if (!context.async) {\n            await context.finalize(modified);\n        }\n    }\n\n    // This is called with a thisObj of the context object\n    // We set \"me\" to the owner, and \"context\" to the thisObj so that it\n    // reads as if it were a method of this class.\n    async finalize(updateRecord) {\n        const\n            me      = this.owner,\n            context = this,\n            {\n                eventRecord,\n                oldValue,\n                toSet\n            }       = context,\n            {\n                snapRelativeToEventStartDate,\n                timeAxis\n            }       = me.client;\n\n        let wasChanged = false;\n\n        if (updateRecord) {\n            if (snapRelativeToEventStartDate) {\n                context[toSet] = context.snappedDate = timeAxis.roundDate(context.date, oldValue);\n            }\n\n            // Each product updates the record differently\n            wasChanged = await me.internalUpdateRecord(context, eventRecord);\n        }\n        else {\n            // Reverts the changes, a batchedUpdate event will fire which will reset the UI\n            me.cancelEventRecordBatch(eventRecord);\n\n            // Manually trigger redraw of occurrences since they are not part of any stores\n            if (eventRecord.isOccurrence) {\n                eventRecord.resources.forEach(resource => me.client.repaintEventsForResource(resource));\n            }\n        }\n\n        if (!me.isDestroyed) {\n            me.cleanup(context, wasChanged);\n        }\n    }\n\n    // This is always called on drop or abort.\n    cleanup(context, changed) {\n        const\n            me               = this,\n            { client }       = me,\n            {\n                element,\n                eventRecord\n            }                = context,\n            name             = client.scheduledEventName;\n\n        // The record must know that it is being resized.\n        eventRecord.meta.isResizing = false;\n\n        client.endListeningForBatchedUpdates();\n        me.tip?.hide();\n        me.unHighlightHandle(element);\n        client.element.classList.remove(...me.dragActiveCls.split(' '));\n        // if (dependencies) {\n        //     // When resizing is done and mouse is over element, we show terminals\n        //     if (element.matches(':hover')) {\n        //         dependencies.showTerminals(eventRecord, element);\n        //     }\n        // }\n\n        // Triggers eventResizeEnd or taskResizeEnd depending on product\n        me.triggerEventResizeEnd(`${name}ResizeEnd`, {\n            changed,\n            [`${name}Record`] : eventRecord,\n            ...me.getResizeEndParams(context)\n        });\n    }\n\n    async internalUpdateRecord(context, timespanRecord) {\n        const\n            { client }     = this,\n            { generation } = timespanRecord;\n\n        // Special handling of occurrences, they need normalization since that is not handled by engine at the moment\n        if (timespanRecord.isOccurrence) {\n            client.endListeningForBatchedUpdates();\n\n            // If >1 level deep, just unwind one level.\n            timespanRecord[timespanRecord.batching > 1 ? 'endBatch' : 'cancelBatch']();\n            timespanRecord.set(TimeSpan.prototype.inSetNormalize.call(timespanRecord, {\n                startDate : context.startDate,\n                endDate   : context.endDate\n            }));\n        }\n        else {\n            const toSet = {\n                [context.toSet] : context[context.toSet]\n            };\n\n            // If we have the Engine available, consult it to calculate a corrected duration.\n            // Adjust the dragged date point to conform with the calculated duration.\n            if (timespanRecord.isEntity) {\n                const\n                    {\n                        startDate,\n                        endDate,\n                        draggingEnd\n                    } = context;\n\n                // Fix the duration according to the Entity's rules.\n                context.duration = toSet.duration = timespanRecord.run('calculateProjectedDuration', startDate, endDate);\n\n                // Fix the dragged date point according to the Entity's rules.\n                toSet[context.toSet] = timespanRecord.run('calculateProjectedXDateWithDuration', draggingEnd ? startDate : endDate, draggingEnd, context.duration);\n\n                const setOtherEnd = !timespanRecord[context.otherEnd];\n\n                // Set all values, start and end in case they had never been set\n                // ie, we're now scheduling a previously unscheduled event.\n                if (setOtherEnd) {\n                    toSet[context.otherEnd] = context[context.otherEnd];\n                }\n\n                // Update the record to its final correct state using *batched changes*\n                // These will *not* be propagated, it's just to force the dragged event bar\n                // into its corrected shape before the real changes which will propagate are applied below.\n                // We MUST do it like this because the final state may not be a net change if the changes\n                // got rejected, and in that case, the engine will not end up firing any change events.\n                timespanRecord.set(toSet);\n\n                // Quit listening for batchedUpdate *before* we cancel the batch so that the\n                // change events from the revert do not update the UI.\n                client.endListeningForBatchedUpdates();\n\n                this.cancelEventRecordBatch(timespanRecord);\n\n                // Clear estimated wrap date, exact wrap date will be calculated when referred to from renderer\n                if (client.features.eventBuffer?.enabled) {\n                    timespanRecord[context.wrapToSet] = null;\n                }\n\n                const promisesToWait = [];\n\n                // Really update the data after cancelling the batch\n                if (setOtherEnd) {\n                    promisesToWait.push(timespanRecord[context.setOtherMethod](toSet[context.otherEnd], false));\n                }\n\n                promisesToWait.push(timespanRecord[context.setMethod](toSet[context.toSet], false));\n\n                await Promise.all(promisesToWait);\n\n                timespanRecord.endBatch();\n            }\n            else {\n                // Collect any changes (except the start/end date) that happened during the resize operation\n                const batchChanges = Object.assign({}, timespanRecord.meta.batchChanges);\n                delete batchChanges[context.toSet];\n                client.endListeningForBatchedUpdates();\n\n                this.cancelEventRecordBatch(timespanRecord);\n\n                timespanRecord.set(batchChanges);\n                timespanRecord[context.setMethod](toSet[context.toSet], false);\n            }\n        }\n\n        // wait for project data update\n        await client.project.commitAsync();\n\n        // If the record has been changed\n        return timespanRecord.generation !== generation;\n    }\n\n    onDragItemMouseMove(event) {\n        if (event.pointerType !== 'touch' && !this.handleSelector) {\n            this.checkResizeHandles(event);\n        }\n    }\n\n    /**\n     * Check if mouse is over a resize handle (virtual). If so, highlight.\n     * @private\n     * @param {MouseEvent} event\n     */\n    checkResizeHandles(event) {\n        const\n            me           = this,\n            { overItem } = me;\n\n        // mouse over a target element and allowed to resize?\n        if (overItem && !me.client.readOnly && (!me.allowResize || me.allowResize(overItem, event))) {\n            const eventRecord = me.client.resolveTimeSpanRecord(overItem);\n\n            if (eventRecord?.readOnly) {\n                return;\n            }\n\n            if (me.isOverAnyHandle(event, overItem)) {\n                me.highlightHandle(); // over handle\n            }\n            else {\n                me.unHighlightHandle(); // not over handle\n            }\n        }\n    }\n\n    onDragItemMouseLeave(event, oldOverItem) {\n        this.unHighlightHandle(oldOverItem);\n    }\n\n    /**\n     * Highlights handles (applies css that changes cursor).\n     * @private\n     */\n    highlightHandle() {\n        const\n            {\n                overItem : item,\n                client\n            }      = this,\n            handleTargetElement = item.syncIdMap?.[client.scheduledEventName] ?? item.querySelector(client.eventInnerSelector);\n\n        // over a handle, add cls to change cursor\n        handleTargetElement.classList.add('b-resize-handle');\n        item.classList.add('b-over-resize-handle');\n    }\n\n    /**\n     * Unhighlight handles (removes css).\n     * @private\n     */\n    unHighlightHandle(item = this.overItem) {\n        if (item) {\n            const\n                me    = this,\n                inner = item.syncIdMap?.[me.client.scheduledEventName] ?? item.querySelector(me.client.eventInnerSelector);\n\n            if (inner) {\n                inner.classList.remove('b-resize-handle', me.resizingItemInnerCls);\n            }\n\n            item.classList.remove('b-over-resize-handle', me.draggingItemCls);\n        }\n    }\n\n    isOverAnyHandle(event, target) {\n        return this.isOverStartHandle(event, target) || this.isOverEndHandle(event, target);\n    }\n\n    isOverStartHandle(event, target) {\n        return this.getHandleRect('start', event, target)?.contains(EventHelper.getPagePoint(event));\n    }\n\n    isOverEndHandle(event, target) {\n        return this.getHandleRect('end', event, target)?.contains(EventHelper.getPagePoint(event));\n    }\n\n    getHandleRect(side, event, eventEl) {\n        if (this.overItem) {\n            eventEl = event.target.closest(`.${this.client.eventCls}`) || eventEl.querySelector(`.${this.client.eventCls}`);\n            if (!eventEl) {\n                return;\n            }\n\n            const\n                me              = this,\n                start           = side === 'start',\n                { client }      = me,\n                rtl             = Boolean(client.rtl),\n                axis            = me.dragLock,\n                horizontal      = axis === 'x',\n                dim             = horizontal ? 'width' : 'height',\n                handleSpec      = `${horizontal ? (start && !rtl) ? 'left' : 'right' : start ? 'top' : 'bottom'}Handle`,\n                { offsetWidth } = eventEl,\n                timespanRecord  = client.resolveTimeSpanRecord(eventEl),\n                resizable       = timespanRecord?.isResizable,\n                eventRect       = Rectangle.from(eventEl),\n                result          = eventRect.clone(),\n                handleStyle     = globalThis.getComputedStyle(eventEl, ':before'),\n                // Larger draggable zones on pure touch devices with no mouse\n                touchHandleSize = (!me.handleSelector && !BrowserHelper.isHoverableDevice) ? me.touchHandleSize : undefined,\n                handleSize      = touchHandleSize || me.handleSize || parseFloat(handleStyle[dim]),\n                handleVisThresh = me.handleVisibilityThreshold || 2 * me.handleSize,\n                centerGap       = me.dynamicHandleSize ? me.reservedSpace / 2 : 0,\n                deflateArgs     = [0, 0, 0, 0];\n\n            // To decide if we are over a valid handle, we first check disabled state\n            // Then this.leftHandle/this.rightHandle/this.topHandle/this.bottomHandle\n            // Then whether there's enough event bar width to accommodate separate handles\n            // Then whether the event itself allows resizing at the specified side.\n            if (!me.disabled && me[handleSpec] && (offsetWidth >= handleVisThresh || me.dynamicHandleSize) && (resizable === true || resizable === side)) {\n                const oppositeEnd = (!horizontal && !start) || (horizontal && (rtl  === start));\n\n                if (oppositeEnd) {\n                    // Push handle start point to other end and clip result to other end\n                    result[axis] += (eventRect[dim] - handleSize);\n                    deflateArgs[horizontal ? 3 : 0] = eventRect[dim] / 2 + centerGap;\n                }\n                else {\n                    deflateArgs[horizontal ? 1 : 2] = eventRect[dim] / 2 + centerGap;\n                }\n\n                // Deflate the event bar rectangle to encapsulate 2px less than the side's own half\n                // so that we can constrain the handle zone to be inside its own half when bar is small.\n                eventRect.deflate(...deflateArgs);\n                result[dim] = handleSize;\n\n                // Constrain handle rectangles to each side so that they can never collide.\n                // Each handle is constrained into its own half.\n                result.constrainTo(eventRect);\n\n                // Zero sized handles cannot be hovered\n                if (result[dim]) {\n                    return result;\n                }\n            }\n        }\n    }\n\n    setupDragContext(event) {\n        const me = this;\n\n        // Only start a drag if we are over a handle zone.\n        if (me.overItem && me.isOverAnyHandle(event, me.overItem) && me.isElementResizable(me.overItem, event)) {\n            const result = super.setupDragContext(event);\n\n            result.scrollManager = me.client.scrollManager;\n\n            return result;\n        }\n    }\n\n    changeHandleSize() {\n        VersionHelper.deprecate('Scheduler', '6.0.0', 'Handle size is from CSS');\n    }\n\n    changeTouchHandleSize() {\n        VersionHelper.deprecate('Scheduler', '6.0.0', 'Handle size is from CSS');\n    }\n\n    changeTip(tip, oldTip) {\n        const me = this;\n\n        if (!me.showTooltip) {\n            return null;\n        }\n\n        if (tip) {\n            if (tip.isTooltip) {\n                tip.owner = me;\n            }\n            else {\n                tip = Tooltip.reconfigure(oldTip, Tooltip.mergeConfigs({\n                    id : me.tipId\n                }, tip, {\n                    getHtml : me.getTipHtml.bind(me),\n                    owner   : me.client\n                }, me.tip), {\n                    owner    : me,\n                    defaults : {\n                        type : 'tooltip'\n                    }\n                });\n            }\n\n            tip.ion({\n                innerhtmlupdate : 'updateDateIndicator',\n                thisObj         : me\n            });\n\n            me.clockTemplate = new ClockTemplate({\n                scheduler : me.client\n            });\n        }\n        else if (oldTip) {\n            oldTip.destroy();\n            me.clockTemplate?.destroy();\n        }\n\n        return tip;\n    }\n\n    //endregion\n\n    //region Events\n\n    isElementResizable(element, event) {\n        const\n            me             = this,\n            { client }     = me,\n            timespanRecord = client.resolveTimeSpanRecord(element);\n\n        if (client.readOnly) {\n            return false;\n        }\n\n        let resizable = timespanRecord?.isResizable;\n\n        // Not resizable if the mousedown is on a resizing handle of\n        // a percent bar.\n        const\n            handleHoldingElement = element?.syncIdMap[client.scheduledEventName] ?? element,\n            handleEl             = event.target.closest('[class$=\"-handle\"]');\n\n        if (!resizable || (handleEl && handleEl !== handleHoldingElement)) {\n            return false;\n        }\n\n        element = event.target.closest(me.dragSelector);\n\n        if (!element) {\n            return false;\n        }\n\n        const\n            startsOutside = element.classList.contains('b-sch-event-startsoutside'),\n            endsOutside   = element.classList.contains('b-sch-event-endsoutside');\n\n        if (resizable === true) {\n            if (startsOutside && endsOutside) {\n                return false;\n            }\n            else if (startsOutside) {\n                resizable = 'end';\n            }\n            else if (endsOutside) {\n                resizable = 'start';\n            }\n            else {\n                return me.isOverStartHandle(event, element) || me.isOverEndHandle(event, element);\n            }\n        }\n\n        if (\n            (startsOutside && resizable === 'start') ||\n            (endsOutside && resizable === 'end')\n        ) {\n            return false;\n        }\n\n        if (\n            (me.isOverStartHandle(event, element) && resizable === 'start') ||\n            (me.isOverEndHandle(event, element) && resizable === 'end')\n        ) {\n            return true;\n        }\n\n        return false;\n    }\n\n    updateDateIndicator() {\n        const\n            { clockTemplate } = this,\n            {\n                eventRecord,\n                draggingEnd,\n                snappedDate\n            }                 = this.dragging.context,\n            startDate         = draggingEnd ? eventRecord.get('startDate') : snappedDate,\n            endDate           = draggingEnd ? snappedDate : eventRecord.get('endDate'),\n            { element }       = this.tip;\n\n        clockTemplate.updateDateIndicator(element.querySelector('.b-sch-tooltip-startdate'), startDate);\n        clockTemplate.updateDateIndicator(element.querySelector('.b-sch-tooltip-enddate'), endDate);\n    }\n\n    getTooltipTarget({ itemElement, context }) {\n        const\n            me      = this,\n            { rtl } = me.client,\n            target  = Rectangle.from(itemElement, null, true);\n\n        if (me.dragLock === 'x') {\n            // Align to the dragged edge of the proxy, and then bump right so that the anchor aligns perfectly.\n            if ((!rtl && context.edge === 'right') || (rtl && context.edge === 'left')) {\n                target.x = target.right - 1;\n            }\n            else {\n                target.x -= me.tip.anchorSize[0] / 2;\n            }\n            target.width = me.tip.anchorSize[0] / 2;\n        }\n        else {\n            // Align to the dragged edge of the proxy, and then bump bottom so that the anchor aligns perfectly.\n            if (context.edge === 'bottom') {\n                target.y = target.bottom - 1;\n            }\n            target.height = me.tip.anchorSize[1] / 2;\n        }\n\n        return { target };\n    }\n\n    basicValidityCheck(context, event) {\n        return context.startDate &&\n            (context.endDate > context.startDate || this.allowResizeToZero) &&\n            this.validatorFn.call(this.validatorFnThisObj || this, context, event);\n    }\n\n    //endregion\n\n    //region Tooltip\n\n    getTipHtml({ tip }) {\n        const\n            me = this,\n            {\n                startDate,\n                endDate,\n                toSet,\n                snappedDate,\n                valid,\n                message = '',\n                timespanRecord\n            }  = me.dragging.context;\n\n        // Empty string hides the tip - we get called before the Resizer, so first call will be empty\n        if (!startDate || !endDate) {\n            return tip.html;\n        }\n\n        // Set whichever one we are moving\n        const tipData = {\n            record  : timespanRecord,\n            valid,\n            message,\n            startDate,\n            endDate,\n            [toSet] : snappedDate\n        };\n\n        // Format the two ends. This has to be done outside of the object initializer\n        // because they use properties that are only in the tipData object.\n        tipData.startText = me.client.getFormattedDate(tipData.startDate);\n        tipData.endText = me.client.getFormattedDate(tipData.endDate);\n        tipData.startClockHtml = me.clockTemplate.template({\n            date : tipData.startDate,\n            text : tipData.startText,\n            cls  : 'b-sch-tooltip-startdate'\n        });\n        tipData.endClockHtml = me.clockTemplate.template({\n            date : tipData.endDate,\n            text : tipData.endText,\n            cls  : 'b-sch-tooltip-enddate'\n        });\n\n        return me.tooltipTemplate(tipData);\n    }\n\n    //endregion\n\n    //region Product specific, may be overridden in subclasses\n\n    beginEventRecordBatch(eventRecord) {\n        eventRecord.beginBatch();\n    }\n\n    cancelEventRecordBatch(eventRecord) {\n        // Reverts the changes, a batchedUpdate event will fire which will reset the UI\n        eventRecord.cancelBatch();\n    }\n\n    getBeforeResizeParams(context) {\n        const { client } = this;\n\n        return {\n            resourceRecord : client.resolveResourceRecord(client.isVertical ? context.event : context.element)\n        };\n    }\n\n    getResizeStartParams(context) {\n        return {\n            resourceRecord : context.resourceRecord\n        };\n    }\n\n    getResizeEndParams(context) {\n        return {\n            resourceRecord : context.resourceRecord,\n            event          : context.event\n        };\n    }\n\n    setupProductResizeContext(context, event) {\n        const\n            { client }       = this,\n            { element }      = context,\n            eventRecord      = client.resolveEventRecord(element),\n            resourceRecord   = client.resolveResourceRecord?.(element),\n            assignmentRecord = client.resolveAssignmentRecord?.(element);\n\n        Object.assign(context, {\n            eventRecord,\n            taskRecord      : eventRecord,\n            resourceRecord,\n            assignmentRecord,\n            dateConstraints : client.getDateConstraints?.(resourceRecord, eventRecord)\n        });\n    }\n\n    checkValidity({ startDate, endDate, eventRecord, resourceRecord }) {\n        const { client } = this;\n\n        if (!client.allowOverlap) {\n            if (eventRecord.resources.some(resource => !client.isDateRangeAvailable(startDate, endDate, eventRecord, resource))) {\n                return {\n                    valid   : false,\n                    message : this.L('L{EventDrag.eventOverlapsExisting}')\n                };\n            }\n        }\n        return this.basicValidityCheck(...arguments);\n    }\n\n    get tipId() {\n        return `${this.client.id}-event-resize-tip`;\n    }\n\n    //endregion\n}\n\nGridFeatureManager.registerFeature(EventResize, true, 'Scheduler');\nGridFeatureManager.registerFeature(EventResize, false, 'ResourceHistogram');\n", "import Base from '../../../Core/Base.js';\n\n/**\n * @module Scheduler/feature/mixin/TaskEditTransactional\n */\n\n/**\n * Mixin adding live updates support\n *\n * @mixin\n */\nexport default Target => class TaskEditTransactional extends (Target || Base) {\n    static get $name() {\n        return 'TaskEditTransactional';\n    }\n\n    captureStm(force) {\n        if (this.client.transactionalFeaturesEnabled) {\n            super.captureStm();\n\n            return this.startStmTransaction(force);\n        }\n        else {\n            super.captureStm(force);\n        }\n    }\n\n    freeStm(commitOrReject) {\n        if (this.hasStmCapture || !this.client.transactionalFeaturesEnabled) {\n            return super.freeStm(commitOrReject);\n        }\n    }\n\n    async startStmTransaction(startRecordingEarly) {\n        if (this.client.transactionalFeaturesEnabled) {\n            await this.startFeatureTransaction(startRecordingEarly);\n        }\n        else {\n            super.startStmTransaction();\n        }\n    }\n\n    commitStmTransaction() {\n        if (this.client.transactionalFeaturesEnabled) {\n            return this.finishFeatureTransaction();\n        }\n        else {\n            super.commitStmTransaction();\n        }\n    }\n\n    async rejectStmTransaction() {\n        if (this.client.transactionalFeaturesEnabled) {\n            this.rejectFeatureTransaction();\n        }\n        else {\n            await super.rejectStmTransaction();\n        }\n    }\n};\n", "import Base from '../../../Core/Base.js';\nimport AttachToProjectMixin from '../../data/mixin/AttachToProjectMixin.js';\nimport IdHelper from '../../../Core/helper/IdHelper.js';\n\n/**\n * @module Scheduler/feature/mixin/TransactionalFeature\n */\n\n/**\n * Feature defining methods to lock the view for a time of a user action\n * @internal\n * @mixin\n */\nexport default Target => class TransactionalFeature extends AttachToProjectMixin(Target || Base) {\n    static $name = 'TransactionalFeature';\n\n    //#region AttachToProjectMixin implementation\n\n    detachFromProject(project) {\n        this.rejectFeatureTransaction();\n        super.detachFromProject(project);\n    }\n\n    //#endregion\n\n    getStmCapture() {\n        const result = super.getStmCapture();\n        result._editorPromiseResolve = this._editorPromiseResolve;\n        return result;\n    }\n\n    applyStmCapture(stmCapture) {\n        super.applyStmCapture(stmCapture);\n\n        this._editorPromiseResolve = stmCapture._editorPromiseResolve;\n    }\n\n    async startFeatureTransaction() {\n        if (!this.client.transactionalFeaturesEnabled) {\n            return;\n        }\n\n        const\n            me          = this,\n            { project } = me.client,\n            { stm }     = project;\n\n        // Await previous promise chain to resolve\n        let chainResolved;\n\n        if (me.hasStmCapture) {\n            stm.startTransaction();\n        }\n        else {\n            chainResolved = project.queue(() => project.commitAsync());\n        }\n\n        project.queue(() => {\n            if (!me.hasStmCapture) {\n                me._stmInitiallyDisabled = stm.disabled;\n                me._stmInitiallyAutoRecord = stm.autoRecord;\n\n                if (stm.isRecording) {\n                    stm.stopTransaction();\n                }\n                else if (me._stmInitiallyDisabled) {\n                    stm.enable();\n                }\n\n                // Disable autoRecord to avoid finishing transaction after a timeout\n                stm.autoRecord = false;\n            }\n\n            if (!stm.isRecording) {\n                // We need to wrap cell editing into own transaction to be able to apply user changes last\n                stm.startTransaction();\n            }\n\n            me.trigger?.('featureTransactionStart');\n\n            // Put an empty promise to the queue to pause it\n            return new Promise(resolve => me._editorPromiseResolve = resolve);\n        });\n\n        await chainResolved;\n    }\n\n    rejectFeatureTransaction() {\n        if (!this.client.transactionalFeaturesEnabled) {\n            return;\n        }\n\n        const\n            me = this,\n            { stm } = me.client.project;\n\n        me._editorPromiseResolve?.();\n        me._editorPromiseResolve = null;\n\n        stm.isRecording && stm.rejectTransaction();\n\n        if (!me.hasStmCapture && me._stmInitiallyDisabled != null) {\n            stm.disabled = me._stmInitiallyDisabled;\n            stm.autoRecord = me._stmInitiallyAutoRecord;\n        }\n\n        me.trigger('featureTransactionReject');\n    }\n\n    async finishFeatureTransaction(afterApplyStashCallback) {\n        if (!this.client.transactionalFeaturesEnabled) {\n            return;\n        }\n\n        const\n            me            = this,\n            { project }   = me.client,\n            { stm }       = project;\n\n        // In case there is a commit pending, we need to wait to not suspend more events than we should\n        if (!project.isEngineReady()) {\n            await project.commitAsync();\n        }\n\n        const\n            transactionId = stm.stash(),\n            {\n                _stmInitiallyDisabled,\n                _stmInitiallyAutoRecord\n            }             = me,\n            // This id is used to help debugging concurrent promises\n            id            = IdHelper.generateId('featureTransaction');\n\n        me._editorPromiseResolve?.();\n        me._editorPromiseResolve = null;\n\n        if (!me.isDestroying) {\n            me.trigger('featureTransactionFinalizeStart', { id });\n        }\n\n        return project.queue(async() => {\n            stm?.applyStash(transactionId);\n\n            await afterApplyStashCallback?.();\n\n            await project.commitAsync?.();\n\n            if (stm.isRecording) {\n                stm.stopTransaction();\n            }\n\n            if (!me.hasStmCapture && stm && !stm.isDestroying && _stmInitiallyDisabled != null) {\n                stm.disabled = _stmInitiallyDisabled;\n                stm.autoRecord = _stmInitiallyAutoRecord;\n            }\n\n            me.trigger?.('featureTransactionFinalized', { id });\n        });\n    }\n};\n", "import EventResize from '../EventResize.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\nimport Draggable from '../../../Core/mixin/Draggable.js';\nimport TaskEditStm from '../mixin/TaskEditStm.js';\nimport TaskEditTransactional from '../mixin/TaskEditTransactional.js';\nimport TransactionalFeature from '../mixin/TransactionalFeature.js';\n\n/**\n * @module Scheduler/feature/base/DragCreateBase\n */\nconst getDragCreateDragDistance = function(event) {\n    // Do not allow the drag to begin if the taskEdit feature (if present) is in the process\n    // of canceling. We must wait for it to have cleaned up its data manipulations before\n    // we can add the new, drag-created record\n    if (this.source?.client.features.taskEdit?._canceling) {\n        return false;\n    }\n    return EventHelper.getDistanceBetween(this.startEvent, event);\n};\n\n/**\n * Base class for EventDragCreate (Scheduler) and TaskDragCreate (Gantt) features. Contains shared code. Not to be used directly.\n *\n * @extends Scheduler/feature/EventResize\n */\nexport default class DragCreateBase extends EventResize.mixin(\n    TaskEditStm,\n    TransactionalFeature,\n    TaskEditTransactional\n) {\n    //region Config\n\n    static configurable = {\n        /**\n         * true to show a time tooltip when dragging to create a new event\n         * @config {Boolean}\n         * @default\n         */\n        showTooltip : true,\n\n        /**\n         * Number of pixels the drag target must be moved before dragging is considered to have started. Defaults to 2.\n         * @config {Number}\n         * @default\n         */\n        dragTolerance : 2,\n\n        // used by gantt to only allow one task per row\n        preventMultiple : false,\n\n        dragTouchStartDelay : 300,\n\n        /**\n         * `this` reference for the validatorFn\n         * @config {Object}\n         */\n        validatorFnThisObj : null,\n\n        tipTemplate : data => `\n            <div class=\"b-sch-tip-${data.valid ? 'valid' : 'invalid'}\">\n                ${data.startClockHtml}\n                ${data.endClockHtml}\n                <div class=\"b-sch-tip-message\">${data.message}</div>\n            </div>\n        `,\n\n        dragActiveCls : 'b-dragcreating'\n    };\n\n    static pluginConfig = {\n        chain  : ['render', 'onEventDataGenerated'],\n        before : ['onElementContextMenu']\n    };\n\n    construct(scheduler, config) {\n        if (config?.showTooltip === false) {\n            config.tip = null;\n        }\n        super.construct(...arguments);\n    }\n\n    //endregion\n\n    changeValidatorFn(validatorFn) {\n        // validatorFn property is used by the EventResize base to validate each mousemove\n        // We change the property name to createValidatorFn\n        this.createValidatorFn = validatorFn;\n    }\n\n    render() {\n        const\n            me         = this,\n            { client } = me;\n\n        // Set up elements and listeners\n        me.dragRootElement = me.dropRootElement = client.timeAxisSubGridElement;\n\n        // Drag only in time dimension\n        me.dragLock = client.isVertical ? 'y' : 'x';\n    }\n\n    onDragEndSwitch(context) {\n        const\n            { client }                = this,\n            { enableEventAnimations } = client,\n            {\n                eventRecord,\n                draggingEnd\n            }                         = context,\n            horizontal                = this.dragLock === 'x',\n            { initialDate }           = this.dragging;\n\n        // Setting the new opposite end should not animate\n        client.enableEventAnimations = false;\n\n        // Zero duration at the moment of the flip\n        eventRecord.set({\n            startDate : initialDate,\n            endDate   : initialDate\n        });\n\n        // We're switching to dragging the start\n        if (draggingEnd) {\n            Object.assign(context, {\n                endDate        : initialDate,\n                toSet          : 'startDate',\n                otherEnd       : 'endDate',\n                setMethod      : 'setStartDate',\n                setOtherMethod : 'setEndDate',\n                edge           : horizontal ? 'left' : 'top'\n            });\n        }\n        else {\n            Object.assign(context, {\n                startDate      : initialDate,\n                toSet          : 'endDate',\n                otherEnd       : 'startDate',\n                setMethod      : 'setEndDate',\n                setOtherMethod : 'setStartDate',\n                edge           : horizontal ? 'right' : 'bottom'\n            });\n        }\n\n        context.draggingEnd = this.draggingEnd = !draggingEnd;\n        client.enableEventAnimations = enableEventAnimations;\n    }\n\n    beforeDrag(drag) {\n        const\n            me                       = this,\n            result                   = super.beforeDrag(drag),\n            { pan, eventDragSelect } = me.client.features;\n\n        // Superclass's handler may also veto\n        if (result !== false && (\n            // used by gantt to only allow one task per row\n            (me.preventMultiple && !me.isRowEmpty(drag.rowRecord)) ||\n            me.disabled ||\n            // If Pan is enabled, it has right of way\n            (pan && !pan.disabled) ||\n            // If EventDragSelect is enabled, it has right of way\n            (eventDragSelect && !eventDragSelect.disabled)\n        )) {\n            return false;\n        }\n\n        // Prevent drag select if drag-creating, could collide otherwise\n        // (reset by GridSelection)\n        me.client.preventDragSelect = true;\n\n        return result;\n    }\n\n    startDrag(drag) {\n        const result = super.startDrag(drag);\n\n        // Returning false means operation is aborted.\n        if (result !== false) {\n            const { context } = drag;\n\n            // Date to flip around when changing direction\n            drag.initialDate = context.eventRecord.get(this.draggingEnd ? 'startDate' : 'endDate');\n\n            this.client.trigger('dragCreateStart', {\n                proxyElement   : drag.element,\n                eventElement   : drag.element,\n                eventRecord    : context.eventRecord,\n                resourceRecord : context.resourceRecord\n            });\n\n            // We are always dragging the exact edge of the event element.\n            drag.context.offset   = 0;\n            drag.context.oldValue = drag.mousedownDate;\n        }\n        return result;\n    }\n\n    // Used by our EventResize superclass to know whether the drag point is the end or the beginning.\n    isOverEndHandle() {\n        return this.draggingEnd;\n    }\n\n    setupDragContext(event) {\n        const { client } = this;\n\n        // Only mousedown on an empty cell can initiate drag-create\n        if (client.matchScheduleCell(event.target)) {\n            const resourceRecord = client.resolveResourceRecord(event)?.$original;\n\n            // And there must be a resource backing the cell.\n            if (resourceRecord && !resourceRecord.isSpecialRow) {\n                // Skip the EventResize's setupDragContext. We want the base one.\n                const\n                    result      = Draggable().prototype.setupDragContext.call(this, event),\n                    scrollables = [];\n\n                if (client.isVertical) {\n                    scrollables.push({\n                        element   : client.scrollable.element,\n                        direction : 'vertical'\n                    });\n                }\n                else {\n                    scrollables.push({\n                        element   : client.timeAxisSubGrid.scrollable.element,\n                        direction : 'horizontal'\n                    });\n                }\n\n                result.scrollManager = client.scrollManager;\n                result.monitoringConfig = { scrollables };\n                result.resourceRecord = result.rowRecord = resourceRecord;\n\n                // We use a special method to get the distance moved.\n                // If the TaskEdit feature is still in its canceling phase, then\n                // it returns false which inhibits the start of the drag-create\n                // until the cancelation is complete.\n                result.getDistance = getDragCreateDragDistance;\n                return result;\n            }\n        }\n    }\n\n    async dragDrop({ context, event }) {\n        // Set the start/end date, whichever we were dragging\n        // to the correctly rounded value before updating.\n        context[context.toSet] = context.snappedDate;\n\n        const\n            {\n                client\n            } = this,\n            {\n                startDate,\n                endDate,\n                eventRecord\n            } = context,\n            { generation } = eventRecord;\n\n        let modified;\n\n        this.tip?.hide();\n\n        // Handle https://github.com/bryntum/support/issues/3210.\n        // The issue arises when the mouseup arrives very quickly and the commit kicked off\n        // at event add has not yet completed. If it now completes *after* we finalize\n        // the drag, it will reset the event to its initial state.\n        // If that commit has in fact finished, this will be a no-op\n        await client.project.commitAsync();\n\n        // If the above commit in fact reset the event back to the initial state, we have to\n        // force the event rendering to bring it back to the currently known context state.\n        if (eventRecord.generation !== generation) {\n            context.eventRecord[context.toSet] = context.oldValue;\n            context.eventRecord[context.toSet] = context[context.toSet];\n        }\n\n        context.valid = startDate && endDate && (endDate - startDate > 0) && // Input sanity check\n            (context[context.toSet] - context.oldValue) && // Make sure dragged end changed\n            context.valid !== false;\n\n        if (context.valid) {\n            // Seems to be a valid drag-create operation, ask outside world if anyone wants to take control over the finalizing,\n            // to show a confirm dialog prior to finalizing the create.\n            client.trigger('beforeDragCreateFinalize', {\n                context,\n                event,\n                proxyElement   : context.element,\n                eventElement   : context.element,\n                eventRecord    : context.eventRecord,\n                resourceRecord : context.resourceRecord\n            });\n            modified = true;\n        }\n\n        // If a handler has set the async flag, it means that they are going to finalize\n        // the operation at some time in the future, so we should not call it.\n        if (!context.async) {\n            await context.finalize(modified);\n        }\n    }\n\n    updateDragTolerance(dragTolerance) {\n        this.dragThreshold = dragTolerance;\n    }\n\n    //region Tooltip\n\n    changeTip(tip, oldTip) {\n        return super.changeTip(!tip || tip.isTooltip ? tip : ObjectHelper.assign({\n            id : `${this.client.id}-drag-create-tip`\n        }, tip), oldTip);\n    }\n\n    //endregion\n\n    //region Finalize (create EventModel)\n\n    // this method is actually called on the `context` object,\n    // so `this` object inside might not be what you think (see `me = this.owner` below)\n    // not clear what was the motivation for such design\n    async finalize(doCreate) {\n        // only call this method once, do not re-enter\n        if (this.finalized) {\n            return;\n        }\n\n        this.finalized = true;\n\n        const\n            me                = this.owner,\n            context           = this,\n            completeFinalization = () => {\n                if (!me.isDestroyed) {\n                    me.client.trigger('afterDragCreate', {\n                        proxyElement   : context.element,\n                        eventElement   : context.element,\n                        eventRecord    : context.eventRecord,\n                        resourceRecord : context.resourceRecord\n                    });\n                    me.cleanup(context);\n                }\n            };\n\n        if (doCreate) {\n            // Call product specific implementation\n            await me.finalizeDragCreate(context);\n\n            completeFinalization();\n        }\n        // Aborting without going ahead with create - we must deassign and remove the event\n        else {\n            await me.cancelDragCreate(context);\n\n            me.onAborted?.(context);\n            completeFinalization();\n        }\n    }\n\n    async cancelDragCreate(context) {\n    }\n\n    async finalizeDragCreate(context) {\n        // EventResize base class applies final changes to the event record\n        await this.internalUpdateRecord(context, context.eventRecord);\n\n        const stmCapture = this.getStmCapture();\n\n        this.client?.trigger('dragCreateEnd', {\n            eventRecord    : context.eventRecord,\n            resourceRecord : context.resourceRecord,\n            event          : context.event,\n            eventElement   : context.element,\n            stmCapture\n        });\n\n        // Part of the Scheduler API. Triggered by its createEvent method.\n        // Auto-editing features can use this to edit new events.\n        // Note that this may be destroyed by a listener of the previous event.\n        this.client?.trigger('eventAutoCreated', {\n            eventRecord    : context.eventRecord,\n            resourceRecord : context.resourceRecord\n        });\n\n        return stmCapture.transferred;\n    }\n\n    cleanup(context) {\n        const\n            { client }      = this,\n            { eventRecord } = context;\n\n        // Base class's cleanup is not called, we have to clear this flag.\n        // The isCreating flag is only set if the event is to be handed off to the\n        // eventEdit feature and that feature then has responsibility for clearing it.\n        eventRecord.meta.isResizing = false;\n\n        client.endListeningForBatchedUpdates();\n        this.tip?.hide();\n        client.element.classList.remove(...this.dragActiveCls.split(' '));\n\n        context.element.parentElement.classList.remove('b-sch-dragcreating');\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * Prevent right click when drag creating\n     * @returns {Boolean}\n     * @private\n     */\n    onElementContextMenu() {\n        if (this.proxy) {\n            return false;\n        }\n    }\n\n    prepareCreateContextForFinalization(createContext, event, finalize, async = false) {\n        return {\n            ...createContext,\n            async,\n            event,\n            finalize\n        };\n    }\n\n    // Apply drag create \"proxy\" styling\n    onEventDataGenerated(renderData) {\n        if (this.dragging?.context?.eventRecord === renderData.eventRecord) {\n            // Allow custom styling for drag creation element\n            renderData.wrapperCls['b-sch-dragcreating'] = true;\n            // Styling when drag create will be aborted on drop (because it would yield zero duration)\n            renderData.wrapperCls['b-too-narrow'] = this.dragging.context.tooNarrow;\n        }\n    }\n\n    //endregion\n\n    //region Product specific, implemented in subclasses\n\n    // Empty implementation here. Only base EventResize class triggers this\n    triggerBeforeResize() {}\n\n    // Empty implementation here. Only base EventResize class triggers this\n    triggerEventResizeStart() {}\n\n    checkValidity(context, event) {\n        throw new Error('Implement in subclass');\n    }\n\n    handleBeforeDragCreate(dateTime, event) {\n        throw new Error('Implement in subclass');\n    }\n\n    isRowEmpty(rowRecord) {\n        throw new Error('Implement in subclass');\n    }\n\n    //endregion\n}\n", "import InstancePlugin from '../../../Core/mixin/InstancePlugin.js';\nimport Tooltip from '../../../Core/widget/Tooltip.js';\nimport ClockTemplate from '../../tooltip/ClockTemplate.js';\n\n/**\n * @module Scheduler/feature/base/TooltipBase\n */\n\n/**\n * Base class for `EventTooltip` (Scheduler) and `TaskTooltip` (Gantt) features. Contains shared code. Not to be used directly.\n *\n * @extends Core/mixin/InstancePlugin\n * @extendsconfigs Core/widget/Tooltip\n */\nexport default class TooltipBase extends InstancePlugin {\n    //region Config\n\n    static get defaultConfig() {\n        return {\n\n            /**\n             * Specify true to have tooltip updated when mouse moves, if you for example want to display date at mouse\n             * position.\n             * @config {Boolean}\n             * @default\n             * @category Misc\n             */\n            autoUpdate : false,\n\n            /**\n             * The amount of time to hover before showing\n             * @config {Number}\n             * @default\n             */\n            hoverDelay : 250,\n\n            /**\n             * The time (in milliseconds) for which the Tooltip remains visible when the mouse leaves the target.\n             *\n             * May be configured as `false` to persist visible after the mouse exits the target element. Configure it\n             * as 0 to always retrigger `hoverDelay` even when moving mouse inside `fromElement`\n             * @config {Number}\n             * @default\n             */\n            hideDelay : 100,\n\n            // <remove-on-release>\n            // TODO: Rename to tooltipTemplate, deprecate template\n            // </remove-on-release>\n            template : null,\n\n            cls : null,\n\n            align : {\n                align : 'b-t'\n            },\n\n            clockTemplate : null,\n\n            // Set to true to update tooltip contents if record changes while tip is open\n            monitorRecordUpdate : null,\n\n            testConfig : {\n                hoverDelay : 0\n            }\n        };\n    }\n\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['onPaint']\n        };\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * Triggered before a tooltip is shown. Return `false` to prevent the action.\n     * @preventable\n     * @event beforeShow\n     * @param {Core.widget.Tooltip} source The tooltip being shown.\n     * @param {Scheduler.model.EventModel} source.eventRecord The event record.\n     */\n\n    /**\n     * Triggered after a tooltip is shown.\n     * @event show\n     * @param {Core.widget.Tooltip} source The tooltip.\n     * @param {Scheduler.model.EventModel} source.eventRecord The event record.\n     */\n\n    //endregion\n\n    //region Init\n\n    construct(client, config) {\n        const me = this;\n\n        // process initial config into an actual config object\n        config = me.processConfig(config);\n\n        super.construct(client, config);\n\n        // Default triggering selector is the client's inner element selector\n        if (!me.forSelector) {\n            me.forSelector = `${client.eventInnerSelector}:not(.b-dragproxy,.b-iscreating)`;\n        }\n\n        me.clockTemplate = new ClockTemplate({\n            scheduler : client\n        });\n\n        client.ion({\n            [`before${client.scheduledEventName}drag`] : () => {\n                // Using {} on purpose to not return the promise\n                me.tooltip?.hide();\n            }\n        });\n    }\n\n    // TooltipBase feature handles special config cases, where user can supply a function to use as template\n    // instead of a normal config object\n    processConfig(config) {\n        if (typeof config === 'function') {\n            return {\n                template : config\n            };\n        }\n\n        return config;\n    }\n\n    // override setConfig to process config before applying it (used mainly from ReactScheduler)\n    setConfig(config) {\n        super.setConfig(this.processConfig(config));\n    }\n\n    doDestroy() {\n        this.destroyProperties('clockTemplate', 'tooltip');\n\n        super.doDestroy();\n    }\n\n    doDisable(disable) {\n        if (this.tooltip) {\n            this.tooltip.disabled = disable;\n        }\n\n        super.doDisable(disable);\n    }\n\n    //endregion\n\n    onPaint({ firstPaint }) {\n        if (firstPaint) {\n            const\n                me             = this,\n                { client }     = me,\n                ignoreSelector = `:not(${[\n                    '.b-dragselecting',\n                    '.b-eventeditor-editing',\n                    '.b-taskeditor-editing',\n                    '.b-resizing-event',\n                    '.b-task-percent-bar-resizing-task',\n                    '.b-dragcreating',\n                    `.b-dragging-${client.scheduledEventName}`,\n                    '.b-creating-dependency',\n                    '.b-dragproxy'\n                ].join()})`;\n\n            me.tooltip?.destroy();\n\n            /**\n             * A reference to the tooltip instance, which will have a special `eventRecord` property that\n             * you can use to get data from the contextual event record to which this tooltip is related.\n             * @member {Core.widget.Tooltip} tooltip\n             * @readonly\n             * @category Misc\n             */\n            const tip = me.tooltip = new Tooltip({\n                axisLock          : 'flexible',\n                id                : me.tipId || `${me.client.id}-event-tip`,\n                cls               : me.tipCls,\n                forSelector       : `.b-timelinebase${ignoreSelector} .b-grid-body-container:not(.b-scrolling) ${me.forSelector}`,\n                scrollAction      : 'realign',\n                forElement        : client.timeAxisSubGridElement,\n                showOnHover       : true,\n                anchorToTarget    : true,\n                getHtml           : me.getTipHtml.bind(me),\n                disabled          : me.disabled,\n                // on Core/mixin/Events constructor, me.config.listeners is deleted and attributed its value to me.configuredListeners\n                // to then on processConfiguredListeners it set me.listeners to our TooltipBase\n                // but since we need our initial config.listeners to set to our internal tooltip, we leave processConfiguredListeners empty\n                // to avoid lost our listeners to apply for our internal tooltip here and force our feature has all Tooltip events firing\n                ...me.config,\n                internalListeners : me.configuredListeners\n            });\n\n            tip.ion({\n                innerhtmlupdate : 'updateDateIndicator',\n                overtarget      : 'onOverNewTarget',\n                show            : 'onTipShow',\n                hide            : 'onTipHide',\n                thisObj         : me\n            });\n\n            // Once instantiated, any Tooltip configs are relayed through the feature directly to the tip\n            Object.keys(tip.$meta.configs).forEach(name => {\n                Object.defineProperty(this, name, {\n                    set : v => tip[name] = v,\n                    get : () => tip[name]\n                });\n            });\n        }\n    }\n\n    //region Listeners\n\n    // leave configuredListeners alone until render time at which they are used on the tooltip\n    processConfiguredListeners() {}\n\n    addListener(...args) {\n        const\n            // Call super method to handle enable/disable feature events\n            defaultDetacher = super.addListener(...args),\n            // Add listener to the `tooltip` instance\n            tooltipDetacher = this.tooltip?.addListener(...args);\n\n        if (defaultDetacher || tooltipDetacher) {\n            return () => {\n                defaultDetacher?.();\n                tooltipDetacher?.();\n            };\n        }\n    }\n\n    removeListener(...args) {\n        super.removeListener(...args);\n\n        // Remove listener from the `tooltip` instance\n        this.tooltip?.removeListener(...args);\n    }\n\n    //endregion\n\n    updateDateIndicator() {\n        const\n            me             = this,\n            tip            = me.tooltip,\n            endDateElement = tip.element.querySelector('.b-sch-tooltip-enddate');\n\n        if (!me.record) {\n            return;\n        }\n\n        me.clockTemplate.updateDateIndicator(tip.element, me.record.startDate);\n\n        endDateElement && me.clockTemplate.updateDateIndicator(endDateElement, me.record.endDate);\n    }\n\n    resolveTimeSpanRecord(forElement) {\n        return this.client.resolveTimeSpanRecord(forElement);\n    }\n\n    getTipHtml({ tip, activeTarget }) {\n        const\n            me             = this,\n            { client }     = me,\n            recordProp     = me.recordType || `${client.scheduledEventName}Record`,\n            timeSpanRecord = me.resolveTimeSpanRecord(activeTarget);\n\n        // If user has mouseovered a fading away element of a deleted event,\n        // an event record will not be found. In this case the tip must hide.\n        // Instance of check is to not display while propagating\n        if (timeSpanRecord?.startDate instanceof Date) {\n            const\n                { startDate, endDate } = timeSpanRecord,\n                startText              = client.getFormattedDate(startDate),\n                endDateValue           = client.getDisplayEndDate(endDate, startDate),\n                endText                = client.getFormattedDate(endDateValue);\n\n            tip.eventRecord = timeSpanRecord;\n\n            return me.template({\n                tip,\n                // eventRecord for Scheduler, taskRecord for Gantt\n                [`${recordProp}`] : timeSpanRecord,\n                startDate,\n                endDate,\n                startText,\n                endText,\n                startClockHtml    : me.clockTemplate.template({\n                    date : startDate,\n                    text : startText,\n                    cls  : 'b-sch-tooltip-startdate'\n                }),\n                endClockHtml : timeSpanRecord.isMilestone ? '' : me.clockTemplate.template({\n                    date : endDateValue,\n                    text : endText,\n                    cls  : 'b-sch-tooltip-enddate'\n                })\n            });\n        }\n        else {\n            tip.hide();\n            return '';\n        }\n    }\n\n    get record() {\n        return this.tooltip.eventRecord;\n    }\n\n    onTipShow() {\n        const me = this;\n\n        if (me.monitorRecordUpdate && !me.updateListener) {\n            me.updateListener = me.client.eventStore.ion({\n                change  : me.onRecordUpdate,\n                buffer  : 300,\n                thisObj : me\n            });\n        }\n    }\n\n    onTipHide() {\n        // To not retain full project when changing project\n        this.tooltip.eventRecord = null;\n\n        this.updateListener?.();\n        this.updateListener = null;\n    }\n\n    onOverNewTarget({ newTarget }) {\n        const { tooltip } = this;\n\n        if (tooltip.isVisible) {\n            if (this.client.timeAxisSubGrid.scrolling || this.client.scrolling) {\n                tooltip.hide(false);\n            }\n            else {\n                tooltip.eventRecord = this.resolveTimeSpanRecord(newTarget);\n            }\n        }\n    }\n\n    onRecordUpdate({ record }) {\n        const { tooltip } = this;\n\n        // Make sure the record we are showing the tip for is still relevant\n        // If the change moved the element out from under the mouse, we will be hidden.\n        if (tooltip?.isVisible && record === this.record) {\n            tooltip.updateContent();\n\n            // If we were aligning to the event bar, realign to it.\n            if (tooltip.lastAlignSpec.aligningToElement) {\n                tooltip.realign();\n            }\n            // The pointer is still over the target (otherwise tooltip would be hidden)\n            // So invoke the tooltip's positioning\n            else {\n                tooltip.internalOnPointerOver(this.client.lastPointerEvent);\n            }\n        }\n    }\n}\n", "import DragHelper from '../../Core/helper/DragHelper.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport ResizeHelper from '../../Core/helper/ResizeHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\nimport ClockTemplate from '../tooltip/ClockTemplate.js';\n\n/**\n * @module Scheduler/feature/AbstractTimeRanges\n */\n\n/**\n * Abstract base class, you should not use this class directly.\n * @abstract\n * @mixes Core/mixin/Delayable\n * @extends Core/mixin/InstancePlugin\n */\nexport default class AbstractTimeRanges extends InstancePlugin.mixin(Delayable) {\n    //region Config\n\n    /**\n     * Fired on the owning Scheduler when a click happens on a time range header element\n     * @event timeRangeHeaderClick\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.TimeSpan} timeRangeRecord The record\n     * @param {MouseEvent} event DEPRECATED 5.3.0 Use `domEvent` instead\n     * @param {MouseEvent} domEvent Browser event\n     */\n\n    /**\n     * Fired on the owning Scheduler when a double click happens on a time range header element\n     * @event timeRangeHeaderDblClick\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.TimeSpan} timeRangeRecord The record\n     * @param {MouseEvent} event DEPRECATED 5.3.0 Use `domEvent` instead\n     * @param {MouseEvent} domEvent Browser event\n     */\n\n    /**\n     * Fired on the owning Scheduler when a right click happens on a time range header element\n     * @event timeRangeHeaderContextMenu\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.TimeSpan} timeRangeRecord The record\n     * @param {MouseEvent} event DEPRECATED 5.3.0 Use `domEvent` instead\n     * @param {MouseEvent} domEvent Browser event\n     */\n\n    static get defaultConfig() {\n        return {\n            // CSS class to apply to range elements\n            rangeCls : 'b-sch-range',\n\n            // CSS class to apply to line elements (0-duration time range)\n            lineCls : 'b-sch-line',\n\n            /**\n             * Set to `true` to enable dragging and resizing of range elements in the header. Only relevant when\n             * {@link #config-showHeaderElements} is `true`.\n             * @config {Boolean}\n             * @default\n             * @category Common\n             */\n            enableResizing : false,\n\n            /**\n             * A Boolean specifying whether to show tooltip while resizing range elements, or a\n             * {@link Core.widget.Tooltip} config object which is applied to the tooltip\n             * @config {Boolean|TooltipConfig}\n             * @default\n             * @category Common\n             */\n            showTooltip : true,\n\n            /**\n             * Template used to generate the tooltip contents when hovering a time range header element.\n             * ```\n             * const scheduler = new Scheduler({\n             *   features : {\n             *     timeRanges : {\n             *       tooltipTemplate({ timeRange }) {\n             *         return `${timeRange.name}`\n             *       }\n             *     }\n             *   }\n             * });\n             * ```\n             * @config {Function} tooltipTemplate\n             * @param {Object} data Tooltip data\n             * @param {Scheduler.model.TimeSpan} data.timeRange\n             * @category Common\n             */\n            tooltipTemplate : null,\n\n            dragTipTemplate : data => `\n                <div class=\"b-sch-tip-${data.valid ? 'valid' : 'invalid'}\">\n                    <div class=\"b-sch-tip-name\">${StringHelper.encodeHtml(data.name) || ''}</div>\n                    ${data.startClockHtml}\n                    ${data.endClockHtml || ''}\n                </div>\n            `,\n\n            baseCls : 'b-sch-timerange',\n\n            /**\n             * Function used to generate the HTML content for a time range header element.\n             * ```\n             * const scheduler = new Scheduler({\n             *   features : {\n             *     timeRanges : {\n             *       headerRenderer({ timeRange }) {\n             *         return `${timeRange.name}`\n             *       }\n             *     }\n             *   }\n             * });\n             * ```\n             * @config {Function} headerRenderer\n             * @param {Object} data Render data\n             * @param {Scheduler.model.TimeSpan} data.timeRange\n             * @category Common\n             */\n            headerRenderer : null,\n\n            /**\n             * Function used to generate the HTML content for a time range body element.\n             * ```\n             * const scheduler = new Scheduler({\n             *   features : {\n             *     timeRanges : {\n             *       bodyRenderer({ timeRange }) {\n             *         return `${timeRange.name}`\n             *       }\n             *     }\n             *   }\n             * });\n             * ```\n             * @config {Function} bodyRenderer\n             * @param {Object} data Render data\n             * @param {Scheduler.model.TimeSpan} data.timeRange\n             * @category Common\n             */\n            bodyRenderer : null,\n\n            // a unique cls used by subclasses to get custom styling of the elements rendered\n            cls : null,\n\n            narrowThreshold : 80\n        };\n    }\n\n    static configurable = {\n        /**\n         * Set to `false` to not render range elements into the time axis header\n         * @prp {Boolean}\n         * @default\n         * @category Common\n         */\n        showHeaderElements : true\n    };\n\n    // Plugin configuration. This plugin chains some functions in Grid.\n    static pluginConfig = {\n        chain : [\n            'onPaint',\n            'populateTimeAxisHeaderMenu',\n            'onSchedulerHorizontalScroll',\n            'afterScroll',\n            'onInternalResize'\n        ]\n    };\n\n    //endregion\n\n    //region Init & destroy\n\n    construct(client, config) {\n        const me = this;\n\n        super.construct(client, config);\n\n        if (client.isVertical) {\n            client.ion({\n                renderRows : me.onUIReady,\n                thisObj    : me,\n                once       : true\n            });\n        }\n\n        // Add a unique cls used by subclasses to get custom styling of the elements rendered\n        // This makes sure that each class only removed its own elements from the DOM\n        me.cls = me.cls || `b-sch-${me.constructor.$$name.toLowerCase()}`;\n\n        me.baseSelector = `.${me.baseCls}.${me.cls}`;\n\n        // header elements are required for interaction\n        if (me.enableResizing) {\n            me.showHeaderElements = true;\n        }\n    }\n\n    doDestroy() {\n        const me = this;\n\n        me.detachListeners('timeAxisViewModel');\n        me.detachListeners('timeAxis');\n\n        me.clockTemplate?.destroy();\n        me.tip?.destroy();\n\n        me.drag?.destroy();\n        me.resize?.destroy();\n\n        super.doDestroy();\n    }\n\n    doDisable(disable) {\n        this.renderRanges();\n\n        super.doDisable(disable);\n    }\n\n    setupTimeAxisViewModelListeners() {\n        const me = this;\n\n        me.detachListeners('timeAxisViewModel');\n        me.detachListeners('timeAxis');\n\n        me.client.timeAxisViewModel.ion({\n            name    : 'timeAxisViewModel',\n            update  : 'onTimeAxisViewModelUpdate',\n            thisObj : me\n        });\n\n        me.client.timeAxis.ion({\n            name          : 'timeAxis',\n            includeChange : 'renderRanges',\n            thisObj       : me\n        });\n\n        me.updateLineBuffer();\n    }\n\n    onUIReady() {\n        const\n            me         = this,\n            { client } = me;\n\n        // If timeAxisViewModel is swapped, re-setup listeners to new instance\n        client.ion({\n            timeAxisViewModelChange : me.setupTimeAxisViewModelListeners,\n            thisObj                 : me\n        });\n\n        me.setupTimeAxisViewModelListeners();\n\n        if (!client.hideHeaders) {\n            if (me.headerContainerElement) {\n                EventHelper.on({\n                    click       : me.onTimeRangeClick,\n                    dblclick    : me.onTimeRangeClick,\n                    contextmenu : me.onTimeRangeClick,\n                    delegate    : me.baseSelector,\n                    element     : me.headerContainerElement,\n                    thisObj     : me\n                });\n            }\n\n            if (me.enableResizing) {\n\n                me.drag = DragHelper.new({\n                    name               : 'rangeDrag',\n                    lockX              : client.isVertical,\n                    lockY              : client.isHorizontal,\n                    constrain          : true,\n                    outerElement       : me.headerContainerElement,\n                    targetSelector     : `${me.baseSelector}`,\n                    isElementDraggable : (el, event) => !client.readOnly && me.isElementDraggable(el, event),\n                    rtlSource          : client,\n\n                    internalListeners : {\n                        dragstart : 'onDragStart',\n                        drag      : 'onDrag',\n                        drop      : 'onDrop',\n                        reset     : 'onDragReset',\n                        abort     : 'onInvalidDrop',\n                        thisObj   : me\n                    }\n                }, me.dragHelperConfig);\n\n                me.resize = ResizeHelper.new({\n                    direction          : client.mode,\n                    targetSelector     : `${me.baseSelector}.b-sch-range`,\n                    outerElement       : me.headerContainerElement,\n                    isElementResizable : (el, event) => !el.matches('.b-dragging,.b-readonly') && !event.target.matches('.b-fa'),\n                    internalListeners  : {\n                        resizestart : 'onResizeStart',\n                        resizing    : 'onResizeDrag',\n                        resize      : 'onResize',\n                        cancel      : 'onInvalidResize',\n                        reset       : 'onResizeReset',\n                        thisObj     : me\n                    }\n                }, me.resizeHelperConfig);\n            }\n        }\n\n        me.renderRanges();\n\n        if (me.tooltipTemplate) {\n            me.hoverTooltip = new Tooltip({\n                forElement : me.headerContainerElement,\n                getHtml({ activeTarget }) {\n                    const timeRange = me.resolveTimeRangeRecord(activeTarget);\n\n                    return me.tooltipTemplate({ timeRange });\n                },\n                forSelector : '.' + me.baseCls + (me.cls ? '.' + me.cls : '')\n            });\n        }\n    }\n\n    //endregion\n\n    //region Draw\n\n    refresh() {\n        this._timeRanges = null;\n        this.renderRanges();\n    }\n\n    getDOMConfig(startDate, endDate) {\n        const\n            me            = this,\n            bodyConfigs   = [],\n            headerConfigs = [];\n\n        if (!me.disabled) {\n            // clear label rotation map cache here, used to prevent height calculations for every timeRange entry to\n            // speed up using recurrences\n            me._labelRotationMap = {};\n\n            for (const range of me.timeRanges) {\n                const result = me.renderRange(range, startDate, endDate);\n                if (result) {\n                    bodyConfigs.push(result.bodyConfig);\n                    headerConfigs.push(result.headerConfig);\n                }\n            }\n        }\n\n        return [bodyConfigs, headerConfigs];\n    }\n\n    renderRanges() {\n        const\n            me                   = this,\n            { client }           = me,\n            { foregroundCanvas } = client;\n\n        // Scheduler/Gantt might not yet be rendered\n        if (foregroundCanvas && client.isPainted && !client.timeAxisSubGrid.collapsed) {\n            const\n                { headerContainerElement }   = me,\n                updatedBodyElements          = [],\n                [bodyConfigs, headerConfigs] = me.getDOMConfig();\n\n            if (!me.bodyCanvas) {\n                me.bodyCanvas = DomHelper.createElement({\n                    className     : `b-timeranges-canvas ${me.cls}-canvas`,\n                    parent        : foregroundCanvas,\n                    retainElement : true\n                });\n            }\n\n            DomSync.sync({\n                targetElement : me.bodyCanvas,\n                childrenOnly  : true,\n                domConfig     : {\n                    children    : bodyConfigs,\n                    syncOptions : {\n                        releaseThreshold : 0,\n                        syncIdField      : 'id'\n                    }\n                },\n                callback : me.showHeaderElements ? null : ({\n                    targetElement,\n                    action\n                }) => {\n                    // Might need to rotate label when not showing header elements\n                    if (action === 'reuseElement' || action === 'newElement' || action === 'reuseOwnElement') {\n                        // Collect all here, to not force reflows in the middle of syncing\n                        updatedBodyElements.push(targetElement);\n                    }\n                }\n            });\n\n            if (me.showHeaderElements && !me.headerCanvas) {\n                me.headerCanvas = DomHelper.createElement({\n                    className     : `${me.cls}-canvas`,\n                    parent        : headerContainerElement,\n                    retainElement : true\n                });\n            }\n\n            if (me.headerCanvas) {\n                DomSync.sync({\n                    targetElement : me.headerCanvas,\n                    childrenOnly  : true,\n                    domConfig     : {\n                        children    : headerConfigs,\n                        syncOptions : {\n                            releaseThreshold : 0,\n                            syncIdField      : 'id'\n                        }\n                    }\n                });\n            }\n\n            // Rotate labels last, to not force reflows. First check if rotation is needed\n            for (const bodyElement of updatedBodyElements) {\n                me.cacheRotation(bodyElement.elementData.timeRange, bodyElement);\n            }\n\n            // Then apply rotation\n            for (const bodyElement of updatedBodyElements) {\n                me.applyRotation(bodyElement.elementData.timeRange, bodyElement);\n            }\n        }\n    }\n\n    // Implement in subclasses\n    get timeRanges() {\n        return [];\n    }\n\n    /**\n     * Based on this method result the feature decides whether the provided range should\n     * be rendered or not.\n     * The method checks that the range intersects the current viewport.\n     *\n     * Override the method to implement your custom range rendering vetoing logic.\n     * @param {Scheduler.model.TimeSpan} range Range to render.\n     * @param {Date} [startDate] Specifies view start date. Defaults to view visible range start\n     * @param {Date} [endDate] Specifies view end date. Defaults to view visible range end\n     * @returns {Boolean} `true` if the range should be rendered and `false` otherwise.\n     */\n    shouldRenderRange(\n        range,\n        startDate = this.client.visibleDateRange.startDate,\n        endDate   = this.client.visibleDateRange.endDate\n    ) {\n        const\n            { timeAxis }                                             = this.client,\n            { startDate : rangeStart, endDate : rangeEnd, duration } = range;\n\n        return Boolean(rangeStart && (timeAxis.isContinuous || timeAxis.isTimeSpanInAxis(range)) && DateHelper.intersectSpans(\n            startDate,\n            endDate,\n            rangeStart,\n            // Lines are included longer, to make sure label does not disappear\n            duration ? rangeEnd : DateHelper.add(rangeStart, this._lineBufferDurationMS)\n        ));\n    }\n\n    getRangeDomConfig(timeRange, minDate, maxDate, relativeTo = 0) {\n        const\n            me         = this,\n            { client } = me,\n            { rtl }    = client,\n            startPos   = client.getCoordinateFromDate(DateHelper.max(timeRange.startDate, minDate), {\n                respectExclusion : true\n            }) - relativeTo,\n            endPos     = timeRange.endDate ? client.getCoordinateFromDate(DateHelper.min(timeRange.endDate, maxDate), {\n                respectExclusion : true,\n                isEnd            : true\n            }) - relativeTo : startPos,\n            size       = Math.abs(endPos - startPos),\n            isRange    = size > 0,\n            translateX = rtl ? `calc(${startPos}px - 100%)` : `${startPos}px`;\n\n        return {\n            className : {\n                [me.baseCls]     : 1,\n                [me.cls]         : me.cls,\n                [me.rangeCls]    : isRange,\n                [me.lineCls]     : !isRange,\n                [timeRange.cls]  : timeRange.cls,\n                'b-narrow-range' : isRange && size < me.narrowThreshold,\n                'b-readonly'     : timeRange.readOnly,\n                'b-rtl'          : rtl\n            },\n            dataset : {\n                id : timeRange.id\n            },\n            elementData : {\n                timeRange\n            },\n            style : client.isVertical\n                ? `transform: translateY(${translateX}); ${isRange ? `height:${size}px` : ''};`\n                : `transform: translateX(${translateX}); ${isRange ? `width:${size}px` : ''};`\n        };\n    }\n\n    renderRange(timeRange, startDate, endDate) {\n        const\n            me           = this,\n            { client }   = me,\n            { timeAxis } = client;\n\n        if (me.shouldRenderRange(timeRange, startDate, endDate) && timeAxis.startDate) {\n            const\n                config     = me.getRangeDomConfig(timeRange, timeAxis.startDate, timeAxis.endDate),\n                icon       = timeRange.iconCls && StringHelper.xss`<i class=\"${timeRange.iconCls}\"></i>`,\n                name       = timeRange.name && StringHelper.encodeHtml(timeRange.name),\n                labelTpl   = (name || icon) ? `<label>${icon || ''}${name || '&nbsp;'}</label>` : '',\n                bodyConfig = {\n                    ...config,\n                    style : config.style + (timeRange.style || ''),\n                    html  : me.bodyRenderer ? me.bodyRenderer({ timeRange }) : (me.showHeaderElements && !me.showLabelInBody ? '' : labelTpl)\n                };\n\n            let headerConfig;\n\n            if (me.showHeaderElements) {\n                headerConfig = {\n                    ...config,\n                    html : (me.headerRenderer ? me.headerRenderer({ timeRange }) : (me.showLabelInBody ? '' : labelTpl))\n                };\n            }\n\n            return { bodyConfig, headerConfig };\n        }\n    }\n\n    // Cache label rotation to not have to calculate for each occurrence when using recurring timeranges\n    cacheRotation(range, bodyElement) {\n        // Lines have no label. Do not check label content to do not force DOM layout!\n        if ((!range.iconCls && !range.name) || !range.duration) {\n            return;\n        }\n\n        const label = bodyElement.firstElementChild;\n\n        if (label && !range.recurringTimeSpan) {\n            this._labelRotationMap[range.id] = this.client.isVertical\n                ? label.offsetHeight < bodyElement.offsetHeight\n                : label.offsetWidth > bodyElement.offsetWidth;\n        }\n    }\n\n    applyRotation(range, bodyElement) {\n        const rotate = this._labelRotationMap[range.recurringTimeSpan?.id ?? range.id];\n\n        bodyElement.firstElementChild?.classList.toggle('b-vertical', Boolean(rotate));\n    }\n\n    getBodyElementByRecord(idOrRecord) {\n        const id = typeof idOrRecord === 'string' ? idOrRecord : idOrRecord?.id;\n\n        return id != null && DomSync.getChild(this.bodyCanvas, id);\n    }\n\n    // Implement in subclasses\n    resolveTimeRangeRecord(el) {}\n\n    get headerContainerElement() {\n        const\n            me                                       = this,\n            { isVertical, timeView, timeAxisColumn } = me.client;\n\n        if (!me._headerContainerElement) {\n            // Render into the subGrids header element or the vertical timeaxis depending on mode\n            if (isVertical && timeView.element) {\n                me._headerContainerElement = timeView.element.parentElement;\n            }\n            else if (!isVertical) {\n                me._headerContainerElement = timeAxisColumn.element;\n            }\n        }\n\n        return me._headerContainerElement;\n    }\n\n    //endregion\n\n    //region Settings\n\n    get showHeaderElements() {\n        return !this.client.hideHeaders && this._showHeaderElements;\n    }\n\n    updateShowHeaderElements(show) {\n        const { client } = this;\n\n        if (!this.isConfiguring) {\n            client.element.classList.toggle('b-sch-timeranges-with-headerelements', Boolean(show));\n\n            this.renderRanges();\n        }\n    }\n\n    //endregion\n\n    //region Menu items\n\n    /**\n     * Adds menu items for the context menu, and may mutate the menu configuration.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateTimeAxisHeaderMenu({ column, items }) {}\n\n    //endregion\n\n    //region Events & hooks\n\n    onPaint({ firstPaint }) {\n        if (firstPaint && this.client.isHorizontal) {\n            this.onUIReady();\n        }\n    }\n\n    onSchedulerHorizontalScroll() {\n        // Don't need a refresh, ranges are already available. Just need to draw those now in view\n        this.client.isHorizontal && this.renderRanges();\n    }\n\n    afterScroll() {\n        this.client.isVertical && this.renderRanges();\n    }\n\n    updateLineBuffer() {\n        const { timeAxisViewModel } = this.client;\n        // Lines have no duration, but we want them to be visible longer for the label to not suddenly disappear.\n        // We use a 300px buffer for that, recalculated as an amount of ms\n        this._lineBufferDurationMS = timeAxisViewModel.getDateFromPosition(300) - timeAxisViewModel.getDateFromPosition(0);\n    }\n\n    onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight) {\n        if (this.client.isVertical && oldHeight !== newHeight) {\n            this.renderRanges();\n        }\n    }\n\n    onTimeAxisViewModelUpdate() {\n        this.updateLineBuffer();\n\n        this.refresh();\n    }\n\n    onTimeRangeClick(event) {\n        const timeRangeRecord = this.resolveTimeRangeRecord(event.target);\n\n        this.client.trigger(`timeRangeHeader${StringHelper.capitalize(event.type)}`, { event, domEvent : event, timeRangeRecord });\n    }\n\n    //endregion\n\n    //region Drag drop\n\n    showTip(context) {\n        const me = this;\n\n        if (me.showTooltip) {\n            me.clockTemplate = new ClockTemplate({\n                scheduler : me.client\n            });\n\n            me.tip = new Tooltip(ObjectHelper.assign({\n                id                       : `${me.client.id}-time-range-tip`,\n                cls                      : 'b-interaction-tooltip',\n                align                    : 'b-t',\n                autoShow                 : true,\n                updateContentOnMouseMove : true,\n                forElement               : context.element,\n                getHtml                  : () => me.getTipHtml(context.record, context.element)\n            }, me.showTooltip));\n        }\n    }\n\n    destroyTip() {\n        if (this.tip) {\n            this.tip.destroy();\n            this.tip = null;\n        }\n    }\n\n    isElementDraggable(el) {\n        el = el.closest(this.baseSelector + ':not(.b-resizing):not(.b-readonly)');\n\n        return el && !el.classList.contains('b-over-resize-handle');\n    }\n\n    onDragStart({ context }) {\n        const { client, drag } = this;\n\n        if (client.isVertical) {\n            drag.minY = 0;\n            // Moving the range, you can drag the start marker down until the end of the range hits the time axis end\n            drag.maxY = client.timeAxisViewModel.totalSize - context.element.offsetHeight;\n            // Setting min/max for X makes drag right of the header valid, but visually still constrained vertically\n            drag.minX = 0;\n            drag.maxX = Number.MAX_SAFE_INTEGER;\n        }\n        else {\n            drag.minX = 0;\n            // Moving the range, you can drag the start marker right until the end of the range hits the time axis end\n            drag.maxX = client.timeAxisViewModel.totalSize - context.element.offsetWidth;\n            // Setting min/max for Y makes drag below header valid, but visually still constrained horizontally\n            drag.minY = 0;\n            drag.maxY = Number.MAX_SAFE_INTEGER;\n        }\n\n        client.element.classList.add('b-dragging-timerange');\n    }\n\n    onDrop({ context }) {\n        this.client.element.classList.remove('b-dragging-timerange');\n    }\n\n    onInvalidDrop() {\n        this.drag.reset();\n        this.client.element.classList.remove('b-dragging-timerange');\n\n        this.destroyTip();\n    }\n\n    updateDateIndicator({ startDate, endDate }) {\n        const\n            me             = this,\n            { tip }        = me,\n            endDateElement = tip.element.querySelector('.b-sch-tooltip-enddate');\n\n        me.clockTemplate.updateDateIndicator(tip.element, startDate);\n        endDateElement && me.clockTemplate.updateDateIndicator(endDateElement, endDate);\n    }\n\n    onDrag({ context }) {\n        const\n            me         = this,\n            { client } = me,\n            box        = Rectangle.from(context.element),\n            startPos   = box.getStart(client.rtl, client.isHorizontal),\n            endPos     = box.getEnd(client.rtl, client.isHorizontal),\n            startDate  = client.getDateFromCoordinate(startPos, 'round', false),\n            endDate    = client.getDateFromCoordinate(endPos, 'round', false);\n\n        me.updateDateIndicator({ startDate, endDate });\n    }\n\n    onDragReset() {}\n\n    // endregion\n\n    // region Resize\n\n    onResizeStart() {}\n\n    onResizeDrag() {}\n\n    onResize() {}\n\n    onInvalidResize() {}\n\n    onResizeReset() {}\n\n    //endregion\n\n    //region Tooltip\n\n    /**\n     * Generates the html to display in the tooltip during drag drop.\n     *\n     */\n    getTipHtml(record, element) {\n        const\n            me         = this,\n            { client } = me,\n            box        = Rectangle.from(element),\n            startPos   = box.getStart(client.rtl, client.isHorizontal),\n            endPos     = box.getEnd(client.rtl, client.isHorizontal),\n            startDate  = client.getDateFromCoordinate(startPos, 'round', false),\n            endDate    = record.endDate && client.getDateFromCoordinate(endPos, 'round', false),\n            startText  = client.getFormattedDate(startDate),\n            endText    = endDate && client.getFormattedEndDate(endDate, startDate);\n\n        return me.dragTipTemplate({\n            name           : record.name || '',\n            startDate,\n            endDate,\n            startText,\n            endText,\n            startClockHtml : me.clockTemplate.template({\n                date : startDate,\n                text : startText,\n                cls  : 'b-sch-tooltip-startdate'\n            }),\n            endClockHtml : endText && me.clockTemplate.template({\n                date : endDate,\n                text : endText,\n                cls  : 'b-sch-tooltip-enddate'\n            })\n        });\n    }\n\n    //endregion\n}\n", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport AttachToProjectMixin from '../../Scheduler/data/mixin/AttachToProjectMixin.js';\n\n/**\n * @module Scheduler/feature/ColumnLines\n */\nconst emptyObject = Object.freeze({});\n\n/**\n * Displays column lines for ticks, with a different styling for major ticks (by default they are darker). If this\n * feature is disabled, no lines are shown. If it's enabled, line are shown for the tick level which is set in current\n * ViewPreset. Please see {@link Scheduler.preset.ViewPreset#field-columnLinesFor} config for details.\n *\n * The lines are drawn as divs, with only visible lines available in DOM. The color and style of the lines are\n * determined the css rules for `.b-column-line` and `.b-column-line-major`.\n *\n * For vertical mode, this features also draws vertical resource column lines if scheduler is configured with\n * `columnLines : true` (which is the default, see {@link Grid.view.GridBase#config-columnLines}).\n *\n * This feature is **enabled** by default\n *\n * @extends Core/mixin/InstancePlugin\n * @mixes Core/mixin/Delayable\n * @demo Scheduler/basic\n * @inlineexample Scheduler/feature/ColumnLines.js\n * @classtype columnLines\n * @feature\n */\nexport default class ColumnLines extends InstancePlugin.mixin(AttachToProjectMixin, Delayable) {\n    //region Config\n\n    static get $name() {\n        return 'ColumnLines';\n    }\n\n    static get delayable() {\n        return {\n            refresh : {\n                type              : 'raf',\n                cancelOutstanding : true\n            }\n        };\n    }\n\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            after : ['render', 'updateCanvasSize', 'onVisibleDateRangeChange', 'onVisibleResourceRangeChange']\n        };\n    }\n\n    //endregion\n\n    //region Init & destroy\n\n    construct(client, config) {\n        client.useBackgroundCanvas = true;\n\n        super.construct(client, config);\n    }\n\n    attachToResourceStore(resourceStore) {\n        const { client } = this;\n\n        super.attachToResourceStore(resourceStore);\n\n        if (client.isVertical) {\n            client.resourceStore.ion({\n                name : 'resourceStore',\n                group({ groupers }) {\n                    if (groupers.length === 0) {\n                        this.refresh();\n                    }\n                },\n                thisObj : this\n            });\n        }\n    }\n\n    doDisable(disable) {\n        super.doDisable(disable);\n\n        if (!this.isConfiguring) {\n            this.refresh();\n        }\n    }\n\n    //endregion\n\n    //region Draw\n\n    /**\n     * Draw lines when scheduler/gantt is rendered.\n     * @private\n     */\n    render() {\n        this.refresh();\n    }\n\n    getColumnLinesDOMConfig(startDate, endDate) {\n        const\n            me               = this,\n            { client }       = me,\n            { rtl }          = client,\n            m                = rtl ? -1 : 1,\n            {\n                timeAxisViewModel,\n                isHorizontal,\n                resourceStore,\n                variableColumnWidths\n            }                = client,\n            { columnConfig } = timeAxisViewModel;\n\n        const\n            linesForLevel      = timeAxisViewModel.columnLinesFor,\n            majorLinesForLevel = Math.max(linesForLevel - 1, 0),\n            start              = startDate.getTime(),\n            end                = endDate.getTime(),\n            domConfigs         = [],\n            dates              = new Set(),\n            dimension          = isHorizontal ? 'X' : 'Y';\n\n        if (!me.disabled) {\n            const addLineConfig = (tick, isMajor) => {\n                const tickStart = tick.start.getTime();\n                // Only start of tick matters.\n                // Each tick has an exact calculated start position along the time axis\n                // and carries a border on its left, so column lines follow from\n                // tick 1 (zero-based) onwards.\n                if (tickStart > start && tickStart < end && !dates.has(tickStart)) {\n                    dates.add(tickStart);\n                    domConfigs.push({\n                        role      : 'presentation',\n                        className : isMajor ? 'b-column-line-major' : 'b-column-line',\n                        style     : {\n                            transform : `translate${dimension}(${tick.coord * m}px)`\n                        },\n                        dataset : {\n                            line : isMajor ? `major-${tick.index}` : `line-${tick.index}`\n                        }\n                    });\n                }\n            };\n\n            // Collect configs for major lines\n            if (linesForLevel !== majorLinesForLevel) {\n                for (let i = 1; i <= columnConfig[majorLinesForLevel].length - 1; i++) {\n                    addLineConfig(columnConfig[majorLinesForLevel][i], true);\n                }\n            }\n\n            // And normal lines, skipping dates already occupied by major lines\n            for (let i = 1; i <= columnConfig[linesForLevel].length - 1; i++) {\n                addLineConfig(columnConfig[linesForLevel][i], false);\n            }\n\n            // Add vertical resource column lines, if grid is configured to show column lines\n            if (!isHorizontal && client.columnLines) {\n                const\n                    { columnWidth } = client.resourceColumns;\n                let {\n                    first : firstResource,\n                    last  : lastResource\n                }               = client.currentOrientation.getResourceRange(true);\n\n                let nbrGroupHeaders = 0;\n\n                if (firstResource > -1) {\n                    for (let i = firstResource; i < lastResource + 1; i++) {\n                        const\n                            resourceRecord = resourceStore.getAt(i);\n\n                        // Only add lines for group children\n                        if (resourceRecord.isGroupHeader) {\n                            lastResource++;\n                            nbrGroupHeaders++;\n                            continue;\n                        }\n\n                        const\n                            instanceMeta = resourceRecord.instanceMeta(resourceStore),\n                            left         = variableColumnWidths ? instanceMeta.insetStart + resourceRecord.columnWidth - 1 : (i - nbrGroupHeaders + 1) * columnWidth - 1;\n\n                        domConfigs.push({\n                            className : {\n                                'b-column-line'            : 1,\n                                'b-resource-column-line'   : 1,\n                                'b-resource-group-divider' : resourceStore.isGrouped && instanceMeta.groupParent?.groupChildren[instanceMeta.groupParent?.groupChildren.length - 1] === resourceRecord\n                            },\n                            style : {\n                                transform : `translateX(${left * m}px)`\n                            },\n                            dataset : {\n                                line : `resource-${i}`\n                            }\n                        });\n                    }\n                }\n            }\n        }\n\n        return domConfigs;\n    }\n\n    /**\n     * Draw column lines that are in view\n     * @private\n     */\n    refresh() {\n        const\n            me                     = this,\n            { client }             = me,\n            { timeAxis }           = client,\n            { startDate, endDate } = client.visibleDateRange || emptyObject,\n            axisStart              = timeAxis.startDate;\n\n        // Early bailout for timeaxis without start date or when starting with schedule collapsed\n        if (!axisStart || !startDate || me.client.timeAxisSubGrid.collapsed) {\n            return;\n        }\n\n        if (!me.element) {\n            me.element = DomHelper.createElement({\n                parent    : client.backgroundCanvas,\n                className : 'b-column-lines-canvas'\n            });\n        }\n\n        const domConfigs = me.getColumnLinesDOMConfig(startDate, endDate);\n\n        DomSync.sync({\n            targetElement : me.element,\n            onlyChildren  : true,\n            domConfig     : {\n                children    : domConfigs,\n                syncOptions : {\n                    // When zooming in and out we risk getting a lot of released lines if we do not limit it\n                    releaseThreshold : 4\n                }\n            },\n            syncIdField : 'line'\n        });\n    }\n\n    //endregion\n\n    //region Events\n\n    // Called when visible date range changes, for example from zooming, scrolling, resizing\n    onVisibleDateRangeChange() {\n        this.refresh();\n    }\n\n    // Called when visible resource range changes, for example on scroll and resize\n    onVisibleResourceRangeChange({ firstResource, lastResource }) {\n        this.refresh();\n    }\n\n    updateCanvasSize() {\n        this.refresh();\n    }\n\n    //endregion\n}\n\nGridFeatureManager.registerFeature(ColumnLines, true, ['Scheduler', 'Gantt', 'TimelineHistogram']);\n", "import Base from '../../../Core/Base.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport Objects from '../../../Core/helper/util/Objects.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport Tooltip from '../../../Core/widget/Tooltip.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\nimport DependencyBaseModel from '../../model/DependencyBaseModel.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\n\n/**\n * @module Scheduler/feature/mixin/DependencyCreation\n */\n\n// <remove-on-release>\n// TODO: refactor this class using StateChart utility to be implemented in Core/util/StateChart.js or XState library if allowed to be used\n// </remove-on-release>\n\n/**\n * Mixin for Dependencies feature that handles dependency creation (drag & drop from terminals which are shown on hover).\n * Requires {@link Core.mixin.Delayable} to be mixed in alongside.\n *\n * @mixin\n */\nexport default Target => class DependencyCreation extends (Target || Base) {\n    static get $name() {\n        return 'DependencyCreation';\n    }\n\n    //region Config\n\n    static get defaultConfig() {\n        return {\n            /**\n             * `false` to require a drop on a target event bar side circle to define the dependency type.\n             * If dropped on the event bar, the `defaultValue` of the DependencyModel `type` field will be used to\n             * determine the target task side.\n             *\n             * @member {Boolean} allowDropOnEventBar\n             */\n            /**\n             * `false` to require a drop on a target event bar side circle to define the dependency type.\n             * If dropped on the event bar, the `defaultValue` of the DependencyModel `type` field will be used to\n             * determine the target task side.\n             *\n             * @config {Boolean}\n             * @default\n             */\n            allowDropOnEventBar : true,\n\n            /**\n             * `false` to not show a tooltip while creating a dependency\n             * @config {Boolean}\n             * @default\n             */\n            showCreationTooltip : true,\n\n            /**\n             * A tooltip config object that will be applied to the dependency creation {@link Core.widget.Tooltip}\n             * @config {TooltipConfig}\n             */\n            creationTooltip : null,\n\n            /**\n             * A template function that will be called to generate the HTML contents of the dependency creation tooltip.\n             * You can return either an HTML string or a {@link DomConfig} object.\n             * @prp {Function} creationTooltipTemplate\n             * @param {Object} data Data about the dependency being created\n             * @param {Scheduler.model.TimeSpan} data.source The from event\n             * @param {Scheduler.model.TimeSpan} data.target The target event\n             * @param {String} data.fromSide The from side (start, end, top, bottom)\n             * @param {String} data.toSide The target side (start, end, top, bottom)\n             * @param {Boolean} data.valid The validity of the dependency\n             * @returns {String|DomConfig}\n             */\n\n            /**\n             * CSS class used for terminals\n             * @config {String}\n             * @default\n             */\n            terminalCls : 'b-sch-terminal',\n\n            /**\n             * Where (on event bar edges) to display terminals. The sides are `'start'`, `'top'`,\n             * `'end'` and `'bottom'`\n             * @config {String[]}\n             */\n            terminalSides : ['start', 'top', 'end', 'bottom'],\n\n            /**\n             * Set to `false` to not allow creating dependencies\n             * @config {Boolean}\n             * @default\n             */\n            allowCreate : true\n        };\n    }\n\n    //endregion\n\n    //region Init & destroy\n\n    construct(view, config) {\n        super.construct(view, config);\n\n        const me = this;\n\n        me.view = view;\n        me.eventName = view.scheduledEventName;\n\n        view.ion({ readOnly : () => me.updateCreateListeners() });\n\n        me.updateCreateListeners();\n\n        me.chain(view, 'onElementTouchMove', 'onElementTouchMove');\n    }\n\n    doDestroy() {\n        const me = this;\n\n        me.detachListeners('view');\n\n        me.creationData = null;\n\n        me.pointerUpMoveDetacher?.();\n        me.creationTooltip?.destroy();\n\n        super.doDestroy();\n    }\n\n    updateCreateListeners() {\n        const me = this;\n\n        if (!me.view) {\n            return;\n        }\n\n        me.detachListeners('view');\n\n        if (me.isCreateAllowed) {\n            me.view.ion({\n                name                          : 'view',\n                [`${me.eventName}mouseenter`] : 'onTimeSpanMouseEnter',\n                [`${me.eventName}mouseleave`] : 'onTimeSpanMouseLeave',\n                thisObj                       : me\n            });\n        }\n    }\n\n    set allowCreate(value) {\n        this._allowCreate = value;\n\n        this.updateCreateListeners();\n    }\n\n    get allowCreate() {\n        return this._allowCreate;\n    }\n\n    get isCreateAllowed() {\n        return this.allowCreate && !this.view.readOnly && !this.disabled;\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * Show terminals when mouse enters event/task element\n     * @private\n     */\n    onTimeSpanMouseEnter({\n        event, source, [`${this.eventName}Record`]: record, [`${this.eventName}Element`]: element\n    }) {\n        if (!record.isCreating && !record.readOnly && (!this.client.features.nestedEvents || record.parent.isRoot)) {\n            const\n                me               = this,\n                { creationData } = me,\n                eventBarElement  = DomHelper.down(element, source.eventInnerSelector);\n\n            // When we enter a different event than the one we started on\n            if (record !== creationData?.source) {\n                me.showTerminals(record, eventBarElement);\n\n                if (creationData && event.target.closest(me.client.eventSelector)) {\n                    creationData.timeSpanElement = eventBarElement;\n                    me.onOverTargetEventBar(event);\n                }\n            }\n        }\n    }\n\n    /**\n     * Hide terminals when mouse leaves event/task element\n     * @private\n     */\n    onTimeSpanMouseLeave(event) {\n        const\n            me               = this,\n            { creationData } = me,\n            element          = event[`${me.eventName}Element`],\n            timeSpanLeft     = DomHelper.down(element, me.view.eventInnerSelector),\n            target           = event.event?.relatedTarget,\n            timeSpanElement  = creationData?.timeSpanElement;\n\n        // Can happen when unhovering an occurrence during update\n        if (!target) {\n            return;\n        }\n\n        if (!creationData || !timeSpanElement || !target || !DomHelper.isDescendant(timeSpanElement, target)) {\n            // We cannot hide the terminals for non-trusted events because non-trusted means it's\n            // synthesized from a touchmove event and if the source element of a touchmove\n            // leaves the DOM, the touch gesture is ended.\n            if (event.event.isTrusted || (timeSpanLeft !== creationData?.sourceElement)) {\n                me.hideTerminals(element);\n            }\n        }\n\n        if (creationData && !creationData.finalizing && !target.closest(me.client.eventSelector)) {\n            creationData.timeSpanElement = null;\n            me.onOverNewTargetWhileCreating(undefined, undefined, event);\n        }\n    }\n\n    onTerminalMouseOver(event) {\n        if (this.creationData) {\n            this.onOverTargetEventBar(event);\n        }\n    }\n\n    /**\n     * Remove hover styling when mouse leaves terminal. Also hides terminals when mouse leaves one it and not creating a\n     * dependency.\n     * @private\n     */\n    onTerminalMouseOut(event) {\n        const\n            me               = this,\n            { creationData } = me,\n            eventElement     = event.target.closest(me.view.eventSelector);\n\n        if (eventElement && (!me.showingTerminalsFor || !DomHelper.isDescendant(eventElement, me.showingTerminalsFor)) && (!creationData || eventElement !== creationData.timeSpanElement)) {\n            me.hideTerminals(eventElement);\n            me.view.unhover(eventElement, event);\n        }\n\n        if (creationData) {\n            me.onOverNewTargetWhileCreating(event.relatedTarget, creationData.target, event);\n        }\n    }\n\n    /**\n     * Start creating a dependency when mouse is pressed over terminal\n     * @private\n     */\n    onTerminalPointerDown(event) {\n        const me = this;\n\n        // ignore non-left button clicks\n        if (event.button === 0 && !me.creationData) {\n            const\n                scheduler              = me.view,\n                timeAxisSubGridElement = scheduler.timeAxisSubGridElement,\n                terminalNode           = event.target,\n                timeSpanElement        = terminalNode.closest(scheduler.eventInnerSelector),\n                viewBounds             = Rectangle.from(scheduler.element, document.body);\n\n            event.stopPropagation();\n\n            me.creationData = {\n                sourceElement  : timeSpanElement,\n                source         : scheduler.resolveTimeSpanRecord(timeSpanElement).$original,\n                fromSide       : terminalNode.dataset.side,\n                startPoint     : Rectangle.from(terminalNode, timeAxisSubGridElement).center,\n                startX         : event.pageX - viewBounds.x + scheduler.scrollLeft,\n                startY         : event.pageY - viewBounds.y + scheduler.scrollTop,\n                valid          : false,\n                sourceResource : scheduler.resolveResourceRecord?.(event),\n                tooltip        : me.creationTooltip\n            };\n\n            me.pointerUpMoveDetacher = EventHelper.on({\n                pointerup : {\n                    element : scheduler.element.getRootNode(),\n                    handler : 'onMouseUp',\n                    passive : false\n                },\n                pointermove : {\n                    element : timeAxisSubGridElement,\n                    handler : 'onMouseMove',\n                    passive : false\n                },\n                thisObj : me\n            });\n\n            // If root element is anything but Document (it could be Document Fragment or regular Node in case of LWC)\n            // then we should also add listener to document to cancel dependency creation\n            me.documentPointerUpDetacher = EventHelper.on({\n                pointerup : {\n                    element : document,\n                    handler : 'onDocumentMouseUp'\n                },\n                keydown : {\n                    element : document,\n                    handler : ({ key }) => {\n                        if (key === 'Escape') {\n                            me.abort();\n                        }\n                    }\n                },\n                thisObj : me\n            });\n        }\n    }\n\n    onElementTouchMove(event) {\n        super.onElementTouchMove?.(event);\n\n        if (this.connector) {\n            // Prevent touch scrolling while dragging a connector\n            event.preventDefault();\n        }\n    }\n\n    /**\n     * Update connector line showing dependency between source and target when mouse moves. Also check if mouse is over\n     * a valid target terminal\n     * @private\n     */\n    onMouseMove(event) {\n        const\n            me                            = this,\n            { view, creationData : data } = me,\n            viewBounds                    = Rectangle.from(view.element, document.body),\n            deltaX                        = (event.pageX - viewBounds.x + view.scrollLeft) - data.startX,\n            deltaY                        = (event.pageY - viewBounds.y + view.scrollTop) - data.startY,\n            length                        = Math.round(Math.sqrt(deltaX * deltaX + deltaY * deltaY)) - 3,\n            angle                         = Math.atan2(deltaY, deltaX);\n\n        let { connector } = me;\n\n        if (!connector) {\n            if (me.onRequestDragCreate(event) === false) {\n                return;\n            }\n            connector = me.connector;\n        }\n\n        connector.style.width     = `${length}px`;\n        connector.style.transform = `rotate(${angle}rad)`;\n\n        me.lastMouseMoveEvent = event;\n    }\n\n    onRequestDragCreate(event) {\n        const\n            me                            = this,\n            { view, creationData : data } = me;\n\n        /**\n         * Fired on the owning Scheduler/Gantt before a dependency creation drag operation starts. Return `false` to\n         * prevent it\n         * @event beforeDependencyCreateDrag\n         * @on-owner\n         * @param {Scheduler.model.TimeSpan} source The source task\n         */\n        if (view.trigger('beforeDependencyCreateDrag', { data, source : data.source }) === false) {\n            me.abort();\n            return false;\n        }\n\n        view.element.classList.add('b-creating-dependency');\n\n        me.createConnector(data.startPoint.x, data.startPoint.y);\n\n        /**\n         * Fired on the owning Scheduler/Gantt when a dependency creation drag operation starts\n         * @event dependencyCreateDragStart\n         * @on-owner\n         * @param {Scheduler.model.TimeSpan} source The source task\n         */\n        view.trigger('dependencyCreateDragStart', { data, source : data.source  });\n\n        if (me.showCreationTooltip) {\n            const tip = me.creationTooltip || (me.creationTooltip = me.createDragTooltip());\n\n            me.creationData.tooltip = tip;\n\n            tip.disabled = false;\n            tip.show();\n\n            tip.onMouseMove(event);\n        }\n\n        view.scrollManager.startMonitoring({\n            scrollables : [\n                {\n                    element   : view.timeAxisSubGrid.scrollable.element,\n                    direction : 'horizontal'\n                },\n                {\n                    element   : view.scrollable.element,\n                    direction : 'vertical'\n                }\n            ],\n            callback : () => me.lastMouseMoveEvent && me.onMouseMove(me.lastMouseMoveEvent)\n        });\n    }\n\n    onOverTargetEventBar(event) {\n        const\n            me                                                = this,\n            { view, creationData: data, allowDropOnEventBar } = me,\n            { target }                                        = event;\n\n        let overEventRecord = view.resolveTimeSpanRecord(target).$original;\n\n        // use main event if a segment resolved\n        if (overEventRecord?.isEventSegment) {\n            overEventRecord = overEventRecord.event;\n        }\n\n        if (Objects.isPromise(data.valid) || (!allowDropOnEventBar && !target.classList.contains(me.terminalCls))) {\n            return;\n        }\n\n        if (overEventRecord !== data.source) {\n            me.onOverNewTargetWhileCreating(target, overEventRecord, event);\n        }\n    }\n\n    async onOverNewTargetWhileCreating(targetElement, overEventRecord, event) {\n        const\n            me                                                            = this,\n            { view, creationData : data, allowDropOnEventBar, connector } = me;\n\n        if (Objects.isPromise(data.valid)) {\n            return;\n        }\n\n        // stop target updating if dependency finalizing in progress\n        if (data.finalizing) {\n            return;\n        }\n\n        // Connector might not exist at this point because `pointerout` on the terminal might fire before `pointermove`\n        // on the time axis subgrid. This is difficult to reproduce, so shouldn't be triggered often.\n        // https://github.com/bryntum/support/issues/3116#issuecomment-894256799\n        if (!connector) {\n            return;\n        }\n\n        connector.classList.remove('b-valid', 'b-invalid');\n        data.timeSpanElement && DomHelper.removeClsGlobally(data.timeSpanElement, 'b-sch-terminal-active');\n\n        if (!overEventRecord || overEventRecord === data.source || (!allowDropOnEventBar && !targetElement.classList.contains(me.terminalCls))) {\n            data.target = data.toSide = null;\n            data.valid = false;\n            connector.classList.add('b-invalid');\n        }\n        else {\n            const\n                target     = data.target = overEventRecord,\n                { source } = data;\n\n            let toSide  = targetElement.dataset.side;\n\n            // If we allow dropping anywhere on a task, resolve target side based on the default type of the\n            // dependency model used\n            if (allowDropOnEventBar && !targetElement.classList.contains(me.terminalCls)) {\n                toSide = me.getTargetSideFromType(me.dependencyStore.modelClass.fieldMap.type.defaultValue || DependencyBaseModel.Type.EndToStart);\n            }\n\n            if (view.resolveResourceRecord) {\n                data.targetResource = view.resolveResourceRecord(event);\n            }\n\n            let dependencyType;\n\n            data.toSide = toSide;\n\n            const\n                fromSide       = data.fromSide,\n                updateValidity = valid => {\n                    if (!me.isDestroyed) {\n                        data.valid = valid;\n                        targetElement.classList.add(valid ? 'b-valid' : 'b-invalid');\n                        connector.classList.add(valid ? 'b-valid' : 'b-invalid');\n                        /**\n                         * Fired on the owning Scheduler/Gantt when asynchronous dependency validation completes\n                         * @event dependencyValidationComplete\n                         * @on-owner\n                         * @param {Scheduler.model.TimeSpan} source The source task\n                         * @param {Scheduler.model.TimeSpan} target The target task\n                         * @param {Number} dependencyType The dependency type, see {@link Scheduler.model.DependencyBaseModel#property-Type-static}\n                         */\n                        view.trigger('dependencyValidationComplete', {\n                            data,\n                            source,\n                            target,\n                            dependencyType\n                        });\n                    }\n                };\n\n            // NOTE: Top/Bottom sides are not taken into account due to\n            //       scheduler doesn't check for type value anyway, whereas\n            //       gantt will reject any other dependency types undefined in\n            //       DependencyBaseModel.Type enumeration.\n            switch (true) {\n                case fromSide === 'start' && toSide === 'start':\n                    dependencyType = DependencyBaseModel.Type.StartToStart;\n                    break;\n                case fromSide === 'start' && toSide === 'end':\n                    dependencyType = DependencyBaseModel.Type.StartToEnd;\n                    break;\n                case fromSide === 'end' && toSide === 'start':\n                    dependencyType = DependencyBaseModel.Type.EndToStart;\n                    break;\n                case fromSide === 'end' && toSide === 'end':\n                    dependencyType = DependencyBaseModel.Type.EndToEnd;\n                    break;\n            }\n\n            /**\n             * Fired on the owning Scheduler/Gantt when asynchronous dependency validation starts\n             * @event dependencyValidationStart\n             * @on-owner\n             * @param {Scheduler.model.TimeSpan} source The source task\n             * @param {Scheduler.model.TimeSpan} target The target task\n             * @param {Number} dependencyType The dependency type, see {@link Scheduler.model.DependencyBaseModel#property-Type-static}\n             */\n            view.trigger('dependencyValidationStart', {\n                data,\n                source,\n                target,\n                dependencyType\n            });\n\n            let valid = data.valid = me.dependencyStore.isValidDependency(source, target, dependencyType);\n\n            // Promise is returned when using the engine\n            if (Objects.isPromise(valid)) {\n                valid = await valid;\n                updateValidity(valid);\n            }\n            else {\n                updateValidity(valid);\n            }\n\n            const validityCls = valid ? 'b-valid' : 'b-invalid';\n            connector.classList.add(validityCls);\n            data.timeSpanElement?.querySelector(`.b-sch-terminal[data-side=${toSide}]`)?.classList.add('b-sch-terminal-active', validityCls);\n        }\n\n        me.updateCreationTooltip();\n    }\n\n    /**\n     * Create a new dependency if mouse release over valid terminal. Hides connector\n     * @private\n     */\n    async onMouseUp() {\n        const\n            me   = this,\n            data = me.creationData;\n\n        data.finalizing = true;\n        me.pointerUpMoveDetacher?.();\n\n        if (data.valid) {\n            /**\n             * Fired on the owning Scheduler/Gantt when a dependency drag creation operation is about to finalize\n             *\n             * @event beforeDependencyCreateFinalize\n             * @on-owner\n             * @preventable\n             * @async\n             * @param {Scheduler.model.TimeSpan} source The source task\n             * @param {Scheduler.model.TimeSpan} target The target task\n             * @param {'start'|'end'|'top'|'bottom'} fromSide The from side (start / end / top / bottom)\n             * @param {'start'|'end'|'top'|'bottom'} toSide The to side (start / end / top / bottom)\n             */\n            const result = await me.view.trigger('beforeDependencyCreateFinalize', data);\n\n            if (result === false) {\n                data.valid = false;\n            }\n            // Await any async validation logic before continuing\n            else if (Objects.isPromise(data.valid)) {\n                data.valid = await data.valid;\n            }\n\n            if (data.valid) {\n                let dependency = me.createDependency(data);\n\n                if (dependency !== null) {\n                    if (Objects.isPromise(dependency)) {\n                        dependency = await dependency;\n                    }\n\n                    data.dependency = dependency;\n\n                    /**\n                     * Fired on the owning Scheduler/Gantt when a dependency drag creation operation succeeds\n                     * @event dependencyCreateDrop\n                     * @on-owner\n                     * @param {Scheduler.model.TimeSpan} source The source task\n                     * @param {Scheduler.model.TimeSpan} target The target task\n                     * @param {Scheduler.model.DependencyBaseModel} dependency The created dependency\n                     */\n                    me.view.trigger('dependencyCreateDrop', { data, source : data.source, target : data.target, dependency });\n                    me.doAfterDependencyDrop(data);\n                }\n            }\n            else {\n                me.doAfterDependencyDrop(data);\n            }\n        }\n        else {\n            data.valid = false;\n            me.doAfterDependencyDrop(data);\n        }\n\n        me.abort();\n    }\n\n    doAfterDependencyDrop(data) {\n        /**\n         * Fired on the owning Scheduler/Gantt after a dependency drag creation operation finished, no matter to outcome\n         * @event afterDependencyCreateDrop\n         * @on-owner\n         * @param {Scheduler.model.TimeSpan} source The source task\n         * @param {Scheduler.model.TimeSpan} target The target task\n         * @param {Scheduler.model.DependencyBaseModel} dependency The created dependency\n         */\n        this.view.trigger('afterDependencyCreateDrop', {\n            data,\n            ...data\n        });\n    }\n\n    onDocumentMouseUp({ target }) {\n        if (!this.view.timeAxisSubGridElement.contains(target)) {\n            this.abort();\n        }\n    }\n\n    /**\n     * Aborts dependency creation, removes proxy and cleans up listeners\n     */\n    abort() {\n        const\n            me                     = this,\n            { view, creationData } = me;\n\n        // Remove terminals from source and target events.\n        if (creationData) {\n            const { source, sourceResource, target, targetResource } = creationData;\n\n            if (source) {\n                const el = view.getElementFromEventRecord(source, sourceResource);\n                if (el) {\n                    me.hideTerminals(el);\n                }\n            }\n            if (target) {\n                const el = view.getElementFromEventRecord(target, targetResource);\n                if (el) {\n                    me.hideTerminals(el);\n                }\n            }\n        }\n\n        if (me.creationTooltip) {\n            me.creationTooltip.disabled = true;\n        }\n\n        me.creationData = me.lastMouseMoveEvent = null;\n\n        me.pointerUpMoveDetacher?.();\n\n        me.documentPointerUpDetacher?.();\n\n        me.removeConnector();\n    }\n\n    //endregion\n\n    //region Connector\n\n    /**\n     * Creates a connector line that visualizes dependency source & target\n     * @private\n     */\n    createConnector(x, y) {\n        const\n            me       = this,\n            { view } = me;\n\n        me.clearTimeout(me.removeConnectorTimeout);\n        me.connector = DomHelper.createElement({\n            parent    : view.timeAxisSubGridElement,\n            className : `${me.baseCls}-connector`,\n            style     : `left:${x}px;top:${y}px`\n        });\n\n        view.element.classList.add('b-creating-dependency');\n    }\n\n    createDragTooltip() {\n        const\n            me       = this,\n            { view } = me;\n\n        return me.creationTooltip = Tooltip.new({\n            id             : `${view.id}-dependency-drag-tip`,\n            cls            : 'b-sch-dependency-creation-tooltip',\n            loadingMsg     : '',\n            anchorToTarget : false,\n            // Keep tip visible until drag drop operation is finalized\n            forElement     : view.timeAxisSubGridElement,\n            trackMouse     : true,\n            // Do not constrain at all, want it to be able to go outside of the viewport to not get in the way\n            constrainTo    : null,\n\n            header : {\n                dock : 'right'\n            },\n\n            internalListeners : {\n                // Show initial content immediately\n                beforeShow : 'updateCreationTooltip',\n                thisObj    : me\n            }\n        }, me.creationTooltip);\n    }\n\n    /**\n     * Remove connector\n     * @private\n     */\n    removeConnector() {\n        const\n            me                  = this,\n            { connector, view } = me;\n\n        if (connector) {\n            connector.classList.add('b-removing');\n            connector.style.width = '0';\n            me.removeConnectorTimeout = me.setTimeout(() => {\n                connector.remove();\n                me.connector = null;\n            }, 200);\n        }\n\n        view.element.classList.remove('b-creating-dependency');\n        me.creationTooltip && me.creationTooltip.hide();\n\n        view.scrollManager.stopMonitoring();\n    }\n\n    //endregion\n\n    //region Terminals\n\n    /**\n     * Show terminals for specified event at sides defined in #terminalSides.\n     * @param {Scheduler.model.TimeSpan} timeSpanRecord Event/task to show terminals for\n     * @param {HTMLElement} element Event/task element\n     */\n    showTerminals(timeSpanRecord, element) {\n        const me = this;\n\n        // Record not part of project is a transient record in a display store, not meant to be manipulated\n        if (!me.isCreateAllowed || !timeSpanRecord.project) {\n            return;\n        }\n\n        const\n            cls                 = me.terminalCls,\n            terminalsVisibleCls = `${cls}s-visible`;\n\n        // We operate on the event bar, not the wrap\n        element = DomHelper.down(element, me.view.eventInnerSelector);\n\n        // bail out if terminals already shown or if view is readonly\n        // do not draw new terminals if we are resizing event\n        if (!element.classList.contains(terminalsVisibleCls) && !me.view.element.classList.contains('b-resizing-event') && !me.view.readOnly) {\n            /**\n             * Fired on the owning Scheduler/Gantt before showing dependency terminals on a task or event. Return `false` to\n             * prevent it\n             * @event beforeShowTerminals\n             * @on-owner\n             * @param {Scheduler.model.TimeSpan} source The hovered task\n             */\n            if (me.client.trigger('beforeShowTerminals', { source : timeSpanRecord }) === false) {\n                return;\n            }\n\n            // create terminals for desired sides\n            me.terminalSides.forEach(side => {\n                // Allow code to use left for the start side and right for the end side\n                side = me.fixSide(side);\n\n                const terminal = DomHelper.createElement({\n                    parent    : element,\n                    className : `${cls} ${cls}-${side}`,\n                    dataset   : {\n                        side,\n                        feature : true\n                    }\n                });\n\n                terminal.detacher = EventHelper.on({\n                    element     : terminal,\n                    mouseover   : 'onTerminalMouseOver',\n                    mouseout    : 'onTerminalMouseOut',\n                    // Needs to be pointerdown to match DragHelper, otherwise will be preventing wrong event\n                    pointerdown : {\n                        handler : 'onTerminalPointerDown',\n                        capture : true\n                    },\n                    thisObj : me\n                });\n            });\n\n            element.classList.add(terminalsVisibleCls);\n            timeSpanRecord.internalCls.add(terminalsVisibleCls);\n\n            me.showingTerminalsFor = element;\n        }\n    }\n\n    fixSide(side) {\n        if (side === 'left') {\n            return 'start';\n        }\n        if (side === 'right') {\n            return 'end';\n        }\n        return side;\n    }\n\n    /**\n     * Hide terminals for specified event\n     * @param {HTMLElement} eventElement Event element\n     */\n    hideTerminals(eventElement) {\n        // remove all terminals\n        const\n            me                  = this,\n            eventParams         = me.client.getTimeSpanMouseEventParams(eventElement),\n            timeSpanRecord      = eventParams?.[`${me.eventName}Record`],\n            terminalsVisibleCls = `${me.terminalCls}s-visible`;\n\n        DomHelper.forEachSelector(eventElement, `.${me.terminalCls}`, terminal => {\n            terminal.detacher && terminal.detacher();\n            terminal.remove();\n        });\n\n        DomHelper.down(eventElement, me.view.eventInnerSelector).classList.remove(terminalsVisibleCls);\n        timeSpanRecord.internalCls.remove(terminalsVisibleCls);\n\n        me.showingTerminalsFor = null;\n    }\n\n    //endregion\n\n    //region Dependency creation\n\n    /**\n     * Create a new dependency from source terminal to target terminal\n     * @internal\n     */\n    createDependency(data) {\n        const\n            { source, target, fromSide, toSide } = data,\n            type                                 = (fromSide === 'start' ? 0 : 2) + (toSide === 'end' ? 1 : 0);\n\n        const newDependency = this.dependencyStore.add({\n            from : source.id,\n            to   : target.id,\n            type,\n            fromSide,\n            toSide\n        });\n\n        return newDependency !== null ? newDependency[0] : null;\n    }\n\n    getTargetSideFromType(type) {\n        if (type === DependencyBaseModel.Type.StartToStart || type === DependencyBaseModel.Type.EndToStart) {\n            return 'start';\n        }\n\n        return 'end';\n    }\n\n    //endregion\n\n    //region Tooltip\n\n    /**\n     * Update dependency creation tooltip\n     * @private\n     */\n    updateCreationTooltip() {\n        const\n            me            = this,\n            data          = me.creationData,\n            { valid }     = data,\n            tip           = me.creationTooltip,\n            { classList } = tip.element;\n\n        // Promise, when using engine\n        if (Objects.isPromise(valid)) {\n            classList.remove('b-invalid');\n            classList.add('b-checking');\n\n            return new Promise(resolve => valid.then(valid => {\n                data.valid = valid;\n\n                if (!tip.isDestroyed) {\n                    resolve(me.updateCreationTooltip());\n                }\n            }));\n        }\n\n        tip.html = me.creationTooltipTemplate(data);\n    }\n\n    creationTooltipTemplate(data) {\n        const\n            me                 = this,\n            { tooltip, valid } = data,\n            { classList }      = tooltip.element;\n\n        Object.assign(data, {\n            fromText : StringHelper.encodeHtml(data.source.name),\n            toText   : StringHelper.encodeHtml(data.target?.name ?? ''),\n            fromSide : data.fromSide,\n            toSide   : data.toSide || ''\n        });\n\n        let tipTitleIconClsSuffix,\n            tipTitleText;\n\n        classList.toggle('b-invalid', !valid);\n        classList.remove('b-checking');\n\n        // Valid\n        if (valid === true) {\n            tipTitleIconClsSuffix = 'valid';\n            tipTitleText          = me.L('L{Dependencies.valid}');\n        }\n        // Invalid\n        else {\n            tipTitleIconClsSuffix = 'invalid';\n            tipTitleText          = me.L('L{Dependencies.invalid}');\n        }\n\n        tooltip.title = `<i class=\"b-icon b-icon-${tipTitleIconClsSuffix}\"></i>${tipTitleText}`;\n\n        return {\n            children : [{\n                className : 'b-sch-dependency-tooltip',\n                children  : [\n                    { dataset : { ref : 'fromLabel' }, tag : 'label', text : me.L('L{Dependencies.from}') },\n                    { dataset : { ref : 'fromText' }, text : data.fromText },\n                    { dataset : { ref : 'fromBox' }, className : `b-sch-box b-${data.fromSide}` },\n                    { dataset : { ref : 'toLabel' }, tag : 'label', text : me.L('L{Dependencies.to}') },\n                    { dataset : { ref : 'toText' }, text : data.toText },\n                    { dataset : { ref : 'toBox' }, className : `b-sch-box b-${data.toSide}` }\n                ]\n            }]\n        };\n    }\n\n    //endregion\n\n    doDisable(disable) {\n        if (!this.isConfiguring) {\n            this.updateCreateListeners();\n        }\n\n        super.doDisable(disable);\n    }\n};\n", "// <remove-on-release>\n// TODO: Consider basing on visible row count\n// </remove-on-release>\nconst ROWS_PER_CELL = 25;\n\n// Mixin that handles the dependency grid cache\n//\n// Grid cache explainer\n// \n// The purpose of the grid cache is to reduce the amount of dependencies we have to iterate over when drawing by\n// partitioning them into a virtual grid. With for example 10k deps we would have to iterate over all 10k on\n// each draw since any of them might be intersecting the view.\n//\n// The cells are horizontally based on ticks (50 per cell) and vertically on rows (also 50 per cell. Each cell\n// lists which dependencies intersect it. When drawing we only have to iterate over the dependencies for the\n// cells that intersect the viewport.\n//\n// The grid cache is populated when dependencies are drawn. Any change to deps, resources, events or assignments\n// clears the cache.\n//\n// The dependency drawn below will be included in the set that is considered for drawing if tickCell 0 or\n// tickCell 1 and rowCell 0 intersects the current view (it is thus represented twice in the grid cache)\n//\n//       tickCell 0           tickCell 1\n//       tick 0-49            tick 50-99\n//    \n// r r0,0                 1,0                  \n// o o                                        \n// w w          !!!!!!!!!!!!!!!!!!!!          \n// C            ! View             !          \n// e 0          ! port             !          \n// l -          !                  !          \n// l 4     !!     \n// 0 9           !                  !          \n//    \n// r r0,1        !        1,1       !          \n// o o           !                  !          \n// w w           !!!!!!!!!!!!!!!!!!!!          \n// C                                           \n// e 5                                         \n// l 0                                         \n// l -                                         \n// 1 9                                         \n//   9\n//               uosn  p\nexport default Target => class DependencyGridCache extends Target {\n    static $name = 'DependencyGridCache';\n\n    gridCache = null;\n\n    // Dependencies that might intersect the current viewport and thus should be considered for drawing\n    getDependenciesToConsider(startMS, endMS, startIndex, endIndex) {\n        const\n            me            = this,\n            { gridCache } = me,\n            { timeAxis }  = me.client;\n\n        if (gridCache) {\n            const\n                dependencies = new Set(),\n                fromMSCell   = Math.floor((startMS - timeAxis.startMS) / me.MS_PER_CELL),\n                toMSCell     = Math.floor((endMS - timeAxis.startMS) / me.MS_PER_CELL),\n                fromRowCell  = Math.floor(startIndex / ROWS_PER_CELL),\n                toRowCell    = Math.floor(endIndex / ROWS_PER_CELL);\n\n            for (let i = fromMSCell; i <= toMSCell; i++) {\n                const msCell = gridCache[i];\n                if (msCell) {\n                    for (let j = fromRowCell; j <= toRowCell; j++) {\n                        const intersectingDependencies = msCell[j];\n                        if (intersectingDependencies) {\n                            for (let i = 0; i < intersectingDependencies.length; i++) {\n                                dependencies.add(intersectingDependencies[i]);\n                            }\n                        }\n                    }\n                }\n            }\n\n            return dependencies;\n        }\n    }\n\n    // A (single) dependency was drawn, we might want to store info about it in the grid cache\n    afterDrawDependency(dependency, fromIndex, toIndex, fromDateMS, toDateMS) {\n        const me = this;\n\n        if (me.constructGridCache) {\n            const\n                { MS_PER_CELL } = me,\n                {\n                    startMS : timeAxisStartMS,\n                    endMS   : timeAxisEndMS\n                }               = me.client.timeAxis,\n                timeAxisCells   = Math.ceil((timeAxisEndMS - timeAxisStartMS) / MS_PER_CELL),\n                fromMSCell      = Math.floor((fromDateMS - timeAxisStartMS) / MS_PER_CELL),\n                toMSCell        = Math.floor((toDateMS - timeAxisStartMS) / MS_PER_CELL),\n                fromRowCell     = Math.floor(fromIndex / ROWS_PER_CELL),\n                toRowCell       = Math.floor(toIndex / ROWS_PER_CELL),\n                firstMSCell     = Math.min(fromMSCell, toMSCell),\n                lastMSCell      = Math.max(fromMSCell, toMSCell),\n                firstRowCell    = Math.min(fromRowCell, toRowCell),\n                lastRowCell     = Math.max(fromRowCell, toRowCell);\n\n            // Ignore dependencies fully outside of the time axis\n            if ((firstMSCell < 0 && lastMSCell < 0) || (firstMSCell > timeAxisCells && lastMSCell > timeAxisCells)) {\n                return;\n            }\n\n            // Cache from time axis start, to time axis end (\"cropping\" deps starting or ending outside)\n            const\n                startMSCell = Math.max(firstMSCell, 0),\n                endMSCell   = Math.min(lastMSCell, timeAxisCells);\n\n            for (let i = startMSCell; i <= endMSCell; i++) {\n                const msCell = me.gridCache[i] ?? (me.gridCache[i] = {});\n                for (let j = firstRowCell; j <= lastRowCell; j++) {\n                    const rowCell = msCell[j] ?? (msCell[j] = []);\n                    rowCell.push(dependency);\n                }\n            }\n        }\n    }\n\n    // All dependencies are about to be drawn, check if we need to build the grid cache\n    beforeDraw() {\n        const me = this;\n\n        if (!me.gridCache) {\n            const { visibleDateRange } = me.client;\n\n            me.constructGridCache = true;\n\n            // Adjust number of ms used in grid cache to match viewport\n            me.MS_PER_CELL = Math.max(visibleDateRange.endMS - visibleDateRange.startMS, 1000);\n\n            // Start with empty cache, will be populated as deps are drawn\n            me.gridCache = {};\n        }\n    }\n\n    // All dependencies are drawn, we no longer need to rebuild the cache\n    afterDraw() {\n        this.constructGridCache = false;\n    }\n\n    reset() {\n        this.gridCache = null;\n    }\n};\n", "import Base from '../../Core/Base.js';\nimport ArrayHelper from '../../Core/helper/ArrayHelper.js';\nimport WalkHelper from '../../Core/helper/WalkHelper.js';\n\n// Start adjusting if there is system scaling > 130%\nconst\n    THRESHOLD      = Math.min(1 / globalThis.devicePixelRatio, 0.75),\n    BOX_PROPERTIES = ['start', 'end', 'top', 'bottom'],\n    equalEnough    = (a, b) => Math.abs(a - b) < 0.1,\n    sideToSide     = {\n        l : 'left',\n        r : 'right',\n        t : 'top',\n        b : 'bottom'\n    };\n\n/**\n * @module Scheduler/util/RectangularPathFinder\n */\n\n/**\n * Class which finds rectangular path, i.e. path with 90 degrees turns, between two boxes.\n * @private\n */\nexport default class RectangularPathFinder extends Base {\n    static get configurable() {\n        return {\n            /**\n             * Default start connection side: 'left', 'right', 'top', 'bottom'\n             * @config {'top'|'bottom'|'left'|'right'}\n             * @default\n             */\n            startSide : 'right',\n\n            // /**\n            //  * Default start arrow size in pixels\n            //  * @config {Number}\n            //  * @default\n            //  */\n            // startArrowSize : 0,\n\n            /**\n             * Default start arrow staff size in pixels\n             * @config {Number}\n             * @default\n             */\n            startArrowMargin : 12,\n\n            /**\n             * Default starting connection point shift from box's arrow pointing side middle point\n             * @config {Number}\n             * @default\n             */\n            startShift : 0,\n\n            /**\n             * Default end arrow pointing direction, possible values are: 'left', 'right', 'top', 'bottom'\n             * @config {'top'|'bottom'|'left'|'right'}\n             * @default\n             */\n            endSide : 'left',\n\n            // /**\n            //  * Default end arrow size in pixels\n            //  * @config {Number}\n            //  * @default\n            //  */\n            // endArrowSize : 0,\n\n            /**\n             * Default end arrow staff size in pixels\n             * @config {Number}\n             * @default\n             */\n            endArrowMargin : 12,\n\n            /**\n             * Default ending connection point shift from box's arrow pointing side middle point\n             * @config {Number}\n             * @default\n             */\n            endShift : 0,\n\n            /**\n             * Start / End box vertical margin, the amount of pixels from top and bottom line of a box where drawing\n             * is prohibited\n             * @config {Number}\n             * @default\n             */\n            verticalMargin : 2,\n\n            /**\n             * Start / End box horizontal margin, the amount of pixels from left and right line of a box where drawing\n             * @config {Number}\n             * @default\n             */\n            horizontalMargin : 5,\n\n            /**\n             * Other rectangular areas (obstacles) to search path through\n             * @config {Object[]}\n             * @default\n             */\n            otherBoxes : null,\n\n            /**\n             * The owning Scheduler. Mandatory so that it can determin RTL state.\n             * @config {Scheduler.view.Scheduler}\n             * @private\n             */\n            client : {}\n        };\n    }\n\n    /**\n     * Returns list of horizontal and vertical segments connecting two boxes\n     * <pre>\n     *    |    | |  |    |       |\n     *  --+----+----+----*-------*---\n     *  --+=>Start  +----*-------*--\n     *  --+----+----+----*-------*--\n     *    |    | |  |    |       |\n     *    |    | |  |    |       |\n     *  --*----*-+-------+-------+--\n     *  --*----*-+         End <=+--\n     *  --*----*-+-------+-------+--\n     *    |    | |  |    |       |\n     * </pre>\n     * Path goes by lines (-=) and turns at intersections (+), boxes depicted are adjusted by horizontal/vertical\n     * margin and arrow margin, original boxes are smaller (path can't go at original box borders). Algorithm finds\n     * the shortest path with minimum amount of turns. In short it's mix of \"Lee\" and \"Dijkstra pathfinding\"\n     * with turns amount taken into account for distance calculation.\n     *\n     * The algorithm is not very performant though, it's O(N^2), where N is amount of\n     * points in the grid, but since the maximum amount of points in the grid might be up to 34 (not 36 since\n     * two box middle points are not permitted) that might be ok for now.\n     *\n     * @param {Object} lineDef An object containing any of the class configuration option overrides as well\n     *                         as `startBox`, `endBox`, `startHorizontalMargin`, `startVerticalMargin`,\n     *                         `endHorizontalMargin`, `endVerticalMargin` properties\n     * @param {Object} lineDef.startBox An object containing `start`, `end`, `top`, `bottom` properties\n     * @param {Object} lineDef.endBox   An object containing `start`, `end`, `top`, `bottom` properties\n     * @param {Number} lineDef.startHorizontalMargin Horizontal margin override for start box\n     * @param {Number} lineDef.startVerticalMargin   Vertical margin override for start box\n     * @param {Number} lineDef.endHorizontalMargin   Horizontal margin override for end box\n     * @param {Number} lineDef.endVerticalMargin     Vertical margin override for end box\n     *\n     *\n     * @returns {Object[]|Boolean} Array of line segments or false if path cannot be found\n     * @returns {Number} return.x1\n     * @returns {Number} return.y1\n     * @returns {Number} return.x2\n     * @returns {Number} return.y2\n     */\n    //\n    //@ignore\n    //@privateparam {Function[]|Function} noPathFallbackFn\n    //     A function or array of functions which will be tried in case a path can't be found\n    //     Each function will be given a line definition it might try to adjust somehow and return.\n    //     The new line definition returned will be tried to find a path.\n    //     If a function returns false, then next function will be called if any.\n    //\n    findPath(lineDef, noPathFallbackFn) {\n        const\n            me              = this,\n            originalLineDef = lineDef;\n\n        let lineDefFull,\n            startBox,\n            endBox,\n            startShift,\n            endShift,\n            startSide,\n            endSide,\n            // startArrowSize,\n            // endArrowSize,\n            startArrowMargin,\n            endArrowMargin,\n            horizontalMargin,\n            verticalMargin,\n            startHorizontalMargin,\n            startVerticalMargin,\n            endHorizontalMargin,\n            endVerticalMargin,\n            otherHorizontalMargin,\n            otherVerticalMargin,\n            otherBoxes,\n\n            connStartPoint, connEndPoint,\n            pathStartPoint, pathEndPoint,\n            gridStartPoint, gridEndPoint,\n            startGridBox, endGridBox,\n            grid, path, tryNum;\n\n        noPathFallbackFn = ArrayHelper.asArray(noPathFallbackFn);\n\n        for (tryNum = 0; lineDef && !path;) {\n            lineDefFull = Object.assign(me.config, lineDef);\n\n            startBox              = lineDefFull.startBox;\n            endBox                = lineDefFull.endBox;\n            startShift            = lineDefFull.startShift;\n            endShift              = lineDefFull.endShift;\n            startSide             = lineDefFull.startSide;\n            endSide               = lineDefFull.endSide;\n            // startArrowSize        = lineDefFull.startArrowSize;\n            // endArrowSize          = lineDefFull.endArrowSize;\n            startArrowMargin      = lineDefFull.startArrowMargin;\n            endArrowMargin        = lineDefFull.endArrowMargin;\n            horizontalMargin      = lineDefFull.horizontalMargin;\n            verticalMargin        = lineDefFull.verticalMargin;\n            startHorizontalMargin = lineDefFull.hasOwnProperty('startHorizontalMargin') ? lineDefFull.startHorizontalMargin : horizontalMargin;\n            startVerticalMargin   = lineDefFull.hasOwnProperty('startVerticalMargin') ? lineDefFull.startVerticalMargin : verticalMargin;\n            endHorizontalMargin   = lineDefFull.hasOwnProperty('endHorizontalMargin') ? lineDefFull.endHorizontalMargin : horizontalMargin;\n            endVerticalMargin     = lineDefFull.hasOwnProperty('endVerticalMargin') ? lineDefFull.endVerticalMargin : verticalMargin;\n            otherHorizontalMargin = lineDefFull.hasOwnProperty('otherHorizontalMargin') ? lineDefFull.otherHorizontalMargin : horizontalMargin;\n            otherVerticalMargin   = lineDefFull.hasOwnProperty('otherVerticalMargin') ? lineDefFull.otherVerticalMargin : verticalMargin;\n            otherBoxes            = lineDefFull.otherBoxes;\n\n            startSide = me.normalizeSide(startSide);\n            endSide   = me.normalizeSide(endSide);\n\n            connStartPoint = me.getConnectionCoordinatesFromBoxSideShift(startBox, startSide, startShift);\n            connEndPoint   = me.getConnectionCoordinatesFromBoxSideShift(endBox, endSide, endShift);\n\n            startGridBox   = me.calcGridBaseBoxFromBoxAndDrawParams(startBox, startSide/*, startArrowSize*/, startArrowMargin, startHorizontalMargin, startVerticalMargin);\n            endGridBox     = me.calcGridBaseBoxFromBoxAndDrawParams(endBox, endSide/*, endArrowSize*/, endArrowMargin, endHorizontalMargin, endVerticalMargin);\n\n            // Iterate over points and merge those which are too close to each other (e.g. if difference is less than one\n            // over devicePixelRatio we won't even see this effect in GUI)\n            // https://github.com/bryntum/support/issues/3923\n            BOX_PROPERTIES.forEach(property => {\n                // We're talking subpixel precision here, so it doesn't really matter which value we choose\n                if (Math.abs(startGridBox[property] - endGridBox[property]) <= THRESHOLD) {\n                    endGridBox[property] = startGridBox[property];\n                }\n            });\n\n            if (me.shouldLookForPath(startBox, endBox, startGridBox, endGridBox)) {\n                otherBoxes     = otherBoxes?.map(box =>\n                    me.calcGridBaseBoxFromBoxAndDrawParams(box, false/*, 0*/, 0, otherHorizontalMargin, otherVerticalMargin)\n                );\n                pathStartPoint = me.getConnectionCoordinatesFromBoxSideShift(startGridBox, startSide, startShift);\n                pathEndPoint   = me.getConnectionCoordinatesFromBoxSideShift(endGridBox, endSide, endShift);\n                grid           = me.buildPathGrid(startGridBox, endGridBox, pathStartPoint, pathEndPoint, startSide, endSide, otherBoxes);\n                gridStartPoint = me.convertDecartPointToGridPoint(grid, pathStartPoint);\n                gridEndPoint   = me.convertDecartPointToGridPoint(grid, pathEndPoint);\n                path           = me.findPathOnGrid(grid, gridStartPoint, gridEndPoint, startSide, endSide);\n            }\n\n            //<debug>\n            // drawPathGrid(grid, lineDef.startBox, lineDef.endBox, startGridBox, endGridBox, otherBoxes, 4);\n            //</debug>\n\n            // Loop if\n            // - path is still not found\n            // - have no next line definition (which should be obtained from call to one of the functions from noPathFallbackFn array\n            // - have noPathFallBackFn array\n            // - current try number is less then noPathFallBackFn array length\n            for (lineDef = false; !path && !lineDef && noPathFallbackFn && tryNum < noPathFallbackFn.length; tryNum++) {\n                lineDef = (noPathFallbackFn[tryNum])(lineDefFull, originalLineDef);\n            }\n        }\n\n        if (path) {\n            path = me.prependPathWithArrowStaffSegment(path, connStartPoint/*, startArrowSize*/, startSide);\n            path = me.appendPathWithArrowStaffSegment(path, connEndPoint/*, endArrowSize*/, endSide);\n            path = me.optimizePath(path);\n        }\n\n        return path;\n    }\n\n    // Compares boxes relative position in the given direction.\n    //  0 - 1 is to the left/top of 2\n    //  1 - 1 overlaps with left/top edge of 2\n    //  2 - 1 is inside 2\n    // -2 - 2 is inside 1\n    //  3 - 1 overlaps with right/bottom edge of 2\n    //  4 - 1 is to the right/bottom of 2\n    static calculateRelativePosition(box1, box2, vertical = false) {\n        const\n            startProp = vertical ? 'top' : 'start',\n            endProp   = vertical ? 'bottom' : 'end';\n\n        let result;\n\n        if (box1[endProp] < box2[startProp]) {\n            result = 0;\n        }\n        else if (box1[endProp] <= box2[endProp] && box1[endProp] >= box2[startProp] && box1[startProp] < box2[startProp]) {\n            result = 1;\n        }\n        else if (box1[startProp] >= box2[startProp] && box1[endProp] <= box2[endProp]) {\n            result = 2;\n        }\n        else if (box1[startProp] < box2[startProp] && box1[endProp] > box2[endProp]) {\n            result = -2;\n        }\n        else if (box1[startProp] <= box2[endProp] && box1[endProp] > box2[endProp]) {\n            result = 3;\n        }\n        else {\n            result = 4;\n        }\n\n        return result;\n    }\n\n    // Checks if relative position of the original and marginized boxes is the same\n    static boxOverlapChanged(startBox, endBox, gridStartBox, gridEndBox, vertical = false) {\n        const\n            calculateOverlap = RectangularPathFinder.calculateRelativePosition,\n            originalOverlap  = calculateOverlap(startBox, endBox, vertical),\n            finalOverlap     = calculateOverlap(gridStartBox, gridEndBox, vertical);\n\n        return originalOverlap !== finalOverlap;\n    }\n\n    shouldLookForPath(startBox, endBox, gridStartBox, gridEndBox) {\n        let result = true;\n\n        // Only calculate overlap if boxes are narrow in horizontal direction\n        if (\n            // We refer to the original arrow margins because during lookup those might be nullified and we need some\n            // criteria to tell if events are too narrow\n            (startBox.end - startBox.start <= this.startArrowMargin || endBox.end - endBox.start <= this.endArrowMargin) &&\n            Math.abs(RectangularPathFinder.calculateRelativePosition(startBox, endBox, true)) === 2\n        ) {\n            result = !RectangularPathFinder.boxOverlapChanged(startBox, endBox, gridStartBox, gridEndBox);\n        }\n\n        return result;\n    }\n\n    getConnectionCoordinatesFromBoxSideShift(box, side, shift) {\n        let coords;\n\n        // Note that we deal with screen geometry here, not logical dependency sides\n        // Possible 'start' and 'end' have been resolved to box sides.\n        switch (side) {\n            case 'left':\n                coords = {\n                    x : box.start,\n                    y : (box.top + box.bottom) / 2 + shift\n                };\n                break;\n            case 'right':\n                coords = {\n                    x : box.end,\n                    y : (box.top + box.bottom) / 2 + shift\n                };\n                break;\n            case 'top':\n                coords = {\n                    x : (box.start + box.end) / 2 + shift,\n                    y : box.top\n                };\n                break;\n            case 'bottom':\n                coords = {\n                    x : (box.start + box.end) / 2 + shift,\n                    y : box.bottom\n                };\n                break;\n        }\n\n        return coords;\n    }\n\n    calcGridBaseBoxFromBoxAndDrawParams(box, side/*, arrowSize*/, arrowMargin, horizontalMargin, verticalMargin) {\n        let gridBox;\n\n        switch (this.normalizeSide(side)) {\n            case 'left':\n                gridBox = {\n                    start  : box.start - Math.max(/*arrowSize + */arrowMargin, horizontalMargin),\n                    end    : box.end + horizontalMargin,\n                    top    : box.top - verticalMargin,\n                    bottom : box.bottom + verticalMargin\n                };\n                break;\n            case 'right':\n                gridBox = {\n                    start  : box.start - horizontalMargin,\n                    end    : box.end + Math.max(/*arrowSize + */arrowMargin, horizontalMargin),\n                    top    : box.top - verticalMargin,\n                    bottom : box.bottom + verticalMargin\n                };\n                break;\n            case 'top':\n                gridBox = {\n                    start  : box.start - horizontalMargin,\n                    end    : box.end + horizontalMargin,\n                    top    : box.top - Math.max(/*arrowSize + */arrowMargin, verticalMargin),\n                    bottom : box.bottom + verticalMargin\n                };\n                break;\n            case 'bottom':\n                gridBox = {\n                    start  : box.start - horizontalMargin,\n                    end    : box.end + horizontalMargin,\n                    top    : box.top - verticalMargin,\n                    bottom : box.bottom + Math.max(/*arrowSize + */arrowMargin, verticalMargin)\n                };\n                break;\n            default:\n                gridBox = {\n                    start  : box.start - horizontalMargin,\n                    end    : box.end + horizontalMargin,\n                    top    : box.top - verticalMargin,\n                    bottom : box.bottom + verticalMargin\n                };\n        }\n\n        return gridBox;\n    }\n\n    normalizeSide(side) {\n        const { rtl } = this.client;\n\n        side => sideToSide[side] || side;\n\n        if (side === 'start') {\n            return rtl ? 'right' : 'left';\n        }\n        if (side === 'end') {\n            return rtl ? 'left' : 'right';\n        }\n        return side;\n    }\n\n    buildPathGrid(startGridBox, endGridBox, pathStartPoint, pathEndPoint, startSide, endSide, otherGridBoxes) {\n        let xs, ys,\n            y, x, ix, iy, xslen, yslen, ib, blen, box, permitted, point;\n\n        const\n            points       = {},\n            linearPoints = [];\n\n        xs = [\n            startGridBox.start,\n            (startSide === 'left' || startSide === 'right') ? (startGridBox.start + startGridBox.end) / 2 : pathStartPoint.x,\n            startGridBox.end,\n            endGridBox.start,\n            (endSide === 'left' || endSide === 'right') ? (endGridBox.start + endGridBox.end) / 2 : pathEndPoint.x,\n            endGridBox.end\n        ];\n        ys = [\n            startGridBox.top,\n            (startSide === 'top' || startSide === 'bottom') ? (startGridBox.top + startGridBox.bottom) / 2 : pathStartPoint.y,\n            startGridBox.bottom,\n            endGridBox.top,\n            (endSide === 'top' || endSide === 'bottom') ? (endGridBox.top + endGridBox.bottom) / 2 : pathEndPoint.y,\n            endGridBox.bottom\n        ];\n\n        if (otherGridBoxes) {\n            otherGridBoxes.forEach(box => {\n                xs.push(box.start, (box.start + box.end) / 2, box.end);\n                ys.push(box.top, (box.top + box.bottom) / 2, box.bottom);\n            });\n        }\n\n        xs = [...new Set(xs.sort((a, b) => a - b))];\n        ys = [...new Set(ys.sort((a, b) => a - b))];\n\n        // <remove-on-release>\n        // TODO: fastest way to make unique, Set is slower\n        // for ( let i = 0, I = array.length; i < I; i++ ) {\n        //     if ( ~array.indexOf( array[ i ], i + 1 ) ) {\n        //         array.splice( i, 1 );\n        //         i--;\n        //         I--;\n        //     }\n        // }\n        // </remove-on-release>\n\n        for (iy = 0, yslen = ys.length; iy < yslen; ++iy) {\n            points[iy] = points[iy] || {};\n            y          = ys[iy];\n            for (ix = 0, xslen = xs.length; ix < xslen; ++ix) {\n                x = xs[ix];\n\n                permitted = (\n                    (x <= startGridBox.start || x >= startGridBox.end || y <= startGridBox.top || y >= startGridBox.bottom) &&\n                    (x <= endGridBox.start || x >= endGridBox.end || y <= endGridBox.top || y >= endGridBox.bottom)\n                );\n\n                if (otherGridBoxes) {\n                    for (ib = 0, blen = otherGridBoxes.length; permitted && ib < blen; ++ib) {\n                        box       = otherGridBoxes[ib];\n                        permitted = (x <= box.start || x >= box.end || y <= box.top || y >= box.bottom) ||\n                            // Allow point if it is a path start/end even if point is inside any box\n                            (x === pathStartPoint.x && y === pathStartPoint.y) ||\n                            (x === pathEndPoint.x && y === pathEndPoint.y);\n                    }\n                }\n\n                point = {\n                    distance : Number.MAX_SAFE_INTEGER,\n                    permitted,\n                    x,\n                    y,\n                    ix,\n                    iy\n                };\n\n                points[iy][ix] = point;\n                linearPoints.push(point);\n            }\n        }\n\n        return {\n            width  : xs.length,\n            height : ys.length,\n            xs,\n            ys,\n            points,\n            linearPoints\n        };\n    }\n\n    convertDecartPointToGridPoint(grid, point) {\n        const\n            x = grid.xs.indexOf(point.x),\n            y = grid.ys.indexOf(point.y);\n\n        return grid.points[y][x];\n    }\n\n    findPathOnGrid(grid, gridStartPoint, gridEndPoint, startSide, endSide) {\n        const me = this;\n\n        let path = false;\n\n        if (gridStartPoint.permitted && gridEndPoint.permitted) {\n            grid = me.waveForward(grid, gridStartPoint, 0);\n            path = me.collectPath(grid, gridEndPoint, endSide);\n        }\n\n        return path;\n    }\n\n    // Returns neighbors from Von Neiman ambit (see Lee pathfinding algorithm description)\n    getGridPointNeighbors(grid, gridPoint, predicateFn) {\n        const\n            ix     = gridPoint.ix,\n            iy     = gridPoint.iy,\n            result = [];\n\n        let neighbor;\n\n        // NOTE:\n        // It's important to push bottom neighbors first since this method is used\n        // in collectPath(), which recursively collects path from end to start node\n        // and if bottom neighbors are pushed first in result array then collectPath()\n        // will produce a line which is more suitable (pleasant looking) for our purposes.\n        if (iy < grid.height - 1) {\n            neighbor = grid.points[iy + 1][ix];\n            (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);\n        }\n        if (iy > 0) {\n            neighbor = grid.points[iy - 1][ix];\n            (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);\n        }\n        if (ix < grid.width - 1) {\n            neighbor = grid.points[iy][ix + 1];\n            (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);\n        }\n        if (ix > 0) {\n            neighbor = grid.points[iy][ix - 1];\n            (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);\n        }\n\n        return result;\n    }\n\n    waveForward(grid, gridStartPoint, distance) {\n        const me = this;\n\n        // I use the WalkHelper here because a point on a grid and it's neighbors might be considered as a hierarchy.\n        // The point is the parent node, and it's neighbors are the children nodes. Thus the grid here is hierarchical\n        // data structure which can be walked. WalkHelper walks non-recursively which is exactly what I need as well.\n        WalkHelper.preWalkUnordered(\n            // Walk starting point - a node is a grid point and it's distance from the starting point\n            [gridStartPoint, distance],\n            // Children query function\n            // NOTE: It's important to fix neighbor distance first, before waving to a neighbor, otherwise waving might\n            //       get through a neighbor point setting it's distance to a value more than (distance + 1) whereas we,\n            //       at the children querying moment in time, already know that the possibly optimal distance is (distance + 1)\n            ([point, distance]) => me.getGridPointNeighbors(\n                grid,\n                point,\n                neighborPoint => neighborPoint.permitted && (neighborPoint.distance > distance + 1)\n            ).map(\n                neighborPoint => [neighborPoint, distance + 1] // Neighbor distance fixation\n            ),\n            // Walk step iterator function\n            ([point, distance]) => point.distance = distance // Neighbor distance applying\n        );\n\n        return grid;\n    }\n\n    collectPath(grid, gridEndPoint, endSide) {\n        const\n            me   = this,\n            path = [];\n\n        let pathFound = true,\n            neighbors,\n            lowestDistanceNeighbor,\n            xDiff, yDiff;\n\n        while (pathFound && gridEndPoint.distance) {\n            neighbors = me.getGridPointNeighbors(grid, gridEndPoint, point =>\n                point.permitted && (point.distance === gridEndPoint.distance - 1)\n            );\n\n            pathFound = neighbors.length > 0;\n\n            if (pathFound) {\n                // Prefer turnless neighbors first\n                neighbors = neighbors.sort((a, b) => {\n                    let xDiff, yDiff;\n\n                    xDiff = a.ix - gridEndPoint.ix;\n                    yDiff = a.iy - gridEndPoint.iy;\n\n                    const resultA = (\n                        ((endSide === 'left' || endSide === 'right') && yDiff === 0) ||\n                        ((endSide === 'top' || endSide === 'bottom') && xDiff === 0)\n                    ) ? -1 : 1;\n\n                    xDiff = b.ix - gridEndPoint.ix;\n                    yDiff = b.iy - gridEndPoint.iy;\n\n                    const resultB = (\n                        ((endSide === 'left' || endSide === 'right') && yDiff === 0) ||\n                        ((endSide === 'top' || endSide === 'bottom') && xDiff === 0)\n                    ) ? -1 : 1;\n\n                    if (resultA > resultB) return 1;\n                    if (resultA < resultB) return -1;\n                    // apply additional sorting to be sure to pick bottom path in IE\n                    if (resultA === resultB) return a.y > b.y ? -1 : 1;\n                });\n\n                lowestDistanceNeighbor = neighbors[0];\n\n                path.push({\n                    x1 : lowestDistanceNeighbor.x,\n                    y1 : lowestDistanceNeighbor.y,\n                    x2 : gridEndPoint.x,\n                    y2 : gridEndPoint.y\n                });\n\n                // Detecting new side, either xDiff or yDiff must be 0 (but not both)\n                xDiff = lowestDistanceNeighbor.ix - gridEndPoint.ix;\n                yDiff = lowestDistanceNeighbor.iy - gridEndPoint.iy;\n\n                switch (true) {\n                    case !yDiff && xDiff > 0:\n                        endSide = 'left';\n                        break;\n                    case !yDiff && xDiff < 0:\n                        endSide = 'right';\n                        break;\n                    case !xDiff && yDiff > 0:\n                        endSide = 'top';\n                        break;\n                    case !xDiff && yDiff < 0:\n                        endSide = 'bottom';\n                        break;\n                }\n\n                gridEndPoint = lowestDistanceNeighbor;\n            }\n        }\n\n        return pathFound && path.reverse() || false;\n    }\n\n    prependPathWithArrowStaffSegment(path, connStartPoint/*, startArrowSize*/, startSide) {\n        if (path.length > 0) {\n            const\n                firstSegment   = path[0],\n                prependSegment = {\n                    x2 : firstSegment.x1,\n                    y2 : firstSegment.y1\n                };\n\n            switch (startSide) {\n                case 'left':\n                    prependSegment.x1 = connStartPoint.x/* - startArrowSize*/;\n                    prependSegment.y1 = firstSegment.y1;\n                    break;\n                case 'right':\n                    prependSegment.x1 = connStartPoint.x/* + startArrowSize*/;\n                    prependSegment.y1 = firstSegment.y1;\n                    break;\n                case 'top':\n                    prependSegment.x1 = firstSegment.x1;\n                    prependSegment.y1 = connStartPoint.y/* - startArrowSize*/;\n                    break;\n                case 'bottom':\n                    prependSegment.x1 = firstSegment.x1;\n                    prependSegment.y1 = connStartPoint.y/* + startArrowSize*/;\n                    break;\n            }\n\n            path.unshift(prependSegment);\n        }\n\n        return path;\n    }\n\n    appendPathWithArrowStaffSegment(path, connEndPoint/*, endArrowSize*/, endSide) {\n        if (path.length > 0) {\n            const\n                lastSegment   = path[path.length - 1],\n                appendSegment = {\n                    x1 : lastSegment.x2,\n                    y1 : lastSegment.y2\n                };\n\n            switch (endSide) {\n                case 'left':\n                    appendSegment.x2 = connEndPoint.x/* - endArrowSize*/;\n                    appendSegment.y2 = lastSegment.y2;\n                    break;\n                case 'right':\n                    appendSegment.x2 = connEndPoint.x/* + endArrowSize*/;\n                    appendSegment.y2 = lastSegment.y2;\n                    break;\n                case 'top':\n                    appendSegment.x2 = lastSegment.x2;\n                    appendSegment.y2 = connEndPoint.y/* - endArrowSize*/;\n                    break;\n                case 'bottom':\n                    appendSegment.x2 = lastSegment.x2;\n                    appendSegment.y2 = connEndPoint.y/* + endArrowSize*/;\n                    break;\n            }\n\n            path.push(appendSegment);\n        }\n\n        return path;\n    }\n\n    optimizePath(path) {\n        const optPath = [];\n\n        let prevSegment,\n            curSegment;\n\n        if (path.length > 0) {\n            prevSegment = path.shift();\n            optPath.push(prevSegment);\n\n            while (path.length > 0) {\n                curSegment = path.shift();\n                // both segments are as good as equal\n                if (\n                    equalEnough(prevSegment.x1, curSegment.x1) && equalEnough(prevSegment.y1, curSegment.y1) &&\n                    equalEnough(prevSegment.x2, curSegment.x2) && equalEnough(prevSegment.y2, curSegment.y2)\n                ) {\n                    prevSegment = curSegment;\n                }\n                // both segments are horizontal or very nearly so\n                else if (equalEnough(prevSegment.y1, prevSegment.y2) && equalEnough(curSegment.y1, curSegment.y2)) {\n                    prevSegment.x2 = curSegment.x2;\n                }\n                // both segments are vertical or very nearly so\n                else if (equalEnough(prevSegment.x1, prevSegment.x2) && equalEnough(curSegment.x1, curSegment.x2)) {\n                    prevSegment.y2 = curSegment.y2;\n                }\n                // segments have different orientation (path turn)\n                else {\n                    optPath.push(curSegment);\n                    prevSegment = curSegment;\n                }\n            }\n        }\n\n        return optPath;\n    }\n}\n\n//<debug>\nfunction createBox(startBox, deltaX, deltaY, scale, stroke) {\n    const points = [\n        [startBox.start * scale - deltaX, startBox.top * scale - deltaY],\n        [startBox.start * scale - deltaX, startBox.bottom * scale - deltaY],\n        [startBox.end * scale - deltaX, startBox.bottom * scale - deltaY],\n        [startBox.end * scale - deltaX, startBox.top * scale - deltaY],\n        [startBox.start * scale - deltaX, startBox.top * scale - deltaY]\n    ].map(pair => `${pair[0]},${pair[1]}`).join(' ');\n\n    return `<polyline points=\"${points}\" style=\"stroke:${stroke || 'blue'};stroke-width:4;\"/>`;\n}\n// eslint-disable-next-line no-unused-vars\nfunction drawPathGrid(grid, sourceBox, targetBox, sourceRegion, targetRegion, otherBoxes, scale = 4) {\n    const\n        rowHeight       = 61,\n        xs              = grid.xs.map(x => x * scale),\n        ys              = grid.ys.map(y => y * scale),\n        xsLength        = xs.length,\n        ysLength        = ys.length,\n        verticalLines   = xs.map(x => `<line style=\"stroke:black\" x1=\"${x - xs[0]}\" x2=\"${x - xs[0]}\"\" y1=\"0\" y2=\"${ys[ysLength - 1] - ys[0]}\"/>`),\n        horizontalLines = ys.map(y => `<line style=\"stroke:black\" x1=\"0\" x2=\"${xs[xsLength - 1] - xs[0]}\"\" y1=\"${y - ys[0]}\" y2=\"${y - ys[0]}\" style=\"${y / scale === rowHeight ? 'stroke:red' : ''}\"/>`),\n        extraLines      = [];\n\n    sourceRegion && extraLines.push(createBox(sourceRegion, xs[0], ys[0], scale, 'green'));\n    targetRegion && extraLines.push(createBox(targetRegion, xs[0], ys[0], scale, 'green'));\n    sourceBox && extraLines.push(createBox(sourceBox, xs[0], ys[0], scale));\n    targetBox && extraLines.push(createBox(targetBox, xs[0], ys[0], scale));\n\n    (otherBoxes || []).forEach(box => extraLines.push(createBox(box, xs[0], ys[0], scale, 'red')));\n\n    console.log(`<svg width=\"${xs[xsLength - 1] - xs[0]}\" height=\"${ys[ysLength - 1] - ys[0]}\">${\n        verticalLines.concat(horizontalLines, extraLines).join('')}</svg>`);\n}\n//</debug>\n", "import DependencyModel from '../../model/DependencyModel.js';\nimport RectangularPathFinder from '../../util/RectangularPathFinder.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\n\n// <remove-on-release>\n// TODO: Tests\n// </remove-on-release>\n\n// Determine a line segments drawing direction\nfunction drawingDirection(pointSet) {\n    if (pointSet.x1 === pointSet.x2) {\n        return pointSet.y2 > pointSet.y1 ? 'd' : 'u';\n    }\n\n    return pointSet.x2 > pointSet.x1 ? 'r' : 'l';\n}\n\n// Determine a line segments length\nfunction segmentLength(pointSet) {\n    return pointSet.x1 === pointSet.x2 ? pointSet.y2 - pointSet.y1 : pointSet.x2 - pointSet.x1;\n}\n\n// Define an arc to tie two line segments together\nfunction arc(pointSet, nextPointSet, radius) {\n    const\n        corner  = drawingDirection(pointSet) + drawingDirection(nextPointSet),\n        // Flip x if this or next segment is drawn right to left\n        rx      = radius * (corner.includes('l') ? -1 : 1),\n        // Flip y if this or next segment is drawn bottom to top\n        ry      = radius * (corner.includes('u') ? -1 : 1),\n        // Positive (0) or negative (1) angle\n        sweep   = corner === 'ur' || corner === 'lu' || corner === 'dl' || corner === 'rd' ? 1 : 0;\n\n    return `a${rx},${ry} 0 0 ${sweep} ${rx},${ry}`;\n}\n\n// Define a line for a set of points, tying it together with the next set with an arc when applicable\nfunction line(pointSet, nextPointSet, location, radius, prevRadius) {\n\n    // Horizontal or vertical line\n    let line      = pointSet.x1 === pointSet.x2 ? 'v' : 'h',\n        useRadius = radius;\n\n    // Add an arc?\n    if (radius) {\n        const\n            // Length of this line segment\n            length     = segmentLength(pointSet),\n            // Length of the next one. Both are needed to determine max radius (half of the shortest delta)\n            nextLength = nextPointSet ? Math.abs(segmentLength(nextPointSet)) : Number.MAX_SAFE_INTEGER,\n            // Line direction\n            sign       = Math.sign(length);\n\n        // If we are not passed a radius from the previous line drawn, we use the configured radius. It is used to shorten\n        // this lines length to fit the arc that connects it to the previous line\n        if (prevRadius == null) {\n            prevRadius = radius;\n        }\n\n        // We cannot use a radius larger than half our or our successor's length, doing so would make the segment too long\n        // when the arc is created\n        if (Math.abs(length) < radius * 2 || nextLength < radius * 2) {\n            useRadius = Math.min(Math.abs(length), nextLength) / 2;\n        }\n\n        const\n            // Radius of neighbouring arcs, subtracted from length below...\n            subtract  = location === 'single' ? 0 : location === 'first' ? useRadius : location === 'between' ? prevRadius + useRadius : /*last*/ prevRadius,\n            // ...to produce the length of the line segment to draw\n            useLength = length - subtract * sign;\n\n        // Apply line segment length, unless it passed over 0 in which case we stick to 0\n        line += Math.sign(useLength) !== sign ? 0 : useLength;\n\n        // Add an arc if applicable\n        if (location !== 'last' && location !== 'single' && useRadius > 0) {\n            line += ` ${arc(pointSet, nextPointSet, useRadius)}`;\n        }\n    }\n    // Otherwise take a shorter code path\n    else {\n        line += segmentLength(pointSet);\n    }\n\n    return {\n        line,\n        currentRadius : radius !== useRadius ? useRadius : null\n    };\n}\n\n// Define an SVG path base on points from the path finder.\n// Each segment in the path can be joined by an arc\nfunction pathMapper(radius, points) {\n    const { length } = points;\n\n    if (!length) {\n        return '';\n    }\n\n    let currentRadius = null;\n\n    return `M${points[0].x1},${points[0].y1} ${points.map((pointSet, i) => {\n        // Segment placement among all segments, used to determine if an arc should be added\n        const\n            location =\n                  length === 1 ? 'single'\n                      : i === length - 1 ? 'last'\n                          : i === 0 ? 'first'\n                              : 'between',\n            lineSpec = line(pointSet, points[i + 1], location, radius, currentRadius);\n\n        ({ currentRadius } = lineSpec);\n\n        return lineSpec.line;\n    }).join(' ')}`;\n}\n\n// Mixin that holds the code needed to generate DomConfigs for dependency lines\nexport default Target => class DependencyLineGenerator extends Target {\n    static $name = 'DependencyLineGenerator';\n\n    lineCache = {};\n\n    onSVGReady() {\n        // <remove-on-release>\n        // TODO: Get rid of pathFinderConfig?? Move to configurable\n        // </remove-on-release>\n        const me = this;\n\n        me.pathFinder = new RectangularPathFinder({\n            ...me.pathFinderConfig,\n            client : me.client\n        });\n        me.lineDefAdjusters = me.createLineDefAdjusters();\n\n        me.createMarker();\n    }\n\n    changeRadius(radius) {\n        if (radius !== null) {\n            ObjectHelper.assertNumber(radius, 'radius');\n        }\n\n        return radius;\n    }\n\n    updateRadius() {\n        if (!this.isConfiguring) {\n            this.reset();\n        }\n    }\n\n    updateRenderer() {\n        if (!this.isConfiguring) {\n            this.reset();\n        }\n    }\n\n    changeClickWidth(width) {\n        if (width !== null) {\n            ObjectHelper.assertNumber(width, 'clickWidth');\n        }\n\n        return width;\n    }\n\n    updateClickWidth() {\n        if (!this.isConfiguring) {\n            this.reset();\n        }\n    }\n\n    //region Marker\n\n    createMarker() {\n        const\n            me            = this,\n            { markerDef } = me,\n            svg           = this.client.svgCanvas,\n            // SVG markers has to use an id, we want the id to be per scheduler when using multiple\n            markerId      = markerDef ? `${me.client.id}-arrowEnd` : 'arrowEnd';\n\n        me.marker?.remove();\n\n        svg.style.setProperty('--scheduler-dependency-marker', `url(#${markerId})`);\n\n        me.marker = DomHelper.createElement({\n            parent        : svg,\n            id            : markerId, // no-sanity\n            tag           : 'marker',\n            className     : 'b-sch-dependency-arrow',\n            ns            : 'http://www.w3.org/2000/svg',\n            markerHeight  : 11,\n            markerWidth   : 11,\n            refX          : 8.5,\n            refY          : 3,\n            viewBox       : '0 0 9 6',\n            orient        : 'auto-start-reverse',\n            markerUnits   : 'userSpaceOnUse',\n            retainElement : true,\n            children      : [{\n                tag : 'path',\n                ns  : 'http://www.w3.org/2000/svg',\n                d   : me.markerDef ?? 'M3,0 L3,6 L9,3 z'\n            }]\n        });\n    }\n\n    updateMarkerDef() {\n        if (!this.isConfiguring) {\n            this.createMarker();\n        }\n    }\n\n    //endregion\n\n    //region DomConfig\n\n    getAssignmentElement(assignment) {\n        // If we are dragging an event, we need to use the proxy element\n        // (which is not the original element if we are not constrained to timeline)\n        const proxyElement = this.client.features.eventDrag?.getProxyElement?.(assignment);\n\n        return proxyElement || this.client.getElementFromAssignmentRecord(assignment);\n    }\n\n    // Generate a DomConfig for a dependency line between two assignments (tasks in Gantt)\n    getDomConfigs(dependency, fromAssignment, toAssignment, forceBoxes) {\n        const\n            me     = this,\n            key    = me.getDependencyKey(dependency, fromAssignment, toAssignment),\n            // Under certain circumstances (scrolling) we might be able to reuse the previous DomConfig.\n            cached = me.lineCache[key];\n\n        // Create line def if not cached, or we are live drawing and have event elements (dragging, transitioning etc)\n        if (me.constructLineCache || !cached || forceBoxes || (me.drawingLive && (me.getAssignmentElement(fromAssignment) || me.getAssignmentElement(toAssignment)))) {\n            const\n                lineDef     = me.prepareLineDef(dependency, fromAssignment, toAssignment, forceBoxes),\n                points      = lineDef && me.pathFinder.findPath(lineDef, me.lineDefAdjusters),\n                {\n                    client,\n                    clickWidth\n                }           = me,\n                { toEvent } = dependency;\n\n            if (points) {\n                const\n                    highlighted = me.highlighted.get(dependency),\n                    domConfig   = {\n                        tag     : 'path',\n                        ns      : 'http://www.w3.org/2000/svg',\n                        d       : pathMapper(me.radius ?? 0, points),\n                        role    : 'presentation',\n                        dataset : {\n                            syncId : key,\n                            depId  : dependency.id,\n                            fromId : fromAssignment.id,\n                            toId   : toAssignment.id\n                        },\n                        elementData : {\n                            dependency,\n                            points\n                        },\n                        class : {\n                            [me.baseCls]                                : 1,\n                            [dependency.cls]                            : dependency.cls,\n                            // Data highlight\n                            [dependency.highlighted]                    : dependency.highlighted,\n                            // Feature highlight\n                            [highlighted && [...highlighted].join(' ')] : highlighted,\n                            [me.noMarkerCls]                            : lineDef.hideMarker,\n                            'b-inactive'                                : dependency.active === false,\n                            'b-sch-bidirectional-line'                  : dependency.bidirectional,\n                            'b-readonly'                                : dependency.readOnly,\n                            // If target event is outside the view add special CSS class to hide marker (arrow)\n                            'b-sch-dependency-ends-outside' :\n                                (!toEvent.milestone && (toEvent.endDate <= client.startDate || client.endDate <= toEvent.startDate)) ||\n                                (toEvent.milestone && (toEvent.endDate < client.startDate || client.endDate < toEvent.startDate))\n                        }\n                    };\n\n                me.renderer?.({\n                    domConfig,\n                    points,\n                    dependencyRecord     : dependency,\n                    fromAssignmentRecord : fromAssignment,\n                    toAssignmentRecord   : toAssignment,\n                    fromBox              : lineDef.startBox,\n                    toBox                : lineDef.endBox,\n                    fromSide             : lineDef.startSide,\n                    toSide               : lineDef.endSide\n                });\n\n                const configs = [domConfig];\n\n                if (clickWidth > 1) {\n                    configs.push({\n                        ...domConfig, // Shallow on purpose, to not waste perf cloning deeply\n                        class : {\n                            ...domConfig.class,\n                            'b-click-area' : 1\n                        },\n                        dataset : {\n                            ...domConfig.dataset,\n                            syncId : `${domConfig.dataset.syncId}-click-area`\n                        },\n                        style : {\n                            strokeWidth : clickWidth\n                        }\n                    });\n                }\n\n                return me.lineCache[key] = configs;\n            }\n\n            // Nothing to draw or cache\n            return me.lineCache[key] = null;\n        }\n\n        return cached;\n    }\n\n    //endregion\n\n    //region Bounds\n\n    // Generates `otherBoxes` config for rectangular path finder, which push dependency line to the row boundary.\n    // It should be enough to return single box with top/bottom taken from row top/bottom and left/right taken from source\n    // box, extended by start arrow margin to both sides.\n    generateBoundaryBoxes(box, side) {\n        // We need two boxes for the bottom edge, because otherwise path cannot be found. Ideally that shouldn't be\n        // necessary. Other solution would be to adjust bottom by -1px, but that would make some dependency lines to take\n        // 1px different path on a row boundary, which doesn't look nice (but slightly more performant)\n        if (side === 'bottom') {\n            return [\n                {\n                    start  : box.left,\n                    end    : box.left + box.width / 2,\n                    top    : box.rowTop,\n                    bottom : box.rowBottom\n                },\n                {\n                    start  : box.left + box.width / 2,\n                    end    : box.right,\n                    top    : box.rowTop,\n                    bottom : box.rowBottom\n                }\n            ];\n        }\n        else {\n            return [\n                {\n                    start  : box.left - this.pathFinder.startArrowMargin,\n                    end    : box.right + this.pathFinder.startArrowMargin,\n                    top    : box.rowTop,\n                    bottom : box.rowBottom\n                }\n            ];\n        }\n\n        // //<debug>\n        // globalThis.DEBUG && boxes.forEach(box => {\n        //     DomHelper.createElement({\n        //         parent : document.querySelector('.b-sch-foreground-canvas'),\n        //         html   : `<div style=\"left:${box.start}px;top:${box.top}px;width:${box.end - box.start}px;height:${box.bottom - box.top}px;border:1px solid green;position:absolute;\"></div>`\n        //     });\n        // });\n        // //</debug>\n    }\n\n    // Bounding box for an assignment, uses elements bounds if rendered\n    getAssignmentBounds(assignment) {\n        const\n            { client } = this,\n            element    = this.getAssignmentElement(assignment);\n\n        if (element && !client.isExporting) {\n            const rectangle = Rectangle.from(element, this.relativeTo);\n\n            if (client.isHorizontal) {\n                let row = client.getRowById(assignment.resource.id);\n\n                // Outside of its row? It is being dragged, resolve new row\n                if (rectangle.y < row.top || rectangle.bottom > row.bottom) {\n                    const overRow = client.rowManager.getRowAt(rectangle.center.y, true);\n                    if (overRow) {\n                        row = overRow;\n                    }\n                }\n\n                rectangle.rowTop = row.top;\n                rectangle.rowBottom = row.bottom;\n            }\n\n            return rectangle;\n        }\n\n        return client.isEngineReady && client.getAssignmentEventBox(assignment, true);\n    }\n\n    //endregion\n\n    //region Sides\n\n    getConnectorStartSide(timeSpanRecord) {\n        return this.client.currentOrientation.getConnectorStartSide(timeSpanRecord);\n    }\n\n    getConnectorEndSide(timeSpanRecord) {\n        return this.client.currentOrientation.getConnectorEndSide(timeSpanRecord);\n    }\n\n    getDependencyStartSide(dependency) {\n        const { fromEvent, type, fromSide } = dependency;\n\n        if (fromSide) {\n            return fromSide;\n        }\n\n        switch (true) {\n            case type === DependencyModel.Type.StartToEnd:\n            case type === DependencyModel.Type.StartToStart:\n                return this.getConnectorStartSide(fromEvent);\n\n            case type === DependencyModel.Type.EndToStart:\n            case type === DependencyModel.Type.EndToEnd:\n                return this.getConnectorEndSide(fromEvent);\n\n            default:\n                // Default value might not be applied yet when rendering early in Pro / Gantt\n                return this.getConnectorEndSide(fromEvent);\n        }\n    }\n\n    getDependencyEndSide(dependency) {\n        const { toEvent, type, toSide } = dependency;\n\n        if (toSide) {\n            return toSide;\n        }\n\n        // Fallback to view trait if dependency end side is not given /*or can be obtained from type*/\n        switch (true) {\n            case type === DependencyModel.Type.EndToEnd:\n            case type === DependencyModel.Type.StartToEnd:\n                return this.getConnectorEndSide(toEvent);\n\n            case type === DependencyModel.Type.EndToStart:\n            case type === DependencyModel.Type.StartToStart:\n                return this.getConnectorStartSide(toEvent);\n\n            default:\n                // Default value might not be applied yet when rendering early in Pro / Gantt\n                return this.getConnectorStartSide(toEvent);\n        }\n    }\n\n    //endregion\n\n    //region Line def\n\n    // An array of functions used to alter path config when no path found.\n    // It first tries to shrink arrow margins and secondly hides arrows entirely\n    createLineDefAdjusters() {\n        const { client } = this;\n\n        function shrinkArrowMargins(lineDef) {\n            const { barMargin } = client;\n\n            let adjusted = false;\n\n            if (lineDef.startArrowMargin > barMargin || lineDef.endArrowMargin > barMargin) {\n                lineDef.startArrowMargin = lineDef.endArrowMargin = barMargin;\n                adjusted = true;\n            }\n\n            return adjusted ? lineDef : adjusted;\n        }\n\n        function resetArrowMargins(lineDef) {\n            let adjusted = false;\n\n            if (lineDef.startArrowMargin > 0 || lineDef.endArrowMargin > 0) {\n                lineDef.startArrowMargin = lineDef.endArrowMargin = 0;\n                adjusted = true;\n            }\n\n            return adjusted ? lineDef : adjusted;\n        }\n\n        function shrinkHorizontalMargin(lineDef, originalLineDef) {\n            let adjusted = false;\n\n            if (lineDef.horizontalMargin > 2) {\n                lineDef.horizontalMargin = 1;\n                adjusted = true;\n                originalLineDef.hideMarker = true;\n            }\n\n            return adjusted ? lineDef : adjusted;\n        }\n\n        return [\n            shrinkArrowMargins,\n            resetArrowMargins,\n            shrinkHorizontalMargin\n        ];\n    }\n\n    // Overridden in Gantt\n    adjustLineDef(dependency, lineDef) {\n        return lineDef;\n    }\n\n    // Prepare data to feed to the path finder\n    prepareLineDef(dependency, fromAssignment, toAssignment, forceBoxes) {\n        const\n            me             = this,\n            startSide      = me.getDependencyStartSide(dependency),\n            endSide        = me.getDependencyEndSide(dependency),\n            startRectangle = forceBoxes?.from ?? me.getAssignmentBounds(fromAssignment),\n            endRectangle   = forceBoxes?.to ?? me.getAssignmentBounds(toAssignment),\n            otherBoxes     = [];\n\n        if (!startRectangle || !endRectangle) {\n            return null;\n        }\n\n        let {\n            startArrowMargin,\n            verticalMargin\n        } = me.pathFinder;\n\n        if (me.client.isHorizontal) {\n            // Only add otherBoxes if assignments are in different resources\n            if (startRectangle.rowTop != null && startRectangle.rowTop !== endRectangle.rowTop) {\n                otherBoxes.push(...me.generateBoundaryBoxes(startRectangle, startSide));\n            }\n\n            // Do not change start arrow margin in case dependency is bidirectional\n            if (!dependency.bidirectional) {\n                if (/(top|bottom)/.test(startSide)) {\n                    startArrowMargin = me.client.barMargin / 2;\n                }\n\n                verticalMargin = me.client.barMargin / 2;\n            }\n        }\n\n        return me.adjustLineDef(dependency, {\n            startBox              : startRectangle,\n            endBox                : endRectangle,\n            otherBoxes,\n            startArrowMargin,\n            verticalMargin,\n            otherVerticalMargin   : 0,\n            otherHorizontalMargin : 0,\n            startSide,\n            endSide\n        });\n    }\n\n    //endregion\n\n    //region Cache\n\n    // All dependencies are about to be drawn, check if we need to build the line cache\n    beforeDraw() {\n        super.beforeDraw();\n\n        if (!Object.keys(this.lineCache).length) {\n            this.constructLineCache = true;\n        }\n    }\n\n    // All dependencies are drawn, we no longer need to rebuild the cache\n    afterDraw() {\n        super.afterDraw();\n\n        this.constructLineCache = false;\n    }\n\n    reset() {\n        super.reset();\n\n        this.lineCache = {};\n    }\n\n    //endregion\n\n};\n", "import Tooltip from '../../../Core/widget/Tooltip.js';\n\n/**\n * @module Scheduler/feature/mixin/DependencyTooltip\n */\n\nconst\n    // Map dependency type to side of a box, for displaying an icon in the tooltip\n    fromBoxSide = [\n        'start',\n        'start',\n        'end',\n        'end'\n    ],\n    toBoxSide   = [\n        'start',\n        'end',\n        'start',\n        'end'\n    ];\n\n/**\n * Mixin that adds tooltip support to the {@link Scheduler/feature/Dependencies} feature.\n * @mixin\n */\nexport default Target => class DependencyTooltip extends Target {\n    static $name = 'DependencyTooltip';\n\n    static configurable = {\n        /**\n         * Set to true to show a tooltip when hovering a dependency line\n         * @config {Boolean}\n         */\n        showTooltip : true,\n\n        /**\n         * A template function allowing you to configure the contents of the tooltip shown when hovering a\n         * dependency line. You can return either an HTML string or a {@link DomConfig} object.\n         * @prp {Function} tooltipTemplate\n         * @param {Scheduler.model.DependencyBaseModel} dependency The dependency record\n         * @returns {String|DomConfig}\n         */\n        tooltipTemplate(dependency) {\n            return {\n                children : [{\n                    className : 'b-sch-dependency-tooltip',\n                    children  : [\n                        { tag : 'label', text : this.L('L{Dependencies.from}') },\n                        { text : dependency.fromEvent.name },\n                        { className : `b-sch-box b-${dependency.fromSide || fromBoxSide[dependency.type]}` },\n                        { tag : 'label', text : this.L('L{Dependencies.to}') },\n                        { text : dependency.toEvent.name },\n                        { className : `b-sch-box b-${dependency.toSide || toBoxSide[dependency.type]}` }\n                    ]\n                }]\n            };\n        },\n\n        /**\n         * A tooltip config object that will be applied to the dependency hover tooltip. Can be used to for example\n         * customize delay\n         * @config {TooltipConfig}\n         */\n        tooltip : {\n            $config : 'nullify',\n\n            value : {}\n        }\n    };\n\n    changeTooltip(tooltip, old) {\n        const me = this;\n\n        old?.destroy();\n\n        if (!me.showTooltip || !tooltip) {\n            return null;\n        }\n\n        return Tooltip.new({\n            align          : 'b-t',\n            id             : `${me.client.id}-dependency-tip`,\n            // <remove-on-release>\n            // TODO: need some way better to specify this. maybe each feature should be queried?\n            // </remove-on-release>\n            forSelector    : `.b-timelinebase:not(.b-eventeditor-editing,.b-taskeditor-editing,.b-resizing-event,.b-dragcreating,.b-dragging-event,.b-creating-dependency) .${me.baseCls}`,\n            forElement     : me.client.timeAxisSubGridElement,\n            showOnHover    : true,\n            hoverDelay     : 0,\n            hideDelay      : 0,\n            anchorToTarget : false,\n            textContent    : false, // Skip max-width setting\n            trackMouse     : false,\n            getHtml        : me.getHoverTipHtml.bind(me)\n        }, tooltip);\n    }\n\n    /**\n     * Generates DomConfig content for the tooltip shown when hovering a dependency\n     * @param {Object} tooltipConfig\n     * @returns {DomConfig} DomConfig used as tooltips content\n     * @private\n     */\n    getHoverTipHtml({ activeTarget }) {\n        return this.tooltipTemplate(this.resolveDependencyRecord(activeTarget));\n    }\n};\n", "import DomSync from '../../Core/helper/DomSync.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport AttachToProjectMixin from '../data/mixin/AttachToProjectMixin.js';\nimport DependencyCreation from './mixin/DependencyCreation.js';\nimport DependencyGridCache from './mixin/DependencyGridCache.js';\nimport DependencyLineGenerator from './mixin/DependencyLineGenerator.js';\nimport DependencyTooltip from './mixin/DependencyTooltip.js';\n\nconst\n    eventNameMap = {\n        click       : 'Click',\n        dblclick    : 'DblClick',\n        contextmenu : 'ContextMenu'\n    },\n    emptyObject = Object.freeze({});\n\n/**\n * @module Scheduler/feature/Dependencies\n */\n\nconst collectLinkedAssignments = assignment => {\n    const result = [assignment];\n\n    if (assignment.resource?.hasLinks) {\n        // Fake linked assignments\n        result.push(...assignment.resource.$links.map(l => ({\n            id               : `${l.id}_${assignment.id}`,\n            resource         : l,\n            event            : assignment.event,\n            drawDependencies : assignment.drawDependencies\n        })));\n    }\n\n    return result;\n};\n\n/**\n * Feature that draws dependencies between events. Uses a {@link Scheduler.data.DependencyStore} to determine which\n * dependencies to draw, if none is defined one will be created automatically. Dependencies can also be specified as\n * `scheduler.dependencies`, see example below:\n *\n * {@inlineexample Scheduler/feature/Dependencies.js}\n *\n * Dependencies also work in vertical mode:\n *\n * {@inlineexample Scheduler/feature/DependenciesVertical.js}\n *\n * To customize the dependency tooltip, you can provide the {@link #config-tooltip} config and specify a\n * {@link Core.widget.Tooltip#config-getHtml} function. For example:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         dependencies : {\n *             tooltip : {\n *                 getHtml({ activeTarget }) {\n *                     const dependencyModel = scheduler.resolveDependencyRecord(activeTarget);\n *\n *                     if (!dependencyModel) return null;\n *\n *                     const { fromEvent, toEvent } = dependencyModel;\n *\n *                     return `${fromEvent.name} (${fromEvent.id}) -> ${toEvent.name} (${toEvent.id})`;\n *                 }\n *             }\n *         }\n *     }\n * }\n * ```\n *\n * ## Styling dependency lines\n *\n * You can easily customize the arrows drawn between events. To change all arrows, apply the following basic SVG CSS:\n *\n * ```css\n * .b-sch-dependency {\n *    stroke-width: 2;\n *    stroke : red;\n * }\n *\n * .b-sch-dependency-arrow {\n *     fill: red;\n * }\n * ```\n *\n * To style an individual dependency line, you can provide a [cls](#Scheduler/model/DependencyModel#field-cls) in your\n * data:\n *\n * ```json\n * {\n *     \"id\"   : 9,\n *     \"from\" : 7,\n *     \"to\"   : 8,\n *     \"cls\"  : \"special-dependency\"\n * }\n * ```\n *\n * ```scss\n * // Make line dashed\n * .b-sch-dependency {\n *    stroke-dasharray: 5, 5;\n * }\n * ```\n *\n * To customize the marker used for the lines (the arrow header), you can supply a SVG path definition to the\n * {@link #config-markerDef} config:\n *\n * {@inlineexample Scheduler/feature/DependenciesMarker.js}\n *\n * You can also specify a {@link #config-radius} to get lines with rounded \"corners\", for a less boxy look:\n *\n * {@inlineexample Scheduler/feature/DependenciesRadius.js}\n *\n * For advanced use cases, you can also manipulate the {@link DomConfig} used to create a dependency line in a\n * {@link #config-renderer} function.\n *\n * This feature is **off** by default. For info on enabling it, see {@link Grid.view.mixin.GridFeatures}.\n *\n * @mixes Core/mixin/Delayable\n * @mixes Scheduler/feature/mixin/DependencyCreation\n * @mixes Scheduler/feature/mixin/DependencyTooltip\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Scheduler/dependencies\n * @classtype dependencies\n * @feature\n */\nexport default class Dependencies extends InstancePlugin.mixin(\n    AttachToProjectMixin,\n    Delayable,\n    DependencyCreation,\n    DependencyGridCache,\n    DependencyLineGenerator,\n    DependencyTooltip\n) {\n\n    // <debug>\n    // region Localization test\n    static localization = [\n        'L{DependencyType.SS}',\n        'L{DependencyType.SF}',\n        'L{DependencyType.FS}',\n        'L{DependencyType.FF}',\n        'L{DependencyType.StartToStart}',\n        'L{DependencyType.StartToEnd}',\n        'L{DependencyType.EndToStart}',\n        'L{DependencyType.EndToEnd}',\n        'L{DependencyType.long}',\n        'L{DependencyType.short}'\n    ];\n    // endregion\n    // </debug>\n\n    static $name = 'Dependencies';\n\n    /**\n     * Fired when dependencies are rendered\n     * @on-owner\n     * @event dependenciesDrawn\n     */\n\n    //region Config\n\n    static configurable = {\n        /**\n         * The CSS class to add to a dependency line when hovering over it\n         * @config {String}\n         * @default\n         * @private\n         */\n        overCls : 'b-sch-dependency-over',\n\n        /**\n         * The CSS class applied to dependency lines\n         * @config {String}\n         * @default\n         * @private\n         */\n        baseCls : 'b-sch-dependency',\n\n        /**\n         * The CSS class applied to a too narrow dependency line (to hide markers)\n         * @config {String}\n         * @default\n         * @private\n         */\n        noMarkerCls : 'b-sch-dependency-markerless',\n\n        /**\n         * SVG path definition used as marker (arrow head) for the dependency lines.\n         * Should fit in a viewBox that is 9 x 6.\n         *\n         * ```javascript\n         * const scheduler = new Scheduler({\n         *     features : {\n         *         dependencies : {\n         *             // Circular marker\n         *             markerDef : 'M 2,3 a 3,3 0 1,0 6,0 a 3,3 0 1,0 -6,0'\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * @config {String}\n         * @default 'M3,0 L3,6 L9,3 z'\n         */\n        markerDef : null,\n\n        /**\n         * Radius (in px) used to draw arcs where dependency line segments connect. Specify it to get a rounded look.\n         * The radius will during drawing be reduced as needed on a per segment basis to fit lines.\n         *\n         * ```javascript\n         * const scheduler = new Scheduler({\n         *     features : {\n         *         dependencies : {\n         *             // Round the corner where line segments connect, similar to 'border-radius: 5px'\n         *             radius : 5\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * <div class=\"note\">Using a radius slightly degrades dependency rendering performance. If your app displays\n         * a lot of dependencies, it might be worth taking this into account when deciding if you want to use radius\n         * or not</div>\n         *\n         * @config {Number}\n         */\n        radius : null,\n\n        /**\n         * Renderer function, supply one if you want to manipulate the {@link DomConfig} object used to draw a\n         * dependency line between two assignments.\n         *\n         * ```javascript\n         * const scheduler = new Scheduler({\n         *     features : {\n         *         dependencies : {\n         *             renderer({ domConfig, fromAssignmentRecord : from, toAssignmentRecord : to }) {\n         *                 // Add a custom CSS class to dependencies between important assignments\n         *                 domConfig.class.important = from.important || to.important;\n         *                 domConfig.class.veryImportant = from.important && to.important;\n         *             }\n         *         }\n         *     }\n         * }\n         * ```\n         *\n         * @param {Object} renderData\n         * @param {DomConfig} renderData.domConfig that will be used to create the dependency line, can be manipulated by the\n         * renderer\n         * @param {Scheduler.model.DependencyModel} renderData.dependencyRecord The dependency being rendered\n         * @param {Scheduler.model.AssignmentModel} renderData.fromAssignmentRecord Drawing line from this assignment\n         * @param {Scheduler.model.AssignmentModel} renderData.toAssignmentRecord Drawing line to this assignment\n         * @param {Object[]} renderData.points A collection of points making up the line segments for the dependency\n         * line. Read-only in the renderer, any manipulation should be done to `domConfig`\n         * @param {Core.helper.util.Rectangle} renderData.fromBox Bounds for the fromAssignment's element\n         * @param {Core.helper.util.Rectangle} renderData.toBox Bounds for the toAssignment's element\n         * @param {'top'|'right'|'bottom'|'left'} renderData.fromSide Drawn from this side of the fromAssignment\n         * @param {'top'|'right'|'bottom'|'left'} renderData.toSide Drawn to this side of the fromAssignment\n         * @prp {Function}\n         */\n        renderer : null,\n\n        /**\n         * Specify `true` to highlight incoming and outgoing dependencies when hovering an event.\n         * @prp {Boolean}\n         */\n        highlightDependenciesOnEventHover : null,\n\n        /**\n         * Specify `false` to prevent dependencies from being drawn during scroll, for smoother scrolling in schedules\n         * with lots of dependencies. Dependencies will be drawn when scrolling stops instead.\n         * @prp {Boolean}\n         * @default\n         */\n        drawOnScroll : true,\n\n        /**\n         * The clickable/touchable width of the dependency line in pixels. Setting this to a number greater than 1 will\n         * draw an invisible but clickable line along the same path as the dependency line, making it easier to click.\n         * The tradeoff is that twice as many lines will be drawn, which can affect performance.\n         * @prp {Number}\n         */\n        clickWidth : null,\n\n        /**\n         * By default, the refresh of dependencies is buffered by 10 milliseconds so that multiple changes\n         * which may cause the dependency lines to become invalid are coalesced into one refresh. This is more\n         * efficient, but may mean the dependency lines may lag behind expectations when moving a pointer.\n         *\n         * Set this to `true` to update dependency lines immediately upon any change which causes them\n         * to require an update.\n         * @prp {Boolean}\n         * @default false\n         * @private\n         */\n        immediateRefresh : null\n    };\n\n    static delayable = {\n        doRefresh : 10\n    };\n\n    static get pluginConfig() {\n        return {\n            chain  : ['render', 'onPaint', 'onElementClick', 'onElementDblClick', 'onElementContextMenu', 'onElementMouseOver', 'onElementMouseOut', 'bindStore'],\n            assign : ['getElementForDependency', 'getElementsForDependency', 'resolveDependencyRecord']\n        };\n    };\n\n    domConfigs  = new Map();\n    drawingLive = false;\n    lastScrollX = null;\n    highlighted = new Map();\n    // Cached lookups\n    visibleResources = null;\n    usingLinks       = null;\n    visibleDateRange = null;\n    relativeTo       = null;\n\n    //endregion\n\n    //region Init & destroy\n\n    construct(client, config) {\n        super.construct(client, config);\n\n        const { scheduledEventName } = client;\n\n        client.ion({\n            svgCanvasCreated                            : 'onSVGReady',\n            // These events trigger live refresh behaviour\n            animationStart                              : 'refresh',\n            // eventDrag in Scheduler, taskDrag in Gantt\n            [scheduledEventName + 'DragStart']          : 'refresh',\n            [scheduledEventName + 'DragAbort']          : 'refresh',\n            [scheduledEventName + 'ResizeStart']        : 'refresh',\n            [scheduledEventName + 'SegmentDragStart']   : 'refresh',\n            [scheduledEventName + 'SegmentResizeStart'] : 'refresh',\n            // These events shift the surroundings to such extent that grid cache needs rebuilding to be sure that\n            // all dependencies are considered\n            timelineViewportResize                      : 'reset',\n            timeAxisViewModelUpdate                     : 'reset',\n            toggleNode                                  : 'reset',\n            thisObj                                     : this\n        });\n\n        client.rowManager.ion({\n            refresh           : 'reset', // For example when changing barMargin or rowHeight\n            changeTotalHeight : 'reset', // For example when collapsing groups\n            thisObj           : this\n        });\n\n        this.bindStore(client.store);\n    }\n\n    doDisable(disable) {\n        if (!this.isConfiguring) {\n            // Need a flag to clear dependencies when disabled, since drawing is otherwise disabled too\n            this._isDisabling = disable;\n            this.draw();\n            this._isDisabling = false;\n        }\n\n        super.doDisable(disable);\n    }\n\n    //endregion\n\n    //region RefreshTriggers\n\n    get rowStore() {\n        return this.client.isVertical ? this.client.resourceStore : this.client.store;\n    }\n\n    // React to replacing or refreshing a display store\n    bindStore(store) {\n        const me = this;\n\n        if (!me.client.isVertical) {\n            me.detachListeners('store');\n\n            if (me.client.usesDisplayStore) {\n                store?.ion({\n                    name    : 'store',\n                    refresh : 'onStoreRefresh',\n                    thisObj : me\n                });\n\n                me.reset();\n            }\n        }\n    }\n\n    onStoreRefresh() {\n        this.reset();\n    }\n\n    // <remove-on-release>\n    // TODO: Need toggleNode, viewportResize, translateRow, changeTotalHeight, idChange ?\n    // </remove-on-release>\n\n    attachToProject(project) {\n        super.attachToProject(project);\n\n        project?.ion({\n            name            : 'project',\n            commitFinalized : 'reset',\n            thisObj         : this\n        });\n    }\n\n    attachToResourceStore(resourceStore) {\n        super.attachToResourceStore(resourceStore);\n\n        resourceStore?.ion({\n            name    : 'resourceStore',\n            change  : 'onResourceStoreChange',\n            refresh : 'onResourceStoreChange',\n            thisObj : this\n        });\n    }\n\n    onResourceStoreChange() {\n        // Might have added or removed links, need to re-cache the flag\n        this.usingLinks = null;\n        this.reset();\n    }\n\n    attachToEventStore(eventStore) {\n        super.attachToEventStore(eventStore);\n\n        eventStore?.ion({\n            name    : 'eventStore',\n            refresh : 'reset',\n            thisObj : this\n        });\n    }\n\n    attachToAssignmentStore(assignmentStore) {\n        super.attachToAssignmentStore(assignmentStore);\n\n        assignmentStore?.ion({\n            name    : 'assignmentStore',\n            refresh : 'reset',\n            thisObj : this\n        });\n    }\n\n    attachToDependencyStore(dependencyStore) {\n        super.attachToDependencyStore(dependencyStore);\n\n        dependencyStore?.ion({\n            name    : 'dependencyStore',\n            change  : 'reset',\n            refresh : 'reset',\n            thisObj : this\n        });\n    }\n\n    updateDrawOnScroll(drawOnScroll) {\n        const me = this;\n\n        me.detachListeners('scroll');\n\n        if (drawOnScroll) {\n            me.client.ion({\n                name             : 'scroll',\n                scroll           : 'doRefresh',\n                horizontalScroll : 'onHorizontalScroll',\n                prio             : -100, // After Scheduler draws on scroll, since we target elements\n                thisObj          : me\n            });\n        }\n        else {\n            me.client.scrollable.ion({\n                name      : 'scroll',\n                scrollEnd : 'draw',\n                thisObj   : me\n            });\n\n            me.client.timeAxisSubGrid.scrollable.ion({\n                name      : 'scroll',\n                scrollEnd : 'draw',\n                thisObj   : me\n            });\n        }\n    }\n\n    onHorizontalScroll({ subGrid, scrollX }) {\n        if (scrollX !== this.lastScrollX && subGrid === this.client.timeAxisSubGrid) {\n            this.lastScrollX = scrollX;\n            this.draw();\n        }\n    }\n\n    onPaint() {\n        this.refresh();\n    }\n\n    //endregion\n\n    //region Dependency types\n\n    // Used by DependencyField\n    static getLocalizedDependencyType(type) {\n        return type ? this.L(`L{DependencyType.${type}}`) : '';\n    }\n\n    //endregion\n\n    //region Elements\n\n    getElementForDependency(dependency, fromAssignment, toAssignment) {\n        return this.getElementsForDependency(dependency, fromAssignment, toAssignment)[0];\n    }\n\n    // NOTE: If we ever make this public we should change it to use the syncIdMap. Currently not needed since only\n    // used in tests\n    getElementsForDependency(dependency, fromAssignment, toAssignment) {\n        // Selector targeting all instances of a dependency\n        let selector = `[data-dep-id=\"${dependency.id}\"]`;\n\n        // Optionally narrow it down to a single instance (assignment)\n        if (fromAssignment) {\n            selector += `[data-from-id=\"${fromAssignment.id}\"]`;\n        }\n        if (toAssignment) {\n            selector += `[data-to-id=\"${toAssignment.id}\"]`;\n        }\n\n        return Array.from(this.client.svgCanvas.querySelectorAll(selector));\n    }\n\n    /**\n     * Returns the dependency record for a DOM element\n     * @param {HTMLElement} element The dependency line element\n     * @returns {Scheduler.model.DependencyModel} The dependency record\n     */\n    resolveDependencyRecord(element) {\n        return element.elementData?.dependency;\n    }\n\n    isDependencyElement(element) {\n        return element.matches(`.${this.baseCls}`);\n    }\n\n    //endregion\n\n    //region DOM Events\n\n    onElementClick(event) {\n        const dependency = this.resolveDependencyRecord(event.target);\n\n        if (dependency) {\n            const eventName = eventNameMap[event.type];\n\n            /**\n             * Fires on the owning Scheduler/Gantt when a context menu event is registered on a dependency line.\n             * @event dependencyContextMenu\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler\n             * @param {Scheduler.model.DependencyModel} dependency\n             * @param {MouseEvent} event\n             */\n            /**\n             * Fires on the owning Scheduler/Gantt when a click is registered on a dependency line.\n             * @event dependencyClick\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler\n             * @param {Scheduler.model.DependencyModel} dependency\n             * @param {MouseEvent} event\n             */\n            /**\n             * Fires on the owning Scheduler/Gantt when a double click is registered on a dependency line.\n             * @event dependencyDblClick\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler\n             * @param {Scheduler.model.DependencyModel} dependency\n             * @param {MouseEvent} event\n             */\n            this.client.trigger(`dependency${eventName}`, {\n                dependency,\n                event\n            });\n        }\n    }\n\n    onElementDblClick(event) {\n        return this.onElementClick(event);\n    }\n\n    onElementContextMenu(event) {\n        return this.onElementClick(event);\n    }\n\n    onElementMouseOver(event) {\n        const\n            me         = this,\n            dependency = me.resolveDependencyRecord(event.target);\n\n        if (dependency) {\n            /**\n             * Fires on the owning Scheduler/Gantt when the mouse moves over a dependency line.\n             * @event dependencyMouseOver\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler\n             * @param {Scheduler.model.DependencyModel} dependency\n             * @param {MouseEvent} event\n             */\n            me.client.trigger('dependencyMouseOver', {\n                dependency,\n                event\n            });\n\n            if (me.overCls) {\n                me.highlight(dependency);\n            }\n        }\n    }\n\n    onElementMouseOut(event) {\n        const\n            me         = this,\n            dependency = me.resolveDependencyRecord(event.target);\n\n        if (dependency) {\n            /**\n             * Fires on the owning Scheduler/Gantt when the mouse moves out of a dependency line.\n             * @event dependencyMouseOut\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler\n             * @param {Scheduler.model.DependencyModel} dependency\n             * @param {MouseEvent} event\n             */\n            me.client.trigger('dependencyMouseOut', {\n                dependency,\n                event\n            });\n\n            if (me.overCls) {\n                me.unhighlight(dependency);\n            }\n        }\n    }\n\n    //endregion\n\n    //region Export\n\n    // Export calls this fn to determine if a dependency should be included or not\n    isDependencyVisible(dependency) {\n        const\n            me           = this,\n            { rowStore } = me,\n            {\n                fromEvent,\n                toEvent\n            }            = dependency;\n\n        // Bail out early in case source or target doesn't exist\n        if (!fromEvent || !toEvent) {\n            return false;\n        }\n\n        const\n            fromResource = fromEvent.resource,\n            toResource   = toEvent.resource;\n\n        // Verify these are real existing Resources and not collapsed away (resource not existing in resource store)\n        if (!rowStore.isAvailable(fromResource) || !rowStore.isAvailable(toResource)) {\n            return false;\n        }\n\n        return fromEvent.isModel &&\n            !fromResource.instanceMeta(rowStore).hidden &&\n            !toResource.instanceMeta(rowStore).hidden;\n    }\n\n    //endregion\n\n    //region Highlight\n\n    updateHighlightDependenciesOnEventHover(enable) {\n        const me = this;\n\n        if (enable) {\n            const { client } = me;\n\n            client.ion({\n                name                                       : 'highlightOnHover',\n                [`${client.scheduledEventName}MouseEnter`] : params => me.highlightEventDependencies(params.eventRecord || params.taskRecord),\n                [`${client.scheduledEventName}MouseLeave`] : params => me.unhighlightEventDependencies(params.eventRecord || params.taskRecord),\n                thisObj                                    : me\n            });\n        }\n        else {\n            me.detachListeners('highlightOnHover');\n        }\n    }\n\n    highlight(dependency, cls = this.overCls) {\n        let classes = this.highlighted.get(dependency);\n\n        if (!classes) {\n            this.highlighted.set(dependency, classes = new Set());\n        }\n\n        classes.add(cls);\n\n        // Update element directly instead of refreshing and letting DomSync handle it,\n        // to optimize highlight performance with many dependencies on screen\n        for (const element of this.getElementsForDependency(dependency)) {\n            element.classList.add(cls);\n        }\n    }\n\n    unhighlight(dependency, cls = this.overCls) {\n        const classes = this.highlighted.get(dependency);\n\n        if (classes) {\n            classes.delete(cls);\n\n            if (!classes.size) {\n                this.highlighted.delete(dependency);\n            }\n        }\n\n        // Update element directly instead of refreshing and letting DomSync handle it,\n        // to optimize highlight performance with many dependencies on screen\n        for (const element of this.getElementsForDependency(dependency)) {\n            element.classList.remove(cls);\n        }\n    }\n\n    highlightEventDependencies(timespan, cls) {\n        timespan.dependencies.forEach(dep => this.highlight(dep, cls));\n    }\n\n    unhighlightEventDependencies(timespan, cls) {\n        timespan.dependencies.forEach(dep => this.unhighlight(dep, cls));\n    }\n\n    //endregion\n\n    //region Drawing\n\n    // Implemented in DependencyGridCache to return dependencies that might intersect the current viewport and thus\n    // should be considered for drawing. Fallback value here is used when there is no grid cache (which happens when it\n    // is reset. Also useful in case we want to have it configurable or opt out automatically for small datasets)\n    getDependenciesToConsider(startMS, endMS, startIndex, endIndex) {\n        // Get records from grid cache\n        return super.getDependenciesToConsider?.(startMS, endMS, startIndex, endIndex) ??\n            // Falling back to using all valid deps (fix for not trying to draw conflicted deps)\n            this.project.dependencyStore.records.filter(d => d.isValid);\n    }\n\n    // String key used as syncId\n    getDependencyKey(dependency, fromAssignment, toAssignment) {\n        return `dep:${dependency.id};from:${fromAssignment.id};to:${toAssignment.id}`;\n    }\n\n    // <remove-on-release>\n    // Draw a single dependency, if it is in view (overridden in Gantt)\n    // TODO: Was public\n    // </remove-on-release>\n    drawDependency(dependency, batch = false, forceBoxes = null) {\n        const\n            me           = this,\n            {\n                domConfigs,\n                client,\n                rowStore,\n                topIndex,\n                bottomIndex\n            }            = me,\n            {\n                eventStore,\n                useInitialAnimation\n            }            = client,\n            { idMap }    = rowStore,\n            {\n                startMS,\n                endMS\n            }            = me.visibleDateRange,\n            {\n                fromEvent,\n                toEvent\n            }            = dependency;\n\n        let fromAssigned = fromEvent.assigned,\n            toAssigned   = toEvent.assigned;\n\n        if (\n            // No point in trying to draw dep between unscheduled/non-existing events\n            fromEvent.isScheduled && toEvent.isScheduled &&\n            // Or between filtered out events\n            eventStore.includes(fromEvent) && eventStore.includes(toEvent) &&\n            // Or unassigned ones\n            fromAssigned?.size && toAssigned?.size\n        ) {\n            // Add links, if used\n            if (me.usingLinks) {\n                fromAssigned = [...fromAssigned].flatMap(collectLinkedAssignments);\n                toAssigned = [...toAssigned].flatMap(collectLinkedAssignments);\n            }\n\n            for (const from of fromAssigned) {\n                for (const to of toAssigned) {\n                    const\n                        // Using direct lookup in idMap instead of indexOf() for performance.\n                        // Resource might be filtered out or not exist at all\n                        fromIndex  = idMap[from.resource?.id]?.index,\n                        toIndex    = idMap[to.resource?.id]?.index,\n                        fromDateMS = Math.min(fromEvent.startDateMS, toEvent.startDateMS),\n                        toDateMS   = Math.max(fromEvent.endDateMS, toEvent.endDateMS);\n\n                    // Draw only if dependency intersects view, unless it is part of an export\n                    if (\n                        client.isExporting || fromIndex != null && toIndex != null &&\n                        (from.drawDependencies !== false && to.drawDependencies !== false) &&\n                        (rowStore.isAvailable(from.resource) && (rowStore.isAvailable(to.resource))) && !(\n                            // Both ends above view\n                            (fromIndex < topIndex && toIndex < topIndex) ||\n                            // Both ends below view\n                            (fromIndex > bottomIndex && toIndex > bottomIndex) ||\n                            // Both ends before view\n                            (fromDateMS < startMS && toDateMS < startMS) ||\n                            // Both ends after view\n                            (fromDateMS > endMS && toDateMS > endMS)\n                        )\n                    ) {\n                        const\n                            key            = me.getDependencyKey(dependency, from, to),\n                            lineDomConfigs = me.getDomConfigs(dependency, from, to, forceBoxes);\n\n                        if (lineDomConfigs) {\n                            // Allow deps to match animation delay of their events (the bottommost one) when fading in\n                            if (useInitialAnimation) {\n                                lineDomConfigs[0].style = {\n                                    animationDelay : `${Math.max(fromIndex, toIndex) / 20 * 1000}ms`\n                                };\n                            }\n\n                            domConfigs.set(key, lineDomConfigs);\n                        }\n                        // No room to draw a line\n                        else {\n                            domConfigs.delete(key);\n                        }\n                    }\n\n                    // Give mixins a shot at running code after a dependency is drawn. Used by grid cache to cache the\n                    // dependency (when needed)\n                    me.afterDrawDependency(dependency, fromIndex, toIndex, fromDateMS, toDateMS);\n                }\n            }\n        }\n\n        if (!batch) {\n            me.domSync();\n        }\n    }\n\n    // Hooks used by grid cache, to keep code in this file readable\n    afterDrawDependency(dependency, fromIndex, toIndex, fromDateMS, toDateMS) {\n        super.afterDrawDependency?.(dependency, fromIndex, toIndex, fromDateMS, toDateMS);\n    }\n\n    beforeDraw() {\n        super.beforeDraw?.();\n    }\n\n    afterDraw() {\n        super.afterDraw?.();\n    }\n\n    // Update DOM\n    domSync(targetElement = this.client.svgCanvas) {\n        DomSync.sync({\n            targetElement,\n            domConfig : {\n                onlyChildren : true,\n                children     : Array.from(this.domConfigs.values()).flat()\n            },\n            syncIdField      : 'syncId',\n            releaseThreshold : 0,\n            strict           : true,\n            callback() {\n                // <remove-on-release>\n                // TODO: trigger events\n                // </remove-on-release>\n            }\n        });\n    }\n\n    fillDrawingCache() {\n        const\n            me         = this,\n            { client } = me;\n\n        // Cache subgrid bounds for the duration of this draw call to not have to figure it out per dep\n        me.relativeTo = Rectangle.from(client.foregroundCanvas);\n\n        // Cache other lookups too\n        me.visibleResources = client.visibleResources;\n        me.visibleDateRange = client.visibleDateRange;\n\n        me.topIndex     = me.rowStore.indexOf(me.visibleResources.first);\n        me.bottomIndex  = me.rowStore.indexOf(me.visibleResources.last);\n\n        // Cache link lookup, to avoid semi-expensive flatMap calls in drawDependency\n        if (me.usingLinks == null) {\n            me.usingLinks = client.resourceStore.some(r => r.hasLinks);\n        }\n    }\n\n    // Draw all dependencies intersecting the current viewport immediately\n    draw() {\n        const\n            me                  = this,\n            { client }          = me,\n            { visibleDateRange } = client;\n\n        if (client.refreshSuspended || !client.foregroundCanvas || !visibleDateRange || !client.isEngineReady || (me.disabled && !me._isDisabling) || client.isExporting) {\n            return;\n        }\n\n        me.fillDrawingCache();\n\n        me.domConfigs.clear();\n\n        // Nothing to draw if there are no rows or no ticks or we are disabled\n        if (client.firstVisibleRow && client.lastVisibleRow && client.timeAxis.count && !me.disabled &&\n            (visibleDateRange.endMS - visibleDateRange.startMS > 0)\n        ) {\n            const\n                {\n                    topIndex,\n                    bottomIndex\n                }                   = me,\n                dependencies        = me.getDependenciesToConsider(visibleDateRange.startMS, visibleDateRange.endMS, topIndex, bottomIndex);\n\n            // Give mixins a shot at doing something before deps are drawn. Used by grid cache to determine if\n            // the cache should be rebuilt\n            me.beforeDraw();\n\n            for (const dependency of dependencies) {\n                me.drawDependency(dependency, true);\n            }\n\n            // Give mixins a shot at doing something after all deps are drawn\n            me.afterDraw();\n        }\n\n        me.domSync();\n\n        client.trigger('dependenciesDrawn');\n    }\n\n    //endregion\n\n    //region Refreshing\n\n    // Performs a draw on next frame, not intended to be called directly, call refresh() instead\n    doRefresh() {\n        const\n            me                     = this,\n            { client }             = me,\n            { scheduledEventName } = client;\n\n        me.draw();\n\n        // Refresh each frame during animations, during dragging & resizing  (if we have dependencies)\n        me.drawingLive = client.dependencyStore.count &&\n            (\n                client.isAnimating || (client.useInitialAnimation && client.eventStore.count) ||\n                client.features[`${scheduledEventName}Drag`]?.isActivelyDragging ||\n                client.features[`${scheduledEventName}Resize`]?.isResizing ||\n                client.features[`${scheduledEventName}SegmentDrag`]?.isActivelyDragging ||\n                client.features[`${scheduledEventName}SegmentResize`]?.isResizing\n            );\n\n        me.drawingLive && me.refresh(false);\n    }\n\n    /**\n     * Redraws dependencies on the next animation frame\n     */\n    refresh(immediateRefresh = this.immediateRefresh) {\n        const { client } = this;\n\n        // Queue up a draw unless refresh is suspended.\n        // immediateRefresh must be true to function because this method may be used as an event listener\n        // so therefore may receive an event object as a sole parameter.\n        if (!client.refreshSuspended && !this.disabled && client.isPainted && !client.timeAxisSubGrid.collapsed) {\n            (immediateRefresh === true ? this.doRefresh.now : this.doRefresh).call(this);\n        }\n    }\n\n    // Resets grid cache and performs a draw on next frame. Conditions when it should be called:\n    // * Zooming\n    // * Shifting time axis\n    // * Resizing window\n    // * CRUD\n    // ...\n    reset({ source, type } = emptyObject) {\n        super.reset?.();\n        // Refresh immediately if the timeline viewport is changing size\n        this.refresh(source === this.client && type === 'timelineviewportresize');\n    }\n\n    /**\n     * Draws all dependencies for the specified task.\n     * @deprecated 5.1 The Dependencies feature was refactored and this fn is no longer needed\n     */\n    drawForEvent() {\n        VersionHelper.deprecate('Scheduler', '6.0.0', 'Dependencies.drawForEvent() is no longer needed');\n        this.refresh();\n    }\n\n    //endregion\n\n    //region Scheduler hooks\n\n    render() {\n        // Pull in the svg canvas early to have it available during drawing\n        this.client.getConfig('svgCanvas');\n    }\n\n    //endregion\n}\n\nGridFeatureManager.registerFeature(Dependencies, false, ['Scheduler', 'ResourceHistogram']);\n", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\n\n/**\n * @module Scheduler/feature/EventFilter\n */\n\n/**\n * Adds event filter menu items to the timeline header context menu.\n *\n * {@inlineexample Scheduler/feature/EventFilter.js}\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *   features : {\n *     eventFilter : true // `true` by default, set to `false` to disable the feature and remove the menu item from the timeline header\n *   }\n * });\n * ```\n *\n * This feature is **enabled** by default\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype eventFilter\n * @feature\n */\nexport default class EventFilter extends InstancePlugin {\n\n    static get $name() {\n        return 'EventFilter';\n    }\n\n    static get pluginConfig() {\n        return {\n            chain : ['populateTimeAxisHeaderMenu']\n        };\n    }\n\n    /**\n     * Populates the header context menu items.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateTimeAxisHeaderMenu({ items }) {\n        const me = this;\n\n        items.eventsFilter = {\n            text        : 'L{filterEvents}',\n            icon        : 'b-fw-icon b-icon-filter',\n            disabled    : me.disabled,\n            localeClass : me,\n            weight      : 100,\n            menu        : {\n                type        : 'popup',\n                localeClass : me,\n                items       : {\n                    nameFilter : {\n                        weight               : 110,\n                        type                 : 'textfield',\n                        cls                  : 'b-eventfilter b-last-row',\n                        clearable            : true,\n                        keyStrokeChangeDelay : 300,\n                        label                : 'L{byName}',\n                        localeClass          : me,\n                        width                : 200,\n                        internalListeners    : {\n                            change  : me.onEventFilterChange,\n                            thisObj : me\n                        }\n                    }\n                },\n                onBeforeShow({ source : menu }) {\n                    const\n                        [filterByName] = menu.items,\n                        filter         = me.store.filters.getBy('property', 'name');\n\n                    filterByName.value = filter?.value || '';\n                }\n            }\n        };\n    }\n\n    onEventFilterChange({ value }) {\n        if (value !== '') {\n            this.store.filter('name', value);\n        }\n        else {\n            this.store.removeFilter('name');\n        }\n    }\n\n    get store() {\n        const { client } = this;\n\n        return client.isGanttBase ? client.store : client.eventStore;\n    }\n}\n\nEventFilter.featureClass = 'b-event-filter';\n\nGridFeatureManager.registerFeature(EventFilter, true, ['Scheduler', 'Gantt']);\nGridFeatureManager.registerFeature(EventFilter, false, 'ResourceHistogram');\n", "import DateHelper from '../../../Core/helper/DateHelper.js';\nimport TimeSpan from '../../model/TimeSpan.js';\n\n/**\n * @module Scheduler/feature/mixin/NonWorkingTimeMixin\n */\n\n/**\n * Mixin with functionality shared between {@link Scheduler/feature/NonWorkingTime} and\n * {@link Scheduler/feature/EventNonWorkingTime}.\n * @mixin\n */\nexport default Target => class NonWorkingTimeMixin extends Target {\n    static $name = 'NonWorkingTimeMixin';\n\n    static configurable = {\n        /**\n         * The maximum time axis unit to display non-working ranges for ('hour' or 'day' etc).\n         * When zooming to a view with a larger unit, no non-working time elements will be rendered.\n         *\n         * **Note:** Be careful with setting this config to big units like 'year'. When doing this,\n         * make sure the timeline {@link Scheduler/view/TimelineBase#config-startDate start} and\n         * {@link Scheduler/view/TimelineBase#config-endDate end} dates are set tightly.\n         * When using a long range (for example many years) with non-working time elements rendered per hour,\n         * you will end up with millions of elements, impacting performance.\n         * When zooming, use the {@link Scheduler/view/mixin/TimelineZoomable#config-zoomKeepsOriginalTimespan} config.\n         * @config {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'}\n         * @default\n         */\n        maxTimeAxisUnit : 'week'\n    };\n\n    getNonWorkingTimeRanges(calendar, startDate, endDate) {\n        if (!calendar.getNonWorkingTimeRanges) {\n            const result = [];\n\n            // <remove-on-release>\n            // TODO: Ask arcady if there is a built-in way for this\n            // </remove-on-release>\n\n            calendar.forEachAvailabilityInterval(\n                { startDate, endDate, isForward : true },\n                (intervalStartDate, intervalEndDate, calendarCacheInterval) => {\n                    for (const [entry, cache] of calendarCacheInterval.intervalGroups) {\n                        if (!cache.getIsWorking()) {\n                            result.push({\n                                name      : entry.name,\n                                iconCls   : entry.iconCls,\n                                cls       : entry.cls,\n                                startDate : intervalStartDate,\n                                endDate   : intervalEndDate\n                            });\n                        }\n                    }\n                }\n            );\n\n            return result;\n        }\n\n        return calendar.getNonWorkingTimeRanges(startDate, endDate);\n    }\n\n    getCalendarTimeRanges(calendar, ignoreName = false) {\n        const\n            me                      = this,\n            { timeAxis, fillTicks } = me.client,\n            { unit, increment }     = timeAxis,\n            shouldPaint             = !me.maxTimeAxisUnit || DateHelper.compareUnits(unit, me.maxTimeAxisUnit) <= 0;\n\n        if (calendar && shouldPaint && timeAxis.count) {\n            const\n                allRanges     = me.getNonWorkingTimeRanges(calendar, timeAxis.startDate, timeAxis.endDate),\n                timeSpans     = allRanges.map(interval => new TimeSpan({\n                    name      : interval.name,\n                    cls       : `b-nonworkingtime ${interval.cls || ''}`,\n                    startDate : interval.startDate,\n                    endDate   : interval.endDate\n                })),\n                mergedSpans = [];\n\n            let prevRange = null;\n\n            // intervals returned by the calendar are not merged, let's combine them to yield fewer elements\n            for (const range of timeSpans) {\n                if (prevRange && range.startDate <= prevRange.endDate && (ignoreName || range.name === prevRange.name) && range.duration > 0) {\n                    prevRange.endDate = range.endDate;\n                }\n                else {\n                    mergedSpans.push(range);\n                    range.setData('id', `nonworking-${mergedSpans.length}`);\n                    prevRange = range;\n                }\n            }\n\n            // When filling ticks, non-working-time ranges are cropped to full ticks too\n            if (fillTicks) {\n                mergedSpans.forEach(span => {\n                    span.setStartEndDate(\n                        DateHelper.ceil(span.startDate, { magnitude : increment, unit }),\n                        DateHelper.floor(span.endDate, { magnitude : increment, unit })\n                    );\n                });\n            }\n\n            return mergedSpans;\n        }\n        else {\n            return [];\n        }\n    }\n\n    //region Basic scheduler calendar\n\n    setupDefaultCalendar() {\n        const { client, project } = this;\n\n        if (\n            // Might have been set up by NonWorkingTime / EventNonWorkingTime already\n            !this.autoGeneratedWeekends &&\n            // For basic scheduler...\n            !client.isSchedulerPro &&\n            !client.isGantt &&\n            // ...that uses the default calendar...\n            project.effectiveCalendar === project.defaultCalendar &&\n            // ...and has no defined intervals\n            !project.defaultCalendar.intervalStore.count\n        ) {\n            this.autoGeneratedWeekends = true;\n            this.updateDefaultCalendar();\n        }\n    }\n\n    updateDefaultCalendar() {\n        if (this.autoGeneratedWeekends) {\n            const\n                calendar     = this.client.project.effectiveCalendar,\n                intervals    = this.defaultNonWorkingIntervals,\n                hasIntervals = Boolean(intervals.length);\n\n            // The default \"weekends\" calendar should not be time zone converted\n            calendar.ignoreTimeZone = true;\n\n            calendar.clearIntervals(hasIntervals);\n\n            // Update weekends as non-working time\n            if (hasIntervals) {\n                calendar.addIntervals(intervals);\n            }\n        }\n    }\n\n    updateLocalization() {\n        super.updateLocalization?.();\n\n        this.autoGeneratedWeekends && this.updateDefaultCalendar();\n    }\n\n    get defaultNonWorkingIntervals() {\n        const dayNames  = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];\n\n        return DateHelper.nonWorkingDaysAsArray.map(dayIndex => ({\n            recurrentStartDate : `on ${dayNames[dayIndex]} at 0:00`,\n            recurrentEndDate   : `on ${dayNames[(dayIndex + 1) % 7]} at 0:00`,\n            isWorking          : false\n        }));\n    }\n\n    //endregion\n};\n", "import AbstractTimeRanges from './AbstractTimeRanges.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\nimport AttachToProjectMixin from '../data/mixin/AttachToProjectMixin.js';\nimport NonWorkingTimeMixin from './mixin/NonWorkingTimeMixin.js';\n\n/**\n * @module Scheduler/feature/NonWorkingTime\n */\n\n/**\n * Feature that allows styling of weekends (and other non-working time) by adding timeRanges for those days.\n *\n * {@inlineexample Scheduler/feature/NonWorkingTime.js}\n *\n * By default, the basic Scheduler's calendar is empty. When enabling this feature in the basic Scheduler, it injects\n * Saturday and Sunday weekend intervals if no intervals are encountered. For Scheduler Pro, it visualizes the project\n * calendar and does not automatically inject anything. You have to define a Calendar in the application and assign it\n * to the project, for more information on how to do that, please see Scheduler Pro's Scheduling/Calendars guide.\n *\n * Please note that to not clutter the view (and have a large negative effect on performance) the feature does not\n * render ranges shorter than the base unit used by the time axis. The behavior can be disabled with\n * {@link #config-hideRangesOnZooming} config.\n *\n * The feature also bails out of rendering ranges for very zoomed out views completely for the same reasons (see\n * {@link #config-maxTimeAxisUnit} for details).\n *\n * Also note that the feature uses virtualized rendering, only the currently visible non-working-time ranges are\n * available in the DOM.\n *\n * This feature is **off** by default for Scheduler, but **enabled** by default for Scheduler Pro.\n * For info on enabling it, see {@link Grid/view/mixin/GridFeatures}.\n *\n * @extends Scheduler/feature/AbstractTimeRanges\n * @demo Scheduler/nonworkingdays\n * @classtype nonWorkingTime\n * @mixes Scheduler/feature/mixin/NonWorkingTimeMixin\n * @feature\n */\nexport default class NonWorkingTime extends AbstractTimeRanges.mixin(AttachToProjectMixin, NonWorkingTimeMixin) {\n    //region Default config\n\n    static $name = 'NonWorkingTime';\n\n    /** @hideconfigs enableResizing, store*/\n\n    static get defaultConfig() {\n        return {\n            /**\n             * Set to `true` to highlight non-working periods of time\n             * @config {Boolean}\n             * @deprecated Since 5.2.0, will be removed since the feature is pointless if set to false\n             */\n            highlightWeekends : null,\n\n            /**\n             * The feature by default does not render ranges smaller than the base unit used by the time axis.\n             * Set this config to `false` to disable this behavior.\n             *\n             * <div class=\"note\">The {@link #config-maxTimeAxisUnit} config defines a zoom level at which to bail out of\n             * rendering ranges completely.</div>\n             * @config {Boolean}\n             * @default\n             */\n            hideRangesOnZooming : true,\n\n            showHeaderElements : true,\n            showLabelInBody    : true,\n\n            autoGeneratedWeekends : false\n        };\n    }\n\n    static pluginConfig = {\n        chain : [\n            'onPaint',\n            'attachToProject',\n            'updateLocalization',\n            'onConfigChange',\n            'onSchedulerHorizontalScroll'\n        ]\n    };\n\n    //endregion\n\n    //region Init & destroy\n\n    doDestroy() {\n        this.attachToCalendar(null);\n        super.doDestroy();\n    }\n\n    set highlightWeekends(highlight) {\n        VersionHelper.deprecate('Scheduler', '6.0.0', 'Deprecated in favour of disabling the feature');\n\n        this.disabled = !highlight;\n    }\n\n    get highlightWeekends() {\n        return !this.disabled;\n    }\n\n    onConfigChange({ name }) {\n        if (!this.isConfiguring && name === 'fillTicks') {\n            this.refresh();\n        }\n    }\n\n    //endregion\n\n    //region Project\n\n    attachToProject(project) {\n        super.attachToProject(project);\n\n        this.attachToCalendar(project.effectiveCalendar);\n\n        // if there's no graph yet - need to delay this call until it appears, but not for scheduler\n        if (!project.graph && !this.client.isScheduler) {\n            project.ion({\n                name      : 'project',\n                dataReady : { fn : () => this.attachToCalendar(project.effectiveCalendar), once : true },\n                thisObj   : this\n            });\n        }\n\n        project.ion({\n            name           : 'project',\n            calendarChange : () => this.attachToCalendar(project.effectiveCalendar),\n            thisObj        : this\n        });\n    }\n\n    //endregion\n\n    //region TimeAxisViewModel\n\n    onTimeAxisViewModelUpdate(...args) {\n        this._timeAxisUnitDurationMs = null;\n        return super.onTimeAxisViewModelUpdate(...args);\n    }\n\n    //endregion\n\n    //region Calendar\n\n    attachToCalendar(calendar) {\n        const\n            me                  = this,\n            { project, client } = me;\n\n        me.detachListeners('calendar');\n\n        me.autoGeneratedWeekends = false;\n\n        if (calendar) {\n            // Sets up a default weekend calendar for basic Scheduler, when no calendar is set\n            me.setupDefaultCalendar();\n\n            calendar.intervalStore.ion({\n                name   : 'calendar',\n                change : () => me.setTimeout(() => me.refresh(), 1)\n            });\n        }\n\n        // On changing calendar we react to a data level event which is triggered after project refresh.\n        // Redraw right away\n        if (client.isEngineReady && !client.project.isDelayingCalculation && !client.isDestroying) {\n            me.refresh();\n        }\n        // Initially there is no guarantee we are ready to draw, wait for refresh\n        else if (!project.isDestroyed) {\n            me.detachListeners('initialProjectListener');\n            project.ion({\n                name : 'initialProjectListener',\n                refresh({ isCalculated }) {\n                    // Cant render early, have to wait for calculations\n                    if (isCalculated !== false) {\n                        me.refresh();\n                        me.detachListeners('initialProjectListener');\n                    }\n                },\n                thisObj : me\n            });\n        }\n    }\n\n    get calendar() {\n        return this.project?.effectiveCalendar;\n    }\n\n    //endregion\n\n    //region Draw\n\n    get timeAxisUnitDurationMs() {\n        // calculate and cache duration of the timeAxis unit in milliseconds\n        if (!this._timeAxisUnitDurationMs) {\n            this._timeAxisUnitDurationMs = DateHelper.as('ms', 1, this.client.timeAxis.unit);\n        }\n\n        return this._timeAxisUnitDurationMs;\n    }\n\n    /**\n     * Based on this method result the feature decides whether the provided non-working period should\n     * be rendered or not.\n     * The method checks that the range has non-zero {@link Scheduler.model.TimeSpan#field-duration},\n     * lays in the visible timespan and its duration is longer or equal the base timeaxis unit\n     * (if {@link #config-hideRangesOnZooming} is `true`).\n     *\n     * Override the method to implement your custom range rendering vetoing logic.\n     * @param {Scheduler.model.TimeSpan} range Range to render.\n     * @returns {Boolean} `true` if the range should be rendered and `false` otherwise.\n     */\n    shouldRenderRange(range) {\n        // if the range is longer or equal than one timeAxis unit then render it\n        return super.shouldRenderRange(range) && (!this.hideRangesOnZooming || range.durationMS >= this.timeAxisUnitDurationMs);\n    }\n\n    // Calendar intervals as TimeSpans, with adjacent intervals merged to create fewer\n    get timeRanges() {\n        const me = this;\n\n        if (!me._timeRanges) {\n            me._timeRanges = me.getCalendarTimeRanges(me.calendar);\n        }\n\n        return me._timeRanges;\n    }\n\n    //endregion\n}\n\nGridFeatureManager.registerFeature(NonWorkingTime, false, 'Scheduler');\nGridFeatureManager.registerFeature(NonWorkingTime, true, ['SchedulerPro', 'Gantt', 'ResourceHistogram']);\n", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\nimport ClockTemplate from '../tooltip/ClockTemplate.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\n\n/**\n * @module Scheduler/feature/ScheduleTooltip\n */\n\n/**\n * Feature that displays a tooltip containing the time at the mouse position when hovering empty parts of the schedule.\n * To hide the schedule tooltip, just disable this feature:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         scheduleTooltip : false\n *     }\n * });\n * ```\n *\n * You can also output a message along with the default time indicator (to indicate resource availability etc)\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *    features : {\n *       scheduleTooltip : {\n *           getText(date, event, resource) {\n *               return 'Hovering ' + resource.name;\n *           }\n *       }\n *   }\n * });\n * ```\n *\n * To take full control over the markup shown in the tooltip you can override the {@link #function-generateTipContent} method:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         scheduleTooltip : {\n *             generateTipContent({ date, event, resourceRecord }) {\n *                 return `\n *                     <dl>\n *                         <dt>Date</dt><dd>${date}</dd>\n *                         <dt>Resource</dt><dd>${resourceRecord.name}</dd>\n *                     </dl>\n *                 `;\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Configuration properties from the feature are passed down into the resulting {@link Core.widget.Tooltip} instance.\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         scheduleTooltip : {\n *             // Don't show the tip until the mouse has been over the schedule for three seconds\n *             hoverDelay : 3000\n *         }\n *     }\n * });\n * ```\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Scheduler/basic\n * @inlineexample Scheduler/feature/ScheduleTooltip.js\n * @classtype scheduleTooltip\n * @feature\n */\nexport default class ScheduleTooltip extends InstancePlugin {\n    //region Config\n\n    static get $name() {\n        return 'ScheduleTooltip';\n    }\n\n    static get configurable() {\n        return {\n            messageTemplate : data => `<div class=\"b-sch-hovertip-msg\">${data.message}</div>`,\n\n            /**\n             * Set to `true` to hide this tooltip when hovering non-working time. Defaults to `false` for Scheduler,\n             * `true` for SchedulerPro\n             * @config {Boolean}\n             */\n            hideForNonWorkingTime : null\n        };\n    }\n\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['onPaint']\n        };\n    }\n\n    //endregion\n\n    //region Init\n\n    /**\n     * Set up drag and drop and hover tooltip.\n     * @private\n     */\n    onPaint({ firstPaint }) {\n        if (!firstPaint) {\n            return;\n        }\n\n        const\n            me         = this,\n            { client } = me;\n\n        if (client.isSchedulerPro && me.hideForNonWorkingTime === undefined) {\n            me.hideForNonWorkingTime = true;\n        }\n\n        let reshowListener;\n\n        const tip = me.hoverTip = new Tooltip({\n            id                       : `${client.id}-schedule-tip`,\n            cls                      : 'b-sch-scheduletip',\n            allowOver                : true,\n            hoverDelay               : 0,\n            hideDelay                : 100,\n            showOnHover              : true,\n            forElement               : client.timeAxisSubGridElement,\n            anchorToTarget           : false,\n            trackMouse               : true,\n            updateContentOnMouseMove : true,\n            // disable text content and monitor resize for tooltip, otherwise it doesn't\n            // get sized properly on first appearance\n            monitorResize            : false,\n            textContent              : false,\n            forSelector              : '.b-schedulerbase:not(.b-dragging-event):not(.b-dragcreating) .b-grid-body-container:not(.b-scrolling) .b-timeline-subgrid:not(.b-scrolling) > :not(.b-sch-foreground-canvas):not(.b-group-footer):not(.b-group-row) *',\n            // Do not constrain at all, want it to be able to go outside of the viewport to not get in the way\n            getHtml                  : me.getHoverTipHtml.bind(me),\n            onDocumentMouseDown(event) {\n                // Click on the scheduler hides until the very next\n                // non-button-pressed mouse move!\n                if (tip.forElement.contains(event.event.target)) {\n                    reshowListener = EventHelper.on({\n                        thisObj   : me,\n                        element   : client.timeAxisSubGridElement,\n                        mousemove : e => tip.internalOnPointerOver(e),\n                        capture   : true\n                    });\n                }\n\n                const hideAnimation = tip.hideAnimation;\n                tip.hideAnimation = false;\n                tip.constructor.prototype.onDocumentMouseDown.call(tip, event);\n                tip.hideAnimation = hideAnimation;\n            },\n            // on Core/mixin/Events constructor, me.config.listeners is deleted and attributed its value to me.configuredListeners\n            // to then on processConfiguredListeners it set me.listeners to our TooltipBase\n            // but since we need our initial config.listeners to set to our internal tooltip, we leave processConfiguredListeners empty\n            // to avoid lost our listeners to apply for our internal tooltip here and force our feature has all Tooltip events firing\n            ...me.config,\n            internalListeners : me.configuredListeners\n        });\n\n        // We have to add our own listener after instantiation because it may conflict with a configured listener\n        tip.ion({\n            pointerover({ event }) {\n                const buttonsPressed = 'buttons' in event ? event.buttons > 0\n                    : event.which > 0; // fallback for Safari which doesn't support 'buttons'\n\n                // This is the non-button-pressed mousemove\n                // after the document mousedown\n                if (!buttonsPressed && reshowListener) {\n                    reshowListener();\n                }\n\n                // Never any tooltip while interaction is ongoing and a mouse button is pressed\n                return !me.disabled && !buttonsPressed;\n            },\n            innerhtmlupdate({ source }) {\n                me.clockTemplate.updateDateIndicator(source.element, me.lastTime);\n            }\n        });\n\n        // Update tooltip after zooming\n        client.ion({\n            timeAxisViewModelUpdate : 'updateTip',\n            thisObj                 : me\n        });\n\n        me.clockTemplate = new ClockTemplate({\n            scheduler : client\n        });\n    }\n\n    // leave configuredListeners alone until render time at which they are used on the tooltip\n    processConfiguredListeners() {}\n\n    updateTip() {\n        if (this.hoverTip.isVisible) {\n            this.hoverTip.updateContent();\n        }\n    }\n\n    doDestroy() {\n        this.destroyProperties('clockTemplate', 'hoverTip');\n        super.doDestroy();\n    }\n\n    //endregion\n\n    //region Contents\n\n    /**\n     * @deprecated Use {@link #function-generateTipContent} instead.\n     * Gets html to display in hover tooltip (tooltip displayed on empty parts of scheduler)\n     * @private\n     */\n    getHoverTipHtml({ tip, event }) {\n        const\n            me        = this,\n            scheduler = me.client,\n            date      = event && scheduler.getDateFromDomEvent(event, 'floor', true);\n\n        let html      = me.lastHtml;\n\n        // event.target might be null in the case of being hosted in a web component https://github.com/bryntum/bryntum-suite/pull/4488\n        if (date && event.target) {\n            const resourceRecord = scheduler.resolveResourceRecord(event);\n\n            // resourceRecord might be null if user hover over the tooltip, but we shouldn't hide the tooltip in this case\n            if ((resourceRecord && (date - me.lastTime !== 0 || resourceRecord.id !== me.lastResourceId))) {\n                if (me.hideForNonWorkingTime) {\n                    const isWorkingTime = resourceRecord.isWorkingTime(date);\n\n                    tip.element.classList.toggle('b-nonworking-time', !isWorkingTime);\n                }\n\n                me.lastResourceId = resourceRecord.id;\n                html              = me.lastHtml = me.generateTipContent({ date, event, resourceRecord });\n            }\n        }\n        else {\n            tip.hide();\n            me.lastTime = null;\n            me.lastResourceId = null;\n        }\n\n        return html;\n    }\n\n    /**\n     * Called as mouse pointer is moved over a new resource or time block. You can override this to show\n     * custom HTML in the tooltip.\n     * @param {Object} context\n     * @param {Date} context.date The date of the hovered point\n     * @param {Event} context.event The DOM event that triggered this tooltip to show\n     * @param {Scheduler.model.ResourceModel} context.resourceRecord The resource record\n     * @returns {String} The HTML contents to show in the tooltip (an empty return value will hide the tooltip)\n     */\n    generateTipContent({ date, event, resourceRecord }) {\n        const\n            me          = this,\n            clockHtml   = me.clockTemplate.generateContent({\n                date,\n                text : me.client.getFormattedDate(date)\n            }),\n            messageHtml = me.messageTemplate({\n                message : me.getText(date, event, resourceRecord) || ''\n            });\n\n        me.lastTime = date;\n\n        return clockHtml + messageHtml;\n    }\n\n    /**\n     * Override this to render custom text to default hover tip\n     * @param {Date} date\n     * @param {Event} event Browser event\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @returns {String}\n     */\n    getText(date, event, resourceRecord) {}\n\n    //endregion\n}\n\n// <remove-on-release>\n// TODO: Refactor SASS so that auto-generated class name of 'b-' + cls.name.toLowerCase() can be used.\n// </remove-on-release>\nScheduleTooltip.featureClass = 'b-scheduletip';\n\nGridFeatureManager.registerFeature(ScheduleTooltip, true, 'Scheduler');\nGridFeatureManager.registerFeature(ScheduleTooltip, false, 'ResourceUtilization');\n", "import HeaderMenu from '../../Grid/feature/HeaderMenu.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport '../../Core/widget/Slider.js';\n\n/**\n * @module Scheduler/feature/TimeAxisHeaderMenu\n */\nconst setTimeSpanOptions = {\n    maintainVisibleStart : true\n};\n\n/**\n * Adds scheduler specific menu items to the timeline header context menu.\n *\n * ## Default timeaxis header menu items\n *\n * Here is the list of menu items provided by this and other features:\n *\n * | Reference          | Text                  | Weight | Feature                                           | Description                  |\n * |--------------------|-----------------------|--------|---------------------------------------------------|------------------------------|\n * | `eventsFilter`     | Filter tasks          | 100    | {@link Scheduler.feature.EventFilter EventFilter} | Submenu for event filtering  |\n * | \\>`nameFilter`     | By name               | 110    | {@link Scheduler.feature.EventFilter EventFilter} | Filter by `name`             |\n * | `zoomLevel`        | Zoom                  | 200    | *This feature*                                    | Submenu for timeline zooming |\n * | \\>`zoomSlider`     | -                     | 210    | *This feature*                                    | Changes current zoom level   |\n * | `dateRange`        | Date range            | 300    | *This feature*                                    | Submenu for timeline range   |\n * | \\>`startDateField` | Start date            | 310    | *This feature*                                    | Start date for the timeline  |\n * | \\>`endDateField`   | End date              | 320    | *This feature*                                    | End date for the timeline    |\n * | \\>`leftShiftBtn`   | <                     | 330    | *This feature*                                    | Shift backward               |\n * | \\>`todayBtn`       | Today                 | 340    | *This feature*                                    | Go to today                  |\n * | \\>`rightShiftBtn`  | \\>                    | 350    | *This feature*                                    | Shift forward                |\n * | `currentTimeLine`  | Show current timeline | 400    | {@link Scheduler.feature.TimeRanges TimeRanges}   | Show current time line       |\n *\n * \\> - first level of submenu\n *\n * ## Customizing the menu items\n *\n * The menu items in the TimeAxis Header menu can be customized, existing items can be changed or removed,\n * and new items can be added. This is handled using the `items` config of the feature.\n *\n * ### Add extra items:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         timeAxisHeaderMenu : {\n *             items : {\n *                 extraItem : {\n *                     text : 'Extra',\n *                     icon : 'b-fa b-fa-fw b-fa-flag',\n *                     onItem() {\n *                         ...\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * ### Remove existing items:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         timeAxisHeaderMenu : {\n *             items : {\n *                 zoomLevel : false\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * ### Customize existing item:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         timeAxisHeaderMenu : {\n *             items : {\n *                 zoomLevel : {\n *                     text : 'Scale'\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * ### Customizing submenu items:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *      features : {\n *          timeAxisHeaderMenu : {\n *              items : {\n *                  dateRange : {\n *                      menu : {\n *                          items : {\n *                              todayBtn : {\n *                                  text : 'Now'\n *                              }\n *                          }\n *                      }\n *                  }\n *              }\n *          }\n *      }\n * });\n * ```\n *\n * ### Manipulate existing items:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         timeAxisHeaderMenu : {\n *             // Process items before menu is shown\n *             processItems({ items }) {\n *                  // Add an extra item dynamically\n *                 items.coolItem = {\n *                     text : 'Cool action',\n *                     onItem() {\n *                           // ...\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Full information of the menu customization can be found in the [\"Customizing the Event menu, the Schedule menu, and the TimeAxisHeader menu\"](#Scheduler/guides/customization/contextmenu.md)\n * guide.\n *\n * This feature is **enabled** by default\n *\n * @extends Grid/feature/HeaderMenu\n * @demo Scheduler/basic\n * @classtype timeAxisHeaderMenu\n * @feature\n * @inlineexample Scheduler/feature/TimeAxisHeaderMenu.js\n */\nexport default class TimeAxisHeaderMenu extends HeaderMenu {\n\n    //region Config\n\n    static get $name() {\n        return 'TimeAxisHeaderMenu';\n    }\n\n    static get defaultConfig() {\n        return {\n            /**\n             * A function called before displaying the menu that allows manipulations of its items.\n             * Returning `false` from this function prevents the menu being shown.\n             *\n             * ```javascript\n             *   features         : {\n             *       timeAxisHeaderMenu : {\n             *           processItems({ items }) {\n             *               // Add or hide existing items here as needed\n             *               items.myAction = {\n             *                   text   : 'Cool action',\n             *                   icon   : 'b-fa b-fa-fw b-fa-ban',\n             *                   onItem : () => console.log('Some coolness'),\n             *                   weight : 300 // Move to end\n             *               };\n             *\n             *               // Hide zoom slider\n             *               items.zoomLevel.hidden = true;\n             *           }\n             *       }\n             *   },\n             * ```\n             *\n             * @param {Object} context An object with information about the menu being shown\n             * @param {Object<String,MenuItemConfig>} context.items An object containing the {@link Core.widget.MenuItem menu item} configs keyed by their id\n             * @param {Event} context.event The DOM event object that triggered the show\n             * @config {Function}\n             * @preventable\n             */\n            processItems : null,\n\n            /**\n             * This is a preconfigured set of items used to create the default context menu.\n             *\n             * The `items` provided by this feature are listed in the intro section of this class. You can\n             * configure existing items by passing a configuration object to the keyed items.\n             *\n             * To remove existing items, set corresponding keys `null`:\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         timeAxisHeaderMenu : {\n             *             items : {\n             *                 eventsFilter : null\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             *\n             * See the feature config in the above example for details.\n             *\n             * @config {Object<String,MenuItemConfig|Boolean|null>} items\n             */\n            items : null,\n\n            type : 'timeAxisHeader'\n        };\n    }\n\n    static get pluginConfig() {\n        const config = super.pluginConfig;\n\n        config.chain.push('populateTimeAxisHeaderMenu');\n\n        return config;\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * This event fires on the owning Scheduler before the context menu is shown for the time axis header.\n     * Allows manipulation of the items to show in the same way as in the {@link #config-processItems}.\n     *\n     * Returning `false` from a listener prevents the menu from being shown.\n     *\n     * @event timeAxisHeaderMenuBeforeShow\n     * @on-owner\n     * @preventable\n     * @param {Scheduler.view.Scheduler} source The scheduler\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Object<String,MenuItemConfig>} items Menu item configs\n     * @param {Grid.column.Column} column Time axis column\n     */\n\n    /**\n     * This event fires on the owning Scheduler after the context menu is shown for a header\n     * @event timeAxisHeaderMenuShow\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source The scheduler\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Object<String,MenuItemConfig>} items Menu item configs\n     * @param {Grid.column.Column} column Time axis column\n     */\n\n    /**\n     * This event fires on the owning Scheduler when an item is selected in the header context menu.\n     * @event timeAxisHeaderMenuItem\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source The scheduler\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Core.widget.MenuItem} item Selected menu item\n     * @param {Grid.column.Column} column Time axis column\n     */\n\n    //endregion\n\n    construct() {\n        super.construct(...arguments);\n\n        if (this.triggerEvent.includes('click') && this.client.zoomOnTimeAxisDoubleClick) {\n            this.client.zoomOnTimeAxisDoubleClick = false;\n        }\n    }\n\n    shouldShowMenu(eventParams) {\n        const\n            { column, targetElement } = eventParams,\n            { client } = this;\n\n        if (client.isHorizontal) {\n            return column?.enableHeaderContextMenu !== false && column?.isTimeAxisColumn;\n        }\n\n        return targetElement.matches('.b-sch-header-timeaxis-cell');\n    }\n\n    showContextMenu(eventParams) {\n        super.showContextMenu(...arguments);\n\n        if (this.menu) {\n            // the TimeAxis's context menu probably will cause scrolls because it manipulates the dates.\n            // The menu should not hide on scroll when for a TimeAxisColumn\n            this.menu.scrollAction = 'realign';\n        }\n    }\n\n    populateTimeAxisHeaderMenu({ items }) {\n        const\n            me         = this,\n            { client } = me,\n            dateStep   = {\n                magnitude : client.timeAxis.shiftIncrement,\n                unit      : client.timeAxis.shiftUnit\n            };\n\n        Object.assign(items, {\n            zoomLevel : {\n                text        : 'L{pickZoomLevel}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-search-plus',\n                disabled    : !client.presets.count || me.disabled,\n                weight      : 200,\n                menu        : {\n                    type  : 'popup',\n                    items : {\n                        zoomSlider : {\n                            weight               : 210,\n                            type                 : 'slider',\n                            minWidth             : 130,\n                            showValue            : false,\n                            // so that we can use the change event which is easier to inject in tests\n                            triggerChangeOnInput : true\n                        }\n                    },\n                    onBeforeShow({ source : menu }) {\n                        const [zoom] = menu.items;\n\n                        zoom.min = client.minZoomLevel;\n                        zoom.max = client.maxZoomLevel;\n                        zoom.value = client.zoomLevel;\n\n                        // Default slider value is 50 which causes the above to trigger onZoomSliderChange (when\n                        // maxZoomLevel < 50) if we add our listener prior to this point.\n                        me.zoomDetatcher = zoom.ion({ change : 'onZoomSliderChange', thisObj : me });\n                    },\n                    onHide() {\n                        if (me.zoomDetatcher) {\n                            me.zoomDetatcher();\n                            me.zoomDetatcher = null;\n                        }\n                    }\n                }\n            },\n            dateRange : {\n                text        : 'L{activeDateRange}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-calendar',\n                weight      : 300,\n                menu        : {\n                    type     : 'popup',\n                    cls      : 'b-sch-timeaxis-menu-daterange-popup',\n                    defaults : {\n                        localeClass : me\n                    },\n                    items : {\n                        startDateField : {\n                            type              : 'datefield',\n                            label             : 'L{startText}',\n                            weight            : 310,\n                            labelWidth        : '6em',\n                            required          : true,\n                            step              : dateStep,\n                            internalListeners : {\n                                change  : me.onRangeDateFieldChange,\n                                thisObj : me\n                            }\n                        },\n                        endDateField : {\n                            type              : 'datefield',\n                            label             : 'L{endText}',\n                            weight            : 320,\n                            labelWidth        : '6em',\n                            required          : true,\n                            step              : dateStep,\n                            internalListeners : {\n                                change  : me.onRangeDateFieldChange,\n                                thisObj : me\n                            }\n                        },\n                        leftShiftBtn : {\n                            type              : 'button',\n                            weight            : 330,\n                            cls               : 'b-left-nav-btn',\n                            icon              : 'b-icon b-icon-previous',\n                            color             : 'b-blue b-raised',\n                            flex              : 1,\n                            margin            : 0,\n                            internalListeners : {\n                                click   : me.onLeftShiftBtnClick,\n                                thisObj : me\n                            }\n                        },\n                        todayBtn : {\n                            type              : 'button',\n                            weight            : 340,\n                            cls               : 'b-today-nav-btn',\n                            color             : 'b-blue b-raised',\n                            text              : 'L{todayText}',\n                            flex              : 4,\n                            margin            : '0 8',\n                            internalListeners : {\n                                click   : me.onTodayBtnClick,\n                                thisObj : me\n                            }\n                        },\n                        rightShiftBtn : {\n                            type              : 'button',\n                            weight            : 350,\n                            cls               : 'b-right-nav-btn',\n                            icon              : 'b-icon b-icon-next',\n                            color             : 'b-blue b-raised',\n                            flex              : 1,\n                            internalListeners : {\n                                click   : me.onRightShiftBtnClick,\n                                thisObj : me\n                            }\n                        }\n                    },\n                    internalListeners : {\n                        paint   : me.initDateRangeFields,\n                        thisObj : me\n                    }\n                }\n            }\n        });\n    }\n\n    onZoomSliderChange({ value }) {\n        const me = this;\n\n        // Zooming maintains timeline center point by scrolling the newly rerendered timeline to the\n        // correct point to maintain the visual center. Temporarily inhibit context menu hide on scroll\n        // of its context element.\n        me.menu.scrollAction = 'realign';\n\n        me.client.zoomLevel = value;\n\n        me.menu.setTimeout({\n            fn                : () => me.menu.scrollAction = 'hide',\n            delay             : 100,\n            cancelOutstanding : true\n        });\n    }\n\n    initDateRangeFields({ source : dateRange, firstPaint }) {\n        if (firstPaint) {\n            const { widgetMap } = dateRange;\n\n            this.startDateField = widgetMap.startDateField;\n            this.endDateField = widgetMap.endDateField;\n        }\n\n        this.initDates();\n    }\n\n    initDates() {\n        const me = this;\n\n        me.startDateField.suspendEvents();\n        me.endDateField.suspendEvents();\n\n        // The actual scheduler start dates may include time, but our Date field cannot currently handle\n        // a time portion and throws it away, so when we need the value from an unchanged field, we need\n        // to use the initialValue set from the timeAxis values.\n        // Until our DateField can optionally include a time value, this is the solution.\n        me.startDateField.value = me.startDateFieldInitialValue = me.client.startDate;\n        me.endDateField.value = me.endDateFieldInitialValue = me.client.endDate;\n\n        me.startDateField.resumeEvents();\n        me.endDateField.resumeEvents();\n    }\n\n    onRangeDateFieldChange({ source }) {\n        const\n            me               = this,\n            startDateChanged = (source === me.startDateField),\n            { client }       = me,\n            { timeAxis }     = client,\n            startDate        = me.startDateFieldInitialValue && !startDateChanged ? me.startDateFieldInitialValue : me.startDateField.value;\n\n        let endDate = me.endDateFieldInitialValue && startDateChanged ? me.endDateFieldInitialValue : me.endDateField.value;\n\n        // When either of the fields is changed, we no longer use its initialValue from the timeAxis start or end\n        // so that gets nulled to indicate that it's unavailable and the real field value is to be used.\n        if (startDateChanged) {\n            me.startDateFieldInitialValue = null;\n        }\n        else {\n            me.endDateFieldInitialValue = null;\n        }\n\n        // Because the start and end dates are exclusive, avoid a zero\n        // length time axis by incrementing the end by one tick unit\n        // if they are the same.\n        if (!(endDate - startDate)) {\n            endDate = DateHelper.add(endDate, timeAxis.shiftIncrement, timeAxis.shiftUnit);\n        }\n        // if start date got bigger than end date set end date to start date plus one tick\n        else if (endDate < startDate) {\n            endDate = DateHelper.add(startDate, timeAxis.shiftIncrement, timeAxis.shiftUnit);\n        }\n\n        // setTimeSpan will try to keep the scroll position the same.\n        client.setTimeSpan(startDate, endDate, setTimeSpanOptions);\n\n        me.initDates();\n    }\n\n    onLeftShiftBtnClick() {\n        this.client.timeAxis.shiftPrevious();\n        this.initDates();\n    }\n\n    onTodayBtnClick() {\n        const today = DateHelper.clearTime(new Date());\n\n        this.client.setTimeSpan(today, DateHelper.add(today, 1, 'day'));\n        this.initDates();\n    }\n\n    onRightShiftBtnClick() {\n        this.client.timeAxis.shiftNext();\n        this.initDates();\n    }\n}\n\nGridFeatureManager.registerFeature(TimeAxisHeaderMenu, true, ['Scheduler', 'TimelineHistogram', 'Gantt']);\n"],
  "mappings": "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",
  "names": ["Base", "initialize", "props", "Object", "assign", "new", "instance", "CalendarCacheIntervalMultiple", "constructor", "config", "intervalGroups", "combineWith", "interval", "copy", "slice", "push", "calendar", "getIsWorkingForEvery", "isWorkingForEvery", "_calendar", "intervals", "getGroups", "isWorking", "getIsWorkingForSome", "isWorkingForSome", "getCalendars", "calendars", "isCalendarWorking", "getCalendarsWorkStatus", "get", "calendarsWorkStatus", "res", "Map", "set", "getCalendarsWorking", "calendarsWorking", "getCalendarsNonWorking", "calendarsNonWorking", "intervalsByCalendar", "forEach", "data", "apply", "unique", "stripDuplicates", "sort", "interval1", "interval2", "getPriorityField", "CalendarCacheMultiple", "CalendarCache", "calendarCaches", "intervalCache", "IntervalCache", "emptyInterval", "combineIntervalsFn", "fillCache", "startDate", "endDate", "calendarCache", "includeWrappingRangeFrom", "COMBINED_CALENDARS_CACHE", "combineCalendars", "uniqueOnly", "length", "Error", "calendar1", "calendar2", "internalId", "hash", "map", "join", "versionsHash", "version", "cached", "cache", "DurationColumn", "NumberColumn", "compositeField", "$name", "type", "isGanttColumn", "fields", "name", "defaultValue", "defaults", "min", "max", "step", "largeStep", "field", "text", "instantUpdate", "filterType", "sortable", "durationEntity1", "durationEntity2", "ms1", "getValue", "ms2", "construct", "arguments", "sortFn", "args", "call", "defaultEditor", "ObjectHelper", "cleanupProperties", "durationUnitField", "roundValue", "duration", "nbrDecimals", "grid", "durationDisplayPrecision", "decimalPrecision", "multiplier", "Math", "pow", "round", "formatValue", "durationUnit", "Duration", "unit", "magnitude", "DateHelper", "getLocalizedNameOfUnit", "defaultRenderer", "value", "record", "isExport", "durationValue", "toClipboardString", "toString", "fromClipboardString", "string", "parseDuration", "fullDuration", "calculateFillValue", "ColumnStore", "registerColumnType", "_$name", "DragBase", "InstancePlugin", "defaultConfig", "tooltipTemplate", "valid", "startClockHtml", "endClockHtml", "message", "showTooltip", "showExactDropPosition", "store", "dragHelperConfig", "tooltipCls", "configurable", "constrainDragToTimeline", "constrainDragToResource", "constrainDragToTimeSlot", "tip", "$config", "align", "allowTargetOut", "autoShow", "updateContentOnMouseMove", "throttleDragEvent", "pluginConfig", "chain", "internalSnapToPosition", "snapTo", "_this$snapToPosition", "dragData", "snapToPosition", "assignmentRecord", "eventRecord", "resourceRecord", "newResource", "buildDragHelperConfig", "me", "client", "timeAxisViewModel", "isHorizontal", "lockY", "lockX", "externalDropTargetSelector", "dropTargetSelector", "Objects", "merge", "positioning", "minX", "maxX", "constrain", "cloneTarget", "removeProxyAfterDrop", "dragWithin", "document", "body", "hideOriginalElement", "dropTargetCls", "outerElement", "timeAxisSubGridElement", "targetSelector", "eventSelector", "scrollManager", "createProxy", "el", "snapCoordinates", "element", "newX", "newY", "snap", "draggedEventRecord", "draggedEntities", "coordinate", "getCoordinate", "snappedDate", "getDateFromPosition", "isWorkingTime", "add", "snappedPosition", "getPositionFromDate", "x", "y", "internalListeners", "beforedragstart", "dragstart", "afterdragstart", "drag", "drop", "abort", "abortFinalized", "reset", "thisObj", "isElementDraggable", "event", "onPaint", "firstPaint", "_me$drag", "destroy", "DragHelper", "rowManager", "ion", "changeTotalHeight", "_me$dragData", "updateYConstraint", "scheduledEventName", "clockTemplate", "ClockTemplate", "scheduler", "doDestroy", "_this$drag", "_this$clockTemplate", "_this$tip", "tipId", "id", "changeTip", "oldTip", "result", "Tooltip", "reconfigure", "mergeConfigs", "forElement", "getHtml", "getTipHtml", "bind", "cls", "owner", "innerHtmlUpdate", "proxy", "cloneNode", "classList", "mode", "onBeforeDragStart", "context", "getMinimalDragData", "readOnly", "disabled", "isDraggable", "pointerStartDate", "getDateFromXY", "startClientX", "startPageY", "triggerBeforeEventDrag", "capitalizedEventName", "_client", "onAfterDragStart", "isDragging", "_this$drag2", "isActivelyDragging", "finalizing", "onDragStart", "_client2", "_menuFeature$hideCont", "findClientFromTarget", "currentOverClient", "unifiedProxy", "unifiedDrag", "onMouseOverNewTimeline", "getDragData", "suspendElementRedrawing", "tipTarget", "dragProxy", "firstChild", "showBy", "triggerDragStart", "eventMenu", "taskMenu", "features", "menuFeature", "hideContextMenu", "updateDateIndicator", "endDateElement", "querySelector", "target", "test", "center", "Rectangle", "from", "DomHelper", "elementFromPoint", "Widget", "fromElement", "isResourceHistogram", "onDrag", "dd", "start", "updateDragContext", "dirty", "triggerEventDrag", "externalDragValidity", "lastAlignSpec", "realign", "newTimeline", "initial", "scrollables", "remove", "stopMonitoring", "timeAxisSubGrid", "scrollable", "direction", "startMonitoring", "callback", "onScrollManagerScrollCallback", "triggerBeforeEventDropFinalize", "eventType", "eventData", "trigger", "onDrop", "_me$tip", "modified", "hide", "isValidDrop", "Boolean", "externalDropTarget", "beforeDropTriggered", "finalize", "async", "domEvent", "origStart", "onDragAbort", "_me$currentOverClient", "_me$tip2", "currentOrientation", "resetDraggedElements", "triggerDragAbort", "onDragAbortFinalized", "_me$client", "_me$client2", "triggerDragAbortFinalized", "onDragReset", "source", "dragHelper", "_dragHelper$context", "currentTimeline", "started", "eventBarEls", "resumeRecordElementRedrawing", "i", "draggingCls", "retainElement", "onInternalInvalidDrop", "_me$tip3", "triggerAfterDrop", "updateRecords", "clientEventTipFeature", "taskTooltip", "eventTooltip", "isPromise", "refreshRows", "enabled", "setTimeout", "info", "isAssignment", "lastDragStartDate", "constrainToTimeSlot", "browserEvent", "getProductDragContext", "timeDiff", "timeAxis", "isContinuous", "timeAxisPosition", "pageX", "startPageX", "pageY", "pointerDate", "getDateFromCoordinate", "range", "resolveStartEndDates", "adjustStartDate", "positionDirty", "L", "checkDragValidity", "_dd$externalDragValid", "suspendRecordElementRedrawing", "suspend", "getRecordElement", "instanceMeta", "resumeElementRedrawing", "productDragData", "setupProductDragData", "startEvent", "timespan", "origEnd", "startsOutsideView", "endsOutsideView", "multiSelect", "isSchedulerBase", "multiEventSelect", "selectionMode", "elementStartX", "elementStartY", "clientCoordinate", "startClientY", "selectAssignment", "ctrlKey", "selectEvent", "sourceDate", "screenSourceDate", "relatedElements", "setupConstraints", "constrainRegion", "elRegion", "tickSize", "constrained", "xTickSize", "yTickSize", "setXConstraint", "left", "right", "width", "setYConstraint", "top", "bottom", "height", "snapPixelAmount", "getScheduleRegion", "offsetHeight", "iLeft", "iRight", "iTickSize", "iUp", "iDown", "minY", "maxY", "rounded", "roundDate", "Date", "snapRelativeToEventStartDate", "constrainStartDate", "draggedElement", "timeline", "proxyRect", "eventInnerSelector", "fillSnap", "fillTicks", "end", "getStartEndDatesFromRectangle", "offsetMS", "startOf", "proxyMS", "offsetPx", "deflate", "proxyStart", "getStart", "rtl", "isVertical", "dateInAxis", "tick", "getTickFromDate", "getDateFromTick", "startText", "getFormattedDate", "endText", "getFormattedEndDate", "dragged", "timeSpanRecord", "isTask", "template", "date", "isMilestone", "updateConstrainDragToTimeSlot", "axis", "updateConstrainDragToResource", "updateConstrainDragToTimeline", "isConfiguring", "dateConstraints", "scheduleableRecord", "taskRecord", "durationMS", "getElementFromContext", "grabbed", "getRelatedRecords", "coord", "tipAlign", "EventResize", "mixin", "Draggable", "Droppable", "draggingItemCls", "resizingItemInnerCls", "leftHandle", "rightHandle", "topHandle", "bottomHandle", "handleSize", "dynamicHandleSize", "allowResizeToZero", "reservedSpace", "touchHandleSize", "dragThreshold", "dragTouchStartDelay", "draggingClsSelector", "showExactResizePosition", "validatorFn", "validatorFnThisObj", "axisLock", "trackMouse", "hideDelay", "ignoreSelector", "dragActiveCls", "_this$dragging", "dragging", "render", "dragSelector", "dragItemSelector", "dragRootElement", "dropRootElement", "dragLock", "isEventElementDraggable", "eventElement", "eventResizable", "resizable", "isOverStartHandle", "isOverEndHandle", "onEventDataGenerated", "wrapperCls", "_this$dragging2", "_this$dragging2$conte", "onDragPointerMove", "_dragging$context", "visibleDateRange", "dimension", "pageScroll", "globalThis", "offset", "clientRect", "startCoord", "endCoord", "getEnd", "getDateFromCoord", "local", "clientStartCoord", "clientEndCoord", "isResizing", "beforeDrag", "resolveTimeSpanRecord", "itemElement", "isGanttBase", "resolveResourceRecord", "project", "isOccurrence", "mousedownDate", "triggerBeforeResize", "dragStart", "_client$features$even", "_client$resolveAssign", "resolveEventRecord", "isBatchUpdating", "wrapStartDate", "wrapEndDate", "useEventBuffer", "eventBuffer", "eventStartDate", "eventEndDate", "horizontal", "draggingEnd", "toSet", "wrapToSet", "otherEnd", "setMethod", "setOtherMethod", "elRect", "clientX", "clientY", "timespanRecord", "oldValue", "edge", "originalStartDate", "originalEndDate", "meta", "split", "listenToBatchedUpdates", "beginListeningForBatchedUpdates", "beginEventRecordBatch", "setupProductResizeContext", "triggerEventResizeStart", "getResizeStartParams", "resizedRecord", "resolveAssignmentRecord", "show", "getTooltipTarget", "getBeforeResizeParams", "_this$client", "_this$client2", "StringHelper", "capitalize", "triggerEventResizeEnd", "triggerEventPartialResize", "triggerBeforeEventResizeFinalize", "dragEnter", "_drag$context", "resizeEventPartiallyInternal", "_client$features$even2", "diff", "getTime", "applyDateConstraints", "_context$dateConstrai", "_context$dateConstrai2", "minDate", "maxDate", "moveDrag", "enableEventAnimations", "weekStartDay", "resolutionUnit", "resolutionIncrement", "eventStart", "eventEnd", "isScroll", "crossedOver", "avoidedZeroSize", "onDragEndSwitch", "resolution", "isEventDragCreate", "tooNarrow", "sign", "checkValidity", "partialResizeEvent", "stores", "eventStore", "alignTo", "dragEnd", "aborted", "EventHelper", "getPagePoint", "equals", "cleanup", "dragDrop", "updateRecord", "wasChanged", "internalUpdateRecord", "cancelEventRecordBatch", "resources", "resource", "repaintEventsForResource", "isDestroyed", "changed", "endListeningForBatchedUpdates", "unHighlightHandle", "getResizeEndParams", "generation", "batching", "TimeSpan", "prototype", "inSetNormalize", "isEntity", "_client$features$even3", "run", "setOtherEnd", "promisesToWait", "Promise", "all", "endBatch", "batchChanges", "commitAsync", "onDragItemMouseMove", "pointerType", "handleSelector", "checkResizeHandles", "overItem", "allowResize", "isOverAnyHandle", "highlightHandle", "onDragItemMouseLeave", "oldOverItem", "_item$syncIdMap", "item", "syncIdMap", "_item$syncIdMap2", "inner", "_this$getHandleRect", "getHandleRect", "contains", "_this$getHandleRect2", "side", "eventEl", "closest", "eventCls", "dim", "handleSpec", "offsetWidth", "isResizable", "eventRect", "clone", "handleStyle", "getComputedStyle", "BrowserHelper", "isHoverableDevice", "undefined", "parseFloat", "handleVisThresh", "handleVisibilityThreshold", "centerGap", "deflateArgs", "constrainTo", "setupDragContext", "isElementResizable", "changeHandleSize", "VersionHelper", "deprecate", "changeTouchHandleSize", "isTooltip", "innerhtmlupdate", "_me$clockTemplate", "_element", "handleHoldingElement", "handleEl", "startsOutside", "endsOutside", "anchorSize", "basicValidityCheck", "html", "tipData", "beginBatch", "cancelBatch", "_client$resolveResour", "_client$resolveAssign2", "_client$getDateConstr", "getDateConstraints", "allowOverlap", "some", "isDateRangeAvailable", "GridFeatureManager", "registerFeature", "TaskEditTransactional", "Target", "captureStm", "force", "transactionalFeaturesEnabled", "startStmTransaction", "freeStm", "commitOrReject", "hasStmCapture", "startRecordingEarly", "startFeatureTransaction", "commitStmTransaction", "finishFeatureTransaction", "rejectStmTransaction", "rejectFeatureTransaction", "TransactionalFeature", "_a", "AttachToProjectMixin", "detachFromProject", "getStmCapture", "_editorPromiseResolve", "applyStmCapture", "stmCapture", "stm", "chainResolved", "startTransaction", "queue", "_me$trigger", "_stmInitiallyDisabled", "_stmInitiallyAutoRecord", "autoRecord", "isRecording", "stopTransaction", "enable", "resolve", "_me$_editorPromiseRes", "rejectTransaction", "afterApplyStashCallback", "_me$_editorPromiseRes2", "isEngineReady", "transactionId", "stash", "IdHelper", "generateId", "isDestroying", "_project$commitAsync", "_me$trigger2", "applyStash", "__publicField", "getDragCreateDragDistance", "_this$source", "_this$source$client$f", "taskEdit", "_canceling", "getDistanceBetween", "DragCreateBase", "TaskEditStm", "changeValidatorFn", "createValidatorFn", "initialDate", "pan", "eventDragSelect", "preventMultiple", "isRowEmpty", "rowRecord", "preventDragSelect", "startDrag", "proxyElement", "matchScheduleCell", "$original", "isSpecialRow", "monitoringConfig", "getDistance", "updateDragTolerance", "dragTolerance", "doCreate", "finalized", "completeFinalization", "finalizeDragCreate", "_me$onAborted", "cancelDragCreate", "onAborted", "transferred", "_this$tip2", "parentElement", "onElementContextMenu", "prepareCreateContextForFinalization", "createContext", "renderData", "_this$dragging$contex", "handleBeforeDragCreate", "dateTime", "tipTemplate", "before", "TooltipBase", "autoUpdate", "hoverDelay", "monitorRecordUpdate", "testConfig", "processConfig", "forSelector", "_me$tooltip", "tooltip", "setConfig", "destroyProperties", "doDisable", "disable", "_me$tooltip2", "tipCls", "scrollAction", "showOnHover", "anchorToTarget", "configuredListeners", "overtarget", "keys", "$meta", "configs", "defineProperty", "v", "processConfiguredListeners", "addListener", "_this$tooltip", "defaultDetacher", "tooltipDetacher", "removeListener", "_this$tooltip2", "activeTarget", "recordProp", "recordType", "endDateValue", "getDisplayEndDate", "onTipShow", "updateListener", "change", "onRecordUpdate", "buffer", "onTipHide", "_this$updateListener", "onOverNewTarget", "newTarget", "isVisible", "scrolling", "updateContent", "aligningToElement", "internalOnPointerOver", "lastPointerEvent", "AbstractTimeRanges", "Delayable", "rangeCls", "lineCls", "enableResizing", "dragTipTemplate", "encodeHtml", "baseCls", "headerRenderer", "bodyRenderer", "narrowThreshold", "renderRows", "onUIReady", "once", "$$name", "toLowerCase", "baseSelector", "showHeaderElements", "_me$resize", "detachListeners", "resize", "renderRanges", "setupTimeAxisViewModelListeners", "update", "includeChange", "updateLineBuffer", "timeAxisViewModelChange", "hideHeaders", "headerContainerElement", "on", "click", "onTimeRangeClick", "dblclick", "contextmenu", "delegate", "rtlSource", "ResizeHelper", "matches", "resizestart", "resizing", "cancel", "resizeHelperConfig", "hoverTooltip", "timeRange", "resolveTimeRangeRecord", "refresh", "_timeRanges", "getDOMConfig", "bodyConfigs", "headerConfigs", "_labelRotationMap", "timeRanges", "renderRange", "bodyConfig", "headerConfig", "foregroundCanvas", "isPainted", "collapsed", "updatedBodyElements", "bodyCanvas", "createElement", "className", "parent", "DomSync", "sync", "targetElement", "childrenOnly", "domConfig", "children", "syncOptions", "releaseThreshold", "syncIdField", "action", "headerCanvas", "bodyElement", "cacheRotation", "elementData", "applyRotation", "shouldRenderRange", "rangeStart", "rangeEnd", "isTimeSpanInAxis", "intersectSpans", "_lineBufferDurationMS", "getRangeDomConfig", "relativeTo", "startPos", "getCoordinateFromDate", "respectExclusion", "endPos", "isEnd", "size", "abs", "isRange", "translateX", "dataset", "style", "icon", "iconCls", "xss", "labelTpl", "showLabelInBody", "label", "firstElementChild", "recurringTimeSpan", "_range$recurringTimeS", "_bodyElement$firstEle", "rotate", "toggle", "getBodyElementByRecord", "idOrRecord", "getChild", "timeView", "timeAxisColumn", "_headerContainerElement", "_showHeaderElements", "updateShowHeaderElements", "populateTimeAxisHeaderMenu", "column", "items", "onSchedulerHorizontalScroll", "afterScroll", "onInternalResize", "newWidth", "newHeight", "oldWidth", "oldHeight", "onTimeAxisViewModelUpdate", "timeRangeRecord", "showTip", "destroyTip", "totalSize", "Number", "MAX_SAFE_INTEGER", "onInvalidDrop", "box", "onResizeStart", "onResizeDrag", "onResize", "onInvalidResize", "onResizeReset", "emptyObject", "freeze", "ColumnLines", "delayable", "cancelOutstanding", "after", "useBackgroundCanvas", "attachToResourceStore", "resourceStore", "group", "groupers", "getColumnLinesDOMConfig", "m", "variableColumnWidths", "columnConfig", "linesForLevel", "columnLinesFor", "majorLinesForLevel", "domConfigs", "dates", "Set", "addLineConfig", "isMajor", "tickStart", "has", "role", "transform", "line", "index", "columnLines", "columnWidth", "resourceColumns", "first", "firstResource", "last", "lastResource", "getResourceRange", "nbrGroupHeaders", "_instanceMeta$groupPa", "_instanceMeta$groupPa2", "getAt", "isGroupHeader", "insetStart", "isGrouped", "groupParent", "groupChildren", "backgroundCanvas", "onlyChildren", "onVisibleDateRangeChange", "onVisibleResourceRangeChange", "updateCanvasSize", "DependencyCreation", "allowDropOnEventBar", "showCreationTooltip", "creationTooltip", "terminalCls", "terminalSides", "allowCreate", "view", "eventName", "updateCreateListeners", "_me$pointerUpMoveDeta", "_me$creationTooltip", "creationData", "pointerUpMoveDetacher", "isCreateAllowed", "_allowCreate", "onTimeSpanMouseEnter", "isCreating", "nestedEvents", "isRoot", "eventBarElement", "down", "showTerminals", "timeSpanElement", "onOverTargetEventBar", "onTimeSpanMouseLeave", "_event$event", "timeSpanLeft", "relatedTarget", "isDescendant", "isTrusted", "sourceElement", "hideTerminals", "onOverNewTargetWhileCreating", "onTerminalMouseOver", "onTerminalMouseOut", "showingTerminalsFor", "unhover", "onTerminalPointerDown", "button", "_scheduler$resolveRes", "terminalNode", "viewBounds", "stopPropagation", "fromSide", "startPoint", "startX", "scrollLeft", "startY", "scrollTop", "sourceResource", "pointerup", "getRootNode", "handler", "passive", "pointermove", "documentPointerUpDetacher", "keydown", "key", "onElementTouchMove", "_super$onElementTouch", "connector", "preventDefault", "onMouseMove", "deltaX", "deltaY", "sqrt", "angle", "atan2", "onRequestDragCreate", "lastMouseMoveEvent", "createConnector", "createDragTooltip", "_overEventRecord", "overEventRecord", "isEventSegment", "removeClsGlobally", "toSide", "_data$timeSpanElement", "_data$timeSpanElement2", "getTargetSideFromType", "dependencyStore", "modelClass", "fieldMap", "DependencyBaseModel", "Type", "EndToStart", "targetResource", "dependencyType", "updateValidity", "StartToStart", "StartToEnd", "EndToEnd", "isValidDependency", "validityCls", "updateCreationTooltip", "onMouseUp", "_me$pointerUpMoveDeta2", "dependency", "createDependency", "doAfterDependencyDrop", "onDocumentMouseUp", "_me$pointerUpMoveDeta3", "_me$documentPointerUp", "getElementFromEventRecord", "removeConnector", "clearTimeout", "removeConnectorTimeout", "loadingMsg", "header", "dock", "beforeShow", "terminalsVisibleCls", "fixSide", "terminal", "feature", "detacher", "mouseover", "mouseout", "pointerdown", "capture", "internalCls", "eventParams", "getTimeSpanMouseEventParams", "forEachSelector", "newDependency", "to", "then", "creationTooltipTemplate", "_data$target", "fromText", "toText", "tipTitleIconClsSuffix", "tipTitleText", "title", "ref", "tag", "ROWS_PER_CELL", "DependencyGridCache", "gridCache", "getDependenciesToConsider", "startMS", "endMS", "startIndex", "endIndex", "dependencies", "fromMSCell", "floor", "MS_PER_CELL", "toMSCell", "fromRowCell", "toRowCell", "msCell", "j", "intersectingDependencies", "afterDrawDependency", "fromIndex", "toIndex", "fromDateMS", "toDateMS", "constructGridCache", "timeAxisStartMS", "timeAxisEndMS", "timeAxisCells", "ceil", "firstMSCell", "lastMSCell", "firstRowCell", "lastRowCell", "startMSCell", "endMSCell", "beforeDraw", "afterDraw", "THRESHOLD", "devicePixelRatio", "BOX_PROPERTIES", "equalEnough", "a", "b", "RectangularPathFinder", "startSide", "startArrowMargin", "startShift", "endSide", "endArrowMargin", "endShift", "verticalMargin", "horizontalMargin", "otherBoxes", "findPath", "lineDef", "noPathFallbackFn", "originalLineDef", "lineDefFull", "startBox", "endBox", "startHorizontalMargin", "startVerticalMargin", "endHorizontalMargin", "endVerticalMargin", "otherHorizontalMargin", "otherVerticalMargin", "connStartPoint", "connEndPoint", "pathStartPoint", "pathEndPoint", "gridStartPoint", "gridEndPoint", "startGridBox", "endGridBox", "path", "tryNum", "ArrayHelper", "asArray", "hasOwnProperty", "normalizeSide", "getConnectionCoordinatesFromBoxSideShift", "calcGridBaseBoxFromBoxAndDrawParams", "property", "shouldLookForPath", "_otherBoxes", "buildPathGrid", "convertDecartPointToGridPoint", "findPathOnGrid", "prependPathWithArrowStaffSegment", "appendPathWithArrowStaffSegment", "optimizePath", "calculateRelativePosition", "box1", "box2", "vertical", "startProp", "endProp", "boxOverlapChanged", "gridStartBox", "gridEndBox", "calculateOverlap", "originalOverlap", "finalOverlap", "shift", "coords", "arrowMargin", "gridBox", "otherGridBoxes", "xs", "ys", "ix", "iy", "xslen", "yslen", "ib", "blen", "permitted", "point", "points", "linearPoints", "distance", "indexOf", "waveForward", "collectPath", "getGridPointNeighbors", "gridPoint", "predicateFn", "neighbor", "WalkHelper", "preWalkUnordered", "neighborPoint", "pathFound", "neighbors", "lowestDistanceNeighbor", "xDiff", "yDiff", "resultA", "resultB", "x1", "y1", "x2", "y2", "reverse", "firstSegment", "prependSegment", "unshift", "lastSegment", "appendSegment", "optPath", "prevSegment", "curSegment", "drawingDirection", "pointSet", "segmentLength", "arc", "nextPointSet", "radius", "corner", "rx", "includes", "ry", "location", "prevRadius", "useRadius", "nextLength", "subtract", "useLength", "currentRadius", "pathMapper", "lineSpec", "DependencyLineGenerator", "lineCache", "onSVGReady", "pathFinder", "pathFinderConfig", "lineDefAdjusters", "createLineDefAdjusters", "createMarker", "changeRadius", "assertNumber", "updateRadius", "updateRenderer", "changeClickWidth", "updateClickWidth", "_me$marker", "markerDef", "svg", "svgCanvas", "markerId", "marker", "setProperty", "ns", "markerHeight", "markerWidth", "refX", "refY", "viewBox", "orient", "markerUnits", "d", "updateMarkerDef", "getAssignmentElement", "assignment", "_this$client$features", "_this$client$features2", "eventDrag", "getProxyElement", "getElementFromAssignmentRecord", "getDomConfigs", "fromAssignment", "toAssignment", "forceBoxes", "getDependencyKey", "constructLineCache", "drawingLive", "prepareLineDef", "clickWidth", "toEvent", "_me$renderer", "highlighted", "syncId", "depId", "fromId", "toId", "class", "noMarkerCls", "hideMarker", "active", "bidirectional", "milestone", "renderer", "dependencyRecord", "fromAssignmentRecord", "toAssignmentRecord", "fromBox", "toBox", "strokeWidth", "generateBoundaryBoxes", "rowTop", "rowBottom", "getAssignmentBounds", "isExporting", "rectangle", "row", "getRowById", "overRow", "getRowAt", "getAssignmentEventBox", "getConnectorStartSide", "getConnectorEndSide", "getDependencyStartSide", "fromEvent", "DependencyModel", "getDependencyEndSide", "shrinkArrowMargins", "barMargin", "adjusted", "resetArrowMargins", "shrinkHorizontalMargin", "adjustLineDef", "startRectangle", "endRectangle", "fromBoxSide", "toBoxSide", "DependencyTooltip", "changeTooltip", "old", "textContent", "getHoverTipHtml", "resolveDependencyRecord", "eventNameMap", "collectLinkedAssignments", "_assignment$resource", "hasLinks", "$links", "l", "drawDependencies", "Dependencies", "lastScrollX", "visibleResources", "usingLinks", "svgCanvasCreated", "animationStart", "timelineViewportResize", "timeAxisViewModelUpdate", "toggleNode", "bindStore", "_isDisabling", "draw", "rowStore", "usesDisplayStore", "onStoreRefresh", "attachToProject", "commitFinalized", "onResourceStoreChange", "attachToEventStore", "attachToAssignmentStore", "assignmentStore", "attachToDependencyStore", "updateDrawOnScroll", "drawOnScroll", "scroll", "horizontalScroll", "prio", "scrollEnd", "onHorizontalScroll", "subGrid", "scrollX", "getLocalizedDependencyType", "getElementForDependency", "getElementsForDependency", "selector", "Array", "querySelectorAll", "_element$elementData", "isDependencyElement", "onElementClick", "onElementDblClick", "onElementMouseOver", "overCls", "highlight", "onElementMouseOut", "unhighlight", "isDependencyVisible", "fromResource", "toResource", "isAvailable", "isModel", "hidden", "updateHighlightDependenciesOnEventHover", "params", "highlightEventDependencies", "unhighlightEventDependencies", "classes", "delete", "dep", "_super$getDependencie", "records", "filter", "isValid", "drawDependency", "batch", "_fromAssigned", "_toAssigned", "topIndex", "bottomIndex", "useInitialAnimation", "idMap", "fromAssigned", "assigned", "toAssigned", "isScheduled", "flatMap", "_idMap$from$resource$", "_from$resource", "_idMap$to$resource$id", "_to$resource", "startDateMS", "endDateMS", "lineDomConfigs", "animationDelay", "domSync", "_super$afterDrawDepen", "_super$beforeDraw", "_super$afterDraw", "values", "flat", "strict", "fillDrawingCache", "r", "refreshSuspended", "clear", "firstVisibleRow", "lastVisibleRow", "count", "doRefresh", "_client$features", "_client$features2", "_client$features3", "_client$features4", "isAnimating", "immediateRefresh", "now", "_super$reset", "drawForEvent", "getConfig", "highlightDependenciesOnEventHover", "EventFilter", "eventsFilter", "localeClass", "weight", "menu", "nameFilter", "clearable", "keyStrokeChangeDelay", "onEventFilterChange", "onBeforeShow", "filterByName", "filters", "getBy", "removeFilter", "featureClass", "NonWorkingTimeMixin", "getNonWorkingTimeRanges", "forEachAvailabilityInterval", "isForward", "intervalStartDate", "intervalEndDate", "calendarCacheInterval", "entry", "getIsWorking", "getCalendarTimeRanges", "ignoreName", "increment", "shouldPaint", "maxTimeAxisUnit", "compareUnits", "allRanges", "timeSpans", "mergedSpans", "prevRange", "setData", "span", "setStartEndDate", "setupDefaultCalendar", "autoGeneratedWeekends", "isSchedulerPro", "isGantt", "effectiveCalendar", "defaultCalendar", "intervalStore", "updateDefaultCalendar", "defaultNonWorkingIntervals", "hasIntervals", "ignoreTimeZone", "clearIntervals", "addIntervals", "updateLocalization", "_super$updateLocaliza", "dayNames", "nonWorkingDaysAsArray", "dayIndex", "recurrentStartDate", "recurrentEndDate", "NonWorkingTime", "highlightWeekends", "hideRangesOnZooming", "attachToCalendar", "onConfigChange", "graph", "isScheduler", "dataReady", "fn", "calendarChange", "_timeAxisUnitDurationMs", "isDelayingCalculation", "isCalculated", "_this$project", "timeAxisUnitDurationMs", "as", "ScheduleTooltip", "messageTemplate", "hideForNonWorkingTime", "reshowListener", "hoverTip", "allowOver", "monitorResize", "onDocumentMouseDown", "mousemove", "e", "hideAnimation", "pointerover", "buttonsPressed", "buttons", "which", "lastTime", "updateTip", "getDateFromDomEvent", "lastHtml", "lastResourceId", "generateTipContent", "clockHtml", "generateContent", "messageHtml", "getText", "setTimeSpanOptions", "maintainVisibleStart", "TimeAxisHeaderMenu", "HeaderMenu", "processItems", "triggerEvent", "zoomOnTimeAxisDoubleClick", "shouldShowMenu", "enableHeaderContextMenu", "isTimeAxisColumn", "showContextMenu", "dateStep", "shiftIncrement", "shiftUnit", "zoomLevel", "presets", "zoomSlider", "minWidth", "showValue", "triggerChangeOnInput", "zoom", "minZoomLevel", "maxZoomLevel", "zoomDetatcher", "onHide", "dateRange", "startDateField", "labelWidth", "required", "onRangeDateFieldChange", "endDateField", "leftShiftBtn", "color", "flex", "margin", "onLeftShiftBtnClick", "todayBtn", "onTodayBtnClick", "rightShiftBtn", "onRightShiftBtnClick", "paint", "initDateRangeFields", "onZoomSliderChange", "delay", "widgetMap", "initDates", "suspendEvents", "startDateFieldInitialValue", "endDateFieldInitialValue", "resumeEvents", "startDateChanged", "setTimeSpan", "shiftPrevious", "today", "clearTime", "shiftNext"]
}
