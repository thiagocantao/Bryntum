{
  "version": 3,
  "sources": ["../../../../Scheduler/lib/Scheduler/column/ScaleColumn.js", "../../../../Scheduler/lib/Scheduler/feature/base/ResourceTimeRangesBase.js", "../../../../Scheduler/lib/Scheduler/view/DependencyEditor.js", "../../../../Scheduler/lib/Scheduler/feature/DependencyEdit.js", "../../../../Scheduler/lib/Scheduler/feature/ScheduleContext.js", "../../../../Scheduler/lib/Scheduler/feature/EventCopyPaste.js", "../../../../Scheduler/lib/Scheduler/feature/EventDrag.js", "../../../../Scheduler/lib/Scheduler/feature/EventDragCreate.js", "../../../../Scheduler/lib/Scheduler/feature/EventTooltip.js", "../../../../Scheduler/lib/Scheduler/feature/StickyEvents.js", "../../../../Scheduler/lib/Scheduler/feature/TimeRanges.js", "../../../../Scheduler/lib/Scheduler/view/mixin/DelayedRecordsRendering.js", "../../../../Scheduler/lib/Scheduler/view/TimelineHistogramRendering.js", "../../../../Scheduler/lib/Scheduler/view/TimelineHistogramBase.js", "../../../../Scheduler/lib/Scheduler/view/mixin/TimelineHistogramGrouping.js", "../../../../Scheduler/lib/Scheduler/view/mixin/TimelineHistogramScaleColumn.js", "../../../../Scheduler/lib/Scheduler/view/TimelineHistogram.js"],
  "sourcesContent": ["import Column from '../../Grid/column/Column.js';\nimport ColumnStore from '../../Grid/data/ColumnStore.js';\nimport Scale from '../../Core/widget/graph/Scale.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\n\n/**\n * @module Scheduler/column/ScaleColumn\n */\n\n/**\n * An object representing a point on the scale displayed by {@link Scheduler.column.ScaleColumn}.\n *\n * @typedef {Object} ScalePoint\n * @property {Number} value Point value\n * @property {String} unit Point value unit\n * @property {String} text Point text label\n */\n\n/**\n * A specialized column showing a graduated scale from a defined array of values\n * and labels. This column is used in the {@link Scheduler.view.TimelineHistogram} and is not editable. Normally\n * you should not need to interact with this class directly.\n *\n * @extends Grid/column/Column\n * @classType scale\n * @column\n */\nexport default class ScaleColumn extends Column {\n\n    //region Config\n\n    static $name = 'ScaleColumn';\n\n    static type = 'scale';\n\n    static isScaleColumn = true;\n\n    static get fields() {\n        return [\n            'scalePoints'\n        ];\n    }\n\n    static get defaults() {\n        return {\n            text            : '\\xa0',\n            width           : 40,\n            minWidth        : 40,\n            field           : 'scalePoints',\n            cellCls         : 'b-scale-cell',\n            editor          : false,\n            sortable        : false,\n            groupable       : false,\n            filterable      : false,\n            alwaysClearCell : false,\n            scalePoints     : null\n        };\n    }\n\n    //endregion\n\n    //region Constructor/Destructor\n\n    onDestroy() {\n        this.scaleWidget.destroy();\n    }\n\n    //endregion\n\n    //region Internal\n\n    set width(width) {\n        super.width = width;\n        this.scaleWidget.width = width;\n    }\n\n    get width() {\n        return super.width;\n    }\n\n    applyValue(useProp, key, value) {\n        // pass value to scaleWidget\n        if (key === 'scalePoints') {\n            this.scaleWidget[key] = value;\n        }\n\n        return super.applyValue(...arguments);\n    }\n\n    buildScaleWidget() {\n        const me = this;\n\n        const scaleWidget = new Scale({\n            owner         : me.grid,\n            appendTo      : me.grid.floatRoot,\n            cls           : 'b-hide-offscreen',\n            align         : 'right',\n            scalePoints   : me.scalePoints,\n            monitorResize : false\n        });\n\n        Object.defineProperties(scaleWidget, {\n            width : {\n                get() {\n                    return me.width;\n                },\n                set(width) {\n                    this.element.style.width = `${width}px`;\n                    this._width = me.width;\n                }\n            },\n            height : {\n                get() {\n                    return this._height;\n                },\n                set(height) {\n                    this.element.style.height = `${height}px`;\n                    this._height = height;\n                }\n            }\n        });\n\n        scaleWidget.width = me.width;\n\n        return scaleWidget;\n    }\n\n    get scaleWidget() {\n        const me = this;\n\n        if (!me._scaleWidget) {\n            me._scaleWidget = me.buildScaleWidget();\n        }\n\n        return me._scaleWidget;\n    }\n\n    //endregion\n\n    //region Render\n\n    renderer({ cellElement, value, scaleWidgetConfig, scaleWidget = this.scaleWidget }) {\n        ObjectHelper.assign(scaleWidget, {\n            scalePoints : value || this.scalePoints,\n            height      : this.grid.rowHeight\n        }, scaleWidgetConfig);\n\n        scaleWidget.refresh();\n\n        // Clone the scale widget element since every row is supposed to have\n        // the same scale settings\n        const scaleCloneElement = scaleWidget.element.cloneNode(true);\n        scaleCloneElement.removeAttribute('id');\n        scaleCloneElement.classList.remove('b-hide-offscreen');\n\n        cellElement.innerHTML = '';\n        cellElement.appendChild(scaleCloneElement);\n    }\n\n    //endregion\n\n}\n\nColumnStore.registerColumnType(ScaleColumn);\n", "import InstancePlugin from '../../../Core/mixin/InstancePlugin.js';\nimport AttachToProjectMixin from '../../data/mixin/AttachToProjectMixin.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\n\n/**\n * @module Scheduler/feature/base/ResourceTimeRangesBase\n */\n\n/**\n * Abstract base class for ResourceTimeRanges and ResourceNonWorkingTime features.\n * You should not use this class directly.\n *\n * @extends Core/mixin/InstancePlugin\n * @abstract\n */\nexport default class ResourceTimeRangesBase extends InstancePlugin.mixin(AttachToProjectMixin) {\n    //region Config\n\n    static configurable = {\n        /**\n         * Specify value to use for the tabIndex attribute of range elements\n         * @config {Number}\n         * @category Misc\n         */\n        tabIndex : null,\n\n        entityName : 'resourceTimeRange'\n    };\n\n    static get pluginConfig()  {\n        return {\n            chain    : ['getEventsToRender', 'onEventDataGenerated', 'noFeatureElementsInAxis'],\n            override : ['matchScheduleCell', 'resolveResourceRecord']\n        };\n    }\n\n    // Let Scheduler know if we have ResourceTimeRanges in view or not\n    noFeatureElementsInAxis() {\n        const { timeAxis } = this.client;\n        return !this.needsRefresh && this.store && !this.store.storage.values.some(t => timeAxis.isTimeSpanInAxis(t));\n    }\n\n    //endregion\n\n    //region Init\n\n    doDisable(disable) {\n        if (this.client.isPainted) {\n            this.client.refresh();\n        }\n\n        super.doDisable(disable);\n    }\n\n    updateTabIndex() {\n        if (!this.isConfiguring) {\n            this.client.refresh();\n        }\n    }\n\n    //endregion\n\n    getEventsToRender(resource, events) {\n        throw new Error('Implement in subclass');\n    }\n\n    // Called for each event during render, allows manipulation of render data. Adjust any resource time ranges\n    // (chained function from Scheduler)\n    onEventDataGenerated(renderData) {\n        const\n            me                       = this,\n            { eventRecord, iconCls } = renderData;\n\n        if (me.shouldInclude(eventRecord)) {\n            if (me.client.isVertical) {\n                renderData.width = renderData.resourceRecord.columnWidth || me.client.resourceColumnWidth;\n            }\n            else {\n                renderData.top = 0;\n            }\n\n            // Flag that we should fill entire row/col\n            renderData.fillSize = true;\n            // Add our own cls\n            renderData.wrapperCls['b-sch-resourcetimerange'] = 1;\n            if (me.rangeCls) {\n                renderData.wrapperCls[me.rangeCls] = 1;\n            }\n            renderData.wrapperCls[`b-sch-color-${eventRecord.timeRangeColor}`] = eventRecord.timeRangeColor;\n            // Add label\n            renderData.eventContent.text = eventRecord.name;\n            renderData.children.push(renderData.eventContent);\n\n            // Allow configuring tabIndex\n            renderData.tabIndex = me.tabIndex != null ? String(me.tabIndex) : null;\n\n            // Add icon\n            if (iconCls?.length > 0) {\n                renderData.children.unshift({\n                    tag       : 'i',\n                    className : iconCls.toString()\n                });\n            }\n\n            // Event data for DOMSync comparison\n            renderData.eventId = me.generateElementId(eventRecord);\n        }\n    }\n\n    /**\n     * Generates ID from the passed time range record\n     * @param {Scheduler.model.TimeSpan} record\n     * @returns {String} Generated ID for the DOM element\n     * @internal\n     */\n    generateElementId(record) {\n        return record.domId;\n    }\n\n    resolveResourceTimeRangeRecord(rangeElement) {\n        return rangeElement?.closest(`.${this.rangeCls}`)?.elementData.eventRecord;\n    }\n\n    getElementFromResourceTimeRangeRecord(record) {\n        // return this.client.foregroundCanvas.querySelector(`[data-event-id=\"${record.domId}\"]`);\n        return this.client.foregroundCanvas.syncIdMap[record.domId];\n    }\n\n    resolveResourceRecord(event) {\n        const record = this.overridden.resolveResourceRecord(...arguments);\n\n        return record || this.resolveResourceTimeRangeRecord(event.target || event)?.resource;\n    }\n\n    shouldInclude(eventRecord) {\n        throw new Error('Implement in subclass');\n    }\n\n    // Called when a ResourceTimeRangeModel is manipulated, relays to Scheduler#onInternalEventStoreChange which updates to UI\n    onStoreChange(event) {\n        // Edge case for scheduler not using any events, it has to refresh anyway to get rid of ResourceTimeRanges\n        if (event.action === 'removeall' || event.action === 'dataset') {\n            this.needsRefresh = true;\n        }\n\n        this.client.onInternalEventStoreChange(event);\n\n        this.needsRefresh = false;\n    }\n\n    // Override to let scheduler find the time cell from a resource time range element\n    matchScheduleCell(target) {\n        let cell = this.overridden.matchScheduleCell(target);\n\n        if (!cell && this.enableMouseEvents) {\n            const\n                { client }   = this,\n                rangeElement = target.closest(`.${this.rangeCls}`);\n\n            cell = rangeElement && client.getCell({\n                record : client.isHorizontal ? rangeElement.elementData.resource : client.store.first,\n                column : client.timeAxisColumn\n            });\n        }\n\n        return cell;\n    }\n\n    handleRangeMouseEvent(domEvent) {\n        const\n            me           = this,\n            rangeElement = domEvent.target.closest(`.${me.rangeCls}`);\n\n        if (rangeElement) {\n            const\n                eventName               = EventHelper.eventNameMap[domEvent.type] ?? StringHelper.capitalize(domEvent.type),\n                resourceTimeRangeRecord = me.resolveResourceTimeRangeRecord(rangeElement);\n\n            me.client.trigger(me.entityName + eventName, {\n                feature                    : me,\n                [`${me.entityName}Record`] : resourceTimeRangeRecord,\n                resourceRecord             : me.client.resourceStore.getById(resourceTimeRangeRecord.resourceId),\n                domEvent\n            });\n        }\n    }\n\n    updateEnableMouseEvents(enable) {\n        const\n            me         = this,\n            { client } = me;\n\n        me.mouseEventsDetacher?.();\n        me.mouseEventsDetacher = null;\n\n        if (enable) {\n            function attachMouseEvents() {\n                me.mouseEventsDetacher = EventHelper.on({\n                    element     : client.foregroundCanvas,\n                    delegate    : `.${me.rangeCls}`,\n                    mousedown   : 'handleRangeMouseEvent',\n                    mouseup     : 'handleRangeMouseEvent',\n                    click       : 'handleRangeMouseEvent',\n                    dblclick    : 'handleRangeMouseEvent',\n                    contextmenu : 'handleRangeMouseEvent',\n                    mouseover   : 'handleRangeMouseEvent',\n                    mouseout    : 'handleRangeMouseEvent',\n                    thisObj     : me\n                });\n            }\n\n            client.whenVisible(attachMouseEvents);\n        }\n\n        client.element.classList.toggle('b-interactive-resourcetimeranges', Boolean(enable));\n    }\n}\n\n// No feature based styling needed, do not add a cls to Scheduler\nResourceTimeRangesBase.featureClass = '';\n", "import Popup from '../../Core/widget/Popup.js';\n\n/**\n * @module Scheduler/view/DependencyEditor\n */\n\n/**\n * A dependency editor popup.\n *\n * @extends Core/widget/Popup\n * @private\n */\nexport default class DependencyEditor extends Popup {\n\n    static get $name() {\n        return 'DependencyEditor';\n    }\n\n    static get defaultConfig() {\n        return {\n            items     : [],\n            draggable : {\n                handleSelector : ':not(button,.b-field-inner)' // blacklist buttons and field inners\n            },\n            axisLock : 'flexible'\n        };\n    }\n\n    processWidgetConfig(widget) {\n        const { dependencyEditFeature } = this;\n\n        if (widget.ref === 'lagField' && !dependencyEditFeature.showLagField) {\n            return false;\n        }\n        if (widget.ref === 'deleteButton' && !dependencyEditFeature.showDeleteButton) {\n            return false;\n        }\n\n        return super.processWidgetConfig(widget);\n    }\n\n    afterShow(...args) {\n        const { deleteButton } = this.widgetMap;\n\n        // Only show delete button if the dependency record belongs to a store\n        if (deleteButton) {\n            deleteButton.hidden = !this.record.isPartOfStore();\n        }\n\n        super.afterShow(...args);\n    }\n\n    onInternalKeyDown(event) {\n        this.trigger('keyDown', { event });\n        super.onInternalKeyDown(event);\n    }\n}\n", "import GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport '../../Core/widget/DisplayField.js';\nimport '../../Core/widget/DurationField.js';\nimport DependencyEditor from '../view/DependencyEditor.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport DependencyModel from '../model/DependencyModel.js';\nimport Duration from '../../Core/data/Duration.js';\n\n/**\n * @module Scheduler/feature/DependencyEdit\n */\n\n/**\n * Feature that displays a popup containing fields for editing a dependency. Requires the\n * {@link Scheduler.feature.Dependencies} feature to be enabled. Double click a line in the demo below to show the\n * editor.\n *\n * {@inlineexample Scheduler/feature/Dependencies.js}\n *\n * ## Customizing the built-in widgets\n *\n * ```javascript\n *  const scheduler = new Scheduler({\n *      columns : [\n *          { field : 'name', text : 'Name', width : 100 }\n *      ],\n *      features : {\n *          dependencies   : true,\n *          dependencyEdit : {\n *              editorConfig : {\n *                  items : {\n *                      // Custom label for the type field\n *                      typeField : {\n *                          label : 'Kind'\n *                      }\n *                  },\n *\n *                  bbar : {\n *                      items : {\n *                          // Hiding save button\n *                          saveButton : {\n *                              hidden : true\n *                          }\n *                      }\n *                  }\n *              }\n *          }\n *      }\n *  });\n * ```\n *\n * ## Built in widgets\n *\n * | Widget ref             | Type                              | Weight | Description               |\n * |------------------------|-----------------------------------|--------|---------------------------|\n * | `fromNameField`        | {@link Core.widget.DisplayField}  | 100    | From task name (readonly) |\n * | `toNameField`          | {@link Core.widget.DisplayField}  | 200    | To task name (readonly)   |\n * | `typeField`            | {@link Core.widget.Combo}         | 300    | Edit type                 |\n * | `lagField`             | {@link Core.widget.DurationField} | 400    | Edit lag                  |\n *\n * The built in buttons are:\n *\n * | Widget ref             | Type                       | Weight | Description                       |\n * |------------------------|----------------------------|--------|-----------------------------------|\n * | `saveButton`           | {@link Core.widget.Button} | 100    | Save button on the bbar           |\n * | `deleteButton`         | {@link Core.widget.Button} | 200    | Delete button on the bbar         |\n * | `cancelButton`         | {@link Core.widget.Button} | 300    | Cancel editing button on the bbar |\n *\n * This feature is **off** by default.\n * For info on enabling it, see {@link Grid.view.mixin.GridFeatures}.\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Scheduler/dependencies\n * @classtype dependencyEdit\n * @feature\n */\nexport default class DependencyEdit extends InstancePlugin {\n\n    // <debug>\n    // region Localization test\n    static localization = [\n        'L{StartToStart}',\n        'L{StartToEnd}',\n        'L{EndToStart}',\n        'L{EndToEnd}'\n    ];\n    // endregion\n    // </debug>\n\n    //region Config\n\n    static get $name() {\n        return 'DependencyEdit';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * True to hide this editor if a click is detected outside it (defaults to true)\n             * @config {Boolean}\n             * @default\n             * @category Editor\n             */\n            autoClose : true,\n\n            /**\n             * True to save and close this panel if ENTER is pressed in one of the input fields inside the panel.\n             * @config {Boolean}\n             * @default\n             * @category Editor\n             */\n            saveAndCloseOnEnter : true,\n\n            /**\n             * True to show a delete button in the form.\n             * @config {Boolean}\n             * @default\n             * @category Editor widgets\n             */\n            showDeleteButton : true,\n\n            /**\n             * The event that shall trigger showing the editor. Defaults to `dependencydblclick`, set to empty string or\n             * `null` to disable editing of dependencies.\n             * @config {String}\n             * @default\n             * @category Editor\n             */\n            triggerEvent : 'dependencydblclick',\n\n            /**\n             * True to show the lag field for the dependency\n             * @config {Boolean}\n             * @default\n             * @category Editor widgets\n             */\n            showLagField : false,\n\n            dependencyRecord : null,\n\n            /**\n             * Default editor configuration, used to configure the Popup.\n             * @config {PopupConfig}\n             * @category Editor\n             */\n            editorConfig : {\n                title       : 'L{Edit dependency}',\n                localeClass : this,\n                closable    : true,\n\n                defaults : {\n                    localeClass : this\n                },\n                items : {\n                    /**\n                     * Reference to the from name\n                     * @member {Core.widget.DisplayField} fromNameField\n                     * @readonly\n                     */\n                    fromNameField : {\n                        type   : 'display',\n                        weight : 100,\n                        label  : 'L{From}'\n                    },\n                    /**\n                     * Reference to the to name field\n                     * @member {Core.widget.DisplayField} toNameField\n                     * @readonly\n                     */\n                    toNameField : {\n                        type   : 'display',\n                        weight : 200,\n                        label  : 'L{To}'\n                    },\n                    /**\n                     * Reference to the type field\n                     * @member {Core.widget.Combo} typeField\n                     * @readonly\n                     */\n                    typeField : {\n                        type                  : 'combo',\n                        weight                : 300,\n                        label                 : 'L{Type}',\n                        name                  : 'type',\n                        editable              : false,\n                        valueField            : 'id',\n                        displayField          : 'name',\n                        localizeDisplayFields : true,\n                        buildItems            : function() {\n                            const dialog = this.parent;\n\n                            return Object.keys(DependencyModel.Type).map(type => ({\n                                id        : DependencyModel.Type[type],\n                                name      : dialog.L(type),\n                                localeKey : type\n                            }));\n                        }\n                    },\n\n                    /**\n                     * Reference to the lag field\n                     * @member {Core.widget.DurationField} lagField\n                     * @readonly\n                     */\n                    lagField : {\n                        type          : 'duration',\n                        weight        : 400,\n                        label         : 'L{Lag}',\n                        name          : 'lag',\n                        allowNegative : true\n                    }\n                },\n\n                bbar : {\n                    defaults : {\n                        localeClass : this\n                    },\n                    items : {\n                        foo : {\n                            type : 'widget',\n                            cls  : 'b-label-filler'\n                        },\n                        /**\n                         * Reference to the save button, if used\n                         * @member {Core.widget.Button} saveButton\n                         * @readonly\n                         */\n                        saveButton : {\n                            color : 'b-green',\n                            text  : 'L{Save}'\n                        },\n                        /**\n                         * Reference to the delete button, if used\n                         * @member {Core.widget.Button} deleteButton\n                         * @readonly\n                         */\n                        deleteButton : {\n                            color : 'b-gray',\n                            text  : 'L{Delete}'\n                        },\n                        /**\n                         * Reference to the cancel button, if used\n                         * @member {Core.widget.Button} cancelButton\n                         * @readonly\n                         */\n                        cancelButton : {\n                            color : 'b-gray',\n                            text  : 'L{Object.Cancel}'\n                        }\n                    }\n                }\n            }\n        };\n    }\n\n    //endregion\n\n    //region Init & destroy\n\n    construct(client, config) {\n        const me = this;\n\n        client.dependencyEdit = me;\n\n        super.construct(client, config);\n\n        if (!client.features.dependencies) {\n            throw new Error('Dependencies feature required when using DependencyEdit');\n        }\n\n        me.clientListenersDetacher = client.ion({\n            [me.triggerEvent] : me.onActivateEditor,\n            thisObj           : me\n        });\n    }\n\n    doDestroy() {\n        this.clientListenersDetacher();\n        this.editor?.destroy();\n        super.doDestroy();\n    }\n\n    //endregion\n\n    //region Editing\n\n    changeEditorConfig(config) {\n        const\n            me                         = this,\n            { autoClose, cls, client } = me;\n\n        return ObjectHelper.assign({\n            owner        : client,\n            align        : 'b-t',\n            id           : `${client.id}-dependency-editor`, // no-sanity\n            autoShow     : false,\n            anchor       : true,\n            scrollAction : 'realign',\n            clippedBy    : [client.timeAxisSubGridElement, client.bodyContainer],\n            constrainTo  : globalThis,\n            autoClose,\n            cls\n        }, config);\n    }\n\n    //endregion\n\n    //region Save\n\n    get isValid() {\n        return Object.values(this.editor.widgetMap).every(field => {\n            if (!field.name || field.hidden) {\n                return true;\n            }\n\n            return field.isValid !== false;\n        });\n    }\n\n    get values() {\n        const values = {};\n\n        this.editor.eachWidget(widget => {\n            if (!widget.name || widget.hidden) return;\n\n            values[widget.name] = widget.value;\n        }, true);\n\n        return values;\n    }\n\n    /**\n     * Template method, intended to be overridden. Called before the dependency record has been updated.\n     * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency record\n     *\n     **/\n    onBeforeSave(dependencyRecord) {}\n\n    /**\n     * Template method, intended to be overridden. Called after the dependency record has been updated.\n     * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency record\n     *\n     **/\n    onAfterSave(dependencyRecord) {}\n\n    /**\n     * Updates record being edited with values from the editor\n     * @private\n     */\n    updateRecord(dependencyRecord) {\n        const { values } = this;\n\n        // Engine does not understand { magnitude, unit } syntax\n        if (values.lag) {\n            values.lagUnit = values.lag.unit;\n            values.lag = values.lag.magnitude;\n        }\n\n        // Type replaces fromSide/toSide, if they are used\n        if ('type' in values) {\n            dependencyRecord.fromSide != null && (values.fromSide = null);\n            dependencyRecord.toSide != null && (values.toSide = null);\n        }\n\n        // Chronograph doesn't filter out undefined fields, it nullifies them instead\n        // https://github.com/bryntum/chronograph/issues/11\n        ObjectHelper.cleanupProperties(values, true);\n\n        dependencyRecord.set(values);\n    }\n\n    //endregion\n\n    //region Events\n\n    onPopupKeyDown({ event }) {\n        if (event.key === 'Enter' && this.saveAndCloseOnEnter && event.target.tagName.toLowerCase() === 'input') {\n            // Need to prevent this key events from being fired on whatever receives focus after the editor is hidden\n            event.preventDefault();\n\n            this.onSaveClick();\n        }\n    }\n\n    onSaveClick() {\n        if (this.save()) {\n            this.afterSave();\n            this.editor.hide();\n        }\n    }\n\n    async onDeleteClick() {\n        if (await this.deleteDependency()) {\n            this.afterDelete();\n        }\n        this.editor.hide();\n    }\n\n    onCancelClick() {\n        this.afterCancel();\n        this.editor.hide();\n    }\n\n    afterSave() {}\n    afterDelete() {}\n    afterCancel() {}\n\n    //region Editing\n\n    // Called from editDependency() to actually show the editor\n    internalShowEditor(dependencyRecord) {\n        const\n            me         = this,\n            { client } = me,\n            editor     = me.getEditor(dependencyRecord);\n\n        me.loadRecord(dependencyRecord);\n\n        /**\n         * Fires on the owning Scheduler when the editor for a dependency is available but before it is shown. Allows\n         * manipulating fields before the widget is shown.\n         * @event beforeDependencyEditShow\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source The scheduler\n         * @param {Scheduler.feature.DependencyEdit} dependencyEdit The dependencyEdit feature\n         * @param {Scheduler.model.DependencyModel} dependencyRecord The record about to be shown in the editor.\n         * @param {Core.widget.Popup} editor The editor popup\n         */\n        client.trigger('beforeDependencyEditShow', {\n            dependencyEdit : me,\n            dependencyRecord,\n            editor\n        });\n\n        let showPoint = me.lastPointerDownCoordinate;\n\n        if (!showPoint) {\n            const center = Rectangle.from(client.element).center;\n\n            showPoint = [center.x - editor.width / 2, center.y - editor.height / 2];\n        }\n\n        return editor.showBy(showPoint);\n    }\n\n    /**\n     * Opens a popup to edit the passed dependency.\n     * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency to edit\n     * @return {Promise} A Promise that yields `true` after the editor is shown\n     * or `false` if some application logic vetoed the editing (see `beforeDependencyEdit` in the docs).\n     */\n    async editDependency(dependencyRecord) {\n        const\n            me         = this,\n            { client } = me;\n\n        if (client.readOnly || dependencyRecord.readOnly ||\n            /**\n             * Fires on the owning Scheduler before an dependency is displayed in the editor.\n             * This may be listened for to allow an application to take over dependency editing duties. Return `false` to\n             * stop the default editing UI from being shown or a `Promise` yielding `true` or `false` for async vetoing.\n             * @event beforeDependencyEdit\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler\n             * @param {Scheduler.feature.DependencyEdit} dependencyEdit The dependencyEdit feature\n             * @param {Scheduler.model.DependencyModel} dependencyRecord The record about to be shown in the editor.\n             * @preventable\n             * @async\n             */\n            await client.trigger('beforeDependencyEdit', { dependencyEdit : me, dependencyRecord }) === false\n        ) {\n            return false;\n        }\n\n        // wait till the editor is shown\n        await this.internalShowEditor(dependencyRecord);\n\n        return true;\n    }\n\n    //endregion\n\n    //region Save\n\n    /**\n     * Gets an editor instance. Creates on first call, reuses on consecutive\n     * @internal\n     * @returns {Scheduler.view.DependencyEditor} Editor popup\n     */\n    getEditor() {\n        const me = this;\n\n        let { editor } = me;\n\n        if (editor) {\n            return editor;\n        }\n\n        editor = me.editor = DependencyEditor.new({\n            dependencyEditFeature : me,\n            autoShow              : false,\n            anchor                : true,\n            scrollAction          : 'realign',\n            constrainTo           : globalThis,\n            autoClose             : me.autoClose,\n            cls                   : me.cls,\n            rootElement           : me.client.rootElement,\n            internalListeners     : {\n                keydown : me.onPopupKeyDown,\n                thisObj : me\n            }\n        }, me.editorConfig);\n\n        if (editor.items.length === 0) {\n            console.warn('Editor configured without any `items`');\n        }\n\n        // assign widget refs\n        editor.eachWidget(widget => {\n            const ref = widget.ref || widget.id;\n            // don't overwrite if already defined\n            if (ref && !me[ref]) {\n                me[ref] = widget;\n            }\n        });\n\n        me.saveButton?.ion({ click : 'onSaveClick', thisObj : me });\n        me.deleteButton?.ion({ click : 'onDeleteClick', thisObj : me });\n        me.cancelButton?.ion({ click : 'onCancelClick', thisObj : me });\n\n        return me.editor;\n    }\n\n    //endregion\n\n    //region Delete\n\n    /**\n     * Sets fields values from record being edited\n     * @private\n     */\n    loadRecord(dependency) {\n        const me = this;\n\n        me.fromNameField.value = dependency.fromEvent.name;\n        me.toNameField.value = dependency.toEvent.name;\n\n        if (me.lagField) {\n            me.lagField.value = new Duration(dependency.lag, dependency.lagUnit);\n        }\n\n        me.editor.record = me.dependencyRecord = dependency;\n    }\n\n    //endregion\n\n    //region Stores\n\n    /**\n     * Saves the changes (applies them to record if valid, if invalid editor stays open)\n     * @private\n     * @fires beforeDependencySave\n     * @fires beforeDependencyAdd\n     * @fires afterDependencySave\n     * @returns {*}\n     */\n    async save() {\n        const\n            me                           = this,\n            { client, dependencyRecord } = me;\n\n        if (!dependencyRecord || !me.isValid) {\n            return;\n        }\n\n        const { dependencyStore, values } = me;\n\n        /**\n         * Fires on the owning Scheduler before a dependency is saved\n         * @event beforeDependencySave\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source The scheduler instance\n         * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency about to be saved\n         * @param {Object} values The new values\n         * @preventable\n         */\n        if (client.trigger('beforeDependencySave', {\n            dependencyRecord,\n            values\n        }) !== false) {\n            me.onBeforeSave(dependencyRecord);\n\n            me.updateRecord(dependencyRecord);\n\n            // Check if this is a new record\n            if (dependencyStore && !dependencyRecord.stores.length) {\n                /**\n                 * Fires on the owning Scheduler before a dependency is added\n                 * @event beforeDependencyAdd\n                 * @on-owner\n                 * @param {Scheduler.view.Scheduler} source The scheduler\n                 * @param {Scheduler.feature.DependencyEdit} dependencyEdit The dependency edit feature\n                 * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency about to be added\n                 * @preventable\n                 */\n                if (client.trigger('beforeDependencyAdd', { dependencyRecord, dependencyEdit : me }) === false) {\n                    return;\n                }\n\n                dependencyStore.add(dependencyRecord);\n            }\n\n            await client.project?.commitAsync();\n\n            /**\n             * Fires on the owning Scheduler after a dependency is successfully saved\n             * @event afterDependencySave\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler instance\n             * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency about to be saved\n             */\n            client.trigger('afterDependencySave', { dependencyRecord });\n\n            me.onAfterSave(dependencyRecord);\n        }\n\n        return dependencyRecord;\n    }\n\n    /**\n     * Delete dependency being edited\n     * @private\n     * @fires beforeDependencyDelete\n     */\n    async deleteDependency() {\n        const { client, editor, dependencyRecord } = this;\n\n        /**\n         * Fires on the owning Scheduler before a dependency is deleted\n         * @event beforeDependencyDelete\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source The scheduler instance\n         * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency record about to be deleted\n         * @preventable\n         */\n        if (client.trigger('beforeDependencyDelete', { dependencyRecord }) !== false) {\n            if (editor.containsFocus) {\n                editor.revertFocus();\n            }\n\n            client.dependencyStore.remove(dependencyRecord);\n            await client.project?.commitAsync();\n\n            return true;\n        }\n\n        return false;\n    }\n\n    get dependencyStore() {\n        return this.client.dependencyStore;\n    }\n    //endregion\n\n    //region Events\n\n    onActivateEditor({ dependency, event }) {\n        if (!this.disabled) {\n            this.lastPointerDownCoordinate = [event.clientX, event.clientY];\n            this.editDependency(dependency);\n        }\n    }\n\n    //endregion\n\n}\n\nGridFeatureManager.registerFeature(DependencyEdit, false);\n", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\n\n/**\n * @module Scheduler/feature/ScheduleContext\n */\n\n/**\n * Allow visually selecting a schedule \"cell\" by clicking, or {@link #config-triggerEvent any other pointer gesture}.\n *\n * This feature is **disabled** by default\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         // Configure as a truthy value to enable the feature\n *         scheduleContext : {\n *             triggerEvent : 'hover',\n *             renderer     : (context, element) => {\n *                 element.innerText = '😎';\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * The contextual details are available in the {@link #property-context} property.\n *\n * **Note that the context is cleared upon change of {@link Scheduler.view.Scheduler#property-viewPreset}\n * such as when zooming in or out.**\n *\n * @extends Core/mixin/InstancePlugin\n * @inlineexample Scheduler/feature/ScheduleContext.js\n * @classtype scheduleContext\n * @feature\n */\nexport default class ScheduleContext extends InstancePlugin.mixin(Delayable) {\n    static get $name() {\n        return 'ScheduleContext';\n    }\n\n    static delayable = {\n        syncContextElement : 'raf'\n    };\n\n    static configurable = {\n        /**\n         * The pointer event type to use to update the context. May be `'hover'` to highlight the\n         * tick context when moving the mouse across the timeline.\n         * @config {'click'|'hover'|'contextmenu'|'mousedown'}\n         * @default\n         */\n        triggerEvent : 'click',\n\n        /**\n         * A function (or the name of a function) which may mutate the contents of the context overlay\n         * element which tracks the active resource/tick context.\n         * @config {String|Function}\n         * @param {TimelineContext} context The context being highlighted.\n         * @param {HTMLElement} element The context highlight element. This will be empty each time.\n         */\n        renderer : null,\n\n        /**\n         * The active context.\n         * @member {TimelineContext} timelineContext\n         * @readonly\n         */\n        context : {\n            $config : {\n                // Reject non-changes so that when using mousemove, we only update the context\n                // when it changes.\n                equal(c1, c2) {\n                    return c1?.index === c2?.index &&\n                        c1?.tickParentIndex === c2?.tickParentIndex &&\n                        !((c1?.tickStartDate || 0) - (c2?.tickStartDate || 0));\n                }\n            }\n        }\n    };\n\n    /**\n     * The contextual information about which cell was clicked on and highlighted.\n     *\n     * When the {@link Scheduler.view.Scheduler#property-viewPreset} is changed (such as when zooming)\n     * the context is cleared and the highlight is removed.\n     *\n     * @member {Object} context\n     * @property {Scheduler.view.TimelineBase} context.source The owning Scheduler\n     * @property {Date} context.date Date at mouse position\n     * @property {Scheduler.model.TimeSpan} context.tick A record which encapsulates the time axis tick clicked on.\n     * @property {Number} context.tickIndex The index of the time axis tick clicked on.\n     * @property {Date} context.tickStartDate The start date of the current time axis tick\n     * @property {Date} context.tickEndDate The end date of the current time axis tick\n     * @property {Grid.row.Row} context.row Clicked row (in horizontal mode only)\n     * @property {Number} context.index Index of clicked resource\n     * @property {Scheduler.model.ResourceModel} context.resourceRecord Resource record\n     * @property {MouseEvent} context.event Browser event\n     */\n\n    construct(client, config) {\n        super.construct(client, config);\n\n        const\n            { triggerEvent } = this,\n            listeners        = {\n                datachange              : 'syncContextElement',\n                timeaxisviewmodelupdate : 'onTimeAxisViewModelUpdate',\n                presetchange            : 'clearContext',\n                thisObj                 : this\n            };\n\n        // If mousemove is our trigger, we cab use the client's timelineContextChange event\n        if (triggerEvent === 'mouseover') {\n            listeners.timelineContextChange = 'onTimelineContextChange';\n        }\n        // Otherwise, we have to listen for the required events on Schedule and events\n        else {\n            // Context menu will be expected to update the context if click or mousedown\n            // is the triggerEvent. Context menu is a mousedown gesture.\n            if (triggerEvent === 'click' || triggerEvent === 'mousedown') {\n                listeners.schedulecontextmenu = 'onScheduleContextGesture';\n            }\n\n            Object.assign(listeners, {\n                [`schedule${triggerEvent}`] : 'onScheduleContextGesture',\n                [`event${triggerEvent}`]    : 'onScheduleContextGesture',\n                ...listeners\n            });\n        }\n\n        // required to work\n        client.useBackgroundCanvas = true;\n\n        client.ion(listeners);\n        client.rowManager.ion({\n            rowheight : 'syncContextElement',\n            thisObj   : this\n        });\n    }\n\n    changeTriggerEvent(triggerEvent) {\n        // Both these things should route through to using the client's timelineContextChange event\n        if (triggerEvent === 'hover' || triggerEvent === 'mousemove') {\n            triggerEvent = 'mouseover';\n        }\n        return triggerEvent;\n    }\n\n    get element() {\n        return this._element || (this._element = DomHelper.createElement({\n            parent    : this.client.backgroundCanvas,\n            className : 'b-schedule-selected-tick'\n        }));\n    }\n\n    // Handle the Client's own timelineContextChange event which it maintains on mousemove\n    onTimelineContextChange({ context }) {\n        this.context = context;\n    }\n\n    // Handle the scheduleclick or eventclick Scheduler events if we re not using mouseover\n    onScheduleContextGesture(context) {\n        this.context = context;\n    }\n\n    onTimeAxisViewModelUpdate({ source : timeAxisViewModel }) {\n        // Just a mutation of existing tick details, sync the element\n        if (timeAxisViewModel.timeAxis.includes(this.context?.tick)) {\n            this.syncContextElement();\n        }\n        // The tick has gone, we have moved to a new ViewPreset, so clear the context.\n        else {\n            this.clearContext();\n        }\n    }\n\n    clearContext() {\n        this.context = null;\n    }\n\n    updateContext(context, oldContext) {\n        this.syncContextElement();\n    }\n\n    syncContextElement() {\n        if (this.context && this.enabled) {\n            const\n                me  = this,\n                {\n                    client,\n                    element,\n                    context,\n                    renderer\n                }   = me,\n                {\n                    isVertical\n                }   = client,\n                {\n                    style\n                }   = element,\n                row = isVertical ? client.rowManager.rows[0] : client.getRowFor(context.resourceRecord);\n\n            if (row) {\n                const\n                    {\n                        tickStartDate,\n                        tickEndDate,\n                        resourceRecord\n                    } = context,\n                    // get the position clicked based on dates\n                    renderData = client.currentOrientation.getTimeSpanRenderData({\n                        startDate   : tickStartDate,\n                        endDate     : tickEndDate,\n                        startDateMS : tickStartDate.getTime(),\n                        endDateMS   : tickEndDate.getTime()\n                    }, resourceRecord);\n\n                let top, width, height;\n\n                if (isVertical) {\n                    top = renderData.top;\n                    width = renderData.resourceWidth;\n                    height = renderData.height;\n                }\n                else {\n                    top = row.top;\n                    width = renderData.width;\n                    height = row.height;\n                }\n\n                // Move to current cell\n                style.display = '';\n                style.width = `${width}px`;\n                style.height = `${height}px`;\n                DomHelper.setTranslateXY(element, renderData.left, top);\n\n                // In case we updated on a datachange action : 'remove' or 'add' event.\n                context.index = row.index;\n\n                // Undo any contents added by the renderer last time round.\n                element.innerHTML = '';\n\n                // Show the context and the element to the renderer\n                renderer && me.callback(renderer, me, [context, element]);\n            }\n            // No row for resource might mean it's scrolled out of view or filtered out\n            // so just hide so that the next valid sync can restore it to visibility\n            else {\n                style.display = 'none';\n            }\n        }\n        else {\n            this.element.style.display = 'none';\n        }\n    }\n}\n\nScheduleContext.featureClass = 'b-scheduler-context';\n\nGridFeatureManager.registerFeature(ScheduleContext, false, ['Scheduler']);\n", "import AttachToProjectMixin from '../../Scheduler/data/mixin/AttachToProjectMixin.js';\nimport CopyPasteBase from '../../Grid/feature/base/CopyPasteBase.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport './ScheduleContext.js';\n\n/**\n * @module Scheduler/feature/EventCopyPaste\n */\n\n/**\n * Allow using [Ctrl/CMD + C/X] and [Ctrl/CMD + V] to copy/cut and paste events.\n *\n * This feature also adds entries to the {@link Scheduler/feature/EventMenu} for copying & cutting (see example below\n * for how to configure) and to the {@link Scheduler/feature/ScheduleMenu} for pasting.\n *\n * You can configure how a newly pasted record is named using {@link #function-generateNewName}.\n *\n * {@inlineexample Scheduler/feature/EventCopyPaste.js}\n *\n * If you want to highlight the paste location when clicking in the schedule, consider enabling the\n * {@link Scheduler/feature/ScheduleContext} feature.\n *\n * <div class=\"note\">When used with Scheduler Pro, pasting will bypass any constraint set on the event to allow the\n * copy to be assigned the targeted date.</div>\n *\n * This feature is **enabled** by default.\n *\n * ## Customize menu items\n *\n * See {@link Scheduler/feature/EventMenu} and {@link Scheduler/feature/ScheduleMenu} for more info on customizing the\n * menu items supplied by the feature. This snippet illustrates the concept:\n *\n * ```javascript\n * // Custom copy text + remove cut option from event menu:\n * const scheduler = new Scheduler({\n *     features : {\n *         eventMenu : {\n *             items : {\n *                 copyEvent : {\n *                     text : 'Copy booking'\n *                 },\n *                 cutEvent  : false\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * ## Keyboard shortcuts\n *\n * The feature has the following default keyboard shortcuts:\n *\n * | Keys       | Action   | Action description                                |\n * |------------|----------|---------------------------------------------------|\n * | `Ctrl`+`C` | *copy*   | Copies selected event(s) into the clipboard.      |\n * | `Ctrl`+`X` | *cut*    | Cuts out selected event(s) into the clipboard.    |\n * | `Ctrl`+`V` | *paste*  | Insert copied or cut event(s) from the clipboard. |\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#Scheduler/guides/customization/keymap.md).\n *\n * ## Multi assigned events\n *\n * In a Scheduler that uses single assignment, copying and then pasting creates a clone of the event and assigns it\n * to the target resource. Cutting and pasting moves the original event to the target resource.\n *\n * In a Scheduler using multi assignment, the behaviour is slightly more complex. Cutting and pasting reassigns the\n * event to the target, keeping other assignments of the same event intact. The behaviour for copying and pasting is\n * configurable using the {@link #config-copyPasteAction} config. It accepts two values:\n *\n * * `'clone'` - The default, the event is cloned and the clone is assigned to the target resource. Very similar to the\n *   behaviour with single assignment (event count goes up by 1).\n * * `'assign'` - The original event is assigned to the target resource (event count is unaffected).\n *\n * This snippet shows how to reconfigure it:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         eventCopyPaste : {\n *             copyPasteAction : 'assign'\n *         }\n *     }\n * });\n * ```\n *\n * <div class=\"note\">Copying multiple assignments of the same event will always result in all but the first assignment\n * being removed on paste, since paste targets a single resource and an event can only be assigned to a resource once.\n * </div>\n *\n * ## Native/shared clipboard\n *\n * If you have multiple Schedulers (or other Bryntum products) on the same page, they will share clipboard. This makes\n * it possible to copy and paste between different Scheduler instances. It is also possible to use the native Clipboard\n * API if it is available and if you set {@link #config-useNativeClipboard} to `true`.\n *\n * Regardless of native clipboard availability, copy-pasting \"outside\" of the current Scheduler instance will convert\n * the copied events to a string. When pasting, the string will then be parsed back into events. In case of usage of the\n * native Clipboard API, this means it is possible to copy and paste events between completely different applications.\n *\n * To configure the fields that is converted and parsed from the copied string value, please see the\n * {@link #config-eventToStringFields} config.\n *\n * @extends Grid/feature/base/CopyPasteBase\n * @classtype eventCopyPaste\n * @feature\n */\n\nexport default class EventCopyPaste extends CopyPasteBase.mixin(AttachToProjectMixin) {\n    static $name = 'EventCopyPaste';\n\n    static pluginConfig = {\n        assign : [\n            'copyEvents',\n            'pasteEvents'\n        ],\n        chain : [\n            'populateEventMenu',\n            'populateScheduleMenu',\n            'onEventDataGenerated'\n        ]\n    };\n\n    static configurable = {\n        /**\n         * The field to use as the name field when updating the name of copied records\n         * @config {String}\n         * @default\n         */\n        nameField : 'name',\n\n        /**\n         * How to handle a copy paste operation when the host uses multi assignment. Either:\n         *\n         * - `'clone'`  - The default, clone the copied event, assigning the clone to the target resource.\n         * - `'assign'` - Add an assignment for the existing event to the target resource.\n         *\n         * For single assignment mode, it always uses the `'clone'` behaviour.\n         *\n         * @config {'clone'|'assign'}\n         * @default\n         */\n        copyPasteAction : 'clone',\n\n        /**\n         * When copying events (or assignments), data will be sent to the clipboard as a tab (`\\t`) and new-line (`\\n`)\n         * separated string with field values for fields present in this config (in specified order). The default\n         * included fields are (in this order):\n         * * name\n         * * startDate\n         * * endDate\n         * * duration\n         * * durationUnit\n         * * allDay\n         * To override, provide your own array of fields:\n         * ```javascript\n         * new Scheduler({\n         *     features : {\n         *         eventCopyPaste : {\n         *             eventToStringFields : [\n         *                'name',\n         *                'startDate',\n         *                'endDate',\n         *                'percentDone'\n         *             ]\n         *         }\n         *     }\n         * });\n         * ```\n         * <div class=\"note\">Please note that this config is both used for **converting** events to a string value and\n         * is also used to **parse** a string value to events.</div>\n         * @config {Array<String>}\n         */\n        eventToStringFields : ['name', 'startDate', 'endDate', 'duration', 'durationUnit', 'allDay']\n    };\n\n    construct(scheduler, config) {\n        super.construct(scheduler, config);\n\n        scheduler.ion({\n            eventClick    : 'onEventClick',\n            scheduleClick : 'onScheduleClick',\n            projectChange : () => {\n                this.clearClipboard();\n                this._cellClickedContext = null;\n            },\n            thisObj : this\n        });\n    }\n\n    // Used in events to separate events from different features from each other\n    entityName = 'event';\n\n    get scheduler() {\n        return this.client;\n    }\n\n    attachToEventStore(eventStore) {\n        super.attachToEventStore(eventStore);\n        delete this._eventClickedContext;\n    }\n\n    onEventDataGenerated(eventData) {\n        const { assignmentRecord } = eventData;\n\n        // No assignmentRecord for resource time ranges, which we want to ignore anyway\n        if (assignmentRecord) {\n            eventData.cls['b-cut-item'] = assignmentRecord.meta.isCut;\n        }\n    }\n\n    onEventClick(context) {\n        this._cellClickedContext = null;\n        this._eventClickedContext = context;\n    }\n\n    onScheduleClick(context) {\n        this._cellClickedContext = context;\n        this._eventClickedContext = null;\n    }\n\n    isActionAvailable({ event }) {\n        // No action if\n        // 1. there is selected text on the page\n        // 2. cell editing is active\n        // 3. cursor is not in the grid (filter bar etc)\n        // 4. focus is on specialrow\n        return !this.disabled &&\n            globalThis.getSelection().toString().length === 0 &&\n            !this.client.features.cellEdit?.isEditing &&\n            Boolean(event.target.closest('.b-timeaxissubgrid')) &&\n            !this.client.focusedCell?.isSpecialRow;\n    }\n\n    async copy() {\n        await this.copyEvents();\n    }\n\n    async cut() {\n        await this.copyEvents(undefined, true);\n    }\n\n    async paste() {\n        await this.pasteEvents();\n    }\n\n    /**\n     * Copy events (when using single assignment mode) or assignments (when using multi assignment mode) to clipboard to\n     * paste later\n     * @fires beforeCopy\n     * @fires copy\n     * @param {Scheduler.model.EventModel[]|Scheduler.model.AssignmentModel[]} [records] Pass records to copy them,\n     * leave out to copying current selection\n     * @param {Boolean} [isCut] Copies by default, pass `true` to cut instead\n     * @category Edit\n     * @on-owner\n     */\n    async copyEvents(records = this.scheduler.selectedAssignments, isCut = false) {\n        const\n            me            = this,\n            { scheduler } = me;\n\n        // Relay to original if split\n        if (scheduler.splitFrom) {\n            return scheduler.splitFrom.features.eventCopyPaste.copyEvents(records, isCut);\n        }\n\n        if (!records?.length) {\n            return;\n        }\n\n        let assignmentRecords = records.slice(); // Slice to not lose records if selection changes\n\n        if (records[0].isEventModel) {\n            assignmentRecords = records.map(r => r.assignments).flat();\n        }\n\n        // Prevent cutting readOnly events\n        if (isCut) {\n            assignmentRecords = assignmentRecords.filter(a => !a.event.readOnly);\n        }\n\n        const eventRecords = assignmentRecords.map(a => a.event);\n\n        if (!assignmentRecords.length || scheduler.readOnly) {\n            return;\n        }\n\n        await me.writeToClipboard({ assignmentRecords, eventRecords }, isCut);\n\n        /**\n         * Fires on the owning Scheduler after a copy action is performed.\n         * @event copy\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source Owner scheduler\n         * @param {Scheduler.model.EventModel[]} eventRecords The event records that were copied\n         * @param {Scheduler.model.AssignmentModel[]} assignmentRecords The assignment records that were copied\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'event' to distinguish this event from other copy events\n         */\n        scheduler.trigger('copy', { assignmentRecords, eventRecords, isCut, entityName : me.entityName });\n\n        // refresh to call onEventDataGenerated and reapply the cls for records where the cut was canceled\n        scheduler.refreshWithTransition();\n\n        me._focusedEventOnCopy = me._eventClickedContext;\n    }\n\n    async beforeCopy({ data : { assignmentRecords, eventRecords }, isCut }) {\n        /**\n         * Fires on the owning Scheduler before a copy action is performed, return `false` to prevent the action\n         * @event beforeCopy\n         * @preventable\n         * @on-owner\n         * @async\n         * @param {Scheduler.view.Scheduler} source Owner scheduler\n         * @param {Scheduler.model.EventModel[]} eventRecords The event records about to be copied\n         * @param {Scheduler.model.AssignmentModel[]} assignmentRecords The assignment records about to be copied\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'event' to distinguish this event from other beforeCopy events\n         */\n        return await this.scheduler.trigger('beforeCopy',\n            { assignmentRecords,  eventRecords, isCut, entityName : this.entityName });\n    }\n\n    // Called from Clipboardable when cutData changes\n    handleCutData({ source }) {\n        const me = this;\n\n        if (source !== me && me.cutData?.length) {\n            const { assignmentRecords, eventRecords } = me.cutData[0];\n\n            if (assignmentRecords?.length) {\n                me.scheduler.assignmentStore.remove(assignmentRecords);\n            }\n            if (eventRecords?.length) {\n                me.scheduler.eventStore.remove(eventRecords);\n            }\n        }\n    }\n\n    /**\n     * Called from Clipboardable after writing a non-string value to the clipboard\n     * @param eventRecords\n     * @returns {string}\n     * @private\n     */\n    stringConverter({ eventRecords }) {\n        const rows = [];\n\n        for (const event of eventRecords) {\n            rows.push(this.eventToStringFields.map(field => {\n                const value = event[field];\n\n                if (value instanceof Date) {\n                    return DateHelper.format(value, this.dateFormat);\n                }\n\n                return value;\n            }).join('\\t'));\n        }\n\n        return rows.join('\\n');\n    }\n\n    // Called from Clipboardable for each cut out record\n    setIsCut({ assignmentRecords }, isCut) {\n        assignmentRecords.forEach(assignment => {\n            assignment.meta.isCut = isCut;\n        });\n        // refresh to call onEventDataGenerated and reapply the cls for records where the cut was canceled\n        this.scheduler.refreshWithTransition();\n    }\n\n    /**\n     * Paste events or assignments to specified date and resource\n     * @fires beforePaste\n     * @fires paste\n     * @param {Date} [date] Date where the events or assignments will be pasted\n     * @param {Scheduler.model.ResourceModel} [resourceRecord] Resource to assign the pasted events or assignments to\n     * @category Edit\n     * @on-owner\n     */\n    async pasteEvents(date, resourceRecord) {\n        const\n            me            = this,\n            { scheduler } = me;\n\n        // Relay to original if split\n        if (scheduler.splitFrom) {\n            return scheduler.splitFrom.features.eventCopyPaste.pasteEvents(date, resourceRecord);\n        }\n\n        const\n            {\n                entityName,\n                isCut,\n                _cellClickedContext,\n                _eventClickedContext\n            }  = me,\n            {\n                eventStore,\n                assignmentStore\n            }  = scheduler;\n\n        if (arguments.length === 0) {\n            if (_cellClickedContext) {\n                date           = _cellClickedContext.date;\n                resourceRecord = _cellClickedContext.resourceRecord;\n            }\n            else if (me._focusedEventOnCopy !== _eventClickedContext) {\n                date           = _eventClickedContext.eventRecord.startDate;\n                resourceRecord = _eventClickedContext.resourceRecord;\n            }\n\n        }\n\n        if (resourceRecord) {\n            resourceRecord = resourceRecord.$original;\n        }\n\n        const clipboardData = await me.readFromClipboard({ resourceRecord, date });\n\n        if (!clipboardData?.assignmentRecords?.length) {\n            return;\n        }\n\n        const\n            {\n                assignmentRecords,\n                eventRecords\n            }            = clipboardData;\n        let toFocus      = null;\n\n        const\n            pastedEvents = new Set(),\n            pastedEventRecords = [];\n\n        for (const assignmentRecord of assignmentRecords) {\n            let { event }            = assignmentRecord;\n            const\n                targetResourceRecord = resourceRecord || assignmentRecord.resource,\n                targetDate           = date || assignmentRecord.event.startDate;\n\n            // Pasting targets a specific resource, we cannot have multiple assignments to the same so remove all but\n            // the first (happens when pasting multiple assignments of the same event)\n            if (pastedEvents.has(event)) {\n                if (isCut) {\n                    assignmentRecord.remove();\n                }\n                continue;\n            }\n\n            pastedEvents.add(event);\n\n            // Cut always means reassign\n            if (isCut) {\n                assignmentRecord.meta.isCut = false;\n                assignmentRecord.resource   = targetResourceRecord;\n                toFocus                     = assignmentRecord;\n            }\n            // Copy creates a new event in single assignment, or when configured to copy\n            else if (eventStore.usesSingleAssignment || me.copyPasteAction === 'clone') {\n                event      = event.copy();\n                event.name = me.generateNewName(event);\n                eventStore.add(event);\n                event.assign(targetResourceRecord);\n                toFocus = assignmentStore.last;\n            }\n            // Safeguard against pasting on a resource where the event is already assigned,\n            // a new assignment in multiassign mode will only change the date in such case\n            else if (!event.resources.includes(targetResourceRecord)) {\n                const newAssignmentRecord    = assignmentRecord.copy();\n                newAssignmentRecord.resource = targetResourceRecord;\n                [toFocus]                    = assignmentStore.add(newAssignmentRecord);\n            }\n\n            event.startDate = targetDate;\n\n            // Pro specific, to allow event to appear where pasted\n            if (event.constraintDate) {\n                event.constraintDate = null;\n            }\n\n            pastedEventRecords.push(event);\n        }\n\n        /**\n         * Fires on the owning Scheduler after a paste action is performed.\n         * @event paste\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source Owner scheduler\n         * @param {Scheduler.model.EventModel[]} eventRecords Original events\n         * @param {Scheduler.model.EventModel[]} pastedEventRecords Pasted events\n         * @param {Scheduler.model.AssignmentModel[]} assignmentRecords Pasted assignments\n         * @param {Date} date date Pasted to this date\n         * @param {Scheduler.model.ResourceModel} resourceRecord The target resource record\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'event' to distinguish this event from other paste events\n         */\n        scheduler.trigger('paste', { assignmentRecords, pastedEventRecords, eventRecords, resourceRecord, date, isCut, entityName });\n\n        // Focus the last pasted assignment\n        const detacher = scheduler.ion({\n            renderEvent({ assignmentRecord }) {\n                if (assignmentRecord === toFocus) {\n                    scheduler.navigateTo(assignmentRecord, { scrollIntoView : false });\n                    detacher();\n                }\n            }\n        });\n\n        if (isCut) {\n            await me.clearClipboard();\n        }\n    }\n\n    // Called from Clipboardable before finishing the internal clipboard read\n    async beforePaste({ data : { assignmentRecords, eventRecords }, resourceRecord, isCut, date }) {\n        const\n            { scheduler } = this,\n            eventData     = {\n                assignmentRecords,\n                eventRecords,\n                resourceRecord : resourceRecord || assignmentRecords[0].resource,\n                date,\n                isCut,\n                entityName     : this.entityName\n            };\n        let reason;\n\n        // No pasting to readOnly resources\n        if (resourceRecord?.readOnly) {\n            reason = 'resourceReadOnly';\n        }\n\n        if (!scheduler.allowOverlap) {\n            const pasteWouldResultInOverlap = assignmentRecords.some(assignmentRecord => !scheduler.isDateRangeAvailable(\n                assignmentRecord.event.startDate,\n                assignmentRecord.event.endDate,\n                isCut ? assignmentRecord.event : null,\n                assignmentRecord.resource)\n            );\n\n            if (pasteWouldResultInOverlap) {\n                reason = 'overlappingEvents';\n            }\n        }\n\n        /**\n         * Fires on the owning Scheduler if a paste action is not allowed\n         * @event pasteNotAllowed\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source Owner scheduler\n         * @param {Scheduler.model.EventModel[]} eventRecords\n         * @param {Scheduler.model.AssignmentModel[]} assignmentRecords\n         * @param {Date} date The paste date\n         * @param {Scheduler.model.ResourceModel} resourceRecord The target resource record\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'event' to distinguish this event from other `pasteNotAllowed` events\n         * @param {'overlappingEvents'|'resourceReadOnly'} reason A string id to use for displaying an error message to the user.\n         */\n        if (reason) {\n            scheduler.trigger('pasteNotAllowed', {\n                ...eventData,\n                reason\n            });\n            return false;\n        }\n\n        /**\n         * Fires on the owning Scheduler before a paste action is performed, return `false` to prevent the action\n         * @event beforePaste\n         * @preventable\n         * @on-owner\n         * @async\n         * @param {Scheduler.view.Scheduler} source Owner scheduler\n         * @param {Scheduler.model.EventModel[]} eventRecords The events about to be pasted\n         * @param {Scheduler.model.AssignmentModel[]} assignmentRecords The assignments about to be pasted\n         * @param {Date} date The date when the pasted events will be scheduled\n         * @param {Scheduler.model.ResourceModel} resourceRecord The target resource record, the clipboard\n         * event records will be assigned to this resource.\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'event' to distinguish this event from other beforePaste events\n         */\n        return await this.scheduler.trigger('beforePaste', eventData);\n    }\n\n    /**\n     * Called from Clipboardable after reading from clipboard, and it is determined that the clipboard data is\n     * \"external\"\n     * @param json\n     * @returns {Object}\n     * @private\n     */\n    stringParser(clipboardData) {\n        const\n            { eventStore, assignmentStore }    = this.scheduler,\n            { modifiedRecords : eventRecords } = this.setFromStringData(clipboardData, true, eventStore, this.eventToStringFields),\n            assignmentRecords                  = [];\n\n        for (const event of eventRecords) {\n            const assignment = new assignmentStore.modelClass({ eventId : event.id });\n            assignment.event = event;\n            assignmentRecords.push(assignment);\n        }\n        return { eventRecords, assignmentRecords };\n    }\n\n    populateEventMenu({ assignmentRecord, items }) {\n        const\n            me            = this,\n            { scheduler } = me;\n\n        if (!scheduler.readOnly) {\n            items.copyEvent = {\n                text        : 'L{copyEvent}',\n                localeClass : me,\n                icon        : 'b-icon b-icon-copy',\n                weight      : 110,\n                onItem      : () => {\n                    const assignments = scheduler.isAssignmentSelected(assignmentRecord) ? scheduler.selectedAssignments : [assignmentRecord];\n\n                    me.copyEvents(assignments);\n                }\n            };\n\n            items.cutEvent = {\n                text        : 'L{cutEvent}',\n                localeClass : me,\n                icon        : 'b-icon b-icon-cut',\n                weight      : 120,\n                disabled    : assignmentRecord.event.readOnly,\n                onItem      : () => {\n                    const assignments = scheduler.isAssignmentSelected(assignmentRecord) ? scheduler.selectedAssignments : [assignmentRecord];\n                    me.copyEvents(assignments, true);\n                }\n            };\n        }\n    }\n\n    populateScheduleMenu({ items, resourceRecord }) {\n        const\n            me            = this,\n            { scheduler } = me;\n\n        if (!scheduler.readOnly && me.hasClipboardData() !== false) {\n            items.pasteEvent = {\n                text        : 'L{pasteEvent}',\n                localeClass : me,\n                icon        : 'b-icon b-icon-paste',\n                disabled    : scheduler.resourceStore.count === 0 || resourceRecord.readOnly,\n                weight      : 110,\n                onItem      : ({\n                    date, resourceRecord\n                }) => me.pasteEvents(date, resourceRecord, scheduler.getRowFor(resourceRecord))\n            };\n        }\n    }\n\n    /**\n     * A method used to generate the name for a copy pasted record. By defaults appends \"- 2\", \"- 3\" as a suffix.\n     *\n     * @param {Scheduler.model.EventModel} eventRecord The new eventRecord being pasted\n     * @returns {String}\n     */\n    generateNewName(eventRecord) {\n        const originalName = eventRecord.getValue(this.nameField);\n        let counter = 2;\n\n        while (this.client.eventStore.findRecord(this.nameField, `${originalName} - ${counter}`)) {\n            counter++;\n        }\n\n        return `${originalName} - ${counter}`;\n    }\n}\n\nEventCopyPaste.featureClass = 'b-event-copypaste';\n\nGridFeatureManager.registerFeature(EventCopyPaste, true, 'Scheduler');\n", "import DragBase from './base/DragBase.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\n\n/**\n * @module Scheduler/feature/EventDrag\n */\n\n/**\n * Allows user to drag and drop events within the scheduler, to change startDate or resource assignment.\n *\n * This feature is **enabled** by default\n *\n * ## Customizing the drag drop tooltip\n *\n * To show custom HTML in the tooltip, please see the {@link #config-tooltipTemplate} config. Example:\n *\n * ```javascript\n * features: {\n *     eventDrag : {\n *         // A minimal start date tooltip\n *         tooltipTemplate : ({ eventRecord, startDate }) => {\n *             return DateHelper.format(startDate, 'HH:mm');\n *         }\n *     }\n * }\n * ```\n *\n * ## Constraining the drag drop area\n *\n * You can constrain how the dragged event is allowed to move by using the following configs\n * * {@link #config-constrainDragToResource} Resource fixed, only allowed to change start date\n * * {@link #config-constrainDragToTimeSlot} Start date is fixed, only move between resources\n * * {@link Scheduler.view.Scheduler#config-getDateConstraints} A method on the Scheduler instance\n *    which lets you define the date range for the dragged event programmatically\n *\n * ```js\n * // Enable dragging + constrain drag to current resource\n * const scheduler = new Scheduler({\n *     features : {\n *         eventDrag : {\n *             constrainDragToResource : true\n *         }\n *     }\n * });\n * ```\n *\n * ## Drag drop events from outside\n *\n * Dragging unplanned events from an external grid is a very popular use case. There are\n * several demos showing you how to do this. Please see the [Drag from grid demo](../examples/dragfromgrid)\n * and study the **Drag from grid guide** to learn more.\n *\n * ## Drag drop events to outside target\n *\n * You can also drag events outside the schedule area by setting {@link #config-constrainDragToTimeline} to `false`. You\n * should also either:\n * * provide a {@link #config-validatorFn} to programmatically define if a drop location is valid or not\n * * configure a {@link #config-externalDropTargetSelector} CSS selector to define where drops are allowed\n *\n * See [this demo](../examples/drag-outside) to see this in action.\n *\n * ## Validating drag drop\n *\n * It is easy to programmatically decide what is a valid drag drop operation. Use the {@link #config-validatorFn}\n * and return either `true` / `false` (optionally a message to show to the user).\n *\n * ```javascript\n * features : {\n *     eventDrag : {\n *        validatorFn({ eventRecords, newResource }) {\n *            const task  = eventRecords[0],\n *                  valid = newResource.role === task.resource.role;\n *\n *            return {\n *                valid   : newResource.role === task.resource.role,\n *                message : valid ? '' : 'Resource role does not match required role for this task'\n *            };\n *        }\n *     }\n * }\n * ```\n *\n * See [this demo](../examples/validation) to see validation in action.\n *\n * If you instead want to do a single validation upon drop, you can listen to {@link #event-beforeEventDropFinalize}\n * and set the `valid` flag on the context object provided.\n *\n * ```javascript\n *   const scheduler = new Scheduler({\n *      listeners : {\n *          beforeEventDropFinalize({ context }) {\n *              const { eventRecords } = context;\n *              // Don't allow dropping events in the past\n *              context.valid = Date.now() <= eventRecords[0].startDate;\n *          }\n *      }\n *  });\n * ```\n *\n * ## Preventing drag of certain events\n *\n * To prevent certain events from being dragged, you have two options. You can set {@link Scheduler.model.EventModel#field-draggable}\n * to `false` in your data, or you can listen for the {@link Scheduler.view.Scheduler#event-beforeEventDrag} event and\n * return `false` to block the drag.\n *\n * ```javascript\n * new Scheduler({\n *    listeners : {\n *        beforeEventDrag({ eventRecord }) {\n *            // Don't allow dragging events that have already started\n *            return Date.now() <= eventRecord.startDate;\n *        }\n *    }\n * })\n * ```\n *\n * @extends Scheduler/feature/base/DragBase\n * @demo Scheduler/basic\n * @inlineexample Scheduler/feature/EventDrag.js\n * @classtype eventDrag\n * @feature\n */\nexport default class EventDrag extends DragBase {\n    //region Config\n\n    static get $name() {\n        return 'EventDrag';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * Template used to generate drag tooltip contents.\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         eventDrag : {\n             *             dragTipTemplate({eventRecord, startText}) {\n             *                 return `${eventRecord.name}: ${startText}`\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             * @config {Function} tooltipTemplate\n             * @param {Object} data Tooltip data\n             * @param {Scheduler.model.EventModel} data.eventRecord\n             * @param {Boolean} data.valid Currently over a valid drop target or not\n             * @param {Date} data.startDate New start date\n             * @param {Date} data.endDate New end date\n             * @returns {String}\n             */\n\n            /**\n             * Set to true to only allow dragging events within the same resource.\n             * @member {Boolean} constrainDragToResource\n             */\n            /**\n             * Set to true to only allow dragging events within the same resource.\n             * @config {Boolean}\n             * @default\n             */\n            constrainDragToResource : false,\n\n            /**\n             * Set to true to only allow dragging events to different resources, and disallow rescheduling by dragging.\n             * @member {Boolean} constrainDragToTimeSlot\n             */\n            /**\n             * Set to true to only allow dragging events to different resources, and disallow rescheduling by dragging.\n             * @config {Boolean}\n             * @default\n             */\n            constrainDragToTimeSlot : false,\n\n            /**\n             * A CSS selector specifying elements outside the scheduler element which are valid drop targets.\n             * @config {String}\n             */\n            externalDropTargetSelector : null,\n\n            /**\n             * An empty function by default, but provided so that you can perform custom validation on the item being\n             * dragged. This function is called during the drag and drop process and also after the drop is made.\n             * Return `true` if the new position is valid, `false` to prevent the drag.\n             *\n             * ```javascript\n             * features : {\n             *     eventDrag : {\n             *         validatorFn({ eventRecords, newResource }) {\n             *             const\n             *                 task  = eventRecords[0],\n             *                 valid = newResource.role === task.resource.role;\n             *\n             *             return {\n             *                 valid   : newResource.role === task.resource.role,\n             *                 message : valid ? '' : 'Resource role does not match required role for this task'\n             *             };\n             *         }\n             *     }\n             * }\n             * ```\n             * @param {Object} context A drag drop context object\n             * @param {Date} context.startDate New start date\n             * @param {Date} context.endDate New end date\n             * @param {Scheduler.model.AssignmentModel[]} context.assignmentRecords Assignment records which were dragged\n             * @param {Scheduler.model.EventModel[]} context.eventRecords Event records which were dragged\n             * @param {Scheduler.model.ResourceModel} context.newResource New resource record\n             * @param {Scheduler.model.EventModel} context.targetEventRecord Currently hovering this event record\n             * @param {Event} event The event object\n             * @returns {Boolean|Object} `true` if this validation passes, `false` if it does not.\n             *\n             * Or an object with 2 properties: `valid` -  Boolean `true`/`false` depending on validity,\n             * and `message` - String with a custom error message to display when invalid.\n             * @config {Function}\n             */\n            validatorFn : (context, event) => {},\n\n            /**\n             * The `this` reference for the validatorFn\n             * @config {Object}\n             */\n            validatorFnThisObj : null,\n\n            /**\n             * When the host Scheduler is `{@link Scheduler.view.mixin.EventSelection#config-multiEventSelect}: true`\n             * then, there are two modes of dragging *within the same Scheduler*.\n             *\n             * Non unified means that all selected events are dragged by the same number of resource rows.\n             *\n             * Unified means that all selected events are collected together and dragged as one, and are all dropped\n             * on the same targeted resource row at the same targeted time.\n             * @member {Boolean} unifiedDrag\n             */\n            /**\n             * When the host Scheduler is `{@link Scheduler.view.mixin.EventSelection#config-multiEventSelect}: true`\n             * then, there are two modes of dragging *within the same Scheduler*.\n             *\n             * Non unified means that all selected events are dragged by the same number of resource rows.\n             *\n             * Unified means that all selected events are collected together and dragged as one, and are all dropped\n             * on the same targeted resource row at the same targeted time.\n             * @config {Boolean}\n             * @default false\n             */\n            unifiedDrag : null,\n\n            /**\n             * A hook that allows manipulating the position the drag proxy snaps to. Manipulate the `snapTo` property\n             * to alter snap position.\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         eventDrag : {\n             *             snapToPosition({ eventRecord, snapTo }) {\n             *                 if (eventRecord.late) {\n             *                     snapTo.x = 400;\n             *                 }\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             *\n             * @config {Function}\n             * @param {Object} context\n             * @param {Scheduler.model.AssignmentModel} context.assignmentRecord Dragged assignment\n             * @param {Scheduler.model.EventModel} context.eventRecord Dragged event\n             * @param {Scheduler.model.ResourceModel} context.resourceRecord Currently over this resource\n             * @param {Date} context.startDate Start date for current position\n             * @param {Date} context.endDate End date for current position\n             * @param {Object} context.snapTo\n             * @param {Number} context.snapTo.x X to snap to\n             * @param {Number} context.snapTo.y Y to snap to\n             */\n            snapToPosition : null,\n\n            /**\n             * A modifier key (CTRL, SHIFT, ALT, META) that when pressed will copy an event instead of moving it. Set to\n             * empty string to disable copying\n             * @prp {'CTRL'|'ALT'|'SHIFT'|'META'|''}\n             * @default\n             */\n            copyKey : 'SHIFT',\n\n            /**\n             * Event can be copied two ways: either by adding new assignment to an existing event ('assignment'), or\n             * by copying the event itself ('event'). 'auto' mode will pick 'event' for a single-assignment mode (when\n             * event has `resourceId` field) and 'assignment' mode otherwise.\n             * @prp {'auto'|'assignment'|'event'}\n             * @default\n             */\n            copyMode : 'auto',\n\n            /**\n             * Mode of the current drag drop operation.\n             * @member {'move'|'copy'}\n             * @readonly\n             */\n            mode : 'move',\n\n            capitalizedEventName : null\n        };\n    }\n\n    afterConstruct() {\n        this.capitalizedEventName = this.capitalizedEventName || this.client.capitalizedEventName;\n        super.afterConstruct(...arguments);\n    }\n\n    //endregion\n\n    changeMode(value) {\n        const { dragData, copyMode } = this;\n\n        // Do not create assignments in case scheduler doesn't use multiple assignments\n        // Do not allow to copy recurring events\n        if (\n            (copyMode === 'event' || copyMode === 'auto' ||\n                copyMode === 'assignment' && !this.scheduler.eventStore.usesSingleAssignment) &&\n            (!dragData || dragData.eventRecords.every(r => !r.isRecurring))\n        ) {\n            return value;\n        }\n    }\n\n    updateMode(mode) {\n        if (this.dragData) {\n            if (mode === 'copy') {\n                this.setCopying();\n            }\n            else {\n                this.setMoving();\n            }\n\n            /**\n             * Triggered when drag mode is changed, for example when copy key is\n             * pressed or released while dragging.\n             * @event eventDragModeChange\n             * @param {String} mode Drag mode, could be either 'move', 'copy', or 'auto'\n             * @on-owner\n             */\n            this.client.trigger('eventDragModeChange', { mode });\n        }\n    }\n\n    setCopying() {\n        const { dragData } = this;\n\n        if (!dragData) {\n            return;\n        }\n\n        // Check if proxies are added to the DOM by checking if any of them is\n        if (!dragData.eventBarCopies.some(el => el.isConnected)) {\n            dragData.eventBarCopies.forEach(el => {\n                el.classList.add('b-drag-proxy-copy');\n                // hidden class can be added by the drag feature if we're dragging event outside\n                el.classList.remove('b-hidden');\n\n                dragData.context.grabbedParent.appendChild(el);\n                // Mark this node as ignored for the DomSync\n                el.retainElement = true;\n            });\n        }\n        else {\n            dragData.eventBarCopies.forEach(el => {\n                el.classList.remove('b-hidden');\n            });\n        }\n    }\n\n    setMoving() {\n        const { dragData } = this;\n\n        if (!dragData) {\n            return;\n        }\n\n        dragData.eventBarCopies.forEach(el => {\n            el.classList.add('b-hidden');\n        });\n    }\n\n    //region Events\n\n    /**\n     * Fired on the owning Scheduler to allow implementer to use asynchronous finalization by setting `context.async = true`\n     * in the listener, to show a confirmation popup etc.\n     * ```javascript\n     *  scheduler.on('beforeeventdropfinalize', ({ context }) => {\n     *      context.async = true;\n     *      setTimeout(() => {\n     *          // async code don't forget to call finalize\n     *          context.finalize();\n     *      }, 1000);\n     *  })\n     * ```\n     *\n     * For synchronous one-time validation, simply set `context.valid` to true or false.\n     * ```javascript\n     *  scheduler.on('beforeeventdropfinalize', ({ context }) => {\n     *      context.valid = false;\n     *  })\n     * ```\n     * @event beforeEventDropFinalize\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Object} context\n     * @param {Boolean} context.async Set true to not finalize the drag-drop operation immediately (e.g. to wait for user confirmation)\n     * @param {Scheduler.model.EventModel[]} context.eventRecords Event records being dragged\n     * @param {Scheduler.model.AssignmentModel[]} context.assignmentRecords Assignment records being dragged\n     * @param {Scheduler.model.EventModel} context.targetEventRecord Event record for drop target\n     * @param {Scheduler.model.ResourceModel} context.newResource Resource record for drop target\n     * @param {Boolean} context.valid Set this to `false` to abort the drop immediately.\n     * @param {Function} context.finalize Call this method after an **async** finalization flow, to finalize the drag-drop operation. This method accepts one\n     * argument: pass `true` to update records, or `false` to ignore changes\n     * @param {MouseEvent} domEvent Browser event\n     */\n\n    /**\n     * Fired on the owning Scheduler after event drop\n     * @event afterEventDrop\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords\n     * @param {Scheduler.model.EventModel[]} eventRecords\n     * @param {Boolean} valid\n     * @param {Object} context\n     * @param {MouseEvent} domEvent Browser event\n     */\n\n    /**\n     * Fired on the owning Scheduler when an event is dropped\n     * @event eventDrop\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.EventModel[]} eventRecords\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords\n     * @param {HTMLElement} externalDropTarget The HTML element dropped upon, if drop happened on a valid external drop target\n     * @param {Boolean} isCopy\n     * @param {Object} context\n     * @param {Scheduler.model.EventModel} context.targetEventRecord Event record for drop target\n     * @param {Scheduler.model.ResourceModel} context.newResource Resource record for drop target\n     * @param {MouseEvent} domEvent Browser event\n     */\n\n    /**\n     * Fired on the owning Scheduler before event dragging starts. Return `false` to prevent the action.\n     * @event beforeEventDrag\n     * @on-owner\n     * @preventable\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel} eventRecord Event record the drag starts from\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record the drag starts from\n     * @param {Scheduler.model.EventModel[]} eventRecords Event records being dragged\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords Assignment records being dragged\n     * @param {MouseEvent} event Browser event DEPRECATED (replaced by domEvent)\n     * @param {MouseEvent} domEvent Browser event\n     */\n\n    /**\n     * Fired on the owning Scheduler when event dragging starts\n     * @event eventDragStart\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record the drag starts from\n     * @param {Scheduler.model.EventModel[]} eventRecords Event records being dragged\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords Assignment records being dragged\n     * @param {MouseEvent} event Browser event DEPRECATED (replaced by domEvent)\n     * @param {MouseEvent} domEvent Browser event\n     */\n\n    /**\n     * Fired on the owning Scheduler when event is dragged\n     * @event eventDrag\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel[]} eventRecords Event records being dragged\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords Assignment records being dragged\n     * @param {Date} startDate Start date for the current location\n     * @param {Date} endDate End date for the current location\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record the drag started from\n     * @param {Scheduler.model.ResourceModel} newResource Resource at the current location\n     * @param {Object} context\n     * @param {Boolean} context.valid Set this to `false` to signal that the current drop position is invalid.\n     * @param {MouseEvent} domEvent Browser event\n     */\n\n    /**\n     * Fired on the owning Scheduler after an event drag operation has been aborted\n     * @event eventDragAbort\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel[]} eventRecords Event records being dragged\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords Assignment records being dragged\n     * @param {MouseEvent} domEvent Browser event\n     */\n    /**\n     * Fired on the owning Scheduler after an event drag operation regardless of the operation being cancelled or not\n     * @event eventDragReset\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     */\n    //endregion\n\n    //region Data layer\n\n    // Deprecated. Use this.client instead\n    get scheduler() {\n        return this.client;\n    }\n\n    //endregion\n\n    //#region Drag lifecycle\n\n    onAfterDragStart(event) {\n        const\n            me                        = this,\n            { context : { element } } = event;\n\n        super.onAfterDragStart(event);\n\n        me.handleKeyDownOrMove(event.event);\n\n        me.keyEventDetacher = EventHelper.on({\n            // In case we drag event between scheduler focused event gets moved and focus\n            // moves to the body. We only need to read the key from this event\n            element : DomHelper.getRootElement(element),\n            keydown : me.handleKeyDownOrMove,\n            keyup   : me.handleKeyUp,\n            thisObj : me\n        });\n    }\n\n    onDragReset(event) {\n        super.onDragReset(event);\n\n        this.keyEventDetacher?.();\n\n        this.mode = 'move';\n    }\n\n    onDrop(event) {\n        // Always remove proxy on drop\n        this.dragData.eventBarCopies?.forEach(el => el.remove());\n\n        return super.onDrop(event);\n    }\n\n    //#endregion\n\n    //region Drag events\n\n    getDraggableElement(el) {\n        return el?.closest(this.drag.targetSelector);\n    }\n\n    resolveEventRecord(eventElement, client = this.client) {\n        return client.resolveEventRecord(eventElement);\n    }\n\n    isElementDraggable(el, event) {\n        const\n            me           = this,\n            { client }   = me,\n            eventElement = me.getDraggableElement(el);\n\n        if (!eventElement || me.disabled || client.readOnly) {\n            return false;\n        }\n\n        // displaying something resizable within the event?\n        if (el.matches('[class$=\"-handle\"]')) {\n            return false;\n        }\n\n        const eventRecord = me.resolveEventRecord(eventElement, client);\n\n        if (!eventRecord || !eventRecord.isDraggable || eventRecord.readOnly) {\n            return false;\n        }\n\n        // Hook for features that need to prevent drag\n        const prevented = client[`is${me.capitalizedEventName}ElementDraggable`]?.(\n            eventElement, eventRecord, el, event\n        ) === false;\n\n        return !prevented;\n    }\n\n    getTriggerParams(dragData) {\n        const { assignmentRecords, eventRecords, resourceRecord, browserEvent : domEvent } = dragData;\n\n        return {\n            // `context` is now private, but used in WebSocketHelper\n            context : dragData,\n            eventRecords,\n            resourceRecord,\n            assignmentRecords,\n            event   : domEvent, // Deprecated, remove on  6.0?\n            domEvent\n        };\n    }\n\n    triggerBeforeEventDrag(eventType, event) {\n        return this.client.trigger(eventType, event);\n    }\n\n    triggerEventDrag(dragData, start) {\n        this.client.trigger('eventDrag', Object.assign(this.getTriggerParams(dragData), {\n            startDate   : dragData.startDate,\n            endDate     : dragData.endDate,\n            newResource : dragData.newResource\n        }));\n    }\n\n    triggerDragStart(dragData) {\n        this.client.navigator.skipNextClick = true;\n\n        this.client.trigger('eventDragStart', this.getTriggerParams(dragData));\n    }\n\n    triggerDragAbort(dragData) {\n        this.client.trigger('eventDragAbort', this.getTriggerParams(dragData));\n    }\n\n    triggerDragAbortFinalized(dragData) {\n        this.client.trigger('eventDragAbortFinalized', this.getTriggerParams(dragData));\n    }\n\n    triggerAfterDrop(dragData, valid) {\n        const me = this;\n\n        me.currentOverClient.trigger('afterEventDrop', Object.assign(me.getTriggerParams(dragData), {\n            valid\n        }));\n\n        if (!valid) {\n            // Edge cases:\n            // 1. If this drag was a no-op, and underlying data was changed while drag was ongoing (e.g. web socket\n            // push), we need to manually force a view refresh to ensure a correct render state\n            //\n            // or\n            // 2. Events were removed before we dropped at an invalid point\n            const\n                { assignmentStore, eventStore } = me.client,\n                needRefresh                     = me.dragData.initialAssignmentsState.find(({\n                    resource, assignment\n                }, i) => {\n                    return !assignmentStore.includes(assignment) ||\n                        !eventStore.includes(assignment.event) ||\n                        resource.id !== me.dragData.assignmentRecords[i]?.resourceId;\n                });\n\n            if (needRefresh) {\n                me.client.refresh();\n            }\n        }\n        // Reset the skipNextClick after a potential click event fires. https://github.com/bryntum/support/issues/5135\n        me.client.setTimeout(() => me.client.navigator.skipNextClick = false, 10);\n    }\n\n    handleKeyDownOrMove(event) {\n        if (this.mode !== 'copy') {\n            if (event.key && EventHelper.specialKeyFromEventKey(event.key) === this.copyKey?.toLowerCase() || event[`${this.copyKey?.toLowerCase()}Key`]) {\n                this.mode = 'copy';\n            }\n        }\n    }\n\n    handleKeyUp(event) {\n        if (EventHelper.specialKeyFromEventKey(event.key) === this.copyKey.toLowerCase()) {\n            this.mode = 'move';\n        }\n    }\n\n    //endregion\n\n    //region Finalization & validation\n\n    /**\n     * Checks if an event can be dropped on the specified position.\n     * @private\n     * @returns {Boolean} Valid (true) or invalid (false)\n     */\n    isValidDrop(dragData) {\n        const\n            {\n                newResource,\n                resourceRecord,\n                browserEvent\n            }            = dragData,\n            sourceRecord = dragData.draggedEntities[0],\n            { target }   = browserEvent;\n\n        // Only allowed to drop outside scheduler element if we hit an element matching the externalDropTargetSelector\n        if (!newResource) {\n            return (!this.constrainDragToTimeline && this.externalDropTargetSelector) ? Boolean(target.closest(this.externalDropTargetSelector)) : false;\n        }\n\n        // Not allowed to drop an event on a group header or a readOnly resource\n        if (newResource.isSpecialRow || newResource.readOnly) {\n            return false;\n        }\n\n        // Not allowed to assign an event twice to the same resource\n        if (resourceRecord !== newResource) {\n            return !sourceRecord.event.resources.includes(newResource);\n        }\n\n        return true;\n    }\n\n    checkDragValidity(dragData, event) {\n        const\n            me        = this,\n            scheduler = me.currentOverClient;\n\n        let result;\n\n        // Cannot assign anything to readOnly resources\n        if (dragData.newResource?.readOnly) {\n            return false;\n        }\n\n        // First make sure there's no overlap, if not run the external validatorFn\n        if (!scheduler.allowOverlap && !scheduler.isDateRangeAvailable(\n            dragData.startDate,\n            dragData.endDate,\n            dragData.draggedEntities[0],\n            dragData.newResource\n        )) {\n            result = {\n                valid   : false,\n                message : me.L('L{eventOverlapsExisting}')\n            };\n        }\n        else {\n            result = me.validatorFn.call(\n                me.validatorFnThisObj || me,\n                dragData,\n                event\n            );\n        }\n\n        if (!result || result.valid) {\n            // Hook for features to have a say on validity\n            result = scheduler['checkEventDragValidity']?.(dragData, event) ?? result;\n        }\n\n        return result;\n    }\n\n    //endregion\n\n    //region Update records\n\n    /**\n     * Update events being dragged.\n     * @private\n     * @param context Drag data.\n     */\n    async updateRecords(context) {\n        const\n            me                            = this,\n            fromScheduler                                          = me.client,\n            toScheduler                                            = me.currentOverClient,\n            copyKeyPressed                                         = me.mode === 'copy',\n            { draggedEntities, timeDiff, initialAssignmentsState } = context,\n            originalStartDate                                      = initialAssignmentsState[0].startDate,\n            droppedStartDate                                       = me.adjustStartDate(originalStartDate, timeDiff);\n\n        let result;\n\n        if (!context.externalDropTarget) {\n            // Dropping dragged event completely outside the time axis is not allowed\n            if (!toScheduler.timeAxis.timeSpanInAxis(droppedStartDate, DateHelper.add(droppedStartDate, draggedEntities[0].event.durationMS, 'ms'))) {\n                context.valid = false;\n            }\n\n            if (context.valid) {\n                fromScheduler.eventStore.suspendAutoCommit();\n                toScheduler.eventStore.suspendAutoCommit();\n\n                result = await me.updateAssignments(fromScheduler, toScheduler, context, copyKeyPressed);\n\n                fromScheduler.eventStore.resumeAutoCommit();\n                toScheduler.eventStore.resumeAutoCommit();\n            }\n        }\n\n        // Might be flagged invalid in updateAssignments() above, if drop did not lead to any change\n        // (for example if dropped on non-working-time in Pro)\n        if (context.valid) {\n            // Tell the world there was a successful drop\n            toScheduler.trigger('eventDrop', Object.assign(me.getTriggerParams(context), {\n                isCopy               : copyKeyPressed,\n                copyMode             : me.copyMode,\n                domEvent             : context.browserEvent,\n                targetEventRecord    : context.targetEventRecord,\n                targetResourceRecord : context.newResource,\n                externalDropTarget   : context.externalDropTarget\n            }));\n        }\n\n        return result;\n    }\n\n    /**\n     * Update assignments being dragged\n     * @private\n     */\n    async updateAssignments(fromScheduler, toScheduler, context, copy) {\n        // The code is written to emit as few store events as possible\n        const\n            me                  = this,\n            { copyMode }        = me,\n            isCrossScheduler    = (fromScheduler !== toScheduler),\n            { isVertical }      = toScheduler,\n            {\n                assignmentStore : fromAssignmentStore,\n                eventStore      : fromEventStore\n            }                   = fromScheduler,\n            {\n                assignmentStore : toAssignmentStore,\n                eventStore      : toEventStore\n            }                   = toScheduler,\n            // When using TreeGroup in horizontal mode, store != resourceStore. Does not apply for vertical mode.\n            fromResourceStore   = fromScheduler.isVertical ? fromScheduler.resourceStore : fromScheduler.store,\n            toResourceStore     = isVertical ? toScheduler.resourceStore : toScheduler.store,\n            {\n                eventRecords,\n                assignmentRecords,\n                timeDiff,\n                initialAssignmentsState,\n                resourceRecord : fromResource,\n                newResource    : toResource\n            }                   = context,\n            { unifiedDrag }     = me,\n            // For an empty target event store, check if it has usesSingleAssignment explicitly set, otherwise use\n            // the value from the source event store\n            useSingleAssignment = (toEventStore.usesSingleAssignment ||\n                (toEventStore.usesSingleAssignment !== false && fromEventStore.usesSingleAssignment)),\n            // this value has clear semantic only for same scheduler case\n            effectiveCopyMode   = copyMode === 'event'\n                ? 'event'\n                : copyMode === 'assignment'\n                    ? 'assignment'\n                    : useSingleAssignment ? 'event' : 'assignment',\n            event1Date          = me.adjustStartDate(assignmentRecords[0].event.startDate, timeDiff),\n            eventsToAdd         = [],\n            eventsToRemove      = [],\n            assignmentsToAdd    = [],\n            assignmentsToRemove = [],\n            eventsToCheck       = [],\n            eventsToBatch       = new Set(),\n            resourcesInStore    = fromResourceStore.getAllDataRecords();\n\n        fromScheduler.suspendRefresh();\n        toScheduler.suspendRefresh();\n\n        let updated      = false,\n            updatedEvent = false,\n            indexDiff; // By how many resource rows has the drag moved.\n\n        if (isCrossScheduler) {\n            // The difference in indices via first dragged event will help us find resources for all the rest of the\n            // events accordingly\n            indexDiff = toResourceStore.indexOf(toResource) - fromResourceStore.indexOf(fromResource);\n        }\n        else if (me.constainDragToResource) {\n            indexDiff = 0;\n        }\n        else if (isVertical && toResourceStore.isGrouped) {\n            indexDiff = resourcesInStore.indexOf(fromResource) - resourcesInStore.indexOf(toResource);\n        }\n        else {\n            indexDiff = fromResourceStore.indexOf(fromResource) - fromResourceStore.indexOf(toResource);\n        }\n\n        if (isVertical) {\n            // <remove-on-release>\n            // TODO: Broken after merge, figure it out\n            // </remove-on-release>\n            eventRecords.forEach((draggedEvent, i) => {\n                const eventBar = context.eventBarEls[i];\n\n                delete draggedEvent.instanceMeta(fromScheduler).hasTemporaryDragElement;\n\n                // If it was created by a call to scheduler.currentOrientation.addTemporaryDragElement\n                // then release it back to be available to DomSync next time the rendered event block\n                // is synced.\n                if (eventBar.dataset.transient) {\n                    eventBar.remove();\n                }\n            });\n        }\n\n        const\n            eventBarEls          = context.eventBarEls.slice(),\n            addedEvents          = [],\n            // this map holds references between original assignment and its copy\n            copiedAssignmentsMap = {};\n\n        // Using for to support await inside\n        for (let i = 0; i < assignmentRecords.length; i++) {\n            const originalAssignment = assignmentRecords[i];\n\n            // Reassigned when dropped on other scheduler, thus not const\n            let draggedEvent = originalAssignment.event,\n                draggedAssignment;\n\n            if (copy) {\n                draggedAssignment                           = originalAssignment.copy();\n                copiedAssignmentsMap[originalAssignment.id] = draggedAssignment;\n            }\n            else {\n                draggedAssignment = originalAssignment;\n            }\n\n            if (!draggedAssignment.isOccurrenceAssignment && (!fromAssignmentStore.includes(originalAssignment) || !fromEventStore.includes(draggedEvent))) {\n                // Event was removed externally during the drag, just remove element from DOM (DomSync already has\n                // tried to clean it up at this point, but could not due to retainElement being set)\n                eventBarEls[i].remove();\n                eventBarEls.splice(i, 1);\n                assignmentRecords.splice(i, 1);\n                i--;\n                continue;\n            }\n\n            const\n                initialState           = initialAssignmentsState[i],\n                originalEventRecord    = draggedEvent,\n                originalStartDate      = initialState.startDate,\n                // grabbing resource early, since after \".copy()\" the record won't belong to any store\n                // and \".getResources()\" won't work. If it's a move to another scheduler, ensure the\n                // array still has a length. The process function will do an assign as opposed\n                // to a reassignment\n                originalResourceRecord = initialState.resource,\n                // Calculate new startDate (and round it) based on timeDiff up here, might be added to another\n                // event store below in which case it is invalidated. But this is anyway the target date\n                newStartDate           = this.constrainDragToTimeSlot\n                    ? originalStartDate\n                    : (unifiedDrag\n                        ? event1Date\n                        : me.adjustStartDate(originalStartDate, timeDiff));\n\n            if (fromAssignmentStore !== toAssignmentStore) {\n                // Single assignment from a multi assigned event dragged over, event needs to be copied over\n                // Same if we hold the copy key\n                const keepEvent = originalEventRecord.assignments.length > 1 || copy;\n\n                let newAssignment;\n\n                if (copy) {\n                    // In a copy mode dragged assignment is already a copy\n                    newAssignment = draggedAssignment;\n                }\n                else {\n                    newAssignment                              = draggedAssignment.copy();\n                    copiedAssignmentsMap[draggedAssignment.id] = newAssignment;\n                }\n\n                // Pro Engine does not seem to handle having the event already in place on the copied assignment,\n                // replacing it with id to have events bucket properly set up on commit\n                if (newAssignment.event && !useSingleAssignment) {\n                    newAssignment.event    = newAssignment.event.id;\n                    newAssignment.resource = newAssignment.resource.id;\n                }\n\n                if (!copy) {\n                    // If we're not copying, remove assignment from source scheduler\n                    assignmentsToRemove.push(draggedAssignment);\n                }\n\n                // If it was the last assignment, the event should also be removed\n                if (!keepEvent) {\n                    eventsToRemove.push(originalEventRecord);\n                }\n\n                // If event does not already exist in target scheduler a copy is added\n                // if we're copying the event, we always need to create new record\n                if (\n                    copy && (copyMode === 'event' || (copyMode === 'auto' && toEventStore.usesSingleAssignment)) ||\n                    !toEventStore.getById(originalEventRecord.id)\n                ) {\n                    draggedEvent = toEventStore.createRecord({\n                        ...originalEventRecord.data,\n                        // If we're copying the event (not making new assignment to existing), we need to generate\n                        // phantom id to link event to the assignment record\n                        id       : copy && (copyMode === 'event' || copyMode === 'auto') ? undefined : originalEventRecord.id,\n                        // Engine gets mad if not nulled\n                        calendar : null\n                    });\n\n                    newAssignment.set({\n                        eventId : draggedEvent.id,\n                        event   : draggedEvent\n                    });\n\n                    eventsToAdd.push(draggedEvent);\n                }\n\n                // And add it to the target scheduler\n                // <remove-on-release>\n                // TODO: Should be handled on the data layer ideally\n                // </remove-on-release>\n                if (!useSingleAssignment) {\n                    assignmentsToAdd.push(newAssignment);\n                }\n                draggedAssignment = newAssignment;\n            }\n\n            let newResource    = toResource,\n                reassignedFrom = null;\n\n            if (!unifiedDrag) {\n                if (!isCrossScheduler) {\n                    // If not dragging events as a unified block, distribute each to a new resource\n                    // using the same offset as the dragged event.\n                    if (indexDiff !== 0) {\n                        let newIndex;\n                        if (isVertical && toResourceStore.isGrouped) {\n                            newIndex    = Math.max(\n                                Math.min(\n                                    resourcesInStore.indexOf(originalResourceRecord) - indexDiff,\n                                    resourcesInStore.length - 1\n                                ),\n                                0\n                            );\n                            newResource = resourcesInStore[newIndex];\n                        }\n                        else {\n                            newIndex = Math.max(\n                                Math.min(\n                                    fromResourceStore.indexOf(originalResourceRecord) - indexDiff,\n                                    fromResourceStore.count - 1\n                                ),\n                                0\n                            );\n\n                            newResource = fromResourceStore.getAt(newIndex);\n\n                            // Exclude group headers, footers, summary row etc\n                            if (newResource.isSpecialRow) {\n                                newResource = fromResourceStore.getNext(newResource, false, true) || fromResourceStore.getPrevious(newResource, false, true);\n                            }\n                        }\n\n                        newResource = newResource?.$original;\n                    }\n                    else {\n                        newResource = originalResourceRecord;\n                    }\n                }\n                // we have a resource for first dragged event in toResource\n                else if (i > 0) {\n                    const draggedEventResourceIndex = fromResourceStore.indexOf(originalResourceRecord);\n                    newResource                     = toResourceStore.getAt(draggedEventResourceIndex + indexDiff) || newResource;\n                }\n            }\n\n            const isCrossResource = draggedAssignment.resourceId !== newResource.id;\n\n            // Cannot rely on assignment generation to detect update, since it might be a new assignment\n            // <remove-on-release>\n            // TODO: what about a case when we drag between schedulers which have different resource with same ids?\n            // </remove-on-release>\n            if (isCrossResource) {\n                reassignedFrom = fromResourceStore.getById(draggedAssignment.resourceId);\n\n                if (copy && fromAssignmentStore === toAssignmentStore) {\n                    // Scheduler Core patch\n                    // need to completely clear the resource/resourceId on the copied assignment, before setting the new\n                    // otherwise, what happens is that in the `$beforeChange.resource/Id` are still\n                    // stored the resource/Id of the original assignment\n                    // then, when finalizing commit, Core engine performs this:\n                    //     // First silently revert any data change (used by buckets), otherwise it won't be detected by `set()`\n                    //     me.setData(me.$beforeChange)\n                    // and then updates the data to new, which is recorded as UpdateAction in the STM with old/new data\n                    // then, when that update action in STM is undo-ed, the old data is written back to the record\n                    // and newly added assignment is pointing to the old resource\n                    // then, when STM action is redo-ed, a \"duplicate assignment\" exception is thrown\n                    // this is covered with the test:\n                    // Scheduler/tests/features/EventDragCopy.t.js -> Should not remove the original when undo-ing the copy-drag action (\"multi-assignment\")\n                    draggedAssignment.setData({\n                        resource   : null,\n                        resourceId : null\n                    });\n                    // eof Scheduler Core patch\n\n                    draggedAssignment.resource = newResource;\n                    draggedAssignment.event    = toEventStore.getById(draggedAssignment.eventId);\n\n                    const shouldCopyEvent = copyMode === 'event' || (fromEventStore.usesSingleAssignment && copyMode === 'auto');\n\n                    if (shouldCopyEvent) {\n                        draggedEvent = draggedEvent.copy();\n                        // need to clear the `endDate` of the copy\n                        // this is because when we drag the copy to a different position on the timeline\n                        // it will set the new start date and re-calculate end date\n                        // as a result, in STM transaction for this drag-copy there will be \"add\" action\n                        // and \"update\" action and NO COMMIT in the middle\n                        // so when re-doing this transaction the duration change is lost\n                        // this is covered with the test:\n                        // \"Scheduler/tests/features/EventDragCopy.t.js -> Should not remove the original when undo-ing the copy-drag action (usesSingleAssignment)\",\n                        // Before doing it, save a copy of endDate in meta object, considering timeDiff: that's because below it will check if event is in timeAxis.\n                        draggedEvent.meta.endDateCached = me.adjustStartDate(draggedEvent.endDate, timeDiff);\n                        draggedEvent.endDate = null;\n\n                        draggedAssignment.event = draggedEvent;\n\n                        if (toEventStore.usesSingleAssignment) {\n                            draggedEvent.resource   = newResource;\n                            draggedEvent.resourceId = newResource.id;\n                        }\n                    }\n\n                    if (\n                        !toAssignmentStore.find(a => a.eventId === draggedAssignment.eventId && a.resourceId === draggedAssignment.resourceId) &&\n                        !assignmentsToAdd.find(r => r.eventId === draggedAssignment.eventId && r.resourceId === draggedAssignment.resourceId)\n                    ) {\n                        shouldCopyEvent && eventsToAdd.push(draggedEvent);\n                        assignmentsToAdd.push(draggedAssignment);\n                    }\n                }\n                else {\n                    draggedAssignment.resource = newResource;\n                }\n\n                // Actual events should be batched, not data for new events when dragging between\n                draggedEvent.isEvent && eventsToBatch.add(draggedEvent);\n                updated = true;\n\n                // When dragging an occurrence, the assignment is only temporary. We have to tag the newResource along\n                // to be picked up by the occurrence -> event conversion\n                // <remove-on-release>\n                // TODO: A hack, figure a better way out\n                // </remove-on-release>\n                if (draggedEvent.isOccurrence) {\n                    draggedEvent.set('newResource', newResource);\n                }\n\n                // <remove-on-release>\n                // TODO: Should be handled on the datalayer somehow, but it is kind of edge casey\n                // </remove-on-release>\n                if (isCrossScheduler && useSingleAssignment) {\n                    // In single assignment mode, when dragged to another scheduler it will not copy the assignment\n                    // over but instead set the resourceId of the event. To better match expected behaviour\n                    draggedEvent.resourceId = newResource.id;\n                }\n            }\n            else {\n                if (\n                    copy &&\n                    (copyMode === 'event' || (copyMode === 'auto' && fromEventStore.usesSingleAssignment)) &&\n                    !eventsToAdd.includes(draggedEvent)\n                ) {\n                    draggedEvent = draggedEvent.copy();\n                    // see the comment above\n                    draggedEvent.meta.endDateCached = me.adjustStartDate(draggedEvent.endDate, timeDiff);\n                    draggedEvent.endDate = null;\n\n                    eventsToAdd.push(draggedEvent);\n\n                    draggedAssignment.event = draggedEvent;\n\n                    if (toEventStore.usesSingleAssignment) {\n                        draggedEvent.set({\n                            resource   : newResource,\n                            resourceId : newResource.id\n                        });\n                    }\n\n                    // Always add assignment to the store to allow proper element reuse\n                    assignmentsToAdd.push(draggedAssignment);\n                }\n            }\n\n            // Same for event\n            if (!eventsToCheck.find(ev => ev.draggedEvent === draggedEvent) && !DateHelper.isEqual(draggedEvent.startDate, newStartDate)) {\n\n                // only do for non occurence records\n                while (!draggedEvent.isOccurrence && draggedEvent.isBatchUpdating) {\n                    draggedEvent.endBatch(true);\n                }\n\n                // for same scheduler with multi-assignments, and copyMode === assignment, need to keep the start date\n                // because user intention is to create a new assignment, not re-schedule the event\n                // but only for cross-resource dragging, same resource dragging has semantic of regular drag\n                // <remove-on-release>\n                // TODO should also keep the proxy element on the same X coordinate\n                // </remove-on-release>\n                const shouldKeepStartDate = copy && !isCrossScheduler && !useSingleAssignment && effectiveCopyMode === 'assignment' && isCrossResource;\n\n                if (!shouldKeepStartDate) {\n                    draggedEvent.startDate = newStartDate;\n\n                    eventsToCheck.push({ draggedEvent, originalStartDate });\n                }\n\n                draggedEvent.isEvent && eventsToBatch.add(draggedEvent);\n                updatedEvent = true;\n            }\n\n            // Hook for features that need to do additional processing on drop (used by NestedEvents)\n            toScheduler.processEventDrop({\n                eventRecord    : draggedEvent,\n                resourceRecord : newResource,\n                element        : i === 0 ? context.context.element : context.context.relatedElements[i - 1],\n                context,\n                toScheduler,\n                reassignedFrom,\n                eventsToAdd,\n                addedEvents,\n                draggedAssignment\n            });\n\n            // There are two cases to consider when triggering this event - `copy` and `move` mode. In case we are\n            // copying the assignment (we can also copy the event) draggedAssignment will point to the copy of the\n            // original assignment record. Same for draggedEvent. These records are new records which are not yet added\n            // to the store and they contain correct state of the drop - which event is going to be assigned to which\n            // resource on what time.\n            // These records possess no knowledge about original records which they were cloned from. And that might be\n            // useful. Let's say you want to copy assignment (or event) to every row in the way. You need to know start\n            // row and the end row. That information is kept in the `originalAssignment` record. Which might be identical\n            // to the `draggedAssignment` record in `move` mode.\n            toScheduler.trigger('processEventDrop', {\n                originalAssignment,\n                draggedAssignment,\n                context,\n                copyMode,\n                isCopy : copy\n            });\n        }\n\n        fromAssignmentStore.remove(assignmentsToRemove);\n        fromEventStore.remove(eventsToRemove);\n        toAssignmentStore.add(assignmentsToAdd);\n\n        // Modify syncIdMap on the FGCanvas to make sure elements get animated nicely to new position\n        if (copy && fromAssignmentStore === toAssignmentStore) {\n            const { syncIdMap } = fromScheduler.foregroundCanvas;\n\n            Object.entries(copiedAssignmentsMap).forEach(([originalId, cloneRecord]) => {\n                const element = syncIdMap[originalId];\n                delete syncIdMap[originalId];\n                syncIdMap[cloneRecord.id] = element;\n            });\n        }\n\n        eventsToAdd.length && addedEvents.push(...toEventStore.add(eventsToAdd));\n\n        // When not constrained to timeline we are dragging a clone and need to manually do some cleanup if\n        // dropped in view\n        if (!me.constrainDragToTimeline) {\n            // go through assignmentRecords again after events has been added to toEventStore (if any)\n            // now we have updated assignment ids and can properly reuse event HTML elements\n            for (let i = 0; i < assignmentRecords.length; i++) {\n                const\n                    assignmentRecord     = copiedAssignmentsMap[assignmentRecords[i].id] || assignmentRecords[i],\n                    originalDraggedEvent = assignmentRecord.event,\n                    // try to get dragged event from addedEvents array, it will be there with updated ids\n                    // if toScheduler is different\n                    draggedEvent         = addedEvents?.find(r => r.id === originalDraggedEvent.id) || originalDraggedEvent,\n                    eventBar             = context.eventBarEls[i],\n                    element              = i === 0 ? context.context.element : context.context.relatedElements[i - 1],\n                    // Determine if in time axis here also, since the records date might be invalidated further below\n                    inTimeAxis           = toScheduler.isInTimeAxis(draggedEvent);\n\n                // after checking if is in time axis, imeta.endDateCached can be deleted\n                delete draggedEvent.meta.endDateCached;\n\n                if (!copy) {\n                    // Remove original element properly\n                    DomSync.removeChild(eventBar.parentElement, eventBar);\n                }\n\n                if (draggedEvent.resource && (isVertical || toScheduler.rowManager.getRowFor(draggedEvent.resource)) && inTimeAxis) {\n                    // Nested events are added to correct parent by the feature\n                    if (!draggedEvent.parent || draggedEvent.parent.isRoot) {\n                        const elRect = Rectangle.from(element, toScheduler.foregroundCanvas, true);\n\n                        // Ensure that after inserting the dragged element clone into the toScheduler's foregroundCanvas\n                        // it's at the same visual position that it was dragged to.\n                        DomHelper.setTopLeft(element, elRect.y, elRect.x);\n\n                        // Add element properly, so that DomSync will reuse it on next update\n                        DomSync.addChild(toScheduler.foregroundCanvas, element, draggedEvent.assignments[0].id);\n\n                        isCrossScheduler && toScheduler.processCrossSchedulerEventDrop({\n                            eventRecord : draggedEvent,\n                            toScheduler\n                        });\n                    }\n\n                    element.classList.remove('b-sch-event-hover', 'b-active', 'b-drag-proxy', 'b-dragging');\n                    element.retainElement = false;\n                }\n            }\n        }\n\n        addedEvents?.forEach(added => eventsToBatch.add(added));\n\n        // addedEvents order is the same with [context.element, ..context.relatedElements]\n        // Any added or removed events or assignments => something changed\n        if (assignmentsToRemove.length || eventsToRemove.length || assignmentsToAdd.length || eventsToAdd.length) {\n            updated = true;\n        }\n\n        // Commit changes to affected projects\n        if (updated || updatedEvent) {\n            // By batching event changes when using single assignment we avoid two updates, without it there will be one\n            // for date change and one when changed assignment updates resourceId on the event\n            useSingleAssignment && eventsToBatch.forEach(eventRecord => eventRecord.beginBatch());\n\n            await Promise.all([\n                toScheduler.project !== fromScheduler.project ? toScheduler.project.commitAsync() : null,\n                fromScheduler.project.commitAsync()\n            ]);\n\n            // End batch in engine friendly way, avoiding to have `set()` trigger another round of calculations\n            useSingleAssignment && eventsToBatch.forEach(eventRecord => eventRecord.endBatch(false, true));\n        }\n\n        if (!updated) {\n            // Engine might have reverted the date change, in which case this should be considered an invalid op\n            updated = eventsToCheck.some(({ draggedEvent, originalStartDate }) =>\n                !DateHelper.isEqual(draggedEvent.startDate, originalStartDate)\n            );\n        }\n\n        // Resumes self twice if not cross scheduler, but was suspended twice above also so all good\n        toScheduler.resumeRefresh();\n        fromScheduler.resumeRefresh();\n\n        if (assignmentRecords.length > 0) {\n            if (!updated) {\n                context.valid = false;\n            }\n            else {\n                // Always force re-render of the bars, to return them to their original position when:\n                // * Fill ticks leading to small date adjustment not actually changing the DOM\n                //   (https://github.com/bryntum/support/issues/630)\n                // * Dragging straight down with multiselection, events in the last resource will still be assigned to\n                //   that resource = no change in the DOM (https://github.com/bryntum/support/issues/6293)\n                eventBarEls.forEach(el => delete el.lastDomConfig);\n\n                // Not doing full refresh above, to allow for animations\n                toScheduler.refreshWithTransition();\n\n                if (isCrossScheduler) {\n                    fromScheduler.refreshWithTransition();\n\n                    toScheduler.selectedEvents = addedEvents;\n                }\n            }\n        }\n    }\n\n    //endregion\n\n    //region Drag data\n\n    getProductDragContext(dragData) {\n        const\n            me                                = this,\n            { currentOverClient : scheduler } = me,\n            target                            = dragData.browserEvent.target,\n            previousResolvedResource          = dragData.newResource || dragData.resourceRecord,\n            previousTargetEventRecord         = dragData.targetEventRecord;\n\n        let\n            targetEventRecord = scheduler ? me.resolveEventRecord(target, scheduler) : null,\n            newResource, externalDropTarget;\n\n        // Ignore if over dragged event\n        if (dragData.eventRecords.includes(targetEventRecord)) {\n            targetEventRecord = null;\n        }\n\n        if (me.constrainDragToResource) {\n            newResource = dragData.resourceRecord;\n        }\n        else if (!me.constrainDragToTimeline) {\n            newResource = me.resolveResource();\n        }\n        else if (scheduler) {\n            newResource = me.resolveResource() || dragData.newResource || dragData.resourceRecord;\n        }\n\n        const\n            { assignmentRecords, eventRecords } = dragData,\n            isOverNewResource                   = previousResolvedResource !== newResource;\n\n        let valid = Boolean(newResource && !newResource.isSpecialRow);\n\n        if (!newResource && me.externalDropTargetSelector) {\n            externalDropTarget = target.closest(me.externalDropTargetSelector);\n            valid              = Boolean(externalDropTarget);\n        }\n\n        return {\n            valid,\n            externalDropTarget,\n            eventRecords,\n            assignmentRecords,\n            newResource,\n            targetEventRecord,\n            dirty         : isOverNewResource || targetEventRecord !== previousTargetEventRecord,\n            proxyElements : [dragData.context.element, ...dragData.context.relatedElements || []]\n        };\n    }\n\n    getMinimalDragData(info) {\n        const\n            me                = this,\n            { scheduler }     = me,\n            element           = me.getElementFromContext(info),\n            eventRecord       = me.resolveEventRecord(element, scheduler),\n            resourceRecord    = scheduler.resolveResourceRecord(element),\n            assignmentRecord  = scheduler.resolveAssignmentRecord(element),\n            assignmentRecords = assignmentRecord ? [assignmentRecord] : [];\n\n        // We multi drag other selected events if the dragged event is already selected, or the ctrl key is pressed\n        if (assignmentRecord && (scheduler.isAssignmentSelected(assignmentRecords[0]) || (me.drag.startEvent.ctrlKey && scheduler.multiEventSelect))) {\n            assignmentRecords.push.apply(assignmentRecords, me.getRelatedRecords(assignmentRecord));\n        }\n\n        const eventRecords = [...new Set(assignmentRecords.map(assignment => assignment.event))];\n\n        return {\n            eventRecord,\n            resourceRecord,\n            assignmentRecord,\n            eventRecords,\n            assignmentRecords\n        };\n    }\n\n    setupProductDragData(info) {\n        const\n            me            = this,\n            { scheduler } = me,\n            element       = me.getElementFromContext(info),\n            {\n                eventRecord,\n                resourceRecord,\n                assignmentRecord,\n                assignmentRecords\n            }             = me.getMinimalDragData(info),\n            eventBarEls   = [];\n\n        if (me.constrainDragToResource && !resourceRecord) {\n            throw new Error('Resource could not be resolved for event: ' + eventRecord.id);\n        }\n\n        let dateConstraints;\n\n        if (me.constrainDragToTimeline) {\n            dateConstraints = me.getDateConstraints?.(resourceRecord, eventRecord);\n\n            const\n                constrainRectangle = me.constrainRectangle = me.getConstrainingRectangle(dateConstraints, resourceRecord, eventRecord),\n                eventRegion        = Rectangle.from(element, scheduler.timeAxisSubGridElement);\n\n            super.setupConstraints(\n                constrainRectangle,\n                eventRegion,\n                scheduler.timeAxisViewModel.snapPixelAmount,\n                Boolean(dateConstraints.start)\n            );\n        }\n\n        // Collecting all elements to drag\n        assignmentRecords.forEach(assignment => {\n            let eventBarEl = scheduler.getElementFromAssignmentRecord(assignment, true);\n\n            if (!eventBarEl) {\n                eventBarEl = scheduler.currentOrientation.addTemporaryDragElement(assignment.event, assignment.resource);\n            }\n\n            eventBarEls.push(eventBarEl);\n        });\n\n        return {\n            record          : assignmentRecord,\n            draggedEntities : assignmentRecords,\n            dateConstraints : dateConstraints?.start ? dateConstraints : null,\n            // Create copies of the elements\n            eventBarCopies  : eventBarEls.map(el => me.createProxy(el)),\n            eventBarEls\n        };\n    }\n\n    getDateConstraints(resourceRecord, eventRecord) {\n        const\n            { scheduler }           = this,\n            externalDateConstraints = scheduler.getDateConstraints?.(resourceRecord, eventRecord);\n\n        let minDate, maxDate;\n\n        if (this.constrainDragToTimeSlot) {\n            minDate = eventRecord.startDate;\n            maxDate = eventRecord.endDate;\n        }\n        else if (externalDateConstraints) {\n            minDate = externalDateConstraints.start;\n            maxDate = externalDateConstraints.end;\n        }\n\n        return {\n            start : minDate,\n            end   : maxDate\n        };\n    }\n\n    getConstrainingRectangle(dateRange, resourceRecord, eventRecord) {\n        return this.scheduler.getScheduleRegion(this.constrainDragToResource && resourceRecord, eventRecord, true, dateRange && {\n            start : dateRange.start, end : dateRange.end\n        });\n    }\n\n    /**\n     * Initializes drag data (dates, constraints, dragged events etc). Called when drag starts.\n     * @private\n     * @param info\n     * @returns {*}\n     */\n    getDragData(info) {\n        const dragData = this.getMinimalDragData(info) || {};\n\n        return {\n            ...super.getDragData(info),\n            ...dragData,\n            initialAssignmentsState : dragData.assignmentRecords.map(assignment => ({\n                startDate : assignment.event.startDate,\n                resource  : assignment.resource,\n                assignment\n            }))\n        };\n    }\n\n    /**\n     * Provide your custom implementation of this to allow additional selected records to be dragged together with the original one.\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord The assignment about to be dragged\n     * @returns {Scheduler.model.AssignmentModel[]} An array of assignment records to drag together with the original\n     */\n    getRelatedRecords(assignmentRecord) {\n        return this.scheduler.selectedAssignments.filter(selectedRecord => selectedRecord !== assignmentRecord && !selectedRecord.resource.readOnly && selectedRecord.event.isDraggable);\n    }\n\n    /**\n     * Get correct axis coordinate depending on schedulers mode (horizontal -> x, vertical -> y). Also takes milestone\n     * layout into account.\n     * @private\n     * @param {Scheduler.model.EventModel} eventRecord Record being dragged\n     * @param {HTMLElement} element Element being dragged\n     * @param {Number[]} coord XY coordinates\n     * @returns {Number|Number[]} X,Y or XY\n     */\n    getCoordinate(eventRecord, element, coord) {\n        const scheduler = this.currentOverClient;\n\n        if (scheduler.isHorizontal) {\n            let x = coord[0];\n\n            // Adjust coordinate for milestones if using a layout mode, since they are aligned differently than events\n            if (scheduler.milestoneLayoutMode !== 'default' && eventRecord.isMilestone) {\n                switch (scheduler.milestoneAlign) {\n                    case 'center':\n                        x += element.offsetWidth / 2;\n                        break;\n                    case 'end':\n                        x += element.offsetWidth;\n                        break;\n                }\n            }\n\n            return x;\n        }\n        else {\n            let y = coord[1];\n            // Adjust coordinate for milestones if using a layout mode, since they are aligned differently than events\n            if (scheduler.milestoneLayoutMode !== 'default' && eventRecord.isMilestone) {\n                switch (scheduler.milestoneAlign) {\n                    case 'center':\n                        y += element.offsetHeight / 2;\n                        break;\n                    case 'end':\n                        y += element.offsetHeight;\n                        break;\n                }\n            }\n\n            return y;\n        }\n    }\n\n    /**\n     * Get resource record occluded by the drag proxy.\n     * @private\n     * @returns {Scheduler.model.ResourceModel}\n     */\n    resolveResource() {\n        const\n            me                 = this,\n            client             = me.currentOverClient,\n            { isHorizontal }   = client,\n            {\n                context,\n                browserEvent,\n                dragProxy\n            }                  = me.dragData,\n            element            = dragProxy || context.element,\n            // Page coords for elementFromPoint\n            pageRect           = Rectangle.from(element, null, true),\n            y                  = (client.isVertical || me.unifiedDrag) ? context.clientY : pageRect.center.y,\n            // Local coords to resolve resource in vertical\n            localRect          = Rectangle.from(element, client.timeAxisSubGridElement, true),\n            { x : lx, y : ly } = localRect.center,\n            eventTarget        = me.getMouseMoveEventTarget(browserEvent);\n\n        let resource = null;\n\n        if (client.element.contains(eventTarget)) {\n            // This is benchmarked as the fastest way to find a Grid Row from a viewport Y coordinate\n            // so use it in preference to elementFromPoint (which causes a forced synchronous layout) in horizontal mode.\n            if (isHorizontal) {\n                const row = client.rowManager.getRowAt(y);\n\n                resource = row && client.store.getAt(row.dataIndex);\n            }\n            else {\n                // In vertical mode, just use the X coordinate to find out which resource we are under.\n                // The method requires that a .b-sch-timeaxis-cell element be passed.\n                // There is only one in vertical mode, so use that.\n                resource = client.resolveResourceRecord(client.timeAxisSubGridElement.querySelector('.b-sch-timeaxis-cell'), [lx, ly]);\n            }\n        }\n\n        return resource;\n    }\n\n    //endregion\n\n    //region Other stuff\n\n    adjustStartDate(startDate, timeDiff) {\n        const\n            scheduler = this.currentOverClient;\n\n        startDate = scheduler.timeAxis.roundDate(new Date(startDate - 0 + timeDiff), scheduler.snapRelativeToEventStartDate ? startDate : false);\n\n        return this.constrainStartDate(startDate);\n    }\n\n    getRecordElement(assignmentRecord) {\n        return this.client.getElementFromAssignmentRecord(assignmentRecord, true);\n    }\n\n    // Used by the Dependencies feature to draw lines to the drag proxy instead of the original event element\n    getProxyElement(assignmentRecord) {\n        if (this.isDragging) {\n            const index = this.dragData.assignmentRecords.indexOf(assignmentRecord);\n\n            if (index >= 0) {\n                return this.dragData.proxyElements[index];\n            }\n        }\n\n        return null;\n    }\n\n    //endregion\n\n    //#region Salesforce hooks\n\n    getMouseMoveEventTarget(event) {\n        return event.target;\n    }\n\n    //#endregion\n}\n\nGridFeatureManager.registerFeature(EventDrag, true, 'Scheduler');\nGridFeatureManager.registerFeature(EventDrag, false, 'ResourceHistogram');\n", "import DragCreateBase from './base/DragCreateBase.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\n\n/**\n * @module Scheduler/feature/EventDragCreate\n */\n\n/**\n * Feature that allows the user to create new events by dragging in empty parts of the scheduler rows.\n *\n * {@inlineexample Scheduler/feature/EventDragCreate.js}\n *\n * This feature is **enabled** by default.\n *\n * <div class=\"note\">Incompatible with the {@link Scheduler.feature.EventDragSelect EventDragSelect} and\n * {@link Scheduler.feature.Pan Pan} features. If either of those features are enabled, this feature has no effect.\n * </div>\n *\n * ## Conditionally preventing drag creation\n *\n * To conditionally prevent drag creation for a certain resource or a certain timespan, you listen for the\n * {@link #event-beforeDragCreate} event, add your custom logic to it and return `false` to prevent the operation\n * from starting. For example to not allow drag creation on the topmost resource:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     listeners : {\n *         beforeDragCreate({ resource }) {\n *             // Prevent drag creating on the topmost resource\n *             if (resource === scheduler.resourceStore.first) {\n *                 return false;\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * @extends Scheduler/feature/base/DragCreateBase\n * @demo Scheduler/basic\n * @classtype eventDragCreate\n * @feature\n */\nexport default class EventDragCreate extends DragCreateBase {\n    //region Config\n\n    static $name = 'EventDragCreate';\n\n    static configurable = {\n        /**\n         * An empty function by default, but provided so that you can perform custom validation on the event being\n         * created. Return `true` if the new event is valid, `false` to prevent an event being created.\n         * @param {Object} context A drag create context\n         * @param {Date} context.startDate Event start date\n         * @param {Date} context.endDate Event end date\n         * @param {Scheduler.model.EventModel} context.record Event record\n         * @param {Scheduler.model.ResourceModel} context.resourceRecord Resource record\n         * @param {Event} event The event object\n         * @returns {Boolean} `true` if this validation passes\n         * @config {Function}\n         */\n        validatorFn : () => true,\n\n        /**\n         * Locks the layout during drag create, overriding the default behaviour that uses the same rendering\n         * pathway for drag creation as for already existing events.\n         *\n         * This more closely resembles the behaviour of versions prior to 4.2.0.\n         *\n         * @config {Boolean}\n         * @default\n         */\n        lockLayout : false\n    };\n\n    //endregion\n\n    //region Events\n\n    /**\n     * Fires on the owning Scheduler after the new event has been created.\n     * @event dragCreateEnd\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.EventModel} eventRecord The new `EventModel` record.\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource for the row in which the event is being\n     * created.\n     * @param {MouseEvent} event The ending mouseup event.\n     * @param {HTMLElement} eventElement The DOM element representing the newly created event un the UI.\n     */\n\n    /**\n     * Fires on the owning Scheduler at the beginning of the drag gesture. Returning `false` from a listener prevents\n     * the drag create operation from starting.\n     *\n     * ```javascript\n     * const scheduler = new Scheduler({\n     *     listeners : {\n     *         beforeDragCreate({ date }) {\n     *             // Prevent drag creating events in the past\n     *             return date >= Date.now();\n     *         }\n     *     }\n     * });\n     * ```\n     *\n     * @event beforeDragCreate\n     * @on-owner\n     * @preventable\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @param {Date} date The datetime associated with the drag start point.\n     */\n\n    /**\n     * Fires on the owning Scheduler after the drag start has created a new Event record.\n     * @event dragCreateStart\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.EventModel} eventRecord The event record being created\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {HTMLElement} eventElement The element representing the new event.\n     */\n\n    /**\n     * Fires on the owning Scheduler to allow implementer to prevent immediate finalization by setting\n     * `data.context.async = true` in the listener, to show a confirmation popup etc\n     * ```javascript\n     *  scheduler.on('beforedragcreatefinalize', ({context}) => {\n     *      context.async = true;\n     *      setTimeout(() => {\n     *          // async code don't forget to call finalize\n     *          context.finalize();\n     *      }, 1000);\n     *  })\n     * ```\n     * @event beforeDragCreateFinalize\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel} eventRecord The event record being created\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {HTMLElement} eventElement The element representing the new Event record\n     * @param {Object} context\n     * @param {Boolean} context.async Set true to handle drag create asynchronously (e.g. to wait for user\n     * confirmation)\n     * @param {Function} context.finalize Call this method to finalize drag create. This method accepts one\n     * argument: pass true to update records, or false, to ignore changes\n     */\n\n    /**\n     * Fires on the owning Scheduler at the end of the drag create gesture whether or not\n     * a new event was created by the gesture.\n     * @event afterDragCreate\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.EventModel} eventRecord The event record being created\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {HTMLElement} eventElement The element representing the created event record\n     */\n\n    //endregion\n\n    //region Init\n\n    get scheduler() {\n        return this.client;\n    }\n\n    get store() {\n        return this.client.eventStore;\n    }\n\n    get project() {\n        return this.client.project;\n    }\n\n    updateLockLayout(lock) {\n        this.dragActiveCls = `b-dragcreating${lock ? ' b-dragcreate-lock' : ''}`;\n    }\n\n    //endregion\n\n    //region Scheduler specific implementation\n\n    handleBeforeDragCreate(drag, eventRecord, event) {\n        const { resourceRecord } = drag;\n\n        if (resourceRecord.readOnly || !this.scheduler.resourceStore.isAvailable(resourceRecord)) {\n            return false;\n        }\n\n        const\n            { scheduler }      = this,\n            // For resources with a calendar, ensure the date is inside a working time range\n            isWorkingTime      = !scheduler.isSchedulerPro || eventRecord.ignoreResourceCalendar || resourceRecord.isWorkingTime(drag.mousedownDate),\n            result             = isWorkingTime && scheduler.trigger('beforeDragCreate', {\n                resourceRecord,\n                date : drag.mousedownDate,\n                event\n            });\n\n        // Save date constraints\n        this.dateConstraints = scheduler.getDateConstraints?.(resourceRecord, eventRecord);\n\n        return result;\n    }\n\n    dragStart(drag) {\n        const\n            me               = this,\n            { client }       = me,\n            {\n                eventStore,\n                assignmentStore,\n                enableEventAnimations,\n                enableTransactionalFeatures\n            }                  = client,\n            { resourceRecord } = drag,\n            eventRecord        = me.createEventRecord(drag),\n            resourceRecords    = [resourceRecord];\n\n        eventRecord.set('duration', DateHelper.diff(eventRecord.startDate, eventRecord.endDate, eventRecord.durationUnit, true));\n\n        // It's only a provisional event until gesture is completed (possibly longer if an editor dialog is shown after)\n        eventRecord.isCreating = true;\n\n        // Flag used by rendering to not draw a zero length event being drag created as a milestone\n        eventRecord.meta.isDragCreating = true;\n\n        // force the transaction canceling in the taskeditor early\n        // this is because we are going to add a new event record to the store, and it has to be out of the\n        // task editor's stm transaction\n        // now there's a re-entrant protection in that method, so hopefully when it will be called by the\n        // editor itself that's ok\n        // `taskEdit === false` in some cases, so can't just use `?.` here\n        client.features.taskEdit && client.features.taskEdit.doCancel();\n\n        // This presents the event to be scheduled for validation at the proposed mouse/date point\n        // If rejected, we cancel operation\n        if (me.handleBeforeDragCreate(drag, eventRecord, drag.event) === false) {\n            return false;\n        }\n\n        // This is an async function which will start transaction asynchronously. This workflow expect transaction to\n        // be started ASAP\n        me.captureStm(true);\n\n        let assignmentRecords = [];\n\n        if (resourceRecord) {\n            if (eventStore.usesSingleAssignment || !enableTransactionalFeatures) {\n                assignmentRecords = assignmentStore.assignEventToResource(eventRecord, resourceRecord);\n            }\n            else {\n                // <remove-on-release>\n                // TODO: Max and Nick should investigate why this is needed, better if assignment could be there when\n                //   event is added to the store, to avoid having it included in chained stores that check for\n                //   unassigned events\n                // </remove-on-release>\n                // Do not add record to the store just yet, otherwise records would get to the STM queue assignment first,\n                // then event, which will break `store.added` bag after undo/redo.\n                assignmentRecords = [assignmentStore.createRecord({\n                    event    : eventRecord,\n                    resource : resourceRecord\n                })];\n            }\n        }\n\n        // Vetoable beforeEventAdd allows cancel of this operation\n        if (client.trigger('beforeEventAdd', { eventRecord, resourceRecords, assignmentRecords }) === false) {\n            if (eventStore.usesSingleAssignment || !enableTransactionalFeatures) {\n                assignmentStore.remove(assignmentRecords);\n            }\n            return false;\n        }\n\n        // When configured to lock layout during drag create, set a flag that HorizontalRendering will pick up to\n        // exclude the new event from the layout calculations. It will then be at the topmost position in the \"cell\"\n        if (me.lockLayout) {\n            eventRecord.meta.excludeFromLayout = true;\n        }\n\n        client.onEventCreated?.(eventRecord);\n\n        client.enableEventAnimations = false;\n        eventStore.addAsync(eventRecord).then(() => client.enableEventAnimations = enableEventAnimations);\n\n        if (!eventStore.usesSingleAssignment && enableTransactionalFeatures) {\n            // Add assignment after event only to keep STM transaction sane\n            assignmentStore.add(assignmentRecords[0]);\n        }\n\n        // Element must be created synchronously, not after the project's normalizing delays.\n        // Overrides the check for isEngineReady in VerticalRendering so that the newly added record\n        // will be rendered when we call refreshRows.\n        client.isCreating = true;\n        client.refreshRows();\n        client.isCreating = false;\n\n        // Set the element we are dragging\n        drag.itemElement = drag.element = client.getElementFromEventRecord(eventRecord);\n\n        // If the resource row is very tall, the event may have been rendered outside of the\n        // visible viewport. If so, scroll it into view.\n        if (!DomHelper.isInView(drag.itemElement)) {\n            client.scrollable.scrollIntoView(drag.itemElement, {\n                animate    : true,\n                edgeOffset : client.barMargin\n            });\n        }\n\n        return super.dragStart(drag);\n    }\n\n    checkValidity(context, event) {\n        const\n            me         = this,\n            { client } = me;\n\n        // Nicer for users of validatorFn\n        context.resourceRecord = me.dragging.resourceRecord;\n        return (\n            client.allowOverlap ||\n            client.isDateRangeAvailable(context.startDate, context.endDate, context.eventRecord, context.resourceRecord)\n        ) && me.createValidatorFn.call(me.validatorFnThisObj || me, context, event);\n    }\n\n    // Determine if resource already has events or not\n    isRowEmpty(resourceRecord) {\n        const events = this.store.getEventsForResource(resourceRecord);\n        return !events || !events.length;\n    }\n\n    //endregion\n\n    triggerBeforeFinalize(event) {\n        this.client.trigger(`beforeDragCreateFinalize`, event);\n    }\n\n    /**\n     * Creates an event by the event object coordinates\n     * @param {Object} drag The Bryntum event object\n     * @private\n     */\n    createEventRecord(drag) {\n        const\n            me          = this,\n            { client }  = me,\n            dimension   = client.isHorizontal ? 'X' : 'Y',\n            {\n                timeAxis,\n                eventStore,\n                weekStartDay\n            }           = client,\n            {\n                event,\n                mousedownDate\n            }           = drag,\n            draggingEnd = me.draggingEnd = event[`page${dimension}`] > drag.startEvent[`page${dimension}`],\n            eventConfig = {\n                name      : eventStore.modelClass.fieldMap.name.defaultValue || me.L('L{Object.newEvent}'),\n                startDate : draggingEnd ? DateHelper.floor(mousedownDate, timeAxis.resolution, null, weekStartDay) : mousedownDate,\n                endDate   : draggingEnd ? mousedownDate : DateHelper.ceil(mousedownDate, timeAxis.resolution, null, weekStartDay)\n            };\n\n        // if project model has been imported from Gantt, we have to define constraint data directly to correct\n        // auto-scheduling while dragCreate\n        if (client.project.isGanttProjectMixin) {\n            ObjectHelper.assign(eventConfig, {\n                constraintDate : eventConfig.startDate,\n                constraintType : 'startnoearlierthan'\n            });\n        }\n\n        return eventStore.createRecord(eventConfig);\n    }\n\n    async internalUpdateRecord(context, eventRecord) {\n        await super.internalUpdateRecord(context, eventRecord);\n\n        // Toggle isCreating after ending batch, to make sure assignments can become persistable\n        if (!this.client.hasEventEditor) {\n            context.eventRecord.isCreating = false;\n        }\n    }\n\n    async finalizeDragCreate(context) {\n        const { meta } = context.eventRecord;\n\n        // Remove the layout lock flag, event will jump into place as part of the finalization\n        meta.excludeFromLayout = false;\n        // Also allow new event to become a milestone now\n        meta.isDragCreating    = false;\n\n        const transferred = await super.finalizeDragCreate(context);\n\n        // if STM capture has NOT been transferred to the\n        // event editor, we need to finalize the STM transaction / release the capture\n        if (!transferred) {\n            await this.freeStm(true);\n        }\n        else {\n            // otherwise just freeing our capture\n            this.hasStmCapture = false;\n        }\n\n        return transferred;\n    }\n\n    async cancelDragCreate(context) {\n        await super.cancelDragCreate(context);\n\n        await this.freeStm(false);\n    }\n\n    getTipHtml(...args) {\n        const\n            html        = super.getTipHtml(...args),\n            { element } = this.tip;\n\n        element.classList.add('b-sch-dragcreate-tooltip');\n        element.classList.toggle('b-too-narrow', this.dragging.context.tooNarrow);\n\n        return html;\n    }\n\n    onAborted(context) {\n        const { eventRecord, resourceRecord } = context;\n\n        // The product this is being used in may not have resources.\n        this.store.unassignEventFromResource?.(eventRecord, resourceRecord);\n        this.store.remove(eventRecord);\n    }\n}\n\nGridFeatureManager.registerFeature(EventDragCreate, true, 'Scheduler');\nGridFeatureManager.registerFeature(EventDragCreate, false, 'ResourceHistogram');\n", "import TooltipBase from './base/TooltipBase.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport { parseAlign } from '../../Core/helper/util/Rectangle.js';\n\n/**\n * @module Scheduler/feature/EventTooltip\n */\n\n// Alignment offsets to clear any dependency terminals depending on whether\n// the tooltip is aligned top/bottom (1) or left/right (2) as parsed from the\n// align string by Rectangle's parseAlign\nconst\n    zeroOffset = [0, 0],\n    depOffset  = [\n        null, [0, 10], [10, 0]\n    ];\n\n/**\n * Displays a tooltip when hovering events. The template used to render the tooltip can be customized, see {@link #config-template}.\n * Config options are also applied to the tooltip shown, see {@link Core.widget.Tooltip} for available options.\n *\n * ## Showing local data\n * To show a basic \"local\" tooltip (with data available in the Event record) upon hover:\n * ```javascript\n * new Scheduler({\n *   features : {\n *     eventTooltip : {\n *         // Tooltip configs can be used here\n *         align : 'l-r' // Align left to right,\n *         // A custom HTML template\n *         template : data => `<dl>\n *           <dt>Assigned to:</dt>\n *              <dt>Time:</dt>\n *              <dd>\n *                  ${DateHelper.format(data.eventRecord.startDate, 'LT')} - ${DateHelper.format(data.eventRecord.endDate, 'LT')}\n *              </dd>\n *              ${data.eventRecord.get('note') ? `<dt>Note:</dt><dd>${data.eventRecord.note}</dd>` : ''}\n *\n *              ${data.eventRecord.get('image') ? `<dt>Image:</dt><dd><img class=\"image\" src=\"${data.eventRecord.get('image')}\"/></dd>` : ''}\n *          </dl>`\n *     }\n *   }\n * });\n * ```\n *\n * ## Showing remotely loaded data\n * Loading remote data into the event tooltip is easy. Simply use the {@link #config-template} and return a Promise which yields the content to show.\n * ```javascript\n * new Scheduler({\n *   features : {\n *     eventTooltip : {\n *        template : ({ eventRecord }) => AjaxHelper.get(`./fakeServer?name=${eventRecord.name}`).then(response => response.text())\n *     }\n *   }\n * });\n * ```\n *\n * This feature is **enabled** by default\n *\n * By default, the tooltip {@link Core.widget.Widget#config-scrollAction realigns on scroll}\n * meaning that it will stay aligned with its target should a scroll interaction make the target move.\n *\n * If this is causing performance issues in a Scheduler, such as if there are many dozens of events\n * visible, you can configure this feature with `scrollAction: 'hide'`. This feature's configuration is\n * applied to the tooltip, so that will mean that the tooltip will hide if its target is moved by a\n * scroll interaction.\n *\n * @extends Scheduler/feature/base/TooltipBase\n * @demo Scheduler/basic\n * @inlineexample Scheduler/feature/EventTooltip.js\n * @classtype eventTooltip\n * @feature\n */\nexport default class EventTooltip extends TooltipBase {\n    //region Config\n\n    static get $name() {\n        return 'EventTooltip';\n    }\n\n    static get defaultConfig() {\n        return {\n            /**\n             * A function which receives data about the event and returns a string,\n             * or a Promise yielding a string (for async tooltips), to be displayed in the tooltip.\n             * This method will be called with an object containing the fields below\n             * @param {Object} data\n             * @param {Scheduler.model.EventModel} data.eventRecord\n             * @param {Date} data.startDate\n             * @param {Date} data.endDate\n             * @param {String} data.startText\n             * @param {String} data.endText\n             * @config {Function} template\n             */\n            template : data => `\n                ${data.eventRecord.name ? StringHelper.xss`<div class=\"b-sch-event-title\">${data.eventRecord.name}</div>` : ''}\n                ${data.startClockHtml}\n                ${data.endClockHtml}`,\n\n            cls : 'b-sch-event-tooltip',\n\n            monitorRecordUpdate : true,\n\n            /**\n             * Defines what to do if document is scrolled while the tooltip is visible.\n             *\n             * Valid values: ´null´: do nothing, ´hide´: hide the tooltip or ´realign´: realign to the target if possible.\n             *\n             * @config {'hide'|'realign'|null}\n             * @default\n             */\n            scrollAction : 'hide'\n        };\n    }\n\n    /**\n     * The event which the tooltip feature has been activated for.\n     * @member {Scheduler.model.EventModel} eventRecord\n     * @readonly\n     */\n\n    //endregion\n\n    construct(client, config) {\n        super.construct(client, config);\n\n        if (typeof this.align === 'string') {\n            this.align = { align : this.align };\n        }\n    }\n\n    onPaint({ firstPaint }) {\n        super.onPaint(...arguments);\n\n        if (firstPaint) {\n            const\n                { dependencies } = this.client.features;\n\n            if (dependencies) {\n                this.tooltip.ion({\n                    beforeAlign({ source : tooltip, offset = zeroOffset }) {\n                        const\n                            { edgeAligned }   = parseAlign(tooltip.align.align),\n                            depTerminalOffset = dependencies.disabled ? zeroOffset : depOffset[edgeAligned];\n\n                        // Add the spec's offset to the offset necessitated by dependency terminals\n                        arguments[0].offset = [\n                            offset[0] + depTerminalOffset[0],\n                            offset[1] + depTerminalOffset[1]\n                        ];\n                    }\n                });\n            }\n        }\n    }\n}\n\nGridFeatureManager.registerFeature(EventTooltip, true, 'Scheduler');\nGridFeatureManager.registerFeature(EventTooltip, false, 'ResourceHistogram');\n", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\n\n/**\n * @module Scheduler/feature/StickyEvents\n */\n\nconst zeroMargins = { width : 0, height : 0 };\n\n/**\n * This feature applies native `position: sticky` to event contents in horizontal mode, keeping the contents in view as\n * long as possible on scroll. For vertical mode it uses a programmatic solution to achieve the same result.\n *\n * Assign `eventRecord.stickyContents = false` to disable stickiness on a per event level (docs for\n * {@link Scheduler/model/EventModel#field-stickyContents}).\n *\n * This feature is **enabled** by default.\n *\n * ### Note\n * If a complex {@link Scheduler.view.Scheduler#config-eventRenderer} is used to create a DOM structure within the\n * `.b-sch-event-content` element, then application CSS will need to be written to cancel the stickiness on the\n * `.b-sch-event-content` element, and make some inner content element(s) sticky.\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype stickyEvents\n * @feature\n */\nexport default class StickyEvents extends InstancePlugin {\n    static $name = 'StickyEvents';\n\n    static type = 'stickyEvents';\n\n    static pluginConfig = {\n        chain : ['onEventDataGenerated']\n    };\n\n    construct(scheduler, config) {\n        super.construct(scheduler, config);\n\n        if (scheduler.isVertical) {\n            this.toUpdate = new Set();\n\n            scheduler.ion({\n                scroll           : 'onSchedulerScroll',\n                horizontalScroll : 'onHorizontalScroll',\n                thisObj          : this,\n                prio             : 10000\n            });\n        }\n    }\n\n    onEventDataGenerated(renderData) {\n        if (this.client.isHorizontal) {\n            renderData.wrapperCls['b-disable-sticky'] = renderData.eventRecord.stickyContents === false;\n        }\n        else {\n            this.syncEventContentPosition(renderData, undefined, true);\n            this.updateStyles();\n        }\n    }\n\n    //region Vertical mode\n\n    onSchedulerScroll() {\n        if (!this.disabled) {\n            this.verticalSyncAllEventsContentPosition(this.client);\n        }\n    }\n\n    // Have to sync also on horizontal scroll, since we reuse elements and dom configs\n    onHorizontalScroll({ subGrid }) {\n        if (subGrid === this.client.timeAxisSubGrid) {\n            this.verticalSyncAllEventsContentPosition(this.client);\n        }\n    }\n\n    updateStyles() {\n        for (const { contentEl, style } of this.toUpdate) {\n            DomHelper.applyStyle(contentEl, style);\n        }\n\n        this.toUpdate.clear();\n    }\n\n    verticalSyncAllEventsContentPosition(scheduler) {\n        const { resourceMap } = scheduler.currentOrientation;\n\n        for (const eventsData of resourceMap.values()) {\n            for (const { renderData, elementConfig } of Object.values(eventsData)) {\n                const args = [renderData];\n\n                if (elementConfig && renderData.eventRecord.isResourceTimeRange) {\n                    args.push(elementConfig.children[0]);\n                }\n\n                this.syncEventContentPosition.apply(this, args);\n            }\n        }\n        this.toUpdate.size && this.updateStyles();\n    }\n\n    syncEventContentPosition(renderData, eventContent = renderData.eventContent, duringGeneration = false) {\n        if (\n            this.disabled ||\n            // Allow client disable stickiness for certain events\n            renderData.eventRecord.stickyContents === false\n        ) {\n            return;\n        }\n\n        const\n            { client }        = this,\n            {\n                eventRecord,\n                resourceRecord,\n                useEventBuffer,\n                bufferAfterWidth,\n                bufferBeforeWidth,\n                top,\n                height\n            }                 = renderData,\n            scrollPosition    = client.scrollable.y,\n            wrapperEl         = duringGeneration ? null : client.getElementFromEventRecord(eventRecord, resourceRecord, true),\n            contentEl         = wrapperEl && DomSync.getChild(wrapperEl, 'event.content'),\n            meta              = eventRecord.instanceMeta(client),\n            style             = typeof eventContent.style === 'string'\n                ? (eventContent.style = DomHelper.parseStyle(eventContent.style))\n                : eventContent.style || (eventContent.style = {});\n\n        // Do not process events being dragged\n        if (wrapperEl?.classList.contains('b-dragging')) {\n            return;\n        }\n\n        let start       = top,\n            contentSize = height,\n            end         = start + contentSize;\n\n        if (useEventBuffer) {\n            start += bufferBeforeWidth;\n            contentSize = contentSize - bufferBeforeWidth - bufferAfterWidth;\n            end = start + contentSize;\n        }\n\n        // Only process non-milestones that are partially out of view\n        if (start < scrollPosition && end >= scrollPosition && !eventRecord.isMilestone) {\n            const\n                contentWidth = contentEl?.offsetWidth,\n                justify      = contentEl?.parentNode && DomHelper.getStyleValue(contentEl.parentNode, 'justifyContent'),\n                c            = justify === 'center' ? (renderData.width - contentWidth) / 2 : 0,\n                eventStart   = start,\n                eventEnd     = eventStart + contentSize - 1;\n\n            // Only process non-milestone events. Milestones have no width.\n            // If there's no offsetWidth, it's still b-released, so we cannot measure it.\n            // If the event starts off the left edge, but its right edge is still visible,\n            // translate the contentEl to compensate. If not, undo any translation.\n            if ((!contentEl || contentWidth) && eventStart < scrollPosition && eventEnd >= scrollPosition) {\n                const\n                    edgeSizes = this.getEventContentMargins(contentEl),\n                    maxOffset = contentEl\n                        ? (contentSize - contentEl.offsetHeight - edgeSizes.height) - c\n                        : Number.MAX_SAFE_INTEGER,\n                    offset = Math.min(scrollPosition - eventStart, maxOffset - 2);\n\n                style.transform = offset > 0 ? `translateY(${offset}px)` : '';\n                meta.stuck = true;\n            }\n            else {\n                style.transform = '';\n                meta.stuck = false;\n            }\n\n            if (contentEl) {\n                this.toUpdate.add({\n                    contentEl,\n                    style\n                });\n            }\n        }\n        else if (contentEl && meta.stuck) {\n            style.transform = '';\n            meta.stuck = false;\n\n            this.toUpdate.add({\n                contentEl,\n                style\n            });\n        }\n    }\n\n    // Only measure the margins of an event's contentEl once\n    getEventContentMargins(contentEl) {\n        if (contentEl?.classList.contains('b-sch-event-content')) {\n            return DomHelper.getEdgeSize(contentEl, 'margin');\n        }\n        return zeroMargins;\n    }\n\n    //endregion\n\n    doDisable() {\n        super.doDisable(...arguments);\n\n        if (!this.isConfiguring) {\n            this.client.refreshWithTransition();\n        }\n    }\n}\n\nGridFeatureManager.registerFeature(StickyEvents, true, 'Scheduler');\nGridFeatureManager.registerFeature(StickyEvents, false, 'ResourceHistogram');\n", "import AbstractTimeRanges from './AbstractTimeRanges.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport AttachToProjectMixin from '../data/mixin/AttachToProjectMixin.js';\nimport TimeSpan from '../model/TimeSpan.js';\n\n/**\n * @module Scheduler/feature/TimeRanges\n */\n\n/**\n * Feature that renders global ranges of time in the timeline. Use this feature to visualize a `range` like a 1 hr lunch\n * or some important point in time (a `line`, i.e. a range with 0 duration). This feature can also show a current time\n * indicator if you set {@link #config-showCurrentTimeLine} to true. To style the rendered elements, use the\n * {@link Scheduler.model.TimeSpan#field-cls cls} field of the `TimeSpan` class.\n *\n * {@inlineexample Scheduler/feature/TimeRanges.js}\n *\n * Each time range is represented by an instances of {@link Scheduler.model.TimeSpan}, held in a simple\n * {@link Core.data.Store}. The feature uses {@link Scheduler/model/ProjectModel#property-timeRangeStore} defined on the\n * project by default. The store's persisting/loading is handled by Crud Manager (if it's used by the component).\n *\n * Note that the feature uses virtualized rendering, only the currently visible ranges are available in the DOM.\n *\n * This feature is **off** by default. For info on enabling it, see {@link Grid.view.mixin.GridFeatures}.\n *\n * ## Showing an icon in the time range header\n *\n * You can use Font Awesome icons easily (or set any other icon using CSS) by using the {@link Scheduler.model.TimeSpan#field-iconCls}\n * field. The JSON data below will show a flag icon:\n *\n * ```json\n * {\n *     \"id\"        : 5,\n *     \"iconCls\"   : \"b-fa b-fa-flag\",\n *     \"name\"      : \"v5.0\",\n *     \"startDate\" : \"2019-02-07 15:45\"\n * },\n * ```\n *\n * ## Recurring time ranges\n *\n * The feature supports recurring ranges in case the provided store and models\n * have {@link Scheduler/data/mixin/RecurringTimeSpansMixin} and {@link Scheduler/model/mixin/RecurringTimeSpan}\n * mixins applied:\n *\n * ```javascript\n * // We want to use recurring time ranges so we make a special model extending standard TimeSpan model with\n * // RecurringTimeSpan which adds recurrence support\n * class MyTimeRange extends RecurringTimeSpan(TimeSpan) {}\n *\n * // Define a new store extending standard Store with RecurringTimeSpansMixin mixin to add recurrence support to the\n * // store. This store will contain time ranges.\n * class MyTimeRangeStore extends RecurringTimeSpansMixin(Store) {\n *     static get defaultConfig() {\n *         return {\n *             // use our new MyResourceTimeRange model\n *             modelClass : MyTimeRange\n *         };\n *     }\n * };\n *\n * // Instantiate store for timeRanges using our new classes\n * const timeRangeStore = new MyTimeRangeStore({\n *     data : [{\n *         id             : 1,\n *         resourceId     : 'r1',\n *         startDate      : '2019-01-01T11:00',\n *         endDate        : '2019-01-01T13:00',\n *         name           : 'Lunch',\n *         // this time range should repeat every day\n *         recurrenceRule : 'FREQ=DAILY'\n *     }]\n * });\n *\n * const scheduler = new Scheduler({\n *     ...\n *     features : {\n *         timeRanges : true\n *     },\n *\n *     crudManager : {\n *         // store for \"timeRanges\" feature\n *         timeRangeStore\n *     }\n * });\n * ```\n *\n * @extends Scheduler/feature/AbstractTimeRanges\n * @classtype timeRanges\n * @feature\n * @demo Scheduler/timeranges\n */\nexport default class TimeRanges extends AbstractTimeRanges.mixin(AttachToProjectMixin) {\n    //region Config\n\n    static get $name() {\n        return 'TimeRanges';\n    }\n\n    static get defaultConfig() {\n        return {\n            store : true\n        };\n    }\n\n    static configurable = {\n        /**\n         * Store that holds the time ranges (using the {@link Scheduler.model.TimeSpan} model or subclass thereof).\n         * A store will be automatically created if none is specified.\n         * @config {Core.data.Store|StoreConfig}\n         * @category Misc\n         */\n        store : {\n            modelClass : TimeSpan\n        },\n\n        /**\n         * The interval (as amount of ms) defining how frequently the current timeline will be updated\n         * @config {Number}\n         * @default\n         * @category Misc\n         */\n        currentTimeLineUpdateInterval : 10000,\n\n        /**\n         * The date format to show in the header for the current time line (when {@link #config-showCurrentTimeLine} is configured).\n         * See {@link Core.helper.DateHelper} for the possible formats to use.\n         * @config {String}\n         * @default\n         * @category Common\n         */\n        currentDateFormat : 'HH:mm',\n\n        /**\n         * Show a line indicating current time. Either `true` or `false` or a {@link Scheduler.model.TimeSpan}\n         * configuration object to apply to this special time range (allowing you to provide a custom text):\n         *\n         * ```javascript\n         * showCurrentTimeLine : {\n         *     name : 'Now'\n         * }\n         * ```\n         *\n         * The line carries the CSS class name `b-sch-current-time`, and this may be used to add custom styling to it.\n         *\n         * @prp {Boolean|TimeSpanConfig}\n         * @default\n         * @category Common\n         */\n        showCurrentTimeLine : false\n    };\n\n    //endregion\n\n    //region Init & destroy\n\n    doDestroy() {\n        this.storeDetacher?.();\n\n        super.doDestroy();\n    }\n\n    /**\n     * Returns the TimeRanges which occur within the client Scheduler's time axis.\n     * @property {Scheduler.model.TimeSpan[]}\n     */\n    get timeRanges() {\n        const me        = this;\n\n        if (!me._timeRanges) {\n            const { store } = me;\n\n            let { records } = store;\n\n            if (store.recurringEvents) {\n                const {\n                    startDate,\n                    endDate\n                } = me.client.timeAxis;\n\n                records = records.flatMap(timeSpan => {\n                    // Collect occurrences for the recurring events in the record set\n                    if (timeSpan.isRecurring) {\n                        return timeSpan.getOccurrencesForDateRange(startDate, endDate);\n                    }\n\n                    return timeSpan;\n                });\n            }\n\n            if (me.currentTimeLine) {\n                // Avoid polluting store records\n                if (!store.recurringEvents) {\n                    records = records.slice();\n                }\n\n                records.push(me.currentTimeLine);\n            }\n\n            me._timeRanges = records;\n        }\n\n        return me._timeRanges;\n    }\n    //endregion\n\n    //region Current time line\n\n    attachToProject(project) {\n        super.attachToProject(project);\n        const me = this;\n\n        me.projectTimeZoneChangeDetacher?.();\n\n        if (me.showCurrentTimeLine) {\n\n            // Update currentTimeLine immediately after a time zone change\n            me.projectTimeZoneChangeDetacher = me.client.project?.ion({ timeZoneChange : () => me.updateCurrentTimeLine() });\n\n            // Update currentTimeLine if its already created\n            if (me.currentTimeLine) {\n                me.updateCurrentTimeLine();\n            }\n        }\n    }\n\n    initCurrentTimeLine() {\n        const me = this;\n\n        if (me.currentTimeLine || !me.showCurrentTimeLine) {\n            return;\n        }\n\n        const data = typeof me.showCurrentTimeLine === 'object' ? me.showCurrentTimeLine : {};\n\n        me.currentTimeLine = me.store.modelClass.new({\n            id  : 'currentTime', // no-sanity\n            cls : 'b-sch-current-time'\n        }, data);\n\n        me.currentTimeInterval = me.setInterval(() => me.updateCurrentTimeLine(), me.currentTimeLineUpdateInterval);\n\n        me._timeRanges = null;\n\n        me.updateCurrentTimeLine();\n    }\n\n    updateCurrentTimeLine() {\n        const\n            me                  = this,\n            { currentTimeLine } = me;\n\n        currentTimeLine.timeZone = me.project?.timeZone;\n        currentTimeLine.setLocalDate('startDate', new Date());\n        currentTimeLine.endDate = currentTimeLine.startDate;\n\n        if (!currentTimeLine.originalData.name) {\n            currentTimeLine.name = DateHelper.format(currentTimeLine.startDate, me.currentDateFormat);\n        }\n\n        me.renderRanges();\n    }\n\n    hideCurrentTimeLine() {\n        const me = this;\n\n        if (!me.currentTimeLine) {\n            return;\n        }\n\n        me.clearInterval(me.currentTimeInterval);\n        me.currentTimeLine = null;\n\n        me.refresh();\n    }\n\n    updateShowCurrentTimeLine(show) {\n        if (show) {\n            this.initCurrentTimeLine();\n        }\n        else {\n            this.hideCurrentTimeLine();\n        }\n    }\n\n    //endregion\n\n    //region Menu items\n\n    /**\n     * Adds a menu item to show/hide current time line.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateTimeAxisHeaderMenu({ items }) {\n        items.currentTimeLine = {\n            weight   : 400,\n            text     : this.L('L{showCurrentTimeLine}'),\n            checked  : this.currentTimeLine,\n            onToggle : ({ checked }) => this.updateShowCurrentTimeLine(checked && this.showCurrentTimeLine)\n        };\n    }\n\n    //endregion\n\n    //region Store\n\n    attachToStore(store) {\n        const me = this;\n\n        let renderRanges = false;\n\n        // if we had some store assigned before we need to detach it\n        if (me.storeDetacher) {\n            me.storeDetacher();\n            // then we'll need to render ranges provided by the new store\n            renderRanges = true;\n        }\n\n        me.storeDetacher = store.ion({\n            change  : 'onStoreChange',\n            refresh : 'onStoreChange',\n            thisObj : me\n        });\n\n        me._timeRanges = null;\n\n        // render ranges if needed\n        renderRanges && me.renderRanges();\n    }\n\n    /**\n     * Returns the {@link Core.data.Store store} used by this feature\n     * @property {Core.data.Store}\n     * @category Misc\n     */\n    get store() {\n        return this.client.project.timeRangeStore;\n    }\n\n    updateStore(store) {\n        const\n            me          = this,\n            { client }  = me,\n            { project } = client;\n\n        store = project.timeRangeStore;\n\n        me.attachToStore(store);\n\n        // timeRanges can be set on scheduler/gantt, for convenience. Should only be processed by the TimeRanges and not\n        // any subclasses\n        if (client.timeRanges && !client._timeRangesExposed) {\n            store.add(client.timeRanges);\n            delete client.timeRanges;\n        }\n    }\n\n    // Called by ProjectConsumer after a new store is assigned at runtime\n    attachToTimeRangeStore(store) {\n        this.store = store;\n    }\n\n    resolveTimeRangeRecord(el) {\n        return this.store.getById(el.closest(this.baseSelector).dataset.id);\n    }\n\n    onStoreChange({ type, action }) {\n        const me = this;\n\n        // Force re-evaluating of which ranges to consider for render\n        me._timeRanges = null;\n\n        // https://github.com/bryntum/support/issues/1398 - checking also if scheduler is visible to change elements\n        if (me.disabled || !me.client.isVisible || me.isConfiguring || (type === 'refresh' && action !== 'batch')) {\n            return;\n        }\n\n        me.client.runWithTransition(() => me.renderRanges(), !me.client.refreshSuspended);\n    }\n\n    //endregion\n\n    //region Drag\n\n    onDragStart(event) {\n        const\n            me                = this,\n            { context }       = event,\n            record            = me.resolveTimeRangeRecord(context.element.closest(me.baseSelector)),\n            rangeBodyEl       = me.getBodyElementByRecord(record);\n\n        context.relatedElements = [rangeBodyEl];\n\n        Object.assign(context, {\n            record,\n            rangeBodyEl,\n            originRangeX : DomHelper.getTranslateX(rangeBodyEl),\n            originRangeY : DomHelper.getTranslateY(rangeBodyEl)\n        });\n\n        super.onDragStart(event);\n\n        me.showTip(context);\n    }\n\n    onDrop(event) {\n        const { context } = event;\n\n        if (!context.valid) {\n            return this.onInvalidDrop({ context });\n        }\n\n        const\n            me          = this,\n            { client }  = me,\n            { record }  = context,\n            box         = Rectangle.from(context.rangeBodyEl),\n            newStart    = client.getDateFromCoordinate(box.getStart(client.rtl, client.isHorizontal), 'round', false),\n            wasModified = (record.startDate - newStart !== 0);\n\n        if (wasModified) {\n            record.setStartDate(newStart);\n        }\n        else {\n            me.onInvalidDrop();\n        }\n\n        me.destroyTip();\n\n        super.onDrop(event);\n    }\n\n    //endregion\n\n    //region Resize\n\n    onResizeStart({ context }) {\n        const\n            me          = this,\n            record      = me.resolveTimeRangeRecord(context.element.closest(me.baseSelector)),\n            rangeBodyEl = me.getBodyElementByRecord(record);\n\n        Object.assign(context, {\n            record,\n            rangeBodyEl\n        });\n\n        me.showTip(context);\n    }\n\n    onResizeDrag({ context }) {\n        const\n            me              = this,\n            { rangeBodyEl } = context,\n            { client }      = me,\n            box             = Rectangle.from(context.element),\n            startPos        = box.getStart(client.rtl, client.isHorizontal),\n            endPos          = box.getEnd(client.rtl, client.isHorizontal),\n            startDate       = client.getDateFromCoordinate(startPos, 'round', false),\n            endDate         = client.getDateFromCoordinate(endPos, 'round', false);\n\n        if (me.client.isVertical) {\n            if (context.edge === 'top') {\n                DomHelper.setTranslateY(rangeBodyEl, context.newY);\n            }\n\n            rangeBodyEl.style.height = context.newHeight + 'px';\n        }\n        else {\n            if (context.edge === 'left') {\n                DomHelper.setTranslateX(rangeBodyEl, context.newX);\n            }\n\n            rangeBodyEl.style.width = context.newWidth + 'px';\n        }\n\n        me.updateDateIndicator({ startDate, endDate });\n    }\n\n    onResize({ context }) {\n        if (!context.valid) {\n            return this.onInvalidDrop({ context });\n        }\n\n        const\n            me          = this,\n            { client }  = me,\n            { rtl }     = client,\n            record      = context.record,\n            box         = Rectangle.from(context.element),\n            startPos    = box.getStart(rtl, client.isHorizontal),\n            endPos      = box.getEnd(rtl, client.isHorizontal),\n            newStart    = client.getDateFromCoordinate(startPos, 'round', false),\n            isStart     = (rtl && context.edge === 'right') || (!rtl && context.edge === 'left') || context.edge === 'top',\n            newEnd      = client.getDateFromCoordinate(endPos, 'round', false),\n            wasModified = (isStart && record.startDate - newStart !== 0) ||\n                (newEnd && record.endDate - newEnd !== 0);\n\n        if (wasModified && newEnd > newStart) {\n            if (isStart) {\n                // could be that the drag operation placed the range with start/end outside the axis\n                record.setStartDate(newStart, false);\n            }\n            else {\n                record.setEndDate(newEnd, false);\n            }\n        }\n        else {\n            me.onInvalidResize({ context });\n        }\n\n        me.destroyTip();\n    }\n\n    onInvalidResize({ context }) {\n        const me = this;\n\n        me.resize.reset();\n        // Allow DomSync to reapply original state\n        context.rangeBodyEl.parentElement.lastDomConfig = context.rangeBodyEl.lastDomConfig = null;\n        me.renderRanges();\n\n        me.destroyTip();\n    }\n\n    //endregion\n}\n\nGridFeatureManager.registerFeature(TimeRanges, false, ['Scheduler', 'Gantt']);\n", "import Base from '../../../Core/Base.js';\nimport ArrayHelper from '../../../Core/helper/ArrayHelper.js';\n\n/**\n * @module Scheduler/view/mixin/DelayedRecordsRendering\n */\n\n/**\n * Mixin that implements scheduling/unscheduling a delayed row refresh.\n * @mixin\n * @internal\n */\nexport default Target => class DelayedRecordsRendering extends (Target || Base) {\n\n    static $name = 'DelayedRecordsRendering';\n\n    static configurable = {\n        scheduledRecordsRefreshTimeout : 10\n    };\n\n    static get properties() {\n        return {\n            recordsToRefresh : new Set()\n        };\n    }\n\n    beforeRenderRow({ record }) {\n        // unscheduler records refresh when corresponding rows are rendered\n        if (this.recordIsReadyForRendering?.(record)) {\n            this.unscheduleRecordRefresh(record);\n        }\n\n        return super.beforeRenderRow(...arguments);\n    }\n\n    cleanupScheduledRecord() {\n        const { rowManager, store } = this;\n\n        for (const record of [...this.recordsToRefresh]) {\n            // Remove the record from to-refresh list if:\n            // - it's not in the view store\n            // - or it's not visible\n            if (!record.stores.includes(store) || !rowManager.getRowById(record)) {\n                this.recordsToRefresh.delete(record);\n            }\n        }\n    }\n\n    renderScheduledRecords() {\n        const me = this;\n\n        if (!me.refreshSuspended) {\n            // remove invisible records from the set of scheduled\n            me.cleanupScheduledRecord();\n\n            const\n                { rowManager } = me,\n                records        = [...me.recordsToRefresh],\n                rows           = records.map(record => rowManager.getRowById(record));\n\n            if (rows.length) {\n                rowManager.renderRows(rows);\n\n                /**\n                 * This event fires when records which rendering\n                 * was previously scheduled is finally done.\n                 * @event scheduledRecordsRender\n                 * @param {Grid.view.Grid} source The component.\n                 * @param {Core.data.Model[]} records Rendered records.\n                 * @param {Grid.row.Row[]} rows Rendered rows.\n                 */\n                me.trigger('scheduledRecordsRender', { records, rows });\n            }\n\n            if (me.recordsToRefresh.size) {\n                me.scheduleRecordRefresh();\n            }\n        }\n        // reschedule this call if view refresh is suspended\n        else {\n            me.scheduleRecordRefresh();\n        }\n    }\n\n    /**\n     * Cancels scheduled rows refresh.\n     * @param {Core.data.Model|Core.data.Model[]|Boolean} [clearRecords=true] `true` to also clear the list of records\n     * scheduled for refreshing. `false` will result only canceling the scheduled call and keeping intact\n     * the list of records planned for refreshing.\n     */\n    unscheduleRecordRefresh(clearRecords = true) {\n        const me = this;\n\n        if (clearRecords === true) {\n            me.recordsToRefresh.clear();\n        }\n        else if (clearRecords) {\n            ArrayHelper.asArray(clearRecords).forEach(record => me.recordsToRefresh.delete(record));\n        }\n\n        if (me.scheduledRecordsRefreshTimer && !me.recordsToRefresh.size) {\n            me.clearTimeout(me.scheduledRecordsRefreshTimer);\n        }\n    }\n\n    /**\n     * Schedules the provided record row refresh.\n     * @param {Core.data.Model} records Record to refresh the row of.\n     */\n    scheduleRecordRefresh(records) {\n        const me = this;\n\n        if (records) {\n            ArrayHelper.asArray(records).forEach(record => me.recordsToRefresh.add(record));\n        }\n\n        me.scheduledRecordsRefreshTimer = me.setTimeout({\n            fn                : 'renderScheduledRecords',\n            delay             : me.scheduledRecordsRefreshTimeout,\n            cancelOutstanding : true\n        });\n    }\n\n    get widgetClass() {}\n\n};\n", "import Base from '../../Core/Base.js';\n\nexport default class TimelineHistogramRendering extends Base {\n\n    static configurable = {\n        scrollBuffer : 0\n    };\n\n    construct(client) {\n        super.construct();\n        this.client = client;\n    }\n\n    init() {}\n\n    onTimeAxisViewModelUpdate() {\n        const { scrollable } = this.client.timeAxisSubGrid;\n\n        // scrollLeft is the DOM's concept which is -ve in RTL mode.\n        // scrollX i always the +ve scroll offset from the origin.\n        // Both may be needed for different calculations.\n        this.updateFromHorizontalScroll(scrollable.x);\n    }\n\n    // Update header range on horizontal scroll\n    updateFromHorizontalScroll(scrollX) {\n        const\n            me            = this,\n            {\n                client,\n                // scrollBuffer is an export only thing\n                scrollBuffer\n            } = me,\n            {\n                timeAxisSubGrid,\n                timeAxis,\n                rtl\n            }             = client,\n            { width }     = timeAxisSubGrid,\n            { totalSize } = client.timeAxisViewModel,\n            start         = scrollX,\n            // If there are few pixels left from the right most position then just render all remaining ticks,\n            // there wouldn't be many. It makes end date reachable with more page zoom levels while not having any poor\n            // implications.\n            // 5px to make TimeViewRangePageZoom test stable in puppeteer.\n            returnEnd     = timeAxisSubGrid.scrollable.maxX !== 0 && Math.abs(timeAxisSubGrid.scrollable.maxX) <= Math.round(start) + 5,\n            startDate     = client.getDateFromCoord({ coord : Math.max(0, start - scrollBuffer), ignoreRTL : true }),\n            endDate       = returnEnd ? timeAxis.endDate : (client.getDateFromCoord({ coord : start + width + scrollBuffer, ignoreRTL : true }) || timeAxis.endDate);\n\n        if (startDate && !client._viewPresetChanging) {\n            me._visibleDateRange = { startDate, endDate, startMS : startDate.getTime(), endMS : endDate.getTime() };\n            me.viewportCoords  = rtl\n                // RTL starts all the way to the right (and goes in opposite direction)\n                ? { left : totalSize - scrollX - width + scrollBuffer, right : totalSize - scrollX - scrollBuffer }\n                // LTR all the way to the left\n                : { left : scrollX - scrollBuffer, right : scrollX + width + scrollBuffer };\n\n            // Update timeaxis header making it display the new dates\n            const range = client.timeView.range = { startDate, endDate };\n\n            client.onVisibleDateRangeChange(range);\n\n            // If refresh is suspended, someone else is responsible for updating the UI later\n            if (!client.refreshSuspended && client.rowManager.rows.length) {\n                // Gets here too early in Safari for ResourceHistogram. ResizeObserver triggers a scroll before rows are\n                // rendered first time. Could not track down why, bailing out\n                if (client.rowManager.rows[0].id === null) {\n                    return;\n                }\n\n                // re-render all rows is timeAxis range has been updated\n                if (me._timeAxisStartDate - timeAxis.startDate || me._timeAxisEndDate - timeAxis.endDate) {\n                    me._timeAxisStartDate = timeAxis.startDate;\n                    me._timeAxisEndDate = timeAxis.endDate;\n\n                    client.rowManager.renderRows(client.rowManager.rows);\n                }\n            }\n        }\n    }\n\n    onViewportResize() {}\n\n    refreshRows() {}\n\n    get visibleDateRange() {\n        return this._visibleDateRange;\n    }\n\n    translateToPageCoordinate(x) {\n        const\n            { client } = this,\n            { scrollable } = client.timeAxisSubGrid;\n\n        let result = x + client.timeAxisSubGridElement.getBoundingClientRect().left;\n\n        if (client.rtl) {\n            result -= scrollable.maxX - Math.abs(client.scrollLeft);\n        }\n        else {\n            result -= client.scrollLeft;\n        }\n\n        return result;\n    }\n\n    translateToScheduleCoordinate(x) {\n        const\n            { client } = this,\n            { scrollable } = client.timeAxisSubGrid;\n\n        let result = x - client.timeAxisSubGridElement.getBoundingClientRect().left - globalThis.scrollX;\n\n        // Because we use getBoundingClientRect's left, we have to adjust for page scroll.\n\n        if (client.rtl) {\n            result += scrollable.maxX - Math.abs(client.scrollLeft);\n        }\n        else {\n            result += client.scrollLeft;\n        }\n\n        return result;\n    }\n\n    getDateFromXY(xy, roundingMethod, local, allowOutOfRange = false) {\n        const { client } = this;\n\n        let coord = xy[0];\n\n        if (!local) {\n            coord = this.translateToScheduleCoordinate(coord);\n        }\n\n        coord = client.getRtlX(coord);\n\n        return client.timeAxisViewModel.getDateFromPosition(coord, roundingMethod, allowOutOfRange);\n    }\n\n}\n", "import Objects from '../../Core/helper/util/Objects.js';\nimport Histogram from '../../Core/widget/graph/Histogram.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\nimport '../../Grid/column/TreeColumn.js';\nimport '../../Grid/feature/Tree.js';\nimport '../column/TimeAxisColumn.js';\nimport '../feature/ColumnLines.js';\nimport DelayedRecordsRendering from './mixin/DelayedRecordsRendering.js';\nimport TimelineBase from './TimelineBase.js';\nimport TimelineHistogramRendering from './TimelineHistogramRendering.js';\n\n/**\n * @module Scheduler/view/TimelineHistogramBase\n */\n\nconst\n    histogramWidgetCleanState = {\n        series   : null,\n        topValue : null\n    },\n    emptyFn = () => {};\n\n/**\n * Histogram renderer parameters.\n *\n * @typedef {Object} HistogramRenderData\n * @property {Object} histogramData Histogram data\n * @property {HistogramConfig} histogramConfig Configuration object for the histogram widget\n * @property {HTMLElement|null} cellElement Cell element, for adding CSS classes, styling etc.\n *        Can be `null` in case of export\n * @property {Core.data.Model} record Record for the row\n * @property {Grid.column.Column} column This column\n * @property {Grid.view.Grid} grid This grid\n * @property {Grid.row.Row} row Row object. Can be null in case of export. Use the\n * {@link Grid.row.Row#function-assignCls row's API} to manipulate CSS class names.\n */\n\n/**\n * Base class for {@link Scheduler/view/TimelineHistogram} class.\n *\n * @extends Scheduler/view/TimelineBase\n * @abstract\n */\nexport default class TimelineHistogramBase extends TimelineBase.mixin(DelayedRecordsRendering) {\n\n    //region Config\n\n    static $name = 'TimelineHistogramBase';\n\n    static type = 'timelinehistogrambase';\n\n    static configurable = {\n\n        timeAxisColumnCellCls : 'b-sch-timeaxis-cell b-timelinehistogram-cell',\n\n        mode : 'horizontal',\n\n        rowHeight : 50,\n\n        /**\n         * Set to `true` if you want to display a tooltip when hovering an allocation bar. You can also pass a\n         * {@link Core/widget/Tooltip#configs} config object.\n         * Please use {@link #config-barTooltipTemplate} function to customize the tooltip contents.\n         * @config {Boolean|TooltipConfig}\n         */\n        showBarTip : false,\n\n        barTooltip : null,\n\n        barTooltipClass : Tooltip,\n\n        /**\n         * Object enumerating data series for the histogram.\n         * The object keys are treated as the series identifiers and values are objects that\n         * must contain two properties:\n         *  - `type` A String, either `'bar'` or `'outline'`\n         *  - `field` A String, the name of the property to use from the data objects in the {@link #config-data} option.\n         *\n         * ```javascript\n         * histogram = new TimelineHistogram({\n         *     ...\n         *     series : {\n         *         s1 : {\n         *             type  : 'bar',\n         *             field : 's1'\n         *         },\n         *         s2 : {\n         *             type  : 'outline',\n         *             field : 's2'\n         *         }\n         *     },\n         *     store : new Store({\n         *         data : [\n         *             {\n         *                 id            : 'r1',\n         *                 name          : 'Record 1',\n         *                 histogramData : [\n         *                     { s1 : 200, s2 : 100 },\n         *                     { s1 : 150, s2 : 50 },\n         *                     { s1 : 175, s2 : 50 },\n         *                     { s1 : 175, s2 : 75 }\n         *                 ]\n         *             },\n         *             {\n         *                 id            : 'r2',\n         *                 name          : 'Record 2',\n         *                 histogramData : [\n         *                     { s1 : 100, s2 : 100 },\n         *                     { s1 : 150, s2 : 125 },\n         *                     { s1 : 175, s2 : 150 },\n         *                     { s1 : 175, s2 : 75 }\n         *                 ]\n         *             }\n         *         ]\n         *     })\n         * });\n         * ```\n         *\n         * @config {Object<String, HistogramSeries>}\n         */\n        series : null,\n\n        /**\n         * Record field from which the histogram data will be collected.\n         *\n         * ```javascript\n         * histogram = new TimelineHistogram({\n         *     ...\n         *     series : {\n         *         s1 : {\n         *             type : 'bar'\n         *         }\n         *     },\n         *     dataModelField : 'foo',\n         *     store : new Store({\n         *         data : [\n         *             {\n         *                 id   : 'r1',\n         *                 name : 'Record 1',\n         *                 foo  : [\n         *                     { s1 : 200 },\n         *                     { s1 : 150 },\n         *                     { s1 : 175 },\n         *                     { s1 : 175 }\n         *                 ]\n         *             },\n         *             {\n         *                 id   : 'r2',\n         *                 name : 'Record 2',\n         *                 foo  : [\n         *                     { s1 : 100 },\n         *                     { s1 : 150 },\n         *                     { s1 : 175 },\n         *                     { s1 : 175 }\n         *                 ]\n         *             }\n         *         ]\n         *     })\n         * });\n         * ```\n         *\n         * Alternatively {@link #config-getRecordData} function can be used to build a\n         * record's histogram data dynamically.\n         * @config {String}\n         * @default\n         */\n        dataModelField : 'histogramData',\n\n        /**\n         * A function, or name of a function which builds histogram data for the provided record.\n         *\n         * See also {@link #config-dataModelField} allowing to load histogram data from a record field.\n         *\n         * @config {Function|String} getRecordData\n         * @param {Core.data.Model} getRecordData.record Record to get histogram data for.\n         * @param {Object} [aggregationContext] Context object passed in case the data is being retrieved\n         * as a part of some parent record data collecting.\n         * @returns {Object} Histogram data.\n         */\n        getRecordData : null,\n\n        /**\n         * When set to `true` (default) the component reacts on time axis changes\n         * (zooming or changing the displayed time span), clears the histogram data cache of the records\n         * and then refreshes the view.\n         * @config {Boolean}\n         * @default\n         */\n        hardRefreshOnTimeAxisReconfigure : true,\n\n        /**\n         * A Function which returns a CSS class name to add to a rectangle element.\n         * The following parameters are passed:\n         * @param {HistogramSeries} series The series being rendered\n         * @param {DomConfig} rectConfig The rectangle configuration object\n         * @param {Object} datum The datum being rendered\n         * @param {Number} index The index of the datum being rendered\n         * @param {HistogramRenderData} renderData Current render data giving access to the record, row and cell\n         * being rendered.\n         * @returns {String} CSS classes of the rectangle element\n         * @config {Function}\n         */\n        getRectClass : null,\n\n        /**\n         * A Function which returns a CSS class name to add to a path element\n         * built for an `outline` type series.\n         * The following parameters are passed:\n         * @param {HistogramSeries} series The series being rendered\n         * @param {Object[]} data The series data\n         * @param {HistogramRenderData} renderData Current render data giving access to the record, row and cell\n         * being rendered.\n         * @returns {String} CSS class name of the path element\n         * @config {Function}\n         */\n        getOutlineClass(series) {\n            return '';\n        },\n\n        readOnly : true,\n\n        // <remove-on-release>\n        // TODO: get rid of getBarTip in 6.0\n        // </remove-on-release>\n        /**\n         * A Function which returns the tooltip text to display when hovering a bar.\n         * The following parameters are passed:\n         * @param {HistogramSeries} series The series being rendered\n         * @param {DomConfig} rectConfig The rectangle configuration object\n         * @param {Object} datum The datum being rendered\n         * @param {Number} index The index of the datum being rendered\n         * @deprecated Since 5.0.0. Please use {@link #config-barTooltipTemplate}\n         * @config {Function}\n         */\n        getBarTip : null,\n\n        /**\n         * A Function which returns the tooltip text to display when hovering a bar.\n         * The following parameters are passed:\n         * @param {Object} context The tooltip context info\n         * @param {Object} context.datum The histogram bar being hovered info\n         * @param {Core.widget.Tooltip} context.tip The tooltip instance\n         * @param {HTMLElement} context.element The Element for which the Tooltip is monitoring mouse movement\n         * @param {HTMLElement} context.activeTarget The target element that triggered the show\n         * @param {Event} context.event The raw DOM event\n         * @param {Core.data.Model} data.record The record which value\n         * the hovered bar displays.\n         * @returns {String} Tooltip HTML content\n         * @config {Function}\n         */\n        barTooltipTemplate : null,\n\n        /**\n         * A Function which returns the text to render inside a bar.\n         *\n         * ```javascript\n         * new TimelineHistogram({\n         *     series : {\n         *         foo : {\n         *             type  : 'bar',\n         *             field : 'foo'\n         *         }\n         *     },\n         *     getBarText(datum) {\n         *         // display the value in the bar\n         *         return datum.foo;\n         *     },\n         *     ...\n         * })\n         * ```\n         *\n         * **Please note** that the function will be injected into the underlying\n         * {@link Core/widget/graph/Histogram} component that is used under the hood\n         * to render actual charts.\n         * So `this` will refer to the {@link Core/widget/graph/Histogram} instance, not\n         * this class instance.\n         * To access the view please use `this.owner` in the function:\n         *\n         * ```javascript\n         * new TimelineHistogram({\n         *     getBarText(datum) {\n         *         // \"this\" in the method refers core Histogram instance\n         *         // get the view instance\n         *         const timelineHistogram = this.owner;\n         *\n         *         .....\n         *     },\n         *     ...\n         * })\n         * ```\n         * The following parameters are passed:\n         * @param {Object} datum The datum being rendered\n         * @param {Number} index The index of the datum being rendered\n         * @param {HistogramSeries} series The series (provided if histogram widget\n         * {@link Core/widget/graph/Histogram#config-singleTextForAllBars} is `false`)\n         * @param {HistogramRenderData} renderData Current render data giving access to the record, row and cell\n         * being rendered.\n         * @returns {String} Text to render inside the bar\n         * @config {Function}\n         */\n        getBarText : null,\n\n        getRectConfig : null,\n\n        getBarTextRenderData : undefined,\n\n        /**\n         * The class used for building the {@link #property-histogramWidget histogram widget}\n         * @config {Core.widget.graph.Histogram}\n         * @default\n         */\n        histogramWidgetClass : Histogram,\n\n        /**\n         * The underlying {@link Core/widget/graph/Histogram} component that is used under the hood\n         * to render actual charts.\n         * @member {Core.widget.graph.Histogram} histogramWidget\n         */\n        /**\n         * An instance or a configuration object of the underlying {@link Core/widget/graph/Histogram}\n         * component that is used under the hood to render actual charts.\n         * In case a configuration object is provided the built class is defined with\n         * {@link #config-histogramWidgetClass} config.\n         * @config {Core.widget.graph.Histogram|HistogramConfig}\n         */\n        histogramWidget : {\n            cls                : 'b-hide-offscreen b-timelinehistogram-histogram',\n            omitZeroHeightBars : true,\n            data               : []\n        },\n\n        fixedRowHeight : true\n    };\n\n    static get properties() {\n        return {\n            histogramDataByRecord : new Map(),\n            collectingDataFor     : new Map()\n        };\n    }\n\n    updateGetRecordData(fn) {\n        this._getRecordData = fn ? this.resolveCallback(fn) : null;\n    }\n\n    updateHardRefreshOnTimeAxisReconfigure(value) {\n        const name = 'hardRefreshOnTimeAxisReconfigure';\n\n        if (value) {\n            this.timeAxis.ion({\n                name,\n                endReconfigure : 'onTimeAxisEndReconfigure',\n                thisObj        : this\n            });\n        }\n        else {\n            this.detachListeners(name);\n        }\n    }\n\n    //endregion\n\n    //region Constructor/Destructor\n\n    construct(config) {\n        super.construct(config);\n\n        const me = this;\n\n        // debounce refreshRows calls\n        me.scheduleRefreshRows = me.createOnFrame(me.refreshRows, [], me, true);\n\n        me.rowManager.ion({\n            beforeRowHeight : 'onBeforeRowHeight',\n            thisObj         : me\n        });\n    }\n\n    onDestroy() {\n        this.clearHistogramDataCache();\n        this._histogramWidget?.destroy();\n        this.barTooltip = null;\n    }\n\n    //endregion\n\n    //region Internal\n\n    // Used by shared features to resolve an event or task\n    resolveTimeSpanRecord(element) {}\n\n    getScheduleMouseEventParams(cellData, event) {\n        const record = this.store.getById(cellData.id);\n\n        return { record };\n    }\n\n    get currentOrientation() {\n        if (!this._currentOrientation) {\n            this._currentOrientation = new TimelineHistogramRendering(this);\n        }\n\n        return this._currentOrientation;\n    }\n\n    updateSeries(value) {\n        const me = this;\n\n        me.histogramWidget.series = value;\n\n        me._series = me.histogramWidget.series;\n\n        if (me.isPainted && !me.isConfiguring) {\n            me.scheduleRefreshRows();\n        }\n    }\n\n    getAsyncEventSuffixForStore(store) {\n        // Use xxPreCommit version of events if the store is a part of a project\n        return store.isAbstractPartOfProjectStoreMixin ? 'PreCommit' : '';\n    }\n\n    /**\n     * Schedules the component rows refresh on the next animation frame. However many time it is\n     * called in one event run, it will only be scheduled to run once.\n     */\n    scheduleRefreshRows() {}\n\n    getRowHeight() {\n        return this.rowHeight;\n    }\n\n    onPaint({ firstPaint }) {\n        super.onPaint({ firstPaint });\n\n        if (firstPaint && this.showBarTip) {\n            this.barTooltip = {};\n        }\n    }\n\n    updateGetBarTip(value) {\n        // reset barTooltipTemplate if custom getBarTip function is provided\n        if (value) {\n            this.barTooltipTemplate = null;\n        }\n\n        return value;\n    }\n\n    changeBarTooltip(tooltip, oldTooltip) {\n        oldTooltip?.destroy();\n\n        if (tooltip) {\n            return tooltip.isTooltip ? tooltip : this.barTooltipClass.new({\n                forElement  : this.timeAxisSubGridElement,\n                forSelector : '.b-histogram rect',\n                hoverDelay  : 0,\n                trackMouse  : false,\n                cls         : 'b-celltooltip-tip',\n                getHtml     : this.getTipHtml.bind(this)\n            }, this.showBarTip, tooltip);\n        }\n\n        return null;\n    }\n\n    async getTipHtml(args) {\n        if (this.showBarTip && this.barTooltipTemplate) {\n            const\n                { activeTarget } = args,\n                index            = parseInt(activeTarget.dataset.index, 10),\n                record           = this.getRecordFromElement(activeTarget),\n                histogramData    = await this.getRecordHistogramData(record);\n\n            return this.barTooltipTemplate({\n                ...args,\n                datum : this.extractHistogramDataArray(histogramData, record)[index],\n                record,\n                index\n            });\n        }\n    }\n\n    collectTicksWidth() {\n        const\n            { ticks }     = this.timeAxis,\n            prevDuration  = ticks[0].endDate - ticks[0].startDate,\n            tickDurations = { 0 : prevDuration };\n\n        let\n            totalDuration = prevDuration,\n            isMonotonous  = true;\n\n        for (let i = 1, { length } = ticks; i < length; i++) {\n            const\n                tick   = ticks[i],\n                duration = tick.endDate - tick.startDate;\n\n            // the ticks width is different -> reset isMonotonous flag\n            if (prevDuration !== duration) {\n                isMonotonous = false;\n            }\n\n            totalDuration    += duration;\n            tickDurations[i] = duration;\n        }\n\n        // if the ticks widths are not monotonous we need to calculate\n        // each bar width to provide it to the histogram widget later\n        if (!isMonotonous) {\n            const ticksWidth = {};\n            for (let i = 0, { length } = ticks; i < length; i++) {\n                ticksWidth[i] = tickDurations[i] / totalDuration;\n            }\n            this.ticksWidth = ticksWidth;\n        }\n        else {\n            this.ticksWidth = null;\n        }\n    }\n\n    changeHistogramWidget(widget) {\n        const me = this;\n\n        if (widget && !widget.isHistogram) {\n            if (me.getBarTextRenderData && !widget.getBarTextRenderData) {\n                widget.getBarTextRenderData = me.getBarTextRenderData;\n            }\n\n            widget = me.histogramWidgetClass.new({\n                owner           : me,\n                appendTo        : me.element,\n                height          : me.rowHeight,\n                width           : me.timeAxisColumn?.width || 0,\n                getBarTip       : !me.barTooltipTemplate && me.getBarTip || emptyFn,\n                getRectClass    : me.getRectClass || me.getRectClassDefault,\n                getBarText      : me.getBarText || me.getBarTextDefault,\n                getOutlineClass : me.getOutlineClass,\n                getRectConfig   : me.getRectConfig\n            }, widget);\n\n            widget.suspendRefresh();\n\n            // bind default getBarText in case it will be called from a custom getBarText()\n            me.getBarTextDefault = me.getBarTextDefault.bind(widget);\n        }\n\n        return widget;\n    }\n\n    // Injectable method.\n    getRectClassDefault(series, rectConfig, datum) {}\n\n    getBarTextDefault(datum, index) {}\n\n    updateShowBarTip(value) {\n        this.barTooltip = value;\n    }\n\n    //endregion\n\n    //region Columns\n\n    get columns() {\n        return super.columns;\n    }\n\n    set columns(columns) {\n        const me = this;\n\n        super.columns = columns;\n\n        if (!me.isDestroying) {\n            me.timeAxisColumn.renderer = me.histogramRenderer.bind(me);\n            me.timeAxisColumn.cellCls = me.timeAxisColumnCellCls;\n        }\n    }\n\n    //endregion\n\n    //region Events\n\n    onHistogramDataCacheSet({ record, data }) {\n        // schedule record refresh for later\n        this.scheduleRecordRefresh(record);\n    }\n\n    onTimeAxisEndReconfigure() {\n        if (this.hardRefreshOnTimeAxisReconfigure) {\n            // reset histogram cache\n            this.clearHistogramDataCache();\n            // schedule records refresh (that will re-fetch the histogram data from the server since the cache is empty)\n            this.scheduleRefreshRows();\n        }\n    }\n\n    onStoreUpdateRecord({ record, changes }) {\n        const me = this;\n\n        // If we read histogram data from a field and that field got changed\n        // - clear the corresponding record cache\n        if (!me.getRecordData && me.dataModelField && changes[me.dataModelField]) {\n            me.clearHistogramDataCache(record);\n        }\n\n        return super.onStoreUpdateRecord(...arguments);\n    }\n\n    onStoreRemove({ records }) {\n        super.onStoreRemove(...arguments);\n\n        for (const record of records) {\n            this.clearHistogramDataCache(record);\n        }\n    }\n\n    onBeforeRowHeight({ height }) {\n        // <remove-on-release>\n        // TODO: histogramWidget getter requests timeAxisColumn column too early which causes an infinite cycle\n        // </remove-on-release>\n        if (this._timeAxisColumn) {\n            const widget = this._histogramWidget;\n\n            if (widget) {\n                widget.height = height;\n                widget.onElementResize(widget.element);\n            }\n        }\n    }\n\n    onTimeAxisViewModelUpdate() {\n        super.onTimeAxisViewModelUpdate(...arguments);\n\n        const widget = this._histogramWidget;\n\n        if (widget) {\n            widget.width = this.timeAxisViewModel.totalSize;\n            widget.onElementResize(widget.element);\n        }\n\n        this.collectTicksWidth();\n    }\n\n    //endregion\n\n    //region Data processing\n\n    extractHistogramDataArray(histogramData, record) {\n        return histogramData;\n    }\n\n    processRecordRenderData(renderData) {\n        return renderData;\n    }\n\n    /**\n     * Clears the histogram data cache for the provided record (if provided).\n     * If the record is not provided clears the cache for all records.\n     * @param {Core.data.Model} [record] Record to clear the cache for.\n     */\n    clearHistogramDataCache(record) {\n        if (record) {\n            this.histogramDataByRecord.delete(record);\n        }\n        else {\n            this.histogramDataByRecord.clear();\n        }\n    }\n\n    /**\n     * Caches the provided histogram data for the given record.\n     * @param {Core.data.Model} record Record to cache data for.\n     * @param {Object} data Histogram data to cache.\n     */\n    setHistogramDataCache(record, data) {\n        const eventData = { record, data };\n\n        /**\n         * Fires before the component stores a record's histogram data into the cache.\n         *\n         * A listener can be used to transform the collected data dynamically before\n         * it's cached:\n         *\n         * ```javascript\n         * new TimelineHistogram({\n         *     series : {\n         *         foo : {\n         *             type  : 'bar',\n         *             field : 'f1'\n         *         }\n         *     },\n         *     ...\n         *     listeners : {\n         *         beforeHistogramDataCacheSet(eventData) {\n         *             // completely replace the data for a specific record\n         *             if (eventData.record.id === 123) {\n         *                 eventData.data = [\n         *                     { f1 : 10 },\n         *                     { f1 : 20 },\n         *                     { f1 : 30 },\n         *                     { f1 : 40 },\n         *                     { f1 : 50 },\n         *                     { f1 : 60 }\n         *                 ];\n         *             }\n         *         }\n         *     }\n         * })\n         * ```\n         *\n         * @param {Scheduler.view.TimelineHistogram} source The component instance\n         * @param {Core.data.Model} record Record the histogram data of which is ready.\n         * @param {Object} data The record histogram data.\n         * @event beforeHistogramDataCacheSet\n         */\n        this.trigger('beforeHistogramDataCacheSet', eventData);\n\n        this.histogramDataByRecord.set(eventData.record, eventData.data);\n\n        /**\n         * Fires after the component retrieves a record's histogram data and stores\n         * it into the cache.\n         *\n         * Unlike similar {@link #event-beforeHistogramDataCacheSet} event this event is triggered\n         * after the data is put into the cache.\n         *\n         * A listener can be used to transform the collected data dynamically:\n         *\n         * ```javascript\n         * new TimelineHistogram({\n         *     series : {\n         *         bar : {\n         *             type : 'bar',\n         *             field : 'bar'\n         *         },\n         *         halfOfBar : {\n         *             type  : 'outline',\n         *             field : 'half'\n         *         }\n         *     },\n         *     ...\n         *     listeners : {\n         *         histogramDataCacheSet({ data }) {\n         *             // add extra entries to collected data\n         *             data.forEach(entry => {\n         *                 entry.half = entry.bar / 2;\n         *             });\n         *         }\n         *     }\n         * })\n         * ```\n         *\n         * @param {Scheduler.view.TimelineHistogram} source The component instance\n         * @param {Core.data.Model} record Record the histogram data of which is ready.\n         * @param {Object} data The record histogram data.\n         * @event histogramDataCacheSet\n         */\n        this.trigger('histogramDataCacheSet', eventData);\n    }\n\n    /**\n     * Returns entire histogram data cache if no record provided,\n     * or cached data for the provided record.\n     * @param {Core.data.Model} [record] Record to get the cached data for.\n     * @returns {Object} The provided record cached data or all the records data cache\n     * as a `Map` keyed by records.\n     */\n    getHistogramDataCache(record) {\n        return record ? this.histogramDataByRecord.get(record) : this.histogramDataByRecord;\n    }\n\n    /**\n     * Returns `true` if there is cached histogram data for the provided record.\n     * @param {Core.data.Model} record Record to check the cache existence for.\n     * @returns {Boolean} `True` if there is a cache for provided record.\n     */\n    hasHistogramDataCache(record) {\n        return this.histogramDataByRecord.has(record);\n    }\n\n    finalizeDataRetrievingInternal(record, data) {\n        // cleanup collectingDataFor map on data collecting completion\n        this.collectingDataFor.delete(record);\n\n        // cache record data\n        this.setHistogramDataCache(record, data);\n\n        // pass data through\n        return data;\n    }\n\n    finalizeDataRetrieving(record, data) {\n        if (Objects.isPromise(data)) {\n            this.collectingDataFor.set(record, data);\n\n            return data.then(data => this.finalizeDataRetrievingInternal(record, data));\n        }\n\n        return this.finalizeDataRetrievingInternal(record, data);\n    }\n\n    /**\n     * Retrieves the histogram data for the provided record.\n     *\n     * The method first checks if there is cached data for the record and returns it if found.\n     * Otherwise it starts collecting data by calling {@link #config-getRecordData} (if provided)\n     * or by reading it from {@link #config-dataModelField} record field.\n     *\n     * The method can be asynchronous depending on the provided {@link #config-getRecordData} function.\n     * If the function returns a `Promise` then the method will return a wrapping `Promise` in turn that will\n     * resolve with the collected histogram data.\n     *\n     * The method triggers {@link #event-histogramDataCacheSet} event when a record data is ready.\n     *\n     * @param {Core.data.Model} record Record to retrieve the histogram data for.\n     * @returns {Object|Promise} The histogram data for the provided record or a `Promise` that will provide the data\n     * when resolved.\n     */\n    getRecordHistogramData(record) {\n        const\n            me     = this,\n            { getRecordData } = me;\n\n        let result = me.collectingDataFor.get(record) || me.getHistogramDataCache(record);\n\n        if (!result && !me.hasHistogramDataCache(record)) {\n            // use \"getRecordData\" function if provided\n            if (getRecordData) {\n                result = getRecordData.handler.call(getRecordData.thisObj, ...arguments);\n            }\n            // or read data from the configured model field\n            else {\n                result = record.get(me.dataModelField);\n            }\n\n            result = me.finalizeDataRetrieving(record, result);\n        }\n\n        return result;\n    }\n\n    recordIsReadyForRendering(record) {\n        return !this.collectingDataFor.has(record);\n    }\n\n    //endregion\n\n    //region Render\n\n    beforeRenderRow(eventData) {\n        const\n            me = this,\n            histogramData = me.getRecordHistogramData(eventData.record);\n\n        if (!Objects.isPromise(histogramData)) {\n            const data = histogramData ? me.extractHistogramDataArray(histogramData, eventData.record) : [];\n\n            // if ticks widths are not monotonous\n            // we provide widths for each bar since in that case the histogram widget\n            // won't be able to calculate them properly\n            if (me.ticksWidth) {\n                for (let i = 0, { length } = data; i < length; i++) {\n                    data[i].width = me.ticksWidth[i];\n                }\n            }\n\n            const histogramConfig = Objects.merge(\n                // reset topValue by default to enable its auto-detection\n                { topValue : null },\n                me.initialConfig.histogramWidget,\n                {\n                    data,\n                    series : { ...me.series }\n                });\n\n            eventData = {\n                ...eventData,\n                histogramConfig,\n                histogramData,\n                histogramWidget : me.histogramWidget\n            };\n\n            /**\n             * Fires before the component renders a row.\n             *\n             * This event is recommended to use instead of generic {@link #event-beforeRenderRow} event since\n             * the component bails out of rendering rows for which histogram data is not ready yet\n             * (happens in case of async data collecting). The generic {@link #event-beforeRenderRow}\n             * is triggered in such cases too while this event is triggered only when the data is ready and the\n             * row is actually about to be rendered.\n             *\n             * Use a listener to adjust histograms rendering dynamically for individual rows:\n             *\n             * ```javascript\n             * new TimelineHistogram({\n             *     ...\n             *     listeners : {\n             *         beforeRenderHistogramRow({ record, histogramConfig }) {\n             *             // display an extra line for some specific record\n             *             if (record.id == 111) {\n             *                 histogramConfig.series.extraLine = {\n             *                     type  : 'outline',\n             *                     field : 'foo'\n             *                 };\n             *             }\n             *         }\n             *     }\n             * })\n             * ```\n             *\n             * @param {Scheduler.view.TimelineHistogram} source The component instance\n             * @param {Core.data.Model} record Record the histogram data of which is ready.\n             * @param {HistogramConfig} histogramConfig Configuration object that will be applied to `histogramWidget`.\n             * @param {Core.widget.graph.Histogram} histogramWidget The underlying widget that is used to render a chart.\n             * @event beforeRenderHistogramRow\n             */\n            me.trigger('beforeRenderHistogramRow', eventData);\n\n            // We are going to use eventData as stored renderData\n            // so sanitize it from unwanted properties\n            delete eventData.eventName;\n            delete eventData.source;\n            delete eventData.type;\n            delete eventData.oldId;\n            delete eventData.row;\n            delete eventData.recordIndex;\n\n            me._recordRenderData = me.processRecordRenderData(eventData);\n        }\n\n        super.beforeRenderRow(...arguments);\n    }\n\n    applyHistogramWidgetConfig(histogramWidget = this.histogramWidget, histogramConfig) {\n        // reset some parameters (topValue and series) to force recalculations\n        // and apply new configuration after\n        Object.assign(histogramWidget, histogramWidgetCleanState, histogramConfig);\n    }\n\n    /**\n     * Renders a histogram for a row.\n     * The method applies passed data to the underlying {@link #property-histogramWidget} component.\n     * Then the component renders charts and the method injects them into the corresponding column cell.\n     * @param {HistogramRenderData} renderData Render data\n     * @internal\n     */\n    renderRecordHistogram(renderData) {\n        const\n            me = this,\n            { histogramData, cellElement } = renderData;\n\n        // reset the cell for rows not having histogram data\n        if (!histogramData) {\n            cellElement.innerHTML = '';\n            return;\n        }\n\n        /**\n         * Fires before the component renders a histogram in a cell.\n         *\n         * @param {Scheduler.view.TimelineHistogram} source The component instance\n         * @param {Core.data.Model} record Record the histogram data of which is ready.\n         * @param {HistogramConfig} histogramConfig Configuration object that will be applied to `histogramWidget`.\n         * @param {Core.widget.graph.Histogram} histogramWidget The underlying widget that is used to render a chart.\n         * @event beforeRenderRecordHistogram\n         */\n        me.trigger('beforeRenderRecordHistogram', renderData);\n\n        // sanitize renderData from unwanted properties\n        delete renderData.eventName;\n        delete renderData.type;\n        delete renderData.source;\n\n        const histogramWidget = renderData.histogramWidget || me.histogramWidget;\n\n        me.applyHistogramWidgetConfig(histogramWidget, renderData.histogramConfig);\n\n        histogramWidget.refresh({\n            // tell histogram we want it to pass renderData as an extra argument in nested calls of getBarText and\n            // other configured hooks\n            args : [renderData]\n        });\n\n        const histogramCloneElement = histogramWidget.element.cloneNode(true);\n        histogramCloneElement.removeAttribute('id');\n        histogramCloneElement.classList.remove('b-hide-offscreen');\n\n        cellElement.innerHTML = '';\n        cellElement.appendChild(histogramCloneElement);\n    }\n\n    /**\n     * TimeAxis column renderer used by this view to render row histograms.\n     * It first calls {@link #function-getRecordHistogramData} method to retrieve\n     * the histogram data for the renderer record.\n     * If the record data is ready the method renders the record histogram.\n     * And in case the method returns a `Promise` the renderer just\n     * schedules the record refresh for later and exits.\n     *\n     * @param {HistogramRenderData} renderData Object containing renderer parameters.\n     * @internal\n     */\n    histogramRenderer(renderData) {\n        const\n            me            = this,\n            histogramData = renderData.histogramData || me.getRecordHistogramData(renderData.record);\n\n        // If the data is ready we just render a histogram\n        // Otherwise we render nothing and the rendering will happen once the data is ready\n        // (which is signalized by histogramDataCacheSet event)\n\n        if (!Objects.isPromise(histogramData)) {\n            Object.assign(renderData, me._recordRenderData);\n\n            return me.renderRecordHistogram(...arguments);\n        }\n\n        return '';\n    }\n\n    /**\n     * Group feature hook triggered by the feature to render group headers\n     * @param {*} renderData\n     * @internal\n     */\n    buildGroupHeader(renderData) {\n        if (renderData.column === this.timeAxisColumn) {\n            return this.histogramRenderer(renderData);\n        }\n\n        return this.features.group.buildGroupHeader(renderData);\n    }\n\n    //endregion\n\n    get widgetClass() {}\n\n}\n\nTimelineHistogramBase.initClass();\n", "import ArrayHelper from '../../../Core/helper/ArrayHelper.js';\nimport Objects from '../../../Core/helper/util/Objects.js';\nimport TimelineHistogramBase from '../TimelineHistogramBase.js';\n\n/**\n * @module Scheduler/view/mixin/TimelineHistogramGrouping\n */\n\n/**\n * Mixin for {@link Scheduler/view/TimelineHistogram} that provides record grouping support.\n * The class implements API to work with groups and their members and allows to rollup group members data\n * to their parents.\n *\n * The _groups_ here are either group headers built with the {@link Grid/feature/Group} feature or\n * parent nodes built with the {@link Grid/feature/TreeGroup} feature.\n *\n * ## Parent histogram data aggregating\n *\n * The mixin provides a {@link #config-aggregateHistogramDataForGroups} config which enables automatically rolling up\n * child records histogram data to their parents. By default all registered {@link #config-series}' values are\n * just summed up on parents level, but that can be changed by providing `aggregate`\n * config to {@link #config-series}:\n *\n * ```javascript\n * new TimelineHistogram({\n *     series : {\n *         salary : {\n *            type : 'bar',\n *            // show maximum value on the parent level\n *            aggregate : 'max'\n *         }\n *     },\n *     ...\n * })\n * ```\n *\n * Here is the list of supported `aggregate` values:\n *\n * - `sum` or `add` - sum of values in the group (default)\n * - `min` - minimum value in the group\n * - `max` - maximum value in the group\n * - `count` - number of child records in the group\n * - `avg` - average of the child values in the group\n *\n * There are a few hooks allowing customization of the rolling up process:\n * {@link #config-aggregateDataEntry}, {@link #config-getDataEntryForAggregating} and\n * {@link #config-initAggregatedDataEntry}.\n *\n * @extends Scheduler/view/TimelineHistogramBase\n * @mixin\n */\nexport default Target => class TimelineHistogramGrouping extends (Target || TimelineHistogramBase) {\n\n    static $name = 'TimelineHistogramGrouping';\n\n    //region Configs\n\n    static configurable = {\n        /**\n         * When `true` the component will automatically calculate data for group records\n         * based on the groups members data by calling {@link #function-getGroupRecordHistogramData} method.\n         * @config {Boolean}\n         * @category Parent histogram data collecting\n         * @default\n         */\n        aggregateHistogramDataForGroups : true,\n\n        /**\n         * A function used for aggregating child records histogram data entries to their parent entry.\n         *\n         * It's called for each child entry and is meant to apply the child entry values to the\n         * target parent entry (provided in `aggregated` parameter).\n         * The function must return the resulting aggregated entry that will be passed as `aggregated`\n         * parameter to the next __aggregating__ step.\n         *\n         * Should be provided as a function, or name of a function in the ownership hierarchy which may be called.\n         * @config {Function|String} aggregateDataEntry\n         * @param {Object} aggregateDataEntry.aggregated Target parent data entry to aggregate the entry into.\n         * @param {Object} aggregateDataEntry.entry Current entry to aggregate into `aggregated`.\n         * @param {Number} aggregateDataEntry.arrayIndex Index of current array (index of the record among other\n         * records being aggregated).\n         * @param {Object[]} aggregateDataEntry.entryIndex Index of `entry` in the current array.\n         * @returns {Object} Return value becomes the value of the `aggregated` parameter on the next\n         * invocation of this function.\n         * @category Parent histogram data collecting\n         * @default\n         */\n        aggregateDataEntry : null,\n\n        /**\n         * Function that extracts a record histogram data entry for aggregating.\n         * By default it returns the entry as is. Override the function if you need a more complex way\n         * to retrieve the value for aggregating.\n         *\n         * Should be provided as a function, or name of a function in the ownership hierarchy which may be called.\n         * @config {Function|String} getDataEntryForAggregating\n         * @param {Object} getDataEntryForAggregating.entry Current data entry.\n         * @returns {Object} Entry to aggregate\n         * @category Parent histogram data collecting\n         * @default\n         */\n        getDataEntryForAggregating : null,\n\n        /**\n         * A function that initializes a target group record entry.\n         *\n         * Should be provided as a function, or name of a function in the ownership hierarchy which may be called.\n         * @config {Function|String} initAggregatedDataEntry\n         * @returns {Object} Target aggregated entry\n         * @category Parent histogram data collecting\n         * @default\n         */\n        initAggregatedDataEntry : null,\n\n        aggregateFunctions : {\n            sum : {\n                aliases : ['add'],\n                entry(seriesId, acc, entry) {\n                    acc[seriesId] = (acc[seriesId] || 0) + entry[seriesId];\n\n                    return acc;\n                }\n            },\n            min : {\n                entry(seriesId, acc, entry) {\n                    const entryValue = entry[seriesId];\n\n                    if (entryValue < (acc[seriesId] || Number.MAX_VALUE)) acc[seriesId] = entryValue;\n\n                    return acc;\n                }\n            },\n            max : {\n                entry(seriesId, acc, entry) {\n                    const entryValue = entry[seriesId];\n\n                    if (entryValue > (acc[seriesId] || Number.MIN_VALUE)) acc[seriesId] = entryValue;\n\n                    return acc;\n                }\n            },\n            count : {\n                init(seriesId, entry, entryIndex, aggregationContext) {\n                    entry[seriesId] = aggregationContext.arrays.length;\n                }\n            },\n            avg : {\n                entry(seriesId, acc, entry) {\n                    acc[seriesId] = (acc[seriesId] || 0) + entry[seriesId];\n\n                    return acc;\n                },\n                finalize(seriesId, data, recordsData, records, aggregationContext) {\n                    const cnt = aggregationContext.arrays.length;\n\n                    data.forEach(entry => entry[seriesId] /= cnt);\n                }\n            }\n        }\n    };\n\n    afterConfigure() {\n        const me = this;\n\n        me.internalAggregateDataEntry = me.internalAggregateDataEntry.bind(this);\n        me.internalInitAggregatedDataEntry = me.internalInitAggregatedDataEntry.bind(this);\n\n        super.afterConfigure();\n\n        if (me.features.treeGroup) {\n            me.features.treeGroup.ion({\n                // reset groups cache on store grouping change\n                beforeDataLoad : me.onTreeGroupBeforeDataLoad,\n                thisObj        : me\n            });\n        }\n    }\n\n    updateAggregateFunctions(value) {\n        for (const [id, fn] of Object.entries(value)) {\n            fn.id = id;\n            if (fn.aliases) {\n                for (const alias of fn.aliases) {\n                    value[alias] = fn;\n                }\n            }\n        }\n    }\n\n    updateStore(store) {\n        super.updateStore(...arguments);\n\n        this.detachListeners('store');\n\n        if (store) {\n            store.ion({\n                name    : 'store',\n                // reset groups cache on store grouping change\n                group   : this.onStoreGroup,\n                thisObj : this\n            });\n        }\n    }\n\n    changeAggregateDataEntry(fn) {\n        return this.bindCallback(fn);\n    }\n\n    changeGetDataEntryForAggregating(fn) {\n        return this.bindCallback(fn);\n    }\n\n    changeInitAggregatedDataEntry(fn) {\n        return this.bindCallback(fn);\n    }\n\n    //endregion\n\n    //region Event listeners\n\n    onHistogramDataCacheSet({ record, data }) {\n        // schedule record refresh for later\n        super.onHistogramDataCacheSet(...arguments);\n\n        if (this.aggregateHistogramDataForGroups) {\n            this.scheduleRecordParentsRefresh(record);\n        }\n    }\n\n    onTreeGroupBeforeDataLoad() {\n        if (this.aggregateHistogramDataForGroups) {\n            // reset groups cache on store grouping change\n            this.resetGeneratedRecordsHistogramDataCache();\n        }\n    }\n\n    onStoreGroup() {\n        if (this.aggregateHistogramDataForGroups) {\n            // reset groups cache on store grouping change\n            this.resetGeneratedRecordsHistogramDataCache();\n        }\n    }\n\n    //endregion\n\n    // Override getRecordHistogramData to support data aggregating for parents\n    getRecordHistogramData(record, aggregationContext) {\n        const me = this;\n\n        let result;\n\n        // If that's a group record and records aggregating is enabled\n        // collect the aggregated data based on children\n        if (me.aggregateHistogramDataForGroups && me.isGroupRecord(record)) {\n\n            result = me.collectingDataFor.get(record) || me.getHistogramDataCache(record);\n\n            if (!result && !me.hasHistogramDataCache(record)) {\n                result = me.getGroupRecordHistogramData(record, aggregationContext);\n\n                result = me.finalizeDataRetrieving(record, result);\n            }\n        }\n        else {\n            result = super.getRecordHistogramData(...arguments);\n        }\n\n        return result;\n    }\n\n    //region ArrayHelper.aggregate default callbacks\n\n    internalAggregateDataEntry(acc, ...args) {\n        const { aggregateFunctions } = this;\n\n        // call series aggregate functions\n        for (const { id, aggregate = 'sum' } of Object.values(this.series)) {\n            let fn;\n            if (aggregate !== false && ((fn = aggregateFunctions[aggregate].entry))) {\n                acc = fn(id, acc, ...args);\n            }\n        }\n\n        return this.aggregateDataEntry ? this.aggregateDataEntry(acc, ...args) : acc;\n    }\n\n    internalInitAggregatedDataEntry() {\n        const\n            entry = this.initAggregatedDataEntry ? this.initAggregatedDataEntry(...arguments) : {},\n            { aggregateFunctions } = this;\n\n        // call series aggregate functions\n        for (const { id, aggregate = 'sum' } of Object.values(this.series)) {\n            const fn = aggregateFunctions[aggregate].init;\n            if (fn && aggregate !== false) {\n                fn(id, entry, ...arguments);\n            }\n        }\n\n        return entry;\n    }\n\n    //endregion\n\n    //region Public methods\n\n    /**\n     * Resets generated records (parents and links) data cache\n     */\n    resetGeneratedRecordsHistogramDataCache() {\n        const { store } = this;\n\n        for (const record of this.getHistogramDataCache().keys()) {\n            // clear cache for generated parents and links no longer in the store\n            if (record.isGroupHeader || record.generatedParent || (record.isLinked && !store.includes(record))) {\n                this.clearHistogramDataCache(record);\n            }\n        }\n    }\n\n    setHistogramDataCache(record, data) {\n        super.setHistogramDataCache(record, data);\n\n        // If that's a link let's update the original record cache too\n        if (record.isLinked) {\n            super.setHistogramDataCache(record.$original, data);\n        }\n        // if that's a record having links - update their caches too\n        else if (record.$links) {\n            const { store } = this;\n\n            for (const link of record.$links) {\n                // make sure the link belongs to this view store\n                if (store.includes(link)) {\n                    super.setHistogramDataCache(link, data);\n                }\n            }\n        }\n    }\n\n    // Override method to support links built by TreeGroup feature\n    // so for the links the method will retrieve original records cache\n    getHistogramDataCache(record) {\n        let result = super.getHistogramDataCache(record);\n\n        // if that's a link - try getting the original record cache\n        if (!result && record.isLinked) {\n            result = super.getHistogramDataCache(record.$original);\n        }\n\n        return result;\n    }\n\n    /**\n     * Aggregates the provided group record children histogram data.\n     * If some of the provided records data is not ready yet the method returns a `Promise`\n     * that's resolved once the data is ready and aggregated.\n     *\n     * ```javascript\n     * // get parent record aggregated histogram data\n     * const aggregatedData = await histogram.getGroupRecordHistogramData(record);\n     * ```\n     *\n     * @param {Core.data.Model} record Group record.\n     * @param {Object} [aggregationContext] Optional aggregation context object.\n     * When provided will be used as a shared object passed through while collecting the data.\n     * So can be used for some custom application purposes.\n     * @returns {Object[]|Promise} Either the provided group record histogram data or a `Promise` that\n     * returns the data when resolved.\n     * @category Parent histogram data collecting\n     */\n    getGroupRecordHistogramData(record, aggregationContext = {}) {\n        aggregationContext.parentRecord = record;\n\n        const result = this.aggregateRecordsHistogramData(this.getGroupChildren(record), aggregationContext);\n\n        return Objects.isPromise(result) ? result.then(res => res) : result;\n    }\n\n    /**\n     * Aggregates multiple records histogram data.\n     * If some of the provided records data is not ready yet the method returns a `Promise`\n     * that's resolved once the data is ready and aggregated.\n     *\n     * @param {Core.data.Model[]} records Records to aggregate data of.\n     * @param {Object} [aggregationContext] Optional aggregation context object.\n     * Can be used by to share some data between the aggregation steps.\n     * @returns {Object[]|Promise} Either the provided group record histogram data or a `Promise` that\n     * returns the data when resolved.\n     * @category Parent histogram data collecting\n     */\n    aggregateRecordsHistogramData(records, aggregationContext = {}) {\n        const\n            me = this,\n            recordsData = [],\n            { parentRecord } = aggregationContext;\n\n        let hasPromise = false;\n\n        // collect children data\n        for (const child of records) {\n            const childData = me.getRecordHistogramData(child, aggregationContext);\n\n            hasPromise = hasPromise || Objects.isPromise(childData);\n\n            childData && recordsData.push(childData);\n        }\n\n        // If some of children daa is not ready yet\n        if (hasPromise) {\n            // wait till all children data is ready\n            return Promise.all(recordsData).then(values => {\n                // re-apply parentRecord since it could get overridden in above getRecordHistogramData() calls\n                aggregationContext.parentRecord = parentRecord;\n\n                // filter out empty values\n                values = values.filter(x => x);\n\n                return me.aggregateHistogramData(values, records, aggregationContext);\n            });\n        }\n\n        // aggregate collected data\n        return me.aggregateHistogramData(recordsData, records, aggregationContext);\n    }\n\n    /**\n     * Indicates if the passed record represents a group header built by {@link Grid/feature/Group} feature\n     * or a group built by {@link Grid/feature/TreeGroup} feature.\n     *\n     * @param {Core.data.Model} record The view record\n     * @returns {Boolean} `true` if the record represents a group.\n     * @internal\n     */\n    isGroupRecord(record) {\n        return record.isGroupHeader || (this.isTreeGrouped && record.generatedParent);\n    }\n\n    /**\n     * For a record representing a group built by {@link Grid/feature/Group} or {@link Grid/feature/TreeGroup}\n     * feature returns the group members.\n     *\n     * @param {Core.data.Model} record A group record\n     * @returns {Core.data.Model[]} Records belonging to the group\n     * @internal\n     */\n    getGroupChildren(record) {\n        return record.groupChildren || record.children;\n    }\n\n    /**\n     * For a record belonging to a group built by {@link Grid/feature/Group} or {@link Grid/feature/TreeGroup}\n     * feature returns the group header or parent respectively.\n     *\n     * @param {Core.data.Model} record A member record\n     * @returns {Core.data.Model} The record group header or parent record\n     * @internal\n     */\n    getRecordParent(record) {\n        const instanceMeta = record.instanceMeta(this.store.id);\n\n        return instanceMeta?.groupParent || (this.isTreeGrouped && record.parent);\n    }\n\n    /**\n     * Schedules refresh of the provided record's parents.\n     * The method iterates up from the provided record parent to the root node\n     * and schedules the iterated node rows refresh.\n     * @param {Core.data.Model} record Record to refresh parent rows of.\n     * @param {Boolean} [clearCache=true] `true` to reset the scheduled records histogram data cache.\n     * @internal\n     */\n    scheduleRecordParentsRefresh(record, clearCache = true) {\n        const me = this;\n\n        let groupParent;\n\n        while ((groupParent = me.getRecordParent(record))) {\n            // reset group cache\n            clearCache && me.clearHistogramDataCache(groupParent);\n            // and scheduler its later refresh\n            me.scheduleRecordRefresh(groupParent);\n            // bubble up\n            record = groupParent;\n        }\n    }\n\n    //endregion\n\n    /**\n     * Aggregates collected child records data to its parent.\n     * The method is synchronous and is called when all the child records data is ready.\n     * Override the method if you need to preprocess or postprocess parent records aggregated data:\n     *\n     * ````javascript\n     * class MyHistogramView extends TimelineHistogram({\n     *\n     *     aggregateHistogramData(recordsData, records, aggregationContext) {\n     *         const result = super.aggregateHistogramData(recordsData, records, aggregationContext);\n     *\n     *         // postprocess averageSalary series values collected for a parent record\n     *         result.forEach(entry => {\n     *             entry.averageSalary = entry.averageSalary / records.length;\n     *         });\n     *\n     *         return result;\n     *     }\n     *\n     * });\n     * ```\n     *\n     * @param {Object[]} recordsData Child records histogram data.\n     * @param {Core.data.Model[]} records Child records.\n     * @param {Object} aggregationContext An object containing current shared info on the current aggregation process\n     */\n    aggregateHistogramData(recordsData, records, aggregationContext = {}) {\n        const\n            me = this,\n            { aggregateFunctions } = me;\n\n        aggregationContext.recordsData = recordsData;\n        aggregationContext.records     = records;\n\n        const arrays = recordsData.map((histogramData, index) => {\n            return me.extractHistogramDataArray(\n                histogramData,\n                records[index]\n            );\n        });\n\n        // summarize children histogram data\n        const result = ArrayHelper.aggregate(\n            arrays,\n            me.getDataEntryForAggregating || (entry => entry),\n            me.internalAggregateDataEntry,\n            me.internalInitAggregatedDataEntry,\n            aggregationContext\n        );\n\n        // call series aggregate functions\n        for (const { id, aggregate = 'sum' } of Object.values(me.series)) {\n            const fn = aggregateFunctions[aggregate].finalize;\n            if (fn && aggregate !== false) {\n                fn(id, result, ...arguments);\n            }\n        }\n\n        return result;\n    }\n\n    get widgetClass() {}\n\n};\n", "import '../../column/ScaleColumn.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n\n/**\n * @module Scheduler/view/mixin/TimelineHistogramScaleColumn\n */\n\n/**\n * Mixin of {@link Scheduler/view/TimelineHistogram} class that implements\n * {@link Scheduler/column/ScaleColumn} automatic injection and functioning.\n *\n * @mixin\n */\nexport default Target => class TimelineHistogramScaleColumn extends (Target) {\n\n    static $name = 'TimelineHistogramScaleColumn';\n\n    //region Config\n\n    static configurable = {\n\n        /**\n         * The locked grid scale column reference.\n         * @member {Scheduler.column.ScaleColumn} scaleColumn\n         * @readonly\n         * @category Scale column\n         */\n\n        /**\n         * An object with configuration for the {@link Scheduler/column/ScaleColumn}.\n         *\n         * Example:\n         *\n         * ```javascript\n         * new TimelineHistogram({\n         *     scaleColumn : {\n         *         width : 50\n         *     },\n         *     ...\n         * });\n         * ```\n         *\n         * Provide `null` to the config to get rid of the column completely:\n         *\n         * ```javascript\n         * new TimelineHistogram({\n         *     // do not add scale column\n         *     scaleColumn : null,\n         *     ...\n         * });\n         * ```\n         *\n         * @config {Object} scaleColumn\n         * @category Scale column\n         */\n        scaleColumn : {},\n\n        scalePoints : null,\n\n        scalePointsModelField : 'scalePoints',\n\n        calculateTopValueByScalePoints : true\n    };\n\n    updateScalePoints(scalePoints) {\n        const\n            me            = this,\n            topScalePoint = scalePoints[scalePoints.length - 1];\n\n        if (topScalePoint) {\n            me.scaleUnit = topScalePoint.unit;\n\n            // Applying new maximum value to the histogram.\n            me.histogramWidget.topValue = me.getTopValueByScalePoints(scalePoints);\n        }\n\n        // Applying new points to the scale column\n        if (me.scaleColumn) {\n            me.scaleColumn.scalePoints = scalePoints;\n        }\n    }\n\n    //endregion\n\n    //region Columns\n\n    changeColumns(columns, currentStore) {\n        const\n            me = this,\n            scaleColumn = me.getConfig('scaleColumn');\n\n        // No columns means destroy\n        if (columns && scaleColumn) {\n            const isArray = Array.isArray(columns);\n\n            let cols = columns;\n\n            if (!isArray) {\n                cols = columns.data;\n            }\n\n            let\n                scaleColumnIndex = cols?.length,\n                scaleColumnConfig = scaleColumn;\n\n            cols.some((col, index) => {\n                if (col.type === 'scale') {\n                    scaleColumnIndex  = index;\n                    scaleColumnConfig = ObjectHelper.assign(col, scaleColumnConfig);\n                    return true;\n                }\n            });\n\n            // We're going to mutate this array which we do not own, so copy it first.\n            cols = cols.slice();\n\n            // Fix up the scaleColumn config in place\n            cols[scaleColumnIndex] = {\n                type : 'scale',\n                ...scaleColumnConfig\n            };\n\n            if (isArray) {\n                columns = cols;\n            }\n            else {\n                columns.data = cols;\n            }\n        }\n\n        return super.changeColumns(columns, currentStore);\n    }\n\n    updateColumns(columns, was) {\n        super.updateColumns(columns, was);\n\n        // Extract the known columns by type. Sorting will have placed them into visual order.\n        if (columns) {\n            this._scaleColumn = this.columns.find(c => c.isScaleColumn);\n        }\n    }\n\n    onColumnsChanged({ action, changes, record : column, records }) {\n        const { scaleColumn, columns } = this;\n        // If someone replaces the column set (syncing leads to batch), ensure scale is always added\n        if (scaleColumn && (action === 'dataset' || action === 'batch') && !columns.includes(scaleColumn)) {\n            columns.add(scaleColumn, true);\n        }\n\n        super.onColumnsChanged(...arguments);\n    }\n\n    //endregion\n\n    //region Data processing\n\n    /**\n     * A hook to convert scale point values to histogram ones.\n     * In case they use different units.\n     *\n     * Override this method in a sub-class to implement your custom\n     * application specific conversion.\n     * @param {Number} value Scale point value\n     * @param {String} unit Scale point unit\n     * @internal\n     */\n    convertUnitsToHistogramValue(value, unit) {\n        return value;\n    }\n\n    /**\n     * A hook to convert histogram values to scale point ones.\n     * In case they use different units.\n     *\n     * Override this method in a sub-class to implement your custom\n     * application specific conversion.\n     * @param {Number} value Scale point value\n     * @param {String} unit Scale point unit\n     * @internal\n     */\n    convertHistogramValueToUnits(value, unit) {\n        return value;\n    }\n\n    extractHistogramDataArray(histogramData, record) {\n        return histogramData;\n    }\n\n    getTopValueByScalePoints(scalePoints) {\n        const\n            me              = this,\n            { scaleColumn } = me,\n            lastPoint       = scalePoints[scalePoints.length - 1],\n            { value, unit } = lastPoint;\n\n        let rawValue = value;\n\n        if (scaleColumn) {\n            // add padding to top value\n            rawValue *= 1 + (scaleColumn.scaleWidget.scaleMaxPadding || 0);\n        }\n\n        return me.convertUnitsToHistogramValue(rawValue, unit || me.scaleUnit);\n    }\n\n    processRecordRenderData(renderData) {\n        renderData = super.processRecordRenderData(...arguments);\n\n        if (this.scaleColumn) {\n            const\n                me = this,\n                { record, histogramData, histogramConfig = {} } = renderData;\n\n            let\n                topValue = me.initialConfig.histogramWidget?.topValue,\n                scalePoints = me.scalePoints || record.get(me.scalePointsModelField);\n\n            if (!topValue) {\n                // if no topValue provided but we have scalePoints\n                if (scalePoints && me.calculateTopValueByScalePoints) {\n                    // calculate topValue based on the max scale point\n                    topValue = me.getTopValueByScalePoints(scalePoints);\n                }\n\n                // if still no topValue\n                if (!topValue && histogramData) {\n                    const histogramWidget = renderData.histogramWidget || me.histogramWidget;\n\n                    ObjectHelper.assign(histogramWidget, histogramConfig);\n\n                    // get top value based on histogramData\n                    topValue = histogramWidget.getDataTopValue(histogramData);\n\n                    scalePoints = [{\n                        // <remove-on-release>\n                        // TODO append scale unit hook?\n                        // </remove-on-release>\n                        value : me.convertHistogramValueToUnits(topValue, me.scaleUnit),\n                        text  : me.convertHistogramValueToUnits(topValue, me.scaleUnit)\n                    }];\n\n                    topValue += me.scaleColumn.scaleWidget.scaleMaxPadding * topValue;\n                }\n\n                renderData.scaleWidgetConfig = { scalePoints };\n                renderData.histogramConfig = { ...histogramConfig, topValue };\n            }\n        }\n\n        return renderData;\n    }\n\n    //endregion\n\n    //region Render\n\n    /**\n     * Group feature hook triggered by the feature to render group headers\n     * @param {Object} renderData\n     * @internal\n     */\n    buildGroupHeader(renderData) {\n        if (renderData.column === this.scaleColumn) {\n            return this.scaleColumn.renderer(renderData);\n        }\n\n        return super.buildGroupHeader(...arguments);\n    }\n\n    beforeRenderCell(renderData) {\n        if (this.scaleColumn && renderData.column === this.scaleColumn) {\n            renderData.histogramData = this.getRecordHistogramData(renderData.record);\n\n            // If data is read apply prepared render data\n            if (!ObjectHelper.isPromise(renderData.histogramData)) {\n                Object.assign(renderData, this._recordRenderData);\n            }\n        }\n\n        return super.beforeRenderCell(...arguments);\n    }\n\n    /**\n     * Renders record scale column content.\n     * @param {Core.data.Model} record Record to render scale for\n     * @param {Object} [renderData]\n     * @category Scale column\n     */\n    renderRecordScale(record, renderData) {\n        if (this.scaleColumn) {\n            const\n                row         = this.getRowFor(record),\n                cellElement = row?.getCell(this.scaleColumn.id);\n\n            if (cellElement) {\n                row.renderCell(cellElement);\n            }\n        }\n    }\n\n    get widgetClass() {}\n\n    //endregion\n};\n", "import '../../Grid/column/TreeColumn.js';\nimport '../../Grid/feature/Tree.js';\nimport '../column/ScaleColumn.js';\nimport '../column/TimeAxisColumn.js';\nimport TimelineHistogramGrouping from './mixin/TimelineHistogramGrouping.js';\nimport '../feature/ColumnLines.js';\nimport '../feature/ScheduleTooltip.js';\nimport TimelineHistogramBase from './TimelineHistogramBase.js';\nimport TimelineHistogramScaleColumn from './mixin/TimelineHistogramScaleColumn.js';\n\n/**\n * @module Scheduler/view/TimelineHistogram\n */\n\n/**\n * This view displays histograms for the provided store records.\n *\n * A {@link Scheduler/column/ScaleColumn} is also added automatically.\n *\n * {@inlineexample Scheduler/view/TimelineHistogram.js}\n *\n * To create a standalone histogram, simply configure it with a {@link Core/data/Store} instance:\n *\n * ```javascript\n * const store = new Store({\n *     data : [\n *         {\n *             id            : 'r1',\n *             name          : 'Record 1',\n *             // data used to render a histogram for this record\n *             histogramData : [\n *                 { value1 : 200, value2 : 100 },\n *                 { value1 : 150, value2 : 50 },\n *                 { value1 : 175, value2 : 50 },\n *                 { value1 : 175, value2 : 75 }\n *             ]\n *         },\n *         {\n *             id            : 'r2',\n *             name          : 'Record 2',\n *             // data used to render a histogram for this record\n *             histogramData : [\n *                 { value1 : 100, value2 : 100 },\n *                 { value1 : 150, value2 : 125 },\n *                 { value1 : 175, value2 : 150 },\n *                 { value1 : 175, value2 : 75 }\n *             ]\n *         }\n *     ]\n * });\n *\n * const histogram = new TimelineHistogram({\n *     appendTo  : 'targetDiv',\n *     startDate : new Date(2022, 11, 26),\n *     endDate   : new Date(2022, 11, 30),\n *     store,\n *     // specify series displayed in the histogram\n *     series : {\n *         value1 : {\n *             type  : 'bar',\n *             field : 'value1'\n *         },\n *         value2 : {\n *             type  : 'bar',\n *             field : 'value2'\n *         }\n *     },\n *     columns : [\n *         {\n *             field : 'name',\n *             text  : 'Name'\n *         }\n *     ]\n * });\n * ```\n *\n * ## Providing histogram data\n *\n * There are two basic ways to provide histogram data:\n *\n * - the data can be provided statically in a record field configured as {@link #config-dataModelField}:\n *\n * ```javascript\n * const store = new Store({\n *     data : [\n *         {\n *             id   : 11,\n *             name : 'John Smith',\n *             // data used to render a histogram for this record\n *             hd   : [\n *                 { weight : 200, price : 100 },\n *                 { weight : 150, price : 105 },\n *                 { weight : 175, price : 90 },\n *                 { weight : 175, price : 95 }\n *             ]\n *         }\n *     ]\n * });\n *\n * const histogram = new TimelineHistogram({\n *     dataModelField : 'hd',\n *     series : {\n *         weight : {\n *             type : 'bar'\n *         },\n *         price : {\n *             type : 'outline'\n *         }\n *     },\n *     ...\n * });\n * ```\n * - the data can be collected dynamically with the provided {@link #config-getRecordData} function:\n *\n * ```javascript\n * const histogram = new TimelineHistogram({\n *     dataModelField : 'hd',\n *     series : {\n *         weight : {\n *             type : 'bar'\n *         },\n *         price : {\n *             type : 'outline'\n *         }\n *     },\n *     ...\n *     async getRecordData(record) {\n *         // we get record histogram data from the server\n *         const response = await fetch('https://some.url/to/get/data?' + new URLSearchParams({\n *             // pass the record identifier and the time span we need data for\n *             record    : record.id,\n *             startDate : DateHelper.format(this.startDate),\n *             endDate   : DateHelper.format(this.endDate),\n *         }));\n *         return response.json();\n *     }\n * });\n * ```\n *\n * Please check [\"Timeline histogram\" guide](#Scheduler/guides/timelinehistogram.md) for more details.\n *\n * @extends Scheduler/view/TimelineHistogramBase\n * @mixes Scheduler/view/mixin/TimelineHistogramGrouping\n * @mixes Scheduler/view/mixin/TimelineHistogramScaleColumn\n * @features Scheduler/feature/ColumnLines\n * @features Scheduler/feature/ScheduleTooltip\n * @classtype timelinehistogram\n * @widget\n */\nexport default class TimelineHistogram extends TimelineHistogramBase.mixin(\n    TimelineHistogramGrouping,\n    TimelineHistogramScaleColumn\n) {\n\n    //region Config\n\n    static $name = 'TimelineHistogram';\n\n    static type = 'timelinehistogram';\n\n    /**\n     * Retrieves the histogram data for the provided record.\n     *\n     * The method first checks if there is cached data for the record and returns it if found.\n     * Otherwise it starts collecting data by calling {@link #config-getRecordData} (if provided)\n     * or by reading it from the {@link #config-dataModelField} record field.\n     *\n     * If the provided record represents a group and {@link #config-aggregateHistogramDataForGroups} is enabled\n     * then the group members data is calculated with a {@link #function-getGroupRecordHistogramData} method call.\n     *\n     * The method can be asynchronous depending on the provided {@link #config-getRecordData} function.\n     * If the function returns a `Promise` then the method will return a wrapping `Promise` in turn that will\n     * resolve with the collected histogram data.\n     *\n     * The method triggers the {@link #event-histogramDataCacheSet} event when a record data is ready.\n     *\n     * @param {Core.data.Model} record Record to retrieve the histogram data for.\n     * @param {Object} [aggregationContext] An optional object passed when the method is called when aggregating\n     * a group members histogram data.\n     *\n     * See {@link #function-getGroupRecordHistogramData} and {@link Core/helper/ArrayHelper#function-aggregate-static}\n     * for more details.\n     * @returns {Object|Promise} The histogram data for the provided record or a `Promise` that will provide the data\n     * when resolved.\n     * @function getRecordHistogramData\n     */\n\n}\n\nTimelineHistogram.initClass();\n"],
  "mappings": "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",
  "names": ["ScaleColumn", "Column", "fields", "defaults", "text", "width", "minWidth", "field", "cellCls", "editor", "sortable", "groupable", "filterable", "alwaysClearCell", "scalePoints", "onDestroy", "scaleWidget", "destroy", "applyValue", "useProp", "key", "value", "arguments", "buildScaleWidget", "me", "Scale", "owner", "grid", "appendTo", "floatRoot", "cls", "align", "monitorResize", "Object", "defineProperties", "get", "set", "element", "style", "_width", "height", "_height", "_scaleWidget", "renderer", "cellElement", "scaleWidgetConfig", "ObjectHelper", "assign", "rowHeight", "refresh", "scaleCloneElement", "cloneNode", "removeAttribute", "classList", "remove", "innerHTML", "appendChild", "__publicField", "$name", "type", "isScaleColumn", "ColumnStore", "registerColumnType", "_$name", "ResourceTimeRangesBase", "InstancePlugin", "mixin", "AttachToProjectMixin", "pluginConfig", "chain", "override", "noFeatureElementsInAxis", "timeAxis", "client", "needsRefresh", "store", "storage", "values", "some", "t", "isTimeSpanInAxis", "doDisable", "disable", "isPainted", "updateTabIndex", "isConfiguring", "getEventsToRender", "resource", "events", "Error", "onEventDataGenerated", "renderData", "eventRecord", "iconCls", "shouldInclude", "isVertical", "resourceRecord", "columnWidth", "resourceColumnWidth", "top", "fillSize", "wrapperCls", "rangeCls", "timeRangeColor", "eventContent", "name", "children", "push", "tabIndex", "String", "length", "unshift", "tag", "className", "toString", "eventId", "generateElementId", "record", "domId", "resolveResourceTimeRangeRecord", "rangeElement", "_rangeElement$closest", "closest", "elementData", "getElementFromResourceTimeRangeRecord", "foregroundCanvas", "syncIdMap", "resolveResourceRecord", "event", "_this$resolveResource", "overridden", "target", "onStoreChange", "action", "onInternalEventStoreChange", "matchScheduleCell", "cell", "enableMouseEvents", "getCell", "isHorizontal", "first", "column", "timeAxisColumn", "handleRangeMouseEvent", "domEvent", "eventName", "EventHelper", "eventNameMap", "StringHelper", "capitalize", "resourceTimeRangeRecord", "trigger", "entityName", "feature", "resourceStore", "getById", "resourceId", "updateEnableMouseEvents", "enable", "_me$mouseEventsDetach", "mouseEventsDetacher", "call", "attachMouseEvents", "on", "delegate", "mousedown", "mouseup", "click", "dblclick", "contextmenu", "mouseover", "mouseout", "thisObj", "whenVisible", "toggle", "Boolean", "configurable", "featureClass", "DependencyEditor", "Popup", "defaultConfig", "items", "draggable", "handleSelector", "axisLock", "processWidgetConfig", "widget", "dependencyEditFeature", "ref", "showLagField", "showDeleteButton", "afterShow", "args", "deleteButton", "widgetMap", "hidden", "isPartOfStore", "onInternalKeyDown", "DependencyEdit", "autoClose", "saveAndCloseOnEnter", "triggerEvent", "dependencyRecord", "editorConfig", "title", "localeClass", "closable", "fromNameField", "weight", "label", "toNameField", "typeField", "editable", "valueField", "displayField", "localizeDisplayFields", "buildItems", "dialog", "parent", "keys", "DependencyModel", "Type", "map", "id", "L", "localeKey", "lagField", "allowNegative", "bbar", "foo", "saveButton", "color", "cancelButton", "construct", "config", "dependencyEdit", "features", "dependencies", "clientListenersDetacher", "ion", "onActivateEditor", "doDestroy", "_this$editor", "changeEditorConfig", "autoShow", "anchor", "scrollAction", "clippedBy", "timeAxisSubGridElement", "bodyContainer", "constrainTo", "globalThis", "isValid", "every", "eachWidget", "onBeforeSave", "onAfterSave", "updateRecord", "lag", "lagUnit", "unit", "magnitude", "fromSide", "toSide", "cleanupProperties", "onPopupKeyDown", "tagName", "toLowerCase", "preventDefault", "onSaveClick", "save", "afterSave", "hide", "onDeleteClick", "deleteDependency", "afterDelete", "onCancelClick", "afterCancel", "internalShowEditor", "getEditor", "loadRecord", "showPoint", "lastPointerDownCoordinate", "center", "Rectangle", "from", "x", "y", "showBy", "editDependency", "readOnly", "_me$saveButton", "_me$deleteButton", "_me$cancelButton", "new", "rootElement", "internalListeners", "keydown", "console", "warn", "dependency", "fromEvent", "toEvent", "Duration", "dependencyStore", "_client$project", "stores", "add", "project", "commitAsync", "_client$project2", "containsFocus", "revertFocus", "disabled", "clientX", "clientY", "GridFeatureManager", "registerFeature", "ScheduleContext", "Delayable", "listeners", "datachange", "timeaxisviewmodelupdate", "presetchange", "timelineContextChange", "schedulecontextmenu", "useBackgroundCanvas", "rowManager", "rowheight", "changeTriggerEvent", "_element", "DomHelper", "createElement", "backgroundCanvas", "onTimelineContextChange", "context", "onScheduleContextGesture", "onTimeAxisViewModelUpdate", "source", "timeAxisViewModel", "_this$context", "includes", "tick", "syncContextElement", "clearContext", "updateContext", "oldContext", "enabled", "row", "rows", "getRowFor", "tickStartDate", "tickEndDate", "currentOrientation", "getTimeSpanRenderData", "startDate", "endDate", "startDateMS", "getTime", "endDateMS", "resourceWidth", "display", "setTranslateXY", "left", "index", "callback", "delayable", "$config", "equal", "c1", "c2", "tickParentIndex", "EventCopyPaste", "CopyPasteBase", "scheduler", "eventClick", "scheduleClick", "projectChange", "clearClipboard", "_cellClickedContext", "attachToEventStore", "eventStore", "_eventClickedContext", "eventData", "assignmentRecord", "meta", "isCut", "onEventClick", "onScheduleClick", "isActionAvailable", "_this$client$features", "_this$client$focusedC", "getSelection", "cellEdit", "isEditing", "focusedCell", "isSpecialRow", "copy", "copyEvents", "cut", "undefined", "paste", "pasteEvents", "records", "selectedAssignments", "splitFrom", "eventCopyPaste", "assignmentRecords", "slice", "isEventModel", "r", "assignments", "flat", "filter", "a", "eventRecords", "writeToClipboard", "refreshWithTransition", "_focusedEventOnCopy", "beforeCopy", "data", "handleCutData", "_me$cutData", "cutData", "assignmentStore", "stringConverter", "eventToStringFields", "Date", "DateHelper", "format", "dateFormat", "join", "setIsCut", "forEach", "assignment", "date", "_clipboardData$assign", "$original", "clipboardData", "readFromClipboard", "toFocus", "pastedEvents", "Set", "pastedEventRecords", "targetResourceRecord", "targetDate", "has", "usesSingleAssignment", "copyPasteAction", "generateNewName", "last", "resources", "newAssignmentRecord", "constraintDate", "detacher", "renderEvent", "navigateTo", "scrollIntoView", "beforePaste", "reason", "allowOverlap", "isDateRangeAvailable", "stringParser", "modifiedRecords", "setFromStringData", "modelClass", "populateEventMenu", "copyEvent", "icon", "onItem", "isAssignmentSelected", "cutEvent", "populateScheduleMenu", "hasClipboardData", "pasteEvent", "count", "originalName", "getValue", "nameField", "counter", "findRecord", "EventDrag", "DragBase", "constrainDragToResource", "constrainDragToTimeSlot", "externalDropTargetSelector", "validatorFn", "validatorFnThisObj", "unifiedDrag", "snapToPosition", "copyKey", "copyMode", "mode", "capitalizedEventName", "afterConstruct", "changeMode", "dragData", "isRecurring", "updateMode", "setCopying", "setMoving", "eventBarCopies", "el", "isConnected", "grabbedParent", "retainElement", "onAfterDragStart", "handleKeyDownOrMove", "keyEventDetacher", "getRootElement", "keyup", "handleKeyUp", "onDragReset", "_this$keyEventDetache", "onDrop", "_this$dragData$eventB", "getDraggableElement", "drag", "targetSelector", "resolveEventRecord", "eventElement", "isElementDraggable", "_client", "matches", "isDraggable", "getTriggerParams", "browserEvent", "triggerBeforeEventDrag", "eventType", "triggerEventDrag", "start", "newResource", "triggerDragStart", "navigator", "skipNextClick", "triggerDragAbort", "triggerDragAbortFinalized", "triggerAfterDrop", "valid", "currentOverClient", "initialAssignmentsState", "find", "i", "_me$dragData$assignme", "setTimeout", "_this$copyKey", "_this$copyKey2", "specialKeyFromEventKey", "isValidDrop", "sourceRecord", "draggedEntities", "constrainDragToTimeline", "checkDragValidity", "_dragData$newResource", "result", "message", "_scheduler$checkEvent", "updateRecords", "fromScheduler", "toScheduler", "copyKeyPressed", "timeDiff", "originalStartDate", "droppedStartDate", "adjustStartDate", "externalDropTarget", "timeSpanInAxis", "durationMS", "suspendAutoCommit", "updateAssignments", "resumeAutoCommit", "isCopy", "targetEventRecord", "isCrossScheduler", "fromAssignmentStore", "fromEventStore", "toAssignmentStore", "toEventStore", "fromResourceStore", "toResourceStore", "fromResource", "toResource", "useSingleAssignment", "effectiveCopyMode", "event1Date", "eventsToAdd", "eventsToRemove", "assignmentsToAdd", "assignmentsToRemove", "eventsToCheck", "eventsToBatch", "resourcesInStore", "getAllDataRecords", "suspendRefresh", "updated", "updatedEvent", "indexDiff", "indexOf", "constainDragToResource", "isGrouped", "draggedEvent", "eventBar", "eventBarEls", "instanceMeta", "hasTemporaryDragElement", "dataset", "transient", "addedEvents", "copiedAssignmentsMap", "originalAssignment", "draggedAssignment", "isOccurrenceAssignment", "splice", "initialState", "originalEventRecord", "originalResourceRecord", "newStartDate", "keepEvent", "newAssignment", "createRecord", "calendar", "reassignedFrom", "draggedEventResourceIndex", "getAt", "_newResource", "newIndex", "Math", "max", "min", "getNext", "getPrevious", "isCrossResource", "setData", "shouldCopyEvent", "endDateCached", "isEvent", "isOccurrence", "ev", "isEqual", "isBatchUpdating", "endBatch", "processEventDrop", "relatedElements", "entries", "originalId", "cloneRecord", "originalDraggedEvent", "inTimeAxis", "isInTimeAxis", "DomSync", "removeChild", "parentElement", "isRoot", "elRect", "setTopLeft", "addChild", "processCrossSchedulerEventDrop", "added", "beginBatch", "Promise", "all", "resumeRefresh", "lastDomConfig", "selectedEvents", "getProductDragContext", "previousResolvedResource", "previousTargetEventRecord", "resolveResource", "isOverNewResource", "dirty", "proxyElements", "getMinimalDragData", "info", "getElementFromContext", "resolveAssignmentRecord", "startEvent", "ctrlKey", "multiEventSelect", "apply", "getRelatedRecords", "setupProductDragData", "_dateConstraints", "dateConstraints", "_me$getDateConstraint", "getDateConstraints", "constrainRectangle", "getConstrainingRectangle", "eventRegion", "setupConstraints", "snapPixelAmount", "eventBarEl", "getElementFromAssignmentRecord", "addTemporaryDragElement", "createProxy", "_scheduler$getDateCon", "externalDateConstraints", "minDate", "maxDate", "end", "dateRange", "getScheduleRegion", "getDragData", "selectedRecord", "getCoordinate", "coord", "milestoneLayoutMode", "isMilestone", "milestoneAlign", "offsetWidth", "offsetHeight", "dragProxy", "pageRect", "localRect", "lx", "ly", "eventTarget", "getMouseMoveEventTarget", "contains", "getRowAt", "dataIndex", "querySelector", "roundDate", "snapRelativeToEventStartDate", "constrainStartDate", "getRecordElement", "getProxyElement", "isDragging", "EventDragCreate", "DragCreateBase", "updateLockLayout", "lock", "dragActiveCls", "handleBeforeDragCreate", "isAvailable", "isWorkingTime", "isSchedulerPro", "ignoreResourceCalendar", "mousedownDate", "dragStart", "_client$onEventCreate", "enableEventAnimations", "enableTransactionalFeatures", "createEventRecord", "resourceRecords", "diff", "durationUnit", "isCreating", "isDragCreating", "taskEdit", "doCancel", "captureStm", "assignEventToResource", "lockLayout", "excludeFromLayout", "onEventCreated", "addAsync", "then", "refreshRows", "itemElement", "getElementFromEventRecord", "isInView", "scrollable", "animate", "edgeOffset", "barMargin", "checkValidity", "dragging", "createValidatorFn", "isRowEmpty", "getEventsForResource", "triggerBeforeFinalize", "dimension", "weekStartDay", "draggingEnd", "eventConfig", "fieldMap", "defaultValue", "floor", "resolution", "ceil", "isGanttProjectMixin", "constraintType", "internalUpdateRecord", "hasEventEditor", "finalizeDragCreate", "transferred", "hasStmCapture", "freeStm", "cancelDragCreate", "getTipHtml", "html", "tip", "tooNarrow", "onAborted", "_this$store$unassignE", "_this$store", "unassignEventFromResource", "zeroOffset", "depOffset", "EventTooltip", "TooltipBase", "template", "xss", "startClockHtml", "endClockHtml", "monitorRecordUpdate", "onPaint", "firstPaint", "tooltip", "beforeAlign", "offset", "edgeAligned", "parseAlign", "depTerminalOffset", "zeroMargins", "StickyEvents", "toUpdate", "scroll", "horizontalScroll", "prio", "stickyContents", "syncEventContentPosition", "updateStyles", "onSchedulerScroll", "verticalSyncAllEventsContentPosition", "onHorizontalScroll", "subGrid", "timeAxisSubGrid", "contentEl", "applyStyle", "clear", "resourceMap", "eventsData", "elementConfig", "isResourceTimeRange", "size", "duringGeneration", "useEventBuffer", "bufferAfterWidth", "bufferBeforeWidth", "scrollPosition", "wrapperEl", "getChild", "parseStyle", "contentSize", "contentWidth", "justify", "parentNode", "getStyleValue", "c", "eventStart", "eventEnd", "edgeSizes", "getEventContentMargins", "maxOffset", "Number", "MAX_SAFE_INTEGER", "transform", "stuck", "getEdgeSize", "TimeRanges", "AbstractTimeRanges", "_this$storeDetacher", "storeDetacher", "timeRanges", "_timeRanges", "recurringEvents", "flatMap", "timeSpan", "getOccurrencesForDateRange", "currentTimeLine", "attachToProject", "_me$projectTimeZoneCh", "projectTimeZoneChangeDetacher", "showCurrentTimeLine", "_me$client$project", "timeZoneChange", "updateCurrentTimeLine", "initCurrentTimeLine", "currentTimeInterval", "setInterval", "currentTimeLineUpdateInterval", "_me$project", "timeZone", "setLocalDate", "originalData", "currentDateFormat", "renderRanges", "hideCurrentTimeLine", "clearInterval", "updateShowCurrentTimeLine", "show", "populateTimeAxisHeaderMenu", "checked", "onToggle", "attachToStore", "change", "timeRangeStore", "updateStore", "_timeRangesExposed", "attachToTimeRangeStore", "resolveTimeRangeRecord", "baseSelector", "isVisible", "runWithTransition", "refreshSuspended", "onDragStart", "rangeBodyEl", "getBodyElementByRecord", "originRangeX", "getTranslateX", "originRangeY", "getTranslateY", "showTip", "onInvalidDrop", "box", "newStart", "getDateFromCoordinate", "getStart", "rtl", "setStartDate", "destroyTip", "onResizeStart", "onResizeDrag", "startPos", "endPos", "getEnd", "edge", "setTranslateY", "newY", "newHeight", "setTranslateX", "newX", "newWidth", "updateDateIndicator", "onResize", "isStart", "newEnd", "setEndDate", "onInvalidResize", "resize", "reset", "TimeSpan", "DelayedRecordsRendering", "Target", "_a", "Base", "properties", "recordsToRefresh", "beforeRenderRow", "_this$recordIsReadyFo", "recordIsReadyForRendering", "unscheduleRecordRefresh", "cleanupScheduledRecord", "getRowById", "delete", "renderScheduledRecords", "scheduleRecordRefresh", "renderRows", "clearRecords", "ArrayHelper", "asArray", "scheduledRecordsRefreshTimer", "clearTimeout", "fn", "delay", "scheduledRecordsRefreshTimeout", "cancelOutstanding", "widgetClass", "TimelineHistogramRendering", "init", "updateFromHorizontalScroll", "scrollX", "scrollBuffer", "totalSize", "returnEnd", "maxX", "abs", "round", "getDateFromCoord", "ignoreRTL", "_viewPresetChanging", "_visibleDateRange", "startMS", "endMS", "viewportCoords", "right", "range", "timeView", "onVisibleDateRangeChange", "_timeAxisStartDate", "_timeAxisEndDate", "onViewportResize", "visibleDateRange", "translateToPageCoordinate", "getBoundingClientRect", "scrollLeft", "translateToScheduleCoordinate", "getDateFromXY", "xy", "roundingMethod", "local", "allowOutOfRange", "getRtlX", "getDateFromPosition", "histogramWidgetCleanState", "series", "topValue", "emptyFn", "TimelineHistogramBase", "TimelineBase", "histogramDataByRecord", "Map", "collectingDataFor", "updateGetRecordData", "_getRecordData", "resolveCallback", "updateHardRefreshOnTimeAxisReconfigure", "endReconfigure", "detachListeners", "scheduleRefreshRows", "createOnFrame", "beforeRowHeight", "_this$_histogramWidge", "clearHistogramDataCache", "_histogramWidget", "barTooltip", "resolveTimeSpanRecord", "getScheduleMouseEventParams", "cellData", "_currentOrientation", "updateSeries", "histogramWidget", "_series", "getAsyncEventSuffixForStore", "isAbstractPartOfProjectStoreMixin", "getRowHeight", "showBarTip", "updateGetBarTip", "barTooltipTemplate", "changeBarTooltip", "oldTooltip", "isTooltip", "barTooltipClass", "forElement", "forSelector", "hoverDelay", "trackMouse", "getHtml", "bind", "activeTarget", "parseInt", "getRecordFromElement", "histogramData", "getRecordHistogramData", "datum", "extractHistogramDataArray", "collectTicksWidth", "ticks", "prevDuration", "tickDurations", "totalDuration", "isMonotonous", "duration", "ticksWidth", "changeHistogramWidget", "isHistogram", "_me$timeAxisColumn", "getBarTextRenderData", "histogramWidgetClass", "getBarTip", "getRectClass", "getRectClassDefault", "getBarText", "getBarTextDefault", "getOutlineClass", "getRectConfig", "rectConfig", "updateShowBarTip", "columns", "isDestroying", "histogramRenderer", "timeAxisColumnCellCls", "onHistogramDataCacheSet", "onTimeAxisEndReconfigure", "hardRefreshOnTimeAxisReconfigure", "onStoreUpdateRecord", "changes", "getRecordData", "dataModelField", "onStoreRemove", "onBeforeRowHeight", "_timeAxisColumn", "onElementResize", "processRecordRenderData", "setHistogramDataCache", "getHistogramDataCache", "hasHistogramDataCache", "finalizeDataRetrievingInternal", "finalizeDataRetrieving", "Objects", "isPromise", "handler", "histogramConfig", "merge", "initialConfig", "oldId", "recordIndex", "_recordRenderData", "applyHistogramWidgetConfig", "renderRecordHistogram", "histogramCloneElement", "buildGroupHeader", "group", "Tooltip", "Histogram", "omitZeroHeightBars", "fixedRowHeight", "initClass", "TimelineHistogramGrouping", "afterConfigure", "internalAggregateDataEntry", "internalInitAggregatedDataEntry", "treeGroup", "beforeDataLoad", "onTreeGroupBeforeDataLoad", "updateAggregateFunctions", "aliases", "alias", "onStoreGroup", "changeAggregateDataEntry", "bindCallback", "changeGetDataEntryForAggregating", "changeInitAggregatedDataEntry", "aggregateHistogramDataForGroups", "scheduleRecordParentsRefresh", "resetGeneratedRecordsHistogramDataCache", "aggregationContext", "isGroupRecord", "getGroupRecordHistogramData", "acc", "aggregateFunctions", "aggregate", "entry", "aggregateDataEntry", "initAggregatedDataEntry", "isGroupHeader", "generatedParent", "isLinked", "$links", "link", "parentRecord", "aggregateRecordsHistogramData", "getGroupChildren", "res", "recordsData", "hasPromise", "child", "childData", "aggregateHistogramData", "isTreeGrouped", "groupChildren", "getRecordParent", "groupParent", "clearCache", "arrays", "getDataEntryForAggregating", "finalize", "sum", "seriesId", "entryValue", "MAX_VALUE", "MIN_VALUE", "entryIndex", "avg", "cnt", "TimelineHistogramScaleColumn", "updateScalePoints", "topScalePoint", "scaleUnit", "getTopValueByScalePoints", "scaleColumn", "changeColumns", "currentStore", "getConfig", "_cols", "isArray", "Array", "cols", "scaleColumnIndex", "scaleColumnConfig", "col", "updateColumns", "was", "_scaleColumn", "onColumnsChanged", "convertUnitsToHistogramValue", "convertHistogramValueToUnits", "lastPoint", "rawValue", "scaleMaxPadding", "_me$initialConfig$his", "scalePointsModelField", "calculateTopValueByScalePoints", "getDataTopValue", "beforeRenderCell", "renderRecordScale", "renderCell", "TimelineHistogram"]
}
