{
  "version": 3,
  "sources": ["../../../Grid/lib/Grid/column/ActionColumn.js", "../../../Grid/lib/Grid/column/AggregateColumn.js", "../../../Grid/lib/Grid/column/PercentColumn.js", "../../../Grid/lib/Grid/column/RatingColumn.js", "../../../Grid/lib/Grid/column/TemplateColumn.js", "../../../Grid/lib/Grid/column/TimeColumn.js", "../../../Grid/lib/Grid/feature/CellCopyPaste.js", "../../../Grid/lib/Grid/feature/CellTooltip.js", "../../../Grid/lib/Grid/feature/ColumnRename.js", "../../../Grid/lib/Grid/feature/FillHandle.js", "../../../Grid/lib/Grid/feature/MergeCells.js", "../../../Grid/lib/Grid/feature/QuickFind.js", "../../../Grid/lib/Grid/feature/RowExpander.js", "../../../Grid/lib/Grid/feature/Search.js", "../../../Grid/lib/Grid/feature/StickyCells.js", "../../../Grid/lib/Grid/feature/experimental/FileDrop.js", "../../../Grid/lib/Grid/widget/GroupBar.js", "../../../Grid/lib/Grid/widget/TreeCombo.js", "../../../Grid/bundle/entry.thin.js"],
  "sourcesContent": ["import Column from './Column.js';\nimport ColumnStore from '../data/ColumnStore.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\n\n/**\n * @module Grid/column/ActionColumn\n */\n\n/**\n * Config object for an action in an ActionColumn.\n * @typedef {Object} ActionConfig\n * @property {String} cls CSS Class for action icon\n * @property {Function|String|TooltipConfig} tooltip Tooltip text, or a config object which can reconfigure the shared\n * tooltip by setting boolean, numeric and string config values, or a function to return the tooltip text, passed the\n * row's `record`\n * @property {Function|Boolean} visible Boolean to define the action icon visibility or a callback function, passed the\n * row's `record`, to change it dynamically\n * @property {Function} onClick Callback to handle click action item event, passed the row's `record`\n * @property {Boolean} showForGroup Set to true to have action icon visible in group headers only when using the `group`\n * feature\n * @property {Function|String} renderer A render function, or the name of a function in the Grid's ownership tree used\n * to define the action element. Passed the row's `record`, expected to return an HTML string or a DOM config object.\n * **Note**: when specified, the `cls` action config is ignored. Make sure you add an action icon manually, for example:\n * ```javascript\n * {\n *      type    : 'action',\n *      text    : 'Increase amount',\n *      actions : [{\n *          cls      : 'b-fa b-fa-plus', // this line will be ignored\n *          renderer : ({ record }) => '<i class=\"b-action-item b-fa b-fa-plus\"></i> ' + record.name,\n *          onClick  : ({ record }) => {}\n *      }]\n * }\n * ```\n *\n * or\n *\n * ```javascript\n * {\n *      type    : 'action',\n *      text    : 'Increase amount',\n *      actions : [{\n *          cls      : 'b-fa b-fa-plus', // this line will be ignored\n *          renderer : 'up.renderAction' // Defined on the Grid\n *          onClick  : ({ record }) => {}\n *      }]\n * }\n * ```\n */\n\n/**\n * A column that displays actions as clickable icons in the cell.\n *\n * {@inlineexample Grid/column/ActionColumn.js}\n *\n * ```javascript\n * new TreeGrid({\n *     appendTo : document.body,\n *     columns  : [{\n *         type    : 'action',\n *         text    : 'Increase amount',\n *         actions : [{\n *             cls      : 'b-fa b-fa-plus',\n *             renderer : ({ action, record }) => `<i class=\"b-action-item ${action.cls} b-${record.enabled ? \"green\" : \"red\"}-class\"></i>`,\n *             visible  : ({ record }) => record.canAdd,\n *             tooltip  : ({ record }) => `<p class=\"b-nicer-than-default\">Add to ${record.name}</p>`,\n *             onClick  : ({ record }) => console.log(`Adding ${record.name}`)\n *         }, {\n *             cls     : 'b-fa b-fa-pencil',\n *             tooltip : 'Edit note',\n *             onClick : ({ record }) => console.log(`Editing ${record.name}`)\n *         }]\n *     }]\n * });\n * ```\n *\n * Actions may be placed in {@link Grid/feature/Group} headers, by setting `action.showForGroup` to `true`. Those\n * actions will not be shown on normal rows.\n *\n * @extends Grid/column/Column\n * @classType action\n * @column\n */\nexport default class ActionColumn extends Column {\n\n    static type = 'action';\n\n    static fields = [\n        /**\n         * An array of action config objects, see {@link #typedef-ActionConfig} for details.\n         *\n         * ```javascript\n         * new Grid({\n         *     columns  : [{\n         *         type    : 'action',\n         *         text    : 'Actions',\n         *         actions : [{\n         *             cls      : 'b-fa b-fa-plus',\n         *             visible  : ({ record }) => record.canAdd,\n         *             onClick  : ({ record }) => console.log(`Adding ${record.name}`)\n         *         }, {\n         *             cls     : 'b-fa b-fa-pencil',\n         *             tooltip : 'Edit note',\n         *             onClick : ({ record }) => console.log(`Editing ${record.name}`)\n         *         }]\n         *     }]\n         * });\n         * ```\n         *\n         * @config {ActionConfig[]} actions List of action configs\n         * @category Common\n         */\n        { name : 'actions', type : 'array' },\n\n        /**\n         * Set true to hide disable actions in this column if the grid is {@link Core.widget.Widget#config-readOnly}\n         * @config {Boolean} disableIfGridReadOnly\n         * @default\n         * @category Common\n         */\n        { name : 'disableIfGridReadOnly', defaultValue : false }\n    ];\n\n    static defaults = {\n        /**\n         * Filtering by action column is not supported by default, because it has a custom renderer and uses HTML with icons as content.\n         * @config {Boolean} filterable\n         * @default false\n         * @category Interaction\n         * @hide\n         */\n        filterable : false,\n\n        /**\n         * Grouping by action column is not supported by default, because it has a custom renderer and uses HTML with icons as content.\n         * @config {Boolean} groupable\n         * @default false\n         * @category Interaction\n         * @hide\n         */\n        groupable : false,\n\n        /**\n         * Sorting by action column is not supported by default, because it has a custom renderer and uses HTML with icons as content.\n         * @config {Boolean} sortable\n         * @default false\n         * @category Interaction\n         * @hide\n         */\n        sortable : false,\n\n        /**\n         * Editor for action column is not supported by default, because it has a custom renderer and uses HTML with icons as content.\n         * @config {Boolean} editor\n         * @default false\n         * @category Interaction\n         * @hide\n         */\n        editor : false,\n\n        /**\n         * Searching by action column is not supported by default, because it has a custom renderer and uses HTML with icons as content.\n         * @config {Boolean} searchable\n         * @default false\n         * @category Interaction\n         * @hide\n         */\n        searchable : false,\n\n        /**\n         * By default, for action column this flag is switched to `true`, because the content of this column is always HTML.\n         * @config {Boolean} htmlEncode\n         * @default false\n         * @category Misc\n         * @hide\n         */\n        htmlEncode : false,\n\n        /**\n         * Set to `true` to allow the column to being drag-resized when the ColumnResize plugin is enabled.\n         * @config {Boolean} resizable\n         * @default false\n         * @category Interaction\n         */\n        resizable : false,\n\n        /**\n         * Column minimal width. If value is Number then minimal width is in pixels.\n         * @config {Number|String} minWidth\n         * @default 30\n         * @category Layout\n         */\n        minWidth : 30\n    };\n\n    get groupHeaderReserved() {\n        return true;\n    }\n\n    construct(config, store) {\n        const me = this;\n\n        super.construct(...arguments);\n\n        // use auto-size only as default behaviour\n        if (!config.width && !config.flex) {\n            me.grid.ion({ paint : 'updateAutoWidth', thisObj : me });\n        }\n\n        if (me.disableIfGridReadOnly) {\n            me.grid.element.classList.add('b-actioncolumn-readonly');\n        }\n\n        // If column is cloned, renderer is already set up\n        if (me.renderer !== me.internalRenderer) {\n            me.externalRenderer = me.renderer;\n            me.renderer = me.internalRenderer;\n        }\n    }\n\n    /**\n     * Renderer that displays action icon(s) in the cell.\n     * @private\n     */\n    internalRenderer({ grid, column, record, callExternalRenderer = true }) {\n        const\n            inGroupTitle = record && ('groupRowFor' in record.meta),\n            { subGrid }  = column;\n\n        if (callExternalRenderer) {\n            this.externalRenderer?.(...arguments);\n        }\n\n        return {\n            className : { 'b-action-ct' : 1 },\n            children  : column.actions?.map((actionConfig, index) => {\n                if ('visible' in actionConfig) {\n                    if ((typeof actionConfig.visible === 'function') && actionConfig.visible({ record }) === false) {\n                        return '';\n                    }\n                    if (actionConfig.visible === false) {\n                        return '';\n                    }\n                }\n\n                // check if an action allowed to be shown in case of using grouping\n                if ((inGroupTitle && !actionConfig.showForGroup) || (!inGroupTitle && actionConfig.showForGroup)) {\n                    return '';\n                }\n\n                const\n                    {\n                        tooltip,\n                        renderer\n                    }    = actionConfig,\n                    btip = (typeof tooltip === 'function' || tooltip?.startsWith?.('up.')) ? subGrid.callback(tooltip, subGrid, [{ record }]) : tooltip || '';\n\n                // handle custom renderer if it is specified\n                if (renderer) {\n                    const customRendererData = subGrid.callback(renderer, subGrid, [{\n                        index,\n                        record,\n                        column,\n                        tooltip : btip,\n                        action  : actionConfig\n                    }]);\n\n                    // take of set data-index to make onClick handler work stable\n                    if (typeof customRendererData === 'string') {\n                        return {\n                            tag     : 'span',\n                            dataset : {\n                                ...Tooltip.encodeConfig(btip),\n                                index\n                            },\n                            html : customRendererData\n                        };\n                    }\n                    else {\n                        customRendererData.dataset = customRendererData.dataset || {};\n                        customRendererData.dataset.index = index;\n                        return customRendererData;\n                    }\n                }\n                else {\n                    return {\n                        tag     : 'button',\n                        dataset : {\n                            ...Tooltip.encodeConfig(btip),\n                            index\n                        },\n                        'aria-label' : btip,\n                        className    : {\n                            'b-tool'           : 1,\n                            'b-action-item'    : 1,\n                            [actionConfig.cls] : actionConfig.cls\n                        }\n                    };\n                }\n            })\n        };\n    }\n\n    /**\n     * Handle icon click and call action handler.\n     * @private\n     */\n    onCellClick({ column, record, target }) {\n        if (column !== this || !target.classList.contains('b-action-item')) {\n            return;\n        }\n\n        let actionIndex = target.dataset.index;\n        // index may be set in a parent node if user used an html string in his custom renderer\n        // and we take care to set this property to support onClick handler\n        if (!actionIndex) {\n            actionIndex = target.parentElement.dataset && target.parentElement.dataset.index;\n        }\n\n        const\n            action        = column.actions?.[actionIndex],\n            actionHandler = action?.onClick;\n\n        if (actionHandler) {\n            this.callback(actionHandler, column, [{ record, action, target }]);\n        }\n    }\n\n    /**\n     * Update width for actions column to fit content.\n     * @private\n     */\n    updateAutoWidth() {\n        const\n            me           = this,\n            groupActions = [],\n            {\n                actions : oldActions\n            }            = me;\n\n        // header may be disabled, in that case we won't be able to calculate the width properly\n        if (!me.element) {\n            return;\n        }\n\n        const actions = me.actions = [];\n\n        // collect group and non group actions to check length later\n        oldActions?.forEach(actionOriginal => {\n            const action = { ...actionOriginal };\n\n            // remove possible visibility condition to make sure an action will exists in test HTML\n            delete action.visible;\n            // group actions shows in different row and never together with non group\n            if (action.showForGroup) {\n                delete action.showForGroup;\n                groupActions.push(action);\n            }\n            else {\n                actions.push(action);\n            }\n        });\n\n        // use longest actions length to calculate column width\n        if (groupActions.length > actions.length) {\n            me._actions = groupActions;\n        }\n\n        const actionsHtml = DomHelper.createElement(me.internalRenderer({ column : me, callExternalRenderer : false })).outerHTML;\n\n        me.width = DomHelper.measureText(actionsHtml, me.element, true, me.element.parentElement);\n        me.actions = oldActions;\n    }\n}\n\nColumnStore.registerColumnType(ActionColumn);\nActionColumn.exposeProperties();\n", "import ColumnStore from '../data/ColumnStore.js';\nimport NumberColumn from './NumberColumn.js';\n\n/**\n * @module Grid/column/AggregateColumn\n */\n\n/**\n * A column, which, when used as part of a {@link Grid.view.TreeGrid}, aggregates the values of this column's descendants using\n * a configured function which defaults to `sum`. The aggregate value is re-calculated after any change to the data,\n * and if you want aggregate values to be change-tracked, please set {@link #config-includeParentInChangeSet} to true.\n *\n * Default editor depends on the data field type. If it is a number, default editor is a {@link Core/widget/NumberField}.\n * Otherwise Default editor is a {@link Core/widget/TextField}.\n *\n * ```javascript\n * const grid = new TreeGrid({\n *     // Custom aggregation handler.\n *     // For test purposes, this just does \"sum\"\n *     myAggregator(...values) {\n *         let result = 0;\n *\n *         for (let i = 0, { length } = values; i < length; i++) {\n *             result += parseInt(args[i], 10);\n *         }\n *         return result;\n *     },\n *     columns : [\n *         { field : 'name', text : 'Name' },\n *\n *         // Will sum the ages of leaf nodes. This is the default.\n *         { type : 'aggregate', field : 'age', text : 'Age', renderer : ({ value }) => `<b>${value}<b>` },\n *\n *         // Will use AggregateColumn's built-in avg of scores of leaf nodes\n *         { type : 'aggregate', field : 'score', text : 'Score', function : 'avg' },\n *\n *         // Will use the grid's myAggregator function\n *         { type : 'aggregate', field : 'revenue', text : 'Revenue', function : 'up.myAggregator' },\n *     ]\n * });\n * ```\n *\n * @extends Grid/column/NumberColumn\n * @classType aggregate\n * @column\n */\nexport default class AggregateColumn extends NumberColumn {\n    //region Config\n\n    static type = 'aggregate';\n\n    static fields = [\n        'function',\n        'includeParentInChangeSet'\n    ];\n\n    static get defaults() {\n        return {\n            /**\n             * Math Function name, or function name prepended by `\"up.\"` that is resolvable in an\n             * ancestor component (such as the owning Grid, or a height Container), or a function to\n             * use to aggregate child record values for this column, or a function.\n             *\n             * This Column is provided with a `sum` and `avg` function. The default function is `sum`\n             * which is used for the aggregation.\n             *\n             * The function is passed a set of child node values, each value in a separate argument\n             * and should return a single value based upon the value set passed.\n             * @config {'sum'|'avg'|'min'|'max'|Function}\n             * @category Common\n             */\n            function : 'sum',\n\n            /**\n             * Set to `true` to include changes to parent (aggregate) rows in the store's modification tracking.\n             * @config {Boolean} includeParentInChangeSet\n             * @category Common\n             */\n            includeParentInChangeSet : false\n        };\n    }\n\n    construct(data, columnStore) {\n        const me = this;\n        me.configuredAlign = 'align' in data;\n        me.configuredEditor = 'editor' in data;\n\n        super.construct(...arguments);\n\n        const { grid } = columnStore;\n\n        // 'sum' is reserved by Summary feature, so we use a different name\n        if (me.function === 'sum') {\n            me.function = 'sumChildren';\n        }\n\n        if (grid) {\n            me.store = grid.store;\n        }\n    }\n\n    set store(store) {\n        const\n            me             = this,\n            storeListeners = {\n                update  : 'onRecordUpdate',\n                thisObj : me,\n                prio    : 1000\n            },\n            oldStore = me._store;\n\n        if (store !== oldStore) {\n            if (oldStore) {\n                oldStore.un(storeListeners);\n            }\n\n            me._store = store;\n\n            const\n                { modelClass } = store,\n                field = modelClass.fieldMap[me.field];\n\n            // It's *likely*, but not certain that this will be used for a numeric field.\n            // Use numeric defaults unless configured otherwise if so.\n            if (field && field.type === 'number') {\n                if (!me.configuredAlign) {\n                    me.align = 'end';\n                }\n                if (!me.configuredEditor) {\n                    me.editor = 'number';\n                }\n            }\n\n            store.ion(storeListeners);\n        }\n    }\n\n    canEdit(record) {\n        return record.isLeaf;\n    }\n\n    get store() {\n        return this._store;\n    }\n\n    sumChildren(...args) {\n        let result = 0;\n\n        for (let i = 0, { length } = args; i < length; i++) {\n            result += parseFloat(args[i] || 0, 10);\n        }\n        return result;\n    }\n\n    avg(...args) {\n        let result = 0;\n        const { length } = args;\n\n        for (let i = 0; i < length; i++) {\n            result += parseFloat(args[i] || 0, 10);\n        }\n        return result / length;\n    }\n\n    onRecordUpdate({ record, changes }) {\n        const\n            me = this,\n            { rowManager } = me.grid;\n\n        if (me.field in changes) {\n            if (record.isLeaf) {\n                record.bubble(rec => {\n                    const row = rowManager.getRowFor(rec);\n\n                    if (row) {\n                        const cellElement = row.getCell(me.field);\n\n                        if (cellElement) {\n                            row.renderCell(cellElement);\n                        }\n                    }\n                }, true);\n            }\n        }\n    }\n\n    getRawValue(record) {\n        let value;\n\n        const\n            me        = this,\n            { field } = me;\n\n        if (record.children?.length) {\n            const\n                fn       = me.function,\n                isMathFn = typeof fn === 'string' && typeof Math[fn] === 'function',\n                {\n                    handler,\n                    thisObj\n                } = isMathFn ? {\n                    handler : Math[fn],\n                    thisObj : Math\n                } : me.resolveCallback(fn);\n\n            // Gather all child node values before passing them to the aggregator function.\n            value = handler.apply(thisObj, record.children.map(r => me.getRawValue(r)));\n            if (me.includeParentInChangeSet) {\n                record.set(field, value, true);\n            }\n            else {\n                record.setData(field, value);\n            }\n        }\n        else {\n            value = record.getValue(field);\n        }\n        return value;\n    }\n\n    canFillValue() {\n        return false;\n    }\n}\n\nColumnStore.registerColumnType(AggregateColumn, true);\nAggregateColumn.exposeProperties();\n", "import NumberColumn from './NumberColumn.js';\nimport ColumnStore from '../data/ColumnStore.js';\n\n/**\n * @module Grid/column/PercentColumn\n */\n\n/**\n * A column that display a basic progress bar.\n *\n * {@inlineexample Grid/column/PercentColumn.js}\n *\n * ```javascript\n * new Grid({\n *     appendTo : document.body,\n *\n *     columns : [\n *         { type: 'percent', text: 'Progress', data: 'progress' }\n *     ]\n * });\n * ```\n *\n * Default editor is a {@link Core.widget.NumberField NumberField}.\n *\n * @extends Grid/column/NumberColumn\n * @classType percent\n * @column\n */\nexport default class PercentColumn extends NumberColumn {\n\n    static type = 'percent';\n\n    // Type to use when auto adding field\n    static fieldType = 'number';\n\n    static fields = ['showValue', 'lowThreshold'];\n\n    static get defaults() {\n        return {\n            min : 0,\n            max : 100,\n\n            /**\n             * Set to `true` to render the number value inside the bar, for example `'15%'`.\n             * @config {Boolean}\n             * @default\n             * @category Rendering\n             */\n            showValue : false,\n\n            /**\n             * When below this percentage the bar will have `b-low` CSS class added. By default it turns the bar red.\n             * @config {Number}\n             * @default\n             * @category Rendering\n             */\n            lowThreshold : 20,\n\n            htmlEncode      : false,\n            searchable      : false,\n            summaryRenderer : ({ sum }) => `${sum}%`,\n            fitMode         : false\n        };\n    }\n\n    constructor(config, store) {\n        super(...arguments);\n\n        this.internalCellCls = 'b-percent-bar-cell';\n    }\n\n    /**\n     * Renderer that displays a progress bar in the cell. If you create a custom renderer, and want to include the\n     * default markup you can call `defaultRenderer` from it.\n     *\n     * ```javascript\n     * new Grid({\n     *     columns: [\n     *         {\n     *             type: 'percent',\n     *             text : 'Percent',\n     *             field : 'percent',\n     *             renderer({ value }) {\n     *                 const domConfig = this.defaultRenderer();\n     *\n     *                 if (value > 100) {\n     *                     domConfig.className = b-percent-bar-outer over-allocated';\n     *                 }\n     *\n     *                 return domConfig;\n     *             }\n     *         }\n     *     ]\n     * }\n     * ```\n     *\n     * @param {Object} rendererData The data object passed to the renderer\n     * @param {Number} rendererData.value The value to display\n     * @returns {DomConfig} DomConfig object representing the default markup for the cells content\n     */\n    defaultRenderer({ value }) {\n        value = value || 0;\n\n        return {\n            className       : 'b-percent-bar-outer',\n            role            : 'progressbar',\n            'aria-Valuemin' : 0,\n            'aria-Valuemax' : 100,\n            'aria-Valuenow' : value,\n            tabIndex        : 0,\n            children        : [\n                {\n                    tag       : 'div',\n                    className : {\n                        'b-percent-bar' : 1,\n                        'b-zero'        : value === 0,\n                        'b-low'         : value < this.lowThreshold\n                    },\n                    style : {\n                        width : value + '%'\n                    },\n                    children : [\n                        this.showValue ? {\n                            tag  : 'span',\n                            text : value + '%'\n                        } : undefined\n                    ]\n                }\n            ]\n        };\n    }\n\n    // Null implementation because the column width drives the width of its content.\n    // So the concept of sizing to content is invalid here.\n    resizeToFitContent() {}\n}\n\nPercentColumn.sum = 'average';\n\nColumnStore.registerColumnType(PercentColumn, true);\n", "import NumberColumn from './NumberColumn.js';\nimport ColumnStore from '../data/ColumnStore.js';\nimport ArrayHelper from '../../Core/helper/ArrayHelper.js';\n\n/**\n * @module Grid/column/RatingColumn\n */\n\n/**\n * A column that displays a star rating. Click a start to set a value, shift+click to unset a single start from the end.\n * Clicking the first and only star toggles it.\n *\n * This column uses a custom widget as its editor, and it is not intended to be changed.\n *\n * @extends Grid/column/NumberColumn\n *\n * @example\n * new Grid({\n *     appendTo : document.body,\n *\n *     columns : [\n *         { type: 'rating', max : 10, field: 'rating' }\n *     ]\n * });\n *\n * @classType rating\n * @inlineexample Grid/column/RatingColumn.js\n * @column\n */\nexport default class RatingColumn extends NumberColumn {\n\n    // <debug>\n    // region Localization test\n    static localization = [\n        'L{Column.cellLabel}'\n    ];\n    // endregion\n    // </debug>\n\n    static $name = 'RatingColumn';\n\n    static type = 'rating';\n\n    // Type to use when auto adding field\n    static fieldType = 'number';\n\n    static fields = ['emptyIcon', 'filledIcon', 'editable'];\n\n    static get defaults() {\n        return {\n            min : 0,\n            max : 5,\n\n            /**\n             * The empty rating icon to show\n             * @config {String}\n             * @category Rendering\n             */\n            emptyIcon : 'b-icon b-icon-star',\n\n            /**\n             * The filled rating icon to show\n             * @config {String}\n             * @category Rendering\n             */\n            filledIcon : 'b-icon b-icon-star',\n\n            /**\n             * Allow user to click an icon to change the value\n             * @config {Boolean}\n             * @category Interaction\n             */\n            editable : true,\n\n            filterType : 'number',\n            searchable : false,\n            width      : '11.2em',\n            htmlEncode : false,\n            minWidth   : '11.2em',\n            editor     : false,\n            fitMode    : 'value'\n        };\n    }\n\n    /**\n     * Renderer that displays a number of stars in the cell. Also adds CSS class 'b-rating-cell' to the cell.\n     * @private\n     */\n    renderer({ value }) {\n        return {\n            className : {\n                'b-rating-cell-inner' : 1,\n                'b-not-editable'      : !this.editable\n            },\n            children : ArrayHelper.populate(this.max, i => {\n                const filled = i < value;\n                return {\n                    tag       : 'i',\n                    className : {\n                        'b-rating-icon'                             : true,\n                        'b-filled'                                  : filled,\n                        'b-empty'                                   : !filled,\n                        [filled ? this.filledIcon : this.emptyIcon] : true\n                    }\n                };\n            })\n        };\n    }\n\n    onCellClick({ grid, column, record, target, event }) {\n        if (target.classList.contains('b-rating-icon') && !grid.readOnly && column.editable) {\n            let starIndex = [].indexOf.call(target.parentNode.childNodes, target);\n\n            if (target.classList.contains('b-filled') && (event.metaKey || event.shiftKey)) {\n                starIndex = starIndex - 1;\n            }\n\n            // Clicking first star when it is only one removes it\n            if (record.getValue(column.field) === 1 && starIndex === 0) {\n                starIndex = -1;\n            }\n\n            record.set(column.field, starIndex + 1);\n        }\n    }\n}\n\nColumnStore.registerColumnType(RatingColumn, true);\nRatingColumn.exposeProperties();\n", "import Column from './Column.js';\nimport ColumnStore from '../data/ColumnStore.js';\n\n/**\n * @module Grid/column/TemplateColumn\n */\n\n/**\n * A column that uses a template for cell content. Any function can be used as template, and the function is passed { value, record, field } properties.\n * It should return a string which will be rendered in the cell.\n *\n * Default editor is a {@link Core.widget.TextField TextField}.\n *\n * @extends Grid/column/Column\n *\n * @example\n * new Grid({\n *     appendTo : document.body,\n *\n *     columns : [\n *         { type: 'template', field: 'age', template: ({value}) => `${value} years old` }\n *     ]\n * });\n *\n * @classType template\n * @inlineexample Grid/column/TemplateColumn.js\n * @column\n */\nexport default class TemplateColumn extends Column {\n\n    static type = 'template';\n\n    static fields = [\n        /**\n         * Template function used to generate a value displayed in the cell. Called with arguments `{ value, record, field }`\n         * @config {Function} template\n         * @param {Object} data An object that contains data about the cell being rendered.\n         * @param {*} data.value The value (only present when you set a `field` on the column)\n         * @param {Core.data.Model} data.record The record representing the row\n         * @param {String} data.field The column field name\n         * @category Common\n         */\n        'template'\n    ];\n\n    static get defaults() {\n        return {\n            htmlEncode : false\n        };\n    }\n\n    constructor(config, store) {\n        super(...arguments);\n\n        const me = this;\n\n        if (!me.template) {\n            throw new Error('TemplateColumn needs a template');\n        }\n\n        if (typeof me.template !== 'function') {\n            throw new Error('TemplateColumn.template must be a function');\n        }\n    }\n\n    /**\n     * Renderer that uses a template for cell content.\n     * @private\n     */\n    renderer(renderData) {\n        // If it's a special row, such as a group row, we can't use the user's template\n        if (!renderData.record.isSpecialRow) {\n            return this.template({\n                value  : renderData.value,\n                record : renderData.record,\n                field  : this.field\n            });\n        }\n    }\n}\n\nColumnStore.registerColumnType(TemplateColumn, true);\nTemplateColumn.exposeProperties();\n", "import Column from './Column.js';\nimport ColumnStore from '../data/ColumnStore.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\n\n/**\n * @module Grid/column/TimeColumn\n */\n\n/**\n * A column that displays a time in the specified format (see {@link Core.helper.DateHelper#function-format-static} for formatting options).\n *\n * Default editor is a {@link Core.widget.TimeField TimeField}.\n *\n * @extends Grid/column/Column\n *\n * @example\n * new Grid({\n *     appendTo : document.body,\n *\n *     columns : [\n *          { type: 'time', text: 'Start time', format: 'HH:mm:ss', data: 'start' }\n *     ]\n * });\n *\n * @classType time\n * @inlineexample Grid/column/TimeColumn.js\n * @column\n */\nexport default class TimeColumn extends Column {\n\n    //region Config\n\n    static type = 'time';\n\n    // Type to use when auto adding field\n    static fieldType = 'date';\n\n    static fields = ['format'];\n\n    static get defaults() {\n        return {\n            /**\n             * Time format\n             * @config {String}\n             * @category Common\n             */\n            format : 'LT',\n\n            minWidth : 140,\n\n            filterType : 'time'\n        };\n    }\n\n    //endregion\n\n    //region Display\n\n    /**\n     * Renderer that displays the time with the specified format. Also adds cls 'b-time-cell' to the cell.\n     * @private\n     */\n    defaultRenderer({ value }) {\n        return value ? this.formatValue(value) : '';\n    }\n\n    /**\n     * Group renderer that displays the time with the specified format.\n     * @private\n     */\n    groupRenderer({ cellElement, groupRowFor }) {\n        cellElement.innerHTML = this.formatValue(groupRowFor);\n    }\n\n    //endregion\n\n    //region Formatter\n\n    /**\n     * Used by both renderer and groupRenderer to do the actual formatting of the time\n     * @private\n     * @param value\n     * @returns {String}\n     */\n    formatValue(value) {\n        // Ideally we should be served a time, but if not make it easier for the user by parsing\n        if (typeof value === 'string') {\n            value = DateHelper.parse(value, this.format);\n        }\n        return DateHelper.format(value, this.format);\n    }\n\n    //endregion\n\n    //region Getters/Setters\n    /**\n     * Get/Set format for time displayed in cell and editor (see {@link Core.helper.DateHelper#function-format-static} for formatting options)\n     * @property {String}\n     */\n    set format(value) {\n        const { editor } = this;\n\n        this.set('format', value);\n\n        if (editor) {\n            editor.format = value;\n        }\n    }\n\n    get format() {\n        return  this.get('format');\n    }\n\n    get defaultEditor() {\n        return {\n            name   : this.field,\n            type   : 'time',\n            format : this.format\n        };\n    }\n\n    //endregion\n}\n\nColumnStore.registerColumnType(TimeColumn, true);\nTimeColumn.exposeProperties();\n", "import CopyPasteBase from './base/CopyPasteBase.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\n\n/**\n * @module Grid/feature/CellCopyPaste\n */\n\n/**\n * Allows using `[Ctrl/CMD + C]`, `[Ctrl/CMD + X]` and `[Ctrl/CMD + V]` to cut, copy and paste cell or cell ranges. Also\n * makes cut, copy and paste actions available via the cell context menu.\n *\n * <div class=\"note\">\n * Requires {@link Grid/view/Grid#config-selectionMode selectionMode.cell} to be activated. Also, if the\n * {@link Grid/feature/CellEdit} feature is disabled, the {@link #config-copyOnly} config will default to `true` which\n * prevents cut and paste actions completely. Set {@link #config-copyOnly} to `false` to prevent this behaviour.\n * </div>\n *\n * This feature will work alongside with {@link Grid/feature/RowCopyPaste} but there is differences on functionality.\n * * When used together, context menu options will be detailed so the user will know to copy the cell or the row.\n * * They will also detect what type of selection is present at the moment. If there are only rows selected, only row\n *   alternatives are shown in the context menu and the keyboard shortcuts will be processed by RowCopyPaste.\n * * If there are only cells selected, there will be context menu options for both row and cell but keyboard shortcuts\n *   will be handled by CellCopyPaste.\n * * They do share clipboard, even if internal clipboard is used, so it is not possible to have rows and cells copied or\n *   cut at the same time.\n *\n * If the {@link https://developer.mozilla.org/en-US/docs/Web/API/Clipboard_API Clipboard API} is available, that will\n * be used. This enables copying and pasting between different Bryntum products or completely different applications.\n * Please note that only string values are supported.\n *\n * This feature is **disabled** by default\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         cellCopyPaste : true\n *     }\n * });\n * ```\n *\n * {@inlineexample Grid/feature/CellCopyPaste.js}\n *\n * ## Keyboard shortcuts\n * The feature has the following default keyboard shortcuts:\n *\n * | Keys       | Action  | Action description                                                                      |\n * |------------|---------|-----------------------------------------------------------------------------------------|\n * | `Ctrl`+`C` | *copy*  | Calls {@link #function-copy} which copies selected cell values into the clipboard.      |\n * | `Ctrl`+`X` | *cut*   | Calls {@link #function-cut} which cuts out selected cell values and saves in clipboard. |\n * | `Ctrl`+`V` | *paste* | Calls {@link #function-paste} which inserts string values from the clipboard.           |\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [this guide](#Grid/guides/customization/keymap.md).\n *\n * @extends Grid/feature/base/CopyPasteBase\n * @classtype cellCopyPaste\n * @feature\n */\nexport default class CellCopyPaste extends CopyPasteBase {\n    static $name = 'CellCopyPaste';\n\n    static pluginConfig = {\n        chain : [\n            'populateCellMenu', 'afterSelectionModeChange'\n        ]\n    };\n\n    static configurable = {\n\n        useNativeClipboard : !VersionHelper.isTestEnv,\n\n        copyText  : 'L{copy}',\n        cutText   : 'L{cut}',\n        pasteText : 'L{paste}'\n    };\n\n    afterConstruct() {\n        super.afterConstruct();\n        this.afterSelectionModeChange();\n    }\n\n    afterSelectionModeChange() {\n        const me = this;\n\n        if (!me.client.selectionMode.cell) {\n            me.disabled = true;\n        }\n        else if (me._disabledBySelectionMode) {\n            me.disabled = false;\n            delete me._disabledBySelectionMode;\n        }\n    }\n\n    // Used in events to separate events from different features from each other\n    entityName = 'cell';\n\n    set copyOnly(value) {\n        this._copyOnly = value;\n    }\n\n    get copyOnly() {\n        // If celledit is disabled, cut and paste actions are disabled by default\n        if (this._copyOnly == null) {\n            return !this.client.features.cellEdit?.enabled;\n        }\n\n        return Boolean(this._copyOnly);\n    }\n\n    get canCopy() {\n        const { client } = this;\n\n        return Boolean(!this.disabled && client.selectedCells.length &&\n            (\n                !client._selectedRows.length ||\n                client.features.rowCopyPaste?.disabled ||\n                client.focusedCell && client.isCellSelected(client.focusedCell)\n            ));\n    }\n\n    get canCutPaste() {\n        return this.canCopy && !this.copyOnly && !this.client.features.cellEdit?.isEditing && !this.client.readOnly;\n    }\n\n    // Called from keyMap. Also used internally here\n    isActionAvailable({ actionName }) {\n        return this.canCopy && (actionName === 'copy' || this.canCutPaste);\n    }\n\n    /**\n     * Cuts selected cells to clipboard (native if accessible) to paste later\n     * @async\n     */\n    async cut() {\n        await this.copy(true);\n    }\n\n    /**\n     * Copies selected cells to clipboard (native if accessible) to paste later\n     * @async\n     */\n    async copy(isCut = false) {\n        if (typeof isCut != 'boolean') {\n            isCut = false; // If called by keymap, arguments[0] will be an event\n        }\n\n        const\n            me                = this,\n            { selectedCells } = me.client,\n            cells             = isCut ? selectedCells.filter(r => !r.record?.readOnly) : selectedCells;\n\n        if (cells) {\n            if ((isCut ? !me.canCutPaste : !me.canCopy)) {\n                return;\n            }\n\n            const copiedDataString = me.cellsToString(cells);\n            await me.writeToClipboard(copiedDataString, isCut, { cells });\n\n            if (isCut === true) {\n                for (const cell of cells) {\n                    if (!cell.column.readOnly) {\n                        cell.record.set(cell.column.field, null);\n                    }\n                }\n            }\n\n            /**\n             * Fires on the owning Grid after a copy action is performed.\n             * @event copy\n             * @on-owner\n             * @param {Grid.view.Grid} source Owner grid\n             * @param {Grid.util.Location[]} cells The cells about to be copied or cut\n             * @param {String} copiedDataString The concatenated data string that was copied or cut\n             * @param {Boolean} isCut `true` if this was a cut action\n             * @param {String} entityName 'cell' to distinguish this event from other copy events\n             */\n            me.client.trigger('copy', { cells, copiedDataString, isCut, entityName : me.entityName });\n\n        }\n    }\n\n    // Called from Clipboardable before writing to the clipboard\n    async beforeCopy({ data, isCut, cells }) {\n        /**\n         * Fires on the owning Grid before a copy action is performed, return `false` to prevent the action\n         * @event beforeCopy\n         * @preventable\n         * @on-owner\n         * @async\n         * @param {Grid.view.Grid} source Owner grid\n         * @param {Grid.util.Location[]} cells The cells about to be copied or cut\n         * @param {String} data The string data about to be copied or cut\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'cell' to distinguish this event from other beforeCopy events\n         */\n        return await this.client.trigger('beforeCopy', { cells, data, isCut, entityName : this.entityName });\n    }\n\n    /**\n     * Pastes string data into a cell or a range of cells. Either from native clipboard if that is accessible or from a\n     * fallback clipboard that is only available to the owner Grid.\n     *\n     * The string data will be split on `\\n` and `\\t` and put in different rows and columns accordingly.\n     *\n     * Note that there must be a selected cell to paste the data into.\n     * @async\n     */\n    async paste() {\n        const\n            me                     = this,\n            { client, entityName } = me,\n            targetCell             = client.selectedCells[0];\n\n        if (!me.canCutPaste || !targetCell) {\n            return;\n        }\n\n        const clipboardData = await me.readFromClipboard({}, true);\n\n        if (!clipboardData) {\n            return;\n        }\n\n        const { modifiedRecords, targetCells } = me.setFromStringData(clipboardData);\n\n        if (client.selectedCells.length === 1 && targetCells.length > 1) {\n            client.selectCellRange(targetCells[0], targetCells[targetCells.length - 1]);\n        }\n\n        /**\n         * Fires on the owning Grid after a paste action is performed.\n         * @event paste\n         * @on-owner\n         * @param {Grid.view.Grid} source Owner grid\n         * @param {String} clipboardData The clipboardData that was pasted\n         * @param {Core.data.Model[]} modifiedRecords The records which have been modified due to the paste action\n         * @param {Grid.util.Location} targetCell The cell from which the paste will be started\n         * @param {String} entityName 'cell' to distinguish this event from other paste events\n         */\n        client.trigger('paste', { clipboardData, targetCell, modifiedRecords : [...modifiedRecords], entityName });\n    }\n\n    // Called from Clipboardable before finishing the clipboard read\n    async beforePaste({ data }) {\n        /**\n         * Fires on the owning Grid before a paste action is performed, return `false` to prevent the action\n         * @event beforePaste\n         * @preventable\n         * @on-owner\n         * @async\n         * @param {Grid.view.Grid} source Owner grid\n         * @param {String} clipboardData The clipboardData about to be pasted\n         * @param {Grid.util.Location} targetCell The cell from which the paste will be started\n         * @param {String} entityName 'cell' to distinguish this event from other beforePaste events\n         */\n        return await this.client.trigger('beforePaste', {\n            clipboardData : data, targetCell : this.client.selectedCell, entityName : this.entityName\n        });\n    }\n\n    populateCellMenu({ record, items }) {\n        const me = this;\n\n        if (me.canCopy) {\n            items.cutCell = {\n                text        : me.cutText,\n                localeClass : me,\n                icon        : 'b-icon b-icon-cut',\n                weight      : 115,\n                disabled    : record.readOnly || !me.canCutPaste,\n                onItem      : () => me.cut()\n            };\n\n            items.pasteCell = {\n                text        : me.pasteText,\n                localeClass : me,\n                icon        : 'b-icon b-icon-paste',\n                weight      : 120,\n                disabled    : record.readOnly || !me.canCutPaste || me.hasClipboardData() === false,\n                onItem      : () => me.paste()\n            };\n\n            items.copyCell = {\n                text        : me.copyText,\n                localeClass : me,\n                cls         : 'b-separator',\n                icon        : 'b-icon b-icon-copy',\n                weight      : 110,\n                onItem      : () => me.copy()\n            };\n        }\n    }\n}\n\nGridFeatureManager.registerFeature(CellCopyPaste);\n", "import Objects from '../../Core/helper/util/Objects.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\n\n/**\n * @module Grid/feature/CellTooltip\n */\n\n/**\n * Displays a tooltip when hovering cells.\n *\n * {@inlineexample Grid/feature/CellTooltip.js}\n *\n * To show contents when hovering a cell, you can specify a global {@link #config-tooltipRenderer} function for the\n * feature, you can also define a {@link Grid.column.Column#config-tooltipRenderer} for individual columns.\n *\n * ```javascript\n * // Column with its own tooltip renderer\n * {\n *   text            : 'Name',\n *   field           : 'name',\n *   tooltipRenderer : ({ record }) => `My name is\\xa0<b>${record.name}</b>`\n * }\n * ```\n *\n * Configuration properties passed into this feature are used to configure the {@link Core.widget.Tooltip} instance\n * used.\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * ## Showing async content\n * Showing remotely loaded content is super easy using the {@link #config-tooltipRenderer}:\n *\n * ```javascript\n * // Async tooltip with some custom settings\n * const grid = new Grid({\n *   features: {\n *     cellTooltip: {\n *       // Time that mouse needs to be over cell before tooltip is shown\n *       hoverDelay : 4000,\n *       // Time after mouse out to hide the tooltip, 0 = instantly\n *       hideDelay  : 0,\n *       // Async tooltip renderer, return a Promise which yields the text content\n *       tooltipRenderer({ record, tip }) {\n *         return fetch(`tip.php?id=${record.id}`).then(response => response.text())\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @extends Core/mixin/InstancePlugin\n * @extendsconfigs Core/widget/Tooltip\n * @demo Grid/celltooltip\n * @classtype cellTooltip\n * @feature\n */\nexport default class CellTooltip extends InstancePlugin {\n    //region Config\n\n    static $name = 'CellTooltip';\n\n    static configurable = {\n        /**\n         * Function called to generate the HTML content for the cell tooltip.\n         * The function should return a string (your HTML), or a Promise yielding a string (for remotely loaded\n         * content)\n         * @prp {Function}\n         * @param {Object} context\n         * @param {HTMLElement} context.cellElement The cell element\n         * @param {Core.data.Model} context.record The row record\n         * @param {Grid.column.Column} context.column The column\n         * @param {Core.widget.Tooltip} context.tip The Tooltip instance\n         * @param {Grid.feature.CellTooltip} context.cellTooltip The feature\n         * @param {Event} context.event The raw DOM event\n         * @returns {String|Promise}\n         */\n        tooltipRenderer : null\n    };\n\n    //endregion\n\n    // region Init\n\n    construct(grid, config) {\n        super.construct(grid, this.processConfig(config));\n    }\n\n    initTip() {\n        const me = this;\n\n        me.tip = Tooltip.new({\n            forElement        : me.client.element,\n            forSelector       : '.b-grid-row:not(.b-group-row) .b-grid-cell, .b-grid-merged-cells',\n            hoverDelay        : 1000,\n            trackMouse        : false,\n            cls               : 'b-celltooltip-tip',\n            getHtml           : me.getTooltipContent.bind(me),\n            internalListeners : {\n                pointerOver : 'onPointerOver',\n                thisObj     : me\n            },\n            // eslint-disable-next-line bryntum/no-listeners-in-lib\n            listeners : me.configuredListeners\n        }, me.initialConfig);\n\n        me.relayEvents(me.tip, ['beforeShow', 'show']);\n    }\n\n    onPointerOver({ target }) {\n        const column = this.client.getColumnFromElement(target);\n\n        // Veto onPointerOver if column's tooltipRenderer is false\n        return column.tooltipRenderer !== false && Boolean(column.tooltipRenderer || this.tooltipRenderer);\n    }\n\n    // CellTooltip feature handles special config cases, where user can supply a function to use as tooltipRenderer\n    // instead of a normal config object\n    processConfig(config) {\n        if (typeof config === 'function') {\n            return {\n                tooltipRenderer : config\n            };\n        }\n\n        return config;\n    }\n\n    // override setConfig to process config before applying it (used mainly from ReactGrid)\n    setConfig(config) {\n        super.setConfig(this.processConfig(config));\n    }\n\n    doDestroy() {\n        this.tip && this.tip.destroy();\n        super.doDestroy();\n    }\n\n    doDisable(disable) {\n        if (!disable) {\n            this.initTip();\n        }\n        else if (this.tip) {\n            this.tip.destroy();\n            this.tip = null;\n        }\n\n        super.doDisable(disable);\n    }\n\n    //endregion\n\n    //region Content\n\n    /**\n     * Called from Tooltip to populate it with html.\n     * @private\n     */\n    getTooltipContent({ tip, activeTarget : cellElement, event }) {\n        const\n            me     = this,\n            record = me.client.getRecordFromElement(cellElement),\n            column = me.client.getColumnFromElement(cellElement),\n            arg    = { cellElement, record, column, event, tip, cellTooltip : me };\n\n        let result;\n\n        // If we have not changed context, we should not change content, unless we have a custom target selector (element within the cell)\n        if (!me.forSelector && record === me.lastRecord && record.generation === me.lastRecordGeneration && column === me.lastColumn) {\n            return me.tip._html;\n        }\n\n        me.lastRecord = record;\n        me.lastRecordGeneration = record.generation;\n        me.lastColumn = column;\n\n        // first, use columns tooltipRenderer if any\n        if (column.tooltipRenderer) {\n            result = column.tooltipRenderer(arg);\n        }\n        // secondly, try feature's renderer (specifying column.tooltipRenderer as false prevents tooltip in that column)\n        else if (me.tooltipRenderer && column.tooltipRenderer !== false) {\n            result = me.tooltipRenderer(arg);\n        }\n\n        // No caching of async requests\n        if (Objects.isPromise(result)) {\n            me.lastRecord = me.lastRecordGeneration = me.lastColumn = null;\n        }\n\n        // Tip should hide if no content is available\n        if (!result) {\n            tip.hide();\n        }\n\n        return result;\n    }\n\n    //endregion\n}\n\nGridFeatureManager.registerFeature(CellTooltip);\n", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport Editor from '../../Core/widget/Editor.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\n\n/**\n * @module Grid/feature/ColumnRename\n */\n\n/**\n * Allows user to rename columns by either right-clicking column header or using keyboard shortcuts when column header\n * is focused.\n *\n * To get notified about column renaming listen to `change` event on {@link Grid.data.ColumnStore columns} store.\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * {@inlineexample Grid/feature/ColumnRename.js}\n *\n * ## Keyboard shortcuts\n * This feature has the following default keyboard shortcuts:\n *\n * | Keys          | Action           | Action description                        |\n * |---------------|------------------|-------------------------------------------|\n * | `F2`          | *startEdit*      | Starts editing focused column header text |\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#Grid/guides/customization/keymap.md)\n *\n * @extends Core/mixin/InstancePlugin\n *\n * @demo Grid/columns\n * @classtype columnRename\n * @feature\n */\nexport default class ColumnRename extends InstancePlugin {\n\n    static $name = 'ColumnRename';\n\n    static configurable = {\n        /**\n         * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n         * @config {Object<String,String>}\n         */\n        keyMap : {\n            F2 : 'startEdit'\n        }\n    };\n\n    doDestroy() {\n        this.editor?.destroy();\n        super.doDestroy();\n    }\n\n    static get pluginConfig() {\n        return {\n            after : ['populateHeaderMenu']\n        };\n    }\n\n    populateHeaderMenu({ items, column }) {\n        items.rename = {\n            weight   : 215,\n            icon     : 'b-fw-icon b-icon-edit',\n            text     : this.L('L{rename}'),\n            disabled : column.readOnly,\n            onItem   : () => this.startEdit(column)\n        };\n    }\n\n    startEdit(column) {\n        if (column instanceof Event) {\n            // If started editing by key\n            column = this.client.getHeaderDataFromEvent(column)?.column;\n        }\n\n        if (column) {\n            if (column.readOnly) {\n                // return false to let keyMap know that we didn't handle this event\n                return false;\n            }\n\n            const { textWrapper } = column;\n            let { editor } = this;\n\n            if (!editor) {\n                this.editor = editor = new Editor({\n                    owner : this.client,\n                    align : {\n                        align : 't0-t0'\n                    }\n                });\n            }\n\n            editor.render(textWrapper);\n\n            editor.startEdit({\n                target : textWrapper,\n                record : column,\n                field  : 'text'\n            });\n        }\n    }\n}\n\nGridFeatureManager.registerFeature(ColumnRename, false);\n", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport Location from '../../Grid/util/Location.js';\nimport GlobalEvents from '../../Core/GlobalEvents.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\n\n/**\n * @module Grid/feature/FillHandle\n */\n\n/**\n * This features adds a fill handle to a Grid range selection, which when dragged, fills the cells being dragged over\n * with values based on the values in the original selected range. This is similar to functionality normally seen in\n * various spreadsheet applications.\n *\n * {@inlineexample Grid/feature/FillHandle.js}\n *\n * Requires {@link Grid/view/Grid#config-selectionMode selectionMode.cell} to be activated.\n *\n * This feature is **disabled** by default\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         fillHandle : true\n *     }\n * });\n * ```\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype fillHandle\n * @feature\n */\nexport default class FillHandle extends InstancePlugin.mixin(Delayable) {\n    static $name = 'FillHandle';\n\n    static configurable = {\n        /**\n         * Implement this function to be able to customize the value that cells will be filled with.\n         * Return `undefined` to use default calculations.\n         *\n         * ````javascript\n         * new Grid({\n         *    features : {\n         *        fillHandle : {\n         *           calculateFillValue({cell, column, range, record}) {\n         *              if(column.field === 'number') {\n         *                 return range.reduce(\n         *                    (sum, location) => sum + location.record[location.column.field]\n         *                 );\n         *              }\n         *           }\n         *        }\n         *    }\n         * });\n         * ````\n         *\n         * @param {Object} data Object containing information about current cell and fill value\n         * @param {Grid.util.Location} data.cell Current cell data\n         * @param {Grid.column.Column} data.column Current cell column\n         * @param {Grid.util.Location[]} data.range Range from where to calculate values\n         * @param {Core.data.Model} data.record Current cell record\n         * @returns {String|Number|Date} Value to fill current cell\n         * @config {Function}\n         */\n        calculateFillValue : null,\n\n        /**\n         * Set to `true` to enable the fill range to crop the original selected range. This clears the cells which were\n         * a part of the original selected range, but are no longer a part of the smaller range.\n         * @config {Boolean}\n         */\n        allowCropping : false\n\n    };\n\n    // Plugin configuration. This plugin chains/overrides some functions in Grid.\n    static pluginConfig = {\n        chain    : ['afterSelectionChange', 'onContentChange', 'afterColumnsChange', 'fixElementHeights'],\n        override : ['getCellDataFromEvent']\n    };\n\n    afterConstruct() {\n        super.afterConstruct();\n\n        if (!this.client.selectionMode.cell) {\n            this.disabled = true;\n        }\n\n        this._fillListeners = {};\n    }\n\n    delayable = {\n        handleSelection : 'raf'\n    };\n\n    onContentChange() {\n        this.handleSelection();\n    }\n\n    afterColumnsChange() {\n        this.handleSelection();\n    }\n\n    fixElementHeights() {\n        this.handleSelection();\n    }\n\n    getCellDataFromEvent(event, includeSingleAxisMatch) {\n        if (includeSingleAxisMatch) {\n            includeSingleAxisMatch = !event.target.classList.contains('b-fill-handle');\n        }\n        return this.overridden.getCellDataFromEvent(event, includeSingleAxisMatch);\n    }\n\n    // region Pattern recognition\n    findPatternsIn2dRange(range, horizontal, negative) {\n        const values = {};\n\n        // Converts a cellselector range to values per column or row\n        for (const cell of range) {\n            const id = horizontal ? cell.id : cell.columnId;\n            let value = cell.record.getValue(cell.column.field);\n\n            // If a number string, convert to number\n            if (value && typeof value === 'string' && !isNaN(value)) {\n                value = parseFloat(value);\n            }\n\n            if (!values[id]) {\n                values[id] = [];\n            }\n            values[id].push(value);\n        }\n\n        // Find patterns for each column or row in range\n        for (const rowOrCol in values) {\n            values[rowOrCol].pattern = this.findPatternsIn1dRange(values[rowOrCol], negative);\n        }\n\n        return values;\n    }\n\n    findPatternsIn1dRange(range, negative) {\n        const\n            lastValue = range[negative ? 0 : (range.length - 1)],\n            pattern   = {\n                next : () => lastValue,\n                lastValue\n            };\n\n        // If all values in same column/row is either number or date\n        if (range.every(val => typeof val === 'number') || range.every(val => val instanceof Date)) {\n            const diffs = range.map((val, ix) => val - range[ix - 1]);\n            diffs.shift(); // Removes initial NaN\n\n            // Found a repeating pattern\n            if (new Set(diffs).size === 1) {\n                pattern.increaseBy = diffs[0] * (negative ? -1 : 1);\n\n                pattern.next = () => {\n                    if (pattern.lastValue instanceof Date) {\n                        pattern.lastValue = new Date(pattern.lastValue.getTime() + pattern.increaseBy);\n                    }\n                    else {\n                        pattern.lastValue += pattern.increaseBy;\n                    }\n                    return pattern.lastValue;\n                };\n            }\n        }\n        // Else it's treated as a string value\n        else if (range.length > 1) {\n            pattern.stringPattern = [...range];\n            pattern.next = () => {\n                if (pattern.currentIndex === undefined) {\n                    pattern.currentIndex = 0;\n                }\n                else {\n                    pattern.currentIndex += 1;\n                    if (pattern.currentIndex >= pattern.stringPattern.length) {\n                        pattern.currentIndex = 0;\n                    }\n                }\n                return pattern.stringPattern[pattern.currentIndex];\n            };\n        }\n        return pattern;\n    }\n\n    // endregion\n\n    afterSelectionChange() {\n        const me = this;\n\n        if (me.client.readOnly) {\n            me.removeElements();\n            return;\n        }\n\n        // If selection isn't finished, wait for mouse up and then add fill elements\n        if (GlobalEvents.isMouseDown()) {\n            me.client.delayUntilMouseUp(() => me.handleSelection(true));\n            // Remove prev elements immediately in this case\n            me.removeElements();\n        }\n        // Otherwise, add fill elements immediately\n        else {\n            me.handleSelection(true);\n        }\n    }\n\n    /**\n     * Checks selection and sees to it that fill handle and border is drawn.\n     * Runs on next animation frame\n     * @internal\n     */\n    handleSelection() {\n        if (!this._isExtending) {\n            const range = this.rangeSelection;\n\n            if (range) {\n                this.drawFillHandleAndBorder(range[0], range[range.length - 1]);\n            }\n            else {\n                this.removeElements();\n            }\n        }\n    }\n\n    // region Mouse events\n\n    // On fillHandle mouse down only\n    onMouseDown(event) {\n        const { client } = this;\n\n        if (!client.readOnly) {\n            this._fillListeners.mouseMoveOrUp = EventHelper.on({\n                element   : globalThis,\n                mouseover : {\n                    handler : 'onMouseOver',\n                    element : client.selectionDragMouseEventListenerElement\n                },\n                mouseup : 'onMouseUp',\n                thisObj : this\n            });\n            event.preventDefault();\n            event.stopImmediatePropagation();\n            event.handled = true;\n        }\n    }\n\n    // Responsible for doing the filling\n    onMouseUp() {\n        const\n            me              = this,\n            {\n                client,\n                currentRange,\n                _isCropping\n            }               = me,\n            range           = me.rangeSelection,\n            selectionChange = range && currentRange && client.internalSelectRange(currentRange.from, currentRange.to),\n            selectedCells   = selectionChange?.selectedCells || [],\n            // For extending : Only modify cells that are not a part of original range\n            // For cropping  : Only clear cells that are not a part of new selection\n            extensionCells  = _isCropping ? me.croppingCells\n                : selectedCells.filter(cell => !range.some(sel => sel.equals(cell, true)));\n\n        delete me._isCropping; // Removing flag in case we bail out early\n\n        if (me._isExtending) {\n            client.disableScrollingCloseToEdges(client.items);\n            delete me._isExtending;\n        }\n\n        // If no extension, do nothing\n        if (!extensionCells?.length) {\n            me.handleSelection();\n            return;\n        }\n\n        client.suspendRefresh();\n\n        // If trimming (inverted extension), clear cells that where previously selected and not a part of new selection\n        if (_isCropping) {\n            extensionCells.forEach(cell => cell.record.set(cell.column.field, null, false, false, false, true));\n        }\n        // Extending cell values depending on pattern\n        else {\n            const\n                [firstCell] = extensionCells,\n                // If extensioncells has a record that is included in original selection, then we are dragging horizontally\n                horizontal  = range.some(sel => sel.record === firstCell.record),\n                // negative in this aspect, means dragging either upwards or to the left depending on horizontal or vertical\n                negative    = horizontal\n                    ? firstCell.columnIndex < range[0].columnIndex\n                    : firstCell.rowIndex < range[0].rowIndex,\n                patterns    = me.findPatternsIn2dRange(range, horizontal, negative),\n                changeMap   = new Map();\n\n            if (negative) {\n                extensionCells.reverse();\n            }\n\n            for (const cell of extensionCells) {\n                const { column, record } = cell;\n\n                if (!column.readOnly && column.canFillValue({ range, record, cell })) {\n                    let value   = me.calculateFillValue?.({ range, column, record, cell }),\n                        changed = changeMap.get(record);\n\n                    if (!changed) {\n                        changed = {};\n                        changeMap.set(record, changed);\n                    }\n\n                    if (value === undefined) {\n                        const pattern = patterns[horizontal ? cell.id : cell.columnId].pattern;\n                        value = pattern.next();\n                    }\n\n                    changed[column.field] = column.calculateFillValue?.({ value, record, range }) || value;\n                }\n            }\n\n            for (const [record, changes] of changeMap) {\n                record.set(changes, null, null, null, null, true);\n            }\n        }\n\n        client.resumeRefresh(true);\n\n        // Selects the extended area\n        client.performSelection(selectionChange);\n\n        delete me.currentRange;\n        me.handleSelection();\n    }\n\n    // The fill border and handle should refresh on mouse move\n    onMouseOver(event) {\n        const\n            me           = this,\n            {\n                client,\n                rangeSelection\n            }            = me,\n            first        = rangeSelection[0],\n            last         = rangeSelection[rangeSelection.length - 1],\n            cellData     = client.getCellDataFromEvent(event, true);\n        let cellSelector = cellData && client.normalizeCellContext(cellData.cellSelector);\n\n        if (cellSelector?._column?.region === first._column.region) {\n            const\n                equalOrSmaller = rangeSelection.some(cs => cs.equals(cellSelector, true));\n            let negative;\n\n            if (!me._isExtending) {\n                client.enableScrollingCloseToEdges(client.items);\n            }\n\n            if (equalOrSmaller) {\n                // If were smaller, were cropping (if it's allowed)\n                me._isCropping = me.allowCropping &&\n                    (cellSelector.rowIndex < last.rowIndex || cellSelector.columnIndex < last.columnIndex);\n            }\n            else {\n                // If cellSelector is on a row in range, endSelector should be current column but end/first row\n                if (cellSelector.rowIndex >= first.rowIndex && cellSelector.rowIndex <= last.rowIndex) {\n                    negative     = first.columnIndex > cellSelector.columnIndex;\n                    cellSelector = new Location({\n                        grid   : client,\n                        record : negative ? first.record : last.record,\n                        column : cellSelector.column\n                    });\n                }\n                // Else endSelector should be current row but end/first column\n                else {\n                    negative     = first.rowIndex > cellSelector.rowIndex;\n                    cellSelector = new Location({\n                        grid   : client,\n                        record : cellSelector.record,\n                        column : negative ? first.column : last.column\n                    });\n                }\n            }\n\n            // negative means that current mouse over cell is above or to the left\n            const\n                // If negative, draw from calculated mouse over cell\n                // otherwise, draw from top-left selection cell\n                from = negative ? cellSelector : first,\n                // If negative or were inside selection (but not cropping), draw to bottom-right selection cell\n                // otherwise, draw to calculated mouse over cell\n                to   = negative || (equalOrSmaller && !me._isCropping) ? last : cellSelector;\n\n            me.currentRange = { from, to };\n\n            // This flag is true even if were trimming\n            me._isExtending = true;\n\n            me.drawFillHandleAndBorder(from, to, true);\n        }\n    }\n\n    // endregion\n\n    // region Creating, updating and removing fillhandle and fillborder\n    drawFillHandleAndBorder(from, to, keepListeners = false) {\n        const\n            me        = this,\n            {\n                client,\n                currentRange,\n                _fillListeners\n            }         = me,\n            regionEl  = client.subGrids[from.column.region].element,\n            { x }     = Rectangle.from(from.cell || from.column.element, regionEl),\n            { right } = Rectangle.from(to.cell || to.column.element, regionEl),\n            { y }     = client.getRecordCoords(from.record, true),\n            bottom    = client.getRecordCoords(to.record, true).bottom - 1;\n        let {\n            borderElement,\n            handleElement\n        }             = me;\n\n        me.removeElements(keepListeners);\n\n        if (!borderElement) {\n            me.borderElement = borderElement = DomHelper.createElement({\n                className : 'b-fill-selection-border'\n            });\n\n            me.handleElement = handleElement = DomHelper.createElement({\n                className : 'b-fill-handle'\n            });\n        }\n\n        DomHelper.setRect(borderElement, { y, x, width : (right - x), height : (bottom - y) });\n        regionEl.appendChild(borderElement);\n\n        // If fill handle is drawn at right edge, put it to the left instead\n        DomHelper.setTopLeft(handleElement, bottom, right >= regionEl.scrollWidth ? x : right);\n        regionEl.appendChild(handleElement);\n\n        // Remove all previously cropping cls\n        me.toggleCroppingCls(false);\n        delete me.croppingCells;\n\n        // If were cropping, we should add cls class to the cells that will be \"shrunk\"\n        if (me._isCropping && me.rangeSelection?.length) {\n            const newCells = client.getRange(currentRange.from, currentRange.to);\n\n            me.croppingCells = me.rangeSelection.filter(sel => !newCells.some(cell => cell.equals(sel, true)));\n            me.toggleCroppingCls();\n        }\n\n        if (!_fillListeners.handleClick) {\n            _fillListeners.handleClick = EventHelper.on({\n                element   : client.rootElement,\n                delegate  : '.b-fill-handle',\n                mousedown : 'onMouseDown',\n                thisObj   : me\n            });\n        }\n\n        me.hasFillElements = true;\n    }\n\n    toggleCroppingCls(add = true) {\n        this.croppingCells?.forEach(sel => this.client.getCell(sel)?.classList.toggle('b-indicate-crop', add));\n    }\n\n    removeElements(keepListeners = false) {\n        const me = this;\n\n        me.handleElement?.remove();\n        me.borderElement?.remove();\n\n        if (!keepListeners) {\n            me.removeListeners();\n        }\n\n        me.hasFillElements = false;\n    }\n\n    // Detach listeners\n    removeListeners() {\n        const me = this;\n\n        for (const listener in me._fillListeners) {\n            me._fillListeners[listener]();\n        }\n        me._fillListeners = {};\n    }\n\n    // endregion\n\n    // Gets current selection range. Only allows for single range or single cell.\n    get rangeSelection() {\n        const\n            { client }        = this,\n            { selectedCells } = client,\n            range             = client._shiftSelectRange ?? (selectedCells.length === 1 && selectedCells);\n\n        // We only got one selected range, nothing else selected\n        // Only allow fill handle on single region selection\n        if (!client._selectedRows.length && range?.length && range.length === selectedCells.length &&\n            range.every(c1 => selectedCells.some(c2 => c1.equals(c2, true)) &&\n                c1._column.parent && c1._column.region === range[0]._column.region && client.store.isAvailable(c1.id)\n            )\n        ) {\n            return range;\n        }\n\n        return null;\n    }\n}\n\nGridFeatureManager.registerFeature(FillHandle);\n", "import ArrayHelper from '../../Core/helper/ArrayHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from './GridFeatureManager.js';\nimport DomClassList from '../../Core/helper/util/DomClassList.js';\n\n/**\n * @module Grid/feature/MergeCells\n */\n\n// Maps DOM events to relayed events that need correct casing\nconst camelCase = {\n    mousedown   : 'mouseDown',\n    mousemove   : 'mouseMove',\n    mouseup     : 'mouseUp',\n    touchdown   : 'touchDown',\n    touchmove   : 'touchMove',\n    touchup     : 'touchUp',\n    pointerover : 'mouseOver',\n    mouseout    : 'mouseOut',\n    dblclick    : 'dblClick',\n    keydown     : 'keyDown',\n    keypress    : 'keyPress',\n    keyup       : 'keyUp',\n    contextmenu : 'contextMenu'\n};\n\n/**\n * This feature merges cells that have the same value in sorted (or {@link #config-sortedOnly optionally} any) columns\n * configured to {@link Grid/column/Column#config-mergeCells}.\n *\n * The content of merged cells is sticky for Grids with a single subgrid section when all columns fit in view (content\n * stays in view until the cell is scrolled fully out of view).\n *\n * {@note}\n * Support for sticky content is limited because of how <code>position: sticky</code> works. Grid\n * scrolls vertically in one element, and horizontally in another (to support multiple regions in the grid), and this\n * setup is not supported by current browsers implementation of sticky positioning\n * {/@note}\n *\n * Try scrolling in the demo below. As mentioned above, cells are by default merged only in sorted columns -  try\n * sorting by the other columns (\"City\" and \"Favorite food\" are configured to merge cells):\n *\n * {@inlineexample Grid/feature/MergeCells.js}\n *\n * By configuring the feature with `sortedOnly : false`, cells can be merged in any column:\n *\n * {@inlineexample Grid/feature/MergeCellsAll.js}\n *\n * This feature is **disabled** by default.\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype mergeCells\n * @feature\n */\nexport default class MergeCells extends InstancePlugin {\n    //region Config\n\n    static $name = 'MergeCells';\n\n    static configurable = {\n        /**\n         * By default, merged cells allow pointer events to pass through to the underlying row/cell, to allow selecting\n         * a row and editing an individual cell even when they are merged. Configure as `false` to allow merged cells to\n         * catch and react to the pointer events instead.\n         *\n         * ```javascript\n         * const grid = new Grid({\n         *     features : {\n         *         mergeCells : {\n         *             // Let merged cells react to pointer events\n         *             passthrough : false\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * @config {Boolean}\n         */\n        passthrough : true,\n\n        /**\n         * Configure as `false` to allow merging cells in columns that are not sorted.\n         *\n         * {@note}\n         * Note that this will have a slight negative impact on performance, since cells in all columns configured to\n         * merge cells have to be iterated.\n         * {/@note}\n         *\n         * @config {Boolean}\n         * @default true\n         */\n        sortedOnly : true\n    };\n\n    // All current ranges (once rendered)\n    mergedRanges = [];\n    // Ranges indexed by row index & column id -> Each range included multiple times, for easy lookup\n    mergedMap    = {};\n\n    static get pluginConfig() {\n        return {\n            chain : [\n                'beforeRenderCell',\n                'afterRenderRow',\n                'bindStore',\n                'afterColumnsChange',\n                'afterRemove',\n                'afterToggleGroup',\n                'afterToggleSubGrid',\n                'handleEvent',\n                'populateHeaderMenu',\n                // 'setHoveredRow'\n                'afterSelectionChange'\n            ],\n\n            // Grid must perform its update *after* we do.\n            before : [\n                'onInternalResize'\n            ],\n            override : [\n                'getColumnFromElement',\n                'getRecordFromElement'\n            ]\n        };\n    };\n\n    //endregion\n\n    //region Init\n\n    afterConstruct() {\n        const\n            me         = this,\n            { client } = me;\n\n        // Each subgrid gets a merged cells container\n        client.eachSubGrid(subGrid => me.setupSubGrid(subGrid));\n\n        // Merged cells are synced after rows are updated\n        client.rowManager.ion({\n            renderDone : 'onRenderDone',\n            thisObj    : me\n        });\n\n        me.bindStore(client.store);\n    }\n\n    setupSubGrid(subGrid) {\n        // Element that will contain the merged cells\n        subGrid.$mergedCellsElement = DomHelper.createElement({\n            parent    : subGrid.element,\n            className : {\n                'b-grid-merged-cells-container' : 1\n            }\n        });\n\n        // Catch resizing region\n        subGrid.ion({\n            beforeInternalResize : 'refreshBounds',\n            thisObj              : this\n        });\n    }\n\n    doDisable(disable) {\n        if (!this.isConfiguring) {\n            // Flag to allow reset to redraw even though we are already disabled at this stage\n            this.isDisabling = true;\n            this.reset();\n            this.isDisabling = false;\n        }\n\n        super.doDisable(disable);\n    }\n\n    updatePassthrough(use) {\n        // Toggle CSS class that has `pointer-events : none`\n        this.client.element.classList.toggle('b-mergecells-passthrough', use);\n    }\n\n    updateSortedOnly(sortedOnly) {\n        if (!this.isConfiguring) {\n            this.reset(true, sortedOnly);\n        }\n    }\n\n    //endregion\n\n    //region Grid hooks\n\n    bindStore(store) {\n        this.detachListeners('store');\n\n        store.ion({\n            name    : 'store',\n            change  : 'onStoreChange',\n            // Call our refresh logic before grids\n            refresh : {\n                prio : 1,\n                fn   : 'onStoreRefresh'\n            },\n            thisObj : this\n        });\n    }\n\n    // Refresh all ranges when grid is resized\n    onInternalResize() {\n        this.refreshBounds();\n    }\n\n    // Get / create ranges before cell contents are rendered, redirecting the contents to the range\n    beforeRenderCell(renderData) {\n        const\n            me                              = this,\n            { column, record, cellElement } = renderData,\n            subGrid                         = me.client.subGrids[column.region];\n\n        // Only affect sorted columns configured to merge cells\n        if (!me.disabled && column.mergeCells && (column.isSorted || !me.sortedOnly) && !record.isSpecialRow && !subGrid.collapsed) {\n            const mergedRange = me.getMergeRange(record, column);\n            if (mergedRange?.use) {\n                // Flag the unmerged cell to allow styling it\n                cellElement.classList.add('b-merged-cell');\n                // Make sure it is empty\n                cellElement.innerHTML = '';\n                // Redirect output to the merged cell\n                renderData.cellElement = mergedRange.cellElement;\n\n                // <remove-on-release>\n                // TODO: Consider bailing out after rendering first available cell of a merge. It would help with\n                //  performance, but any side effects from the renderer would be lost (such as assigning classes to row)\n                // </remove-on-release>\n            }\n        }\n    }\n\n    afterRenderRow({ row, oldId, oldHeight }) {\n        // Row reused for same record changed height\n        if (oldId === row.id && oldHeight !== row.height) {\n            this.heightChanged = true;\n        }\n    }\n\n    // Refresh all ranges when a column is resized (since it might affect their position and size)\n    afterColumnsChange({ action, changes, column }) {\n        if (this.disabled) {\n            return;\n        }\n\n        if (action === 'update' && changes.mergeCells && !column.mergeCells) {\n            // Remove all ranges for the column when mergeCells is set to false\n            for (const range of this.mergedRanges.slice()) {\n                if (range.column === column) {\n                    this.removeRange(range);\n                }\n            }\n\n            this.syncDom();\n            return;\n        }\n\n        this.refreshBounds();\n    }\n\n    // Remove might be transitioned, wait until it finishes before resetting (in the afterRemove hook)\n    afterRemove() {\n        !this.disabled && this.reset();\n    }\n\n    // Group collapsed or expanded\n    afterToggleGroup() {\n        !this.disabled && this.reset();\n    }\n\n    // SubGrid collapsed or expanded\n    afterToggleSubGrid() {\n        !this.disabled && this.reset();\n    }\n\n    // setHoveredRow(row) {\n    //     this.$hovered = row && this.mergedRanges.find(r => r.fromIndex <= row.dataIndex && r.toIndex >= row.dataIndex);\n    //\n    //     this.syncDom();\n    // }\n\n    // Selection changed, range is considered selected when all of its rows are selected (only in passthrough mode)\n    afterSelectionChange() {\n        if (!this.passthrough) {\n            const\n                { client } = this,\n                indices    = client.selectedRecords.map(r => client.store.indexOf(r));\n            let changed    = false;\n\n            for (const range of this.mergedRanges) {\n                let allSelected = true;\n                // Check if all records in the range are selected\n                for (let i = range.fromIndex; i <= range.toIndex && allSelected; i++) {\n                    allSelected = indices.includes(i);\n                }\n\n                if (range.isSelected !== allSelected) {\n                    range.isSelected = allSelected;\n                    changed = true;\n                }\n            }\n\n            // Only redraw if a range selection status changed\n            changed && this.syncDom();\n        }\n    }\n\n    //endregion\n\n    //region Grid overrides\n\n    // Extract record from merged cells\n    getRecordFromElement(element) {\n        if (element.elementData?.range) {\n            return this.client.store.getAt(element.elementData.range.fromIndex);\n        }\n\n        return this.overridden.getRecordFromElement(element);\n    }\n\n    // Extract column from merged cells\n    getColumnFromElement(element) {\n        if (element.elementData?.range) {\n            return element.elementData.range.column;\n        }\n\n        return this.overridden.getColumnFromElement(element);\n    }\n\n    //endregion\n\n    //region Header menu\n\n    // Allow toggling merging cells from the column header menu (unless column is explicitly disallowing it)\n    populateHeaderMenu({ column, items }) {\n        if (column.mergeable !== false) {\n            items.mergeCells = {\n                text     : 'L{MergeCells.mergeCells}',\n                icon     : `b-fw-icon ${column.mergeCells ? 'b-icon-checked' : 'b-icon-unchecked'}`,\n                tooltip  : 'L{MergeCells.menuTooltip}',\n                cls      : 'b-separator',\n                weight   : 500,\n                disabled : this.disabled,\n                onItem   : () => column.mergeCells = !column.mergeCells\n            };\n        }\n    }\n\n    //endregion\n\n    //region Relaying events\n\n    // Relay pointer events from the merged cell on grid\n    async handleEvent(event) {\n        if (!this.passthrough) {\n            const mergedCellsElement = event.target.closest('.b-grid-merged-cells');\n\n            if (mergedCellsElement) {\n                const\n                    { client }   = this,\n                    { range }    = mergedCellsElement.elementData,\n                    { cellEdit } = client.features,\n                    { column }   = range,\n                    type         = StringHelper.capitalize(camelCase[event.type] ?? event.type),\n                    eventData    = {\n                        grid        : client,\n                        records     : [],\n                        column,\n                        cellElement : mergedCellsElement.firstElementChild,\n                        target      : event.target,\n                        event\n                    };\n\n                for (let i = range.fromIndex; i <= range.toIndex; i++) {\n                    eventData.records.push(client.store.getAt(i));\n                }\n\n                client.trigger(`mergedCell${type}`, eventData);\n\n                // Cell editing, pass through to cell underneath even when not using passthrough mode\n                if (cellEdit?.triggerEvent.toLowerCase() === `cell${type}`.toLowerCase()) {\n                    const row = client.rowManager.getRowAt(event.clientY);\n                    await cellEdit.startEditing({ id : row.id, columnId : column.id });\n                }\n                // Select ranges rows when clicking the merged cell\n                else if (event.type === 'click') {\n                    this.onRangeClick({ range });\n                }\n            }\n        }\n    }\n\n    //endregion\n\n    //region Event listeners\n\n    // Select ranges rows when clicking a merged cell\n    onRangeClick({ range }) {\n        const records = [];\n\n        for (let i = range.fromIndex; i <= range.toIndex; i++) {\n            records.push(this.client.store.getAt(i));\n        }\n\n        this.client.selectedRecords = records;\n    }\n\n    // Reset when data changes\n    onStoreChange() {\n        !this.disabled && this.reset();\n    }\n\n    // Reset before grids refresh listener come into play, grid will redraw\n    onStoreRefresh({ action }) {\n        // filter & dataset triggers change too, handled above\n        if (action !== 'filter' && action !== 'dataset') {\n            !this.disabled && this.reset(false);\n        }\n    }\n\n    //endregion\n\n    //region Render\n\n    // Element is needed early since it is passed to column renderers, and syncing for each rendered cell would give a\n    // lot of overhead. Thus creating element directly instead\n    createRangeElement(range) {\n        const\n            parent = this.client.getSubGridFromColumn(range.column).$mergedCellsElement,\n            syncId = `${range.fromIndex}-@-${range.column.id}`;\n\n        // If there is already an element for the range (also if previously released), we grab that one.\n        // We are bending the rules of DomSync here by spawning the element early\n        let element = parent.syncIdMap?.[syncId] ?? parent.releasedIdMap?.[syncId];\n\n        // No longer considered released\n        if (parent.releasedIdMap) {\n            delete parent.releasedIdMap[syncId];\n        }\n\n        if (!element) {\n            element = DomHelper.createElement(this.createRangeDomConfig(range));\n        }\n\n        // New element or reusing released one, DomSync need to be made aware\n        DomSync.addChild(parent, element, syncId);\n\n        range.element = element;\n        range.cellElement = element.firstElementChild;\n\n        return element;\n    }\n\n    // Create a DomConfig object for the supplied range, used initially with DomHelper and thereafter with DomSync\n    createRangeDomConfig(range) {\n        const\n            { column, fromIndex, toIndex, top, left, width, height } = range,\n            { type } = column,\n            record = this.client.store.getAt(fromIndex),\n            domConfig = {\n                className : {\n                    'b-grid-merged-cells' : 1,\n                    // 'b-hover'             : this.$hovered === range,\n                    'b-selected'          : range.isSelected\n                },\n                elementData : {\n                    range\n                },\n                style : {\n                    top,\n                    left,\n                    height,\n                    width\n                },\n                dataset : {\n                    syncId   : `${fromIndex}-@-${column.id}`,\n                    fromIndex,\n                    toIndex,\n                    column   : column.field,\n                    columnId : column.id\n                },\n                children : [\n                    // Div for an actual cell\n                    {\n                        className : new DomClassList(this.client.cellCls).assign({\n                            [`b-${type?.toLowerCase()}-cell`] : type,\n                            [column.cellCls]                  : column.cellCls,\n                            [column.internalCellCls]          : column.internalCellCls\n                        }).assign(column.autoCls),\n                        // Don't touch cell children that might have been added by renderer\n                        keepChildren : true,\n                        // Tag along the range for easy resolving later\n                        elementData  : {\n                            range\n                        },\n                        // Dataset expected on cells\n                        dataset : {\n                            column   : column.field,\n                            columnId : column.id\n                        },\n                        // Size using configured row height, to at least have a chance of lining up with surrounding cells\n                        style : {\n                            height : this.client.rowManager.rowHeight\n                        }\n                    }\n                ]\n            };\n\n        // Allow application code a chance to affect the merged cell (intended for styling)\n        column.mergedRenderer?.({ domConfig, value : column.getRawValue(record), record, column, fromIndex, toIndex });\n\n        return domConfig;\n    }\n\n    buildMergedCellsConfig(fromIndex, toIndex, rows) {\n        const\n            me             = this,\n            { client }     = me,\n            { rowManager } = client;\n\n        // When exporting content we render rows to a document fragment one by one without RowManager. In\n        // order to draw ranges correctly in this case we need provide some meta information - list of row-like\n        // objects from which we can size for merged cell element, i.e. top, bottom, height, dataIndex\n        // Match grids row buffer, drawing ranges from the topmost row to the bottommost\n        fromIndex = fromIndex ?? rowManager.topRow?.dataIndex;\n        toIndex = toIndex ?? rowManager.bottomRow?.dataIndex;\n\n        const\n            // { locked = [], normal = [] }\n            domConfigMap = client.regions.reduce((map, region) => {\n                map[region] = {\n                    className : {\n                        'b-grid-merged-cells-container' : 1\n                    },\n                    children : []\n                };\n                return map;\n            }, {});\n\n        // Determine and update visible ranges\n        for (const range of me.mergedRanges) {\n            if (range.use && range.fromIndex <= toIndex && range.toIndex >= fromIndex) {\n                // Update the range, in case more of it has been scrolled into view\n                me.updateRange(range, me.heightChanged, rows);\n                // Create a DomConfig for it\n                domConfigMap[range.column.region].children.push(me.createRangeDomConfig(range));\n            }\n        }\n\n        return domConfigMap;\n    }\n\n    syncDom(force = false) {\n        const\n            me             = this,\n            { client }     = me,\n            { rowManager } = client;\n\n        // Bail out if we get here too early (happens in Scheduler) or are disabled\n        if (!force && !rowManager.topRow || me.disabled && !me.isDisabling) {\n            return;\n        }\n\n        const domConfigMap = this.buildMergedCellsConfig();\n\n        // Sync per subgrid\n        client.eachSubGrid(subGrid => {\n            DomSync.sync({\n                targetElement : subGrid.$mergedCellsElement,\n                syncIdField   : 'syncId',\n                domConfig     : domConfigMap[subGrid.region]\n            });\n        });\n\n        me.heightChanged = false;\n    }\n\n    // Called after rows are updated, sync visible ranges per subgrid\n    onRenderDone() {\n        this.syncDom();\n    }\n\n    //endregion\n\n    //region Ranges\n\n    // Remove range from list and index/column map, leaving no trace it since we don't know if it will ever\n    // come back (element will be released by DomSync)\n    removeRange(range) {\n        ArrayHelper.remove(this.mergedRanges, range);\n        for (let index = range.fromIndex; index <= range.toIndex; index++) {\n            delete this.mergedMap[`${index}-@-${range.column.id}`];\n        }\n    }\n\n    // Full reset, regenerating all ranges\n    reset(redraw = true, force = false) {\n        const\n            me        = this,\n            columns   = me.client.columns.visibleColumns.filter(c => c.mergeCells && (c.isSorted || !me.sortedOnly || force), true),\n            hadRanges = me.mergedRanges.length;\n\n        me.mergedRanges = [];\n        me.mergedMap = {};\n\n        if (redraw && !me.client.refreshSuspended) {\n            for (const row of me.client.rowManager.rows) {\n                for (const column of columns) {\n                    row.renderCell(row.getCell(column.id));\n                }\n            }\n\n            // Redraw, forcing it if all rows are gone\n            me.syncDom(hadRanges && !me.client.rowManager.rowCount);\n        }\n    }\n\n    // Refreshes existing ranges coords\n    refreshBounds() {\n        const\n            { mergedRanges } = this,\n            row              = this.client.rowManager.topRow,\n            boundsMap        = new Map();\n\n        for (const range of mergedRanges.slice()) {\n            const\n                { column }  = range,\n                cellElement = row.getCell(column.id);\n\n            // Column shown\n            if (cellElement) {\n                let bounds = boundsMap.get(column);\n\n                if (!bounds) {\n                    // Temporarily cache bounds to avoid calculating them multiple times\n                    boundsMap.set(column, bounds = Rectangle.from(cellElement, cellElement.parentElement));\n                }\n\n                range.left = bounds.left;\n                range.width = bounds.width;\n            }\n            // Column hidden or removed\n            else {\n                this.removeRange(range);\n            }\n        }\n\n        this.syncDom();\n    }\n\n    // Updates the range as user scrolls, until its start and end coords are fully known\n    // Rows argument is required to render merged cells on export. We provide row-like objects there\n    updateRange(range, force, rows = null) {\n        const\n            { store, rowManager }           = this.client,\n            { topRendered, bottomRendered } = range,\n            { rowOffsetHeight }             = rowManager;\n\n        let { fromIndex, toIndex } = range,\n            topRow, bottomRow;\n\n        force = rows ? rows.length > 0 : force;\n\n        // No need to update anything if bounds are correct already\n        if (!force && topRendered && bottomRendered) {\n            return;\n        }\n\n        if (!topRendered || force) {\n            if (rows) {\n                const index = rows.findIndex(row => row.dataIndex >= fromIndex);\n                topRow = rows[index];\n                fromIndex = topRow.dataIndex;\n            }\n            else {\n                // <remove-on-release>\n                // TODO: Should not need to iterate here, calculate top instead\n                // </remove-on-release>\n                do {\n                    topRow = rowManager.getRowById(store.getAt(fromIndex));\n                }\n                while (!topRow && fromIndex++ < toIndex);\n            }\n\n            // topRow is the actual topmost row in the range\n            range.topRendered = (fromIndex === range.fromIndex);\n\n            const rowsAbove = fromIndex - range.fromIndex;\n\n            range.top = topRow.top - rowsAbove * (rows ? topRow.offsetHeight : rowOffsetHeight);\n        }\n\n        if (!bottomRendered || force) {\n            if (rows) {\n                // We need to find last index, so we can just pick max between -1 and whatever we find\n                const index = rows.findIndex(row => row.dataIndex === toIndex);\n                bottomRow = rows[index === -1 ? rows.length - 1 : index];\n                fromIndex = bottomRow.dataIndex;\n            }\n            else {\n                // <remove-on-release>\n                // TODO: Should not need to iterate here, calculate bottom instead\n                // </remove-on-release>\n                do {\n                    bottomRow = rowManager.getRowById(store.getAt(toIndex));\n                }\n                while (!bottomRow && toIndex-- > fromIndex);\n            }\n\n            // bottomRow is the actual bottommost row in the range\n            range.bottomRendered = (toIndex === range.toIndex);\n\n            const rowsBelow = range.toIndex - toIndex;\n\n            range.bottom = bottomRow.bottom + rowsBelow * (rows ? bottomRow.offsetHeight : rowOffsetHeight);\n        }\n\n        range.height = range.bottom - range.top;\n    }\n\n    // Retrieve a range for the specified record / column, creating a new one if none found by walking upwards and\n    // downwards until a deviating value is found\n    getMergeRange(record, column) {\n        if (record.isSpecialRow) {\n            return;\n        }\n\n        const\n            me            = this,\n            { mergedMap } = me,\n            { store }     = me.client,\n            row           = me.client.rowManager.topRow,\n            columnId      = column.id,\n            index         = store.indexOf(record),\n            key           = `${index}-@-${columnId}`;\n\n        let range = mergedMap[key];\n\n        if (!range) {\n            const value = column.getRawValue(record);\n\n            range = mergedMap[key] = {\n                column\n            };\n\n            me.mergedRanges.push(range);\n\n            // Search up until encountering different value\n            let earlierRecord, earlierValue, earlierIndex = index;\n\n            do {\n                earlierRecord = store.getAt(--earlierIndex);\n                earlierValue  = earlierRecord && column.getRawValue(earlierRecord);\n\n                if (earlierValue === value) {\n                    mergedMap[`${earlierIndex}-@-${columnId}`] = range;\n                }\n\n            } while (earlierRecord && earlierValue === value);\n\n            // And down\n            let laterRecord, laterValue, laterIndex = index;\n\n            do {\n                laterRecord = store.getAt(++laterIndex);\n                laterValue  = laterRecord && column.getRawValue(laterRecord);\n\n                if (laterValue === value) {\n                    mergedMap[`${laterIndex}-@-${columnId}`] = range;\n                }\n            } while (laterRecord && laterValue === value);\n\n            range.fromIndex = earlierIndex + 1;\n            range.toIndex   = laterIndex - 1;\n\n            // We only care about ranges longer than 1 record\n            if (range.toIndex - range.fromIndex > 0) {\n                const\n                    cellElement = row.getCell(columnId),\n                    cellBounds  = Rectangle.from(cellElement, cellElement.parentElement);\n\n                range.left  = cellBounds.left;\n                range.width = cellBounds.width;\n                range.use = true;\n            }\n        }\n\n        if (!range.element && range.use) {\n            me.createRangeElement(range);\n        }\n\n        return range;\n    }\n\n    //endregion\n}\n\nGridFeatureManager.registerFeature(MergeCells);\n", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\n\n// <remove-on-release>\n// TODO: Handle date columns\n// TODO: Icons to navigate between hits in the header? or in each cell?\n// TODO: Icon to clear quickfind in header\n// TODO: regex for valid key pressed?\n// </remove-on-release>\n\n/**\n * @module Grid/feature/QuickFind\n */\n\n/**\n * Feature that allows the user to search in a column by focusing a cell and typing. Navigate between hits using the\n * keyboard, [f3] or [ctrl]/[cmd] + [g] moves to next, also pressing [shift] moves to previous.\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * ## Keyboard shortcuts\n * This feature has the following default keyboard shortcuts:\n *\n * | Keys                | Action             | Action description                |\n * |---------------------|--------------------|-----------------------------------|\n * | `F3`                | *goToNextHit*      | Move focus to next search hit     |\n * | `Shift`+F3`         | *goToPrevHit*      | Move focus to previous search hit |\n * | `Ctrl`+`G`          | *goToNextHit*      | Move focus to next search hit     |\n * | `Ctrl`+`Shift`+`G`  | *goToPrevHit*      | Move focus to previous search hit |\n * | `Ctrl`+`Shift`+`F3` | *showFilterEditor* | Shows the filter editor           |\n * | `Escape`            | *clearSearch*      | Removes the search completely     |\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#Grid/guides/customization/keymap.md)\n *\n * @extends Core/mixin/InstancePlugin\n *\n * @example\n * // enable QuickFind\n * let grid = new Grid({\n *   features: {\n *     quickFind: true\n *   }\n * });\n *\n * // navigate to next hit programmatically\n * grid.features.quickFind.gotoNextHit();\n *\n * @demo Grid/quickfind\n * @classtype quickFind\n * @inlineexample Grid/feature/QuickFind.js\n * @feature\n */\nexport default class QuickFind extends InstancePlugin {\n    //region Config\n\n    static $name = 'QuickFind';\n\n    static configurable = {\n        mode : 'header',\n        find : '',\n\n        /**\n         * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n         * @config {Object<String,String>}\n         */\n        keyMap : {\n            F3             : 'gotoNextHit',\n            'Shift+F3'     : 'gotoPrevHit',\n            'Ctrl+g'       : 'gotoNextHit',\n            'Ctrl+Shift+g' : 'gotoPrevHit',\n            'Ctrl+Shift+f' : 'showFilterEditor',\n            Escape         : 'clearSearch',\n\n            //Private\n            Backspace : 'onBackspace'\n        }\n    };\n\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['onElementKeyPress', 'onCellNavigate']\n        };\n    }\n\n    //endregion\n\n    //region Init\n\n    static get properties() {\n        return {\n            hitCls          : 'b-quick-hit',\n            hitCellCls      : 'b-quick-hit-cell',\n            hitCellBadgeCls : 'b-quick-hit-cell-badge',\n            hitTextCls      : 'b-quick-hit-text'\n        };\n    }\n\n    construct(grid, config) {\n        super.construct(grid, config);\n\n        Object.assign(this, {\n            grid,\n            treeWalker : grid.setupTreeWalker(grid.element, DomHelper.NodeFilter.SHOW_TEXT, () => DomHelper.NodeFilter.FILTER_ACCEPT)\n        });\n    }\n\n    isActionAvailable() {\n        const { focusedCell } = this.grid;\n        return !this.disabled && focusedCell?.record && !focusedCell.isActionable && this.find.length > 0;\n    }\n\n    doDisable(disable) {\n        if (disable) {\n            this.clear();\n        }\n\n        super.doDisable(disable);\n    }\n\n    get store() {\n        return this.grid.store;\n    }\n\n    //endregion\n\n    //region Show/hide QuickFind\n\n    /**\n     * Shows a \"searchfield\" in the header. Triggered automatically when you have a cell focused and start typing.\n     * @private\n     */\n    showQuickFind() {\n        const\n            me       = this,\n            { grid } = me,\n            header   = grid.getHeaderElement(me.columnId);\n\n        if (header) {\n            if (!me.headerField) {\n                const [element, field, badge] = DomHelper.createElement({\n                    tag       : 'div',\n                    className : 'b-quick-hit-header',\n                    children  : [\n                        { tag : 'div', className : 'b-quick-hit-field' },\n                        { tag : 'div', className : 'b-quick-hit-badge' }\n                    ]\n                }, { returnAll : true });\n\n                if (me.mode === 'header') {\n                    header.appendChild(element);\n                }\n                else {\n                    element.className += ' b-quick-hit-mode-grid';\n                    grid.element.appendChild(element);\n                }\n\n                me.headerField = {\n                    header    : element,\n                    field,\n                    badge,\n                    colHeader : header\n                };\n            }\n\n            me.headerField.field.innerHTML = me.find;\n            me.headerField.badge.innerHTML = me.found.length;\n\n            header.classList.add('b-quick-find-header');\n        }\n\n        if ((header || grid.hideHeaders) && !me.renderListenerInitialized) {\n            grid.rowManager.ion({\n                rendercell : me.renderCell,\n                thisObj    : me\n            });\n            me.renderListenerInitialized = true;\n        }\n\n    }\n\n    /**\n     * Hide the \"searchfield\" and remove highlighted hits. Called automatically when pressing [esc] or backspacing away\n     * the keywords.\n     * @private\n     */\n    hideQuickFind() {\n        const\n            me                    = this,\n            { grid, headerField } = me;\n\n        // rerender cells to remove quick-find markup\n        for (const hit of (me.prevFound || me.found)) {\n            const row = grid.getRowById(hit.id);\n            if (row) {\n                // Need to force replace quick finds markup\n                row.forceInnerHTML = true;\n\n                const cellElement = row.getCell(me.columnId);\n                cellElement._content = null;\n                row.renderCell(cellElement);\n\n                row.forceInnerHTML = false;\n            }\n        }\n\n        if (headerField) {\n            headerField.header.parentNode.removeChild(headerField.header);\n            headerField.colHeader.classList.remove('b-quick-find-header');\n            me.headerField = null;\n        }\n\n        if (me.renderListenerInitialized) {\n            grid.rowManager.un({ rendercell : me.renderCell }, me);\n            me.renderListenerInitialized = false;\n        }\n\n        grid.trigger('hideQuickFind');\n    }\n\n    //endregion\n\n    //region Search\n\n    /**\n     * Performs a search and highlights hits. If find is empty, QuickFind is closed.\n     * @param {String} find Text to search for\n     * @param {String} columnFieldOrId Column to search\n     */\n    search(find, columnFieldOrId = this.columnId, fromSplit = false) {\n        const\n            me       = this,\n            { grid } = me,\n            column   = grid.columns.getById(columnFieldOrId) || grid.columns.get(columnFieldOrId),\n            found    = me.store.findByField(column.field, find, column.mergeCells && column.isSorted);\n\n        let i = 1;\n\n        Object.assign(me, {\n            foundMap  : {},\n            prevFound : me.found,\n            found,\n            find,\n            columnId  : column.id,\n            findRe    : new RegExp(`(\\\\s+)?(${StringHelper.escapeRegExp(String(find))})(\\\\s+)?`, 'ig')\n        });\n\n        if (find) {\n            me.showQuickFind();\n        }\n        else {\n            me.hideQuickFind();\n        }\n\n        // clear old hits\n        for (const cellElement of DomHelper.children(grid.element, `.${me.hitCls}`)) {\n            cellElement.classList.remove(me.hitCls, me.hitCellCls);\n\n            if (cellElement._originalContent) {\n                cellElement.innerHTML = cellElement._originalContent;\n                cellElement._originalContent = null;\n            }\n        }\n\n        if (!found) {\n            return;\n        }\n\n        if (found.length > 0 && !fromSplit) {\n            me.gotoClosestHit(grid.focusedCell, found);\n        }\n\n        // highlight hits for visible cells\n        for (const hit of found) {\n            me.foundMap[hit.id] = i++;\n\n            const row = grid.getRowById(hit.data.id);\n            row?.renderCell(row.getCell(column.id));\n\n            // limit highlighted hits\n            if (i > 1000) {\n                break;\n            }\n        }\n\n        // Relay to other grids when splitting\n        grid.syncSplits?.(other => other.features.quickFind.search(find, columnFieldOrId, true));\n\n        grid.trigger('quickFind', { find, found });\n    }\n\n    /**\n     * Clears and closes QuickFind.\n     */\n    clear() {\n        if (this.find || this.found?.length) {\n            this.search('');\n        }\n    }\n\n    /**\n     * Number of results found\n     * @type {Number}\n     * @readonly\n     */\n    get foundCount() {\n        return this.found?.length ?? 0;\n    }\n\n    /**\n     * Found results (as returned by Store#findByField), an array in format { index: x, data: record }\n     * @member {StoreSearchResult[]} found\n     * @readonly\n     */\n\n    //endregion\n\n    //region Navigation\n\n    /**\n     * Go to specified hit.\n     * @param {Number} index\n     */\n    gotoHit(index) {\n        const nextHit = this.found[index];\n\n        if (nextHit) {\n            this.grid.focusCell({\n                columnId : this.columnId,\n                id       : nextHit.id\n            }, { doSelect : true });\n        }\n\n        return !!nextHit;\n    }\n\n    gotoClosestHit(focusedCell, found) {\n        const\n            focusedIndex = focusedCell ? this.grid.store.indexOf(focusedCell.id) : 0,\n            foundSorted  = found.slice().sort(\n                (a, b) => Math.abs(a.index - focusedIndex) - Math.abs(b.index - focusedIndex)\n            );\n\n        this.gotoHit(found.indexOf(foundSorted[0]));\n    }\n\n    /**\n     * Go to the first hit.\n     */\n    gotoFirstHit() {\n        this.gotoHit(0);\n    }\n\n    /**\n     * Go to the last hit.\n     */\n    gotoLastHit() {\n        this.gotoHit(this.found.length - 1);\n    }\n\n    /**\n     * Select the next hit, scrolling it into view. Triggered with [f3] or [ctrl]/[cmd] + [g].\n     */\n    gotoNextHit() {\n        const\n            me           = this,\n            { grid }     = me,\n            // start from focused cell, or if focus has left grid use lastFocusedCell\n            currentId    = grid._focusedCell?.id ?? grid.lastFocusedCell?.id,\n            currentIndex = grid.store.indexOf(currentId) || 0,\n            nextHit      = me.found.find(hit => hit.index > currentIndex);\n\n        if (nextHit) {\n            grid.focusCell({\n                columnId : me.columnId,\n                id       : nextHit.id\n            }, { doSelect : true });\n        }\n        else {\n            me.gotoFirstHit();\n        }\n    }\n\n    /**\n     * Select the previous hit, scrolling it into view. Triggered with [shift] + [f3] or [shift] + [ctrl]/[cmd] + [g].\n     */\n    gotoPrevHit() {\n        const\n            me              = this,\n            { grid, found } = me,\n            currentId       = grid._focusedCell?.id ?? grid.lastFocusedCell?.id,\n            currentIndex    = grid.store.indexOf(currentId) || 0;\n\n        let prevHit;\n\n        if (!found.length) {\n            return;\n        }\n\n        for (let i = found.length - 1; i--; i >= 0) {\n            if (found[i].index < currentIndex) {\n                prevHit = found[i];\n                break;\n            }\n        }\n\n        if (prevHit) {\n            grid.focusCell({\n                columnId : me.columnId,\n                id       : prevHit.id\n            }, { doSelect : true });\n        }\n        else {\n            me.gotoLastHit();\n        }\n    }\n\n    //endregion\n\n    //region Render\n\n    /**\n     * Called from SubGrid when a cell is rendered.\n     * @private\n     */\n    renderCell({ cellElement, column, record }) {\n        const\n            me           = this,\n            { classList } = cellElement,\n            {\n                treeWalker,\n                findRe,\n                hitTextCls\n            }           = me,\n            hitIndex    = me.columnId === column.id && me.foundMap?.[record.id];\n\n        if (hitIndex) {\n            // highlight cell\n            classList.add(me.hitCls);\n            cellElement.isQuickHit = true;\n            cellElement._originalContent = cellElement.innerHTML;\n\n            // if features have added other stuff to the cell, value is in div.b-grid-cell-value\n            // highlight in cell if found in innerHTML\n            const inner = treeWalker.currentNode = DomHelper.down(cellElement, '.b-grid-cell-value,.b-tree-cell-value') || cellElement;\n\n            for (let textNode = treeWalker.nextNode(); textNode && inner.contains(textNode);) {\n                const\n                    nodeToReplace = textNode,\n                    textContent   = textNode.nodeValue,\n                    newText       = ['<span>'];\n\n                // Move onto next text node before we replace the node with a highlight HTML sequence\n                textNode = treeWalker.nextNode();\n\n                let offset = findRe.lastIndex;\n\n                // Convert textContent into an innerHTML string which htmlEncodes the text and embeds\n                // a highlighting span which contains the target text.\n                for (let match = findRe.exec(textContent); match; match = findRe.exec(textContent)) {\n                    const\n                        preamble    = textContent.substring(offset, match.index),\n                        spaceBefore = match[1] ? '\\xa0' : '',\n                        v           = match[2],\n                        spaceAfter  = match[3] ? '\\xa0' : '';\n\n                    newText.push(`${StringHelper.encodeHtml(preamble)}${spaceBefore}<span class=\"${hitTextCls}\">${v}</span>${spaceAfter}`);\n                    offset = findRe.lastIndex;\n                }\n\n                newText.push(StringHelper.encodeHtml(textContent.substring(offset)), '</span>');\n\n                // Insert a fragment with each match wrapped with a span.\n                nodeToReplace.parentNode.insertBefore(DomHelper.createElementFromTemplate(newText.join(''), {\n                    fragment : true\n                }), nodeToReplace);\n                nodeToReplace.remove();\n            }\n            DomHelper.createElement({\n                parent    : cellElement,\n                className : me.hitCellBadgeCls,\n                text      : hitIndex\n            });\n        }\n    }\n\n    //endregion\n\n    //region Events\n\n    onBackspace(event) {\n        const me = this;\n        if (me.find) {\n            me.find = me.find.substr(0, me.find.length - 1);\n            me.search(me.find);\n            return true;\n        }\n        return false;\n    }\n\n    clearSearch() {\n        if (this.find) {\n            this.find = '';\n            this.search(this.find);\n            return true;\n        }\n        return false;\n    }\n\n    showFilterEditor() {\n        const\n            me = this,\n            { filter } = me.client.features;\n\n        if (filter && me.columnId && me.foundCount) {\n            me.clear();\n            filter.showFilterEditor(me.client.columns.getById(me.columnId), me.find);\n        }\n    }\n\n    /**\n     * Chained function called on grids keypress event. Handles input for \"searchfield\".\n     * @private\n     * @param event\n     */\n    onElementKeyPress(event) {\n        const\n            me              = this,\n            { grid }        = me,\n            { focusedCell } = grid;\n\n        // Only react to keystrokes on grid cell elements\n        if (!event.handled && !me.disabled && focusedCell?.record && !focusedCell.isActionable && event.key?.length === 1) {\n            const column = grid.columns.getById(grid._focusedCell.columnId);\n            // if trying to search in invalid column, it's a hard failure\n            //<debug>\n            console.assert(column, 'Focused cell column not found');\n            //</debug>\n            if (column && column.searchable !== false) {\n                me.columnId = grid._focusedCell.columnId;\n                me.find += event.key;\n                me.search(me.find);\n            }\n        }\n    }\n\n    onCellNavigate(grid, fromCellSelector, toCellSelector) {\n        const\n            me    = this;\n\n        if (me.find && (!toCellSelector || toCellSelector.columnId !== me.columnId)) {\n            me.clear();\n        }\n    }\n\n    //endregion\n}\n\nGridFeatureManager.registerFeature(QuickFind);\n", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport Widget from '../../Core/widget/Widget.js';\nimport Objects from '../../Core/helper/util/Objects.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport GlobalEvents from '../../Core/GlobalEvents.js';\nimport '../column/ActionColumn.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\n\n/**\n * @module Grid/feature/RowExpander\n */\n\nconst storeRemoveActions = { remove : 1, filter : 1, dataset : 1, replace : 1 };\n\n/**\n * Enables expanding of Grid rows by either row click or double click, or by adding a separate Grid column which renders\n * a button that expands or collapses the row.\n *\n * {@inlineexample Grid/feature/RowExpander.js}\n *\n * The content of the expanded row body is rendered by providing either a {@link #config-renderer} function to the\n * rowExpander feature config:\n *\n * ```javascript\n * new Grid({\n *    features : {\n *        rowExpander : {\n *            renderer({record, region, expanderElement}){\n *                return htmlToBeExpanded;\n *            }\n *        }\n *    }\n * });\n * ```\n *\n * Or a {@link #config-widget} configuration object:\n * ```javascript\n * new Grid({\n *    features : {\n *        rowExpander : {\n *            widget : {\n *                type : 'detailGrid',\n *            },\n *            dataField : 'orderDetails'\n *        }\n *    }\n * });\n * ```\n *\n * {@inlineexample Grid/feature/RowExpanderWidget.js}\n *\n * <div class=\"note\">Note that if used in a Gantt, the Gant's `fixedRowHeight` must be set to `false`.</div>\n *\n * This feature is **disabled** by default\n *\n * ## Expand on click\n * Set {@link #config-triggerEvent} to a Grid cell event that should trigger row expanding and collapsing.\n *\n * ```javascript\n * new Grid({\n *    features : {\n *        rowExpander : {\n *            triggerEvent: 'celldblclick',\n *            renderer...\n *        }\n *    }\n * });\n * ```\n *\n * ## Expander column position\n * The expander column can either be inserted before or after the existing Grid columns. If the Grid has multiple\n * regions the column will be added to the first region.\n *\n * Adjust expander column position to last in a specific Grid region by setting {@link #config-columnPosition}\n * to `last` and configuring the {@link #config-column} with a region name.\n *\n * ```javascript\n * new Grid({\n *    features : {\n *        rowExpander : {\n *            column: {\n *                region: 'last'\n *            },\n *            columnPosition: 'last',\n *            renderer...\n *        }\n *    }\n * });\n * ```\n *\n * ## Record update\n * If the expander content depends on row record data, the expander can be re-rendered on record update by setting\n * {@link #config-refreshOnRecordChange} to `true`.\n * ```javascript\n * new Grid({\n *    features : {\n *        rowExpander : {\n *            refreshOnRecordChange: true,\n *            renderer...\n *        }\n *    }\n * });\n * ```\n *\n * ## Async\n * When the content of the row expander should be rendered async just see to it that you return a promise.\n * ```javascript\n * new Grid({\n *    features : {\n *        rowExpander : {\n *            async renderer({record, region, expanderElement}){\n *                return fetchFromBackendAndRenderData(record);\n *            }\n *        }\n *    }\n * });\n * ```\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype rowExpander\n * @feature\n */\nexport default class RowExpander extends InstancePlugin.mixin(Delayable) {\n\n    //region Config\n    static $name = 'RowExpander';\n\n    // Cannot use `static properties = {}`, new Map/Set would pollute the prototype\n    static get properties() {\n        return {\n            // CSS classes\n            expanderBodyClass        : 'b-rowexpander-body',\n            expandedRowClass         : 'b-rowexpander-row-expanded',\n            shadowRootContainerClass : 'b-rowexpander-shadowroot-container',\n            // Map where the keys are the expanded records and values are an object\n            // {rowHeight, cellHeight, expandedBodyElements}\n            recordStateMap           : new Map(),\n            collapsingStateMap       : new Map()\n        };\n    }\n\n    static configurable = {\n\n        /**\n         * The implementation of this function is called each time the body of an expanded row is rendered. Either\n         * return an HTML string, a {@link Core.helper.DomHelper#typedef-DomConfig} object describing the markup or any\n         * Widget configuration object, like a Grid configuration object for example.\n         *\n         * ```javascript\n         * new Grid({\n         *    features : {\n         *        rowExpander : {\n         *            renderer({record, region, expanderElement}){\n         *                return htmlToBeExpanded;\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * Or return a {@link Core.helper.DomHelper#typedef-DomConfig} object.\n         *\n         * ```javascript\n         * new Grid({\n         *    features : {\n         *        rowExpander : {\n         *            renderer({record, region, expanderElement}){\n         *                return {\n         *                   tag       : 'form',\n         *                   className : 'expanded-row-form',\n         *                   children  : [\n         *                       {\n         *                           tag        : 'textarea',\n         *                           name       : 'description',\n         *                           className  : 'expanded-textarea'\n         *                       },\n         *                       {\n         *                           tag        : 'button',\n         *                           text       : 'Save',\n         *                           className  : 'expanded-save-button',\n         *                       }\n         *                   ]\n         *                };\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * Or return a Widget configuration object. What differs a Widget configuration object from a DomConfig object\n         * is the presence of the `type` property and the absence of a `tag` property.\n         *\n         * ```javascript\n         * new Grid({\n         *    features : {\n         *        rowExpander : {\n         *            async renderer({record, region, expanderElement}){\n         *                const myData = await fetch('myURL');\n         *                return {\n         *                   type : 'grid',\n         *                   autoHeight : true,\n         *                   columns : [\n         *                       ...\n         *                   ],\n         *                   data : myData\n         *                };\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * It is also possible to add markup directly to the expanderElement.\n         *\n         * ```javascript\n         * new Grid({\n         *    features : {\n         *        rowExpander : {\n         *            renderer({record, region, expanderElement}){\n         *                new UIComponent({\n         *                    appendTo: expanderElement,\n         *                    ...\n         *                });\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         * The renderer function can also be asynchronous.\n         *\n         * ```javascript\n         * new Grid({\n         *    features : {\n         *        rowExpander : {\n         *            async renderer({record, region, expanderElement}){\n         *                return await awaitAsynchronousOperation();\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         * @param {Object} renderData Object containing renderer parameters\n         * @param {Core.data.Model} renderData.record Record for the row\n         * @param {HTMLElement} renderData.expanderElement Expander body element\n         * @param {HTMLElement} renderData.rowElement Row element\n         * @param {String} renderData.region Grid region name\n         * @returns {String|DomConfig} Row expander body content\n         * @config {Function}\n         * @async\n         */\n        renderer : null,\n\n        /**\n         * The name of the Grid event that will toggle expander. Defaults to `null` but can be set to any event such\n         * as {@link Grid.view.mixin.GridElementEvents#event-cellDblClick} or\n         * {@link Grid.view.mixin.GridElementEvents#event-cellClick}.\n         *\n         * ```javascript\n         * features : {\n         *     rowExpander : {\n         *         triggerEvent : 'cellclick'\n         *     }\n         * }\n         * ```\n         *\n         * @config {String}\n         */\n        triggerEvent : null,\n\n        /**\n         * Provide a column config object to display a button with expand/collapse functionality.\n         * Shown by default, set to `null` to not include.\n         *\n         * ```javascript\n         * new Grid({\n         *    features : {\n         *        rowExpander : {\n         *            column: {\n         *                // Use column config options here\n         *                region: 'last'\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @config {ActionColumnConfig|Grid.column.ActionColumn}\n         */\n        column : {},\n\n        /**\n         * Makes the expand/collapse button column appear either as the first column (default or `first`) or as the\n         * last (set to `last`). Note that the column by default will be added to the first region, if the Grid\n         * has multiple regions. Use the {@link #config-column} config to change region.\n         * @config {String}\n         * @default\n         */\n        columnPosition : 'first',\n\n        /**\n         * If set to `true`, the RowExpander will, on record update, re-render an expanded row by calling the\n         * {@link #config-renderer} function or recreate the configured {@link #config-widget}.\n         * @config {Boolean}\n         * @default\n         */\n        refreshOnRecordChange : false,\n\n        /**\n         * Use this for customizing async {@link #config-renderer} loading indicator height.\n         * @config {Number}\n         * @defalt\n         */\n        loadingIndicatorHeight : 100,\n\n        /**\n         * Use this for customizing async {@link #config-renderer} loading indicator text.\n         * @config {String}\n         * @default Loading\n         */\n        loadingIndicatorText : 'L{loading}',\n\n        /**\n         * Use this to disable expand and collapse animations.\n         * @config {Boolean}\n         * @default\n         */\n        enableAnimations : true,\n\n        /**\n         * A widget configuration object that will be used to create a widget to render into the row expander body. Can\n         * be used instead of providing a {@link #config-renderer}.\n         *\n         * If the widget needs a store, it can be populated by use of the {@link #config-dataField} config. This will\n         * create a store from the expanded record's corresponding `dataField` value, which needs to be an array of\n         * objects or a store itself.\n         *\n         * ```javascript\n         * new Grid({\n         *    features : {\n         *        rowExpander : {\n         *            widget : {\n         *                type : 'detailGrid',\n         *            },\n         *            dataField : 'orderDetails'\n         *        }\n         *    }\n         * });\n         *\n         * @config {ContainerItemConfig}\n         */\n        widget : null,\n\n        /**\n         * Used together with {@link #config-widget} to populate the widget's Store from the expanded record's\n         * corresponding `dataField` value, which needs to be an array of objects or a store itself.\n         * @config {String}\n         */\n        dataField : null,\n\n        keyMap : {\n            // Private\n            Tab         : { handler : 'onTab', weight : 50 },\n            'Shift+Tab' : { handler : 'onShiftTab', weight : 50 }\n        },\n\n        /**\n         * When expanding a row and the expanded body element is not completely in view, setting this to `true` will\n         * automatically scroll the expanded row into view.\n         * @config {Boolean}\n         * @default\n         */\n        autoScroll : false\n    };\n\n    // Plugin configuration. This plugin chains/overrides some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain    : ['afterColumnsChange', 'beforeRenderRow', 'processRowHeight', 'bindStore', 'navigateUp'],\n            override : ['onGridBodyFocusIn', 'navigateDown', 'catchFocus', 'keyMapOnKeyDown']\n        };\n    }\n\n    //endregion\n\n    //region Init\n\n    afterConstruct() {\n        const\n            me         = this,\n            { client } = me;\n\n        if (!me.renderer && !me.widget) {\n            console.warn('RowExpander requires either a widget config or implementing the renderer function.');\n            return;\n        }\n        if (client.isGanttBase && client.fixedRowHeight !== false) {\n            console.warn('When using RowExpander on a Gantt, the Gantt`s fixedRowHeight config must be set to false.');\n        }\n\n        if (me.widget) {\n            GlobalEvents.ion({\n                theme   : me.onThemeChange,\n                thisObj : me\n            });\n        }\n\n        // Bind initial store\n        me.bindStore(client.store);\n\n        if (me.triggerEvent) {\n            client.ion({ [me.triggerEvent] : 'onTriggerEvent', thisObj : me });\n        }\n\n        me.addColumn();\n\n        me.resizeObserver = new ResizeObserver((entries) => me.onExpanderBodyResize(entries));\n    }\n\n    bindStore(store) {\n        const me = this;\n\n        me.recordStateMap.clear();\n        me.collapsingStateMap.clear();\n        me.detachListeners('clientStoreChange');\n\n        store.ion({\n            name    : 'clientStoreChange',\n            change  : me.onStoreChange,\n            thisObj : me\n        });\n    }\n\n    doDisable(disable) {\n        const { client } = this;\n\n        if (disable) {\n            this.recordStateMap.clear();\n            this.collapsingStateMap.clear();\n        }\n\n        if (!client.isConfiguring) {\n            client.rowManager.renderFromRow();\n        }\n        super.doDisable(disable);\n    }\n\n    changeLoadingIndicatorText(text) {\n        return text ? this.L(text) : text;\n    }\n\n    // Overrides onGridBodyFocusIn to ignore events on row expander body.\n    onGridBodyFocusIn(event) {\n        const me = this;\n\n        if (me.widget ? !event.target.matches(`.${me.expanderBodyClass}, .${me.shadowRootContainerClass}`)\n            : !me.client.lastMousedownEvent?.target?.closest('.' + me.expanderBodyClass)\n        ) {\n            me.overridden.onGridBodyFocusIn(event);\n        }\n    }\n\n    // Override keyMap key down so to not acting on keydown inside nested grid\n    keyMapOnKeyDown({ target }) {\n        if (!this.widget || !target.classList?.contains(this.shadowRootContainerClass)) {\n            this.overridden.keyMapOnKeyDown(...arguments);\n        }\n    }\n\n    get isAnimating() {\n        return this.client.isAnimating;\n    }\n\n    set isAnimating(value) {\n        const\n            { client }     = this,\n            wasAnimating   = client.isAnimating;\n        client.isAnimating = value;\n\n        if (client.isAnimating !== wasAnimating) {\n            client.element.classList.toggle('b-rowexpander-animating');\n        }\n    }\n\n    //endregion\n\n    //region Events\n    /**\n     * This event fires before row expand is started.\n     *\n     * Returning `false` from a listener prevents the RowExpander to expand the row.\n     *\n     * Note that this event fires when the RowExpander toggles the row, not when the actual row expander body is\n     * rendered. Most of the time this is synchronous, but in the case of a row that is not yet rendered into view by\n     * scrolling, it can happen much later.\n     *\n     * @event beforeExpand\n     * @preventable\n     * @async\n     * @param {Core.data.Model} record Record\n     */\n\n    /**\n     * This event fires before row collapse is started.\n     *\n     * Returning `false` from a listener prevents the RowExpander to collapse the row.\n     *\n     * Note that this event fires when the RowExpander toggles the row, not when the actual row expander body is\n     * rendered. Most of the time this is synchronous, but in the case of a row that is not yet rendered into view by\n     * scrolling, it can happen much later.\n     *\n     * @event beforeCollapse\n     * @preventable\n     * @async\n     * @param {Core.data.Model} record Record\n     */\n\n    /**\n     * This event fires when a row expand has finished expanding.\n     *\n     * Note that this event fires when actual row expander body is rendered, and not necessarily in immediate succession\n     * of an expand action. In the case of expanding a row that is not yet rendered into view by scrolling, it can happen\n     * much later.\n     *\n     * @event expand\n     * @param {Core.data.Model} record Record\n     * @param {Object} expandedElements An object with the Grid region name as property and the expanded body\n     * element as value\n     * @param {Core.widget.Widget} widget In case of expanding a Widget, this will be a reference to the instance\n     * created by the actual expansion\n     */\n\n    /**\n     * This event fires when a row has finished collapsing.\n     *\n     * @event collapse\n     * @param {Core.data.Model} record Record\n     */\n    //endregion\n\n    //region ExpanderColumn\n    afterColumnsChange() {\n        this.addColumn();\n    }\n\n    changeColumn(config) {\n        if (config == null) {\n            return config;\n        }\n        return {\n            type    : 'action',\n            actions : [{\n                cls     : 'b-icon b-icon-collapse-down',\n                tooltip : ({ record }) => this.L(this.recordStateMap.has(record) ? 'L{RowExpander.collapse}' : 'L{RowExpander.expand}'),\n                onClick : ({ record }) => this.toggleExpand(record)\n            }],\n            width    : 40,\n            hideable : false,\n            align    : 'center',\n            region   : this.client.regions[0],\n            ...config,\n            field    : 'expanderActionColumn'\n        };\n    }\n\n    // Called in construct and if grid columns change\n    addColumn() {\n        const\n            me          = this,\n            { column }  = me,\n            { columns } = me.client;\n\n        if (!me._isAddingExpanderColumn && column && (!me._expander || !columns.includes(me._expander))) {\n            me._isAddingExpanderColumn = true;\n            if (me.columnPosition === 'last') {\n                [me._expander] = columns.add(column);\n            }\n            else {\n                [me._expander] = columns.insert(0, column);\n            }\n            me._isAddingExpanderColumn = false;\n        }\n    }\n\n    //endregion\n\n    //region UI events\n\n    onTriggerEvent({ target }) {\n        // Only grid cell event is handled. Action-cell event has its own handler.\n        if (this.disabled || target?.closest('.b-action-cell') || !target.closest('.b-grid-cell')) {\n            return;\n        }\n        this.toggleExpand(this.client.getRecordFromElement(target));\n    }\n\n    /**\n     * Toggles expanded state.\n     * @private\n     * @param {Core.data.Model} record The record that should be toggled\n     * @category Internal\n     */\n    toggleExpand(record) {\n        if (record) {\n            if (this.recordStateMap.has(record)) {\n                this.collapse(record);\n            }\n            else {\n                this.expand(record);\n            }\n        }\n    }\n\n    onExpanderBodyResize(entries) {\n        const\n            { client } = this,\n            { store }  = client;\n\n        for (const entry of entries) {\n            const\n                record      = store.getById(entry.target.parentElement?._domData?.id),\n                recordState = record && this.recordStateMap.get(record);\n\n            if (recordState && !recordState.ignoreResize) {\n                const oldHeight = recordState.expanderBodyHeight;\n\n                recordState.expanderBodyHeight = null; // Clears saved height to recalc in processRowHeight\n                if (this.processRowHeight(record, 0) !== oldHeight) {\n                    // bufferedRenderer takes care of multiple rendering calls\n                    this.bufferedRenderer(record);\n                }\n            }\n        }\n    }\n\n    //endregion\n\n    //region Rendering\n\n    /**\n     * Listens to changes in the Grid Store. Will remove expand State data on Store removal.\n     * If the refreshOnRecordChange config is `true`, it will trigger a re-render of the expander.\n     * @private\n     * @param {String} action\n     * @param {Core.data.Store} source\n     * @param {Core.data.Model[]} records\n     * @category Internal\n     */\n    onStoreChange({ action, source, records, changes }) {\n        const\n            me                                     = this,\n            { recordStateMap, collapsingStateMap } = me,\n            changedKeys                            = changes && Object.keys(changes);\n\n        if (changedKeys?.length === 1 && source.modelClass.fieldMap[changedKeys[0]].type === 'store') {\n            return;\n        }\n        if (me.disabled) {\n            return;\n        }\n        if (action === 'removeAll') {\n            recordStateMap.clear();\n            collapsingStateMap.clear();\n        }\n        else if (storeRemoveActions[action]) {\n            for (const [record, state] of recordStateMap) {\n                if (!source.includes(record)) {\n                    state.widget?.destroy();\n                    recordStateMap.delete(record);\n                    collapsingStateMap.delete(record);\n                }\n            }\n        }\n        else if (me.refreshOnRecordChange && records?.length) {\n            if (action === 'update') {\n                const recordState = recordStateMap.get(records[0]);\n                if (recordState?.isCreated) {\n                    recordState.isCreated = false;\n                    me.client.rowManager.renderFromRecord(records[0]);\n                }\n            }\n            else if (action === 'updatemultiple') {\n                let topRecordIndex,\n                    topRecord;\n\n                for (const rec of records) {\n                    const recordState = recordStateMap.get(rec);\n\n                    if (recordState?.isCreated) {\n                        const index           = source.records.indexOf(rec);\n                        recordState.isCreated = false;\n\n                        if (!topRecord || topRecordIndex > index) {\n                            topRecordIndex = index;\n                            topRecord      = rec;\n                        }\n                    }\n                }\n                if (topRecord) {\n                    me.client.rowManager.renderFromRecord(topRecord);\n                }\n            }\n        }\n    }\n\n    // Implements grid.processRowHeight hook\n    processRowHeight(record, height) {\n        const recordState = this.recordStateMap.get(record);\n        if (recordState) {\n            // If we are waiting for async rendering, height is calculated from a fixed loadingIndicatorHeight.\n            if (!recordState.isCreated && recordState.isRenderingAsync) {\n                return this.loadingIndicatorHeight + height;\n            }\n\n            // If we have a recordState but no expanderBodyHeight, we should recalculate height.\n            if (!recordState.expanderBodyHeight) {\n                for (const region of this.client.regions) {\n                    const height = recordState.expandedBodyElements[region].offsetHeight;\n                    if (height > recordState.expanderBodyHeight) {\n                        recordState.expanderBodyHeight = height;\n                    }\n                }\n            }\n        }\n        return (recordState?.expanderBodyHeight ?? 0) + height;\n    }\n\n    /**\n     * Hooks on before row render to render or remove row expander content depending on record state.\n     * @private\n     * @category Internal\n     */\n    beforeRenderRow({ row, record }) {\n        const\n            me           = this,\n            { regions }  = me.client,\n            {\n                expandedRowClass,\n                collapsingStateMap\n            }            = me,\n            // The map only contains record that are expanded\n            recordState  = me.recordStateMap.get(record);\n\n        row.cls.toggle('b-rowexpander-disabled', me.disabled);\n\n        // If current row is expanded\n        if (row.cls[expandedRowClass]) {\n            // If animating a collapse, content should not be removed until animation is complete\n            if (me.enableAnimations && me.isAnimating && collapsingStateMap.has(record)) {\n                me.waitForTransition(row, () => {\n                    // Make sure record still should be collapsed after animation is complete\n                    const collapsingState = collapsingStateMap.get(record);\n\n                    if (collapsingState) {\n                        collapsingStateMap.delete(record);\n                        me.removeExpander(row);\n                        collapsingState.widget?.destroy();\n                    }\n                });\n            }\n            // Row is expanded but record should not be, remove expander\n            else if (!recordState) {\n                me.removeExpander(row);\n            }\n        }\n        else {\n            // Makes sure record should collapse no longer\n            collapsingStateMap.delete(record);\n        }\n\n        if (!me.disabled && recordState) {\n            // Expander content is created once, then reused.\n            if (!recordState.isCreated) {\n                recordState.ignoreResize = true; // Tells the resizeObserver to ignore this element right now\n                me.renderExpander(record, row, recordState);\n            }\n\n            row.cls.add(expandedRowClass);\n\n            for (const region of regions) {\n                const rowElement = row.getElement(region);\n\n                // isCreated means that the content has finished its creation process, which can be async\n                if (recordState.isCreated) {\n                    const bodyElement = recordState.expandedBodyElements[region];\n\n                    // If the bodyElement is connected to our rowElement, we do not need to do anything\n                    if (bodyElement.parentElement !== rowElement) {\n                        // If not, remove current content and add the created element\n                        DomHelper.removeEachSelector(rowElement, '.' + me.expanderBodyClass);\n                        rowElement.appendChild(bodyElement);\n\n                        // Observe body element to refresh grid when the body element resizes\n                        me.resizeObserver.observe(bodyElement);\n                    }\n\n                    recordState.ignoreResize = false;\n\n                    // Resolve the expand promise on next animation frame\n                    if (recordState.renderPromiseResolver) {\n                        me.delay(recordState.renderPromiseResolver);\n                        recordState.renderPromiseResolver = null;\n                    }\n                }\n                else {\n                    // If the renderer is async, we show a loading indicator.\n                    me.renderLoadingIndicator(rowElement, recordState);\n                }\n                me.lockCellHeight(rowElement, recordState.cellHeight, false);\n            }\n\n            // If expander body is rendered not fully in view, it will be scrolled into view\n            if (me._shouldScrollIntoView && me.autoScroll) {\n                me._shouldScrollIntoView = false;\n                if (!DomHelper.isInView(recordState.expandedBodyElements[regions[0]], true)) {\n                    // Wait for rendering to complete, then scroll\n                    me.client.rowManager.ion({\n                        once       : true,\n                        thisObj    : me,\n                        renderDone : () => me.scrollRowIntoView(row, record)\n                    });\n                }\n            }\n        }\n    }\n\n    /**\n     * Scrolls expanded row into view. This function is called after rowManager has finished rendering.\n     * @private\n     * @category Internal\n     */\n    scrollRowIntoView(row, record) {\n        // If animating expand, need to wait for the animation to end before scrolling.\n        if (this.isAnimating) {\n            this.waitForTransition(row, () => this.client.scrollRowIntoView(record));\n        }\n        else {\n            this.client.scrollRowIntoView(record);\n        }\n    }\n\n    /**\n     * Waits for height transition on the provided rows element. Then calls provided function.\n     * @private\n     * @category Internal\n     */\n    waitForTransition(row, fn) {\n        EventHelper.onTransitionEnd({\n            element  : row.element,\n            property : 'height',\n            handler  : fn,\n            thisObj  : this,\n            duration : DomHelper.getPropertyTransitionDuration(row.element, 'height') ?? 1\n        });\n    }\n\n    removeExpander(row, destroyWidget) {\n        row.cls.remove(this.expandedRowClass);\n\n        for (const region of this.client.regions) {\n            const rowElement = row.getElement(region);\n\n            for (const child of rowElement.querySelectorAll('.' + this.expanderBodyClass)) {\n                destroyWidget && child.widget?.destroy();\n                this.resizeObserver.unobserve(child);\n                child.remove();\n            }\n\n            // If this function is called after animation finished, we need to remove class `manually`\n            rowElement.classList.remove(this.expandedRowClass);\n\n            this.lockCellHeight(rowElement, null, false);\n        }\n    }\n\n    renderLoadingIndicator(rowElement, recordState) {\n        recordState.loadingIndicators.push(DomHelper.createElement({\n            parent    : rowElement,\n            className : this.expanderBodyClass + ' b-rowexpander-loading',\n            style     : {\n                top    : recordState.cellHeight,\n                height : this.loadingIndicatorHeight\n            },\n            children : [\n                {\n                    tag       : 'i',\n                    className : 'b-icon b-icon-spinner'\n                },\n                this.loadingIndicatorText\n            ]\n        }));\n    }\n\n    /**\n     * Creates expander element for each grid region and calls the renderer, also for each grid region.\n     * @private\n     * @param {Core.data.Model} record\n     * @param {Grid.row.Row} row\n     * @param {Object} recordState\n     * @category Internal\n     */\n    renderExpander(record, row, recordState) {\n        const\n            me                                   = this,\n            { client : grid, widget, dataField } = me,\n            cellHeight                           = row.cells[0]?.offsetHeight,\n            { expandedBodyElements = {} }        = recordState,\n            renderPromises                       = [],\n            // Will be called sync or async depending on the implementation of the renderer function.\n            continueRendering                    = (content, expanderElement, region) => {\n                if (content != null) {\n                    if (typeof content === 'string') {\n                        expanderElement.innerHTML = content;\n                    }\n                    else if (content.type && !content.tag) {\n                        createWidget(content, expanderElement);\n                    }\n                    // Everything else will be treated as a dom config for now\n                    else {\n                        content = DomHelper.createElement(content);\n                        expanderElement.appendChild(content);\n                    }\n                }\n                expandedBodyElements[region] = expanderElement;\n            },\n            createWidget = (widgetConfig, expanderElement) => {\n                const\n                    themeName           = DomHelper.getThemeInfo()?.name,\n                    shadowRootContainer = DomHelper.createElement({\n                        parent    : expanderElement,\n                        className : me.shadowRootContainerClass,\n                        style     : 'flex : 1'\n                    }),\n                    shadowRoot = shadowRootContainer._shadowRoot = shadowRootContainer.attachShadow({ mode : 'closed' });\n\n                renderPromises.push(DomHelper.cloneStylesIntoShadowRoot(shadowRoot).then(() => {\n                    if (grid.isDestroyed) {\n                        return;\n                    }\n\n                    if (dataField) {\n                        const fieldData = record.getValue(dataField);\n                        // This path is used if field is a StoreDataField\n                        if (fieldData?.isStore) {\n                            widgetConfig.store = fieldData;\n                        }\n                        else if (grid.store[`${dataField}Store`]) {\n                            const relatedStore = grid.store[`${dataField}Store`];\n                            widgetConfig.store = relatedStore.chain(r => record.getValue(dataField).includes(r));\n                        }\n                        else {\n                            widgetConfig.data = fieldData;\n                        }\n                    }\n\n                    if (themeName) {\n                        const\n                            { cls }  = widgetConfig,\n                            themeCls = `b-theme-${themeName.toLowerCase()}`;\n\n                        widgetConfig.cls = cls ? cls + ' ' + themeCls : themeCls;\n                    }\n\n                    recordState.widget = expanderElement.widget = Widget.create(ObjectHelper.assign({\n                        appendTo  : shadowRoot,\n                        owner     : grid,\n                        flex      : 1,\n                        minHeight : '5em',\n                        isNested  : true\n                    }, widgetConfig));\n\n                    if (dataField) {\n                        // If we have created a store, refresh expanded row on store changes\n                        recordState.widget.store.ion({\n                            change  : () => !row.isDestroyed && row.render(),\n                            thisObj : me\n                        });\n                    }\n\n                }).catch((href) => {\n                    throw new Error('Could not load stylesheet ' + href);\n                }));\n            };\n\n        // If another rendering of the same record is made while waiting for async, we should ignore it.\n        if (recordState.isRenderingAsync) {\n            return;\n        }\n\n        Object.assign(recordState, { cellHeight, expandedBodyElements, expanderBodyHeight : 0, loadingIndicators : [] });\n\n        for (const region of grid.regions) {\n            const\n                rowElement = row.getElement(region);\n            let expanderBodyElement = expandedBodyElements[region];\n\n            // class needed at this point to give the expander container correct height\n            row.addCls(me.expandedRowClass);\n\n            if (!expanderBodyElement) {\n                // Create expand container\n                // Expander element needs to be in the DOM for appendTo to work correctly\n                expanderBodyElement = DomHelper.createElement({\n                    parent    : rowElement,\n                    tabIndex  : -1,\n                    className : me.expanderBodyClass,\n                    style     : {\n                        top : cellHeight + 'px'\n                    }\n                });\n\n                me.resizeObserver.observe(expanderBodyElement);\n            }\n\n            let renderResponse;\n\n            if (widget) {\n                createWidget(widget, expanderBodyElement);\n            }\n            else {\n                // The renderer can be async or sync\n                renderResponse = me.renderer({\n                    record, expanderElement : expanderBodyElement, rowElement, region, grid\n                });\n            }\n\n            if (Objects.isPromise(renderResponse)) {\n                renderPromises.push(renderResponse.then(content => continueRendering(content, expanderBodyElement, region)));\n            }\n            else {\n                continueRendering(renderResponse, expanderBodyElement, region);\n            }\n        }\n\n        // If we have async renderer, wait for all to complete\n        if (renderPromises.length) {\n            recordState.isRenderingAsync = true;\n            Promise.all(renderPromises).then(() => {\n                // One of the promises (createWidget) can, while resolving, add another promise to the array\n                // That's why we need to do this twice\n                Promise.all(renderPromises).then(() => {\n                    if (grid.isDestroyed) {\n                        return;\n                    }\n                    // Flag that indicates the completion of expand rendering\n                    recordState.isCreated = true;\n                    // Remove loading indicator\n                    recordState.loadingIndicators?.forEach(li => li.remove());\n                    recordState.loadingIndicators.length = 0;\n\n                    recordState.ignoreResize = false;\n                    recordState.isRenderingAsync = false;\n\n                    // Initiate a render if all current states is created, this code should be executed once for each\n                    // state\n                    for (const [, state] of me.recordStateMap) {\n                        if (!state.isCreated) {\n                            return;\n                        }\n                    }\n\n                    // (?. since we might have been destroyed while waiting for promises)\n                    me.renderRowsWithAnimation?.(record, true);\n\n                });\n            });\n        }\n        else {\n            // Sync rendering\n            recordState.isCreated = true;\n        }\n    }\n\n    /**\n     * Called when grid rows needs to re-render, for example on expand or collapse.\n     * Activates animations on grid, and deactivates them when they are completed.\n     * @private\n     * @param {Core.data.Model} record Record whose row was toggled\n     * @category Internal\n     */\n    renderRowsWithAnimation(record) {\n        const me = this;\n\n        if (me.enableAnimations) {\n            const row = me.client.rowManager.getRowById(record);\n\n            if (row) {\n                me.isAnimating = true;\n\n                if (me.collapsingStateMap.has(record)) {\n                    row.addCls('b-row-is-collapsing');\n                }\n\n                me.waitForTransition(row, () => {\n                    me.isAnimating = false;\n                    if (!row.isDestroyed) {\n                        row.removeCls?.('b-row-is-collapsing');\n                    }\n                });\n            }\n        }\n        return me.bufferedRenderer(record);\n    }\n\n    /**\n     * Collects a rendering call for each record, saves them in array and calls the delayed (RAF) rafRenderer function\n     * @private\n     * @param {Core.data.Model} record Record whose row was toggled\n     * @category Internal\n     */\n    bufferedRenderer(record) {\n        (this._bufferedRecords ?? (this._bufferedRecords = [])).push(record);\n\n        if (!this._rafPromise) {\n            this._rafPromise = new Promise(resolve => {\n                requestAnimationFrame(() => {\n                    this.internalRender?.(resolve);\n                    this._rafPromise = null;\n                });\n            });\n        }\n\n        return this._rafPromise;\n    }\n\n    /**\n     * Re-renders the grid from the topmost record of those saved in bufferedRenderer\n     * @private\n     * @category Internal\n     */\n    internalRender(resolvePromise) {\n        const\n            me                   = this,\n            { _bufferedRecords } = me,\n            { store }            = me.client;\n\n        me.recordStateMap.forEach((state, record) => {\n            if (state.renderPromiseResolver && state.isCreated && !_bufferedRecords.includes(record)) {\n                _bufferedRecords.push(record);\n            }\n        });\n\n        const [top] = _bufferedRecords.sort((a, b) => store.indexOf(a) - store.indexOf(b));\n\n        me.client.rowManager.renderFromRecord(top);\n        _bufferedRecords.length = 0;\n\n        // So that rendering is completed when promises are resolved\n        me.delay(resolvePromise);\n    }\n\n    /**\n     * Called when row is expanded. This function locks all cell's height to current height (before expanding).\n     * @private\n     * @param {HTMLElement} rowElement\n     * @param {Number} cellHeight The height to lock\n     * @param {Boolean} unlock To remove locked cell height when the row is collapsed\n     * @category Internal\n     */\n    lockCellHeight(rowElement, cellHeight, unlock) {\n        for (let a = 0; a < rowElement.children.length; a++) {\n            const child = rowElement.children[a];\n            // Should not lock expander element\n            if (!child.classList.contains(this.expanderBodyClass)) {\n                child.style.height = unlock ? '' : cellHeight + 'px';\n            }\n        }\n    }\n\n    //endregion\n\n    //region Public\n\n    /**\n     * Tells the RowExpander that the provided record should be expanded. If or when the record is rendered into view,\n     * the record will be expanded.\n     *\n     * Promise will resolve when the row gets expanded. Note that this can be much later than the actual expand call,\n     * depending on response times and if current record is in view or not.\n     *\n     * @param {Core.data.Model} record Record whose row should be expanded\n     * @category Common\n     */\n    async expand(record, fromSplit = false) {\n        const me = this;\n\n        if (me.disabled || me.recordStateMap.has(record) || await me.trigger('beforeExpand', { record }) === false) {\n            return;\n        }\n\n        let recordState;\n\n        return new Promise((resolve) => {\n            recordState = {\n                isCreated             : false,\n                renderPromiseResolver : resolve\n            };\n            // Tells renderer that this record should be expanded\n            me.recordStateMap.set(record, recordState);\n\n            // In the event that we have expanded a record which is in collapsing animation state\n            me.collapsingStateMap.delete(record);\n            me._shouldScrollIntoView = true;\n\n            me.renderRowsWithAnimation(record);\n\n            // Propagate to splits\n            if (!fromSplit) {\n                me.client.syncSplits?.(other => other.features.rowExpander.expand(record, true));\n            }\n\n        }).then(() => {\n            me.trigger?.('expand', {\n                record,\n                expandedElements : recordState.expandedBodyElements,\n                widget           : recordState.widget\n            });\n        });\n    }\n\n    /**\n     * Tells the RowExpander that the provided record should be collapsed. If the record is in view, it will be\n     * collapsed. If the record is not in view, it will simply not be expanded when rendered into view.\n     *\n     * @param {Core.data.Model} record Record whose row should be collapsed\n     * @category Common\n     */\n    async collapse(record, fromSplit = false) {\n        const\n            me          = this,\n            recordState = me.recordStateMap.get(record);\n\n        if (me.disabled || await me.trigger('beforeCollapse', { record }) === false) {\n            return;\n        }\n\n        // Unobserve resize\n        if (recordState?.expandedBodyElements) {\n            for (const region in recordState.expandedBodyElements) {\n                me.resizeObserver.unobserve(recordState.expandedBodyElements[region]);\n            }\n        }\n\n        me.recordStateMap.delete(record);\n        me.collapsingStateMap.set(record, recordState);\n\n        await me.renderRowsWithAnimation(record);\n\n        me.trigger('collapse', { record });\n\n        // Propagate to splits\n        if (!fromSplit) {\n            me.client.syncSplits?.(other => other.features.rowExpander.collapse(record, true));\n        }\n    }\n\n    //endregion\n\n    // region Nested navigation\n\n    // Overrides the original, hence the if statement\n    navigateDown() {\n        if (!this.onKeyboardIn()) {\n            return this.overridden.navigateDown(...arguments);\n        }\n    }\n\n    // Chains the original\n    navigateUp() {\n        this.onKeyboardIn(true);\n    }\n\n    // Detects if focus is being reverted here by a nested grid, and focuses either the expanded row or the row below\n    catchFocus({ navigationDirection, source, editing }) {\n        if (this.widget) {\n            const\n                { client }      = this,\n                { focusedCell } = client;\n\n            for (let [record, state] of this.recordStateMap.entries()) {\n                for (const body in state.expandedBodyElements) {\n                    if (state.expandedBodyElements[body].widget === source) {\n                        if (navigationDirection === 'down') {\n                            record = client.store.getNext(record, undefined, true);\n                        }\n\n                        let column;\n                        // If a column has been navigated to earlier, focus that\n                        if (!editing && focusedCell && !focusedCell._isDefaultFocus) {\n                            column = focusedCell.column;\n                        }\n                        // Else, get best candidate\n                        else {\n                            column = this.getNavigateableColumn(client, true, editing && navigationDirection === 'up');\n                        }\n\n                        // In case the cell we want to revert to is the one that was focused previously\n                        client._focusedCell = null;\n\n                        const cellContext = client.normalizeCellContext({ record, column });\n\n                        client.focusCell(cellContext);\n\n                        if (editing) {\n                            client.startEditing(cellContext);\n                        }\n\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n\n    // Detects if the user keyboard navigates either from the expanded row and down, or the row below the expanded row\n    // and up. If so, and there is a Grid in the expanded body, it starts to keyboard navigate there\n    onKeyboardIn(up) {\n        if (this.widget) {\n            const\n                { focusedCell } = this.client,\n                state           = focusedCell && this.recordStateMap.get(focusedCell.record),\n                widget          = state?.expandedBodyElements?.[focusedCell?.column?.region]?.widget;\n\n            if (widget?.isGrid) {\n                let column;\n                // If a column has been navigated to earlier, focus that\n                if (widget.focusedCell && !widget.focusedCell._isDefaultFocus) {\n                    column = widget.focusedCell.column;\n                }\n                // Else, get the best possible candidate\n                else {\n                    column = this.getNavigateableColumn(widget);\n                }\n\n                // In case the cell we want to revert to is the one that was focused previously\n                widget._focusedCell = null;\n\n                widget.focusCell(widget.normalizeCellContext({ record : widget[`${up ? 'last' : 'first'}VisibleRow`], column }));\n\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Get the first column that is not the `checkboxSelectionColumn` and not the expander column.\n     * @param grid\n     * @param editable Also checks that the column has an `editor`\n     * @param reverse If `true`, this functions returns the last column which meets the requirements\n     * @private\n     */\n    getNavigateableColumn(grid, editable = true, reverse = false) {\n        const columns = reverse ? [...grid.columns.visibleColumns].reverse() : grid.columns.visibleColumns;\n\n        return columns.find(c =>\n            c !== grid.checkboxSelectionColumn &&\n            c !== grid.features.rowExpander?._expander &&\n            (!editable || c.editor)\n        ) ?? columns[0];\n    }\n\n    isActionAvailable({ action }) {\n        if (this.isDisabled) {\n            return false;\n        }\n\n        if (['rowExpander.onTab', 'rowExpander.onShiftTab'].includes(action)) {\n            return this.client.features.cellEdit?.isEditing;\n        }\n        // Return true to let customized actions through\n        return true;\n    }\n\n    onTab(previous) {\n        const\n            { client }   = this,\n            { cellEdit } = client.features;\n\n        if (cellEdit?.enabled) {\n            const\n                next             = previous !== true,\n                { activeRecord } = cellEdit,\n                nextCell         = cellEdit.getAdjacentEditableCell(client.focusedCell, next),\n                expandedRecord   = next ? activeRecord : (nextCell ? client.store.getById(nextCell.id) : null),\n                widget           = expandedRecord && this.recordStateMap.get(expandedRecord)?.widget;\n\n            if (activeRecord?.id !== nextCell?.id && widget?.features.cellEdit?.enabled) {\n                cellEdit.finishEditing().then(() => {\n                    const\n                        record = widget[`${next ? 'first' : 'last'}VisibleRow`],\n                        column = this.getNavigateableColumn(widget, true, !next);\n\n                    widget.startEditing(widget.normalizeCellContext({ record, column }));\n                });\n                return true;\n            }\n\n        }\n\n        // KeyMap continues to call action handlers for this shortcut\n        return false;\n    }\n\n    onShiftTab() {\n        return this.onTab(true);\n    }\n\n    // endregion\n\n    doDestroy() {\n        this.resizeObserver?.disconnect();\n        delete this.resizeObserver;\n\n        // destroy any nested widgets\n        for (const [, state] of this.recordStateMap) {\n            state.widget?.destroy();\n        }\n\n        super.doDestroy();\n    }\n\n    onThemeChange({ prev, theme }) {\n        for (const [, entry] of this.recordStateMap) {\n            Object.values(entry.expandedBodyElements).forEach(bodyElement => {\n                const shadowRootContainer = bodyElement.querySelector('.' + this.shadowRootContainerClass);\n                if (shadowRootContainer?._shadowRoot) {\n                    DomHelper.cloneStylesIntoShadowRoot(shadowRootContainer?._shadowRoot, true);\n                    bodyElement.widget?.element?.classList.remove(`b-theme-${prev}`);\n                    bodyElement.widget?.element?.classList.add(`b-theme-${theme}`);\n                }\n            });\n        }\n    }\n\n    /**\n     * Gets the corresponding expanded record from either a nested widget or an element in the expanded body.\n     * @param {HTMLElement|Core.widget.Widget} elementOrWidget\n     * @returns {Core.data.Model}\n     */\n    getExpandedRecord(elementOrWidget) {\n        for (const [rec, obj] of this.recordStateMap.entries()) {\n            if (elementOrWidget.isWidget && obj.widget) {\n                if (obj.widget === elementOrWidget) {\n                    return rec;\n                }\n            }\n            else {\n                const { expandedBodyElements } = obj;\n\n                for (const region in expandedBodyElements) {\n                    const curEl = expandedBodyElements[region];\n\n                    if (curEl === elementOrWidget || curEl.contains(elementOrWidget)) {\n                        return rec;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n}\n\nGridFeatureManager.registerFeature(RowExpander);\n", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport DomDataStore from '../../Core/data/DomDataStore.js';\nimport GridFeatureManager from './GridFeatureManager.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\n\n// <remove-on-release>\n// TODO: Should listen for store search also, to work the other way around\n// TODO: Buggy sometimes, try searching for Barcelona tigers, navigate using buttons\n// TODO: Allow regex\n// TODO: Optional case sensitive\n// TODO: build in UI, popup with keyboard shortcut?\n// </remove-on-release>\n\n/**\n * @module Grid/feature/Search\n */\n\n/**\n * {@inlineexample Grid/feature/Search.js}\n *\n * Feature that allows the user to search the entire grid. Navigate between hits using the\n * keyboard, [F3] or [Ctrl/CMD + G] moves to next, also pressing [Shift] moves to previous.\n *\n * Note that this feature does not include a UI, please build your own and call appropriate methods in the feature.\n * For a demo implementation, see <a href=\"../examples/search/\" target=\"_blank\">Search example</a>.\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * ## Keyboard shortcuts\n *\n * This feature has the following default keyboard shortcuts:\n *\n * | Keys               | Action        | Action description                |\n * |--------------------|---------------|-----------------------------------|\n * | `F3`               | *goToNextHit* | Move focus to next search hit     |\n * | `Shift`+`F3`       | *goToPrevHit* | Move focus to previous search hit |\n * | `Ctrl`+`G`         | *goToNextHit* | Move focus to next search hit     |\n * | `Ctrl`+`Shift`+`G` | *goToPrevHit* | Move focus to previous search hit |\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#Grid/guides/customization/keymap.md)\n *\n * @extends Core/mixin/InstancePlugin\n *\n * @example\n * // enable Search\n * let grid = new Grid({\n *   features: {\n *     search: true\n *   }\n * });\n *\n * // perform search\n * grid.features.search.search('steve');\n *\n * @demo Grid/search\n * @classtype search\n * @feature\n */\nexport default class Search extends Delayable(InstancePlugin) {\n    //region Init\n\n    static $name = 'Search';\n\n    static configurable = {\n        /**\n         * The maximum amount of search hits\n         * @config {Number}\n         * @default\n         */\n        limit : 1000,\n\n        /**\n         * Set to false to not show the search hit index numbers\n         * @config {Boolean}\n         * @default\n         */\n        showHitIndex : true,\n\n        /**\n         * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n         * @config {Object<String,String>}\n         */\n        keyMap : {\n            F3             : 'gotoNextHit',\n            'Ctrl+g'       : 'gotoNextHit',\n            'Shift+F3'     : 'gotoPrevHit',\n            'Ctrl+Shift+g' : 'gotoPrevHit'\n        }\n    };\n\n    static get properties() {\n        return {\n            hitCls          : 'b-search-hit',\n            hitCellCls      : 'b-search-hit-cell',\n            hitCellBadgeCls : 'b-search-hit-cell-badge',\n            hitTextCls      : 'b-search-hit-text'\n        };\n    }\n\n    construct(grid, config) {\n        super.construct(grid, config);\n\n        Object.assign(this, {\n            grid,\n            text       : '',\n            hitEls     : [],\n            treeWalker : grid.setupTreeWalker(grid.element, DomHelper.NodeFilter.SHOW_TEXT, () => DomHelper.NodeFilter.FILTER_ACCEPT)\n        });\n\n        // When new nodes appear due to node expand, include them in the search\n        grid.ion({\n            expandNode : 'onTreeNodeExpand',\n            thisObj    : this\n        });\n    }\n\n    isActionAvailable() {\n        return Boolean(this.text);\n    }\n\n    onTreeNodeExpand() {\n        if (this.text) {\n            this.requestAnimationFrame(this.search, [this.text, false, true]);\n        }\n    }\n\n    doDestroy() {\n        this.clear(true);\n        super.doDestroy();\n    }\n\n    doDisable(disable) {\n        if (disable) {\n            this.clear();\n        }\n\n        super.doDisable(disable);\n    }\n\n    get store() {\n        return this.grid.store;\n    }\n\n    //endregion\n\n    //region Plugin config\n\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['populateCellMenu']\n        };\n    }\n\n    //endregion\n\n    //region Search\n\n    /**\n     * Performs a search and highlights hits.\n     * @param {String} text Text to search for\n     * @param {Boolean} [gotoHit] Go to first hit after search\n     * @param {Boolean} [reapply] Pass true to force search\n     * @param {String[]} [fields] An array of the fields to search for the value in\n     */\n    async search(text, gotoHit = true, reapply = false, fields, fromSplit = false) {\n        const me = this;\n\n        // empty search considered a clear\n        if (!text) {\n            return me.clear();\n        }\n\n        // searching for same thing again, do nothing\n        if (!reapply && text === me.text || me.disabled) {\n            return;\n        }\n\n        const\n            { grid, store } = me,\n            // Only search columns in use\n            columns         = grid.columns.visibleColumns.filter(col => col.searchable !== false),\n            formatters      = [];\n\n        fields      = fields || columns.map(col => {\n            // For date / number columns\n            formatters.push(col.formatValue?.bind(col));\n            return col.field;\n        });\n        const found = store.search(text, fields, formatters);\n\n        if (store.isTree && found.length) {\n            await grid.expandTo(found.map(hit => hit.id));\n        }\n\n        // Only include first result for merged cells in the count\n        for (const column of columns) {\n            if (column.mergeCells && column.isSorted) {\n                let prevValue = null,\n                    belongsTo = null;\n\n                for (const hit of found) {\n                    if (hit.field === column.field) {\n                        const value = hit.data[hit.field];\n                        if (value === prevValue) {\n                            hit.belongsTo = belongsTo;\n                        }\n                        prevValue = value;\n                        belongsTo = `${hit.field}-${hit.id}`;\n                    }\n                }\n            }\n        }\n\n        let i = 1;\n\n        Object.assign(me, {\n            foundMap  : {},\n            prevFound : me.found,\n            found,\n            text,\n            findRe    : new RegExp(`(\\\\s+)?(${StringHelper.escapeRegExp(String(text))})(\\\\s+)?`, 'ig')\n        });\n\n        me.clearHits();\n\n        if (!found) {\n            return;\n        }\n\n        // highlight hits for visible cells\n        for (const hit of found) {\n            // merged cells reuse the index of the first hit in the range\n            me.foundMap[`${hit.field}-${hit.id}`] = hit.belongsTo ? me.foundMap[hit.belongsTo] : i++;\n            // limit hits\n            if (i > me.limit) {\n                break;\n            }\n        }\n\n        if (!me.listenersInitialized) {\n            grid.rowManager.ion({\n                name       : 'renderCell',\n                renderCell : 'renderCell',\n                thisObj    : me\n            });\n            store.ion({\n                name                                : 'storeRefresh',\n                [`refresh${grid.asyncEventSuffix}`] : 'onStoreRefresh',\n                thisObj                             : me\n            });\n            me.listenersInitialized = true;\n        }\n\n        grid.refreshRows();\n\n        grid.trigger('search', { grid, find : text, found });\n\n        if (gotoHit && !me.isHitFocused && !fromSplit) {\n            me.gotoNextHit(true);\n        }\n\n        grid.syncSplits?.(other => other.features.search.search(text, gotoHit, reapply, fields, true));\n\n        return found;\n    }\n\n    clearHits() {\n        // Clear old hits\n        for (const cellElement of DomHelper.children(this.grid.element, '.' + this.hitCls)) {\n            cellElement.classList.remove(this.hitCls, this.hitCellCls);\n\n            // Rerender cell to remove search-hit-text\n            const row = DomDataStore.get(cellElement).row;\n\n            // Merged cells have no row, but they will be cleared anyway by their own DomSync call\n            if (row) {\n                // Need to force replace the markup\n                row.forceInnerHTML = true;\n                row.renderCell(cellElement);\n                row.forceInnerHTML = false;\n            }\n        }\n    }\n\n    /**\n     * Clears search results.\n     */\n    clear(silent = false) {\n        const\n            me       = this,\n            { grid } = me;\n\n        if (me.foundMap) {\n            delete me.foundMap;\n        }\n\n        me.text = null;\n\n        me.clearHits();\n\n        if (me.listenersInitialized) {\n            me.detachListeners('renderCell');\n            me.detachListeners('storeRefresh');\n            me.listenersInitialized = false;\n        }\n\n        if (!silent) {\n            grid.trigger('clearSearch', { grid });\n\n            // Propagate to other grids when splitting\n            grid.syncSplits?.(other => other.features.search.clear());\n        }\n    }\n\n    /**\n     * Number of results found\n     * @readonly\n     * @property {Number}\n     */\n    get foundCount() {\n        return this.found?.length ?? 0;\n    }\n\n    //endregion\n\n    //region Navigation\n\n    /**\n     * Returns true if focused row is a hit\n     * @property {Boolean}\n     * @readonly\n     */\n    get isHitFocused() {\n        const\n            me              = this,\n            { grid }        = me,\n            { focusedCell } = grid;\n\n        if (focusedCell?.cell?.contains(DomHelper.getActiveElement(grid.element))) {\n            const { rowIndex, column } = focusedCell;\n\n            return rowIndex !== -1 && me.found.some(hit =>\n                hit.index === rowIndex && column && hit.field === column.field\n            );\n        }\n    }\n\n    /**\n     * Select the next hit, scrolling it into view. Triggered with [f3] or [ctrl]/[cmd] + [g].\n     */\n    gotoNextHit(fromStart = false) {\n        const\n            me = this;\n\n        if (!me.found?.length) return;\n\n        const\n            { grid, store } = me,\n            fromCell        = grid.focusedCell || grid.lastFocusedCell,\n            currentIndex    = fromCell && fromStart !== true ? store.indexOf(fromCell.record, undefined, true) : -1,\n            nextHit         = me.found.findIndex(hit => hit.index > currentIndex);\n\n        if (nextHit !== -1) {\n            me.gotoHit(nextHit);\n        }\n    }\n\n    /**\n     * Select the previous hit, scrolling it into view. Triggered with [shift] + [f3] or [shift] + [ctrl]/[cmd] + [g].\n     */\n    gotoPrevHit() {\n        const\n            me        = this,\n            { store } = me;\n\n        if (!me.found?.length) return;\n\n        const\n            { grid, found } = me,\n            fromCell        = grid.focusedCell || grid.lastFocusedCell,\n            currentIndex    = fromCell ? store.indexOf(fromCell.record, undefined, true) : 0;\n\n        for (let i = found.length - 1; i--; i >= 0) {\n            const hit = found[i];\n            if (hit.index < currentIndex) {\n                me.gotoHit(i);\n                break;\n            }\n        }\n    }\n\n    /**\n     * Go to specified hit.\n     * @param {Number} index\n     */\n    gotoHit(index) {\n        const\n            { grid } = this,\n            nextHit  = this.found[index];\n\n        if (nextHit) {\n            grid.focusCell({\n                field : nextHit.field,\n                id    : nextHit.id\n            });\n        }\n\n        return Boolean(nextHit);\n    }\n\n    /**\n     * Go to the first hit.\n     */\n    gotoFirstHit() {\n        this.gotoHit(0);\n    }\n\n    /**\n     * Go to the last hit.\n     */\n    gotoLastHit() {\n        this.gotoHit(this.found.length - 1);\n    }\n\n    //endregion\n\n    //region Render\n\n    /**\n     * Called from SubGrid when a cell is rendered. Highlights search hits.\n     * @private\n     */\n    renderCell({ cellElement, column, record, value }) {\n        const\n            me       = this,\n            {\n                treeWalker,\n                findRe,\n                hitTextCls,\n                showHitIndex\n            }        = me,\n            hitIndex = me.foundMap?.[column.field + '-' + record.id];\n\n        if (hitIndex) {\n            // highlight cell\n            cellElement.classList.add(me.hitCls);\n\n            // Remove any previous hit badge\n            showHitIndex && cellElement.querySelector(`.${me.hitCellBadgeCls}`)?.remove();\n\n            // highlight in cell if found in innerHTML\n            const inner = DomHelper.down(cellElement, '.b-grid-cell-value,.b-tree-cell-value') || cellElement;\n\n            if (String(value).toLowerCase() === String(me.text).toLowerCase()) {\n                inner.innerHTML = `<span class=\"${me.hitTextCls}\">${inner.innerHTML}</span>${showHitIndex ? `<div class=\"${me.hitCellBadgeCls}\">${hitIndex}</div>` : ''}`;\n            }\n            // Replace every occurrence of the text in every descendant text node with a span\n            // encapsulating the matched string.\n            else {\n                treeWalker.currentNode = inner;\n                for (let textNode = treeWalker.nextNode(); textNode && inner.contains(textNode);) {\n                    const\n                        nodeToReplace = textNode,\n                        textContent   = textNode.nodeValue,\n                        newText       = ['<span>'];\n\n                    // Move onto next text node before we replace the node with a highlihght HTML sequence\n                    textNode = treeWalker.nextNode();\n\n                    let offset = findRe.lastIndex;\n\n                    // Convert textContent into an innerHTML string which htmlEncodes the text and embeds\n                    // a highlighting span which contains the target text.\n                    for (let match = findRe.exec(textContent); match; match = findRe.exec(textContent)) {\n                        const\n                            preamble    = textContent.substring(offset, match.index),\n                            spaceBefore = match[1] ? '\\xa0' : '',\n                            v           = match[2],\n                            spaceAfter  = match[3] ? '\\xa0' : '';\n\n                        newText.push(`${StringHelper.encodeHtml(preamble)}${spaceBefore}<span class=\"${hitTextCls}\">${StringHelper.encodeHtml(v)}</span>${spaceAfter}`);\n                        offset = findRe.lastIndex;\n                    }\n\n                    newText.push(StringHelper.encodeHtml(textContent.substring(offset)), '<span>');\n\n                    // Insert a fragment with each match wrapped with a span.\n                    nodeToReplace.parentNode.insertBefore(DomHelper.createElementFromTemplate(newText.join(''), {\n                        fragment : true\n                    }), nodeToReplace);\n                    nodeToReplace.remove();\n                }\n\n                if (showHitIndex) {\n                    DomHelper.createElement({\n                        parent    : cellElement,\n                        className : me.hitCellBadgeCls,\n                        text      : hitIndex\n                    });\n                }\n            }\n\n            me.hitEls.push(cellElement);\n        }\n    }\n\n    //endregion\n\n    //region Context menu\n\n    /**\n     * Add search menu item to cell context menu.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown\n     * @param {Core.data.Model} options.record Record for which the menu will be shown\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateCellMenu({ column, record, items, cellElement }) {\n        const me = this;\n\n        if (column.searchable) {\n            items.search = {\n                text        : 'L{searchForValue}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-search',\n                cls         : 'b-separator',\n                weight      : 200,\n                disabled    : me.disabled,\n                onItem      : () => {\n                    // <remove-on-release>\n                    // TODO: Only extract selection from current cell instead? Lazy way for now\n                    // </remove-on-release>\n                    let sel = globalThis.getSelection().toString();\n\n                    if (!sel) {\n                        sel = cellElement.innerText;\n                    }\n\n                    me.search(sel);\n                }\n            };\n        }\n    }\n\n    //endregion\n\n    //region Events\n\n    onStoreRefresh() {\n        this.search(this.text, false, true);\n    }\n\n    //endregion\n}\n\nSearch.featureClass = 'b-search';\n\nGridFeatureManager.registerFeature(Search);\n", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\n\n/**\n * @module Grid/feature/StickyCells\n */\n\n/**\n * A feature which pins configurable content from a grid row to the top of the grid\n * while the row scrolls off the top but is still visible.\n *\n * As soon as the row becomes too small to contain the content, it is unpinned, and\n * scrolls out naturally, and the following row's configured content becomes pinned.\n *\n * For example:\n *\n * ```javascript\n *     new Grid({\n *         features : {\n *             stickyCells : {\n *                 // Identifies elements to clone and pin to the grid top.\n *                 contentSelector : '.myClassName'\n *             }\n *         }\n *     });\n * ```\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype stickyCells\n * @feature\n */\nexport default class StickyCells extends InstancePlugin {\n    //region Config\n\n    static get $name() {\n        return 'StickyCells';\n    }\n\n    static get defaultConfig() {\n        return {\n            /**\n             * A CSS selector which must identify the content within your grid row which you\n             * require to be pinned to the grid while the row if the topmost row, and remains visible.\n             * @config {String}\n             */\n            contentSelector : null,\n\n            currentTopRowCls : 'b-sticky-cells-current-top-row'\n        };\n    }\n\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            before : ['renderRows']\n        };\n    }\n    //endregion\n\n    //region Init\n\n    construct(grid, config) {\n        super.construct(grid, config);\n\n        // We cannot chain our client's onGridScroll because that is now a delayable injected method.\n        grid.ion({\n            scroll  : 'onGridScroll',\n            thisObj : this\n        });\n        Object.assign(this, DomHelper.createElement({\n            reference : 'element',\n            parent    : grid.element,\n            className : 'b-grid-sticky-row',\n            children  : [{\n                reference : 'contentElement',\n                className : 'b-grid-cell'\n            }]\n        }));\n\n        // Clean these classes from copied cell and row classLists\n        this.removeClasses = {\n            'b-focused'             : false,\n            'b-hover'               : false,\n            'b-selected'            : false,\n            [this.currentTopRowCls] : false\n        };\n    }\n\n    renderRows() {\n        // Do not leave stranded sticky row visible on data change\n        this.element.classList.add('b-hide-visibility');\n    }\n\n    onGridScroll() {\n        const\n            me = this,\n            {\n                client : grid,\n                element,\n                contentElement\n            } = me,\n            gridViewport  = Rectangle.client(grid.bodyContainer).roundPx(),\n            currentTopRow = grid.rowManager.getRowAt(gridViewport.y),\n            topRowChanged = currentTopRow !== me.currentTopRow;\n\n        if (currentTopRow) {\n            if (topRowChanged) {\n                if (me.currentTopRow) {\n                    me.currentTopRow.removeCls(me.currentTopRowCls);\n                    me.currentTopRow.removeCls('b-not-enough-height');\n                }\n\n                me.currentTopRow = currentTopRow;\n                currentTopRow.addCls(me.currentTopRowCls);\n\n                contentElement.innerHTML = '';\n                contentElement.appendChild(me.updateStickyContent());\n            }\n\n            // If the outgoing row is not too tall, and doesn't *need* the content\n            // pinning to the top, hide the sticky row, and make the source sticky\n            // elements pin themselves to the bottom of the cell using the b-not-enough-height\n            // class to switch them to align-self: flex-end\n            const notEnoughHeight = me.currentTopRow.bottom - me.client.scrollable.y <= me.stickyContentHeight;\n            me.element.classList[notEnoughHeight ? 'add' : 'remove']('b-hide-visibility');\n            me.currentTopRow[notEnoughHeight ? 'addCls' : 'removeCls']('b-not-enough-height');\n\n            // Keep sticky row aligned while constrained to the viewport.\n            // This keeps it pinned to the top.\n            gridViewport.y += me.stickyContentTop;\n            DomHelper.alignTo(element, me.stickyEls[0], { align : 't0-t0', constrainTo : gridViewport }, true);\n        }\n\n        me.lastProcessedTopRow = currentTopRow;\n    }\n\n    updateStickyContent() {\n        const\n            me            = this,\n            {\n                currentTopRow,\n                removeClasses\n            }             = me,\n            rowClasses   = {\n                'b-grid-sticky-row' : 1\n            },\n            cellClasses  = {},\n            stickyContent = me.stickyContent || (me.stickyContent = document.createDocumentFragment()),\n            stickyEls     = me.stickyEls || (me.stickyEls = []);\n\n        // Release the sticky state on the previous row's sticky elements\n        stickyEls.forEach(e => {\n            e.classList.remove('b-sticky-content-el');\n        });\n\n        // Collect the elements we need to clone from the current top row\n        stickyEls.length = 0;\n        currentTopRow.eachElement(rowEl => {\n            stickyEls.push(...rowEl.querySelectorAll(me.contentSelector));\n        });\n\n        // Clear the documentFragment which we use to hold our clones\n        while (stickyContent.firstChild) {\n            stickyContent.remove(stickyContent.firstChild);\n        }\n\n        me.stickyContentHeight = 0;\n        me.stickyContentTop = 0;\n\n        // Clone the selected elements and measure them for alignment.\n        stickyEls.map(e => {\n            // Collect the app classes that may be necessary on the cell and row elements.\n            e.closest('.b-grid-cell').classList.forEach(cls => cellClasses[cls] = 1);\n            e.closest('.b-grid-row').classList.forEach(cls => rowClasses[cls] = 1);\n\n            // Clean out grid's classes from the class sets.\n            Object.assign(cellClasses, removeClasses);\n            Object.assign(rowClasses,  removeClasses);\n\n            const eTop = e.offsetTop;\n\n            me.stickyContentTop = Math.max(me.stickyContentTop, eTop);\n\n            // We need to know how tall the sticky content is\n            e.style.alignSelf = 'flex-end';\n            me.stickyContentHeight = Math.max(me.stickyContentHeight, me.currentTopRow.height - e.offsetTop + eTop);\n            e.style.alignSelf = '';\n\n            const result = e.cloneNode(true);\n\n            // Tag the content al *after* cloning it.\n            e.classList.add('b-sticky-content-el');\n\n            stickyContent.appendChild(result);\n\n            return result;\n        });\n\n        cellClasses['b-focused'] = false;\n        DomHelper.syncClassList(me.contentElement, cellClasses);\n        DomHelper.syncClassList(me.element, rowClasses);\n\n        return stickyContent;\n    }\n}\n\nGridFeatureManager.registerFeature(StickyCells, false);\n", "import InstancePlugin from '../../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../GridFeatureManager.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\n\n/**\n * @module Grid/feature/experimental/FileDrop\n */\n\n/**\n * An experimental feature that lets users drop files on a Widget. The widget fires an event when a file is dropped onto it.\n * In the event, you get access to the raw files as strings, that were parsed by calling `readAsBinaryString`.\n *\n * NOTE: Currently only supports dropping one file at a time.\n *\n * @experimental\n * @extends Core/mixin/InstancePlugin\n * @classtype fileDrop\n * @feature\n */\nexport default class FileDrop extends InstancePlugin {\n    static $name = 'FileDrop';\n\n    construct(client, config) {\n        const me = this;\n\n        super.construct(client, config);\n\n        // Setup event listeners for dragging files onto the grid element\n        EventHelper.on({\n            element   : client.element,\n            thisObj   : me,\n            drop      : me.onFileDrop,\n            dragover  : me.onFileDragOver,\n            dragenter : me.onFileDragEnter,\n            dragleave : me.onFileDragLeave\n        });\n    }\n\n    onFileLoad(domEvent) {\n\n        this.client.trigger('fileDrop', {\n            file : this.file, domEvent\n        });\n    }\n\n    onFileDragEnter() {\n        // Mouse over styling while dragging a file\n        this.client.element.classList.add('b-dragging-file');\n    }\n\n    onFileDragOver(event) {\n        event.preventDefault();\n    }\n\n    onFileDragLeave(event) {\n        const { element } = this.client;\n\n        if (event.relatedTarget && !element.contains(event.relatedTarget)) {\n            this.client.element.classList.remove('b-dragging-file');\n        }\n    }\n\n    onFileDrop(domEvent) {\n        // Prevent default behavior (prevents the file from being opened)\n        domEvent.preventDefault();\n        const file = domEvent.dataTransfer.items[0].getAsFile();\n\n        /**\n         * Fired when a file is dropped on the widget element\n         * @event fileDrop\n         * @param {Grid.view.Grid} source The owning Grid instance\n         * @param {DataTransferItem} file The dropped file descriptor\n         * @param {DragEvent} domEvent The native DragEvent\n         * @on-owner\n         */\n        this.client.trigger('fileDrop', { file, domEvent });\n\n        this.onFileDragLeave(domEvent);\n    }\n}\n\nGridFeatureManager.registerFeature(FileDrop, false, 'Grid');\n", "import ChipView from '../../Core/widget/ChipView.js';\nimport Store from '../../Core/data/Store.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\n\n/**\n * @module Grid/widget/GroupBar\n */\n\n/**\n * A widget used to manage grouping of a tree with the {@link Grid.feature.TreeGroup} feature. Column headers can be\n * drag-dropped on this widget to regroup the data in the tree store. This widget only handles column-based grouping,\n * and doesn't handle custom group functions.\n *\n * ```javascript\n * const tree = new TreeGrid({\n *     appendTo : 'container',\n *     features : {\n *         treeGroup : {\n *             hideGroupedColumns : true,\n *             levels             : [\n *                 'manager',\n *                 'airline'\n *             ],\n *             parentRenderer : (field, data) => `${StringHelper.capitalize(field)}: ${data.name}`\n *         }\n *     },\n *\n *     columns : [\n *         {\n *             text  : 'Name',\n *             field : 'name',\n *             flex  : 3,\n *             type  : 'tree'\n *         },\n *         {\n *             text   : 'Airline',\n *             field  : 'airline',\n *             align  : 'center',\n *             flex   : 2,\n *         },\n *         {\n *             type  : 'check',\n *             text  : 'Domestic',\n *             field : 'domestic',\n *             align : 'left',\n *             flex  : 1\n *         },\n *         {\n *             type  : 'number',\n *             text  : 'Capacity',\n *             field : 'capacity',\n *             flex  : 1\n *         },\n *         {\n *             type  : 'number',\n *             text  : 'Crew',\n *             field : 'crew',\n *             flex  : 1\n *         }\n *     ],\n *\n *     tbar : [\n *         'Group by',\n *         {\n *             type : 'groupbar'\n *         }\n *     ]\n * ```\n * @classtype groupbar\n * @extends Core/widget/ChipView\n * @demo Grid/tree-grouping\n * @widget\n */\nexport default class GroupBar extends ChipView {\n    static type  = 'groupbar';\n    static $name = 'GroupBar';\n\n    static configurable = {\n        selectedCls : 'not-used',\n        itemTpl(record) {\n            return StringHelper.encodeHtml(StringHelper.capitalize(record.getValue(this.displayField)));\n        }\n    };\n\n    construct() {\n        super.construct(...arguments);\n\n        const treeGrid = this.treeGrid = this.up('gridbase', true);\n\n        if (!treeGrid) {\n            throw new Error('GroupBar must be used inside a Grid component');\n        }\n        treeGrid.ion({\n            paint   : this.onTreePaint,\n            once    : true,\n            thisObj : this\n        });\n    }\n\n    onTreePaint() {\n        const\n            me           = this,\n            { treeGrid } = me,\n            { treeGroup, columnReorder } = treeGrid.features;\n\n        if (!treeGroup) {\n            throw new Error('GroupBar widget requires the TreeGroup feature to be present');\n        }\n\n        columnReorder.usingGroupBarWidget = true;\n\n        me.store = new Store({\n            fields            : ['cls', 'ascending'],\n            internalListeners : {\n                add     : me.onStoreChanged,\n                remove  : me.onStoreChanged,\n                thisObj : me\n            }\n        });\n\n        treeGrid.ion({\n            treeGroupChange          : me.onTreeGroupChanged,\n            beforeColumnDropFinalize : me.onBeforeColumnDropFinalize,\n            columnDrag               : me.onColumnDrag,\n            columnDragStart          : me.onColumnDragStart,\n            columnDrop               : me.onColumnDrop,\n            thisObj                  : me\n        });\n\n        me.onTreeGroupChanged({ levels : treeGroup.levels });\n    }\n\n    onStoreChanged({ records }) {\n        const\n            me           = this,\n            { treeGrid } = me;\n\n        if (!me.treeGrid.isConstructing && records?.[0]?.cls !== 'b-drop-target') {\n            me.ignoreGroupChange               = true;\n            treeGrid.features.treeGroup.levels = me.store.map(({ field }) => field);\n            me.ignoreGroupChange               = false;\n        }\n    }\n\n    onTreeGroupChanged({ levels }) {\n        if (!this.ignoreGroupChange) {\n            if (levels.some(level => level instanceof Function && !level.fieldName)) {\n                throw new Error('GroupBar only supports column grouping');\n            }\n            this.store.data = (levels || []).map(level => {\n                level = level.fieldName || level;\n                return this.treeGrid.columns.get(level);\n            });\n        }\n    }\n\n    onColumnDragStart() {\n        this.store.add({ id : 'placeholder', cls : 'b-drop-target' }); // no-sanity\n    }\n\n    onColumnDrag({ context, column, event }) {\n        const overGroupBar = event.target.closest('.b-groupbar');\n\n        if (overGroupBar) {\n            context.valid = true;\n        }\n    }\n\n    onBeforeColumnDropFinalize({ column, event }) {\n        const droppedOnGroupBar = event.target.closest('.b-groupbar');\n\n        if (droppedOnGroupBar) {\n            if (!column.isTreeColumn) {\n                this.store.getById('placeholder').remove();\n                this.store.add(column);\n            }\n        }\n    }\n\n    onColumnDrop() {\n        this.store.getById('placeholder')?.remove();\n    }\n}\n\nGroupBar.initClass();\n", "import Combo from '../../Core/widget/Combo.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport '../../Grid/view/TreeGrid.js';\n\n/**\n * @module Grid/widget/TreeCombo\n */\n\n/**\n * A powerful {@link Core/widget/Combo} box using a {@link Grid/view/TreeGrid} as its drop down widget. You can define\n * your own set of columns to display and use all the regular features of the Grid.\n *\n * {@inlineexample Grid/widget/TreeCombo.js}\n *\n * ```javascript\n * new TreeCombo({\n *     label    : 'Pick task(s)',\n *     width    : '30em',\n *     appendTo : document.body,\n *     picker   : {\n *         // Define the columns to show in the grid\n *         columns : [\n *             { type : 'tree', text : 'Tasks', field : 'name', flex : 1 },\n *             { text : 'Priority', field : 'prio' }\n *         ]\n *     },\n *     chipView : {\n *         // Render the chips in the combo field\n *         itemTpl(record) {\n *             return StringHelper.xss`${record.name}`;\n *         }\n *     },\n *     store : {\n *         fields     : [\n *             'prio'\n *         ],\n *         data : [\n *             {\n *                 name     : 'Development Tasks',\n *                 expanded : true,\n *                 children : [\n *                     { id : 1, name : 'Improve React docs', prio : 'High' },\n *                     { id : 2, name : 'Build Angular module', prio : 'Low' },\n *                     { id : 3, name : 'Creat Vue project', prio : 'Low' }\n *                 ]\n *             },\n *             { name : 'Customer meeting', prio : 'Normal' },\n *             {\n *                 name     : 'Customer Tasks',\n *                 expanded : true,\n *                 children : [\n *                     { id : 4, name : 'Intro meeting', prio : 'Normal' },\n *                     { id : 5, name : 'Build POC', prio : 'High' },\n *                     { id : 6, name : 'Documentation', prio : 'Low' }\n *                 ]\n *             }\n *         ]\n *     }\n * });\n * ```\n *\n * @extends Core/widget/Combo\n * @classtype treecombo\n * @inputfield\n */\nexport default class TreeCombo extends Combo {\n    static $name = 'TreeCombo';\n\n    static type = 'treecombo';\n\n    static configurable = {\n        multiSelect : true,\n        picker      : {\n            type                       : 'treegrid',\n            minWidth                   : '35em',\n            disableGridRowModelWarning : true,\n            selectionMode              : {\n                row                  : true,\n                rowCheckboxSelection : true\n            }\n        },\n        chipView : {\n            itemTpl(record) {\n                return StringHelper.xss`${record.name}`;\n            },\n            scrollable : {\n                overflowX : 'hidden-scroll'\n            }\n        }\n    };\n\n    changePicker(picker, oldPicker) {\n        picker = super.changePicker(picker, oldPicker);\n\n        picker?.ion({\n            selectionChange : 'onPickerSelectionChange',\n            thisObj         : this\n        });\n\n        return picker;\n    }\n\n    updateMultiSelect(multiSelect) {\n        super.updateMultiSelect(...arguments);\n\n        this.picker.selectionMode.multiSelect = multiSelect;\n    }\n\n    updateReadOnly(readOnly) {\n        super.updateReadOnly(...arguments);\n\n        this.picker.readOnly = readOnly;\n    }\n\n    get value() {\n        return super.value;\n    }\n\n    set value(value) {\n        // indicate we are setting the field value\n        this._settingValue = true;\n\n        super.value = value;\n\n        // select provided value enitres in the picker\n        this.picker.selectedRecords = value.map?.(val => this.store.getById(val)) || [];\n\n        this._settingValue = false;\n    }\n\n    onPickerSelectionChange({ selection }) {\n        // apply selection to value (if we aren't in the middle of value setting)\n        if (!this._settingValue) {\n            this.value = selection;\n        }\n    }\n}\n\nTreeCombo.initClass();\n", "// column\nexport { default as ActionColumn } from '../lib/Grid/column/ActionColumn.js';\nexport { default as AggregateColumn } from '../lib/Grid/column/AggregateColumn.js';\nexport { default as CheckColumn } from '../lib/Grid/column/CheckColumn.js';\nexport { default as ColorColumn } from '../lib/Grid/column/ColorColumn.js';\nexport { default as Column } from '../lib/Grid/column/Column.js';\nexport { default as DateColumn } from '../lib/Grid/column/DateColumn.js';\nexport { default as NumberColumn } from '../lib/Grid/column/NumberColumn.js';\nexport { default as PercentColumn } from '../lib/Grid/column/PercentColumn.js';\nexport { default as RatingColumn } from '../lib/Grid/column/RatingColumn.js';\nexport { default as RowNumberColumn } from '../lib/Grid/column/RowNumberColumn.js';\nexport { default as TemplateColumn } from '../lib/Grid/column/TemplateColumn.js';\nexport { default as TimeColumn } from '../lib/Grid/column/TimeColumn.js';\nexport { default as TreeColumn } from '../lib/Grid/column/TreeColumn.js';\nexport { default as WidgetColumn } from '../lib/Grid/column/WidgetColumn.js';\n\n// data\nexport { default as ColumnStore } from '../lib/Grid/data/ColumnStore.js';\nexport { default as GridRowModel } from '../lib/Grid/data/GridRowModel.js';\n\n// feature\nexport { default as CellCopyPaste } from '../lib/Grid/feature/CellCopyPaste.js';\nexport { default as CellEdit } from '../lib/Grid/feature/CellEdit.js';\nexport { default as CellMenu } from '../lib/Grid/feature/CellMenu.js';\nexport { default as CellTooltip } from '../lib/Grid/feature/CellTooltip.js';\nexport { default as ColumnAutoWidth } from '../lib/Grid/feature/ColumnAutoWidth.js';\nexport { default as ColumnDragToolbar } from '../lib/Grid/feature/ColumnDragToolbar.js';\nexport { default as ColumnPicker } from '../lib/Grid/feature/ColumnPicker.js';\nexport { default as ColumnRename } from '../lib/Grid/feature/ColumnRename.js';\nexport { default as ColumnReorder } from '../lib/Grid/feature/ColumnReorder.js';\nexport { default as ColumnResize } from '../lib/Grid/feature/ColumnResize.js';\nexport { default as FillHandle } from '../lib/Grid/feature/FillHandle.js';\nexport { default as Filter } from '../lib/Grid/feature/Filter.js';\nexport { default as FilterBar } from '../lib/Grid/feature/FilterBar.js';\nexport { default as GridFeatureManager } from '../lib/Grid/feature/GridFeatureManager.js';\nexport { default as Group } from '../lib/Grid/feature/Group.js';\nexport { default as GroupSummary } from '../lib/Grid/feature/GroupSummary.js';\nexport { default as HeaderMenu } from '../lib/Grid/feature/HeaderMenu.js';\nexport { default as MergeCells } from '../lib/Grid/feature/MergeCells.js';\nexport { default as QuickFind } from '../lib/Grid/feature/QuickFind.js';\nexport { default as RegionResize } from '../lib/Grid/feature/RegionResize.js';\nexport { default as RowCopyPaste } from '../lib/Grid/feature/RowCopyPaste.js';\nexport { default as RowExpander } from '../lib/Grid/feature/RowExpander.js';\nexport { default as RowReorder } from '../lib/Grid/feature/RowReorder.js';\nexport { default as Search } from '../lib/Grid/feature/Search.js';\nexport { default as Sort } from '../lib/Grid/feature/Sort.js';\nexport { default as StickyCells } from '../lib/Grid/feature/StickyCells.js';\nexport { default as Stripe } from '../lib/Grid/feature/Stripe.js';\nexport { default as Split } from '../lib/Grid/feature/Split.js';\nexport { default as Summary } from '../lib/Grid/feature/Summary.js';\nexport { default as Tree } from '../lib/Grid/feature/Tree.js';\nexport { default as TreeGroup } from '../lib/Grid/feature/TreeGroup.js';\n\n// feature base\nexport { default as CopyPasteBase } from '../lib/Grid/feature/base/CopyPasteBase.js';\n\n// export feature\nexport { default as ExportDialog } from '../lib/Grid/view/export/ExportDialog.js';\nexport { default as Exporter } from '../lib/Grid/feature/export/exporter/Exporter.js';\nexport { default as ExportOrientationCombo } from '../lib/Grid/view/export/field/ExportOrientationCombo.js';\nexport { default as ExportRowsCombo } from '../lib/Grid/view/export/field/ExportRowsCombo.js';\nexport { default as MultiPageExporter } from '../lib/Grid/feature/export/exporter/MultiPageExporter.js';\nexport { default as MultiPageVerticalExporter } from '../lib/Grid/feature/export/exporter/MultiPageVerticalExporter.js';\nexport { default as PdfExport } from '../lib/Grid/feature/export/PdfExport.js';\nexport { default as SinglePageExporter } from '../lib/Grid/feature/export/exporter/SinglePageExporter.js';\nexport { FileFormat, Orientation, PaperFormat, RowsRange } from '../lib/Grid/feature/export/Utils.js';\n\n// feature experimental\nexport { default as ExcelExporter } from '../lib/Grid/feature/experimental/ExcelExporter.js';\nexport { default as FileDrop } from '../lib/Grid/feature/experimental/FileDrop.js';\n\n// row\nexport { default as Row } from '../lib/Grid/row/Row.js';\n\n// util\nexport { default as Location } from '../lib/Grid/util/Location.js';\nexport { default as TableExporter } from '../lib/Grid/util/TableExporter.js';\n\n// view\nexport { default as Bar } from '../lib/Grid/view/Bar.js';\nexport { default as Footer } from '../lib/Grid/view/Footer.js';\nexport { default as Grid } from '../lib/Grid/view/Grid.js';\nexport { default as GridBase } from '../lib/Grid/view/GridBase.js';\nexport { default as Header } from '../lib/Grid/view/Header.js';\nexport { default as RowManager } from '../lib/Grid/row/RowManager.js';\nexport { default as SubGrid } from '../lib/Grid/view/SubGrid.js';\nexport { default as TreeGrid } from '../lib/Grid/view/TreeGrid.js';\n\n// view mixin\nexport { default as GridElementEvents } from '../lib/Grid/view/mixin/GridElementEvents.js';\nexport { default as GridFeatures } from '../lib/Grid/view/mixin/GridFeatures.js';\nexport { default as GridResponsive } from '../lib/Grid/view/mixin/GridResponsive.js';\nexport { default as GridSelection } from '../lib/Grid/view/mixin/GridSelection.js';\nexport { default as GridState } from '../lib/Grid/view/mixin/GridState.js';\nexport { default as GridSubGrids } from '../lib/Grid/view/mixin/GridSubGrids.js';\n\n// widget\nexport { default as GridFieldFilterPicker } from '../lib/Grid/widget/GridFieldFilterPicker.js';\nexport { default as GridFieldFilterPickerGroup } from '../lib/Grid/widget/GridFieldFilterPickerGroup.js';\nexport { default as GroupBar } from '../lib/Grid/widget/GroupBar.js';\nexport { default as TreeCombo } from '../lib/Grid/widget/TreeCombo.js';\n"],
  "mappings": "k2EAiFe,MAAMA,UAAqBC,CAAO,CAoG7C,IAAIC,qBAAsB,CACtB,MAAO,EACX,CACAC,UAAUC,EAAQC,EAAO,CACrB,MAAMC,EAAK,KACX,MAAMH,UAAU,GAAGI,SAAS,EAExB,CAACH,EAAOI,OAAS,CAACJ,EAAOK,MACzBH,EAAGI,KAAKC,IAAI,CAAEC,MAAQ,kBAAmBC,QAAUP,CAAG,CAAC,EAEvDA,EAAGQ,uBACHR,EAAGI,KAAKK,QAAQC,UAAUC,IAAI,yBAAyB,EAGvDX,EAAGY,WAAaZ,EAAGa,mBACnBb,EAAGc,iBAAmBd,EAAGY,SACzBZ,EAAGY,SAAWZ,EAAGa,iBAEzB,CAKAA,iBAAiB,CAAET,KAAAA,EAAMW,OAAAA,EAAQC,OAAAA,EAAQC,qBAAAA,EAAuB,EAAK,EAAG,CAAA,IAAAC,EACpE,MACIC,EAAeH,GAAW,gBAAiBA,EAAOI,KAClD,CAAEC,QAAAA,CAAQ,EAAKN,EACnB,GAAIE,EAAsB,CAAA,IAAAK,GACtBA,EAAA,KAAKR,oBAAgB,MAAAQ,IAAA,QAArBA,EAAAC,KAAA,KAAwB,GAAGtB,SAAS,EAExC,MAAO,CACHuB,UAAY,CAAE,cAAgB,GAC9BC,UAAQP,EAAIH,EAAOW,WAAOR,MAAAA,IAAdA,OAAAA,OAAAA,EAAgBS,IAAI,CAACC,EAAcC,IAAU,CAAA,IAAAC,EAUrD,GATI,YAAaF,IACR,OAAOA,EAAaG,SAAY,YAAeH,EAAaG,QAAQ,CAAEf,OAAAA,EAAQ,IAAM,IAGrFY,EAAaG,UAAY,KAK5BZ,GAAgB,CAACS,EAAaI,cAAkB,CAACb,GAAgBS,EAAaI,aAC/E,MAAO,GAEX,KACI,CACIC,QAAAA,EACArB,SAAAA,CACJ,EAAOgB,EACPM,EAAQ,OAAOD,GAAY,YAAcA,GAAAA,OAAOH,EAAPG,EAASE,cAAUL,MAAAA,IAAnBA,QAAAA,EAAAP,KAAAU,EAAsB,KAAK,EAAKZ,EAAQe,SAASH,EAASZ,EAAS,CAAC,CAAEL,OAAAA,CAAO,CAAC,CAAC,EAAIiB,GAAW,GAE3I,GAAIrB,EAAU,CACV,MAAMyB,EAAqBhB,EAAQe,SAASxB,EAAUS,EAAS,CAAC,CAC5DQ,MAAAA,EACAb,OAAAA,EACAD,OAAAA,EACAkB,QAAUC,EACVI,OAAUV,CACd,CAAC,CAAC,EAEF,OAAI,OAAOS,GAAuB,SACvB,CACHE,IAAU,OACVC,QAAU,CACN,GAAGC,EAAQC,aAAaR,CAAI,EAC5BL,MAAAA,GAEJc,KAAON,IAIXA,EAAmBG,QAAUH,EAAmBG,SAAW,CAAA,EAC3DH,EAAmBG,QAAQX,MAAQA,EAC5BQ,OAIX,OAAO,CACHE,IAAU,SACVC,QAAU,CACN,GAAGC,EAAQC,aAAaR,CAAI,EAC5BL,MAAAA,GAEJ,aAAeK,EACfV,UAAe,CACX,SAAqB,EACrB,gBAAqB,EACrB,CAACI,EAAagB,GAAG,EAAIhB,EAAagB,GACtC,GAGX,EAET,CAKAC,YAAY,CAAE9B,OAAAA,EAAQC,OAAAA,EAAQ8B,OAAAA,CAAO,EAAG,CAAA,IAAAC,EACpC,GAAIhC,IAAW,MAAQ,CAAC+B,EAAOpC,UAAUsC,SAAS,eAAe,EAC7D,OAEJ,IAAIC,EAAcH,EAAON,QAAQX,MAG5BoB,IACDA,EAAcH,EAAOI,cAAcV,SAAWM,EAAOI,cAAcV,QAAQX,OAE/E,MACIS,GAAMS,EAAUhC,EAAOW,WAAO,MAAAqB,IAAA,OAAA,OAAdA,EAAiBE,CAAW,EAC5CE,EAAgBb,GAAM,KAANA,OAAAA,EAAQc,QACxBD,GACA,KAAKf,SAASe,EAAepC,EAAQ,CAAC,CAAEC,OAAAA,EAAQsB,OAAAA,EAAQQ,OAAAA,CAAO,CAAC,CAAC,CAEzE,CAKAO,iBAAkB,CACd,MACIrD,EAAe,KACfsD,EAAe,CAAA,EACf,CACI5B,QAAU6B,CACd,EAAevD,EAEnB,GAAI,CAACA,EAAGS,QACJ,OAEJ,MAAMiB,EAAU1B,EAAG0B,QAAU,CAAA,EAE7B6B,GAAU,MAAVA,EAAYC,QAAQC,GAAkB,CAClC,MAAMnB,EAAS,CAAE,GAAGmB,GAEpB,OAAOnB,EAAOP,QAEVO,EAAON,cACP,OAAOM,EAAON,aACdsB,EAAaI,KAAKpB,CAAM,GAGxBZ,EAAQgC,KAAKpB,CAAM,CAE3B,CAAC,EAEGgB,EAAaK,OAASjC,EAAQiC,SAC9B3D,EAAG4D,SAAWN,GAElB,MAAMO,EAAcC,EAAUC,cAAc/D,EAAGa,iBAAiB,CAAEE,OAASf,EAAIiB,qBAAuB,GAAO,CAAC,EAAE+C,UAChHhE,EAAGE,MAAQ4D,EAAUG,YAAYJ,EAAa7D,EAAGS,QAAS,GAAMT,EAAGS,QAAQyC,aAAa,EACxFlD,EAAG0B,QAAU6B,CACjB,CACJ,CA7PIW,EADiBxE,EACVyE,OAAO,UACdD,EAFiBxE,EAEV0E,SAAS,CAyBZ,CAAEC,KAAO,UAAWF,KAAO,SAO3B,CAAEE,KAAO,wBAAyBC,aAAe,EAAM,CAAC,GAE5DJ,EApCiBxE,EAoCV6E,WAAW,CAQdC,WAAa,GAQbC,UAAY,GAQZC,SAAW,GAQXC,OAAS,GAQTC,WAAa,GAQbC,WAAa,GAObC,UAAY,GAOZC,SAAW,KA6JnBC,EAAYC,mBAAmBvF,CAAY,EAC3CA,EAAawF,iBAAgB,EAC7BxF,EAAayF,OAAS,eCtSP,MAAMC,UAAwBC,EAAa,CAOtD,WAAWd,UAAW,CAClB,MAAO,CAcHe,SAAW,MAMXC,yBAA2B,GAEnC,CACA1F,UAAU2F,EAAMC,EAAa,CACzB,MAAMzF,EAAK,KACXA,EAAG0F,gBAAkB,UAAWF,EAChCxF,EAAG2F,iBAAmB,WAAYH,EAClC,MAAM3F,UAAU,GAAGI,SAAS,EAC5B,KAAM,CAAEG,KAAAA,CAAK,EAAIqF,EAEbzF,EAAGsF,WAAa,QAChBtF,EAAGsF,SAAW,eAEdlF,IACAJ,EAAGD,MAAQK,EAAKL,MAExB,CACA,IAAIA,MAAMA,EAAO,CACb,MACIC,EAAiB,KACjB4F,EAAiB,CACbC,OAAU,iBACVtF,QAAUP,EACV8F,KAAU,KAEdC,EAAW/F,EAAGgG,OAClB,GAAIjG,IAAUgG,EAAU,CAChBA,GACAA,EAASE,GAAGL,CAAc,EAE9B5F,EAAGgG,OAASjG,EACZ,KACI,CAAEmG,WAAAA,CAAW,EAAInG,EACjBoG,EAAQD,EAAWE,SAASpG,EAAGmG,KAAK,EAGpCA,GAASA,EAAMhC,OAAS,WACnBnE,EAAG0F,kBACJ1F,EAAGqG,MAAQ,OAEVrG,EAAG2F,mBACJ3F,EAAG2E,OAAS,WAGpB5E,EAAMM,IAAIuF,CAAc,EAEhC,CACAU,QAAQtF,EAAQ,CACZ,OAAOA,EAAOuF,MAClB,CACA,IAAIxG,OAAQ,CACR,OAAO,KAAKiG,MAChB,CACAQ,eAAeC,EAAM,CACjB,IAAIC,EAAS,EACb,QAASC,EAAI,EAAG,CAAEhD,OAAAA,GAAW8C,EAAME,EAAIhD,EAAQgD,IAC3CD,GAAUE,WAAWH,EAAKE,CAAC,GAAK,EAAG,EAAE,EAEzC,OAAOD,CACX,CACAG,OAAOJ,EAAM,CACT,IAAIC,EAAS,EACb,KAAM,CAAE/C,OAAAA,CAAO,EAAI8C,EACnB,QAASE,EAAI,EAAGA,EAAIhD,EAAQgD,IACxBD,GAAUE,WAAWH,EAAKE,CAAC,GAAK,EAAG,EAAE,EAEzC,OAAOD,EAAS/C,CACpB,CACAmD,eAAe,CAAE9F,OAAAA,EAAQ+F,QAAAA,CAAQ,EAAG,CAChC,MACI/G,EAAK,KACL,CAAEgH,WAAAA,GAAehH,EAAGI,KACpBJ,EAAGmG,SAASY,GACR/F,EAAOuF,QACPvF,EAAOiG,OAAOC,GAAO,CACjB,MAAMC,EAAMH,EAAWI,UAAUF,CAAG,EACpC,GAAIC,EAAK,CACL,MAAME,EAAcF,EAAIG,QAAQtH,EAAGmG,KAAK,EACpCkB,GACAF,EAAII,WAAWF,CAAW,IAGnC,EAAI,CAGnB,CACAG,YAAYxG,EAAQ,CAAA,IAAAyG,EAChB,IAAIC,EACJ,MACI1H,EAAY,KACZ,CAAEmG,MAAAA,CAAM,EAAInG,EAChB,IAAAyH,EAAIzG,EAAOS,YAAQgG,MAAAA,IAAfA,QAAAA,EAAiB9D,OAAQ,CACzB,MACIgE,EAAW3H,EAAGsF,SACdsC,EAAW,OAAOD,GAAO,UAAY,OAAOE,KAAKF,CAAE,GAAM,WACzD,CACIG,QAAAA,EACAvH,QAAAA,GACAqH,EAAW,CACXE,QAAUD,KAAKF,CAAE,EACjBpH,QAAUsH,IACd,EAAI7H,EAAG+H,gBAAgBJ,CAAE,EAE7BD,EAAQI,EAAQE,MAAMzH,EAASS,EAAOS,SAASE,IAAIsG,GAAKjI,EAAGwH,YAAYS,CAAC,CAAC,CAAC,EACtEjI,EAAGuF,yBACHvE,EAAOkH,IAAI/B,EAAOuB,EAAO,EAAI,EAG7B1G,EAAOmH,QAAQhC,EAAOuB,CAAK,OAI/BA,EAAQ1G,EAAOoH,SAASjC,CAAK,EAEjC,OAAOuB,CACX,CACAW,cAAe,CACX,MAAO,EACX,CACJ,CAjJInE,EAFiBkB,EAEVjB,OAAO,aACdD,EAHiBkB,EAGVhB,SAAS,CACZ,WACA,0BAA0B,GA+IlCY,EAAYC,mBAAmBG,EAAiB,EAAI,EACpDA,EAAgBF,iBAAgB,EAChCE,EAAgBD,OAAS,kBCxKV,MAAMmD,UAAsBjD,EAAa,CAKpD,WAAWd,UAAW,CAClB,MAAO,CACHgE,IAAM,EACNC,IAAM,IAONC,UAAY,GAOZC,aAAe,GACf7D,WAAkB,GAClBD,WAAkB,GAClB+D,gBAAkBA,CAAC,CAAEC,IAAAA,KAAW,GAAEA,KAClCC,QAAkB,GAE1B,CACAC,YAAYhJ,EAAQC,EAAO,CACvB,MAAM,GAAGE,SAAS,EAClB,KAAK8I,gBAAkB,oBAC3B,CA8BAC,gBAAgB,CAAEtB,MAAAA,CAAM,EAAG,CACvBA,OAAAA,EAAQA,GAAS,EACV,CACHlG,UAAkB,sBAClByH,KAAkB,cAClB,gBAAkB,EAClB,gBAAkB,IAClB,gBAAkBvB,EAClBwB,SAAkB,EAClBzH,SAAkB,CACd,CACIc,IAAY,MACZf,UAAY,CACR,gBAAkB,EAClB,SAAkBkG,IAAU,EAC5B,QAAkBA,EAAQ,KAAKgB,cAEnCS,MAAQ,CACJjJ,MAAQwH,EAAQ,KAEpBjG,SAAW,CACP,KAAKgH,UAAY,CACblG,IAAO,OACP6G,KAAO1B,EAAQ,GACnB,EAAI2B,MAAS,EAEpB,EAGb,CAGAC,oBAAqB,CAAA,CACzB,CA9FIpF,EADiBoE,EACVnE,OAAO,WAEdD,EAHiBoE,EAGViB,YAAY,UACnBrF,EAJiBoE,EAIVlE,SAAS,CAAC,YAAa,cAAc,GA4FhDkE,EAAcM,IAAM,UACpB5D,EAAYC,mBAAmBqD,EAAe,EAAI,EAClDA,EAAcnD,OAAS,gBCjGR,MAAMqE,UAAqBnE,EAAa,CAMnD,WAAWd,UAAW,CAClB,MAAO,CACHgE,IAAM,EACNC,IAAM,EAMNiB,UAAY,qBAMZC,WAAa,qBAMbC,SAAW,GACXC,WAAa,SACbhF,WAAa,GACb1E,MAAa,SACb2E,WAAa,GACbE,SAAa,SACbJ,OAAa,GACbkE,QAAa,QAErB,CAKAjI,SAAS,CAAE8G,MAAAA,CAAM,EAAG,CAChB,MAAO,CACHlG,UAAY,CACR,sBAAwB,EACxB,iBAAwB,CAAC,KAAKmI,UAElClI,SAAWoI,GAAYC,SAAS,KAAKtB,IAAK7B,GAAK,CAC3C,MAAMoD,EAASpD,EAAIe,EACnB,MAAO,CACHnF,IAAY,IACZf,UAAY,CACR,gBAA8C,GAC9C,WAA8CuI,EAC9C,UAA8C,CAACA,EAC/C,CAACA,EAAS,KAAKL,WAAa,KAAKD,SAAS,EAAI,EAClD,GAEP,EAET,CACA5G,YAAY,CAAEzC,KAAAA,EAAMW,OAAAA,EAAQC,OAAAA,EAAQ8B,OAAAA,EAAQkH,MAAAA,CAAM,EAAG,CACjD,GAAIlH,EAAOpC,UAAUsC,SAAS,eAAe,GAAK,CAAC5C,EAAK6J,UAAYlJ,EAAO4I,SAAU,CACjF,IAAIO,EAAY,CAAA,EAAGC,QAAQ5I,KAAKuB,EAAOsH,WAAWC,WAAYvH,CAAM,EAChEA,EAAOpC,UAAUsC,SAAS,UAAU,IAAMgH,EAAMM,SAAWN,EAAMO,YACjEL,EAAYA,EAAY,GAGxBlJ,EAAOoH,SAASrH,EAAOoF,KAAK,IAAM,GAAK+D,IAAc,IACrDA,EAAY,IAEhBlJ,EAAOkH,IAAInH,EAAOoF,MAAO+D,EAAY,CAAC,EAE9C,CACJ,CAzEIhG,EADiBsF,EACVgB,QAAQ,gBACftG,EAFiBsF,EAEVrF,OAAO,UAEdD,EAJiBsF,EAIVD,YAAY,UACnBrF,EALiBsF,EAKVpF,SAAS,CAAC,YAAa,aAAc,UAAU,GAsE1DY,EAAYC,mBAAmBuE,EAAc,EAAI,EACjDA,EAAatE,iBAAgB,EAC7BsE,EAAarE,OAAS,eC9EP,MAAMsF,UAAuB9K,CAAO,CAc/C,WAAW4E,UAAW,CAClB,MAAO,CACHM,WAAa,GAErB,CACAiE,YAAYhJ,EAAQC,EAAO,CACvB,MAAM,GAAGE,SAAS,EAClB,MAAMD,EAAK,KACX,GAAI,CAACA,EAAG0K,SACJ,MAAM,IAAIC,MAAM,iCAAiC,EAErD,GAAI,OAAO3K,EAAG0K,UAAa,WACvB,MAAM,IAAIC,MAAM,4CAA4C,CAEpE,CAKA/J,SAASgK,EAAY,CAEjB,GAAI,CAACA,EAAW5J,OAAO6J,aACnB,OAAO,KAAKH,SAAS,CACjBhD,MAASkD,EAAWlD,MACpB1G,OAAS4J,EAAW5J,OACpBmF,MAAS,KAAKA,KAClB,CAAC,CAET,CACJ,CA1CIjC,EADiBuG,EACVtG,OAAO,YACdD,EAFiBuG,EAEVrG,SAAS,CAUZ,UAAU,GAgClBY,EAAYC,mBAAmBwF,EAAgB,EAAI,EACnDA,EAAevF,iBAAgB,EAC/BuF,EAAetF,OAAS,iBC9CT,MAAM2F,UAAmBnL,CAAO,CAM3C,WAAW4E,UAAW,CAClB,MAAO,CAMHwG,OAAS,KACThG,SAAW,IACX6E,WAAa,OAErB,CAOAZ,gBAAgB,CAAEtB,MAAAA,CAAM,EAAG,CACvB,OAAOA,EAAQ,KAAKsD,YAAYtD,CAAK,EAAI,EAC7C,CAKAuD,cAAc,CAAE5D,YAAAA,EAAa6D,YAAAA,CAAY,EAAG,CACxC7D,EAAY8D,UAAY,KAAKH,YAAYE,CAAW,CACxD,CASAF,YAAYtD,EAAO,CAEf,OAAI,OAAOA,GAAU,WACjBA,EAAQ0D,GAAWC,MAAM3D,EAAO,KAAKqD,MAAM,GAExCK,GAAWL,OAAOrD,EAAO,KAAKqD,MAAM,CAC/C,CAOA,IAAIA,OAAOrD,EAAO,CACd,KAAM,CAAE/C,OAAAA,CAAO,EAAI,KACnB,KAAKuD,IAAI,SAAUR,CAAK,EACpB/C,IACAA,EAAOoG,OAASrD,EAExB,CACA,IAAIqD,QAAS,CACT,OAAQ,KAAKO,IAAI,QAAQ,CAC7B,CACA,IAAIC,eAAgB,CAChB,MAAO,CACHlH,KAAS,KAAK8B,MACdhC,KAAS,OACT4G,OAAS,KAAKA,OAEtB,CAEJ,CAvEI7G,EAFiB4G,EAEV3G,OAAO,QAEdD,EAJiB4G,EAIVvB,YAAY,QACnBrF,EALiB4G,EAKV1G,SAAS,CAAC,QAAQ,GAqE7BY,EAAYC,mBAAmB6F,EAAY,EAAI,EAC/CA,EAAW5F,iBAAgB,EAC3B4F,EAAW3F,OAAS,aC1CL,MAAMqG,UAAsBC,EAAc,CAA1C,kCA4BXC,EAAAA,kBAAa,QAfbC,gBAAiB,CACb,MAAMA,eAAc,EACpB,KAAKC,yBAAwB,CACjC,CACAA,0BAA2B,CACvB,MAAM5L,EAAK,KACNA,EAAG6L,OAAOC,cAAcC,KAGpB/L,EAAGgM,2BACRhM,EAAGiM,SAAW,GACd,OAAOjM,EAAGgM,0BAJVhM,EAAGiM,SAAW,EAMtB,CAGA,IAAIC,SAASxE,EAAO,CAChB,KAAKyE,UAAYzE,CACrB,CACA,IAAIwE,UAAW,CAEX,GAAI,KAAKC,WAAa,KAAM,CAAA,IAAAC,EACxB,MAAO,GAAAA,EAAC,KAAKP,OAAOQ,SAASC,YAAQF,MAAAA,IAA7BA,QAAAA,EAA+BG,SAE3C,MAAOC,EAAQ,KAAKL,SACxB,CACA,IAAIM,SAAU,CAAA,IAAAC,EACV,KAAM,CAAEb,OAAAA,CAAO,EAAI,KACnB,MAAOW,GAAQ,CAAC,KAAKP,UAAYJ,EAAOc,cAAchJ,SAE9C,CAACkI,EAAOe,cAAcjJ,QAAM+I,GAAAA,EAC5Bb,EAAOQ,SAASQ,gBAAYH,MAAAA,IAAA,SAA5BA,EAA8BT,UAC9BJ,EAAOiB,aAAejB,EAAOkB,eAAelB,EAAOiB,WAAW,GAE1E,CACA,IAAIE,aAAc,CAAA,IAAAC,EACd,OAAO,KAAKR,SAAW,CAAC,KAAKP,UAAY,GAAAe,EAAC,KAAKpB,OAAOQ,SAASC,YAAQW,MAAAA,IAAA,QAA7BA,EAA+BC,YAAa,CAAC,KAAKrB,OAAO5B,QACvG,CAEAkD,kBAAkB,CAAEC,WAAAA,CAAW,EAAG,CAC9B,OAAO,KAAKX,UAAYW,IAAe,QAAU,KAAKJ,YAC1D,CAKA,MAAMK,KAAM,CACR,MAAM,KAAKC,KAAK,EAAI,CACxB,CAKA,MAAMA,KAAKC,EAAQ,GAAO,CAClB,OAAOA,GAAS,YAChBA,EAAQ,IAEZ,MACIvN,EAAoB,KACpB,CAAE2M,cAAAA,GAAkB3M,EAAG6L,OACvB2B,EAAoBD,EAAQZ,EAAcc,OAAOxF,GAAC,CAAA,IAAAyF,EAAA,MAAI,GAAAA,EAACzF,EAAEjH,UAAM,MAAA0M,IAAA,QAARA,EAAUzD,SAAQ,CAAA,EAAI0C,EACjF,GAAIa,EAAO,CACP,GAAKD,EAAQ,CAACvN,EAAGgN,YAAc,CAAChN,EAAGyM,QAC/B,OAEJ,MAAMkB,EAAmB3N,EAAG4N,cAAcJ,CAAK,EAE/C,GADA,MAAMxN,EAAG6N,iBAAiBF,EAAkBJ,EAAO,CAAEC,MAAAA,CAAM,CAAC,EACxDD,IAAU,GACV,UAAWxB,KAAQyB,EACVzB,EAAKhL,OAAOkJ,UACb8B,EAAK/K,OAAOkH,IAAI6D,EAAKhL,OAAOoF,MAAO,IAAI,EAcnDnG,EAAG6L,OAAOiC,QAAQ,OAAQ,CAAEN,MAAAA,EAAOG,iBAAAA,EAAkBJ,MAAAA,EAAO7B,WAAa1L,EAAG0L,UAAW,CAAC,EAEhG,CAEA,MAAMqC,WAAW,CAAEvI,KAAAA,EAAM+H,MAAAA,EAAOC,MAAAA,CAAM,EAAG,CAarC,OAAO,MAAM,KAAK3B,OAAOiC,QAAQ,aAAc,CAAEN,MAAAA,EAAOhI,KAAAA,EAAM+H,MAAAA,EAAO7B,WAAa,KAAKA,UAAW,CAAC,CACvG,CAUA,MAAMsC,OAAQ,CACV,MACIhO,EAAyB,KACzB,CAAE6L,OAAAA,EAAQH,WAAAA,CAAW,EAAI1L,EACzBiO,EAAyBpC,EAAOc,cAAc,CAAC,EACnD,GAAI,CAAC3M,EAAGgN,aAAe,CAACiB,EACpB,OAEJ,MAAMC,EAAgB,MAAMlO,EAAGmO,kBAAkB,CAAA,EAAI,EAAI,EACzD,GAAI,CAACD,EACD,OAEJ,KAAM,CAAEE,gBAAAA,EAAiBC,YAAAA,CAAY,EAAIrO,EAAGsO,kBAAkBJ,CAAa,EACvErC,EAAOc,cAAchJ,SAAW,GAAK0K,EAAY1K,OAAS,GAC1DkI,EAAO0C,gBAAgBF,EAAY,CAAC,EAAGA,EAAYA,EAAY1K,OAAS,CAAC,CAAC,EAY9EkI,EAAOiC,QAAQ,QAAS,CAAEI,cAAAA,EAAeD,WAAAA,EAAYG,gBAAkB,CAAC,GAAGA,CAAe,EAAG1C,WAAAA,CAAW,CAAC,CAC7G,CAEA,MAAM8C,YAAY,CAAEhJ,KAAAA,CAAK,EAAG,CAYxB,OAAO,MAAM,KAAKqG,OAAOiC,QAAQ,cAAe,CAC5CI,cAAgB1I,EAAMyI,WAAa,KAAKpC,OAAO4C,aAAc/C,WAAa,KAAKA,UACnF,CAAC,CACL,CACAgD,iBAAiB,CAAE1N,OAAAA,EAAQ2N,MAAAA,CAAM,EAAG,CAChC,MAAM3O,EAAK,KACPA,EAAGyM,UACHkC,EAAMC,QAAU,CACZxF,KAAcpJ,EAAG6O,QACjBC,YAAc9O,EACd+O,KAAc,oBACdC,OAAc,IACd/C,SAAcjL,EAAOiJ,UAAY,CAACjK,EAAGgN,YACrCiC,OAAcA,IAAMjP,EAAGqN,IAAG,GAE9BsB,EAAMO,UAAY,CACd9F,KAAcpJ,EAAGmP,UACjBL,YAAc9O,EACd+O,KAAc,sBACdC,OAAc,IACd/C,SAAcjL,EAAOiJ,UAAY,CAACjK,EAAGgN,aAAehN,EAAGoP,iBAAgB,IAAO,GAC9EH,OAAcA,IAAMjP,EAAGgO,MAAK,GAEhCW,EAAMU,SAAW,CACbjG,KAAcpJ,EAAGsP,SACjBR,YAAc9O,EACd4C,IAAc,cACdmM,KAAc,qBACdC,OAAc,IACdC,OAAcA,IAAMjP,EAAGsN,KAAI,GAGvC,CACJ,CAtMIpJ,EADiBsH,EACVhB,QAAQ,iBACftG,EAFiBsH,EAEV+D,eAAe,CAClBC,MAAQ,CACJ,mBAAoB,0BAA0B,IAGtDtL,EAPiBsH,EAOViE,eAAe,CAClBC,mBAAqB,CAACC,EAAcC,UACpCN,SAAY,UACZT,QAAY,SACZM,UAAY,aA6LpB3D,EAAcrG,OAAS,gBAAiB0K,EAAmBC,gBAAgBtE,CAAa,EC5MzE,MAAMuE,UAAoBC,CAAe,CAsBpDnQ,UAAUO,EAAMN,EAAQ,CACpB,MAAMD,UAAUO,EAAM,KAAK6P,cAAcnQ,CAAM,CAAC,CACpD,CACAoQ,SAAU,CACN,MAAMlQ,EAAK,KACXA,EAAGmQ,IAAM1N,EAAQ2N,IAAI,CACjBC,WAAoBrQ,EAAG6L,OAAOpL,QAC9B6P,YAAoB,mEACpBC,WAAoB,IACpBC,WAAoB,GACpB5N,IAAoB,oBACpB6N,QAAoBzQ,EAAG0Q,kBAAkBC,KAAK3Q,CAAE,EAChD4Q,kBAAoB,CAChBC,YAAc,gBACdtQ,QAAcP,GAGlB8Q,UAAY9Q,EAAG+Q,mBACnB,EAAG/Q,EAAGgR,aAAa,EACnBhR,EAAGiR,YAAYjR,EAAGmQ,IAAK,CAAC,aAAc,MAAM,CAAC,CACjD,CACAe,cAAc,CAAEpO,OAAAA,CAAO,EAAG,CACtB,MAAM/B,EAAS,KAAK8K,OAAOsF,qBAAqBrO,CAAM,EAEtD,OAAO/B,EAAOqQ,kBAAoB,IAAS5E,GAAQzL,EAAOqQ,iBAAmB,KAAKA,gBACtF,CAGAnB,cAAcnQ,EAAQ,CAClB,OAAI,OAAOA,GAAW,WACX,CACHsR,gBAAkBtR,GAGnBA,CACX,CAEAuR,UAAUvR,EAAQ,CACd,MAAMuR,UAAU,KAAKpB,cAAcnQ,CAAM,CAAC,CAC9C,CACAwR,WAAY,CACR,KAAKnB,KAAO,KAAKA,IAAIoB,QAAO,EAC5B,MAAMD,UAAS,CACnB,CACAE,UAAUC,EAAS,CACVA,EAGI,KAAKtB,MACV,KAAKA,IAAIoB,QAAO,EAChB,KAAKpB,IAAM,MAJX,KAAKD,QAAO,EAMhB,MAAMsB,UAAUC,CAAO,CAC3B,CAOAf,kBAAkB,CAAEP,IAAAA,EAAKuB,aAAerK,EAAa2C,MAAAA,CAAM,EAAG,CAC1D,MACIhK,EAAS,KACTgB,EAAShB,EAAG6L,OAAO8F,qBAAqBtK,CAAW,EACnDtG,EAASf,EAAG6L,OAAOsF,qBAAqB9J,CAAW,EACnDuK,EAAS,CAAEvK,YAAAA,EAAarG,OAAAA,EAAQD,OAAAA,EAAQiJ,MAAAA,EAAOmG,IAAAA,EAAK0B,YAAc7R,GACtE,IAAI0G,EAEJ,MAAI,CAAC1G,EAAGsQ,aAAetP,IAAWhB,EAAG8R,YAAc9Q,EAAO+Q,aAAe/R,EAAGgS,sBAAwBjR,IAAWf,EAAGiS,WACvGjS,EAAGmQ,IAAI+B,OAElBlS,EAAG8R,WAAa9Q,EAChBhB,EAAGgS,qBAAuBhR,EAAO+Q,WACjC/R,EAAGiS,WAAalR,EAEZA,EAAOqQ,gBACP1K,EAAS3F,EAAOqQ,gBAAgBQ,CAAG,EAG9B5R,EAAGoR,iBAAmBrQ,EAAOqQ,kBAAoB,KACtD1K,EAAS1G,EAAGoR,gBAAgBQ,CAAG,GAG/BO,GAAQC,UAAU1L,CAAM,IACxB1G,EAAG8R,WAAa9R,EAAGgS,qBAAuBhS,EAAGiS,WAAa,MAGzDvL,GACDyJ,EAAIkC,KAAI,EAEL3L,EACX,CAEJ,CAjHIxC,EAFiB6L,EAEVvF,QAAQ,eACftG,EAHiB6L,EAGVN,eAAe,CAelB2B,gBAAkB,OAkG1BrB,EAAY5K,OAAS,cAAe0K,EAAmBC,gBAAgBC,CAAW,ECzInE,MAAMuC,UAAqBtC,CAAe,CAWrDsB,WAAY,CAAA,IAAAiB,GACRA,EAAI,KAAC5N,UAAM,MAAA4N,IAAA,QAAXA,EAAahB,QAAO,EACpB,MAAMD,UAAS,CACnB,CACA,WAAW/B,cAAe,CACtB,MAAO,CACHiD,MAAQ,CAAC,oBAAoB,EAErC,CACAC,mBAAmB,CAAE9D,MAAAA,EAAO5N,OAAAA,CAAO,EAAG,CAClC4N,EAAM+D,OAAS,CACX1D,OAAW,IACXD,KAAW,wBACX3F,KAAW,KAAKuJ,EAAE,WAAW,EAC7B1G,SAAWlL,EAAOkJ,SAClBgF,OAAWA,IAAM,KAAK2D,UAAU7R,CAAM,EAE9C,CACA6R,UAAU7R,EAAQ,CACd,GAAIA,aAAkB8R,MAAO,CAAA,IAAAC,EAEzB/R,GAAM+R,EAAG,KAAKjH,OAAOkH,uBAAuBhS,CAAM,KAAC+R,MAAAA,IAA1CA,OAAAA,OAAAA,EAA4C/R,OAEzD,GAAIA,EAAQ,CACR,GAAIA,EAAOkJ,SAEP,MAAO,GAEX,KAAM,CAAE+I,YAAAA,CAAY,EAAIjS,EACxB,GAAI,CAAE4D,OAAAA,CAAO,EAAI,KACZA,IACD,KAAKA,OAASA,EAAS,IAAIsO,GAAO,CAC9BC,MAAQ,KAAKrH,OACbxF,MAAQ,CACJA,MAAQ,OACZ,CACJ,CAAC,GAEL1B,EAAOwO,OAAOH,CAAW,EACzBrO,EAAOiO,UAAU,CACb9P,OAASkQ,EACThS,OAASD,EACToF,MAAS,MACb,CAAC,EAET,CACJ,CAxDIjC,EADiBoO,EACV9H,QAAQ,gBACftG,EAFiBoO,EAEV7C,eAAe,CAKlB2D,OAAS,CACLC,GAAK,WACT,IAiDRf,EAAanN,OAAS,eAAgB0K,EAAmBC,gBAAgBwC,EAAc,EAAK,EC3D7E,MAAMgB,UAAmBtD,EAAeuD,MAAMC,CAAS,CAAE,CAAzD,kCAmDXC,EAAAA,iBAAY,CACRC,gBAAkB,QARtB/H,gBAAiB,CACb,MAAMA,eAAc,EACf,KAAKE,OAAOC,cAAcC,OAC3B,KAAKE,SAAW,IAEpB,KAAK0H,eAAiB,CAAA,CAC1B,CAIAC,iBAAkB,CACd,KAAKF,gBAAe,CACxB,CACAG,oBAAqB,CACjB,KAAKH,gBAAe,CACxB,CACAI,mBAAoB,CAChB,KAAKJ,gBAAe,CACxB,CACAK,qBAAqB/J,EAAOgK,EAAwB,CAChD,OAAIA,IACAA,EAAyB,CAAChK,EAAMlH,OAAOpC,UAAUsC,SAAS,eAAe,GAEtE,KAAKiR,WAAWF,qBAAqB/J,EAAOgK,CAAsB,CAC7E,CAEAE,sBAAsBC,EAAOC,EAAYC,EAAU,CAC/C,MAAMC,EAAS,CAAA,EAEf,UAAWvI,KAAQoI,EAAO,CACtB,MAAMI,EAAKH,EAAarI,EAAKwI,GAAKxI,EAAKyI,SACvC,IAAI9M,EAAQqE,EAAK/K,OAAOoH,SAAS2D,EAAKhL,OAAOoF,KAAK,EAE9CuB,GAAS,OAAOA,GAAU,UAAY,CAAC+M,MAAM/M,CAAK,IAClDA,EAAQd,WAAWc,CAAK,GAEvB4M,EAAOC,CAAE,IACVD,EAAOC,CAAE,EAAI,CAAA,GAEjBD,EAAOC,CAAE,EAAE7Q,KAAKgE,CAAK,EAGzB,UAAWgN,KAAYJ,EACnBA,EAAOI,CAAQ,EAAEC,QAAU,KAAKC,sBAAsBN,EAAOI,CAAQ,EAAGL,CAAQ,EAEpF,OAAOC,CACX,CACAM,sBAAsBT,EAAOE,EAAU,CACnC,MACIQ,EAAYV,EAAME,EAAW,EAAKF,EAAMxQ,OAAS,CAAE,EACnDgR,EAAY,CACRG,KAAOA,IAAMD,EACbA,UAAAA,GAGR,GAAIV,EAAMY,MAAMC,GAAO,OAAOA,GAAQ,QAAQ,GAAKb,EAAMY,MAAMC,GAAOA,aAAeC,IAAI,EAAG,CACxF,MAAMC,EAAQf,EAAMxS,IAAI,CAACqT,EAAKG,IAAOH,EAAMb,EAAMgB,EAAK,CAAC,CAAC,EACxDD,EAAME,MAAK,EAEP,IAAIC,IAAIH,CAAK,EAAEI,OAAS,IACxBX,EAAQY,WAAaL,EAAM,CAAC,GAAKb,EAAW,GAAK,GACjDM,EAAQG,KAAO,KACPH,EAAQE,qBAAqBI,KAC7BN,EAAQE,UAAY,IAAII,KAAKN,EAAQE,UAAUW,QAAO,EAAKb,EAAQY,UAAU,EAG7EZ,EAAQE,WAAaF,EAAQY,WAE1BZ,EAAQE,iBAKlBV,EAAMxQ,OAAS,IACpBgR,EAAQc,cAAgB,CAAC,GAAGtB,CAAK,EACjCQ,EAAQG,KAAO,KACPH,EAAQe,eAAiBrM,OACzBsL,EAAQe,aAAe,GAGvBf,EAAQe,cAAgB,EACpBf,EAAQe,cAAgBf,EAAQc,cAAc9R,SAC9CgR,EAAQe,aAAe,IAGxBf,EAAQc,cAAcd,EAAQe,YAAY,IAGzD,OAAOf,CACX,CAEAgB,sBAAuB,CACnB,MAAM3V,EAAK,KACX,GAAIA,EAAG6L,OAAO5B,SAAU,CACpBjK,EAAG4V,eAAc,EACjB,OAGAC,EAAaC,YAAW,GACxB9V,EAAG6L,OAAOkK,kBAAkB,IAAM/V,EAAG0T,gBAAgB,EAAI,CAAC,EAE1D1T,EAAG4V,eAAc,GAIjB5V,EAAG0T,gBAAgB,EAAI,CAE/B,CAMAA,iBAAkB,CACd,GAAI,CAAC,KAAKsC,aAAc,CACpB,MAAM7B,EAAQ,KAAK8B,eACf9B,EACA,KAAK+B,wBAAwB/B,EAAM,CAAC,EAAGA,EAAMA,EAAMxQ,OAAS,CAAC,CAAC,EAG9D,KAAKiS,eAAc,EAG/B,CAGAO,YAAYnM,EAAO,CACf,KAAM,CAAE6B,OAAAA,CAAO,EAAI,KACdA,EAAO5B,WACR,KAAK0J,eAAeyC,cAAgBC,EAAYC,GAAG,CAC/C7V,QAAY8V,WACZC,UAAY,CACR1O,QAAU,cACVrH,QAAUoL,EAAO4K,wCAErBC,QAAU,YACVnW,QAAU,IACd,CAAC,EACDyJ,EAAM2M,eAAc,EACpB3M,EAAM4M,yBAAwB,EAC9B5M,EAAM6M,QAAU,GAExB,CAEAC,WAAY,CACR,MACI9W,EAAkB,KAClB,CACI6L,OAAAA,EACAkL,aAAAA,EACAC,YAAAA,CACJ,EAAkBhX,EAClBmU,EAAkBnU,EAAGiW,eACrBgB,EAAkB9C,GAAS4C,GAAgBlL,EAAOqL,oBAAoBH,EAAaI,KAAMJ,EAAaK,EAAE,EACxGzK,GAAkBsK,GAAAA,KAAe,OAAfA,EAAiBtK,gBAAiB,CAAA,EAGpD0K,EAAkBL,EAAchX,EAAGsX,cAC7B3K,EAAcc,OAAO1B,GAAQ,CAACoI,EAAMoD,KAAKC,GAAOA,EAAIC,OAAO1L,EAAM,EAAI,CAAC,CAAC,EAOjF,GANA,OAAO/L,EAAGgX,YACNhX,EAAGgW,eACHnK,EAAO6L,6BAA6B7L,EAAO8C,KAAK,EAChD,OAAO3O,EAAGgW,cAGV,EAACqB,GAAAA,MAAAA,EAAgB1T,QAAQ,CACzB3D,EAAG0T,gBAAe,EAClB,OAIJ,GAFA7H,EAAO8L,eAAc,EAEjBX,EACAK,EAAe7T,QAAQuI,GAAQA,EAAK/K,OAAOkH,IAAI6D,EAAKhL,OAAOoF,MAAO,KAAM,GAAO,GAAO,GAAO,EAAI,CAAC,MAGjG,CACD,KACI,CAACyR,CAAS,EAAIP,EAEdjD,EAAcD,EAAMoD,KAAKC,GAAOA,EAAIxW,SAAW4W,EAAU5W,MAAM,EAE/DqT,EAAcD,EACRwD,EAAUC,YAAc1D,EAAM,CAAC,EAAE0D,YACjCD,EAAUE,SAAW3D,EAAM,CAAC,EAAE2D,SACpCC,EAAc/X,EAAGkU,sBAAsBC,EAAOC,EAAYC,CAAQ,EAClE2D,EAAc,IAAIC,IAClB5D,GACAgD,EAAea,QAAO,EAE1B,UAAWnM,KAAQsL,EAAgB,CAC/B,KAAM,CAAEtW,OAAAA,EAAQC,OAAAA,CAAO,EAAI+K,EAC3B,GAAI,CAAChL,EAAOkJ,UAAYlJ,EAAOsH,aAAa,CAAE8L,MAAAA,EAAOnT,OAAAA,EAAQ+K,KAAAA,CAAK,CAAC,EAAG,CAAA,IAAAoM,EAAAC,EAClE,IAAI1Q,GAAKyQ,EAAKnY,EAAGqY,sBAAkBF,MAAAA,IAAA,OAAA,OAArBA,EAAA5W,KAAAvB,EAAwB,CAAEmU,MAAAA,EAAOpT,OAAAA,EAAQC,OAAAA,EAAQ+K,KAAAA,CAAK,CAAC,EACjEuM,EAAUN,EAAU1M,IAAItK,CAAM,EAC7BsX,IACDA,EAAU,CAAA,EACVN,EAAU9P,IAAIlH,EAAQsX,CAAO,GAE7B5Q,IAAU2B,SAEV3B,EADgBqQ,EAAS3D,EAAarI,EAAKwI,GAAKxI,EAAKyI,QAAQ,EAAEG,QAC/CG,KAAI,GAExBwD,EAAQvX,EAAOoF,KAAK,IAAIiS,EAAArX,EAAOsX,sBAAkB,MAAAD,IAAzBA,OAAAA,OAAAA,EAAA7W,KAAAR,EAA4B,CAAE2G,MAAAA,EAAO1G,OAAAA,EAAQmT,MAAAA,EAAO,IAAKzM,GAGzF,SAAW,CAAC1G,EAAQ+F,CAAO,IAAKiR,EAC5BhX,EAAOkH,IAAInB,EAAS,KAAM,KAAM,KAAM,KAAM,EAAI,EAGxD8E,EAAO0M,cAAc,EAAI,EAEzB1M,EAAO2M,iBAAiBvB,CAAe,EACvC,OAAOjX,EAAG+W,aACV/W,EAAG0T,gBAAe,CACtB,CAEA+E,YAAYzO,EAAO,CAAA,IAAA0O,EAAAC,EACf,MACI3Y,EAAe,KACf,CACI6L,OAAAA,EACAoK,eAAAA,CACJ,EAAejW,EACf4Y,EAAe3C,EAAe,CAAC,EAC/B4C,EAAe5C,EAAeA,EAAetS,OAAS,CAAC,EACvDmV,EAAejN,EAAOkI,qBAAqB/J,EAAO,EAAI,EAC1D,IAAI+O,EAAeD,GAAYjN,EAAOmN,qBAAqBF,EAASC,YAAY,EAChF,KAAIL,EAAAK,KAAY,MAAAL,IAAAC,SAAAA,EAAZD,EAAcO,WAAO,MAAAN,IAAA,OAATA,OAAZA,EAAuBO,UAAWN,EAAMK,QAAQC,OAAQ,CACxD,MACIC,EAAiBlD,EAAesB,KAAK6B,GAAMA,EAAG3B,OAAOsB,EAAc,EAAI,CAAC,EAC5E,IAAI1E,EACCrU,EAAGgW,cACJnK,EAAOwN,4BAA4BxN,EAAO8C,KAAK,EAE/CwK,EAEAnZ,EAAGgX,YAAchX,EAAGsZ,gBACfP,EAAajB,SAAWe,EAAKf,UAAYiB,EAAalB,YAAcgB,EAAKhB,aAI1EkB,EAAajB,UAAYc,EAAMd,UAAYiB,EAAajB,UAAYe,EAAKf,UACzEzD,EAAeuE,EAAMf,YAAckB,EAAalB,YAChDkB,EAAe,IAAIQ,GAAS,CACxBnZ,KAASyL,EACT7K,OAASqT,EAAWuE,EAAM5X,OAAS6X,EAAK7X,OACxCD,OAASgY,EAAahY,MAC1B,CAAC,IAIDsT,EAAeuE,EAAMd,SAAWiB,EAAajB,SAC7CiB,EAAe,IAAIQ,GAAS,CACxBnZ,KAASyL,EACT7K,OAAS+X,EAAa/X,OACtBD,OAASsT,EAAWuE,EAAM7X,OAAS8X,EAAK9X,MAC5C,CAAC,GAIT,MAGIoW,EAAO9C,EAAW0E,EAAeH,EAGjCxB,EAAO/C,GAAa8E,GAAkB,CAACnZ,EAAGgX,YAAe6B,EAAOE,EACpE/Y,EAAG+W,aAAe,CAAEI,KAAAA,EAAMC,GAAAA,GAE1BpX,EAAGgW,aAAe,GAClBhW,EAAGkW,wBAAwBiB,EAAMC,EAAI,EAAI,EAEjD,CAGAlB,wBAAwBiB,EAAMC,EAAIoC,EAAgB,GAAO,CAAA,IAAAC,EACrD,MACIzZ,EAAY,KACZ,CACI6L,OAAAA,EACAkL,aAAAA,EACApD,eAAAA,CACJ,EAAY3T,EACZ0Z,EAAY7N,EAAO8N,SAASxC,EAAKpW,OAAOmY,MAAM,EAAEzY,QAChD,CAAEmZ,EAAAA,CAAE,EAAQC,EAAU1C,KAAKA,EAAKpL,MAAQoL,EAAKpW,OAAON,QAASiZ,CAAQ,EACrE,CAAEI,MAAAA,CAAM,EAAID,EAAU1C,KAAKC,EAAGrL,MAAQqL,EAAGrW,OAAON,QAASiZ,CAAQ,EACjE,CAAEK,EAAAA,GAAUlO,EAAOmO,gBAAgB7C,EAAKnW,OAAQ,EAAI,EACpDiZ,EAAYpO,EAAOmO,gBAAgB5C,EAAGpW,OAAQ,EAAI,EAAEiZ,OAAS,EACjE,GAAI,CACAC,cAAAA,EACAC,cAAAA,CACJ,EAAgBna,EAmBhB,GAlBAA,EAAG4V,eAAe4D,CAAa,EAC1BU,IACDla,EAAGka,cAAgBA,EAAgBpW,EAAUC,cAAc,CACvDvC,UAAY,yBAChB,CAAC,EACDxB,EAAGma,cAAgBA,EAAgBrW,EAAUC,cAAc,CACvDvC,UAAY,eAChB,CAAC,GAELsC,EAAUsW,QAAQF,EAAe,CAAEH,EAAAA,EAAGH,EAAAA,EAAG1Z,MAAS4Z,EAAQF,EAAIS,OAAUJ,EAASF,CAAG,CAAC,EACrFL,EAASY,YAAYJ,CAAa,EAElCpW,EAAUyW,WAAWJ,EAAeF,EAAQH,GAASJ,EAASc,YAAcZ,EAAIE,CAAK,EACrFJ,EAASY,YAAYH,CAAa,EAElCna,EAAGya,kBAAkB,EAAK,EAC1B,OAAOza,EAAGsX,cAENtX,EAAGgX,cAAWyC,EAAIzZ,EAAGiW,kBAAc,MAAAwD,IAAA,QAAjBA,EAAmB9V,OAAQ,CAC7C,MAAM+W,EAAW7O,EAAO8O,SAAS5D,EAAaI,KAAMJ,EAAaK,EAAE,EACnEpX,EAAGsX,cAAgBtX,EAAGiW,eAAexI,OAAO+J,GAAO,CAACkD,EAASnD,KAAKxL,GAAQA,EAAK0L,OAAOD,EAAK,EAAI,CAAC,CAAC,EACjGxX,EAAGya,kBAAiB,EAEnB9G,EAAeiH,cAChBjH,EAAeiH,YAAcvE,EAAYC,GAAG,CACxC7V,QAAYoL,EAAOgP,YACnBC,SAAY,iBACZC,UAAY,cACZxa,QAAYP,CAChB,CAAC,GAELA,EAAGgb,gBAAkB,EACzB,CACAP,kBAAkB9Z,EAAM,GAAM,CAAA,IAAAsa,GAC1BA,EAAI,KAAC3D,iBAAa,MAAA2D,IAAA,QAAlBA,EAAoBzX,QAAQgU,GAAG,CAAA,IAAA0D,EAAA,OAAAA,EAAI,KAAKrP,OAAOvE,QAAQkQ,CAAG,KAAC,MAAA0D,IAAxBA,OAAAA,OAAAA,EAA0Bxa,UAAUya,OAAO,kBAAmBxa,CAAG,EAAE,CAC1G,CACAiV,eAAe4D,EAAgB,GAAO,CAAA,IAAA4B,EAAAC,EAClC,MAAMrb,EAAK,MACXob,EAAApb,EAAGma,iBAAa,MAAAiB,IAAA,QAAhBA,EAAkBE,OAAM,GACxBD,EAAArb,EAAGka,iBAAa,MAAAmB,IAAA,QAAhBA,EAAkBC,OAAM,EACnB9B,GACDxZ,EAAGub,gBAAe,EAEtBvb,EAAGgb,gBAAkB,EACzB,CAEAO,iBAAkB,CACd,MAAMvb,EAAK,KACX,UAAWwb,KAAYxb,EAAG2T,eACtB3T,EAAG2T,eAAe6H,CAAQ,EAAC,EAE/Bxb,EAAG2T,eAAiB,CAAA,CACxB,CAGA,IAAIsC,gBAAiB,OACjB,KACI,CAAEpK,OAAAA,CAAO,EAAW,KACpB,CAAEc,cAAAA,CAAc,EAAId,EACpBsI,GAAoBtI,EAAAA,EAAO4P,oBAAP5P,KAAAA,EAA6Bc,EAAchJ,SAAW,GAAKgJ,EAGnF,MAAI,CAACd,EAAOe,cAAcjJ,QAAUwQ,IAAAA,MAAAA,IAAK,QAALA,EAAOxQ,QAAUwQ,EAAMxQ,SAAWgJ,EAAchJ,QAChFwQ,EAAMY,MAAM2G,GAAM/O,EAAc4K,KAAKoE,GAAMD,EAAGjE,OAAOkE,EAAI,EAAI,CAAC,GAC1DD,EAAGzC,QAAQ2C,QAAUF,EAAGzC,QAAQC,SAAW/E,EAAM,CAAC,EAAE8E,QAAQC,QAAUrN,EAAO9L,MAAM8b,YAAYH,EAAGnH,EAAE,CACxG,EAEOJ,EAEJ,IACX,CACJ,CAtZIjQ,EADiBoP,EACV9I,QAAQ,cACftG,EAFiBoP,EAEV7D,eAAe,CA6BlB4I,mBAAqB,KAMrBiB,cAAgB,KAGpBpV,EAxCiBoP,EAwCV/D,eAAe,CAClBC,MAAW,CAAC,uBAAwB,kBAAmB,qBAAsB,mBAAmB,EAChGsM,SAAW,CAAC,sBAAsB,IA8W1CxI,EAAWnO,OAAS,aAAc0K,EAAmBC,gBAAgBwD,CAAU,EC9a/E,MAAMyI,GAAY,CACdhB,UAAc,YACdiB,UAAc,YACdtF,QAAc,UACduF,UAAc,YACdC,UAAc,YACdC,QAAc,UACdC,YAAc,YACdC,SAAc,WACdC,SAAc,WACdC,QAAc,UACdC,SAAc,WACdC,MAAc,QACdC,YAAc,aAClB,EA6Be,MAAMC,UAAmB3M,CAAe,CAAxC,kCAqCX4M,EAAAA,oBAAe,CAAA,GAEfC,EAAAA,iBAAe,CAAA,GACf,WAAWtN,cAAe,CACtB,MAAO,CACHC,MAAQ,CACJ,mBACA,iBACA,YACA,qBACA,cACA,mBACA,qBACA,cACA,qBAEA,sBAAsB,EAG1BsN,OAAS,CACL,kBAAkB,EAEtBhB,SAAW,CACP,uBACA,sBAAsB,EAGlC,CAGAnQ,gBAAiB,CACb,MACI3L,EAAa,KACb,CAAE6L,OAAAA,CAAO,EAAI7L,EAEjB6L,EAAOkR,YAAY1b,GAAWrB,EAAGgd,aAAa3b,CAAO,CAAC,EAEtDwK,EAAO7E,WAAW3G,IAAI,CAClB4c,WAAa,eACb1c,QAAaP,CACjB,CAAC,EACDA,EAAGkd,UAAUrR,EAAO9L,KAAK,CAC7B,CACAid,aAAa3b,EAAS,CAElBA,EAAQ8b,oBAAsBrZ,EAAUC,cAAc,CAClD6X,OAAYva,EAAQZ,QACpBe,UAAY,CACR,gCAAkC,CACtC,CACJ,CAAC,EAEDH,EAAQhB,IAAI,CACR+c,qBAAuB,gBACvB7c,QAAuB,IAC3B,CAAC,CACL,CACAiR,UAAUC,EAAS,CACV,KAAK4L,gBAEN,KAAKC,YAAc,GACnB,KAAKC,MAAK,EACV,KAAKD,YAAc,IAEvB,MAAM9L,UAAUC,CAAO,CAC3B,CACA+L,kBAAkBC,EAAK,CAEnB,KAAK5R,OAAOpL,QAAQC,UAAUya,OAAO,2BAA4BsC,CAAG,CACxE,CACAC,iBAAiBC,EAAY,CACpB,KAAKN,eACN,KAAKE,MAAM,GAAMI,CAAU,CAEnC,CAGAT,UAAUnd,EAAO,CACb,KAAK6d,gBAAgB,OAAO,EAC5B7d,EAAMM,IAAI,CACNgE,KAAU,QACVwZ,OAAU,gBAEVC,QAAU,CACNhY,KAAO,EACP6B,GAAO,kBAEXpH,QAAU,IACd,CAAC,CACL,CAEAwd,kBAAmB,CACf,KAAKC,cAAa,CACtB,CAEAC,iBAAiBrT,EAAY,CACzB,MACI5K,EAAkC,KAClC,CAAEe,OAAAA,EAAQC,OAAAA,EAAQqG,YAAAA,CAAY,EAAIuD,EAClCvJ,EAAkCrB,EAAG6L,OAAO8N,SAAS5Y,EAAOmY,MAAM,EAEtE,GAAI,CAAClZ,EAAGiM,UAAYlL,EAAOmd,aAAend,EAAOod,UAAY,CAACne,EAAG2d,aAAe,CAAC3c,EAAO6J,cAAgB,CAACxJ,EAAQ+c,UAAW,CACxH,MAAMC,EAAcre,EAAGse,cAActd,EAAQD,CAAM,EAC/Csd,GAAAA,MAAAA,EAAaZ,MAEbpW,EAAY3G,UAAUC,IAAI,eAAe,EAEzC0G,EAAY8D,UAAY,GAExBP,EAAWvD,YAAcgX,EAAYhX,aAGjD,CACAkX,eAAe,CAAEpX,IAAAA,EAAKqX,MAAAA,EAAOC,UAAAA,CAAU,EAAG,CAElCD,IAAUrX,EAAIoN,IAAMkK,IAActX,EAAIkT,SACtC,KAAKqE,cAAgB,GAE7B,CAEA7K,mBAAmB,CAAEvR,OAAAA,EAAQyE,QAAAA,EAAShG,OAAAA,CAAO,EAAG,CAC5C,GAAI,MAAKkL,SAGT,IAAI3J,IAAW,UAAYyE,EAAQmX,YAAc,CAACnd,EAAOmd,WAAY,CAEjE,UAAW/J,KAAS,KAAKyI,aAAa+B,MAAK,EACnCxK,EAAMpT,SAAWA,GACjB,KAAK6d,YAAYzK,CAAK,EAG9B,KAAK0K,QAAO,EACZ,OAEJ,KAAKb,cAAa,EACtB,CAEAc,aAAc,CACV,CAAC,KAAK7S,UAAY,KAAKsR,MAAK,CAChC,CAEAwB,kBAAmB,CACf,CAAC,KAAK9S,UAAY,KAAKsR,MAAK,CAChC,CAEAyB,oBAAqB,CACjB,CAAC,KAAK/S,UAAY,KAAKsR,MAAK,CAChC,CAOA5H,sBAAuB,CACnB,GAAI,CAAC,KAAKsJ,YAAa,CACnB,KACI,CAAEpT,OAAAA,CAAO,EAAI,KACbqT,EAAarT,EAAOsT,gBAAgBxd,IAAIsG,GAAK4D,EAAO9L,MAAMoK,QAAQlC,CAAC,CAAC,EACxE,IAAIqQ,EAAa,GACjB,UAAWnE,KAAS,KAAKyI,aAAc,CACnC,IAAIwC,EAAc,GAElB,QAASzY,EAAIwN,EAAMkL,UAAW1Y,GAAKwN,EAAMmL,SAAWF,EAAazY,IAC7DyY,EAAcF,EAAQK,SAAS5Y,CAAC,EAEhCwN,EAAMqL,aAAeJ,IACrBjL,EAAMqL,WAAaJ,EACnB9G,EAAU,IAIlBA,GAAW,KAAKuG,QAAO,EAE/B,CAIAlN,qBAAqBlR,EAAS,CAAA,IAAAgf,EAC1B,OAAAA,EAAIhf,EAAQif,eAAWD,MAAAA,IAAnBA,QAAAA,EAAqBtL,MACd,KAAKtI,OAAO9L,MAAM4f,MAAMlf,EAAQif,YAAYvL,MAAMkL,SAAS,EAE/D,KAAKpL,WAAWtC,qBAAqBlR,CAAO,CACvD,CAEA0Q,qBAAqB1Q,EAAS,CAAA,IAAAmf,EAC1B,OAAAA,EAAInf,EAAQif,eAAWE,MAAAA,IAAnBA,QAAAA,EAAqBzL,MACd1T,EAAQif,YAAYvL,MAAMpT,OAE9B,KAAKkT,WAAW9C,qBAAqB1Q,CAAO,CACvD,CAIAgS,mBAAmB,CAAE1R,OAAAA,EAAQ4N,MAAAA,CAAM,EAAG,CAC9B5N,EAAO8e,YAAc,KACrBlR,EAAMuP,WAAa,CACf9U,KAAW,2BACX2F,KAAY,aAAYhO,EAAOmd,WAAa,iBAAmB,qBAC/Djc,QAAW,4BACXW,IAAW,cACXoM,OAAW,IACX/C,SAAW,KAAKA,SAChBgD,OAAWA,IAAMlO,EAAOmd,WAAa,CAACnd,EAAOmd,YAGzD,CAIA,MAAM4B,YAAY9V,EAAO,OACrB,GAAI,CAAC,KAAKiV,YAAa,CACnB,MAAMc,EAAqB/V,EAAMlH,OAAOkd,QAAQ,sBAAsB,EACtE,GAAID,EAAoB,CACpB,KACI,CAAElU,OAAAA,CAAO,EAAM,KACf,CAAEsI,MAAAA,GAAa4L,EAAmBL,YAClC,CAAEpT,SAAAA,GAAaT,EAAOQ,SACtB,CAAEtL,OAAAA,CAAO,EAAMoT,EACfhQ,EAAe8b,EAAaC,YAAWnE,EAAAA,GAAU/R,EAAM7F,IAAI,IAApB4X,KAAAA,EAAyB/R,EAAM7F,IAAI,EAC1Egc,EAAe,CACX/f,KAAcyL,EACduU,QAAc,CAAA,EACdrf,OAAAA,EACAsG,YAAc0Y,EAAmBM,kBACjCvd,OAAckH,EAAMlH,OACpBkH,MAAAA,GAER,QAASrD,EAAIwN,EAAMkL,UAAW1Y,GAAKwN,EAAMmL,QAAS3Y,IAC9CwZ,EAAUC,QAAQ1c,KAAKmI,EAAO9L,MAAM4f,MAAMhZ,CAAC,CAAC,EAIhD,GAFAkF,EAAOiC,QAAS,aAAY3J,IAAQgc,CAAS,GAEzC7T,GAAAA,KAAQ,OAARA,EAAUgU,aAAaC,YAAW,KAAQ,OAAMpc,IAAOoc,YAAW,EAAI,CACtE,MAAMpZ,EAAM0E,EAAO7E,WAAWwZ,SAASxW,EAAMyW,OAAO,EACpD,MAAMnU,EAASoU,aAAa,CAAEnM,GAAKpN,EAAIoN,GAAIC,SAAWzT,EAAOwT,EAAG,CAAC,OAG5DvK,EAAM7F,OAAS,SACpB,KAAKwc,aAAa,CAAExM,MAAAA,CAAM,CAAC,GAI3C,CAIAwM,aAAa,CAAExM,MAAAA,CAAM,EAAG,CACpB,MAAMiM,EAAU,CAAA,EAChB,QAASzZ,EAAIwN,EAAMkL,UAAW1Y,GAAKwN,EAAMmL,QAAS3Y,IAC9CyZ,EAAQ1c,KAAK,KAAKmI,OAAO9L,MAAM4f,MAAMhZ,CAAC,CAAC,EAE3C,KAAKkF,OAAOsT,gBAAkBiB,CAClC,CAEAQ,eAAgB,CACZ,CAAC,KAAK3U,UAAY,KAAKsR,MAAK,CAChC,CAEAsD,eAAe,CAAEve,OAAAA,CAAO,EAAG,CAEnBA,IAAW,UAAYA,IAAW,WAClC,CAAC,KAAK2J,UAAY,KAAKsR,MAAM,EAAK,CAE1C,CAKAuD,mBAAmB3M,EAAO,OAAA,IAAA4M,EAAAC,EACtB,MACIpF,EAAS,KAAK/P,OAAOoV,qBAAqB9M,EAAMpT,MAAM,EAAEoc,oBACxD+D,EAAU,GAAE/M,EAAMkL,eAAelL,EAAMpT,OAAOwT,KAGlD,IAAI9T,GAAUsgB,GAAAA,EAAAnF,EAAOuF,aAAS,MAAAJ,IAAA,OAAA,OAAhBA,EAAmBG,CAAM,IAAzBH,KAAAA,GAA0BC,EAAIpF,EAAOwF,iBAAaJ,MAAAA,IAApBA,OAAAA,OAAAA,EAAuBE,CAAM,EAEzE,OAAItF,EAAOwF,eACP,OAAOxF,EAAOwF,cAAcF,CAAM,EAEjCzgB,IACDA,EAAUqD,EAAUC,cAAc,KAAKsd,qBAAqBlN,CAAK,CAAC,GAGtEmN,GAAQC,SAAS3F,EAAQnb,EAASygB,CAAM,EACxC/M,EAAM1T,QAAUA,EAChB0T,EAAM9M,YAAc5G,EAAQ4f,kBACrB5f,CACX,CAEA4gB,qBAAqBlN,EAAO,CAAA,IAAAqN,EACxB,KACI,CAAEzgB,OAAAA,EAAQse,UAAAA,EAAWC,QAAAA,EAASmC,IAAAA,EAAKC,KAAAA,EAAMxhB,MAAAA,EAAOma,OAAAA,CAAO,EAAIlG,EAC3D,CAAEhQ,KAAAA,CAAK,EAAIpD,EACXC,EAAS,KAAK6K,OAAO9L,MAAM4f,MAAMN,CAAS,EAC1CsC,EAAY,CACRngB,UAAY,CACR,sBAAwB,EAExB,aAAwB2S,EAAMqL,YAElCE,YAAc,CACVvL,MAAAA,GAEJhL,MAAQ,CACJsY,IAAAA,EACAC,KAAAA,EACArH,OAAAA,EACAna,MAAAA,GAEJsC,QAAU,CACN0e,OAAY,GAAE7B,OAAete,EAAOwT,KACpC8K,UAAAA,EACAC,QAAAA,EACAve,OAAWA,EAAOoF,MAClBqO,SAAWzT,EAAOwT,IAEtB9S,SAAW,CAEP,CACID,UAAY,IAAIogB,GAAa,KAAK/V,OAAOgW,OAAO,EAAEC,OAAO,CACrD,CAAE,KAAI3d,GAAAA,KAAAA,OAAAA,EAAMoc,YAAW,QAAS,EAAIpc,EACpC,CAACpD,EAAO8gB,OAAO,EAAqB9gB,EAAO8gB,QAC3C,CAAC9gB,EAAOgI,eAAe,EAAahI,EAAOgI,eAC/C,CAAC,EAAE+Y,OAAO/gB,EAAOghB,OAAO,EAExBC,aAAe,GAEftC,YAAe,CACXvL,MAAAA,GAGJ3R,QAAU,CACNzB,OAAWA,EAAOoF,MAClBqO,SAAWzT,EAAOwT,IAGtBpL,MAAQ,CACJkR,OAAS,KAAKxO,OAAO7E,WAAWib,SACpC,EACH,GAIb,OAAAT,EAAAzgB,EAAOmhB,kBAAc,MAAAV,IAAA,QAArBA,EAAAjgB,KAAAR,EAAwB,CAAE4gB,UAAAA,EAAWja,MAAQ3G,EAAOyG,YAAYxG,CAAM,EAAGA,OAAAA,EAAQD,OAAAA,EAAQse,UAAAA,EAAWC,QAAAA,CAAQ,CAAC,EACtGqC,CACX,CACAQ,uBAAuB9C,EAAWC,EAAS8C,EAAM,CAAA,IAAAC,EAAAC,EAC7C,MACItiB,EAAiB,KACjB,CAAE6L,OAAAA,CAAO,EAAQ7L,EACjB,CAAEgH,WAAAA,CAAW,EAAI6E,EAKrBwT,EAAYA,GAAAA,KAAAA,GAASgD,EAAIrb,EAAWub,UAAMF,MAAAA,IAAjBA,OAAAA,OAAAA,EAAmBG,UAC5ClD,EAAUA,GAAAA,KAAAA,GAAOgD,EAAItb,EAAWyb,aAASH,MAAAA,IAApBA,OAAAA,OAAAA,EAAsBE,UAC3C,MAEIE,EAAe7W,EAAO8W,QAAQC,OAAO,CAACjhB,EAAKuX,KACvCvX,EAAIuX,CAAM,EAAI,CACV1X,UAAY,CACR,gCAAkC,GAEtCC,SAAW,CAAA,GAERE,GACR,CAAA,CAAE,EAET,UAAWwS,KAASnU,EAAG4c,aACfzI,EAAMsJ,KAAOtJ,EAAMkL,WAAaC,GAAWnL,EAAMmL,SAAWD,IAE5Drf,EAAG6iB,YAAY1O,EAAOnU,EAAG0e,cAAe0D,CAAI,EAE5CM,EAAavO,EAAMpT,OAAOmY,MAAM,EAAEzX,SAASiC,KAAK1D,EAAGqhB,qBAAqBlN,CAAK,CAAC,GAGtF,OAAOuO,CACX,CACA7D,QAAQiE,EAAQ,GAAO,CACnB,MACI9iB,EAAiB,KACjB,CAAE6L,OAAAA,CAAO,EAAQ7L,EACjB,CAAEgH,WAAAA,CAAW,EAAI6E,EAErB,GAAI,CAACiX,GAAS,CAAC9b,EAAWub,QAAUviB,EAAGiM,UAAY,CAACjM,EAAGsd,YACnD,OAEJ,MAAMoF,EAAe,KAAKP,uBAAsB,EAEhDtW,EAAOkR,YAAY1b,GAAW,CAC1BigB,GAAQyB,KAAK,CACTC,cAAgB3hB,EAAQ8b,oBACxB8F,YAAgB,SAChBtB,UAAgBe,EAAarhB,EAAQ6X,MAAM,CAC/C,CAAC,CACL,CAAC,EACDlZ,EAAG0e,cAAgB,EACvB,CAEAwE,cAAe,CACX,KAAKrE,QAAO,CAChB,CAKAD,YAAYzK,EAAO,CACftK,GAAYyR,OAAO,KAAKsB,aAAczI,CAAK,EAC3C,QAAStS,EAAQsS,EAAMkL,UAAWxd,GAASsS,EAAMmL,QAASzd,IACtD,OAAO,KAAKgb,UAAW,GAAEhb,OAAWsS,EAAMpT,OAAOwT,IAAI,CAE7D,CAEAgJ,MAAM4F,EAAS,GAAML,EAAQ,GAAO,CAChC,MACI9iB,EAAY,KACZojB,EAAYpjB,EAAG6L,OAAOuX,QAAQC,eAAe5V,OAAO6V,GAAKA,EAAEpF,aAAeoF,EAAEnF,UAAY,CAACne,EAAG2d,YAAcmF,GAAQ,EAAI,EACtHS,EAAYvjB,EAAG4c,aAAajZ,OAGhC,GAFA3D,EAAG4c,aAAe,CAAA,EAClB5c,EAAG6c,UAAY,CAAA,EACXsG,GAAU,CAACnjB,EAAG6L,OAAO2X,iBAAkB,CACvC,UAAWrc,KAAOnH,EAAG6L,OAAO7E,WAAWob,KACnC,UAAWrhB,KAAUqiB,EACjBjc,EAAII,WAAWJ,EAAIG,QAAQvG,EAAOwT,EAAE,CAAC,EAI7CvU,EAAG6e,QAAQ0E,GAAa,CAACvjB,EAAG6L,OAAO7E,WAAWyc,QAAQ,EAE9D,CAEAzF,eAAgB,CACZ,KACI,CAAEpB,aAAAA,CAAa,EAAI,KACnBzV,EAAmB,KAAK0E,OAAO7E,WAAWub,OAC1CmB,EAAmB,IAAIzL,IAC3B,UAAW9D,KAASyI,EAAa+B,MAAK,EAAI,CACtC,KACI,CAAE5d,OAAAA,CAAO,EAAKoT,EACd9M,EAAcF,EAAIG,QAAQvG,EAAOwT,EAAE,EAEvC,GAAIlN,EAAa,CACb,IAAIsc,EAASD,EAAUpY,IAAIvK,CAAM,EAC5B4iB,GAEDD,EAAUxb,IAAInH,EAAQ4iB,EAAS9J,EAAU1C,KAAK9P,EAAaA,EAAYnE,aAAa,CAAC,EAEzFiR,EAAMuN,KAAOiC,EAAOjC,KACpBvN,EAAMjU,MAAQyjB,EAAOzjB,WAIrB,KAAK0e,YAAYzK,CAAK,EAG9B,KAAK0K,QAAO,CAChB,CAGAgE,YAAY1O,EAAO2O,EAAOV,EAAO,KAAM,CACnC,KACI,CAAEriB,MAAAA,EAAOiH,WAAAA,GAAyB,KAAK6E,OACvC,CAAE+X,YAAAA,EAAaC,eAAAA,CAAe,EAAI1P,EAClC,CAAE2P,gBAAAA,CAAgB,EAAgB9c,EACtC,GAAI,CAAEqY,UAAAA,EAAWC,QAAAA,CAAQ,EAAInL,EACzBoO,EAAQE,EAGZ,GAFAK,EAAQV,EAAOA,EAAKze,OAAS,EAAImf,EAE7B,GAACA,GAASc,GAAeC,GAG7B,IAAI,CAACD,GAAed,EAAO,CACvB,GAAIV,EAAM,CACN,MAAMvgB,EAAQugB,EAAK2B,UAAU5c,GAAOA,EAAIqb,WAAanD,CAAS,EAC9DkD,EAASH,EAAKvgB,CAAK,EACnBwd,EAAYkD,EAAOC,cAGnB,IACID,EAASvb,EAAWgd,WAAWjkB,EAAM4f,MAAMN,CAAS,CAAC,QAElD,CAACkD,GAAUlD,IAAcC,GAGpCnL,EAAMyP,YAAevE,IAAclL,EAAMkL,UACzC,MAAM4E,EAAY5E,EAAYlL,EAAMkL,UACpClL,EAAMsN,IAAMc,EAAOd,IAAMwC,GAAa7B,EAAOG,EAAO2B,aAAeJ,GAEvE,GAAI,CAACD,GAAkBf,EAAO,CAC1B,GAAIV,EAAM,CAEN,MAAMvgB,EAAQugB,EAAK2B,UAAU5c,GAAOA,EAAIqb,YAAclD,CAAO,EAC7DmD,EAAYL,EAAKvgB,IAAU,GAAKugB,EAAKze,OAAS,EAAI9B,CAAK,EACvDwd,EAAYoD,EAAUD,cAGtB,IACIC,EAAYzb,EAAWgd,WAAWjkB,EAAM4f,MAAML,CAAO,CAAC,QAEnD,CAACmD,GAAanD,KAAYD,GAGrClL,EAAM0P,eAAkBvE,IAAYnL,EAAMmL,QAC1C,MAAM6E,EAAYhQ,EAAMmL,QAAUA,EAClCnL,EAAM8F,OAASwI,EAAUxI,OAASkK,GAAa/B,EAAOK,EAAUyB,aAAeJ,GAEnF3P,EAAMkG,OAASlG,EAAM8F,OAAS9F,EAAMsN,IACxC,CAGAnD,cAActd,EAAQD,EAAQ,CAC1B,GAAIC,EAAO6J,aACP,OAEJ,MACI7K,EAAgB,KAChB,CAAE6c,UAAAA,CAAU,EAAI7c,EAChB,CAAED,MAAAA,GAAcC,EAAG6L,OACnB1E,EAAgBnH,EAAG6L,OAAO7E,WAAWub,OACrC/N,EAAgBzT,EAAOwT,GACvB1S,EAAgB9B,EAAMoK,QAAQnJ,CAAM,EACpCojB,EAAiB,GAAEviB,OAAW2S,IAClC,IAAIL,EAAQ0I,EAAUuH,CAAG,EACzB,GAAI,CAACjQ,EAAO,CACR,MAAMzM,EAAQ3G,EAAOyG,YAAYxG,CAAM,EACvCmT,EAAQ0I,EAAUuH,CAAG,EAAI,CACrBrjB,OAAAA,GAEJf,EAAG4c,aAAalZ,KAAKyQ,CAAK,EAE1B,IAAIkQ,EAAeC,EAAcC,EAAe1iB,EAChD,GACIwiB,EAAgBtkB,EAAM4f,MAAM,EAAE4E,CAAY,EAC1CD,EAAgBD,GAAiBtjB,EAAOyG,YAAY6c,CAAa,EAC7DC,IAAiB5c,IACjBmV,EAAW,GAAE0H,OAAkB/P,GAAU,EAAIL,SAE5CkQ,GAAiBC,IAAiB5c,GAE3C,IAAI8c,EAAaC,EAAYC,EAAa7iB,EAC1C,GACI2iB,EAAczkB,EAAM4f,MAAM,EAAE+E,CAAU,EACtCD,EAAcD,GAAezjB,EAAOyG,YAAYgd,CAAW,EACvDC,IAAe/c,IACfmV,EAAW,GAAE6H,OAAgBlQ,GAAU,EAAIL,SAE1CqQ,GAAeC,IAAe/c,GAIvC,GAHAyM,EAAMkL,UAAYkF,EAAe,EACjCpQ,EAAMmL,QAAYoF,EAAa,EAE3BvQ,EAAMmL,QAAUnL,EAAMkL,UAAY,EAAG,CACrC,MACIhY,EAAcF,EAAIG,QAAQkN,CAAQ,EAClCmQ,EAAc9K,EAAU1C,KAAK9P,EAAaA,EAAYnE,aAAa,EACvEiR,EAAMuN,KAAQiD,EAAWjD,KACzBvN,EAAMjU,MAAQykB,EAAWzkB,MACzBiU,EAAMsJ,IAAM,IAGpB,MAAI,CAACtJ,EAAM1T,SAAW0T,EAAMsJ,KACxBzd,EAAG8gB,mBAAmB3M,CAAK,EAExBA,CACX,CAEJ,CA1lBIjQ,EAFiByY,EAEVnS,QAAQ,cACftG,EAHiByY,EAGVlN,eAAe,CAmBlBwP,YAAc,GAYdtB,WAAa,KA2jBrBhB,EAAWxX,OAAS,aAAc0K,EAAmBC,gBAAgB6M,CAAU,ECnmBhE,MAAMiI,UAAkB5U,CAAe,CAsBlD,WAAWT,cAAe,CACtB,MAAO,CACHC,MAAQ,CAAC,oBAAqB,gBAAgB,EAEtD,CAGA,WAAWqV,YAAa,CACpB,MAAO,CACHC,OAAkB,cAClBC,WAAkB,mBAClBC,gBAAkB,yBAClBC,WAAkB,mBAE1B,CACAplB,UAAUO,EAAMN,EAAQ,CACpB,MAAMD,UAAUO,EAAMN,CAAM,EAC5BolB,OAAOpD,OAAO,KAAM,CAChB1hB,KAAAA,EACA+kB,WAAa/kB,EAAKglB,gBAAgBhlB,EAAKK,QAASqD,EAAUuhB,WAAWC,UAAW,IAAMxhB,EAAUuhB,WAAWE,aAAa,CAC5H,CAAC,CACL,CACApY,mBAAoB,CAChB,KAAM,CAAEL,YAAAA,GAAgB,KAAK1M,KAC7B,MAAO,CAAC,KAAK6L,WAAYa,GAAAA,KAAAA,OAAAA,EAAa9L,SAAU,CAAC8L,EAAY0Y,cAAgB,KAAKC,KAAK9hB,OAAS,CACpG,CACA6N,UAAUC,EAAS,CACXA,GACA,KAAKiU,MAAK,EAEd,MAAMlU,UAAUC,CAAO,CAC3B,CACA,IAAI1R,OAAQ,CACR,OAAO,KAAKK,KAAKL,KACrB,CAOA4lB,eAAgB,CACZ,MACI3lB,EAAW,KACX,CAAEI,KAAAA,CAAK,EAAIJ,EACX4lB,EAAWxlB,EAAKylB,iBAAiB7lB,EAAGwU,QAAQ,EAChD,GAAIoR,EAAQ,CACR,GAAI,CAAC5lB,EAAG8lB,YAAa,CACjB,KAAM,CAACrlB,EAAS0F,EAAO4f,CAAK,EAAIjiB,EAAUC,cAAc,CACpDxB,IAAY,MACZf,UAAY,qBACZC,SAAY,CACR,CAAEc,IAAM,MAAOf,UAAY,mBAAoB,EAC/C,CAAEe,IAAM,MAAOf,UAAY,oBAAqB,CAExD,EAAG,CAAEwkB,UAAY,EAAK,CAAC,EACnBhmB,EAAGimB,OAAS,SACZL,EAAOtL,YAAY7Z,CAAO,GAG1BA,EAAQe,WAAa,yBACrBpB,EAAKK,QAAQ6Z,YAAY7Z,CAAO,GAEpCT,EAAG8lB,YAAc,CACbF,OAAYnlB,EACZ0F,MAAAA,EACA4f,MAAAA,EACAG,UAAYN,GAGpB5lB,EAAG8lB,YAAY3f,MAAMgF,UAAYnL,EAAGylB,KACpCzlB,EAAG8lB,YAAYC,MAAM5a,UAAYnL,EAAGmmB,MAAMxiB,OAC1CiiB,EAAOllB,UAAUC,IAAI,qBAAqB,GAEzCilB,GAAUxlB,EAAKgmB,cAAgB,CAACpmB,EAAGqmB,4BACpCjmB,EAAK4G,WAAW3G,IAAI,CAChBimB,WAAatmB,EAAGuH,WAChBhH,QAAaP,CACjB,CAAC,EACDA,EAAGqmB,0BAA4B,GAEvC,CAMAE,eAAgB,CACZ,MACIvmB,EAAwB,KACxB,CAAEI,KAAAA,EAAM0lB,YAAAA,CAAY,EAAI9lB,EAE5B,UAAWwmB,KAAQxmB,EAAGymB,WAAazmB,EAAGmmB,MAAQ,CAC1C,MAAMhf,EAAM/G,EAAK4jB,WAAWwC,EAAIjS,EAAE,EAClC,GAAIpN,EAAK,CAELA,EAAIuf,eAAiB,GACrB,MAAMrf,EAAcF,EAAIG,QAAQtH,EAAGwU,QAAQ,EAC3CnN,EAAYsf,SAAW,KACvBxf,EAAII,WAAWF,CAAW,EAC1BF,EAAIuf,eAAiB,IAGzBZ,IACAA,EAAYF,OAAOxb,WAAWwc,YAAYd,EAAYF,MAAM,EAC5DE,EAAYI,UAAUxlB,UAAU4a,OAAO,qBAAqB,EAC5Dtb,EAAG8lB,YAAc,MAEjB9lB,EAAGqmB,4BACHjmB,EAAK4G,WAAWf,GAAG,CAAEqgB,WAAatmB,EAAGuH,YAAcvH,CAAE,EACrDA,EAAGqmB,0BAA4B,IAEnCjmB,EAAK0N,QAAQ,eAAe,CAChC,CAQA+Y,OAAOpB,EAAMqB,EAAkB,KAAKtS,SAAUuS,EAAY,GAAO,CAAA,IAAAC,EAC7D,MACIhnB,EAAW,KACX,CAAEI,KAAAA,CAAK,EAAIJ,EACXe,EAAWX,EAAKgjB,QAAQ6D,QAAQH,CAAe,GAAK1mB,EAAKgjB,QAAQ9X,IAAIwb,CAAe,EACpFX,EAAWnmB,EAAGD,MAAMmnB,YAAYnmB,EAAOoF,MAAOsf,EAAM1kB,EAAOmd,YAAcnd,EAAOod,QAAQ,EAC5F,IAAIxX,EAAI,EACRue,OAAOpD,OAAO9hB,EAAI,CACdmnB,SAAY,CAAA,EACZV,UAAYzmB,EAAGmmB,MACfA,MAAAA,EACAV,KAAAA,EACAjR,SAAYzT,EAAOwT,GACnB6S,OAAY,IAAIC,OAAQ,WAAUpH,EAAaqH,aAAaC,OAAO9B,CAAI,CAAC,YAAa,IAAI,CAC7F,CAAC,EACGA,EACAzlB,EAAG2lB,cAAa,EAGhB3lB,EAAGumB,cAAa,EAGpB,UAAWlf,KAAevD,EAAUrC,SAASrB,EAAKK,QAAU,IAAGT,EAAG8kB,QAAQ,EACtEzd,EAAY3G,UAAU4a,OAAOtb,EAAG8kB,OAAQ9kB,EAAG+kB,UAAU,EACjD1d,EAAYmgB,mBACZngB,EAAY8D,UAAY9D,EAAYmgB,iBACpCngB,EAAYmgB,iBAAmB,MAGvC,GAAKrB,EAGL,CAAIA,EAAMxiB,OAAS,GAAK,CAACojB,GACrB/mB,EAAGynB,eAAernB,EAAK0M,YAAaqZ,CAAK,EAG7C,UAAWK,KAAOL,EAAO,CACrBnmB,EAAGmnB,SAASX,EAAIjS,EAAE,EAAI5N,IACtB,MAAMQ,EAAM/G,EAAK4jB,WAAWwC,EAAIhhB,KAAK+O,EAAE,EAGvC,GAFApN,GAAAA,MAAAA,EAAKI,WAAWJ,EAAIG,QAAQvG,EAAOwT,EAAE,CAAC,EAElC5N,EAAI,IACJ,OAIRqgB,EAAA5mB,EAAKsnB,cAAU,MAAAV,IAAA,QAAfA,EAAAzlB,KAAAnB,EAAkBunB,GAASA,EAAMtb,SAASub,UAAUf,OAAOpB,EAAMqB,EAAiB,EAAI,CAAC,EACvF1mB,EAAK0N,QAAQ,YAAa,CAAE2X,KAAAA,EAAMU,MAAAA,CAAM,CAAC,EAC7C,CAIAT,OAAQ,CAAA,IAAAmC,GACA,KAAKpC,OAAIoC,EAAI,KAAK1B,SAAK,MAAA0B,IAAA,QAAVA,EAAYlkB,SACzB,KAAKkjB,OAAO,EAAE,CAEtB,CAMA,IAAIiB,YAAa,OAAA,IAAAC,EACb,OAAOA,GAAAA,EAAI,KAAC5B,SAAK,MAAA4B,IAAA,OAAA,OAAVA,EAAYpkB,SAAZokB,KAAAA,EAAsB,CACjC,CAYAC,QAAQnmB,EAAO,CACX,MAAMomB,EAAU,KAAK9B,MAAMtkB,CAAK,EAChC,OAAIomB,GACA,KAAK7nB,KAAK8nB,UAAU,CAChB1T,SAAW,KAAKA,SAChBD,GAAW0T,EAAQ1T,EACvB,EAAG,CAAE4T,SAAW,EAAK,CAAC,EAEnB,CAAC,CAACF,CACb,CACAR,eAAe3a,EAAaqZ,EAAO,CAC/B,MACIiC,EAAetb,EAAc,KAAK1M,KAAKL,MAAMoK,QAAQ2C,EAAYyH,EAAE,EAAI,EACvE8T,EAAelC,EAAMxH,MAAK,EAAG2J,KACzB,CAACC,EAAGC,IAAM3gB,KAAK4gB,IAAIF,EAAE1mB,MAAQumB,CAAY,EAAIvgB,KAAK4gB,IAAID,EAAE3mB,MAAQumB,CAAY,CAChF,EACJ,KAAKJ,QAAQ7B,EAAMhc,QAAQke,EAAY,CAAC,CAAC,CAAC,CAC9C,CAIAK,cAAe,CACX,KAAKV,QAAQ,CAAC,CAClB,CAIAW,aAAc,CACV,KAAKX,QAAQ,KAAK7B,MAAMxiB,OAAS,CAAC,CACtC,CAIAilB,aAAc,OAAA,IAAAC,EAAAC,EACV,MACI9oB,EAAe,KACf,CAAEI,KAAAA,CAAK,EAAQJ,EAEf+oB,GAAeF,GAAAA,EAAAzoB,EAAK4oB,gBAAY,MAAAH,IAAA,OAAA,OAAjBA,EAAmBtU,KAAnBsU,KAAAA,GAAqBC,EAAI1oB,EAAK6oB,mBAAe,MAAAH,IAAA,OAAA,OAApBA,EAAsBvU,GAC9DmB,EAAetV,EAAKL,MAAMoK,QAAQ4e,CAAS,GAAK,EAChDd,EAAejoB,EAAGmmB,MAAMV,KAAKe,GAAOA,EAAI3kB,MAAQ6T,CAAY,EAC5DuS,EACA7nB,EAAK8nB,UAAU,CACX1T,SAAWxU,EAAGwU,SACdD,GAAW0T,EAAQ1T,EACvB,EAAG,CAAE4T,SAAW,EAAK,CAAC,EAGtBnoB,EAAG0oB,aAAY,CAEvB,CAIAQ,aAAc,OAAA,IAAAC,EAAAC,EACV,MACIppB,EAAkB,KAClB,CAAEI,KAAAA,EAAM+lB,MAAAA,CAAM,EAAInmB,EAClB+oB,GAAkBI,GAAAA,EAAA/oB,EAAK4oB,gBAAY,MAAAG,IAAA,OAAA,OAAjBA,EAAmB5U,KAAnB4U,KAAAA,GAAqBC,EAAIhpB,EAAK6oB,mBAAe,MAAAG,IAAA,OAAA,OAApBA,EAAsB7U,GACjEmB,EAAkBtV,EAAKL,MAAMoK,QAAQ4e,CAAS,GAAK,EACvD,IAAIM,EACJ,GAAKlD,EAAMxiB,OAGX,SAASgD,EAAIwf,EAAMxiB,OAAS,EAAGgD,IAAKA,GAAK,EACrC,GAAIwf,EAAMxf,CAAC,EAAE9E,MAAQ6T,EAAc,CAC/B2T,EAAUlD,EAAMxf,CAAC,EACjB,MAGJ0iB,EACAjpB,EAAK8nB,UAAU,CACX1T,SAAWxU,EAAGwU,SACdD,GAAW8U,EAAQ9U,EACvB,EAAG,CAAE4T,SAAW,EAAK,CAAC,EAGtBnoB,EAAG2oB,YAAW,EAEtB,CAOAphB,WAAW,CAAEF,YAAAA,EAAatG,OAAAA,EAAQC,OAAAA,CAAO,EAAG,CAAA,IAAAsoB,EACxC,MACItpB,EAAe,KACf,CAAEU,UAAAA,CAAU,EAAI2G,EAChB,CACI8d,WAAAA,EACAiC,OAAAA,EACAnC,WAAAA,CACJ,EAAcjlB,EACdupB,EAAcvpB,EAAGwU,WAAazT,EAAOwT,MAAE+U,EAAItpB,EAAGmnB,YAAQ,MAAAmC,IAAA,OAAA,OAAXA,EAActoB,EAAOuT,EAAE,GACtE,GAAIgV,EAAU,CAEV7oB,EAAUC,IAAIX,EAAG8kB,MAAM,EACvBzd,EAAYmiB,WAAa,GACzBniB,EAAYmgB,iBAAmBngB,EAAY8D,UAG3C,MAAMse,EAAQtE,EAAWuE,YAAc5lB,EAAU6lB,KAAKtiB,EAAa,uCAAuC,GAAKA,EAC/G,QAASuiB,EAAWzE,EAAW0E,SAAQ,EAAID,GAAYH,EAAMzmB,SAAS4mB,CAAQ,GAAI,CAC9E,MACIE,EAAgBF,EAChBG,EAAgBH,EAASI,UACzBC,EAAgB,CAAC,QAAQ,EAE7BL,EAAWzE,EAAW0E,SAAQ,EAC9B,IAAIK,EAAS9C,EAAO+C,UAGpB,QAASC,EAAQhD,EAAOiD,KAAKN,CAAW,EAAGK,EAAOA,EAAQhD,EAAOiD,KAAKN,CAAW,EAAG,CAChF,MACIO,EAAcP,EAAYQ,UAAUL,EAAQE,EAAMvoB,KAAK,EACvD2oB,EAAcJ,EAAM,CAAC,EAAI,OAAS,GAClCK,EAAcL,EAAM,CAAC,EACrBM,EAAcN,EAAM,CAAC,EAAI,OAAS,GACtCH,EAAQvmB,KAAM,GAAEuc,EAAa0K,WAAWL,CAAQ,IAAIE,iBAA2BvF,MAAewF,WAAWC,GAAY,EACrHR,EAAS9C,EAAO+C,UAEpBF,EAAQvmB,KAAKuc,EAAa0K,WAAWZ,EAAYQ,UAAUL,CAAM,CAAC,EAAG,SAAS,EAE9EJ,EAAc1f,WAAWwgB,aAAa9mB,EAAU+mB,0BAA0BZ,EAAQa,KAAK,EAAE,EAAG,CACxFC,SAAW,GACd,EAAGjB,CAAa,EACjBA,EAAcxO,OAAM,EAExBxX,EAAUC,cAAc,CACpB6X,OAAYvU,EACZ7F,UAAYxB,EAAGglB,gBACf5b,KAAYmgB,CAChB,CAAC,EAET,CAGAyB,YAAYhhB,EAAO,CACf,MAAMhK,EAAK,KACX,OAAIA,EAAGylB,MACHzlB,EAAGylB,KAAOzlB,EAAGylB,KAAKwF,OAAO,EAAGjrB,EAAGylB,KAAK9hB,OAAS,CAAC,EAC9C3D,EAAG6mB,OAAO7mB,EAAGylB,IAAI,EACV,IAEJ,EACX,CACAyF,aAAc,CACV,OAAI,KAAKzF,MACL,KAAKA,KAAO,GACZ,KAAKoB,OAAO,KAAKpB,IAAI,EACd,IAEJ,EACX,CACA0F,kBAAmB,CACf,MACInrB,EAAK,KACL,CAAEyN,OAAAA,CAAO,EAAIzN,EAAG6L,OAAOQ,SACvBoB,GAAUzN,EAAGwU,UAAYxU,EAAG8nB,aAC5B9nB,EAAG0lB,MAAK,EACRjY,EAAO0d,iBAAiBnrB,EAAG6L,OAAOuX,QAAQ6D,QAAQjnB,EAAGwU,QAAQ,EAAGxU,EAAGylB,IAAI,EAE/E,CAMA2F,kBAAkBphB,EAAO,CAAA,IAAAqhB,EACrB,MACIrrB,EAAkB,KAClB,CAAEI,KAAAA,CAAK,EAAWJ,EAClB,CAAE8M,YAAAA,CAAY,EAAI1M,EAEtB,GAAI,CAAC4J,EAAM6M,SAAW,CAAC7W,EAAGiM,UAAYa,IAAAA,MAAAA,IAAAA,QAAAA,EAAa9L,QAAU,CAAC8L,EAAY0Y,gBAAgB6F,EAAArhB,EAAMoa,OAAG,MAAAiH,IAATA,OAAAA,OAAAA,EAAW1nB,UAAW,EAAG,CAC/G,MAAM5C,EAASX,EAAKgjB,QAAQ6D,QAAQ7mB,EAAK4oB,aAAaxU,QAAQ,EAE1DzT,GAAUA,EAAO6D,aAAe,KAChC5E,EAAGwU,SAAWpU,EAAK4oB,aAAaxU,SAChCxU,EAAGylB,MAAQzb,EAAMoa,IACjBpkB,EAAG6mB,OAAO7mB,EAAGylB,IAAI,GAG7B,CACA6F,eAAelrB,EAAMmrB,EAAkBC,EAAgB,CACnD,MACIxrB,EAAQ,KACRA,EAAGylB,OAAS,CAAC+F,GAAkBA,EAAehX,WAAaxU,EAAGwU,WAC9DxU,EAAG0lB,MAAK,CAEhB,CAEJ,CA3ZIxhB,EAFiB0gB,EAEVpa,QAAQ,aACftG,EAHiB0gB,EAGVnV,eAAe,CAClBwW,KAAO,SACPR,KAAO,GAKPrS,OAAS,CACLqY,GAAiB,cACjB,WAAiB,cACjB,SAAiB,cACjB,eAAiB,cACjB,eAAiB,mBACjBC,OAAiB,cAEjBC,UAAY,aAChB,IA2YR/G,EAAUzf,OAAS,YAAa0K,EAAmBC,gBAAgB8U,CAAS,EClc5E,MAAMgH,GAAqB,CAAEtQ,OAAS,EAAG7N,OAAS,EAAGjL,QAAU,EAAGqpB,QAAU,CAAE,EA6G/D,MAAMC,UAAoB9b,EAAeuD,MAAMC,CAAS,CAAE,CAIrE,WAAWqR,YAAa,CACpB,MAAO,CAEHkH,kBAA2B,qBAC3BC,iBAA2B,6BAC3BC,yBAA2B,qCAG3BC,eAA2B,IAAIjU,IAC/BkU,mBAA2B,IAAIlU,IAEvC,CA8NA,WAAW1I,cAAe,CACtB,MAAO,CACHC,MAAW,CAAC,qBAAsB,kBAAmB,mBAAoB,YAAa,YAAY,EAClGsM,SAAW,CAAC,oBAAqB,eAAgB,aAAc,iBAAiB,EAExF,CAGAnQ,gBAAiB,CACb,MACI3L,EAAa,KACb,CAAE6L,OAAAA,CAAO,EAAI7L,EACjB,GAAI,CAACA,EAAGY,UAAY,CAACZ,EAAGosB,OAAQ,CAC5BC,QAAQC,KAAK,oFAAoF,EACjG,OAEAzgB,EAAO0gB,aAAe1gB,EAAO2gB,iBAAmB,IAChDH,QAAQC,KAAK,4FAA4F,EAEzGtsB,EAAGosB,QACHvW,EAAaxV,IAAI,CACbosB,MAAUzsB,EAAG0sB,cACbnsB,QAAUP,CACd,CAAC,EAGLA,EAAGkd,UAAUrR,EAAO9L,KAAK,EACrBC,EAAGsgB,cACHzU,EAAOxL,IAAI,CAAE,CAACL,EAAGsgB,YAAY,EAAI,iBAAkB/f,QAAUP,CAAG,CAAC,EAErEA,EAAG2sB,UAAS,EACZ3sB,EAAG4sB,eAAiB,IAAIC,eAAgBC,GAAY9sB,EAAG+sB,qBAAqBD,CAAO,CAAC,CACxF,CACA5P,UAAUnd,EAAO,CACb,MAAMC,EAAK,KACXA,EAAGksB,eAAexG,MAAK,EACvB1lB,EAAGmsB,mBAAmBzG,MAAK,EAC3B1lB,EAAG4d,gBAAgB,mBAAmB,EACtC7d,EAAMM,IAAI,CACNgE,KAAU,oBACVwZ,OAAU7d,EAAG4gB,cACbrgB,QAAUP,CACd,CAAC,CACL,CACAwR,UAAUC,EAAS,CACf,KAAM,CAAE5F,OAAAA,CAAO,EAAI,KACf4F,IACA,KAAKya,eAAexG,MAAK,EACzB,KAAKyG,mBAAmBzG,MAAK,GAE5B7Z,EAAOwR,eACRxR,EAAO7E,WAAWgmB,cAAa,EAEnC,MAAMxb,UAAUC,CAAO,CAC3B,CACAwb,2BAA2B7jB,EAAM,CAC7B,OAAOA,GAAO,KAAKuJ,EAAEvJ,CAAI,CAC7B,CAEA8jB,kBAAkBljB,EAAO,CAAA,IAAAmjB,EAAAC,EACrB,MAAMptB,EAAK,MACPA,EAAGosB,OAAS,CAACpiB,EAAMlH,OAAOuqB,QAAS,IAAGrtB,EAAG+rB,uBAAuB/rB,EAAGisB,0BAA0B,EAC3F,GAAAkB,EAACntB,EAAG6L,OAAOyhB,sBAAkBH,MAAAA,IAAA,SAAAC,EAA5BD,EAA8BrqB,UAAM,MAAAsqB,IAApCA,QAAAA,EAAsCpN,QAAQ,IAAMhgB,EAAG+rB,iBAAiB,KAE3E/rB,EAAGiU,WAAWiZ,kBAAkBljB,CAAK,CAE7C,CAEAujB,gBAAgB,CAAEzqB,OAAAA,CAAO,EAAG,CAAA,IAAA0qB,GACpB,CAAC,KAAKpB,QAAU,GAAAoB,EAAC1qB,EAAOpC,aAAS,MAAA8sB,IAAA,QAAhBA,EAAkBxqB,SAAS,KAAKipB,wBAAwB,KACzE,KAAKhY,WAAWsZ,gBAAgB,GAAGttB,SAAS,CAEpD,CACA,IAAIwtB,aAAc,CACd,OAAO,KAAK5hB,OAAO4hB,WACvB,CACA,IAAIA,YAAY/lB,EAAO,CACnB,KACI,CAAEmE,OAAAA,CAAO,EAAQ,KACjB6hB,EAAiB7hB,EAAO4hB,YAC5B5hB,EAAO4hB,YAAc/lB,EACjBmE,EAAO4hB,cAAgBC,GACvB7hB,EAAOpL,QAAQC,UAAUya,OAAO,yBAAyB,CAEjE,CAqDAtH,oBAAqB,CACjB,KAAK8Y,UAAS,CAClB,CACAgB,aAAa7tB,EAAQ,CACjB,OAAIA,GAAU,KACHA,EAEJ,CACHqE,KAAU,SACVzC,QAAU,CAAC,CACPkB,IAAU,8BACVX,QAAUA,CAAC,CAAEjB,OAAAA,CAAO,IAAM,KAAK2R,EAAE,KAAKuZ,eAAe0B,IAAI5sB,CAAM,EAAI,0BAA4B,uBAAuB,EACtHoC,QAAUA,CAAC,CAAEpC,OAAAA,CAAO,IAAM,KAAK6sB,aAAa7sB,CAAM,CACtD,CAAC,EACDd,MAAW,GACX4tB,SAAW,GACXznB,MAAW,SACX6S,OAAW,KAAKrN,OAAO8W,QAAQ,CAAC,EAChC,GAAG7iB,EACHqG,MAAW,uBAEnB,CAEAwmB,WAAY,CACR,MACI3sB,EAAc,KACd,CAAEe,OAAAA,CAAO,EAAKf,EACd,CAAEojB,QAAAA,GAAYpjB,EAAG6L,OACjB,CAAC7L,EAAG+tB,yBAA2BhtB,IAAW,CAACf,EAAGguB,WAAa,CAAC5K,EAAQ7D,SAASvf,EAAGguB,SAAS,KACzFhuB,EAAG+tB,wBAA0B,GACzB/tB,EAAGiuB,iBAAmB,OACtB,CAACjuB,EAAGguB,SAAS,EAAI5K,EAAQziB,IAAII,CAAM,EAGnC,CAACf,EAAGguB,SAAS,EAAI5K,EAAQ8K,OAAO,EAAGntB,CAAM,EAE7Cf,EAAG+tB,wBAA0B,GAErC,CAGAI,eAAe,CAAErrB,OAAAA,CAAO,EAAG,CAEnB,KAAKmJ,UAAYnJ,GAAAA,MAAAA,EAAQkd,QAAQ,gBAAgB,GAAK,CAACld,EAAOkd,QAAQ,cAAc,GAGxF,KAAK6N,aAAa,KAAKhiB,OAAO8F,qBAAqB7O,CAAM,CAAC,CAC9D,CAOA+qB,aAAa7sB,EAAQ,CACbA,IACI,KAAKkrB,eAAe0B,IAAI5sB,CAAM,EAC9B,KAAKotB,SAASptB,CAAM,EAGpB,KAAKqtB,OAAOrtB,CAAM,EAG9B,CACA+rB,qBAAqBD,EAAS,CAC1B,KACI,CAAEjhB,OAAAA,CAAO,EAAI,KACb,CAAE9L,MAAAA,CAAM,EAAK8L,EACjB,UAAWyiB,KAASxB,EAAS,CAAA,IAAAyB,EAAAC,EACzB,MACIxtB,EAAcjB,EAAMknB,SAAOsH,EAACD,EAAMxrB,OAAOI,iBAAaqrB,MAAAA,IAAAC,SAAAA,EAA1BD,EAA4BE,YAAQD,MAAAA,IAApCA,OAA0BA,OAA1BA,EAAsCja,EAAE,EACpEma,EAAc1tB,GAAU,KAAKkrB,eAAe5gB,IAAItK,CAAM,EAC1D,GAAI0tB,GAAe,CAACA,EAAYC,aAAc,CAC1C,MAAMlQ,EAAYiQ,EAAYE,mBAC9BF,EAAYE,mBAAqB,KAC7B,KAAKC,iBAAiB7tB,EAAQ,CAAC,IAAMyd,GAErC,KAAKqQ,iBAAiB9tB,CAAM,GAI5C,CAYA4f,cAAc,CAAEte,OAAAA,EAAQysB,OAAAA,EAAQ3O,QAAAA,EAASrZ,QAAAA,CAAQ,EAAG,CAChD,MACI/G,EAAyC,KACzC,CAAEksB,eAAAA,EAAgBC,mBAAAA,CAAmB,EAAInsB,EACzCgvB,EAAyCjoB,GAAWme,OAAO+J,KAAKloB,CAAO,EAC3E,GAAIioB,GAAAA,GAAW,KAAA,OAAXA,EAAarrB,UAAW,GAAKorB,EAAO7oB,WAAWE,SAAS4oB,EAAY,CAAC,CAAC,EAAE7qB,OAAS,UAGjFnE,CAAAA,EAAGiM,UAGP,GAAI3J,IAAW,YACX4pB,EAAexG,MAAK,EACpByG,EAAmBzG,MAAK,UAEnBkG,GAAmBtpB,CAAM,GAC9B,SAAW,CAACtB,EAAQkuB,CAAK,IAAKhD,EAC1B,GAAI,CAAC6C,EAAOxP,SAASve,CAAM,EAAG,CAAA,IAAAmuB,GAC1BA,EAAAD,EAAM9C,UAAM,MAAA+C,IAAA,QAAZA,EAAc5d,QAAO,EACrB2a,EAAekD,OAAOpuB,CAAM,EAC5BmrB,EAAmBiD,OAAOpuB,CAAM,WAInChB,EAAGqvB,uBAAyBjP,IAAO,MAAPA,IAAO,QAAPA,EAASzc,QAC1C,GAAIrB,IAAW,SAAU,CACrB,MAAMosB,EAAcxC,EAAe5gB,IAAI8U,EAAQ,CAAC,CAAC,EAC7CsO,GAAAA,MAAAA,EAAaY,YACbZ,EAAYY,UAAY,GACxBtvB,EAAG6L,OAAO7E,WAAWuoB,iBAAiBnP,EAAQ,CAAC,CAAC,WAG/C9d,IAAW,iBAAkB,CAClC,IAAIktB,EACAC,EACJ,UAAWvoB,KAAOkZ,EAAS,CACvB,MAAMsO,EAAcxC,EAAe5gB,IAAIpE,CAAG,EAC1C,GAAIwnB,GAAAA,MAAAA,EAAaY,UAAW,CACxB,MAAMztB,EAAkBktB,EAAO3O,QAAQjW,QAAQjD,CAAG,EAClDwnB,EAAYY,UAAY,IACpB,CAACG,GAAaD,EAAiB3tB,KAC/B2tB,EAAiB3tB,EACjB4tB,EAAiBvoB,IAIzBuoB,GACAzvB,EAAG6L,OAAO7E,WAAWuoB,iBAAiBE,CAAS,IAI/D,CAEAZ,iBAAiB7tB,EAAQqZ,EAAQ,OAC7B,MAAMqU,EAAc,KAAKxC,eAAe5gB,IAAItK,CAAM,EAClD,GAAI0tB,EAAa,CAEb,GAAI,CAACA,EAAYY,WAAaZ,EAAYgB,iBACtC,OAAO,KAAKC,uBAAyBtV,EAGzC,GAAI,CAACqU,EAAYE,mBACb,UAAW1V,KAAU,KAAKrN,OAAO8W,QAAS,CACtC,MAAMtI,EAASqU,EAAYkB,qBAAqB1W,CAAM,EAAEgL,aACpD7J,EAASqU,EAAYE,qBACrBF,EAAYE,mBAAqBvU,IAKjD,QAAQqU,EAAAA,GAAW,KAAA,OAAXA,EAAaE,qBAAbF,KAAAA,EAAmC,GAAKrU,CACpD,CAMAwV,gBAAgB,CAAE1oB,IAAAA,EAAKnG,OAAAA,CAAO,EAAG,CAC7B,MACIhB,EAAe,KACf,CAAE2iB,QAAAA,GAAa3iB,EAAG6L,OAClB,CACImgB,iBAAAA,EACAG,mBAAAA,CACJ,EAAensB,EAEf0uB,EAAe1uB,EAAGksB,eAAe5gB,IAAItK,CAAM,EAyB/C,GAxBAmG,EAAIvE,IAAIuY,OAAO,yBAA0Bnb,EAAGiM,QAAQ,EAEhD9E,EAAIvE,IAAIopB,CAAgB,EAEpBhsB,EAAG8vB,kBAAoB9vB,EAAGytB,aAAetB,EAAmByB,IAAI5sB,CAAM,EACtEhB,EAAG+vB,kBAAkB5oB,EAAK,IAAM,CAE5B,MAAM6oB,EAAkB7D,EAAmB7gB,IAAItK,CAAM,EACrD,GAAIgvB,EAAiB,CAAA,IAAAC,EACjB9D,EAAmBiD,OAAOpuB,CAAM,EAChChB,EAAGkwB,eAAe/oB,CAAG,GACrB8oB,EAAAD,EAAgB5D,UAAM,MAAA6D,IAAA,QAAtBA,EAAwB1e,QAAO,EAEvC,CAAC,EAGKmd,GACN1uB,EAAGkwB,eAAe/oB,CAAG,EAKzBglB,EAAmBiD,OAAOpuB,CAAM,EAEhC,CAAChB,EAAGiM,UAAYyiB,EAAa,CAExBA,EAAYY,YACbZ,EAAYC,aAAe,GAC3B3uB,EAAGmwB,eAAenvB,EAAQmG,EAAKunB,CAAW,GAE9CvnB,EAAIvE,IAAIjC,IAAIqrB,CAAgB,EAC5B,UAAW9S,KAAUyJ,EAAS,CAC1B,MAAMyN,EAAajpB,EAAIkpB,WAAWnX,CAAM,EAExC,GAAIwV,EAAYY,UAAW,CACvB,MAAMgB,EAAc5B,EAAYkB,qBAAqB1W,CAAM,EAEvDoX,EAAYptB,gBAAkBktB,IAE9BtsB,EAAUysB,mBAAmBH,EAAY,IAAMpwB,EAAG+rB,iBAAiB,EACnEqE,EAAW9V,YAAYgW,CAAW,EAElCtwB,EAAG4sB,eAAe4D,QAAQF,CAAW,GAEzC5B,EAAYC,aAAe,GAEvBD,EAAY+B,wBACZzwB,EAAG0wB,MAAMhC,EAAY+B,qBAAqB,EAC1C/B,EAAY+B,sBAAwB,WAKxCzwB,EAAG2wB,uBAAuBP,EAAY1B,CAAW,EAErD1uB,EAAG4wB,eAAeR,EAAY1B,EAAYmC,WAAY,EAAK,EAG3D7wB,EAAG8wB,uBAAyB9wB,EAAG+wB,aAC/B/wB,EAAG8wB,sBAAwB,GACtBhtB,EAAUktB,SAAStC,EAAYkB,qBAAqBjN,EAAQ,CAAC,CAAC,EAAG,EAAI,GAEtE3iB,EAAG6L,OAAO7E,WAAW3G,IAAI,CACrB4wB,KAAa,GACb1wB,QAAaP,EACbid,WAAaA,IAAMjd,EAAGkxB,kBAAkB/pB,EAAKnG,CAAM,CACvD,CAAC,GAIjB,CAMAkwB,kBAAkB/pB,EAAKnG,EAAQ,CAEvB,KAAKysB,YACL,KAAKsC,kBAAkB5oB,EAAK,IAAM,KAAK0E,OAAOqlB,kBAAkBlwB,CAAM,CAAC,EAGvE,KAAK6K,OAAOqlB,kBAAkBlwB,CAAM,CAE5C,CAMA+uB,kBAAkB5oB,EAAKQ,EAAI,OACvB0O,EAAY8a,gBAAgB,CACxB1wB,QAAW0G,EAAI1G,QACf2wB,SAAW,SACXtpB,QAAWH,EACXpH,QAAW,KACX8wB,UAAWvtB,EAAAA,EAAUwtB,8BAA8BnqB,EAAI1G,QAAS,QAAQ,IAA7DqD,KAAAA,EAAkE,CACjF,CAAC,CACL,CACAosB,eAAe/oB,EAAKoqB,EAAe,CAC/BpqB,EAAIvE,IAAI0Y,OAAO,KAAK0Q,gBAAgB,EACpC,UAAW9S,KAAU,KAAKrN,OAAO8W,QAAS,CACtC,MAAMyN,EAAajpB,EAAIkpB,WAAWnX,CAAM,EACxC,UAAWsY,KAASpB,EAAWqB,iBAAiB,IAAM,KAAK1F,iBAAiB,EAAG,CAAA,IAAA2F,EAC3EH,KAAaG,EAAIF,EAAMpF,UAAMsF,MAAAA,IAAZA,QAAAA,EAAcngB,QAAO,GACtC,KAAKqb,eAAe+E,UAAUH,CAAK,EACnCA,EAAMlW,OAAM,EAGhB8U,EAAW1vB,UAAU4a,OAAO,KAAK0Q,gBAAgB,EACjD,KAAK4E,eAAeR,EAAY,KAAM,EAAK,EAEnD,CACAO,uBAAuBP,EAAY1B,EAAa,CAC5CA,EAAYkD,kBAAkBluB,KAAKI,EAAUC,cAAc,CACvD6X,OAAYwU,EACZ5uB,UAAY,KAAKuqB,kBAAoB,yBACrC5iB,MAAY,CACRsY,IAASiN,EAAYmC,WACrBxW,OAAS,KAAKsV,wBAElBluB,SAAW,CACP,CACIc,IAAY,IACZf,UAAY,yBAEhB,KAAKqwB,oBAAoB,CAEjC,CAAC,CAAC,CACN,CASA1B,eAAenvB,EAAQmG,EAAKunB,EAAa,CAAA,IAAAoD,EACrC,MACI9xB,EAAuC,KACvC,CAAE6L,OAASzL,EAAMgsB,OAAAA,EAAQ2F,UAAAA,CAAU,EAAI/xB,EACvC6wB,GAAUiB,EAA6B3qB,EAAIqG,MAAM,CAAC,KAACskB,MAAAA,IAAZA,OAAAA,OAAAA,EAAc5N,aACrD,CAAE0L,qBAAAA,EAAuB,CAAA,CAAG,EAAWlB,EACvCsD,EAAuC,CAAA,EAEvCC,EAAuCA,CAACC,EAASC,EAAiBjZ,IAAW,CACrEgZ,GAAW,OACP,OAAOA,GAAY,SACnBC,EAAgBhnB,UAAY+mB,EAEvBA,EAAQ/tB,MAAQ,CAAC+tB,EAAQ3vB,IAC9B6vB,EAAaF,EAASC,CAAe,GAIrCD,EAAUpuB,EAAUC,cAAcmuB,CAAO,EACzCC,EAAgB7X,YAAY4X,CAAO,IAG3CtC,EAAqB1W,CAAM,EAAIiZ,GAEnCC,EAAeA,CAACC,EAAcF,IAAoB,CAAA,IAAAG,EAC9C,MACIC,GAASD,EAAaxuB,EAAU0uB,aAAY,KAAEF,MAAAA,IAAxBA,OAAAA,OAAAA,EAA0BjuB,KAChDouB,EAAsB3uB,EAAUC,cAAc,CAC1C6X,OAAYuW,EACZ3wB,UAAYxB,EAAGisB,yBACf9iB,MAAY,UAChB,CAAC,EACDupB,EAAaD,EAAoBE,YAAcF,EAAoBG,aAAa,CAAE3M,KAAO,QAAS,CAAC,EACvG+L,EAAetuB,KAAKI,EAAU+uB,0BAA0BH,CAAU,EAAEI,KAAK,IAAM,CAC3E,GAAI1yB,CAAAA,EAAK2yB,YAGT,IAAIhB,EAAW,CACX,MAAMiB,EAAYhyB,EAAOoH,SAAS2pB,CAAS,EAE3C,GAAIiB,GAAAA,MAAAA,EAAWC,QACXZ,EAAatyB,MAAQizB,UAEhB5yB,EAAKL,MAAO,GAAEgyB,QAAgB,EAAG,CACtC,MAAMmB,EAAe9yB,EAAKL,MAAO,GAAEgyB,QAAgB,EACnDM,EAAatyB,MAAQmzB,EAAa1jB,MAAMvH,GAAKjH,EAAOoH,SAAS2pB,CAAS,EAAExS,SAAStX,CAAC,CAAC,OAGnFoqB,EAAa7sB,KAAOwtB,EAG5B,GAAIT,EAAW,CACX,KACI,CAAE3vB,IAAAA,CAAI,EAAKyvB,EACXc,EAAY,WAAUZ,EAAUhS,YAAW,IAC/C8R,EAAazvB,IAAMA,EAAMA,EAAM,IAAMuwB,EAAWA,EAEpDzE,EAAYtC,OAAS+F,EAAgB/F,OAASgH,GAAOC,OAAOC,GAAaxR,OAAO,CAC5EyR,SAAYb,EACZxf,MAAY9S,EACZD,KAAY,EACZqzB,UAAY,MACZC,SAAY,IACbpB,CAAY,CAAC,EACZN,GAEArD,EAAYtC,OAAOrsB,MAAMM,IAAI,CACzBwd,OAAUA,IAAM,CAAC1W,EAAI4rB,aAAe5rB,EAAIgM,OAAM,EAC9C5S,QAAUP,CACd,CAAC,EAET,CAAC,EAAE0zB,MAAOC,GAAS,CACf,MAAM,IAAIhpB,MAAM,6BAA+BgpB,CAAI,CACvD,CAAC,CAAC,GAGV,GAAIjF,CAAAA,EAAYgB,iBAGhBxK,QAAOpD,OAAO4M,EAAa,CAAEmC,WAAAA,EAAYjB,qBAAAA,EAAsBhB,mBAAqB,EAAGgD,kBAAoB,CAAA,CAAG,CAAC,EAC/G,UAAW1Y,KAAU9Y,EAAKuiB,QAAS,CAC/B,MACIyN,EAAajpB,EAAIkpB,WAAWnX,CAAM,EACtC,IAAI0a,EAAsBhE,EAAqB1W,CAAM,EAErD/R,EAAI0sB,OAAO7zB,EAAGgsB,gBAAgB,EACzB4H,IAGDA,EAAsB9vB,EAAUC,cAAc,CAC1C6X,OAAYwU,EACZlnB,SAAY,GACZ1H,UAAYxB,EAAG+rB,kBACf5iB,MAAY,CACRsY,IAAMoP,EAAa,IACvB,CACJ,CAAC,EACD7wB,EAAG4sB,eAAe4D,QAAQoD,CAAmB,GAEjD,IAAIE,EACA1H,EACAgG,EAAahG,EAAQwH,CAAmB,EAIxCE,EAAiB9zB,EAAGY,SAAS,CACzBI,OAAAA,EAAQmxB,gBAAkByB,EAAqBxD,WAAAA,EAAYlX,OAAAA,EAAQ9Y,KAAAA,CACvE,CAAC,EAED+R,GAAQC,UAAU0hB,CAAc,EAChC9B,EAAetuB,KAAKowB,EAAehB,KAAKZ,GAAWD,EAAkBC,EAAS0B,EAAqB1a,CAAM,CAAC,CAAC,EAG3G+Y,EAAkB6B,EAAgBF,EAAqB1a,CAAM,EAIjE8Y,EAAeruB,QACf+qB,EAAYgB,iBAAmB,GAC/BqE,QAAQC,IAAIhC,CAAc,EAAEc,KAAK,IAAM,CAGnCiB,QAAQC,IAAIhC,CAAc,EAAEc,KAAK,IAAM,CAAA,IAAAmB,EAAAC,EACnC,GAAI9zB,CAAAA,EAAK2yB,YAITrE,CAAAA,EAAYY,UAAY,IAExB2E,EAAAvF,EAAYkD,qBAAiB,MAAAqC,IAA7BA,QAAAA,EAA+BzwB,QAAQ2wB,GAAMA,EAAG7Y,OAAM,CAAE,EACxDoT,EAAYkD,kBAAkBjuB,OAAS,EACvC+qB,EAAYC,aAAe,GAC3BD,EAAYgB,iBAAmB,GAG/B,SAAW,CAAA,CAAGR,CAAK,IAAKlvB,EAAGksB,eACvB,GAAI,CAACgD,EAAMI,UACP,QAIR4E,EAAAl0B,EAAGo0B,2BAAuB,MAAAF,IAAA,QAA1BA,EAAA3yB,KAAAvB,EAA6BgB,EAAQ,EAAI,EAC7C,CAAC,CACL,CAAC,GAID0tB,EAAYY,UAAY,GAEhC,CAQA8E,wBAAwBpzB,EAAQ,CAC5B,MAAMhB,EAAK,KACX,GAAIA,EAAG8vB,iBAAkB,CACrB,MAAM3oB,EAAMnH,EAAG6L,OAAO7E,WAAWgd,WAAWhjB,CAAM,EAC9CmG,IACAnH,EAAGytB,YAAc,GACbztB,EAAGmsB,mBAAmByB,IAAI5sB,CAAM,GAChCmG,EAAI0sB,OAAO,qBAAqB,EAEpC7zB,EAAG+vB,kBAAkB5oB,EAAK,IAAM,CAE5B,GADAnH,EAAGytB,YAAc,GACb,CAACtmB,EAAI4rB,YAAa,CAAA,IAAAsB,GAClBA,EAAAltB,EAAImtB,aAASD,MAAAA,IAAbA,QAAAA,EAAA9yB,KAAA4F,EAAgB,qBAAqB,EAE7C,CAAC,GAGT,OAAOnH,EAAG8uB,iBAAiB9tB,CAAM,CACrC,CAOA8tB,iBAAiB9tB,EAAQ,OACrB,QAACuzB,EAAA,KAAKC,mBAAL,KAAAD,EAA0B,KAAKC,iBAAmB,CAAA,GAAK9wB,KAAK1C,CAAM,EAC9D,KAAKyzB,cACN,KAAKA,YAAc,IAAIV,QAAQW,GAAW,CACtCC,sBAAsB,IAAM,CAAA,IAAAC,GACxBA,EAAA,KAAKC,kBAAcD,MAAAA,IAAnBA,QAAAA,EAAArzB,KAAI,KAAkBmzB,CAAO,EAC7B,KAAKD,YAAc,IACvB,CAAC,CACL,CAAC,GAEE,KAAKA,WAChB,CAMAI,eAAeC,EAAgB,CAC3B,MACI90B,EAAuB,KACvB,CAAEw0B,iBAAAA,CAAiB,EAAIx0B,EACvB,CAAED,MAAAA,GAAqBC,EAAG6L,OAC9B7L,EAAGksB,eAAe1oB,QAAQ,CAAC0rB,EAAOluB,IAAW,CACrCkuB,EAAMuB,uBAAyBvB,EAAMI,WAAa,CAACkF,EAAiBjV,SAASve,CAAM,GACnFwzB,EAAiB9wB,KAAK1C,CAAM,CAEpC,CAAC,EACD,KAAM,CAACygB,CAAG,EAAI+S,EAAiBlM,KAAK,CAACC,EAAGC,IAAMzoB,EAAMoK,QAAQoe,CAAC,EAAIxoB,EAAMoK,QAAQqe,CAAC,CAAC,EACjFxoB,EAAG6L,OAAO7E,WAAWuoB,iBAAiB9N,CAAG,EACzC+S,EAAiB7wB,OAAS,EAE1B3D,EAAG0wB,MAAMoE,CAAc,CAC3B,CASAlE,eAAeR,EAAYS,EAAYkE,EAAQ,CAC3C,QAASxM,EAAI,EAAGA,EAAI6H,EAAW3uB,SAASkC,OAAQ4kB,IAAK,CACjD,MAAMiJ,EAAQpB,EAAW3uB,SAAS8mB,CAAC,EAE9BiJ,EAAM9wB,UAAUsC,SAAS,KAAK+oB,iBAAiB,IAChDyF,EAAMroB,MAAMkR,OAAS0a,EAAS,GAAKlE,EAAa,MAG5D,CAaA,MAAMxC,OAAOrtB,EAAQ+lB,EAAY,GAAO,CACpC,MAAM/mB,EAAK,KACX,GAAIA,EAAGiM,UAAYjM,EAAGksB,eAAe0B,IAAI5sB,CAAM,GAAWhB,MAAAA,EAAG8N,QAAQ,eAAgB,CAAE9M,OAAAA,EAAQ,IAAM,GACjG,OAEJ,IAAI0tB,EACJ,OAAO,IAAIqF,QAASW,GAAY,CAY5B,GAXAhG,EAAc,CACVY,UAAwB,GACxBmB,sBAAwBiE,GAG5B10B,EAAGksB,eAAehkB,IAAIlH,EAAQ0tB,CAAW,EAEzC1uB,EAAGmsB,mBAAmBiD,OAAOpuB,CAAM,EACnChB,EAAG8wB,sBAAwB,GAC3B9wB,EAAGo0B,wBAAwBpzB,CAAM,EAE7B,CAAC+lB,EAAW,CAAA,IAAAiO,EAAAC,GACZD,GAAAC,EAAAj1B,EAAG6L,QAAO6b,cAAUsN,MAAAA,IAApBA,QAAAA,EAAAzzB,KAAA0zB,EAAuBtN,GAASA,EAAMtb,SAAS6oB,YAAY7G,OAAOrtB,EAAQ,EAAI,CAAC,EAEvF,CAAC,EAAE8xB,KAAK,IAAM,CAAA,IAAAqC,GACVA,EAAAn1B,EAAG8N,WAAOqnB,MAAAA,IAAVA,QAAAA,EAAA5zB,KAAAvB,EAAa,SAAU,CACnBgB,OAAAA,EACAo0B,iBAAmB1G,EAAYkB,qBAC/BxD,OAAmBsC,EAAYtC,MACnC,CAAC,CACL,CAAC,CACL,CAQA,MAAMgC,SAASptB,EAAQ+lB,EAAY,GAAO,CACtC,MACI/mB,EAAc,KACd0uB,EAAc1uB,EAAGksB,eAAe5gB,IAAItK,CAAM,EAC9C,GAAIhB,EAAAA,EAAGiM,UAAY,MAAMjM,EAAG8N,QAAQ,iBAAkB,CAAE9M,OAAAA,EAAQ,IAAM,IAItE,IAAI0tB,GAAAA,MAAAA,EAAakB,qBACb,UAAW1W,KAAUwV,EAAYkB,qBAC7B5vB,EAAG4sB,eAAe+E,UAAUjD,EAAYkB,qBAAqB1W,CAAM,CAAC,EAQ5E,GALAlZ,EAAGksB,eAAekD,OAAOpuB,CAAM,EAC/BhB,EAAGmsB,mBAAmBjkB,IAAIlH,EAAQ0tB,CAAW,EAC7C,MAAM1uB,EAAGo0B,wBAAwBpzB,CAAM,EACvChB,EAAG8N,QAAQ,WAAY,CAAE9M,OAAAA,CAAO,CAAC,EAE7B,CAAC+lB,EAAW,CAAA,IAAAsO,EAAAC,GACZD,GAAAC,EAAAt1B,EAAG6L,QAAO6b,cAAU2N,MAAAA,IAApBA,QAAAA,EAAA9zB,KAAA+zB,EAAuB3N,GAASA,EAAMtb,SAAS6oB,YAAY9G,SAASptB,EAAQ,EAAI,CAAC,GAEzF,CAIAu0B,cAAe,CACX,GAAI,CAAC,KAAKC,aAAY,EAClB,OAAO,KAAKvhB,WAAWshB,aAAa,GAAGt1B,SAAS,CAExD,CAEAw1B,YAAa,CACT,KAAKD,aAAa,EAAI,CAC1B,CAEAE,WAAW,CAAEC,oBAAAA,EAAqB5G,OAAAA,EAAQ6G,QAAAA,CAAQ,EAAG,CACjD,GAAI,KAAKxJ,OAAQ,CACb,KACI,CAAEvgB,OAAAA,CAAO,EAAS,KAClB,CAAEiB,YAAAA,CAAY,EAAIjB,EACtB,OAAS,CAAC7K,EAAQkuB,CAAK,IAAK,KAAKhD,eAAeY,QAAO,EACnD,UAAW+I,KAAQ3G,EAAMU,qBACrB,GAAIV,EAAMU,qBAAqBiG,CAAI,EAAEzJ,SAAW2C,EAAQ,CAChD4G,IAAwB,SACxB30B,EAAS6K,EAAO9L,MAAM+1B,QAAQ90B,EAAQqI,OAAW,EAAI,GAEzD,IAAItI,EAEA,CAAC60B,GAAW9oB,GAAe,CAACA,EAAYipB,gBACxCh1B,EAAS+L,EAAY/L,OAIrBA,EAAS,KAAKi1B,sBAAsBnqB,EAAQ,GAAM+pB,GAAWD,IAAwB,IAAI,EAG7F9pB,EAAOmd,aAAe,KACtB,MAAMiN,EAAcpqB,EAAOmN,qBAAqB,CAAEhY,OAAAA,EAAQD,OAAAA,CAAO,CAAC,EAClE8K,OAAAA,EAAOqc,UAAU+N,CAAW,EACxBL,GACA/pB,EAAO6U,aAAauV,CAAW,EAE5B,IAK3B,CAGAT,aAAaU,EAAI,CACb,GAAI,KAAK9J,OAAQ,CAAA,IAAA+J,EAAAC,EAAAC,EACb,KACI,CAAEvpB,YAAAA,GAAgB,KAAKjB,OACvBqjB,EAAkBpiB,GAAe,KAAKof,eAAe5gB,IAAIwB,EAAY9L,MAAM,EAC3EorB,EAAkB8C,GAAK,OAAAiH,EAALjH,EAAOU,wBAAoB,MAAAuG,IAAA,SAAAC,EAA3BD,EAA8BrpB,GAAW,OAAAupB,EAAXvpB,EAAa/L,UAAM,MAAAs1B,IAAA,OAAR,OAAXA,EAAqBnd,MAAM,KAAC,MAAAkd,IAA1DA,OAAK,OAALA,EAA4DhK,OAClF,GAAIA,GAAAA,MAAAA,EAAQkK,OAAQ,CAChB,IAAIv1B,EAEJ,OAAIqrB,EAAOtf,aAAe,CAACsf,EAAOtf,YAAYipB,gBAC1Ch1B,EAASqrB,EAAOtf,YAAY/L,OAI5BA,EAAS,KAAKi1B,sBAAsB5J,CAAM,EAG9CA,EAAOpD,aAAe,KACtBoD,EAAOlE,UAAUkE,EAAOpT,qBAAqB,CAAEhY,OAASorB,EAAQ,GAAE8J,EAAK,OAAS,mBAAmB,EAAGn1B,OAAAA,CAAO,CAAC,CAAC,EACxG,IAGf,MAAO,EACX,CAQAi1B,sBAAsB51B,EAAMuJ,EAAW,GAAMuO,EAAU,GAAO,OAC1D,MAAMkL,EAAUlL,EAAU,CAAC,GAAG9X,EAAKgjB,QAAQC,cAAc,EAAEnL,QAAO,EAAK9X,EAAKgjB,QAAQC,eACpF,OAAOD,EAAAA,EAAQqC,KAAKnC,GAAC,CAAA,IAAAiT,EAAA,OACjBjT,IAAMljB,EAAKo2B,yBACXlT,MAACiT,EAAKn2B,EAAKiM,SAAS6oB,eAAW,MAAAqB,IAAA,OAAA,OAAzBA,EAA2BvI,aAChC,CAACrkB,GAAY2Z,EAAE3e,OAAO,CAC3B,IAJOye,KAAAA,EAIFA,EAAQ,CAAC,CAClB,CACAjW,kBAAkB,CAAE7K,OAAAA,CAAO,EAAG,CAC1B,GAAI,KAAKm0B,WACL,MAAO,GAEX,GAAI,CAAC,oBAAqB,wBAAwB,EAAElX,SAASjd,CAAM,EAAG,CAAA,IAAA8J,EAClE,OAAAA,EAAO,KAAKP,OAAOQ,SAASC,YAAQF,MAAAA,IAA7BA,OAAAA,OAAAA,EAA+Bc,UAG1C,MAAO,EACX,CACAwpB,MAAMC,EAAU,CACZ,KACI,CAAE9qB,OAAAA,CAAO,EAAM,KACf,CAAES,SAAAA,GAAaT,EAAOQ,SAC1B,GAAIC,GAAAA,MAAAA,EAAUC,QAAS,CAAA,IAAAqqB,EAAAC,EACnB,MACI/hB,EAAmB6hB,IAAa,GAChC,CAAEG,aAAAA,CAAa,EAAIxqB,EACnByqB,EAAmBzqB,EAAS0qB,wBAAwBnrB,EAAOiB,YAAagI,CAAI,EAC5EmiB,EAAmBniB,EAAOgiB,EAAgBC,EAAWlrB,EAAO9L,MAAMknB,QAAQ8P,EAASxiB,EAAE,EAAI,KACzF6X,EAAmB6K,KAAcL,EAAI,KAAK1K,eAAe5gB,IAAI2rB,CAAc,KAAC,MAAAL,IAAvCA,OAAAA,OAAAA,EAAyCxK,QAClF,IAAI0K,GAAAA,KAAY,OAAZA,EAAcviB,OAAOwiB,GAAAA,KAAAA,OAAAA,EAAUxiB,KAAM6X,IAAM,MAANA,IAAM,SAAAyK,EAANzK,EAAQ/f,SAASC,YAAQ,MAAAuqB,IAAA,QAAzBA,EAA2BtqB,QAChED,OAAAA,EAAS4qB,cAAa,EAAGpE,KAAK,IAAM,CAChC,MACI9xB,EAASorB,EAAQ,GAAEtX,EAAO,QAAU,kBAAkB,EACtD/T,EAAS,KAAKi1B,sBAAsB5J,EAAQ,GAAM,CAACtX,CAAI,EAC3DsX,EAAO1L,aAAa0L,EAAOpT,qBAAqB,CAAEhY,OAAAA,EAAQD,OAAAA,CAAO,CAAC,CAAC,CACvE,CAAC,EACM,GAIf,MAAO,EACX,CACAo2B,YAAa,CACT,OAAO,KAAKT,MAAM,EAAI,CAC1B,CAEAplB,WAAY,CAAA,IAAA8lB,GACRA,EAAI,KAACxK,kBAAc,MAAAwK,IAAA,QAAnBA,EAAqBC,WAAU,EAC/B,OAAO,KAAKzK,eAEZ,SAAW,CAAA,CAAGsC,CAAK,IAAK,KAAKhD,eAAgB,CAAA,IAAAoL,GACzCA,EAAApI,EAAM9C,UAAM,MAAAkL,IAAA,QAAZA,EAAc/lB,QAAO,EAEzB,MAAMD,UAAS,CACnB,CACAob,cAAc,CAAE6K,KAAAA,EAAM9K,MAAAA,CAAM,EAAG,CAC3B,SAAW,CAAA,CAAG6B,CAAK,IAAK,KAAKpC,eACzBhH,OAAO5Q,OAAOga,EAAMsB,oBAAoB,EAAEpsB,QAAQ8sB,GAAe,CAC7D,MAAMmC,EAAsBnC,EAAYkH,cAAc,IAAM,KAAKvL,wBAAwB,EACzF,GAAIwG,GAAAA,MAAAA,EAAqBE,YAAa,CAAA,IAAA8E,EAAAC,EAAAC,EAAAC,EAClC9zB,EAAU+uB,0BAA0BJ,GAAAA,KAAAA,OAAAA,EAAqBE,YAAa,EAAI,GAC1E8E,EAAAnH,EAAYlE,UAAM,MAAAqL,IAAA,SAAAC,EAAlBD,EAAoBh3B,WAAOi3B,MAAAA,IAA3BA,QAAAA,EAA6Bh3B,UAAU4a,OAAQ,WAAUic,GAAM,GAC/DI,EAAArH,EAAYlE,UAAM,MAAAuL,IAAA,SAAAC,EAAlBD,EAAoBl3B,WAAOm3B,MAAAA,IAA3BA,QAAAA,EAA6Bl3B,UAAUC,IAAK,WAAU8rB,GAAO,EAErE,CAAC,CAET,CAMAoL,kBAAkBC,EAAiB,CAC/B,SAAW,CAAC5wB,EAAK6wB,CAAG,IAAK,KAAK7L,eAAeY,QAAO,EAChD,GAAIgL,EAAgBE,UAAYD,EAAI3L,QAChC,GAAI2L,EAAI3L,SAAW0L,EACf,OAAO5wB,MAGV,CACD,KAAM,CAAE0oB,qBAAAA,CAAqB,EAAImI,EACjC,UAAW7e,KAAU0W,EAAsB,CACvC,MAAMqI,EAAQrI,EAAqB1W,CAAM,EACzC,GAAI+e,IAAUH,GAAmBG,EAAMj1B,SAAS80B,CAAe,EAC3D,OAAO5wB,GAKvB,OAAO,IACX,CACJ,CA1oCIhD,EAFiB4nB,EAEVthB,QAAQ,eAcftG,EAhBiB4nB,EAgBVrc,eAAe,CA4GlB7O,SAAW,KAgBX0f,aAAe,KAoBfvf,OAAS,CAAA,EAQTktB,eAAiB,QAOjBoB,sBAAwB,GAMxBM,uBAAyB,IAMzBkC,qBAAuB,aAMvB/B,iBAAmB,GAuBnB1D,OAAS,KAMT2F,UAAY,KACZ3e,OAAS,CAEL8kB,IAAc,CAAEpwB,QAAU,QAASkH,OAAS,IAC5C,YAAc,CAAElH,QAAU,aAAckH,OAAS,EAAG,GAQxD+hB,WAAa,KAm6BrBjF,EAAY3mB,OAAS,cAAe0K,EAAmBC,gBAAgBgc,CAAW,ECjtCnE,MAAMqM,UAAe3kB,EAAUxD,CAAc,CAAE,CA2B1D,WAAW6U,YAAa,CACpB,MAAO,CACHC,OAAkB,eAClBC,WAAkB,oBAClBC,gBAAkB,0BAClBC,WAAkB,oBAE1B,CACAplB,UAAUO,EAAMN,EAAQ,CACpB,MAAMD,UAAUO,EAAMN,CAAM,EAC5BolB,OAAOpD,OAAO,KAAM,CAChB1hB,KAAAA,EACAgJ,KAAa,GACbgvB,OAAa,CAAA,EACbjT,WAAa/kB,EAAKglB,gBAAgBhlB,EAAKK,QAASqD,EAAUuhB,WAAWC,UAAW,IAAMxhB,EAAUuhB,WAAWE,aAAa,CAC5H,CAAC,EAEDnlB,EAAKC,IAAI,CACLg4B,WAAa,mBACb93B,QAAa,IACjB,CAAC,CACL,CACA4M,mBAAoB,CAChB,MAAOX,EAAQ,KAAKpD,IACxB,CACAkvB,kBAAmB,CACX,KAAKlvB,MACL,KAAKurB,sBAAsB,KAAK9N,OAAQ,CAAC,KAAKzd,KAAM,GAAO,EAAI,CAAC,CAExE,CACAkI,WAAY,CACR,KAAKoU,MAAM,EAAI,EACf,MAAMpU,UAAS,CACnB,CACAE,UAAUC,EAAS,CACXA,GACA,KAAKiU,MAAK,EAEd,MAAMlU,UAAUC,CAAO,CAC3B,CACA,IAAI1R,OAAQ,CACR,OAAO,KAAKK,KAAKL,KACrB,CAIA,WAAWwP,cAAe,CACtB,MAAO,CACHC,MAAQ,CAAC,kBAAkB,EAEnC,CAUA,MAAMqX,OAAOzd,EAAM4e,EAAU,GAAMuQ,EAAU,GAAOn0B,EAAQ2iB,EAAY,GAAO,CAAA,IAAAC,EAC3E,MAAMhnB,EAAK,KAEX,GAAI,CAACoJ,EACD,OAAOpJ,EAAG0lB,MAAK,EAGnB,GAAI,CAAC6S,GAAWnvB,IAASpJ,EAAGoJ,MAAQpJ,EAAGiM,SACnC,OAEJ,KACI,CAAE7L,KAAAA,EAAML,MAAAA,CAAM,EAAIC,EAElBojB,EAAkBhjB,EAAKgjB,QAAQC,eAAe5V,OAAO+qB,GAAOA,EAAI5zB,aAAe,EAAK,EACpF6zB,EAAkB,CAAA,EACtBr0B,EAAcA,GAAUgf,EAAQzhB,IAAI62B,GAAO,CAAA,IAAAE,EAEvCD,OAAAA,EAAW/0B,MAAIg1B,EAACF,EAAIxtB,eAAW0tB,MAAAA,IAAA,OAAA,OAAfA,EAAiB/nB,KAAK6nB,CAAG,CAAC,EACnCA,EAAIryB,KACf,CAAC,EACD,MAAMggB,EAAQpmB,EAAM8mB,OAAOzd,EAAMhF,EAAQq0B,CAAU,EAC/C14B,EAAM44B,QAAUxS,EAAMxiB,QACtB,MAAMvD,EAAKw4B,SAASzS,EAAMxkB,IAAI6kB,GAAOA,EAAIjS,EAAE,CAAC,EAGhD,UAAWxT,KAAUqiB,EACjB,GAAIriB,EAAOmd,YAAcnd,EAAOod,SAAU,CACtC,IAAI0a,EAAY,KACZC,EAAY,KAChB,UAAWtS,KAAOL,EACd,GAAIK,EAAIrgB,QAAUpF,EAAOoF,MAAO,CAC5B,MAAMuB,EAAQ8e,EAAIhhB,KAAKghB,EAAIrgB,KAAK,EAC5BuB,IAAUmxB,IACVrS,EAAIsS,UAAYA,GAEpBD,EAAYnxB,EACZoxB,EAAa,GAAEtS,EAAIrgB,SAASqgB,EAAIjS,MAKhD,IAAI5N,EAAI,EASR,GARAue,OAAOpD,OAAO9hB,EAAI,CACdmnB,SAAY,CAAA,EACZV,UAAYzmB,EAAGmmB,MACfA,MAAAA,EACA/c,KAAAA,EACAge,OAAY,IAAIC,OAAQ,WAAUpH,EAAaqH,aAAaC,OAAOne,CAAI,CAAC,YAAa,IAAI,CAC7F,CAAC,EACDpJ,EAAG+4B,UAAS,EACR,EAAC5S,EAIL,WAAWK,KAAOL,EAId,GAFAnmB,EAAGmnB,SAAU,GAAEX,EAAIrgB,SAASqgB,EAAIjS,IAAI,EAAIiS,EAAIsS,UAAY94B,EAAGmnB,SAASX,EAAIsS,SAAS,EAAInyB,IAEjFA,EAAI3G,EAAGg5B,MACP,MAGR,OAAKh5B,EAAGi5B,uBACJ74B,EAAK4G,WAAW3G,IAAI,CAChBgE,KAAa,aACbkD,WAAa,aACbhH,QAAaP,CACjB,CAAC,EACDD,EAAMM,IAAI,CACNgE,KAAsC,eACtC,CAAE,UAASjE,EAAK84B,kBAAkB,EAAI,iBACtC34B,QAAsCP,CAC1C,CAAC,EACDA,EAAGi5B,qBAAuB,IAE9B74B,EAAK+4B,YAAW,EAChB/4B,EAAK0N,QAAQ,SAAU,CAAE1N,KAAAA,EAAMqlB,KAAOrc,EAAM+c,MAAAA,CAAM,CAAC,EAC/C6B,GAAW,CAAChoB,EAAGo5B,cAAgB,CAACrS,GAChC/mB,EAAG4oB,YAAY,EAAI,GAEvB5B,EAAA5mB,EAAKsnB,cAAUV,MAAAA,IAAfA,QAAAA,EAAAzlB,KAAAnB,EAAkBunB,GAASA,EAAMtb,SAASwa,OAAOA,OAAOzd,EAAM4e,EAASuQ,EAASn0B,EAAQ,EAAI,CAAC,EACtF+hB,EACX,CACA4S,WAAY,CAER,UAAW1xB,KAAevD,EAAUrC,SAAS,KAAKrB,KAAKK,QAAS,IAAM,KAAKqkB,MAAM,EAAG,CAChFzd,EAAY3G,UAAU4a,OAAO,KAAKwJ,OAAQ,KAAKC,UAAU,EAEzD,MAAM5d,EAAMkyB,GAAa/tB,IAAIjE,CAAW,EAAEF,IAEtCA,IAEAA,EAAIuf,eAAiB,GACrBvf,EAAII,WAAWF,CAAW,EAC1BF,EAAIuf,eAAiB,IAGjC,CAIAhB,MAAM4T,EAAS,GAAO,CAClB,MACIt5B,EAAW,KACX,CAAEI,KAAAA,CAAK,EAAIJ,EAWf,GAVIA,EAAGmnB,UACH,OAAOnnB,EAAGmnB,SAEdnnB,EAAGoJ,KAAO,KACVpJ,EAAG+4B,UAAS,EACR/4B,EAAGi5B,uBACHj5B,EAAG4d,gBAAgB,YAAY,EAC/B5d,EAAG4d,gBAAgB,cAAc,EACjC5d,EAAGi5B,qBAAuB,IAE1B,CAACK,EAAQ,CAAA,IAAAC,EACTn5B,EAAK0N,QAAQ,cAAe,CAAE1N,KAAAA,CAAK,CAAC,GAEpCm5B,EAAAn5B,EAAKsnB,cAAU,MAAA6R,IAAA,QAAfA,EAAAh4B,KAAAnB,EAAkBunB,GAASA,EAAMtb,SAASwa,OAAOnB,MAAK,CAAE,EAEhE,CAMA,IAAIoC,YAAa,OAAA,IAAAD,EACb,OAAOA,GAAAA,EAAI,KAAC1B,SAAK,MAAA0B,IAAA,OAAA,OAAVA,EAAYlkB,SAAZkkB,KAAAA,EAAsB,CACjC,CAQA,IAAIuR,cAAe,CAAA,IAAAI,EACf,MACIx5B,EAAkB,KAClB,CAAEI,KAAAA,CAAK,EAAWJ,EAClB,CAAE8M,YAAAA,CAAY,EAAI1M,EACtB,GAAI0M,GAAAA,OAAW0sB,EAAX1sB,EAAaf,QAAI,MAAAytB,IAAA,QAAjBA,EAAmBx2B,SAASc,EAAU21B,iBAAiBr5B,EAAKK,OAAO,CAAC,EAAG,CACvE,KAAM,CAAEqX,SAAAA,EAAU/W,OAAAA,CAAO,EAAI+L,EAC7B,OAAOgL,IAAa,IAAM9X,EAAGmmB,MAAM5O,KAAKiP,GACpCA,EAAI3kB,QAAUiW,GAAY/W,GAAUylB,EAAIrgB,QAAUpF,EAAOoF,KAC7D,EAER,CAIAyiB,YAAY8Q,EAAY,GAAO,CAAA,IAAAC,EAC3B,MACI35B,EAAK,KACT,GAAI,GAAA25B,EAAC35B,EAAGmmB,SAAKwT,MAAAA,IAARA,QAAAA,EAAUh2B,QAAQ,OACvB,KACI,CAAEvD,KAAAA,EAAML,MAAAA,CAAM,EAAIC,EAClB45B,EAAkBx5B,EAAK0M,aAAe1M,EAAK6oB,gBAC3CvT,EAAkBkkB,GAAYF,IAAc,GAAO35B,EAAMoK,QAAQyvB,EAAS54B,OAAQqI,OAAW,EAAI,EAAI,GACrG4e,EAAkBjoB,EAAGmmB,MAAMpC,UAAUyC,GAAOA,EAAI3kB,MAAQ6T,CAAY,EACpEuS,IAAY,IACZjoB,EAAGgoB,QAAQC,CAAO,CAE1B,CAIAiB,aAAc,CAAA,IAAA2Q,EACV,MACI75B,EAAY,KACZ,CAAED,MAAAA,CAAM,EAAIC,EAChB,GAAI,GAAA65B,EAAC75B,EAAGmmB,SAAK0T,MAAAA,IAARA,QAAAA,EAAUl2B,QAAQ,OACvB,KACI,CAAEvD,KAAAA,EAAM+lB,MAAAA,CAAM,EAAInmB,EAClB45B,EAAkBx5B,EAAK0M,aAAe1M,EAAK6oB,gBAC3CvT,EAAkBkkB,EAAW75B,EAAMoK,QAAQyvB,EAAS54B,OAAQqI,OAAW,EAAI,EAAI,EACnF,QAAS1C,EAAIwf,EAAMxiB,OAAS,EAAGgD,IAAKA,GAAK,EAErC,GADYwf,EAAMxf,CAAC,EACX9E,MAAQ6T,EAAc,CAC1B1V,EAAGgoB,QAAQrhB,CAAC,EACZ,MAGZ,CAKAqhB,QAAQnmB,EAAO,CACX,KACI,CAAEzB,KAAAA,CAAK,EAAI,KACX6nB,EAAW,KAAK9B,MAAMtkB,CAAK,EAC/B,OAAIomB,GACA7nB,EAAK8nB,UAAU,CACX/hB,MAAQ8hB,EAAQ9hB,MAChBoO,GAAQ0T,EAAQ1T,EACpB,CAAC,EAEE/H,EAAQyb,CACnB,CAIAS,cAAe,CACX,KAAKV,QAAQ,CAAC,CAClB,CAIAW,aAAc,CACV,KAAKX,QAAQ,KAAK7B,MAAMxiB,OAAS,CAAC,CACtC,CAOA4D,WAAW,CAAEF,YAAAA,EAAatG,OAAAA,EAAQC,OAAAA,EAAQ0G,MAAAA,CAAM,EAAG,CAAA,IAAA4hB,EAC/C,MACItpB,EAAW,KACX,CACImlB,WAAAA,EACAiC,OAAAA,EACAnC,WAAAA,EACA6U,aAAAA,CACJ,EAAW95B,EACXupB,GAAQD,EAAGtpB,EAAGmnB,YAAQ,MAAAmC,IAAXA,OAAAA,OAAAA,EAAcvoB,EAAOoF,MAAQ,IAAMnF,EAAOuT,EAAE,EAC3D,GAAIgV,EAAU,CAAA,IAAAwQ,EAEV1yB,EAAY3G,UAAUC,IAAIX,EAAG8kB,MAAM,EAEnCgV,KAAYC,EAAI1yB,EAAYmwB,cAAe,IAAGx3B,EAAGglB,iBAAiB,KAAC,MAAA+U,IAAA,QAAnDA,EAAqDze,OAAM,GAE3E,MAAMmO,EAAQ3lB,EAAU6lB,KAAKtiB,EAAa,uCAAuC,GAAKA,EACtF,GAAIkgB,OAAO7f,CAAK,EAAE6Y,YAAW,IAAOgH,OAAOvnB,EAAGoJ,IAAI,EAAEmX,YAAW,EAC3DkJ,EAAMte,UAAa,gBAAenL,EAAGilB,eAAewE,EAAMte,mBAAmB2uB,EAAgB,eAAc95B,EAAGglB,oBAAoBuE,UAAmB,SAIpJ,CACDpE,EAAWuE,YAAcD,EACzB,QAASG,EAAWzE,EAAW0E,SAAQ,EAAID,GAAYH,EAAMzmB,SAAS4mB,CAAQ,GAAI,CAC9E,MACIE,EAAgBF,EAChBG,EAAgBH,EAASI,UACzBC,EAAgB,CAAC,QAAQ,EAE7BL,EAAWzE,EAAW0E,SAAQ,EAC9B,IAAIK,EAAS9C,EAAO+C,UAGpB,QAASC,EAAQhD,EAAOiD,KAAKN,CAAW,EAAGK,EAAOA,EAAQhD,EAAOiD,KAAKN,CAAW,EAAG,CAChF,MACIO,EAAcP,EAAYQ,UAAUL,EAAQE,EAAMvoB,KAAK,EACvD2oB,EAAcJ,EAAM,CAAC,EAAI,OAAS,GAClCK,EAAcL,EAAM,CAAC,EACrBM,GAAcN,EAAM,CAAC,EAAI,OAAS,GACtCH,EAAQvmB,KAAM,GAAEuc,EAAa0K,WAAWL,CAAQ,IAAIE,iBAA2BvF,MAAehF,EAAa0K,WAAWF,CAAC,WAAWC,IAAY,EAC9IR,EAAS9C,EAAO+C,UAEpBF,EAAQvmB,KAAKuc,EAAa0K,WAAWZ,EAAYQ,UAAUL,CAAM,CAAC,EAAG,QAAQ,EAE7EJ,EAAc1f,WAAWwgB,aAAa9mB,EAAU+mB,0BAA0BZ,EAAQa,KAAK,EAAE,EAAG,CACxFC,SAAW,GACd,EAAGjB,CAAa,EACjBA,EAAcxO,OAAM,EAEpBwe,GACAh2B,EAAUC,cAAc,CACpB6X,OAAYvU,EACZ7F,UAAYxB,EAAGglB,gBACf5b,KAAYmgB,CAChB,CAAC,EAGTvpB,EAAGo4B,OAAO10B,KAAK2D,CAAW,EAElC,CAWAqH,iBAAiB,CAAE3N,OAAAA,EAAQC,OAAAA,EAAQ2N,MAAAA,EAAOtH,YAAAA,CAAY,EAAG,CACrD,MAAMrH,EAAK,KACPe,EAAO6D,aACP+J,EAAMkY,OAAS,CACXzd,KAAc,oBACd0F,YAAc9O,EACd+O,KAAc,0BACdnM,IAAc,cACdoM,OAAc,IACd/C,SAAcjM,EAAGiM,SACjBgD,OAAcA,IAAM,CAChB,IAAIuI,EAAMjB,WAAWyjB,aAAY,EAAGC,SAAQ,EACvCziB,IACDA,EAAMnQ,EAAY6yB,WAEtBl6B,EAAG6mB,OAAOrP,CAAG,CACjB,GAGZ,CAGAqJ,gBAAiB,CACb,KAAKgG,OAAO,KAAKzd,KAAM,GAAO,EAAI,CACtC,CAEJ,CAhZIlF,EAFiBi0B,EAEV3tB,QAAQ,UACftG,EAHiBi0B,EAGV1oB,eAAe,CAMlBupB,MAAQ,IAMRc,aAAe,GAKf1mB,OAAS,CACLqY,GAAiB,cACjB,SAAiB,cACjB,WAAiB,cACjB,eAAiB,aACrB,IA0XR0M,EAAOgC,aAAe,WACtBhC,EAAOhzB,OAAS,SAAU0K,EAAmBC,gBAAgBqoB,CAAM,EC3apD,MAAMiC,WAAoBpqB,CAAe,CAEpD,WAAWxF,OAAQ,CACf,MAAO,aACX,CACA,WAAW6vB,eAAgB,CACvB,MAAO,CAMHC,gBAAkB,KAClBC,iBAAmB,iCAE3B,CAEA,WAAWhrB,cAAe,CACtB,MAAO,CACHuN,OAAS,CAAC,YAAY,EAE9B,CAGAjd,UAAUO,EAAMN,EAAQ,CACpB,MAAMD,UAAUO,EAAMN,CAAM,EAE5BM,EAAKC,IAAI,CACLm6B,OAAU,eACVj6B,QAAU,IACd,CAAC,EACD2kB,OAAOpD,OAAO,KAAMhe,EAAUC,cAAc,CACxC02B,UAAY,UACZ7e,OAAYxb,EAAKK,QACjBe,UAAY,oBACZC,SAAY,CAAC,CACTg5B,UAAY,iBACZj5B,UAAY,cACf,CACL,CAAC,CAAC,EAEF,KAAKk5B,cAAgB,CACjB,YAA0B,GAC1B,UAA0B,GAC1B,aAA0B,GAC1B,CAAC,KAAKH,gBAAgB,EAAI,GAElC,CACAI,YAAa,CAET,KAAKl6B,QAAQC,UAAUC,IAAI,mBAAmB,CAClD,CACAi6B,cAAe,CACX,MACI56B,EAAK,KACL,CACI6L,OAASzL,EACTK,QAAAA,EACAo6B,eAAAA,CACJ,EAAI76B,EACJ86B,EAAgBjhB,EAAUhO,OAAOzL,EAAK26B,aAAa,EAAEC,QAAO,EAC5DC,EAAgB76B,EAAK4G,WAAWwZ,SAASsa,EAAa/gB,CAAC,EACvDmhB,EAAgBD,IAAkBj7B,EAAGi7B,cACzC,GAAIA,EAAe,CACXC,IACIl7B,EAAGi7B,gBACHj7B,EAAGi7B,cAAc3G,UAAUt0B,EAAGu6B,gBAAgB,EAC9Cv6B,EAAGi7B,cAAc3G,UAAU,qBAAqB,GAEpDt0B,EAAGi7B,cAAgBA,EACnBA,EAAcpH,OAAO7zB,EAAGu6B,gBAAgB,EACxCM,EAAe1vB,UAAY,GAC3B0vB,EAAevgB,YAAYta,EAAGm7B,oBAAmB,CAAE,GAMvD,MAAMC,EAAkBp7B,EAAGi7B,cAAchhB,OAASja,EAAG6L,OAAOwvB,WAAWthB,GAAK/Z,EAAGs7B,oBAC/Et7B,EAAGS,QAAQC,UAAU06B,EAAkB,MAAQ,QAAQ,EAAE,mBAAmB,EAC5Ep7B,EAAGi7B,cAAcG,EAAkB,SAAW,WAAW,EAAE,qBAAqB,EAGhFN,EAAa/gB,GAAK/Z,EAAGu7B,iBACrBz3B,EAAU03B,QAAQ/6B,EAAST,EAAGy7B,UAAU,CAAC,EAAG,CAAEp1B,MAAQ,QAASq1B,YAAcZ,GAAgB,EAAI,EAErG96B,EAAG27B,oBAAsBV,CAC7B,CACAE,qBAAsB,CAClB,MACIn7B,EAAgB,KAChB,CACIi7B,cAAAA,EACAP,cAAAA,CACJ,EAAgB16B,EAChB47B,EAAe,CACX,oBAAsB,GAE1BC,EAAe,CAAA,EACfC,EAAgB97B,EAAG87B,gBAAkB97B,EAAG87B,cAAgBC,SAASC,uBAAsB,GACvFP,EAAgBz7B,EAAGy7B,YAAcz7B,EAAGy7B,UAAY,CAAA,GAWpD,IATAA,EAAUj4B,QAAQy4B,GAAK,CACnBA,EAAEv7B,UAAU4a,OAAO,qBAAqB,CAC5C,CAAC,EAEDmgB,EAAU93B,OAAS,EACnBs3B,EAAciB,YAAYC,GAAS,CAC/BV,EAAU/3B,KAAK,GAAGy4B,EAAM1K,iBAAiBzxB,EAAGs6B,eAAe,CAAC,CAChE,CAAC,EAEMwB,EAAcM,YACjBN,EAAcxgB,OAAOwgB,EAAcM,UAAU,EAEjDp8B,OAAAA,EAAGs7B,oBAAsB,EACzBt7B,EAAGu7B,iBAAmB,EAEtBE,EAAU95B,IAAIs6B,GAAK,CAEfA,EAAEjc,QAAQ,cAAc,EAAEtf,UAAU8C,QAAQZ,GAAOi5B,EAAYj5B,CAAG,EAAI,CAAC,EACvEq5B,EAAEjc,QAAQ,aAAa,EAAEtf,UAAU8C,QAAQZ,GAAOg5B,EAAWh5B,CAAG,EAAI,CAAC,EAErEsiB,OAAOpD,OAAO+Z,EAAanB,CAAa,EACxCxV,OAAOpD,OAAO8Z,EAAalB,CAAa,EACxC,MAAM2B,EAAOJ,EAAEK,UACft8B,EAAGu7B,iBAAmB1zB,KAAKW,IAAIxI,EAAGu7B,iBAAkBc,CAAI,EAExDJ,EAAE9yB,MAAMozB,UAAY,WACpBv8B,EAAGs7B,oBAAsBzzB,KAAKW,IAAIxI,EAAGs7B,oBAAqBt7B,EAAGi7B,cAAc5gB,OAAS4hB,EAAEK,UAAYD,CAAI,EACtGJ,EAAE9yB,MAAMozB,UAAY,GACpB,MAAM71B,EAASu1B,EAAEO,UAAU,EAAI,EAE/BP,OAAAA,EAAEv7B,UAAUC,IAAI,qBAAqB,EACrCm7B,EAAcxhB,YAAY5T,CAAM,EACzBA,CACX,CAAC,EACDm1B,EAAY,WAAW,EAAI,GAC3B/3B,EAAU24B,cAAcz8B,EAAG66B,eAAgBgB,CAAW,EACtD/3B,EAAU24B,cAAcz8B,EAAGS,QAASm7B,CAAU,EACvCE,CACX,CACJ,CACA1B,GAAYj1B,OAAS,cAAe0K,EAAmBC,gBAAgBsqB,GAAa,EAAK,EC5J1E,MAAMsC,UAAiB1sB,CAAe,CAEjDnQ,UAAUgM,EAAQ/L,EAAQ,CACtB,MAAME,EAAK,KACX,MAAMH,UAAUgM,EAAQ/L,CAAM,EAE9BuW,EAAYC,GAAG,CACX7V,QAAYoL,EAAOpL,QACnBF,QAAYP,EACZ28B,KAAY38B,EAAG48B,WACfC,SAAY78B,EAAG88B,eACfC,UAAY/8B,EAAGg9B,gBACfC,UAAYj9B,EAAGk9B,eACnB,CAAC,CACL,CACAC,WAAWC,EAAU,CACjB,KAAKvxB,OAAOiC,QAAQ,WAAY,CAC5BuvB,KAAO,KAAKA,KAAMD,SAAAA,CACtB,CAAC,CACL,CACAJ,iBAAkB,CAEd,KAAKnxB,OAAOpL,QAAQC,UAAUC,IAAI,iBAAiB,CACvD,CACAm8B,eAAe9yB,EAAO,CAClBA,EAAM2M,eAAc,CACxB,CACAumB,gBAAgBlzB,EAAO,CACnB,KAAM,CAAEvJ,QAAAA,GAAY,KAAKoL,OACrB7B,EAAMszB,eAAiB,CAAC78B,EAAQuC,SAASgH,EAAMszB,aAAa,GAC5D,KAAKzxB,OAAOpL,QAAQC,UAAU4a,OAAO,iBAAiB,CAE9D,CACAshB,WAAWQ,EAAU,CAEjBA,EAASzmB,eAAc,EACvB,MAAM0mB,EAAOD,EAASG,aAAa5uB,MAAM,CAAC,EAAE6uB,UAAS,EASrD,KAAK3xB,OAAOiC,QAAQ,WAAY,CAAEuvB,KAAAA,EAAMD,SAAAA,CAAS,CAAC,EAClD,KAAKF,gBAAgBE,CAAQ,CACjC,CACJ,CA/CIl5B,EADiBw4B,EACVlyB,QAAQ,YAgDnBkyB,EAASv3B,OAAS,WAAY0K,EAAmBC,gBAAgB4sB,EAAU,GAAO,MAAM,ECKzE,MAAMe,UAAiBC,EAAS,CAS3C79B,WAAY,CACR,MAAMA,UAAU,GAAGI,SAAS,EAC5B,MAAM09B,EAAW,KAAKA,SAAW,KAAKzH,GAAG,WAAY,EAAI,EACzD,GAAI,CAACyH,EACD,MAAM,IAAIhzB,MAAM,+CAA+C,EAEnEgzB,EAASt9B,IAAI,CACTC,MAAU,KAAKs9B,YACf3M,KAAU,GACV1wB,QAAU,IACd,CAAC,CACL,CACAq9B,aAAc,CACV,MACI59B,EAAe,KACf,CAAE29B,SAAAA,CAAS,EAAI39B,EACf,CAAE69B,UAAAA,EAAWC,cAAAA,GAAkBH,EAAStxB,SAC5C,GAAI,CAACwxB,EACD,MAAM,IAAIlzB,MAAM,8DAA8D,EAElFmzB,EAAcC,oBAAsB,GACpC/9B,EAAGD,MAAQ,IAAIi+B,GAAM,CACjB55B,OAAoB,CAAC,MAAO,WAAW,EACvCwM,kBAAoB,CAChBjQ,IAAUX,EAAGi+B,eACb3iB,OAAUtb,EAAGi+B,eACb19B,QAAUP,CACd,CACJ,CAAC,EACD29B,EAASt9B,IAAI,CACT69B,gBAA2Bl+B,EAAGm+B,mBAC9BC,yBAA2Bp+B,EAAGq+B,2BAC9BC,WAA2Bt+B,EAAGu+B,aAC9BC,gBAA2Bx+B,EAAGy+B,kBAC9BC,WAA2B1+B,EAAG2+B,aAC9Bp+B,QAA2BP,CAC/B,CAAC,EACDA,EAAGm+B,mBAAmB,CAAES,OAASf,EAAUe,MAAO,CAAC,CACvD,CACAX,eAAe,CAAE7d,QAAAA,CAAQ,EAAG,CAAA,IAAAye,EACxB,MACI7+B,EAAe,KACf,CAAE29B,SAAAA,CAAS,EAAI39B,EACf,CAACA,EAAG29B,SAASmB,iBAAkB1e,GAAAA,OAAOye,EAAPze,EAAU,CAAC,KAACye,MAAAA,IAAZA,OAAOA,OAAPA,EAAcj8B,OAAQ,kBACrD5C,EAAG++B,kBAAkC,GACrCpB,EAAStxB,SAASwxB,UAAUe,OAAS5+B,EAAGD,MAAM4B,IAAI,CAAC,CAAEwE,MAAAA,KAAYA,CAAK,EACtEnG,EAAG++B,kBAAkC,GAE7C,CACAZ,mBAAmB,CAAES,OAAAA,CAAO,EAAG,CAC3B,GAAI,CAAC,KAAKG,kBAAmB,CACzB,GAAIH,EAAOrnB,KAAKynB,GAASA,aAAiBC,UAAY,CAACD,EAAME,SAAS,EAClE,MAAM,IAAIv0B,MAAM,wCAAwC,EAE5D,KAAK5K,MAAMyF,MAAQo5B,GAAU,CAAA,GAAIj9B,IAAIq9B,IACjCA,EAAQA,EAAME,WAAaF,EACpB,KAAKrB,SAASva,QAAQ9X,IAAI0zB,CAAK,EACzC,EAET,CACAP,mBAAoB,CAChB,KAAK1+B,MAAMY,IAAI,CAAE4T,GAAK,cAAe3R,IAAM,eAAgB,CAAC,CAChE,CACA27B,aAAa,CAAEY,QAAAA,EAASp+B,OAAAA,EAAQiJ,MAAAA,CAAM,EAAG,CAChBA,EAAMlH,OAAOkd,QAAQ,aAAa,IAEnDmf,EAAQC,MAAQ,GAExB,CACAf,2BAA2B,CAAEt9B,OAAAA,EAAQiJ,MAAAA,CAAM,EAAG,CAChBA,EAAMlH,OAAOkd,QAAQ,aAAa,IAEnDjf,EAAOs+B,eACR,KAAKt/B,MAAMknB,QAAQ,aAAa,EAAE3L,OAAM,EACxC,KAAKvb,MAAMY,IAAII,CAAM,GAGjC,CACA49B,cAAe,CAAA,IAAAW,GACXA,EAAI,KAACv/B,MAAMknB,QAAQ,aAAa,KAAC,MAAAqY,IAAjCA,QAAAA,EAAmChkB,OAAM,CAC7C,CACJ,CAzFIpX,EADiBu5B,EACVt5B,OAAQ,YACfD,EAFiBu5B,EAEVjzB,QAAQ,YACftG,EAHiBu5B,EAGVhuB,eAAe,CAClB8vB,YAAc,WACdC,QAAQx+B,EAAQ,CACZ,OAAOif,EAAa0K,WAAW1K,EAAaC,WAAWlf,EAAOoH,SAAS,KAAKq3B,YAAY,CAAC,CAAC,CAC9F,IAoFRhC,EAASiC,UAAS,EAClBjC,EAASt4B,OAAS,WCpGH,MAAMw6B,UAAkBC,EAAM,CAuBzCC,aAAaC,EAAQC,EAAW,CAAA,IAAAC,EAC5BF,OAAAA,EAAS,MAAMD,aAAaC,EAAQC,CAAS,GAC7CC,EAAAF,KAAM,MAAAE,IAANA,QAAAA,EAAQ3/B,IAAI,CACR4W,gBAAkB,0BAClB1W,QAAkB,IACtB,CAAC,EACMu/B,CACX,CACAG,kBAAkBC,EAAa,CAC3B,MAAMD,kBAAkB,GAAGhgC,SAAS,EACpC,KAAK6/B,OAAOh0B,cAAco0B,YAAcA,CAC5C,CACAC,eAAel2B,EAAU,CACrB,MAAMk2B,eAAe,GAAGlgC,SAAS,EACjC,KAAK6/B,OAAO71B,SAAWA,CAC3B,CACA,IAAIvC,OAAQ,CACR,OAAO,MAAMA,KACjB,CACA,IAAIA,MAAMA,EAAO,CAAA,IAAA04B,EAEb,KAAKC,cAAgB,GACrB,MAAM34B,MAAQA,EAEd,KAAKo4B,OAAO3gB,kBAAkBihB,EAAA14B,EAAM/F,OAAGy+B,MAAAA,IAAA,OAAA,OAATA,EAAA7+B,KAAAmG,EAAYsN,GAAO,KAAKjV,MAAMknB,QAAQjS,CAAG,CAAC,IAAK,CAAA,EAC7E,KAAKqrB,cAAgB,EACzB,CACAC,wBAAwB,CAAEC,UAAAA,CAAU,EAAG,CAE9B,KAAKF,gBACN,KAAK34B,MAAQ64B,EAErB,CACJ,CAvDIr8B,EADiBy7B,EACVn1B,QAAQ,aACftG,EAFiBy7B,EAEVx7B,OAAO,aACdD,EAHiBy7B,EAGVlwB,eAAe,CAClBywB,YAAc,GACdJ,OAAc,CACV37B,KAA6B,WAC7BY,SAA6B,OAC7By7B,2BAA6B,GAC7B10B,cAA6B,CACzB3E,IAAuB,GACvBs5B,qBAAuB,EAC3B,GAEJC,SAAW,CACPlB,QAAQx+B,EAAQ,CACZ,OAAOif,EAAa0gB,MAAM3/B,EAAOqD,QAErCg3B,WAAa,CACTuF,UAAY,eAChB,CACJ,IAoCRjB,EAAUD,UAAS,EACnBC,EAAUx6B,OAAS,aCnBlB,IAAM,CAEH,MACI07B,EAAmB,CACf,cACA,UACA,kBACA,gBACA,oBACA,sBACA,wBACA,uBACA,mBACA,qBACA,YAAY,EAGhBC,EAAmB,CAAA,EACvB,GAAI,CAACnxB,EAAcC,YAAcixB,EAAMtpB,KAAKwpB,GAAQC,SAASD,KAAKxhB,SAASwhB,CAAI,CAAC,GAAK,SAASE,KAAKD,SAASrN,IAAI,GAC5G,OAEJ,IAAIuN,EACJ,SAASC,EAAiBjuB,EAAOkuB,EAAW,CACnCF,IACDA,EAAc,GACdG,EAAaxhC,UAAU,CACnBusB,OAASlZ,CACb,CAAC,GAGLA,EAAMouB,MAAQ,aAClB,CAGA,MAAMD,CAAa,CACf,OAAOxhC,UAAUC,EAAQ,CACrB,MACIE,EAAgB,KAChBuhC,EAAgB,QAChBC,EAAgB,QAChBC,EAAgB9xB,EAAc+xB,WAAWH,CAAO,EAChDI,EAAgBhyB,EAAcC,UAAY,IAAO,IAAO,GACxDgyB,EAAgBC,EAAcC,YAAYF,SAC9C1c,OAAOpD,OAAO9hB,EAAI,CACdyhC,QAAAA,EACAF,QAAAA,EACAQ,QAAmBP,EACnBQ,UAAmBryB,EAAcC,UAAYgyB,EAAW,8BACxDK,QAAmB,GACnBC,iBAAmB,EACnBC,SAAoB,KAAIZ,gBACxBa,gBAAoB,KAAIb,iBACzBzhC,CAAM,EACJ6P,EAAcC,WACfyc,QAAQgW,IAAK,WAAUb,iBAA2B,EAEtDxhC,EAAGsiC,oBAAmB,EAClBtiC,EAAGuiC,YACCxG,SAASyG,aAAe,WACxBxiC,EAAGyiC,eAAc,EAGjB1G,SAAS2G,iBAAiB,mBAAoB,IAAM,CAC5C3G,SAASyG,aAAe,YACxBxiC,EAAGyiC,eAAc,CAEzB,CAAC,GAKTE,WAAW,IAAM,CACb3iC,EAAG4iC,oBAAmB,GACvBjB,CAAa,CACpB,CACA,OAAOW,qBAAsB,CACzB,MACItiC,EAAa,KACb6iC,EAAahB,EAAciB,oBAAoB9iC,EAAGmiC,QAAQ,EAC1DY,EAAaC,OAAOH,CAAU,EAC9BE,GAAQ,CAACtuB,MAAMsuB,CAAI,IACnB/iC,EAAGijC,eAAiBF,GAExB/iC,EAAGijC,eAAiBjjC,EAAGijC,gBAAkBhuB,KAAKiuB,IAAG,EAEjDrB,EAAcsB,oBAAoBnjC,EAAGmiC,SAAUniC,EAAGijC,cAAc,CACpE,CACA,WAAWV,WAAY,CAAA,IAAAa,EAAAC,EACnB,OAAO,KAAKpB,SAAYhtB,KAAKiuB,IAAG,EAAK,KAAKD,eAAiBK,MAAU,MAAGF,EAAIG,OAAOC,WAAO,MAAAJ,IAAAC,SAAAA,EAAdD,EAAiB,KAAK7B,OAAO,KAAC,MAAA8B,IAA9BA,OAAcA,OAAdA,EAAgCI,QAChH,CACA,OAAOb,qBAAsB,CACzB,MACI5iC,EAAsB,KACtB0jC,EAAsBA,IAAM7B,EAAcsB,oBAAoBnjC,EAAGoiC,gBAAiBntB,KAAKiuB,IAAG,CAAE,EAGhG,GAFAljC,EAAGkiC,iBAAmBliC,EAAGkiC,kBAAoBL,EAAciB,oBAAoB9iC,EAAGoiC,eAAe,GAAK,EAElGpiC,EAAAA,EAAGkiC,kBAAoBjtB,KAAKiuB,IAAG,EAAKljC,EAAGkiC,iBAAmBoB,OAG9D,GAAItjC,EAAGgiC,UAAW,CACd,MACI2B,EAASC,mBAAmB5C,SAASrN,IAAI,EACzCkQ,EAAU,GAAE7jC,EAAGgiC,gBAAgBuB,OAAOC,QAAQM,eAAeH,IAC7DI,EAAS,IAAIC,MACjBD,EAAIE,OAAS,IAAM,CAEXF,EAAIG,eAAiB,EACrBlkC,EAAGmkC,WAAU,EAIbT,EAAmB,GAG3BK,EAAIK,QAAU,IAAM,CAChBV,EAAmB,GAEvBK,EAAIM,IAAMR,OAGVH,EAAmB,CAE3B,CACA,OAAOjB,gBAAiB,CACpB,MAAM6B,EAAS,KAAKlY,OAAOvR,YACtB,KAAK0pB,kBACN,KAAKA,gBAAkB,GAClB50B,EAAcC,WACfyc,QAAQC,KAAM,WAAU,KAAKyV,qJAAqJ,EAEtLuC,EAAOE,WAAaC,GAAMC,KAAK,CAC3B/hC,KAAe,sBAAqB,KAAKo/B,gHACzC4C,QAAc,IACd9pB,YAAcypB,CAClB,CAAC,GAELxgC,EAAUysB,mBAAmB+T,EAAQ,mBAAmB,EACxDxgC,EAAU8gC,gBAAgBN,EAAQ,eAAgB7jC,GAAW,CACzD,MAAM2rB,EAASgH,GAAOyR,YAAYpkC,EAAS,QAAQ,EAC/CqgC,EAAiBvpB,KAAK3U,GAAOwpB,aAAkBxpB,CAAG,GAClD,KAAKkiC,kBAAkB1Y,CAAM,CAErC,CAAC,CACL,CACA,OAAO+X,YAAa,CAChB,KAAKlC,QAAU,GAEfJ,EAAckD,uBAAuB,KAAK3C,eAAe,EAEzDP,EAAcsB,oBAAoB,KAAKhB,SAAU,CAAC,EAClD,KAAKM,eAAc,CACvB,CACA,OAAOqC,kBAAkB1Y,EAAQ,CAC7BA,EAAO4Y,KAAK,CACR57B,KAAQ,oJACR2F,KAAQ,kBACR5K,KAAQ,QACR8gC,MAAQ,QACZ,CAAC,CACL,CACA,OAAOC,aAAazkC,EAAS,CACzB0kC,UAAAA,EAAY,4BACZC,WAAAA,EAAa,6BACb,CAAA,EAAI,CAAA,IAAAC,EAAAC,EAEJ,GAAIzD,EAAcC,YAAYyD,OAAS,KACnC,OAEJ,MACIC,GAAYH,EAAAvhC,EAAU2hC,aAAS,MAAAJ,IAAA,SAAAC,EAAnBD,EAAqBhhC,QAAIihC,MAAAA,IAAzBA,QAAAA,EAA2B/kB,YAAW,EAAGmlB,SAAS,OAAO,EAAIP,EAAYC,EACrFO,EAAa;sLACyJH;;;;;;;;;;;wBAY1K/kC,EAAQ0I,MAAMy8B,gBAAmB,kCAAiCrC,OAAOsC,KAAKF,CAAS,KAC3F,CACJ,CAmCI,OAAOG,IAAa,eAhCE1E,GAAa,CACnCN,EAAiBp9B,KAAK09B,CAAS,EAC/B2E,GAAS/9B,MAAM,KAAM,CACjB,WAAWlF,QAAS,CAChB,MAAO,CACHkjC,MAAQ5E,EAEhB,CACA6E,iBAAkB,CACd,MACIjmC,EAAgB,KAChBkmC,EAAgBA,IAAM,CAClB,MAAMC,EAAUnmC,EAAG2Z,SAAWuL,OAAO5Q,OAAOtU,EAAG2Z,QAAQ,EAAI,CAAC3Z,CAAE,EAC9D,UAAW8C,KAAUqjC,EACbrjC,EAAOrC,SACP4gC,EAAa6D,aAAapiC,EAAOrC,OAAO,GAIxD0gC,EAAiBnhC,CAAa,EAC9BkmC,EAAa,EAEbrwB,EAAaS,GAAG,QAAS,IAAM,CAC3B4vB,EAAa,CACjB,CAAC,EACG7E,EAAakB,WACblB,EAAayD,kBAAkB9kC,CAAE,CAEzC,CACJ,CAAC,IAIiB8lC,EAAQ,EAC1BC,GAAS/9B,MAAM,KAAM,CACjB,WAAWlF,QAAS,CAChB,MAAO,CACHkjC,MAAQI,GAEhB,CACAC,eAAgB,CAAA,IAAAC,GACR,CAACjF,EAAakB,YAAS+D,EAAI,KAAKlmC,QAAI,MAAAkmC,IAAA,QAATA,EAAWC,cACtC,KAAKC,YAAYH,cAAcr+B,MAAM,KAAM/H,SAAS,CAE5D,CACA06B,YAAa,CAAA,IAAA8L,GACL,CAACpF,EAAakB,YAASkE,EAAI,KAAKrmC,QAAI,MAAAqmC,IAAA,QAATA,EAAWF,cACtC,KAAKC,YAAY7L,WAAW3yB,MAAM,KAAM/H,SAAS,CAEzD,CACA+sB,eAAgB,CAAA,IAAA0Z,GACR,CAACrF,EAAakB,YAASmE,EAAI,KAAKtmC,QAAI,MAAAsmC,IAAA,QAATA,EAAWH,cACtC,KAAKC,YAAYxZ,cAAchlB,MAAM,KAAM/H,SAAS,CAE5D,CACJ,CAAC,EAET,GAAC,GACA,IAAM,CAEH,MAAM0mC,EAAiB,wFAEvB,GAAI,CAAC5K,SAASiF,UAAY2F,EAAe1F,KAAKlF,SAASiF,SAASrN,IAAI,GAAK4P,OAAO9hB,MAAQ8hB,OACpF,OAEJ,IAAIhvB,EACJ,MAAMqyB,EAAc,CAChB,cACA,SAAS,EAGTC,EAAa,CAAC,WAAY,OAAQ,QAAS,YAAa,eAAgB,WAAW,EACnFC,EAAa,CAAC,UAAW,QAAS,MAAO,OAAO,EACpDF,EAAYG,OAAO,EAAG,EAAG,GAAGF,EAASllC,IAAIqlC,GAAQF,EAAWnlC,IAAIslC,GAAc,GAAEA,KAAaD,GAAM,CAAC,EAAEE,OAAO,aAAa,EAAEC,KAAI,CAAE,EAC9HpL,SAASiF,SAASD,KAAK3W,MAAMwc,EAAY9b,KAAK,GAAG,CAAC,EAClDvW,EAAK,eAGLA,EAAK,eAET,MAAM6yB,EAAYrL,SAASh4B,cAAc,QAAQ,EACjDqjC,EAAUnD,OAAS,UAAW,CAC1BV,OAAO8D,UAAY9D,OAAO8D,WAAa,CAAA,EACvC,SAASC,GAAO,CACZ/D,OAAO8D,UAAU3jC,KAAKzD,SAAS,CACnC,CACAqnC,EAAK,KAAM,IAAIryB,IAAM,EACrBqyB,EAAK,SAAU/yB,CAAE,GAErBwnB,SAASwL,KAAKjtB,YAAY8sB,CAAS,EACnCA,EAAU/C,IAAM,+CAAiD9vB,CACrE,GAAC",
  "names": ["ActionColumn", "Column", "groupHeaderReserved", "construct", "config", "store", "me", "arguments", "width", "flex", "grid", "ion", "paint", "thisObj", "disableIfGridReadOnly", "element", "classList", "add", "renderer", "internalRenderer", "externalRenderer", "column", "record", "callExternalRenderer", "_column$actions", "inGroupTitle", "meta", "subGrid", "_this$externalRendere", "call", "className", "children", "actions", "map", "actionConfig", "index", "_tooltip$startsWith", "visible", "showForGroup", "tooltip", "btip", "startsWith", "callback", "customRendererData", "action", "tag", "dataset", "Tooltip", "encodeConfig", "html", "cls", "onCellClick", "target", "_column$actions2", "contains", "actionIndex", "parentElement", "actionHandler", "onClick", "updateAutoWidth", "groupActions", "oldActions", "forEach", "actionOriginal", "push", "length", "_actions", "actionsHtml", "DomHelper", "createElement", "outerHTML", "measureText", "__publicField", "type", "fields", "name", "defaultValue", "defaults", "filterable", "groupable", "sortable", "editor", "searchable", "htmlEncode", "resizable", "minWidth", "ColumnStore", "registerColumnType", "exposeProperties", "_$name", "AggregateColumn", "NumberColumn", "function", "includeParentInChangeSet", "data", "columnStore", "configuredAlign", "configuredEditor", "storeListeners", "update", "prio", "oldStore", "_store", "un", "modelClass", "field", "fieldMap", "align", "canEdit", "isLeaf", "sumChildren", "args", "result", "i", "parseFloat", "avg", "onRecordUpdate", "changes", "rowManager", "bubble", "rec", "row", "getRowFor", "cellElement", "getCell", "renderCell", "getRawValue", "_record$children", "value", "fn", "isMathFn", "Math", "handler", "resolveCallback", "apply", "r", "set", "setData", "getValue", "canFillValue", "PercentColumn", "min", "max", "showValue", "lowThreshold", "summaryRenderer", "sum", "fitMode", "constructor", "internalCellCls", "defaultRenderer", "role", "tabIndex", "style", "text", "undefined", "resizeToFitContent", "fieldType", "RatingColumn", "emptyIcon", "filledIcon", "editable", "filterType", "ArrayHelper", "populate", "filled", "event", "readOnly", "starIndex", "indexOf", "parentNode", "childNodes", "metaKey", "shiftKey", "$name", "TemplateColumn", "template", "Error", "renderData", "isSpecialRow", "TimeColumn", "format", "formatValue", "groupRenderer", "groupRowFor", "innerHTML", "DateHelper", "parse", "get", "defaultEditor", "CellCopyPaste", "CopyPasteBase", "entityName", "afterConstruct", "afterSelectionModeChange", "client", "selectionMode", "cell", "_disabledBySelectionMode", "disabled", "copyOnly", "_copyOnly", "_this$client$features", "features", "cellEdit", "enabled", "Boolean", "canCopy", "_client$features$rowC", "selectedCells", "_selectedRows", "rowCopyPaste", "focusedCell", "isCellSelected", "canCutPaste", "_this$client$features2", "isEditing", "isActionAvailable", "actionName", "cut", "copy", "isCut", "cells", "filter", "_r$record", "copiedDataString", "cellsToString", "writeToClipboard", "trigger", "beforeCopy", "paste", "targetCell", "clipboardData", "readFromClipboard", "modifiedRecords", "targetCells", "setFromStringData", "selectCellRange", "beforePaste", "selectedCell", "populateCellMenu", "items", "cutCell", "cutText", "localeClass", "icon", "weight", "onItem", "pasteCell", "pasteText", "hasClipboardData", "copyCell", "copyText", "pluginConfig", "chain", "configurable", "useNativeClipboard", "VersionHelper", "isTestEnv", "GridFeatureManager", "registerFeature", "CellTooltip", "InstancePlugin", "processConfig", "initTip", "tip", "new", "forElement", "forSelector", "hoverDelay", "trackMouse", "getHtml", "getTooltipContent", "bind", "internalListeners", "pointerOver", "listeners", "configuredListeners", "initialConfig", "relayEvents", "onPointerOver", "getColumnFromElement", "tooltipRenderer", "setConfig", "doDestroy", "destroy", "doDisable", "disable", "activeTarget", "getRecordFromElement", "arg", "cellTooltip", "lastRecord", "generation", "lastRecordGeneration", "lastColumn", "_html", "Objects", "isPromise", "hide", "ColumnRename", "_this$editor", "after", "populateHeaderMenu", "rename", "L", "startEdit", "Event", "_this$client$getHeade", "getHeaderDataFromEvent", "textWrapper", "Editor", "owner", "render", "keyMap", "F2", "FillHandle", "mixin", "Delayable", "delayable", "handleSelection", "_fillListeners", "onContentChange", "afterColumnsChange", "fixElementHeights", "getCellDataFromEvent", "includeSingleAxisMatch", "overridden", "findPatternsIn2dRange", "range", "horizontal", "negative", "values", "id", "columnId", "isNaN", "rowOrCol", "pattern", "findPatternsIn1dRange", "lastValue", "next", "every", "val", "Date", "diffs", "ix", "shift", "Set", "size", "increaseBy", "getTime", "stringPattern", "currentIndex", "afterSelectionChange", "removeElements", "GlobalEvents", "isMouseDown", "delayUntilMouseUp", "_isExtending", "rangeSelection", "drawFillHandleAndBorder", "onMouseDown", "mouseMoveOrUp", "EventHelper", "on", "globalThis", "mouseover", "selectionDragMouseEventListenerElement", "mouseup", "preventDefault", "stopImmediatePropagation", "handled", "onMouseUp", "currentRange", "_isCropping", "selectionChange", "internalSelectRange", "from", "to", "extensionCells", "croppingCells", "some", "sel", "equals", "disableScrollingCloseToEdges", "suspendRefresh", "firstCell", "columnIndex", "rowIndex", "patterns", "changeMap", "Map", "reverse", "_me$calculateFillValu", "_column$calculateFill", "calculateFillValue", "changed", "resumeRefresh", "performSelection", "onMouseOver", "_cellSelector", "_cellSelector$_column", "first", "last", "cellData", "cellSelector", "normalizeCellContext", "_column", "region", "equalOrSmaller", "cs", "enableScrollingCloseToEdges", "allowCropping", "Location", "keepListeners", "_me$rangeSelection", "regionEl", "subGrids", "x", "Rectangle", "right", "y", "getRecordCoords", "bottom", "borderElement", "handleElement", "setRect", "height", "appendChild", "setTopLeft", "scrollWidth", "toggleCroppingCls", "newCells", "getRange", "handleClick", "rootElement", "delegate", "mousedown", "hasFillElements", "_this$croppingCells", "_this$client$getCell", "toggle", "_me$handleElement", "_me$borderElement", "remove", "removeListeners", "listener", "_shiftSelectRange", "c1", "c2", "parent", "isAvailable", "override", "camelCase", "mousemove", "touchdown", "touchmove", "touchup", "pointerover", "mouseout", "dblclick", "keydown", "keypress", "keyup", "contextmenu", "MergeCells", "mergedRanges", "mergedMap", "before", "eachSubGrid", "setupSubGrid", "renderDone", "bindStore", "$mergedCellsElement", "beforeInternalResize", "isConfiguring", "isDisabling", "reset", "updatePassthrough", "use", "updateSortedOnly", "sortedOnly", "detachListeners", "change", "refresh", "onInternalResize", "refreshBounds", "beforeRenderCell", "mergeCells", "isSorted", "collapsed", "mergedRange", "getMergeRange", "afterRenderRow", "oldId", "oldHeight", "heightChanged", "slice", "removeRange", "syncDom", "afterRemove", "afterToggleGroup", "afterToggleSubGrid", "passthrough", "indices", "selectedRecords", "allSelected", "fromIndex", "toIndex", "includes", "isSelected", "_element$elementData", "elementData", "getAt", "_element$elementData2", "mergeable", "handleEvent", "mergedCellsElement", "closest", "StringHelper", "capitalize", "eventData", "records", "firstElementChild", "triggerEvent", "toLowerCase", "getRowAt", "clientY", "startEditing", "onRangeClick", "onStoreChange", "onStoreRefresh", "createRangeElement", "_parent$syncIdMap", "_parent$releasedIdMap", "getSubGridFromColumn", "syncId", "syncIdMap", "releasedIdMap", "createRangeDomConfig", "DomSync", "addChild", "_column$mergedRendere", "top", "left", "domConfig", "DomClassList", "cellCls", "assign", "autoCls", "keepChildren", "rowHeight", "mergedRenderer", "buildMergedCellsConfig", "rows", "_rowManager$topRow", "_rowManager$bottomRow", "topRow", "dataIndex", "bottomRow", "domConfigMap", "regions", "reduce", "updateRange", "force", "sync", "targetElement", "syncIdField", "onRenderDone", "redraw", "columns", "visibleColumns", "c", "hadRanges", "refreshSuspended", "rowCount", "boundsMap", "bounds", "topRendered", "bottomRendered", "rowOffsetHeight", "findIndex", "getRowById", "rowsAbove", "offsetHeight", "rowsBelow", "key", "earlierRecord", "earlierValue", "earlierIndex", "laterRecord", "laterValue", "laterIndex", "cellBounds", "QuickFind", "properties", "hitCls", "hitCellCls", "hitCellBadgeCls", "hitTextCls", "Object", "treeWalker", "setupTreeWalker", "NodeFilter", "SHOW_TEXT", "FILTER_ACCEPT", "isActionable", "find", "clear", "showQuickFind", "header", "getHeaderElement", "headerField", "badge", "returnAll", "mode", "colHeader", "found", "hideHeaders", "renderListenerInitialized", "rendercell", "hideQuickFind", "hit", "prevFound", "forceInnerHTML", "_content", "removeChild", "search", "columnFieldOrId", "fromSplit", "_grid$syncSplits", "getById", "findByField", "foundMap", "findRe", "RegExp", "escapeRegExp", "String", "_originalContent", "gotoClosestHit", "syncSplits", "other", "quickFind", "_this$found", "foundCount", "_this$found2", "gotoHit", "nextHit", "focusCell", "doSelect", "focusedIndex", "foundSorted", "sort", "a", "b", "abs", "gotoFirstHit", "gotoLastHit", "gotoNextHit", "_grid$_focusedCell", "_grid$lastFocusedCell", "currentId", "_focusedCell", "lastFocusedCell", "gotoPrevHit", "_grid$_focusedCell2", "_grid$lastFocusedCell2", "prevHit", "_me$foundMap", "hitIndex", "isQuickHit", "inner", "currentNode", "down", "textNode", "nextNode", "nodeToReplace", "textContent", "nodeValue", "newText", "offset", "lastIndex", "match", "exec", "preamble", "substring", "spaceBefore", "v", "spaceAfter", "encodeHtml", "insertBefore", "createElementFromTemplate", "join", "fragment", "onBackspace", "substr", "clearSearch", "showFilterEditor", "onElementKeyPress", "_event$key", "onCellNavigate", "fromCellSelector", "toCellSelector", "F3", "Escape", "Backspace", "storeRemoveActions", "replace", "RowExpander", "expanderBodyClass", "expandedRowClass", "shadowRootContainerClass", "recordStateMap", "collapsingStateMap", "widget", "console", "warn", "isGanttBase", "fixedRowHeight", "theme", "onThemeChange", "addColumn", "resizeObserver", "ResizeObserver", "entries", "onExpanderBodyResize", "renderFromRow", "changeLoadingIndicatorText", "onGridBodyFocusIn", "_me$client$lastMoused", "_me$client$lastMoused2", "matches", "lastMousedownEvent", "keyMapOnKeyDown", "_target$classList", "isAnimating", "wasAnimating", "changeColumn", "has", "toggleExpand", "hideable", "_isAddingExpanderColumn", "_expander", "columnPosition", "insert", "onTriggerEvent", "collapse", "expand", "entry", "_entry$target$parentE", "_entry$target$parentE2", "_domData", "recordState", "ignoreResize", "expanderBodyHeight", "processRowHeight", "bufferedRenderer", "source", "changedKeys", "keys", "state", "_state$widget", "delete", "refreshOnRecordChange", "isCreated", "renderFromRecord", "topRecordIndex", "topRecord", "isRenderingAsync", "loadingIndicatorHeight", "expandedBodyElements", "beforeRenderRow", "enableAnimations", "waitForTransition", "collapsingState", "_collapsingState$widg", "removeExpander", "renderExpander", "rowElement", "getElement", "bodyElement", "removeEachSelector", "observe", "renderPromiseResolver", "delay", "renderLoadingIndicator", "lockCellHeight", "cellHeight", "_shouldScrollIntoView", "autoScroll", "isInView", "once", "scrollRowIntoView", "onTransitionEnd", "property", "duration", "getPropertyTransitionDuration", "destroyWidget", "child", "querySelectorAll", "_child$widget", "unobserve", "loadingIndicators", "loadingIndicatorText", "_row$cells$", "dataField", "renderPromises", "continueRendering", "content", "expanderElement", "createWidget", "widgetConfig", "_DomHelper$getThemeIn", "themeName", "getThemeInfo", "shadowRootContainer", "shadowRoot", "_shadowRoot", "attachShadow", "cloneStylesIntoShadowRoot", "then", "isDestroyed", "fieldData", "isStore", "relatedStore", "themeCls", "Widget", "create", "ObjectHelper", "appendTo", "minHeight", "isNested", "catch", "href", "expanderBodyElement", "addCls", "renderResponse", "Promise", "all", "_recordState$loadingI", "_me$renderRowsWithAni", "li", "renderRowsWithAnimation", "_row$removeCls", "removeCls", "_a", "_bufferedRecords", "_rafPromise", "resolve", "requestAnimationFrame", "_this$internalRender", "internalRender", "resolvePromise", "unlock", "_me$client$syncSplits", "_me$client", "rowExpander", "_me$trigger", "expandedElements", "_me$client$syncSplits2", "_me$client2", "navigateDown", "onKeyboardIn", "navigateUp", "catchFocus", "navigationDirection", "editing", "body", "getNext", "_isDefaultFocus", "getNavigateableColumn", "cellContext", "up", "_state$expandedBodyEl", "_state$expandedBodyEl2", "_focusedCell$column", "isGrid", "_grid$features$rowExp", "checkboxSelectionColumn", "isDisabled", "onTab", "previous", "_this$recordStateMap$", "_widget$features$cell", "activeRecord", "nextCell", "getAdjacentEditableCell", "expandedRecord", "finishEditing", "onShiftTab", "_this$resizeObserver", "disconnect", "_state$widget2", "prev", "querySelector", "_bodyElement$widget", "_bodyElement$widget$e", "_bodyElement$widget2", "_bodyElement$widget2$", "getExpandedRecord", "elementOrWidget", "obj", "isWidget", "curEl", "Tab", "Search", "hitEls", "expandNode", "onTreeNodeExpand", "reapply", "col", "formatters", "_col$formatValue", "isTree", "expandTo", "prevValue", "belongsTo", "clearHits", "limit", "listenersInitialized", "asyncEventSuffix", "refreshRows", "isHitFocused", "DomDataStore", "silent", "_grid$syncSplits2", "_focusedCell$cell", "getActiveElement", "fromStart", "_me$found", "fromCell", "_me$found2", "showHitIndex", "_cellElement$querySel", "getSelection", "toString", "innerText", "featureClass", "StickyCells", "defaultConfig", "contentSelector", "currentTopRowCls", "scroll", "reference", "removeClasses", "renderRows", "onGridScroll", "contentElement", "gridViewport", "bodyContainer", "roundPx", "currentTopRow", "topRowChanged", "updateStickyContent", "notEnoughHeight", "scrollable", "stickyContentHeight", "stickyContentTop", "alignTo", "stickyEls", "constrainTo", "lastProcessedTopRow", "rowClasses", "cellClasses", "stickyContent", "document", "createDocumentFragment", "e", "eachElement", "rowEl", "firstChild", "eTop", "offsetTop", "alignSelf", "cloneNode", "syncClassList", "FileDrop", "drop", "onFileDrop", "dragover", "onFileDragOver", "dragenter", "onFileDragEnter", "dragleave", "onFileDragLeave", "onFileLoad", "domEvent", "file", "relatedTarget", "dataTransfer", "getAsFile", "GroupBar", "ChipView", "treeGrid", "onTreePaint", "treeGroup", "columnReorder", "usingGroupBarWidget", "Store", "onStoreChanged", "treeGroupChange", "onTreeGroupChanged", "beforeColumnDropFinalize", "onBeforeColumnDropFinalize", "columnDrag", "onColumnDrag", "columnDragStart", "onColumnDragStart", "columnDrop", "onColumnDrop", "levels", "_records$", "isConstructing", "ignoreGroupChange", "level", "Function", "fieldName", "context", "valid", "isTreeColumn", "_this$store$getById", "selectedCls", "itemTpl", "displayField", "initClass", "TreeCombo", "Combo", "changePicker", "picker", "oldPicker", "_picker", "updateMultiSelect", "multiSelect", "updateReadOnly", "_value$map", "_settingValue", "onPickerSelectionChange", "selection", "disableGridRowModelWarning", "rowCheckboxSelection", "chipView", "xss", "overflowX", "HOSTS", "EXPIRING_CLASSES", "host", "location", "test", "initialized", "initExpiryHelper", "baseClass", "ExpiryHelper", "__foo", "product", "productName", "version", "getVersion", "callHomeDelay", "blockUrl", "BrowserHelper", "queryString", "Product", "verifyUrl", "blocked", "lastVersionCheck", "trialKey", "versionCheckKey", "log", "cacheTrialStartTime", "isExpired", "readyState", "onTrialExpired", "addEventListener", "setTimeout", "updateBlockedStatus", "timeString", "getLocalStorageItem", "time", "Number", "trialStartTime", "now", "setLocalStorageItem", "_window$bryntum", "_window$bryntum$this$", "ONE_DAY", "window", "bryntum", "expired", "saveVersionCheckKey", "url", "encodeURIComponent", "logUrl", "license", "img", "Image", "onload", "naturalWidth", "blockTrial", "onerror", "src", "rootEl", "expirationShown", "floatRoot", "Toast", "show", "timeout", "forEachSelector", "fromElement", "maskExpiredWidget", "removeLocalStorageItem", "mask", "cover", "setWaterMark", "darkColor", "lightColor", "_DomHelper$themeInfo", "_DomHelper$themeInfo$", "thumb", "color", "themeInfo", "endsWith", "svgString", "backgroundImage", "btoa", "GridBase", "Override", "class", "onPaintOverride", "setWatermarks", "targets", "RowManager", "matchRowCount", "_this$grid", "isScheduler", "_overridden", "_this$grid2", "_this$grid3", "ignoreDomainRe", "websiteUrls", "products", "frameworks", "splice", "prod", "framework", "concat", "flat", "newScript", "dataLayer", "gtag", "head"]
}
