{
  "version": 3,
  "sources": ["../../../TaskBoard/lib/TaskBoard/feature/TaskBoardFeature.js", "../../../TaskBoard/lib/TaskBoard/feature/ColumnDrag.js", "../../../TaskBoard/lib/TaskBoard/feature/ColumnHeaderMenu.js", "../../../TaskBoard/lib/TaskBoard/feature/ColumnToolbars.js", "../../../TaskBoard/lib/TaskBoard/view/item/TaskItem.js", "../../../TaskBoard/lib/TaskBoard/feature/SimpleTaskEdit.js", "../../../TaskBoard/lib/TaskBoard/feature/SwimlaneDrag.js", "../../../TaskBoard/lib/TaskBoard/feature/TaskDrag.js", "../../../TaskBoard/lib/TaskBoard/feature/TaskDragSelect.js", "../../../TaskBoard/lib/TaskBoard/widget/mixin/TaskBoardLinked.js", "../../../TaskBoard/lib/TaskBoard/widget/base/ColorBoxCombo.js", "../../../TaskBoard/lib/TaskBoard/widget/ColumnCombo.js", "../../../TaskBoard/lib/TaskBoard/widget/ResourcesCombo.js", "../../../TaskBoard/lib/TaskBoard/widget/SwimlaneCombo.js", "../../../TaskBoard/lib/TaskBoard/widget/TaskColorPicker.js", "../../../TaskBoard/lib/TaskBoard/widget/TaskColorCombo.js", "../../../TaskBoard/lib/TaskBoard/widget/TaskEditor.js", "../../../TaskBoard/lib/TaskBoard/feature/TaskEdit.js", "../../../TaskBoard/lib/TaskBoard/feature/TaskMenu.js", "../../../TaskBoard/lib/TaskBoard/feature/TaskTooltip.js", "../../../TaskBoard/lib/TaskBoard/model/ColumnModel.js", "../../../TaskBoard/lib/TaskBoard/model/TaskModel.js", "../../../TaskBoard/lib/TaskBoard/store/TaskStore.js", "../../../TaskBoard/lib/TaskBoard/model/ProjectModel.js", "../../../TaskBoard/lib/TaskBoard/model/SwimlaneModel.js", "../../../TaskBoard/lib/TaskBoard/view/mixin/ExpandCollapse.js", "../../../TaskBoard/lib/TaskBoard/view/mixin/ResponsiveCards.js", "../../../TaskBoard/lib/TaskBoard/view/mixin/TaskBoardColumns.js", "../../../TaskBoard/lib/TaskBoard/view/mixin/TaskBoardDom.js", "../../../TaskBoard/lib/TaskBoard/view/mixin/TaskBoardDomEvents.js", "../../../TaskBoard/lib/TaskBoard/view/mixin/TaskBoardScroll.js", "../../../TaskBoard/lib/TaskBoard/view/mixin/TaskBoardStores.js", "../../../TaskBoard/lib/TaskBoard/view/mixin/TaskBoardSwimlanes.js", "../../../TaskBoard/lib/TaskBoard/view/mixin/TaskBoardVirtualization.js", "../../../TaskBoard/lib/TaskBoard/view/item/TextItem.js", "../../../TaskBoard/lib/TaskBoard/view/item/ResourceAvatarsItem.js", "../../../TaskBoard/lib/TaskBoard/view/mixin/TaskItems.js", "../../../TaskBoard/lib/TaskBoard/view/mixin/TaskNavigation.js", "../../../TaskBoard/lib/TaskBoard/view/mixin/TaskSelection.js", "../../../TaskBoard/lib/TaskBoard/view/item/ImageItem.js", "../../../TaskBoard/lib/TaskBoard/view/item/ProgressItem.js", "../../../TaskBoard/lib/TaskBoard/view/item/RatingItem.js", "../../../TaskBoard/lib/TaskBoard/view/item/SeparatorItem.js", "../../../TaskBoard/lib/TaskBoard/widget/TagCombo.js", "../../../TaskBoard/lib/TaskBoard/view/item/TagsItem.js", "../../../TaskBoard/lib/TaskBoard/view/item/TemplateItem.js", "../../../TaskBoard/lib/TaskBoard/view/item/TodoListItem.js", "../../../TaskBoard/lib/TaskBoard/localization/En.js", "../../../TaskBoard/lib/TaskBoard/view/TaskBoardBase.js", "../../../TaskBoard/lib/TaskBoard/view/item/TaskMenuItem.js", "../../../TaskBoard/lib/TaskBoard/view/TaskBoard.js", "../../../TaskBoard/lib/TaskBoard/widget/ColumnFilterField.js", "../../../TaskBoard/lib/TaskBoard/widget/ColumnPickerButton.js", "../../../TaskBoard/lib/TaskBoard/widget/ColumnScrollButton.js", "../../../TaskBoard/lib/TaskBoard/widget/ProjectCombo.js", "../../../TaskBoard/lib/TaskBoard/widget/SwimlaneFilterField.js", "../../../TaskBoard/lib/TaskBoard/widget/SwimlanePickerButton.js", "../../../TaskBoard/lib/TaskBoard/widget/SwimlaneScrollButton.js", "../../../TaskBoard/lib/TaskBoard/widget/TaskFilterField.js", "../../../TaskBoard/lib/TaskBoard/widget/TodoListField.js", "../../../TaskBoard/lib/TaskBoard/widget/UndoRedo.js", "../../../TaskBoard/lib/TaskBoard/widget/ZoomSlider.js", "../../../TaskBoard/bundle/entry.thin.js"],
  "sourcesContent": ["import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport Factoryable from '../../Core/mixin/Factoryable.js';\n\n/**\n * @module TaskBoard/feature/TaskBoardFeature\n */\n\n/**\n * The abstract base class for TaskBoard features.\n *\n * @extends Core/mixin/InstancePlugin\n * @abstract\n */\nexport default class TaskBoardFeature extends InstancePlugin.mixin(Factoryable) {\n    static factoryable = {};\n\n    static configurable = {};\n\n    // This makes all feature config changes after initialization recompose TaskBoard\n    onConfigChange(args) {\n        if (!this.isConfiguring && !this.isDestroying) {\n            this.client.recompose();\n        }\n        super.onConfigChange(args);\n    }\n}\n", "import TaskBoardFeature from './TaskBoardFeature.js';\nimport Base from '../../Core/Base.js';\nimport ArrayHelper from '../../Core/helper/ArrayHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport Draggable from '../../Core/mixin/Draggable.js';\nimport Droppable from '../../Core/mixin/Droppable.js';\nimport Events from '../../Core/mixin/Events.js';\n\n/**\n * @module TaskBoard/feature/ColumnDrag\n */\n\n/**\n * This feature allows users to drag columns on the TaskBoard to change the column order. Drag is initiated upon\n * mouse down in the column header. Try it out below!\n *\n * {@inlineexample TaskBoard/feature/ColumnDrag.js}\n *\n * Works just as well when using swimlanes:\n *\n * {@inlineexample TaskBoard/feature/ColumnDragSwimlanes.js}\n *\n * ## Drag events\n *\n * The different stages of a drag operation trigger different events, in order of appearance:\n *\n * | Event                           | Description                                                                    |\n * |---------------------------------|--------------------------------------------------------------------------------|\n * | {@link #event-beforeColumnDrag} | Preventable event fired before a drag starts                                   |\n * | {@link #event-columnDragStart}  | Fired when dragging starts                                                     |\n * | {@link #event-columnDrag}       | Fired when movement during a drag will lead to changes                         |\n * | {@link #event-beforeColumnDrop} | Preventable event fired before finalizing a valid drop. Allows async listeners |\n * | {@link #event-columnDrop}       | Fired after finalizing a valid drop                                            |\n * | {@link #event-columnDragAbort}  | Fired when a drag is aborted (ESC, drop out of bounds or by a listener)        |\n * | {@link #event-columnDragEnd}    | Fired when a started drag ends, no matter the outcome                          |\n *\n * This feature is **disabled** by default.\n *\n * @extends TaskBoard/feature/TaskBoardFeature\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype columnDrag\n * @feature\n */\nexport default class ColumnDrag extends TaskBoardFeature {\n    static $name = 'ColumnDrag';\n\n    static type = 'columnDrag';\n\n    static pluginConfig = {\n        after : ['initialCompose', 'populateColumnHeaderMenu']\n    };\n\n    initialCompose() {\n        const me = this;\n\n        // Cannot use configurable since bodyElement is not available yet when feature is pulled in\n        me.draggable = ColumnZone.new({\n            dragRootElement : me.disabled ? null : me.client.bodyWrapElement,\n            dropRootElement : me.client.bodyWrapElement,\n            owner           : me,\n\n            internalListeners : {\n                beforeDragStart : 'onBeforeDragStart',\n                dragStart       : 'onDragStart',\n                thisObj         : me\n            }\n        }, me.draggable);\n    }\n\n    doDestroy() {\n        this.draggable?.destroy();\n\n        super.doDestroy();\n    }\n\n    doDisable(disable) {\n        super.doDisable(disable);\n\n        if (this.draggable) {\n            this.draggable.dragRootElement = disable ? null : this.client.bodyWrapElement;\n        }\n    }\n\n    movePrev(columnRecord) {\n        const { columns } = this.client;\n\n        columns.move(columnRecord, columns.getPrev(columnRecord));\n    }\n\n    moveNext(columnRecord) {\n        const\n            { columns } = this.client,\n            beforeIndex = Math.min(columns.indexOf(columnRecord) + 2, columns.count);\n\n        columns.move(columnRecord, columns.getAt(beforeIndex));\n    }\n\n    populateColumnHeaderMenu({ items, columnRecord }) {\n        const\n            { client }       = this,\n            { columns, rtl } = client;\n\n        if (!client.readOnly && !this.disabled) {\n            items.moveColumnLeft = {\n                text     : 'L{TaskBoard.moveColumnLeft}',\n                icon     : 'b-fw-icon b-icon-left',\n                disabled : columnRecord === columns[rtl ? 'last' : 'first'],\n                weight   : 200,\n                onItem   : () => this['move' + (rtl ? 'Next' : 'Prev')](columnRecord)\n            };\n\n            items.moveColumnRight = {\n                text     : 'L{TaskBoard.moveColumnRight}',\n                icon     : 'b-fw-icon b-icon-right',\n                disabled : columnRecord === columns[rtl ? 'first' : 'last'],\n                weight   : 300,\n                onItem   : () => this['move' + (rtl ? 'Prev' : 'Next')](columnRecord)\n            };\n        }\n    }\n\n    onBeforeDragStart({ drag, event }) {\n        /**\n         * Fires on the owning TaskBoard before column dragging starts. Return `false` to prevent the action\n         * @event beforeColumnDrag\n         * @preventable\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n         * @param {TaskBoard.model.ColumnModel} columnRecord Column to be dragged\n         */\n        return this.client.trigger('beforeColumnDrag', { drag, event, columnRecord : drag.columnRecord });\n    }\n\n    onDragStart({ drag, event }) {\n        /**\n         * Fires on the owning TaskBoard when column dragging starts\n         * @event columnDragStart\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n         * @param {TaskBoard.model.ColumnModel} columnRecord Column to be dragged\n         */\n        return this.client.trigger('columnDragStart', { drag, event, columnRecord : drag.columnRecord });\n    }\n}\n\nColumnDrag.initClass();\n\nclass ColumnZone extends Base.mixin(Draggable, Droppable, Events) {\n    static get configurable() {\n        return {\n            dragSelector     : '.b-taskboard-column-header, .b-taskboard-column-header *',\n            dragItemSelector : '.b-taskboard-column-header',\n\n            // Column has multiple parts (header + one element per swimlane), going to add cls manually to them\n            draggingItemCls : null,\n\n            dragProxy : {\n                type : 'default',\n\n                async open(drag) {\n                    const\n                        { owner }    = this,\n                        {\n                            itemElement,\n                            startEvent,\n                            columnRecord\n                        }            = drag,\n                        taskBoard    = owner.owner.client,\n                        headerBounds = Rectangle.from(itemElement, owner.dragRootElement),\n                        // Offset from cursor\n                        proxyOffset  = EventHelper.getClientPoint(startEvent).getDelta(headerBounds),\n                        // Drag proxy, positioned over column being dragged\n                        proxy        = DomHelper.createElement({\n                            className : 'b-taskboard-column-drag-proxy',\n                            parent    : owner.dragRootElement,\n                            style     : {\n                                // Using fixed top, only draggable horizontally\n                                top   : headerBounds.y,\n                                // Offset from cursor to be positioned over original column\n                                left  : EventHelper.getClientPoint(startEvent).translate(proxyOffset[0], 0).x,\n                                // Need a fixed width on the proxy, since columns width might be flexed etc\n                                width : itemElement.getBoundingClientRect().width\n                            },\n                            // Don't want it being removed while dragging\n                            retainElement : true\n                        }),\n                        // A column consists of multiple elements, a header and one \"column\" per swimlane (at least one)\n                        elements     = [itemElement, ...taskBoard.getColumnElements(columnRecord)];\n\n                    // Things we want to access later on drag\n                    Object.assign(drag, {\n                        proxy,\n                        elements,\n                        proxyOffset\n                    });\n\n                    // Clone all dragged column elements and put them in the proxy\n                    elements.forEach((element, i) => {\n                        const\n                            columnClone = element.cloneNode(true),\n                            bounds      = element.getBoundingClientRect();\n\n                        // Store size, used to size drop indicator later\n                        element.originalWidth = bounds.width;\n                        element.originalHeight = bounds.height;\n\n                        // Mimic element structure, swimlane > column (not fully mimicking it for now, should suffice)\n                        if (element.matches('.b-taskboard-column')) {\n                            const\n                                swimlane      = element.closest('.b-taskboard-swimlane'),\n                                header        = DomSync.getChild(swimlane, 'header'),\n                                body          = DomSync.getChild(swimlane, 'body'),\n                                swimlaneClone = swimlane.cloneNode(),\n                                headerClone   = header?.cloneNode(true),\n                                bodyClone     = body.cloneNode();\n\n                            let height = swimlane.getBoundingClientRect().height;\n\n                            // Last swimlane has bottom padding that we do not want in proxy\n                            if (i === elements.length - 1) {\n                                const paddingBottom = DomHelper.getStyleValue(element.parentElement, 'padding-bottom');\n                                height -= parseFloat(paddingBottom);\n                            }\n\n                            // Use fixed height on the swimlanes in the drag proxy, to have it exactly match the board.\n                            // Otherwise it would shrinkwrap\n                            swimlaneClone.style.flex = `0 0 ${height}px`;\n\n                            headerClone && swimlaneClone.appendChild(headerClone);\n                            bodyClone.appendChild(columnClone);\n                            swimlaneClone.appendChild(bodyClone);\n\n                            proxy.appendChild(swimlaneClone);\n                        }\n                        // Column header\n                        else {\n                            proxy.appendChild(columnClone);\n                        }\n\n                        // Hide original column after measuring it above\n                        element.classList.add('b-drag-original');\n                    });\n                },\n\n                dragMove({ proxy, event, proxyOffset }) {\n                    // Move along x-axis only\n                    const position = EventHelper.getClientPoint(event).translate(proxyOffset[0], 0);\n\n                    proxy.style.left = `${position.x}px`;\n                }\n            }\n        };\n    }\n\n    setupDragContext(event) {\n        const\n            result = super.setupDragContext(event),\n            { client } = this.owner;\n\n        result.scrollManager = client.scrollManager;\n        result.monitoringConfig = {\n            scrollables : [{\n                element   : client.bodyElement,\n                direction : 'horizontal'\n            }]\n        };\n\n        return result;\n    }\n\n    // Populate the drag context early, to have something to take decisions on in beforeDragStart listeners\n    startDrag(drag) {\n        drag.columnRecord = this.owner.client.resolveColumnRecord(drag.itemElement);\n\n        return super.startDrag(drag);\n    }\n\n    dragStart(drag) {\n        // Even though the size of other columns should not be affected, we might decide to animate in the future.\n        // Suspending responsiveness to not have it kick in if we do...\n        this.owner.client.suspendResponsiveness();\n\n        drag.wasStarted = true;\n    }\n\n    dragEnter(drag) {\n        // Only accept columns\n        if (!drag.itemElement.matches(this.dragItemSelector)) {\n            return false;\n        }\n\n        // Create drop indicators on first enter\n        if (!drag.dropIndicators) {\n            // Need one indicator for each part of the column\n            drag.dropIndicators = drag.elements.map((element, i) => DomHelper.createElement({\n                className   : 'b-taskboard-column-drop-indicator',\n                elementData : {\n                    dropIndicator : true,\n                    // Tag along the element, to be able to return the drop indicator to its position for\n                    // invalid drop targets. NOTE: Currently not used\n                    element\n                },\n                // Use same size as dragged column had originally\n                style : {\n                    width  : element.originalWidth,\n                    height : element.originalHeight\n                }\n            }));\n\n            this.insertDropIndicators(drag, drag.columnRecord);\n        }\n    }\n\n    insertDropIndicators(drag, beforeColumnRecord) {\n        // Figure out insertion index among headers, will use same index within swimlanes\n        const\n            { client } = this.owner,\n            insertAt   = client.columns.indexOf(beforeColumnRecord);\n\n        // Insert all drop indicators\n        drag.dropIndicators.forEach((dropIndicator, i) => {\n            // Header\n            if (i === 0) {\n                // Insert at correct place among column headers\n                const\n                    headerContainer = DomSync.getChild(client.bodyElement, 'header'),\n                    actualHeaders   = [...headerContainer.children];\n\n                ArrayHelper.remove(actualHeaders, dropIndicator);\n\n                headerContainer.insertBefore(dropIndicator, actualHeaders[insertAt]);\n            }\n            // Column\n            else {\n                // Insert it at correct place within corresponding swimlane\n                const\n                    // Get corresponding swimlane (default if swimlanes not used)\n                    swimlaneRecord = client.swimlanes?.getAt(i - 1) ?? { domId : 'default' },\n                    swimlaneBody   = DomSync.getChild(client.getSwimlaneElement(swimlaneRecord), 'body'),\n                    actualColumns  = [...swimlaneBody.children];\n\n                ArrayHelper.remove(actualColumns, dropIndicator);\n\n                swimlaneBody.insertBefore(dropIndicator, actualColumns[insertAt]);\n            }\n        });\n    }\n\n    updateValidity(drag, valid) {\n        drag.proxy.classList.toggle('b-invalid', !valid);\n        drag.dropIndicators.forEach(dropIndicator => dropIndicator.classList.toggle('b-invalid', !valid));\n        drag.invalid = !valid;\n    }\n\n    dragMove(drag) {\n        const\n            { client }          = this.owner,\n            documentRoot        = client.documentRoot,\n            proxyBounds         = Rectangle.from(drag.proxy, undefined, true),\n            // Check element under proxy top center, should get a column header (or a gap)\n            overElement         = documentRoot.elementFromPoint(proxyBounds.center.x, proxyBounds.y),\n            columnHeaderElement = overElement?.closest('.b-taskboard-column-header');\n\n        if (drag.invalid) {\n            drag.valid = false;\n        }\n\n        // If we are over the drop indicator or something not a column header, we do nothing\n        if (!overElement?.elementData?.dropIndicator && columnHeaderElement) {\n            const targetBounds = Rectangle.from(columnHeaderElement);\n\n            // Column that we are going to insert the dragged column before or after\n            let beforeColumn = client.resolveColumnRecord(columnHeaderElement);\n\n            // If beyond center, insert before next column\n            if (proxyBounds.center.x > targetBounds.center.x) {\n                beforeColumn = client.columns.getNext(beforeColumn);\n            }\n\n            this.insertDropIndicators(drag, beforeColumn);\n\n            // Only trigger if order will change\n            const shouldTrigger = drag.beforeColumn !== beforeColumn;\n\n            drag.beforeColumn = beforeColumn;\n\n            if (shouldTrigger) {\n                /**\n                 * Fires on the owning TaskBoard when a column is dragged, if the drag leads to a change compared to\n                 * the last columnDrag event.\n                 *\n                 * Returning `false` from a listener will flag the drag as invalid (by default turning the drop\n                 * indicator red)\n                 *\n                 * ```javascript\n                 * const taskBoard = new TaskBoard({\n                 *    listeners : {\n                 *        // Do not allow moving beyond last column\n                 *        columnDrag({ columnRecord, beforeColumn }) {\n                 *           return beforeColumn === null;\n                 *        }\n                 *    }\n                 * });\n                 * ```\n                 *\n                 * @event columnDrag\n                 * @on-owner\n                 * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n                 * @param {TaskBoard.model.ColumnModel} columnRecord Column being dragged\n                 * @param {TaskBoard.model.ColumnModel} beforeColumn Insert before this column on drop, `null` if last\n                 */\n                const result = client.trigger('columnDrag', { drag, columnRecord : drag.columnRecord, beforeColumn });\n\n                this.updateValidity(drag, result !== false);\n            }\n        }\n    }\n\n    async dragDrop(drag) {\n        // Data part\n        const\n            { client }  = this.owner,\n            { columns } = client,\n            {\n                columnRecord,\n                beforeColumn,\n                elements,\n                dropIndicators,\n                proxy\n            }           = drag;\n\n        /**\n         * Fires on the owning TaskBoard when dropping a column, before the operation completes. Handles async\n         * listeners, returning `false` from one will abort the operation\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    listeners : {\n         *        async beforeColumnDrop({ columnRecord, beforeColumn }) {\n         *            // Show confirmation dialog\n         *            const result = await MessageDialog.confirm({\n         *                title   : 'Verify drop',\n         *                message : `Please confirm moving ${columnRecord.text} before ${beforeColumn.text}?`\n         *            });\n         *\n         *            // Returning false will abort the drop (if user pressed Cancel)\n         *            return result === MessageDialog.okButton;\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @event beforeColumnDrop\n         * @preventable\n         * @async\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n         * @param {TaskBoard.model.ColumnModel} columnRecord Dropped column\n         * @param {TaskBoard.model.ColumnModel} beforeColumn Dropped before this column\n         */\n        if (drag.invalid || await client.trigger('beforeColumnDrop', { drag, columnRecord, beforeColumn }) === false) {\n            drag.valid = false;\n        }\n        else {\n            drag.finalizer = new Promise(resolve => {\n                function commit() {\n                    // Remove proxy & dropIndicator\n                    proxy.remove();\n                    dropIndicators.forEach(dropIndicator => dropIndicator.remove());\n\n                    // Restore original elements\n                    elements.forEach(element => element.classList.remove('b-drag-original'));\n\n                    // Update data\n                    client.suspendDomTransition();\n                    beforeColumn !== undefined && columns.move(columnRecord, beforeColumn);\n                    client.resumeDomTransition();\n\n                    /**\n                     * Fires on the owning TaskBoard when a column is successfully dropped (after the drop transition\n                     * has finished)\n                     * @event columnDrop\n                     * @on-owner\n                     * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n                     * @param {TaskBoard.model.ColumnModel} columnRecord Dropped column\n                     * @param {TaskBoard.model.ColumnModel} beforeColumn Dropped before this column (`null` if last)\n                     * @param {TaskBoard.model.SwimlaneModel} targetSwimlane Dropped in this swimlane (if used)\n                     */\n                    client.trigger('columnDrop', { drag, columnRecord, beforeColumn });\n\n                    /**\n                     * Fires on the owning TaskBoard when a previously started drag operation ends, no matter the\n                     * outcome of it (whether valid, invalid or aborted)\n                     *\n                     * @event columnDragEnd\n                     * @on-owner\n                     * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n                     * @param {TaskBoard.model.ColumnModel} columnRecord Affected column\n                     */\n                    client.trigger('columnDragEnd', { drag, columnRecord, beforeColumn });\n\n                    client.resumeResponsiveness();\n\n                    resolve();\n                }\n\n                // UI part\n\n                // We are dropping, this cls by default has a transition\n                proxy.classList.add('b-dropping');\n\n                // Move proxy to drop location, allowing it to transition there\n                DomHelper.alignTo(\n                    proxy,\n                    Rectangle.from(dropIndicators[0], undefined, true)\n                );\n\n                // Update record after the transition, to prevent too early redraw (which would ruin the transition)\n                if (DomHelper.getPropertyTransitionDuration(proxy, 'transform')) {\n                    EventHelper.onTransitionEnd({\n                        element  : proxy,\n                        property : 'transform',\n                        handler  : commit,\n                        thisObj  : client\n                    });\n                }\n                // Or right away if no transition is used\n                else {\n                    commit();\n                }\n            });\n        }\n    }\n\n    dragLeave(drag) {\n        // Doing nothing feels ok for now\n    }\n\n    doAbort(drag) {\n        const\n            { client }                                        = this.owner,\n            { dropIndicators, proxy, columnRecord, elements } = drag;\n\n        if (proxy) {\n            function finalizeAbort() {\n                // Remove proxy & dropIndicator\n                proxy.remove();\n                dropIndicators.forEach(dropIndicator => dropIndicator.remove());\n\n                // Restore original elements\n                elements.forEach(element => element.classList.remove('b-drag-original'));\n\n                client.trigger('columnDragAbortFinalized');\n            }\n\n            // Emulate a drop on abort, to get transitions\n            proxy.classList.add('b-dropping');\n\n            // Move drop indicators to where column originated\n            dropIndicators.forEach((dropIndicator, i) => {\n                const original = drag.elements[i];\n\n                dropIndicator.classList.remove('b-invalid'); // Looks better if not invalid on return to origin\n\n                original.parentElement.insertBefore(dropIndicator, original);\n            });\n\n            // Move proxy to original location, allowing it to transition there\n            DomHelper.alignTo(\n                proxy,\n                Rectangle.from(dropIndicators[0], undefined, true)\n            );\n\n            // Finalize after transition\n            if (DomHelper.getPropertyTransitionDuration(proxy, 'transform')) {\n                EventHelper.onTransitionEnd({\n                    element  : proxy,\n                    property : 'transform',\n                    handler  : finalizeAbort,\n                    thisObj  : client // For timer cleanup\n                });\n            }\n            // Or right away if no transition is used\n            else {\n                finalizeAbort();\n            }\n        }\n\n        /**\n         * Fires on the owning TaskBoard when a drag operation is aborted (invalid drop or aborted using ESC)\n         *\n         * @event columnDragAbort\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n         * @param {TaskBoard.model.ColumnModel} columnRecord Dragged column\n         */\n        client.trigger('columnDragAbort', { drag, columnRecord });\n\n        if (drag.wasStarted) {\n            // Documented in dragDrop()\n            client.trigger('columnDragEnd', { drag, columnRecord });\n        }\n    }\n\n    dragEnd(drag) {\n        // Move back to original location when drag was aborted\n        if (!drag.valid || drag.aborted) {\n            this.doAbort(drag);\n        }\n    }\n}\n", "import TaskBoardFeature from './TaskBoardFeature.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport ContextMenuBase from '../../Core/feature/base/ContextMenuBase.js';\n\n/**\n * @module TaskBoard/feature/ColumnHeaderMenu\n */\n\n/**\n * Adds a menu button (`···`) to column headers, clicking it displays a menu. Items are populated by other features\n * and/or application code.\n *\n * {@inlineexample TaskBoard/feature/ColumnHeaderMenu.js}\n *\n * ## Default items\n *\n * These are the default items provided by TaskBoard features:\n *\n * | Reference         | Weight | Feature                              | Description                   |\n * |-------------------|--------|--------------------------------------|-------------------------------|\n * | `addTask `        | 100    | *This feature*                       | Add a new task to this column |\n * | `moveColumnLeft`  | 200    | {@link TaskBoard.feature.ColumnDrag} | Move column one step left     |\n * | `moveColumnRight` | 300    | {@link TaskBoard.feature.ColumnDrag} | Move column one step right    |\n *\n * Default items in the menu can be changed or removed and new items can be added. This is handled using the\n * {@link #config-items} config of the feature.\n *\n * ## Add items\n *\n * Add menu items for all column headers by adding a key (used as menu item {@link Core/widget/Widget#config-ref}) with\n * a {@link Core/widget/MenuItem#configs config object for a menu item} as the value to the {@link #config-items} config:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     features : {\n *         columnHeaderMenu : {\n *             items : {\n *                 flagTasks : {\n *                     text : 'Flag task',\n *                     icon : 'b-fa-fw b-fa-flag',\n *                     onItem({ columnRecord }) {\n *                         columnRecord.tasks.forEach(taskRecord => taskRecord.flagged = true);\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/feature/ColumnHeaderMenuAdd.js}\n *\n * ## Remove items\n *\n * To remove default items, configure them as `null` in the {@link #config-items} config:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     features : {\n *         columnHeaderMenu : {\n *             items : {\n *                 moveColumnLeft  : null,\n *                 moveColumnRight : null\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/feature/ColumnHeaderMenuRemove.js}\n *\n * ## Customize items\n *\n * To customize default items, supply a new config object for them in the {@link #config-items} config. It will merge\n * with the default config object:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     features : {\n *         columnHeaderMenu : {\n *             items : {\n *                 // Change the text of the \"Add new task\" item\n *                 addTask : {\n *                     text : 'New card'\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/feature/ColumnHeaderMenuCustomize.js}\n *\n * ## Manipulating items at runtime\n *\n * Manipulate items for all columns or specific columns at runtime by supplying a {@link #config-processItems} function:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     features : {\n *         columnHeaderMenu : {\n *             // Process items before menu is shown\n *             processItems({ columnRecord, items }) {\n *                  // Push an extra item for the done column\n *                  if (columnRecord.id === 'done') {\n *                      items.archive = {\n *                          text : 'Archive',\n *                          icon : 'b-fa-fw b-fa-archive',\n *                          onItem({ columnRecord }) {\n *                              columnRecord.tasks.forEach(taskRecord => taskRecord.archived = true);\n *                          }\n *                      };\n *                  }\n *\n *                  // Do not show \"Add new task\" for the todo column\n *                  if (columnRecord.id === 'todo') {\n *                      items.addTask = null;\n *                  }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/feature/ColumnHeaderMenuProcessItems.js}\n *\n * This feature is **enabled** by default.\n *\n * ## Keyboard shortcuts\n * This feature has the following default keyboard shortcuts:\n *\n * | Keys           | Action                 | Action description                                     |\n * |----------------|------------------------|--------------------------------------------------------|\n * | `Space`        | *showContextMenuByKey* | Shows context menu for currently focused column header |\n * | `Ctrl`+`Space` | *showContextMenuByKey* | Shows context menu for currently focused column header |\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#TaskBoard/guides/customization/keymap.md).\n *\n * @extends TaskBoard/feature/TaskBoardFeature\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype columnHeaderMenu\n * @feature\n */\nexport default class ColumnHeaderMenu extends ContextMenuBase {\n\n    static $name = 'ColumnHeaderMenu';\n\n    static type = 'columnHeaderMenu';\n\n    static configurable = {\n        /**\n         * A function called before displaying the menu that allows manipulations of its items.\n         * Returning `false` from this function prevents the menu from being shown.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *   features         : {\n         *       columnHeaderMenu : {\n         *           processItems({ columnRecord, items }) {\n         *              // Push an extra item for the todo column\n         *              if (columnRecord.id === 'todo') {\n         *                  items.finishAll = {\n         *                      text : 'Finish all',\n         *                      icon : 'b-fa-fw b-fa-check'\n         *                      onItem({ columnRecord }) {\n         *                          columnRecord.tasks.forEach(taskRecord => taskRecord.status = 'done');\n         *                      }\n         *                  };\n         *               }\n         *           }\n         *       }\n         *   }\n         * });\n         * ```\n         *\n         * @param {Object} context An object with information about the menu being shown\n         * @param {TaskBoard.model.ColumnModel} context.columnRecord The column for which the menu will be shown\n         * @param {Object<String,MenuItemConfig>} context.items An object containing the {@link Core.widget.MenuItem menu item} configs keyed\n         * by their id\n         * @param {Event} context.event The DOM event object that triggered the show\n         * @config {Function}\n         * @preventable\n         */\n        processItems : null,\n\n        /**\n         * This is a preconfigured set of items used to create the default context menu.\n         *\n         * The `items` provided by this feature are listed in the intro section of this class. You can configure\n         * existing items by passing a configuration object to the keyed items.\n         *\n         * To remove existing items, set corresponding keys `null`:\n         *\n         * ```javascript\n         * const scheduler = new Scheduler({\n         *     features : {\n         *         columnHeaderMenu : {\n         *             items : {\n         *                 addTask : null\n         *             }\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * See the class description for more examples.\n         *\n         * @config {Object<string,MenuItemConfig|Boolean|null>} items\n         */\n        items : null,\n\n        menu : {\n            anchor : true\n        },\n\n        type : 'columnHeader',\n\n        triggerEvent : false\n\n        /**\n         * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n         * @config {Object<String,String>>} keyMap\n         */\n\n        /**\n         * @hideconfigs type, triggerEvent\n         */\n    };\n\n    static get pluginConfig() {\n        const config = super.pluginConfig;\n\n        config.chain.push(...['populateColumnHeaderMenu', 'populateColumnHeader', 'onColumnHeaderClick']);\n\n        return config;\n    }\n\n    //region Events\n\n    /**\n     * This event fires on the owning TaskBoard before the menu is shown for a column header.\n     * Allows manipulation of the items to show in the same way as in the {@link #config-processItems}.\n     *\n     * Returning `false` from a listener prevents the menu from being shown.\n     *\n     * @event columnHeaderMenuBeforeShow\n     * @on-owner\n     * @preventable\n     * @param {TaskBoard.view.TaskBoard} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Object<string,MenuItemConfig>} items Menu item configs\n     * @param {TaskBoard.model.ColumnModel} columnRecord The column\n     * @on-owner\n     */\n\n    /**\n     * This event fires on the owning TaskBoard after the context menu is shown for a column header.\n     * @event cellMenuShow\n     * @on-owner\n     * @param {TaskBoard.view.TaskBoard} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Object<string,MenuItemConfig>} items Menu item configs\n     * @param {TaskBoard.model.ColumnModel} columnRecord The column\n     * @on-owner\n     */\n\n    /**\n     * This event fires on the owning TaskBoard when an item is selected in the column header menu.\n     * @event cellMenuItem\n     * @on-owner\n     * @param {TaskBoard.view.TaskBoard} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Core.widget.MenuItem} item Selected menu item\n     * @param {TaskBoard.model.ColumnModel} columnRecord The column\n     * @on-owner\n     */\n\n    /**\n     * This event fires on the owning TaskBoard when a check item is toggled in the column header menu.\n     * @event cellMenuToggleItem\n     * @on-owner\n     * @param {TaskBoard.view.TaskBoard} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Core.widget.MenuItem} item Selected menu item\n     * @param {TaskBoard.model.ColumnModel} columnRecord The column\n     * @param {Boolean} checked Checked or not\n     * @on-owner\n     */\n\n    //endregion\n\n    //region Type assertions\n\n    changeItems(items) {\n        ObjectHelper.assertObject(items, 'features.columnHeaderMenu.items');\n\n        return items;\n    }\n\n    changeProcessItems(fn) {\n        ObjectHelper.assertFunction(fn, 'features.columnHeaderMenu.processItems');\n\n        return fn;\n    }\n\n    //endregion\n\n    // Inject a \"button\" into column headers\n    populateColumnHeader({ columnHeaderConfig }) {\n        if (!this.disabled) {\n            columnHeaderConfig.children.padder.children.menu = {\n                tag   : 'button',\n                class : {\n                    'b-column-header-button'                : 1,\n                    'b-taskboard-column-header-menu-button' : 1,\n                    'b-fw-icon'                             : 1,\n                    'b-icon-menu-horizontal'                : 1\n                }\n            };\n        }\n    }\n\n    // Populate menu events with taskboard specifics\n    getDataFromEvent(event) {\n        return ObjectHelper.assign(super.getDataFromEvent(event), event.taskBoardData);\n    }\n\n    // Add default menu items\n    populateColumnHeaderMenu({ items, columnRecord }) {\n        const { client } = this;\n\n        if (!client.readOnly) {\n            items.addTask = {\n                text   : 'L{TaskBoard.addTask}',\n                icon   : 'b-fw-icon b-icon-add',\n                weight : 100,\n                onItem() {\n                    client.addTask(columnRecord);\n                }\n            };\n        }\n    }\n\n    // Detect \"button\" click\n    onColumnHeaderClick(args) {\n        const { event } = args;\n\n        if (event.target.matches('.b-column-header-button')) {\n            this.showContextMenu(event, { target : event.target, align : 't90-b90' });\n        }\n    }\n\n    doDisable(disable) {\n        super.doDisable(disable);\n\n        !this.isConfiguring && this.client.recompose();\n    }\n\n    get showMenu() {\n        return true;\n    }\n}\n\n// Register this feature type with its Factory\nTaskBoardFeature.register(ColumnHeaderMenu.type, ColumnHeaderMenu);\n", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport '../../Core/widget/Toolbar.js';\nimport '../../Core/widget/Menu.js';\nimport TaskBoardFeature from './TaskBoardFeature.js';\n\n/**\n * @module TaskBoard/feature/ColumnToolbars\n */\n\n/**\n * Adds toolbars to the top and/or bottom of each column. By default it adds a bottom toolbar containing a single button\n * for adding events to that column/swimlane:\n *\n * {@inlineexample TaskBoard/feature/ColumnToolbars.js}\n *\n * To add, remove or modify toolbar items for all columns, see {@link #config-topItems} and {@link #config-bottomItems}:\n *\n * {@inlineexample TaskBoard/feature/ColumnToolbarsAdd.js}\n *\n * To have per column/swimlane control over the items, see {@link #config-processItems}:\n *\n * {@inlineexample TaskBoard/feature/ColumnToolbarsProcess.js}\n *\n * In handlers for buttons etc, you can access which column/swimlane the action was taken in on the supplied `source`\n * param, using its `columnRecord` and `swimlaneRecord` properties:\n *\n * ```javascript\n * new TaskBoard({\n *    features : {\n *        columnToolbars : {\n *            topItems : {\n *                clearButton : {\n *                    icon    : 'b-fa-trash',\n *                    onClick({ source }) {\n *                        if (source.columnRecord) {\n *                            ...\n *                        }\n *                    }\n *                }\n *            }\n *        }\n *    }\n * });\n * ```\n *\n * This feature is **enabled** by default.\n *\n * @extends TaskBoard/feature/TaskBoardFeature\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype columnToolbars\n * @feature\n */\nexport default class ColumnToolbars extends TaskBoardFeature {\n\n    static $name = 'ColumnToolbars';\n\n    static type = 'columnToolbars';\n\n    static configurable = {\n        /**\n         * Items to add to the top toolbar, in object format.\n         *\n         *\n         * ```javascript\n         * new TaskBoard({\n         *    features : {\n         *        columnToolbars : {\n         *            topItems : {\n         *                clearButton : {\n         *                    icon    : 'b-fa-trash',\n         *                    onClick : ...\n         *                }\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @config {Object<String,ContainerItemConfig|Boolean|null>}\n         */\n        topItems : null,\n\n        /**\n         * Items to add to the bottom toolbar, in object format.\n         *\n         * To remove existing items, set corresponding keys to `null`.\n         *\n         * ```javascript\n         * new TaskBoard({\n         *    features : {\n         *        columnToolbars : {\n         *            bottomItems : {\n         *                clearButton : {\n         *                    icon    : 'b-fa-trash',\n         *                    onClick : ...\n         *                }\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @config {Object<String,ContainerItemConfig|Boolean|null>}\n         */\n        bottomItems : {\n            addTask : true\n        },\n\n        // Predefined items that can be used in topItems and/or bottomItems\n        // <remove-on-release>\n        // TODO: Document and make public?\n        // </remove-on-release>\n        namedItems : {\n            addTask : {\n                type              : 'button',\n                icon              : 'b-icon-add',\n                tooltip           : 'L{TaskBoard.addTask}',\n                ariaLabel         : 'L{TaskBoard.addTask}',\n                internalListeners : {\n                    click : 'onAddClick'\n                }\n            }\n        },\n\n        /**\n         * A function called before displaying the toolbar that allows manipulations of its items.\n         * Returning `false` from this function prevents the menu being shown.\n         *\n         * ```javascript\n         * features         : {\n         *    columnToolbars : {\n         *         processItems({ items, location, columnRecord, swimlaneRecord }) {\n         *             // Add or hide existing items here as needed\n         *             items.myAction = {\n         *                 text   : 'Cool action',\n         *                 icon   : 'b-fa-ban',\n         *                 onClick : () => console.log(`Clicked button for ${columnRecord.text}`)\n         *             };\n         *\n         *            if (columnRecord.id === 'done') {\n         *                items.addTask = false\n         *            }\n         *         }\n         *     }\n         * },\n         * ```\n         *\n         * @param {Object} context An object with information about the toolbar being shown\n         * @param {Object<String,ContainerItemConfig>} context.items An object containing the toolbar item configs keyed\n         * by ref\n         * @param {'top'|'bottom'} context.location Toolbar location, \"top\" or \"bottom\"\n         * @param {TaskBoard.model.ColumnModel} context.columnRecord Record representing toolbars column\n         * @param {TaskBoard.model.SwimlaneModel} context.swimlaneRecord Record representing toolbars swimlane\n         * @config {Function}\n         * @preventable\n         */\n        processItems : null\n    };\n\n    // Holds exising toolbars, keyed by location, column and swimlane\n    columnMap = new Map();\n\n    static pluginConfig = {\n        chain : ['populateColumn', 'onRemoveColumnElement', 'onRemoveSwimlaneElement']\n    };\n\n    doDestroy() {\n        for (const [, toolbar] of this.columnMap) {\n            toolbar.destroy();\n        }\n\n        super.doDestroy();\n    }\n\n    //region Type assertions\n\n    changeTopItems(items) {\n        ObjectHelper.assertObject(items, 'features.columnToolbars.topItems');\n\n        return items;\n    }\n\n    changeBottomItems(items) {\n        ObjectHelper.assertObject(items, 'features.columnToolbars.bottomItems');\n\n        return items;\n    }\n\n    changeProcessItems(fn) {\n        ObjectHelper.assertFunction(fn, 'features.columnToolbars.processItems');\n\n        return fn;\n    }\n\n    //endregion\n\n    //region Toolbars\n\n    // removeToolbar(location) {\n    //     const columnMap = this.columnMap;\n    //\n    //     for (const [key, toolbar] of columnMap) {\n    //         if (key.startsWith(location)) {\n    //             toolbar.destroy();\n    //             columnMap.delete(toolbar);\n    //         }\n    //     }\n    // }\n    //\n    // changeTopItems(items, old) {\n    //     if (old && !items) {\n    //         this.removeToolbar('top');\n    //     }\n    //\n    //     return items;\n    // }\n    //\n    // changeBottomItems(items, old) {\n    //     if (old && !items) {\n    //         this.removeToolbar('items');\n    //     }\n    //\n    //     return items;\n    // }\n\n    // Creates or retrieves a toolbar instance for the requested column/swimlane intersection\n    getToolbar(location, columnRecord, swimlaneRecord) {\n        const\n            me                                = this,\n            { columnMap, client, namedItems } = me,\n            items                             = me[`${location}Items`],\n            key                               = `${location}_._${columnRecord.domId}_._${swimlaneRecord?.domId ?? 'default'}`;\n\n        let toolbar = columnMap.get(key);\n\n        if (!toolbar) {\n            const clonedItems = {};\n\n            // items allows configuring out using falsy value, only iterate the truthy ones\n            ObjectHelper.getTruthyKeys(items).map(ref => {\n                const\n                    // Could match a named item, to either be used as is or use reconfigured\n                    namedItem = namedItems[ref],\n                    // Item config or a truthy value to include a named item as is\n                    item      = items[ref];\n\n                clonedItems[ref] = ObjectHelper.merge(\n                    // Default listeners + decorate with records\n                    {\n                        internalListeners : {\n                            click   : 'onClick',\n                            change  : 'onChange',\n                            thisObj : me\n                        },\n\n                        columnRecord,\n                        swimlaneRecord\n                    },\n                    // Merge with any matched named item\n                    namedItem,\n                    // And any supplied config\n                    item\n                );\n            });\n\n            // Allow client code to alter items before adding them to the toolbar\n            if (me.processItems?.({ items : clonedItems, location, columnRecord, swimlaneRecord }) === false) {\n                return null;\n            }\n\n            // Create toolbar using the processed items\n            toolbar = client.add({\n                type                      : 'toolbar',\n                cls                       : `b-taskboard-column-${location[0]}bar`,\n                overflow                  : null,\n                monitorResize             : false,\n                contentElMutationObserver : false,\n                items                     : clonedItems,\n                dataset                   : {\n                    role          : `${location}-toolbar`,\n                    domTransition : true\n                }\n            });\n\n            columnMap.set(key, toolbar);\n        }\n\n        return toolbar.element;\n    }\n\n    populateColumn({ columnConfig, columnRecord, swimlaneRecord }) {\n        const me = this;\n\n        if (!me.disabled) {\n            // Add top toolbar, if it has items\n            if (ObjectHelper.getTruthyKeys(me.topItems).length) {\n                DomHelper.merge(columnConfig, {\n                    children : {\n                        'tbar > body' : me.getToolbar('top', columnRecord, swimlaneRecord)\n                    }\n                });\n            }\n\n            // Add bottom toolbar, if it has items\n            if (ObjectHelper.getTruthyKeys(me.bottomItems).length) {\n                columnConfig.children.bbar = me.getToolbar('bottom', columnRecord, swimlaneRecord);\n            }\n        }\n    }\n\n    removeColumnToolbar(location, columnId, swimlaneId) {\n        const\n            { columnMap, client } = this,\n            key                   = `${location}_._${columnId}_._${swimlaneId}`,\n            toolbar               = columnMap.get(key);\n\n        if (toolbar) {\n            client.remove(toolbar);\n\n            // Toolbar gets removed during a compose, which leads to a race condition with syncOverflowVisibility.\n            // Postpone destroy til after compose to avoid this\n            client.setTimeout(() => toolbar.destroy(), 0);\n\n            columnMap.delete(key);\n        }\n    }\n\n    removeColumnToolbars(columnId, swimlaneId) {\n        this.removeColumnToolbar('top', columnId, swimlaneId);\n        this.removeColumnToolbar('bottom', columnId, swimlaneId);\n    }\n\n    onRemoveColumnElement({ columnId, swimlaneRecord }) {\n        this.removeColumnToolbars(columnId, swimlaneRecord.id ?? 'default');\n    }\n\n    onRemoveSwimlaneElement({ swimlaneId }) {\n        for (const column of this.client.columns) {\n            this.removeColumnToolbars(column.id, swimlaneId);\n        }\n    }\n\n    //endregion\n\n    //region Predefined items events\n\n    onAddClick({ source }) {\n        this.client.addTask(source.columnRecord, source.swimlaneRecord);\n    }\n\n    //endregion\n\n    //region Generic events\n\n    onChange({ source }) {\n        this.trigger('itemChange', {\n            item           : source,\n            columnRecord   : source.columnRecord,\n            swimlaneRecord : source.swimlaneRecord\n        });\n    }\n\n    onClick({ source }) {\n        this.trigger('itemClick', {\n            item           : source,\n            columnRecord   : source.columnRecord,\n            swimlaneRecord : source.swimlaneRecord\n        });\n    }\n\n    //endregion\n}\n\nColumnToolbars.initClass();\n", "import Base from '../../../Core/Base.js';\nimport Factoryable from '../../../Core/mixin/Factoryable.js';\n\n/**\n * @module TaskBoard/view/item/TaskItem\n */\n\n/**\n * Config options for all TaskItems combined. See respective item classes for more information.\n * @typedef {Object} TaskItemOptions\n * @property {String} type Type of the item\n * @property {String} [field] Field to display in the item. Usually inferred from the key when supplying items\n * @property {String|Object} [style] Style definition in string or object form\n * @property {String} [cls] CSS class to add\n * @property {Number} [order] Flex order, can be used to re-order task items\n * @property {Boolean} [hidden] Specify `true` to hide the task item\n * @property {String|Object} [editor] Widget type or config to use as the editor for this item. Used in the inline task\n * editor. Set to `null` to not use an editor for this item\n * @property {String} [baseUrl] For `type : 'image'` - Url prepended to this items value\n * @property {Function} [template] For `type : 'template'` - Template function used to generate task content\n * @property {Number} [max] For `type : 'progress'` and `type : 'rating'` - Max value\n * @property {String} [textField] For `type : 'todoList'` - Name of a property on a todo item to display as its text\n * @property {String} [checkedField] For `type : 'todoList'` - Name of a property on a todo item to use for the checkbox\n * @property {String} [clsField] For `type : 'todoList'` - Name of a property on a todo item whose value will be added\n * as a CSS class to the todo item\n * @property {Number} [maxAvatars] For `type : 'resourceAvatars'` - Maximum avatars to display by default.\n * @property {Boolean} [overlap] For `type : 'resourceAvatars'` - Specify `true` to slightly overlap avatars for tasks\n * @property {String} [textProperty] For `type : 'tags'` - Property used to display the tag text\n * @property {String} [clsProperty] For `type : 'tags'` - Property used to add a CSS class to each tag\n * @property {String} [separator] For `type : 'tags'` - Property used to split a value string into tags\n */\n\n/**\n * Abstract base class for task items, lightweight \"widgets\" that can be added to tasks using the\n * {@link TaskBoard/view/TaskBoard#config-headerItems}, {@link TaskBoard/view/TaskBoard#config-bodyItems} and\n * {@link TaskBoard/view/TaskBoard#config-footerItems} configs.\n *\n * @abstract\n */\nexport default class TaskItem extends Base.mixin(Factoryable) {\n    static factoryable = {};\n\n    static configurable = {\n        /**\n         * Task field whose value item will act on (usually display it). Defaults to use the key in the items object.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    features : {\n         *        taskItems : {\n         *            items : {\n         *                // Will use \"prio\" as its field\n         *                prio  : { type : 'textitem' },\n         *                // Will use \"status\" as its field\n         *                state : { type : 'textitem', field : 'status' }\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @config {String} field\n         * @category Common\n         */\n\n        /**\n         * Style definition in string or object form.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    features : {\n         *        taskItems : {\n         *            items : {\n         *                prio  : { type : 'textitem', style : { color : 'red' } }\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @config {String|Object} style\n         * @category Common\n         */\n\n        /**\n         * Specify `true` to hide the task item.\n         *\n         * @config {Boolean} hidden\n         * @category Common\n         */\n\n        /**\n         * Flex order, can be used to re-order task items.\n         *\n         * @config {Number} order\n         * @default 1\n         * @category Common\n         */\n\n        /**\n         * CSS class to add.\n         *\n         * @config {String} cls\n         * @category Common\n         */\n\n        /**\n         * Widget type or config to use as the editor for this item. Used in the inline task editor.\n         * Set to `null` to not use an editor for this item.\n         *\n         * @config {String|Object} editor\n         * @default text\n         * @category Common\n         */\n    };\n\n    static defaultEditor = { type : 'text' };\n\n    static getEditorConfig({ config, item }) {\n        const editor = config.editor !== null && (config.editor || item.defaultEditor);\n\n        if (typeof editor === 'string') {\n            return {\n                type : editor\n            };\n        }\n\n        return editor;\n    }\n}\n", "import TaskBoardFeature from './TaskBoardFeature.js';\nimport TaskItem from '../view/item/TaskItem.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport Editor from '../../Core/widget/Editor.js';\n\n/**\n * @module TaskBoard/feature/SimpleTaskEdit\n */\n\n/**\n * This feature allows inline editing of tasks. Double clicking an item starts editing it:\n *\n * {@inlineexample TaskBoard/feature/SimpleTaskEdit.js}\n *\n * Each {@link TaskBoard.view.item.TaskItem task item} can define an\n * {@link TaskBoard.view.item.TaskItem#config-editor}. To prevent an item from being edited inline, configure it with\n * `editor : null`:\n *\n * {@inlineexample TaskBoard/feature/SimpleTaskEditCustom.js}\n *\n * This feature is **disabled** by default.\n *\n * {@region Keyboard shortcuts}\n * The feature has the following default keyboard shortcuts:\n *\n * | Keys            | Action         | Action description                                                                   |\n * |-----------------|----------------|--------------------------------------------------------------------------------------|\n * | `Enter`         | *editNext*     | In an editor this will accept the change and start editing the next item on that card or the first item on the next card. By default it adds a new task when pressed on the last item of the last card in a column. This behaviour is configurable using the {@link #config-addNewAtEnd} config. |\n * | `Escape`        | *cancel*       | Cancels editing and reverts changes for that item which is currently being edited    |\n * | `Shift`+`Enter` | *editPrevious* | In an editor this will accept the change and start editing the previous item on that card or the last item on the previous card |\n * | `Ctrl`+`Enter`  | *complete*     | Accepts the edit and closes the editor                                               |\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#TaskBoard/guides/customization/keymap.md).\n * {@endregion}\n *\n * @extends TaskBoard/feature/TaskBoardFeature\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype simpleTaskEdit\n * @feature\n */\nexport default class SimpleTaskEdit extends TaskBoardFeature {\n\n    static $name = 'SimpleTaskEdit';\n\n    static type = 'simpleTaskEdit';\n\n    static configurable = {\n        /**\n         * Pressing `Enter` in last item on last task in a column adds a new task.\n         * @config {Boolean}\n         * @default\n         */\n        addNewAtEnd : true,\n\n        /**\n         * A configuration object for the {@link Core.widget.Editor} used by this feature. Useful when you want to\n         * validate the value being set by the end user (see {@link Core.widget.Editor#event-beforeComplete}).\n         *\n         * @config {EditorConfig}\n         */\n        editorConfig : {},\n\n        /**\n         * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n         * @config {Object<String,String>}\n         */\n        keyMap : {\n            Enter         : 'editNext',\n            Escape        : 'cancel',\n            'Ctrl+Enter'  : 'complete',\n            'Shift+Enter' : 'editPrevious'\n        }\n    };\n\n    static pluginConfig = {\n        assign : ['editTask'],\n        before : ['onActivateTask']\n    };\n\n    //region Type assertions\n\n    changeAddNewAtEnd(addNewAtEnd) {\n        ObjectHelper.assertBoolean(addNewAtEnd, 'features.simpleTaskEdit.addNewAtEnd');\n\n        return addNewAtEnd;\n    }\n\n    //endregion\n\n    /**\n     * Starts inline editing of the supplied task, optionally for a specific item on its card.\n     * @on-owner\n     * @param {TaskBoard.model.TaskModel} taskRecord Task record to edit\n     * @param {HTMLElement} [element] Card element or card item element to edit. Resolves element from the passed record\n     * if left out.\n     * @returns {Boolean} Returns `true` if editing started, `false` if it did not.\n     */\n    editTask(taskRecord, element) {\n        const\n            me        = this,\n            taskBoard = me.client;\n\n        // Get element from record if none supplied\n        if (!element) {\n            element = taskBoard.getTaskElement(taskRecord);\n        }\n\n        const\n            // Get a task item from the element, will yield first task item when given the card element\n            taskItem         = taskBoard.resolveTaskItem(element),\n            itemElement      = taskItem.element,\n            itemEditorConfig = TaskItem.getEditorConfig(taskItem);\n\n        // Allow disabling editing for an item using `editor : null`\n        if (!itemEditorConfig) {\n            return false;\n        }\n\n        /**\n         * Fires on the owning TaskBoard before displaying an inline editor. Returning `false` stops the editor from\n         * being shown.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    listeners : {\n         *        beforeSimpleTaskEdit({ taskRecord }) {\n         *            // Some condition for which editing should be blocked...\n         *            if (taskRecord.disallowed) {\n         *                return false;\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @event beforeSimpleTaskEdit\n         * @preventable\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source The task board\n         * @param {TaskBoard.feature.SimpleTaskEdit} simpleTaskEdit The simpleTaskEdit feature\n         * @param {TaskBoard.model.TaskModel} taskRecord The record about to be shown in the editor\n         * @param {String} field Field name being edited\n         */\n        // Give clients a shot at preventing editing\n        if (\n            me.disabled || taskRecord.readOnly ||\n            taskBoard.trigger('beforeSimpleTaskEdit', { simpleTaskEdit : me, taskRecord, field : taskItem.config.field }) === false\n        ) {\n            return true;\n        }\n\n        // Focus the card to ensure focus reverts to it when editor closes\n        element.focus();\n\n        const editor = me.editor = Editor.new({\n            owner        : taskBoard,\n            appendTo     : itemElement.parentNode,\n            scrollAction : 'realign',\n            cls          : 'b-simple-task-editor',\n            completeKey  : null,\n            cancelKey    : null,\n            inputField   : {\n                autoSelect : true,\n                name       : taskItem.config.field,\n                ...itemEditorConfig\n            },\n            align : {\n                align          : 'c-c',\n                allowTargetOut : false\n            },\n            internalListeners : {\n                complete   : 'onEditorComplete',\n                cancel     : 'onEditorCancel',\n                finishEdit : 'onEditorFinishEdit',\n                thisObj    : me\n            }\n        }, me.editorConfig);\n\n        // Store active element, to be able to navigate to next/prev later if requested\n        me.currentElement = itemElement;\n\n        // Add editing cls, will be cleared by recompose\n        itemElement.classList.add('b-editing');\n\n        // Match editor color to item color\n        const color = DomHelper.getStyleValue(itemElement, 'color');\n        editor.element.style.color = color;\n        editor.inputField.element.style.color = color;\n\n        // Don't want a recompose removing editor element\n        editor.element.retainElement = true;\n\n        // Scrolling card into view\n        taskBoard.getTaskElement(taskRecord).scrollIntoView({\n            block : 'nearest'\n        });\n\n        // And then item being edited. Two steps since first one won't do anything if card is already in view while item\n        // is not\n        itemElement.scrollIntoView({\n            block : 'nearest'\n        });\n\n        editor.startEdit({\n            target : taskItem.element,\n            record : taskRecord,\n            field  : taskItem.config.field\n        });\n\n        return true;\n    }\n\n    // Edit previous task item\n    async editPrevious(event) {\n        const\n            me                 = this,\n            { client, editor } = me,\n            taskRecord         = editor.record,\n            cardElement        = client.getTaskElement(taskRecord),\n            itemElements       = Array.from(cardElement.querySelectorAll('.b-taskboard-taskitem.b-editable')),\n            index              = itemElements.indexOf(me.currentElement) - 1;\n\n        if (await me.complete(event)) {\n            // More items on the card, edit prev item\n            if (index >= 0) {\n                me.editTask(taskRecord, itemElements[index]);\n            }\n            // No more items\n            else {\n                const prevTaskRecord = client.getPreviousTask(taskRecord, false);\n                // Edit last item of prev card\n                if (prevTaskRecord) {\n                    const\n                        prevCardElement  = client.getTaskElement(prevTaskRecord),\n                        prevItemElements = Array.from(prevCardElement.querySelectorAll('.b-taskboard-taskitem.b-editable'));\n\n                    me.editTask(prevTaskRecord, prevItemElements[prevItemElements.length - 1]);\n                }\n            }\n        }\n    }\n\n    // Edit next task item\n    async editNext(event) {\n        const\n            me                 = this,\n            { client, editor } = me,\n            taskRecord         = editor.record,\n            cardElement        = client.getTaskElement(taskRecord),\n            itemElements       = Array.from(cardElement.querySelectorAll('.b-taskboard-taskitem.b-editable')),\n            index              = itemElements.indexOf(me.currentElement) + 1;\n\n        if (await me.complete(event)) {\n            // More items on the card, edit next item\n            if (index < itemElements.length) {\n                me.editTask(taskRecord, itemElements[index]);\n            }\n            // No more items\n            else {\n                const nextTaskRecord = client.getNextTask(taskRecord, false);\n                // Edit next card\n                if (nextTaskRecord) {\n                    me.editTask(nextTaskRecord);\n                }\n                // Or add a new card\n                else if (me.addNewAtEnd) {\n                    client.addTask(client.getColumn(taskRecord), client.getSwimlane(taskRecord));\n                }\n            }\n        }\n    }\n\n    complete(event) {\n        return this.editor.completeEdit(null, event);\n    }\n\n    cancel(event) {\n        this.editor.cancelEdit(event);\n    }\n\n    // Start editing when activating task (enter/dblclick)\n    onActivateTask({ taskRecord, event }) {\n        if (this.editTask(taskRecord, event.target)) {\n            // Block other actions (TaskEdit)\n            event.preventDefault();\n        }\n    }\n\n    onEditorComplete({ source }) {\n        /**\n         * Fires on the owning TaskBoard when inline editing of a field has successfully finished.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    listeners : {\n         *        simpleTaskEditComplete({ taskRecord, field }) {\n         *            Toast.show(`Finished editing ${field} of ${taskRecord.name}`);\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @event simpleTaskEditComplete\n         * @preventable\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source The task board\n         * @param {TaskBoard.feature.SimpleTaskEdit} simpleTaskEdit The simpleTaskEdit feature\n         * @param {TaskBoard.model.TaskModel} taskRecord Record that was edited\n         * @param {String} field Field name being edited\n         */\n        this.client.trigger('simpleTaskEditComplete', { simpleTaskEdit : this, taskRecord : source.record, field : source.dataField  });\n    }\n\n    onEditorCancel({ source }) {\n        /**\n         * Fires on the owning TaskBoard when inline editing of a field is cancelled (by pressing ESC).\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    listeners : {\n         *        simpleTaskEditCancel({ taskRecord }) {\n         *            Toast.show(`Aborted editing of ${taskRecord.name}`);\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @event simpleTaskEditCancel\n         * @preventable\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source The task board\n         * @param {TaskBoard.feature.SimpleTaskEdit} simpleTaskEdit The simpleTaskEdit feature\n         * @param {TaskBoard.model.TaskModel} taskRecord Record that was edited\n         * @param {String} field Field name being edited\n         */\n        this.client.trigger('simpleTaskEditCancel', { simpleTaskEdit : this, taskRecord : source.record, field : source.dataField  });\n    }\n\n    onEditorFinishEdit() {\n        // Have to store editor before the timeout, might get replaced by new\n        const\n            me = this,\n            { editor } = me;\n\n        editor?.setTimeout(() => {\n            // Don't retain the element if we did not start editing something else\n            if (me.editor === editor) {\n                me.currentElement = null;\n                me.editor = null;\n            }\n\n            editor.destroy();\n        }, 0);\n    }\n\n    // All keyMap actions require that we are editing\n    isActionAvailable() {\n        return Boolean(this.editor);\n    }\n}\n\nSimpleTaskEdit.initClass();\n", "import TaskBoardFeature from './TaskBoardFeature.js';\nimport Base from '../../Core/Base.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport Draggable from '../../Core/mixin/Draggable.js';\nimport Droppable from '../../Core/mixin/Droppable.js';\n\n/**\n * @module TaskBoard/feature/SwimlaneDrag\n */\n\n/**\n * This feature allows users to drag drop swimlanes on the TaskBoard changing their order (by grabbing their header).\n *\n * {@inlineexample TaskBoard/feature/SwimlaneDrag.js}\n *\n * This feature is **disabled** by default.\n *\n * @extends TaskBoard/feature/TaskBoardFeature\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype swimlaneDrag\n * @feature\n */\nexport default class SwimlaneDrag extends TaskBoardFeature {\n    static $name = 'SwimlaneDrag';\n\n    static type = 'swimlaneDrag';\n\n    static pluginConfig = {\n        after : ['initialCompose']\n    };\n\n    initialCompose() {\n        const me     = this;\n        // Cannot use configurable since bodyElement is not available yet when feature is pulled in\n        me.draggable = SwimlaneZone.new({\n            dragRootElement : me.disabled ? null : me.client.bodyWrapElement,\n            dropRootElement : me.client.bodyWrapElement,\n            owner           : me\n        }, me.draggable);\n    }\n\n    doDisable(disable) {\n        super.doDisable(disable);\n\n        if (this.draggable) {\n            this.draggable.dragRootElement = disable ? null : this.client.bodyWrapElement;\n        }\n    }\n}\n\nSwimlaneDrag.initClass();\n\nclass SwimlaneZone extends Base.mixin(Draggable, Droppable) {\n    static get configurable() {\n        return {\n            dragSelector     : '.b-taskboard-swimlane-header, .b-taskboard-swimlane-header *',\n            dragItemSelector : '.b-taskboard-swimlane-header',\n\n            draggingItemCls : null,\n\n            dragProxy : {\n                type : 'default',\n\n                async open(drag) {\n                    const\n                        { owner }       = this,\n                        {\n                            itemElement,\n                            startEvent\n                        }               = drag,\n                        taskBoard       = owner.owner.client,\n                        swimlaneRecord  = taskBoard.resolveSwimlaneRecord(itemElement),\n                        swimlaneElement = taskBoard.getSwimlaneElement(swimlaneRecord),\n                        padding         = DomHelper.getStyleValue(\n                            swimlaneElement.syncIdMap.body,\n                            ['padding-left', 'padding-right']\n                        ),\n                        bounds          = Rectangle.from(swimlaneElement, owner.dragRootElement).deflate(\n                            0,\n                            parseFloat(padding['padding-right']),\n                            0,\n                            parseFloat(padding['padding-left'])\n                        ),\n                        // Offset from cursor\n                        proxyOffset     = EventHelper.getClientPoint(startEvent).getDelta(bounds),\n                        // Drag proxy, positioned over column being dragged\n                        proxy           = DomHelper.createElement({\n                            className : 'b-taskboard-swimlane-drag-proxy',\n                            parent    : owner.dragRootElement,\n                            style     : {\n                                // Using fixed top, only draggable horizontally\n                                top   : EventHelper.getClientPoint(startEvent).translate(0, proxyOffset[1]).y,\n                                // Offset from cursor to be positioned over original column\n                                left  : bounds.x,\n                                // Need a fixed height on the proxy, since columns width might be flexed etc\n                                width : bounds.width\n                            },\n                            // Don't want it being removed while dragging\n                            retainElement : true\n                        });\n\n                    // Things we want to access later on drag\n                    Object.assign(drag, {\n                        proxy,\n                        swimlaneRecord,\n                        swimlaneElement,\n                        proxyOffset,\n                        // Used to size dropIndicator\n                        bounds\n                    });\n\n                    // Clone all dragged column elements and put them in the proxy\n                    const swimlaneClone = swimlaneElement.cloneNode(true);\n\n                    proxy.appendChild(swimlaneClone);\n                },\n\n                dragMove({ proxy, event, proxyOffset }) {\n                    // Move along y-axis only\n                    const position = EventHelper.getClientPoint(event).translate(0, proxyOffset[1]);\n\n                    proxy.style.top = `${position.y}px`;\n                }\n            }\n        };\n    }\n\n    setupDragContext(event) {\n        const\n            result = super.setupDragContext(event),\n            { client } = this.owner;\n\n        result.scrollManager = client.scrollManager;\n        result.monitoringConfig = {\n            scrollables : [{\n                element   : client.bodyElement,\n                direction : 'vertical'\n            }]\n        };\n\n        return result;\n    }\n\n    dragStart(drag) {\n        // Trigger something...\n    }\n\n    dragEnter(drag) {\n        // Only accept swimlanes\n        if (!drag.itemElement.matches(this.dragItemSelector)) {\n            return false;\n        }\n\n        // Create drop indicators on first enter\n        if (!drag.dropIndicator) {\n            const { bounds } = drag;\n\n            // Need one indicator for each part of the column\n            drag.dropIndicator = DomHelper.createElement({\n                className   : 'b-taskboard-swimlane-drop-indicator',\n                elementData : {\n                    dropIndicator : true\n                },\n                // Use same size as dragged column had originally\n                style : {\n                    width  : bounds.width,\n                    height : bounds.height\n                }\n            });\n\n            this.insertDropIndicator(drag.dropIndicator, drag.swimlaneRecord);\n\n            drag.swimlaneElement.classList.add('b-drag-original');\n        }\n    }\n\n    insertDropIndicator(dropIndicator, beforeSwimlaneRecord) {\n        const { client } = this.owner;\n\n        client.bodyElement.insertBefore(\n            dropIndicator,\n            beforeSwimlaneRecord && client.getSwimlaneElement(beforeSwimlaneRecord)\n        );\n    }\n\n    async dragMove(drag) {\n        const\n            { client }       = this.owner,\n            { documentRoot } = client,\n            taskBoardBounds  = Rectangle.from(client.element, undefined, true),\n            proxyBounds      = Rectangle.from(drag.proxy, undefined, true),\n            // Check element under proxy left center, should get a swimlane (or a gap)\n            overElement      = proxyBounds.center.y > taskBoardBounds.bottom\n                ? documentRoot.elementFromPoint(proxyBounds.x, proxyBounds.y)\n                : documentRoot.elementFromPoint(proxyBounds.x, proxyBounds.center.y),\n            swimlaneElement  = overElement?.closest('.b-taskboard-swimlane');\n\n        // If we are over the drop indicator or something not a column header, we do nothing\n        if (!overElement?.elementData?.dropIndicator && swimlaneElement) {\n            const targetBounds = Rectangle.from(swimlaneElement, undefined, true);\n\n            // Column that we are going to insert the dragged column before or after\n            let beforeSwimlane = client.resolveSwimlaneRecord(swimlaneElement);\n\n            // If beyond center, insert before next column\n            if (proxyBounds.center.y > targetBounds.center.y) {\n                beforeSwimlane = client.swimlanes.getNext(beforeSwimlane);\n            }\n\n            this.insertDropIndicator(drag.dropIndicator, beforeSwimlane);\n\n            drag.beforeSwimlane = beforeSwimlane;\n        }\n    }\n\n    async dragDrop(drag) {\n        // Data part\n        const\n            { client }    = this.owner,\n            { swimlanes } = client,\n            {\n                swimlaneRecord,\n                beforeSwimlane,\n                swimlaneElement,\n                dropIndicator,\n                proxy\n            }             = drag;\n\n        function commit() {\n            // Remove proxy & dropIndicator\n            proxy.remove();\n            dropIndicator.remove();\n\n            // Restore original element\n            swimlaneElement.classList.remove('b-drag-original');\n\n            // Update data\n            beforeSwimlane !== undefined && swimlanes.move(swimlaneRecord, beforeSwimlane);\n\n            client.trigger('dropSwimlane', { beforeSwimlane, drag });\n        }\n\n        // UI part\n\n        // We are dropping, this cls by default has a transition\n        proxy.classList.add('b-dropping');\n\n        // Move proxy to drop location, allowing it to transition there\n        DomHelper.alignTo(\n            proxy,\n            Rectangle.from(dropIndicator, undefined, true)\n        );\n\n        // Update record after the transition, to prevent too early redraw (which would ruin the transition)\n        if (DomHelper.getPropertyTransitionDuration(proxy, 'transform')) {\n            EventHelper.onTransitionEnd({\n                element  : proxy,\n                property : 'transform',\n                handler  : commit,\n                thisObj  : client\n            });\n        }\n        // Or right away if no transition is used\n        else {\n            commit();\n        }\n    }\n\n    dragLeave(drag) {\n        // Doing nothing feels ok for now\n    }\n}\n", "import TaskBoardFeature from './TaskBoardFeature.js';\nimport Base from '../../Core/Base.js';\nimport AsyncHelper from '../../Core/helper/AsyncHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport Draggable from '../../Core/mixin/Draggable.js';\nimport Droppable from '../../Core/mixin/Droppable.js';\nimport Events from '../../Core/mixin/Events.js';\n\n/**\n * @module TaskBoard/feature/TaskDrag\n */\n\nconst\n    cardSelector = '.b-taskboard-card, .b-taskboard-card-drop-indicator',\n    // Index of the specified card/drop indicator (other drop indicators excluded)\n    indexOf      = (element, ignoreOriginal = false) => DomHelper\n        .children(element.parentElement, `.b-taskboard-card${ignoreOriginal ? ':not(.b-drag-original)' : ''}, .b-first-drop-indicator`)\n        .indexOf(element),\n    // Check if any drop indicator has moved in a way that will lead to task changes\n    hasChanged   = dropIndicators => dropIndicators.some((dropIndicator, i) => {\n        return (\n            // Moved to another parent is a change (another column or another swimlane)\n            dropIndicator.parentElement !== dropIndicator.elementData.initialParent ||\n            // Or if first drop indicator has changed index (the others follow it, no need to check)\n            (i === 0 && indexOf(dropIndicator, true) !== dropIndicator.elementData.initialIndex)\n        );\n    });\n\n/**\n * This feature allows cards on the TaskBoard to be dragged across swimlanes and columns but also vertically in the\n * same column to change the order:\n *\n * {@inlineexample TaskBoard/feature/TaskDrag.js}\n *\n * When a task is dropped, its {@link TaskBoard.view.TaskBoard#config-columnField},\n * {@link TaskBoard.view.TaskBoard#config-swimlaneField} and/or {@link TaskBoard.model.TaskModel#field-weight} fields\n * are updated to reflect the new location.\n *\n * ## Drag events\n *\n * The different stages of a drag operation trigger different events, in order of appearance:\n *\n * | Event                         | Description                                                                    |\n * |-------------------------------|--------------------------------------------------------------------------------|\n * | {@link #event-beforeTaskDrag} | Preventable event fired before a drag starts                                   |\n * | {@link #event-taskDragStart}  | Fired when dragging starts                                                     |\n * | {@link #event-taskDrag}       | Fired when movement during a drag will lead to changes                         |\n * | {@link #event-beforeTaskDrop} | Preventable event fired before finalizing a valid drop. Allows async listeners |\n * | {@link #event-taskDrop}       | Fired after finalizing a valid drop                                            |\n * | {@link #event-taskDragAbort}  | Fired when a drag is aborted (ESC, drop out of bounds or by a listener)        |\n * | {@link #event-taskDragEnd}    | Fired when a started drag ends, no matter the outcome                          |\n *\n * The {@link #event-beforeTaskDrop} is useful for example to request user confirmation for a drop:\n *\n * {@inlineexample TaskBoard/feature/TaskDragEvents.js}\n *\n * This feature is **enabled** by default.\n *\n * @extends TaskBoard/feature/TaskBoardFeature\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype taskDrag\n * @feature\n */\nexport default class TaskDrag extends TaskBoardFeature {\n    static $name = 'TaskDrag';\n\n    static type = 'taskDrag';\n\n    static pluginConfig = {\n        after : ['initialCompose']\n    };\n\n    static configurable = {\n        /**\n         * Specify `true` to enable the old behavior of moving tasks in the store on drop.\n         *\n         * This behaviour was made opt in since it does not play well when sharing data with other components.\n         *\n         * <div class=\"note\">\n         * If you are sorting tasks by a field other than `weight` and want predictable results on drop, you should\n         * enable this config.\n         * </div>\n         *\n         * @config {Boolean}\n         * @default\n         */\n        reorderTaskRecords : false\n    };\n\n    initialCompose() {\n        const me = this;\n\n        // Cannot use configurable since bodyElement is not available yet when feature is pulled in\n        me.draggable = TaskZone.new({\n            dragRootElement : me.disabled ? null : me.client.bodyWrapElement,\n            dropRootElement : me.client.bodyWrapElement,\n            owner           : me,\n\n            internalListeners : {\n                beforeDragStart : 'onBeforeDragStart',\n                dragStart       : 'onDragStart',\n                thisObj         : me\n            }\n        }, me.draggable);\n    }\n\n    doDestroy() {\n        super.doDestroy();\n\n        this.draggable?.destroy();\n    }\n\n    doDisable(disable) {\n        super.doDisable(disable);\n\n        if (this.draggable) {\n            this.draggable.dragRootElement = disable ? null : this.client.bodyWrapElement;\n        }\n    }\n\n    onBeforeDragStart({ drag, event }) {\n        /**\n         * Fires on the owning TaskBoard before task dragging starts. Return `false` to prevent the action\n         * @event beforeTaskDrag\n         * @preventable\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n         * @param {TaskBoard.model.TaskModel[]} taskRecords Tasks to be dragged\n         * @param {Event} domEvent The mouse event\n         */\n        return this.client.trigger('beforeTaskDrag', { drag, event, domEvent : event, taskRecords : drag.taskRecords });\n    }\n\n    onDragStart({ drag, event }) {\n        /**\n         * Fires on the owning TaskBoard when task dragging starts\n         * @event taskDragStart\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n         * @param {TaskBoard.model.TaskModel[]} taskRecords Tasks to be dragged\n         * @param {Event} domEvent The mouse event\n         */\n        return this.client.trigger('taskDragStart', { drag, event, domEvent : event, taskRecords : drag.taskRecords });\n    }\n}\n\nTaskDrag.initClass();\n\nclass TaskZone extends Base.mixin(Draggable, Droppable, Events) {\n    static get configurable() {\n        return {\n            dragSelector       : '.b-taskboard-card:not(.b-readonly)',\n            dragItemSelector   : '.b-taskboard-card:not(.b-readonly)',\n            // Accept drops on anything within the TaskBoard\n            dropTargetSelector : '.b-taskboardbase',\n\n            // We are going to allow dragging multiple cards, will need to add cls manually to all of them\n            draggingItemCls : null,\n\n            dragProxy : {\n                type : 'default',\n\n                async open(drag) {\n                    const\n                        {\n                            itemElement,\n                            startEvent\n                        }          = drag,\n                        taskBoard  = this.owner.owner.client,\n                        columnEl   = itemElement.closest('.b-taskboard-column'),\n                        taskRecord = taskBoard.resolveTaskRecord(itemElement),\n                        proxy      = drag.proxy = DomHelper.createElement({\n                            // Add column classes too to get exact same styles applied\n                            className     : 'b-taskboard-drag-proxy ' + columnEl.className,\n                            role          : 'presentation',\n                            // Don't want it being removed while dragging\n                            retainElement : true\n                        }),\n                        cardClones = [];\n\n                    let taskRecords;\n\n                    // If we have selected tasks, drag them only if drag starts from one of the selected\n                    if (taskBoard.selectedTasks.includes(taskRecord)) {\n                        taskRecords = taskBoard.selectedTasks.filter(t => !t.readOnly).sort((a, b) => a.parentIndex - b.parentIndex);\n                    }\n                    // Otherwise (no selection or dragging an unselected) only drag one\n                    else {\n                        taskRecords = [taskRecord];\n                    }\n\n                    const taskElements = taskRecords.map(r => taskBoard.getTaskElement(r));\n\n                    Object.assign(drag, {\n                        taskElements,\n                        // Store heights, cannot measure later when original tasks are hidden\n                        taskHeights : new Map(),\n                        // Offset from cursor, ignoring page scroll = client coords\n                        proxyOffset : EventHelper\n                            .getClientPoint(startEvent)\n                            .getDelta(Rectangle.from(itemElement, null, true))\n                    });\n\n                    // Clone all dragged cards and put them in the proxy\n                    taskElements.forEach(taskElement => {\n                        const\n                            { elementData } = taskElement,\n                            cardClone       = taskElement.cloneNode(true),\n                            bounds          = Rectangle.from(taskElement, itemElement);\n\n                        // Cards get their width from the column, need to apply the width to the proxy card\n                        cardClone.style.width = bounds.width + 'px';\n                        cardClone.style.height = bounds.height + 'px';\n                        drag.taskHeights.set(taskElement, bounds.height);\n\n                        // Position cards in the proxy to overlap their originals\n                        cardClone.style.left = bounds.x + 'px';\n                        cardClone.style.top = bounds.y + 'px';\n\n                        cardClone.taskElement = taskElement;\n                        cardClone.taskRecord = elementData.taskRecord;\n                        cardClone.originalColor = elementData.swimlaneRecord?.color || elementData.columnRecord.color;\n\n                        proxy.appendChild(cardClone);\n                        cardClones.push(cardClone);\n                    });\n\n                    // Hide original card after measuring it above (cannot be done in the same loop, others will get\n                    // wrong bounds)\n                    taskElements.forEach(taskElement => taskElement.classList.add('b-drag-original'));\n\n                    await AsyncHelper.animationFrame();\n\n                    // Now reposition the cards to their desired position within the proxy, transitioning them there\n                    cardClones.forEach((cardClone, i) => {\n                        if (i > 0) {\n                            cardClone.style.top = (30 + i * 20) + 'px';\n                            cardClone.style.left = (40 + i * 5) + 'px';\n                        }\n                        else {\n                            cardClone.style.top = 0;\n                            cardClone.style.left = 0;\n                        }\n                    });\n                },\n\n                dragMove({ proxy, event, proxyOffset }) {\n                    const\n                        { dragRootElement } = this.owner,\n                        // Parent coords relative to screen (client)\n                        parentBounds        = dragRootElement.getBoundingClientRect(),\n                        // Place proxy in client coords\n                        position            = EventHelper.getClientPoint(event).translate(\n                            proxyOffset[0] - parentBounds.left + dragRootElement.scrollLeft,\n                            proxyOffset[1] - parentBounds.top + dragRootElement.scrollTop\n                        );\n\n                    proxy.style.top = position.y + 'px';\n                    proxy.style.left = position.x + 'px';\n\n                    // Experimental, tilt proxy based on drag amount and direction\n\n                    // let delta = 0;\n                    //\n                    // if (proxy.lastClientX != null) {\n                    //     delta = event.clientX - proxy.lastClientX;\n                    // }\n                    //\n                    // proxy.lastClientX = event.clientX;\n                    //\n                    // proxy.style.transform = `rotate(${-delta / 10}deg)`;\n                    // proxy.style.transformOrigin = `${-proxyOffset[0]}px ${-proxyOffset[1]}px`;\n                }\n            }\n        };\n    }\n\n    configureListeners(drag) {\n        const listeners = super.configureListeners(drag);\n\n        // Listen to the events on the root element\n        listeners.element = this.owner.client.rootElement;\n\n        return listeners;\n    }\n\n    setupDragContext(event) {\n        const\n            result     = super.setupDragContext(event),\n            { client } = this.owner;\n\n        result.scrollManager = client.scrollManager;\n        result.monitoringConfig = {\n            scrollables : [\n                {\n                    element   : '.b-taskboard-column-body',\n                    direction : 'vertical'\n                },\n                {\n                    element   : client.bodyElement,\n                    direction : 'both'\n                }\n            ]\n        };\n\n        return result;\n    }\n\n    // Populate the drag context early, to have something to take decisions on in beforeDragStart listeners\n    startDrag(drag) {\n        const\n            { itemElement } = drag,\n            taskBoard       = this.owner.client,\n            taskRecord      = taskBoard.resolveTaskRecord(itemElement);\n\n        // If we have selected tasks, drag them only if drag starts from one of the selected\n        if (taskBoard.isSelected(taskRecord)) {\n            drag.taskRecords = taskBoard.selectedTasks.slice().sort((a, b) => a.parentIndex - b.parentIndex);\n        }\n        // Otherwise (no selection or dragging an unselected) only drag one\n        else {\n            drag.taskRecords = [taskRecord];\n        }\n\n        drag.initiatedFrom = taskRecord;\n\n        return super.startDrag(drag);\n    }\n\n    dragStart(drag) {\n        const\n            { client }  = this.owner,\n            // Insert dropIndicators next to task that drag was initiated on initially\n            nextSibling = drag.itemElement;\n\n        // Flag to determine if `taskDragEnd` should be triggered on later abort\n        drag.wasStarted = true;\n\n        // Initially positioned after task drag is initiated from\n        drag.position = 'after';\n        drag.targetTaskRecord = drag.initiatedFrom;\n\n        for (const taskRecord of drag.taskRecords) {\n            taskRecord.instanceMeta(client).dragging = true;\n        }\n\n        // Adding proxy here and not when it is created saves one layout\n        client.bodyWrapElement.appendChild(drag.proxy);\n\n        // Populate drop indicator with placeholders\n        drag.dropIndicators = drag.taskElements.map((taskElement, i) => {\n            return DomHelper.createElement({\n                className : {\n                    'b-taskboard-card-drop-indicator' : 1,\n                    'b-first-drop-indicator'          : i === 0\n                },\n                style : {\n                    height : drag.taskHeights.get(taskElement)\n                },\n                elementData : {\n                    dropIndicator : true,\n                    // To be able to detect if it has actually moved on drop\n                    initialParent : taskElement.parentElement,\n                    initialIndex  : indexOf(taskElement),\n                    // Tag along the taskElement, to be able to return the drop indicator to its position for\n                    // invalid drop targets\n                    taskElement\n                },\n                retainElement : true,\n                nextSibling\n            });\n        });\n\n        client.element.classList.add('b-dragging-task');\n    }\n\n    dragEnter(drag) {\n        // Only accept tasks\n        if (!drag.itemElement.matches(this.dragItemSelector)) {\n            return false;\n        }\n    }\n\n    // Finds the first visible direct child in a parent element\n    getFirstVisibleChild(parentElement) {\n        for (const element of parentElement.children) {\n            if (element.offsetParent) {\n                return element;\n            }\n        }\n    }\n\n    // Convenience shortcut to not have to pass custom card selector on each call\n    getCardAt(x, y) {\n        return this.owner.client.getCardAt(x, y, cardSelector);\n    }\n\n    updateValidity(drag, valid) {\n        drag.proxy.classList.toggle('b-invalid', !valid);\n        drag.dropIndicators.forEach(dropIndicator => dropIndicator.classList.toggle('b-invalid', !valid));\n        drag.invalid = !valid;\n    }\n\n    dragMove(drag) {\n        const\n            me                                   = this,\n            { client }                           = me.owner,\n            { event : domEvent, dropIndicators } = drag,\n            { clientX, clientY }                 = domEvent,\n            overElement                          = client.documentRoot.elementFromPoint(clientX, clientY),\n            columnElement                        = DomSync.getChild(overElement?.closest('.b-taskboard-column'), 'body.inner');\n\n        if (drag.invalid) {\n            drag.valid = false;\n        }\n\n        if (!overElement) {\n            return;\n        }\n\n        // Over something in a column or the column itself\n        if (columnElement) {\n            const\n                targetSwimlane = client.resolveSwimlaneRecord(overElement),\n                targetColumn   = client.resolveColumnRecord(overElement),\n                tasksPerRow    = targetColumn.tasksPerRow || targetSwimlane?.tasksPerRow || client.tasksPerRow;\n\n            let\n                cardElement   = overElement.closest(cardSelector),\n                // Should only trigger drag event when move actually affected something\n                shouldTrigger = targetSwimlane !== drag.targetSwimlane || targetColumn !== drag.targetColumn;\n\n            // Only resolve swimlane/column when over a column, that way target sticks even if mouse is moved outside\n            drag.targetSwimlane = targetSwimlane;\n            drag.targetColumn = targetColumn;\n\n            // Might be over gap between cards, check if there is card above or below the gap\n            if (!cardElement) {\n                const\n                    { cardGap } = client,\n                    columnRect  = Rectangle.from(columnElement),\n                    topCard     = me.getFirstVisibleChild(columnElement),\n                    top         = topCard?.getBoundingClientRect().top ?? null;\n\n                if (tasksPerRow === 1) {\n                    // Above top card, use it\n                    if (top !== null && clientY < top) {\n                        cardElement = topCard;\n                    }\n                    else {\n                        const\n                            centerX   = columnRect.center.x,\n                            // Check column center, one gap up\n                            cardAbove = me.getCardAt(centerX, clientY - cardGap),\n                            // And one gap down\n                            cardBelow = me.getCardAt(centerX, clientY + cardGap);\n\n                        // Pick one of them\n                        cardElement = cardAbove || cardBelow;\n                    }\n                }\n                else {\n                    // Determine which \"inner column\" mouse is over\n                    const\n                        columnContentWidth = client.getColumnWidth(drag.targetColumn),\n                        // Can calculate padding, avoids reading it from DOM\n                        columnPadding      = (columnRect.width - columnContentWidth) / 2,\n                        // Width of an \"inner column\", ignoring gap between cards which does not matter in this case.\n                        // An approximate center fits our purpose\n                        innerColumnWidth   = columnContentWidth / tasksPerRow,\n                        // \"Inner column\" index\n                        index              = Math.floor((clientX - columnRect.left) / innerColumnWidth),\n                        // That columns center\n                        centerX            = columnRect.left + columnPadding + innerColumnWidth * (index + 0.5);\n\n                    // Above top row, use card below us\n                    if (top !== null && clientY < top) {\n                        cardElement = me.getCardAt(centerX, top);\n                    }\n                    else {\n                        const\n                            centerX    = columnRect.center.x,\n                            // Check column center, one gap left\n                            cardBefore = me.getCardAt(centerX - cardGap, clientY),\n                            // And one gap right\n                            cardAfter  = me.getCardAt(centerX + cardGap, clientY);\n\n                        // Pick one of them\n                        cardElement = cardBefore || cardAfter;\n                    }\n                }\n            }\n\n            // If we are over the drop indicator, we do nothing\n            if (!cardElement?.elementData.dropIndicator) {\n                let insertBefore = false;\n\n                // If we found a card, we should either go above or below it\n                if (cardElement) {\n                    const\n                        cardRect         = Rectangle.from(cardElement),\n                        targetTaskRecord = client.resolveTaskRecord(cardElement);\n\n                    // Insert before\n                    if (\n                        // If above center with single task per row\n                        (tasksPerRow === 1 && clientY < cardRect.center.y) ||\n                        // Or left of center in multiple tasks per row\n                        (tasksPerRow > 1 && clientX < cardRect.center.x)\n                    ) {\n                        if (drag.position !== 'before') {\n                            shouldTrigger = true;\n                        }\n\n                        insertBefore = cardElement;\n                        drag.position = 'before';\n                    }\n                    // Insert after\n                    else {\n                        if (drag.position !== 'after') {\n                            shouldTrigger = true;\n                        }\n\n                        insertBefore = cardElement.nextElementSibling;\n                        drag.position = 'after';\n                    }\n\n                    if (targetTaskRecord !== drag.targetTaskRecord) {\n                        shouldTrigger = true;\n                    }\n\n                    drag.targetTaskRecord = targetTaskRecord;\n                }\n                // No card, either empty column or below cards. Either way we append the card to the column\n                else {\n                    if (drag.position !== 'last') {\n                        shouldTrigger = true;\n                    }\n\n                    drag.position = 'last';\n                    drag.targetTaskRecord = null;\n                }\n\n                if (!insertBefore?.elementData?.dropIndicator) {\n                    if (insertBefore === false) {\n                        dropIndicators.forEach(dropIndicator => {\n                            columnElement?.appendChild(dropIndicator);\n                        });\n                    }\n                    else {\n                        dropIndicators.forEach(dropIndicator => {\n                            (insertBefore?.parentElement || columnElement).insertBefore(dropIndicator, insertBefore);\n                        });\n                    }\n\n                    drag.lastCardElement = cardElement;\n                }\n            }\n\n            // Update dragged cards dataset/color cls in case it is used for styling (as we do in demos)\n            for (const card of drag.proxy.children) {\n\n                if (!card.taskRecord.eventColor) {\n                    const color = drag.targetSwimlane?.color || drag.targetColumn.color;\n\n                    if (card.originalColor) {\n                        card.classList.remove(`b-taskboard-color-${card.originalColor}`);\n                    }\n\n                    if (color) {\n                        card.originalColor = color;\n                        if (DomHelper.isNamedColor(color)) {\n                            card.classList.add(`b-taskboard-color-${color}`);\n                        }\n                        else {\n                            card.style.color = color;\n                        }\n                    }\n                }\n\n                if (drag.targetSwimlane) {\n                    card.dataset.lane = drag.targetSwimlane.id;\n                }\n\n                card.dataset.column = drag.targetColumn.id;\n            }\n\n            if (shouldTrigger) {\n                const\n                    { taskRecords, targetTaskRecord, position } = drag,\n                    /**\n                     * Fires on the owning TaskBoard when tasks are dragged, if the drag leads to any changes compared to\n                     * the last taskDrag event (moved to a new column or changed order within a column).\n                     *\n                     * Returning `false` from a listener will flag the drag as invalid (by default turning the drop\n                     * indicator red)\n                     *\n                     * @event taskDrag\n                     * @on-owner\n                     * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n                     * @param {TaskBoard.model.TaskModel[]} taskRecords Dragged tasks\n                     * @param {TaskBoard.model.ColumnModel} targetColumn Currently over this column\n                     * @param {TaskBoard.model.SwimlaneModel} targetSwimlane Currently over this swimlane (if used)\n                     * @param {Event} domEvent The mouse event\n                     */\n                    result                                      = client.trigger(\n                        'taskDrag',\n                        { drag, taskRecords, targetSwimlane, targetColumn, targetTaskRecord, position, event : domEvent, domEvent }\n                    );\n\n                me.updateValidity(drag, result !== false);\n            }\n        }\n    }\n\n    async dragDrop(drag) {\n        const\n            me         = this,\n            { client } = me.owner,\n            {\n                dropIndicators,\n                taskRecords,\n                targetSwimlane,\n                targetColumn,\n                targetTaskRecord,\n                event : domEvent\n            }          = drag,\n            event      = { drag, domEvent, event : domEvent, taskRecords, targetSwimlane, targetColumn, targetTaskRecord },\n            // Check that drop will lead to changes for at least one dragged task\n            changed    = hasChanged(dropIndicators);\n\n        /**\n         * Fires on the owning TaskBoard when tasks are dropped, before the operation completes. Handles async\n         * listeners, returning `false` from one will abort the operation\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    listeners : {\n         *        async beforeTaskDrop({ taskRecords, targetColumn }) {\n         *            // Show confirmation dialog\n         *            const result = await MessageDialog.confirm({\n         *                title   : 'Verify drop',\n         *                message : `Please confirm moving ${taskRecords.map(t => `\"${t.name}\"`).join(', ')} to ${targetColumn.text}?`\n         *            });\n         *\n         *            // Returning false will abort the drop (if user pressed Cancel)\n         *            return result === MessageDialog.okButton;\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @event beforeTaskDrop\n         * @preventable\n         * @async\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n         * @param {TaskBoard.model.TaskModel[]} taskRecords Dropped tasks\n         * @param {TaskBoard.model.ColumnModel} targetColumn Dropped on this column\n         * @param {TaskBoard.model.SwimlaneModel} targetSwimlane Dropped in this swimlane (if used)\n         * @param {Event} domEvent The mouse event\n         */\n        if (!changed || !targetColumn || drag.invalid || await client.trigger('beforeTaskDrop', event) === false) {\n            drag.valid = false;\n        }\n        else {\n            drag.finalizer = new Promise(resolve => {\n                // Data part\n                const\n                    {\n                        columnField,\n                        swimlaneField\n                    }               = client,\n                    { taskStore }   = client.project,\n                    {\n                        proxy\n                    }               = drag,\n                    columnRecords   = targetColumn.tasks,\n                    swimlaneRecords = targetSwimlane\n                        ? columnRecords?.filter(task => task[swimlaneField] === targetSwimlane.id)\n                        : columnRecords,\n                    invalid         = !columnRecords;\n\n                let moveBefore;\n\n                if (!invalid) {\n                    // Dropped relative to another card?\n                    if (drag.targetTaskRecord) {\n                        // If before it, move to before it in store too\n                        if (drag.position === 'before') {\n                            moveBefore = targetTaskRecord;\n                        }\n                        // If after, move to before the next record\n                        else if (drag.position === 'after') {\n                            const index = swimlaneRecords.indexOf(targetTaskRecord);\n                            moveBefore = swimlaneRecords[index + 1] ?? null;\n                        }\n                    }\n                    // Dropped below all cards or in empty column, move to last in store which guarantees it is last in that column\n                    else if (swimlaneRecords.length) {\n                        moveBefore = null;\n                    }\n                }\n\n                function commit() {\n                    // Remove proxy & dropIndicators\n                    proxy.remove();\n\n                    dropIndicators.forEach(dropIndicator => {\n                        const { taskElement } = dropIndicator.elementData;\n                        // Move original element to the new destination\n                        dropIndicator.parentElement.insertBefore(taskElement, dropIndicator);\n                        // Make it available for syncing\n                        dropIndicator.parentElement.syncIdMap[taskElement.elementData.taskId] = taskElement;\n                        // And unflag it\n                        taskElement.classList.remove('b-drag-original');\n\n                        dropIndicator.remove();\n                    });\n\n                    client.suspendDomTransition();\n\n                    // Update data\n                    if (!invalid) {\n                        let newWeight;\n\n                        // Determine new weight\n                        if (moveBefore) {\n                            const\n                                // Successors, that might need to have their weight updated\n                                tasksBelow = swimlaneRecords.slice(swimlaneRecords.indexOf(moveBefore)),\n                                // Predecessor, we want to squeeze in after it weight-wise\n                                taskAbove = swimlaneRecords[swimlaneRecords.indexOf(moveBefore) - 1];\n\n                            let weightDiff;\n\n                            // We have a predecessor, put us between the card we \"replace\" and it to update as few\n                            // weights as possible\n                            if (taskAbove) {\n                                // Between tasks, down to 1 sized gaps\n                                weightDiff = Math.max(1, Math.round((moveBefore.weight - taskAbove.weight) / 2));\n                                newWeight = taskAbove.weight + weightDiff;\n                            }\n                            // First in column, put us between old first task and 0 in weight\n                            else {\n                                newWeight = Math.max(1, Math.round(moveBefore.weight / 2));\n                            }\n\n                            // Update weight for successors that have colliding weights.\n                            // New weight will be between current and next, to try and avoid having to change\n                            // multiple weights while also leaving gaps for future drops\n                            while (tasksBelow[0]?.weight === newWeight) {\n                                // Place halfway between this and next task\n                                weightDiff = tasksBelow[1]\n                                    ? Math.max(1, Math.round((tasksBelow[1].weight - newWeight) / 2))\n                                    : 50;\n                                newWeight = tasksBelow[0].weight = newWeight + weightDiff;\n                                tasksBelow.shift();\n                            }\n                        }\n                        // Last, add 100 to current lasts weight\n                        else {\n                            newWeight = swimlaneRecords.length\n                                ? swimlaneRecords[swimlaneRecords.length - 1].weight + 100\n                                : 100;\n                        }\n\n                        taskRecords.forEach(taskRecord => {\n                            const toSet = {\n                                [columnField] : targetColumn.id,\n                                weight        : newWeight\n                            };\n\n                            if (targetSwimlane) {\n                                toSet[swimlaneField] = targetSwimlane.id;\n                            }\n\n                            // Optionally reorder the store\n                            if (client.features.taskDrag.reorderTaskRecords && moveBefore !== undefined) {\n                                taskStore.move(taskRecord, moveBefore);\n                            }\n\n                            taskRecord.set(toSet);\n                        });\n\n                        // Reapply sorters if we are not reordering tasks and not overriding sort in the store on drop\n                        if (!client.features.taskDrag.reorderTaskRecords && !client.taskSorterFn) {\n                            client.project.taskStore.sort();\n                        }\n                    }\n\n                    client.resumeDomTransition();\n\n                    /**\n                     * Fires on the owning TaskBoard when tasks are successfully dropped (after the drop transition has\n                     * finished)\n                     * @event taskDrop\n                     * @on-owner\n                     * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n                     * @param {TaskBoard.model.TaskModel[]} taskRecords Dropped tasks\n                     * @param {TaskBoard.model.ColumnModel} targetColumn Dropped on this column\n                     * @param {TaskBoard.model.SwimlaneModel} targetSwimlane Dropped in this swimlane (if used)\n                     * @param {Event} domEvent The mouse event\n                     */\n                    client.trigger('taskDrop', { drag, event : domEvent, taskRecords, targetSwimlane, targetColumn, moveBefore, domEvent });\n\n                    /**\n                     * Fires on the owning TaskBoard when a previously started drag operation ends, no matter the\n                     * outcome of it (whether valid, invalid or aborted)\n                     *\n                     * @event taskDragEnd\n                     * @on-owner\n                     * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n                     * @param {TaskBoard.model.TaskModel[]} taskRecords Affected tasks\n                     * @param {Event} domEvent The mouse event\n                     */\n                    client.trigger('taskDragEnd', { drag, taskRecords, domEvent });\n\n                    // Reading element here flushes the recompose\n                    client.element.classList.remove('b-dragging-task');\n\n                    // Reset flag after recompose to avoid flicker when virtualizing (to not first render outline)\n                    for (const taskRecord of taskRecords) {\n                        taskRecord.instanceMeta(client).dragging = false;\n                    }\n\n                    resolve();\n                }\n\n                // UI part\n\n                const cardClones = Array.from(proxy.children);\n\n                // Ugly \"hack\" to force the transforms used in the proxy to go away\n                proxy.classList.add('b-pre-dropping');\n                cardClones[0].offsetWidth;\n\n                // We are dropping, this cls by default has a transition\n                proxy.classList.add('b-dropping');\n\n                // Move proxy cards to drop locations, allowing them to transition there\n                cardClones.forEach((cardClone, i) => {\n                    const dropClone = dropIndicators[i];\n\n                    DomHelper.alignTo(\n                        cardClone,\n                        // Ignore page scroll when trying to align element in float root to element in taskboard\n                        Rectangle.from(dropClone, undefined, true)\n                    );\n                });\n\n                // Update record after the transition, to prevent too early redraw (which would ruin the transition)\n                if (DomHelper.getPropertyTransitionDuration(cardClones[0], 'transform')) {\n                    EventHelper.onTransitionEnd({\n                        element  : cardClones[0],\n                        property : 'transform',\n                        handler  : commit,\n                        thisObj  : client // For timer cleanup\n                    });\n                }\n                // Or right away if no transition is used\n                else {\n                    commit();\n                }\n            });\n        }\n    }\n\n    dragLeave(drag) {\n        // Move drop indicator to dragged cards origin, to indicate what will happen on invalid drop\n        drag.dropIndicators.forEach(dropIndicator => {\n            const { taskElement } = dropIndicator.elementData;\n            taskElement.parentElement.insertBefore(dropIndicator, taskElement);\n        });\n    }\n\n    doAbort(drag) {\n        const\n            { client }                             = this.owner,\n            { dropIndicators, proxy, taskRecords } = drag;\n\n        if (proxy) {\n            const cardClones = Array.from(proxy.children);\n\n            function finalizeAbort() {\n                // Remove proxy & dropIndicators\n                proxy.remove();\n\n                dropIndicators.forEach(dropIndicator => {\n                    dropIndicator.elementData.taskElement.classList.remove('b-drag-original');\n                    dropIndicator.remove();\n                });\n\n                client.element.classList.remove('b-dragging-task');\n\n                // Rest flag late to avoid flicker when virtualizing (to not first render outline)\n                for (const taskRecord of taskRecords) {\n                    taskRecord.instanceMeta(client).dragging = false;\n                }\n\n                client.trigger('taskDragAbortFinalized');\n            }\n\n            // Emulate drop to enable transitions\n            proxy.classList.add('b-dropping');\n\n            // Move drop indicators to where each task originated\n            dropIndicators.forEach(dropIndicator => {\n                const { taskElement } = dropIndicator.elementData;\n\n                dropIndicator.classList.remove('b-invalid'); // Looks better this way when returning to origin\n\n                taskElement.parentElement.insertBefore(dropIndicator, taskElement);\n            });\n\n            // Move proxy cards to original locations, allowing them to transition there\n            cardClones.forEach((cardClone, i) => {\n                DomHelper.alignTo(\n                    cardClone,\n                    // Ignore page scroll when trying to align element in float root to element in taskboard\n                    Rectangle.from(dropIndicators[i], undefined, true)\n                );\n            });\n\n            // Finalize after transition\n            if (DomHelper.getPropertyTransitionDuration(cardClones[0], 'transform')) {\n                EventHelper.onTransitionEnd({\n                    element  : cardClones[0],\n                    property : 'transform',\n                    handler  : finalizeAbort,\n                    thisObj  : client // For timer cleanup\n                });\n            }\n            // Or right away if no transition is used\n            else {\n                finalizeAbort();\n            }\n        }\n\n        /**\n         * Fires on the owning TaskBoard when a drag operation is aborted (invalid drop or aborted using ESC)\n         *\n         * @event taskDragAbort\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n         * @param {TaskBoard.model.TaskModel[]} taskRecords Dragged tasks\n         */\n        client.trigger('taskDragAbort', { drag, taskRecords });\n\n        if (drag.wasStarted) {\n            // Documented in dragDrop()\n            client.trigger('taskDragEnd', { drag, taskRecords });\n        }\n    }\n\n    dragEnd(drag) {\n        // Move all cards back to their original location when drag was aborted\n        if (!drag.valid || drag.aborted) {\n            this.doAbort(drag);\n        }\n    }\n}\n", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport TaskBoardFeature from './TaskBoardFeature.js';\n\n/**\n * @module TaskBoard/feature/TaskDragSelect\n */\n\n/**\n * Enables users to click and drag to select cards on the TaskBoard (marquee selection).\n *\n * {@inlineexample TaskBoard/feature/TaskDragSelect.js}\n *\n * This feature is **enabled** by default.\n *\n * @extends Core/mixin/InstancePlugin\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype taskDragSelect\n * @feature\n */\nexport default class TaskDragSelect extends TaskBoardFeature {\n\n    static $name =  'TaskDragSelect';\n\n    static type = 'taskDragSelect';\n\n    static configurable = {\n        /**\n         * The amount of pixels to move pointer/mouse before it counts as a drag select operation.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    features : {\n         *        taskDragSelect : {\n         *            dragThreshold : 10\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @config {Number}\n         * @default\n         */\n        dragThreshold : 5\n    };\n\n    state = 'idle';\n\n    static pluginConfig = {\n        chain : ['onColumnMouseDown', 'onMouseMove']\n    };\n\n    //region Type assertions\n\n    changeDragThreshold(threshold) {\n        ObjectHelper.assertNumber(threshold, 'features.taskDragSelect.dragThreshold');\n\n        return threshold;\n    }\n\n    //endregion\n\n    initializeDragSelect(event) {\n        const\n            me         = this,\n            { client } = me;\n\n        me.bounds = Rectangle.from(client.bodyElement, /* ignorePageScroll = */ true);\n\n        me.element = DomHelper.createElement({\n            tag       : 'div',\n            className : 'b-dragselect-rect'\n        }, { returnAll : true })[0];\n\n        client.floatRoot.appendChild(me.element);\n        client.element.classList.add('b-dragselecting');\n\n        // Since the dragselect element is in the floatRoot, we want to use viewport-based coordinates, so we pass\n        // ignorePageScroll=true when calling Rectangle.from():\n        me.cardRectangles = Array.from(client.element.querySelectorAll('.b-taskboard-card')).map(el => ({\n            rectangle : Rectangle.from(el, /* ignorePageScroll = */ true),\n            record    : client.resolveTaskRecord(el)\n        }));\n\n        if (!event.ctrlKey) {\n            client.deselectAll();\n        }\n\n        // No key processing during drag selection\n        client.navigateable = false;\n\n        me.state = 'selecting';\n    }\n\n    // Select cards intersected by the selection marquee\n    updateSelection() {\n        const { cardRectangles, rectangle, client } = this;\n\n        for (let i = 0, len = cardRectangles.length; i < len; i++) {\n            const\n                cardData     = cardRectangles[i],\n                shouldSelect = rectangle.intersect(cardData.rectangle, true);\n\n            if (shouldSelect && !cardData.selected) {\n                cardData.selected = true;\n\n                client.selectTask(cardData.record, true);\n            }\n            else if (!shouldSelect && cardData.selected) {\n                cardData.selected = false;\n\n                client.deselectTask(cardData.record);\n            }\n        }\n    }\n\n    //region Listeners\n\n    onColumnMouseDown({ event }) {\n        const me = this;\n\n        if (!me.disabled && event.button === 0) {\n            me.state = 'considering';\n            me.startX = event.clientX;\n            me.startY = event.clientY;\n\n            me.mouseUpDetacher = EventHelper.on({\n                element : document,\n                mouseup : 'onMouseUp',\n                thisObj : me\n            });\n        }\n    }\n\n    onMouseMove({ event }) {\n        const\n            me                   = this,\n            { startX, startY }   = me,\n            { clientX, clientY } = event;\n\n        if (me.state === 'considering') {\n            const\n                deltaX = Math.abs(clientX - startX),\n                deltaY = Math.abs(clientY - startY);\n\n            if (deltaX > me.dragThreshold || deltaY > me.dragThreshold) {\n                me.initializeDragSelect(event);\n            }\n        }\n\n        if (me.state === 'selecting') {\n            const\n                { element, bounds } = me,\n                x                   = Math.max(clientX, bounds.left),\n                y                   = Math.max(clientY, bounds.top),\n                left                = Math.min(startX, x),\n                top                 = Math.min(startY, y),\n                width               = Math.abs(startX - x),\n                height              = Math.abs(startY - y),\n                rect                = new Rectangle(left, top, width, height).constrainTo(bounds);\n\n            DomHelper.setTranslateXY(element, rect.left, rect.top);\n            element.style.width  = rect.width + 'px';\n            element.style.height = rect.height + 'px';\n\n            me.rectangle = rect;\n\n            me.updateSelection();\n        }\n    }\n\n    onMouseUp() {\n        const\n            me                = this,\n            { client, state } = me;\n\n        // Cards are selected during mouse move, no need to change selection here\n\n        if (state === 'selecting') {\n            me.element?.remove();\n            client.element.classList.remove('b-dragselecting');\n\n            // Navigator will react to the 'click' event which clears selection, bypass this with a short timeout\n            client.setTimeout(() => client.navigateable = true, 100);\n        }\n\n        if (state === 'selecting' || state === 'considering') {\n            me.state = 'idle';\n            me.startX = me.startY = me.rectangle = me.bounds = null;\n        }\n\n        me.mouseUpDetacher?.();\n    }\n\n    //endregion\n}\n\nTaskDragSelect.initClass();\n", "import Base from '../../../Core/Base.js';\nimport Widget from '../../../Core/widget/Widget.js';\n\n/**\n * @module TaskBoard/widget/mixin/TaskBoardLinked\n */\n\n/**\n * Mixin that simplifies linking a widget to a {@link TaskBoard.view.TaskBoard}.\n *\n * @mixin\n */\nexport default Target => class TaskBoardLinked extends (Target || Base) {\n\n    static $name = 'TaskBoardLinked';\n\n    static configurable = {\n        /**\n         * Auto detected when used within a TaskBoard. If you add the widget elsewhere, it will try to find an instance\n         * of TaskBoard on page. If that fails you have to supply this config to connect it to a TaskBoard manually.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({});\n         *\n         * const picker = new ColumnPickerButton({\n         *    taskBoard // Link it to the taskBoard instance created above\n         * });\n         * ```\n         *\n         * @config {TaskBoard.view.TaskBoard}\n         * @category Common\n         */\n        taskBoard : null\n    };\n\n    get taskBoard() {\n        return this._taskBoard || this.up(widget => widget.isTaskBoardBase) || Widget.query(widget => widget.isTaskBoardBase);\n    }\n\n    changeTaskBoard(taskBoard) {\n        if (taskBoard && !taskBoard.isTaskBoard) {\n            throw new Error(`The taskBoard config only accepts an instance of TaskBoard or a subclass thereof`);\n        }\n\n        return taskBoard;\n    }\n};\n", "import DomHelper from '../../../Core/helper/DomHelper.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport Combo from '../../../Core/widget/Combo.js';\nimport TaskBoardLinked from '../mixin/TaskBoardLinked.js';\n\n/**\n * @module TaskBoard/widget/base/ColorBoxCombo\n */\n\n/**\n * Abstract base class with functionality shared between {@link TaskBoard.widget.ColumnCombo} and\n * {@link TaskBoard.widget.SwimlaneCombo}.\n *\n * @extends Core/widget/Combo\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @abstract\n */\nexport default class ColorBoxCombo extends Combo.mixin(TaskBoardLinked) {\n    static $name = 'ColorBoxCombo';\n\n    static type = 'colorboxcombo';\n\n    static configurable = {\n        displayField      : 'text',\n        valueField        : 'id',\n        editable          : false,\n        showBoxForNoColor : false,\n        listItemTpl({ text, color }) {\n            let html = StringHelper.encodeHtml(text);\n\n            if (color) {\n                if (DomHelper.isNamedColor(color)) {\n                    html = `<div class=\"b-colorbox b-taskboard-color-${color}\"></div>` + html;\n                }\n                else {\n                    html = `<div class=\"b-colorbox\" style=\"color : ${color}\"></div>` + html;\n                }\n            }\n\n            return html;\n        },\n        picker : {\n            cls : 'b-colorbox-picker'\n        }\n    };\n\n    afterConstruct() {\n        if (!this.showBoxForNoColor && !this.value) {\n            this.element.classList.add('b-colorless');\n        }\n    }\n\n    syncInputFieldValue(...args) {\n        const\n            me        = this,\n            { color } = me.record || {};\n\n        let className = 'b-colorbox';\n\n        if (color) {\n            if (DomHelper.isNamedColor(color)) {\n                className += ` b-taskboard-color-${color}`;\n            }\n            else {\n                me.colorBox.style.color = color;\n            }\n        }\n\n        me.colorBox.className = className;\n\n        if (!me.showBoxForNoColor) {\n            me.element.classList.toggle('b-colorless', !color);\n        }\n\n        super.syncInputFieldValue(...args);\n    }\n\n    get innerElements() {\n        return [\n            {\n                reference : 'colorBox',\n                className : 'b-colorbox'\n            },\n            ...super.innerElements\n        ];\n    }\n}\n", "import ColorBoxCombo from './base/ColorBoxCombo.js';\n\n/**\n * @module TaskBoard/widget/ColumnCombo\n */\n\n/**\n * A combo populated with the {@link TaskBoard.view.TaskBoard#property-columns} of a {@link TaskBoard.view.TaskBoard}.\n * If a column has a {@link TaskBoard.model.ColumnModel#field-color} defined, that color will be displayed in the combo\n * and its picker.\n *\n * Used in {@link TaskBoard.widget.TaskEditor} to pick which column a task belongs to (\"Status\" below):\n *\n * {@inlineexample TaskBoard/widget/ColumnCombo.js}\n *\n * @classtype columncombo\n * @extends TaskBoard/widget/base/ColorBoxCombo\n * @inputfield\n */\nexport default class ColumnCombo extends ColorBoxCombo {\n    static $name = 'ColumnCombo';\n\n    static type = 'columncombo';\n\n    changeStore() {\n        return this.taskBoard.columns.chain();\n    }\n}\n\nColumnCombo.initClass();\n", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport Combo from '../../Core/widget/Combo.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\nimport AvatarRendering from '../../Core/widget/util/AvatarRendering.js';\n\n/**\n * @module TaskBoard/widget/ResourcesCombo\n */\n\n/**\n * A combo populated with the resources of a {@link TaskBoard.view.TaskBoard taskboard´s}\n * {@link Scheduler.data.ResourceStore resource store}.\n *\n * Used in {@link TaskBoard.widget.TaskEditor} to assign resources to a task. Double-click a task to try it:\n *\n * {@inlineexample TaskBoard/widget/ResourcesCombo.js}\n *\n * @classtype resourcescombo\n * @extends Core/widget/Combo\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @inputfield\n */\nexport default class ResourcesCombo extends Combo.mixin(TaskBoardLinked) {\n    static $name = 'ResourcesCombo';\n\n    static type = 'resourcescombo';\n\n    static configurable = {\n        displayField : 'name',\n        valueField   : 'id',\n        multiSelect  : true,\n        editable     : false,\n\n        listItemTpl(resourceRecord) {\n            const { avatarRendering, taskBoard } = this.owner;\n\n            // <remove-on-release>\n            // TODO: Discuss with nige, improve list, switch to grid or just implement html string here?\n            // </remove-on-release>\n            return DomHelper.createElement(avatarRendering.getResourceAvatar({\n                resourceRecord,\n                initials : resourceRecord.initials,\n                color    : resourceRecord.color,\n                iconCls  : resourceRecord.iconCls,\n                imageUrl : resourceRecord.image === false ? null : (resourceRecord.imageUrl || ((taskBoard.resourceImagePath || '') + (resourceRecord.image || '')))\n            })).outerHTML + StringHelper.encodeHtml(resourceRecord.name);\n        },\n\n        picker : {\n            cls : 'b-resources-picker'\n        },\n\n        chipView : {\n            scrollable : null,\n\n            itemTpl(resourceRecord) {\n                const { avatarRendering, taskBoard } = this.owner;\n\n                // <remove-on-release>\n                // TODO: Discuss with nige, improve list, switch to grid or just implement html string here?\n                // </remove-on-release>\n                return DomHelper.createElement(avatarRendering.getResourceAvatar({\n                    resourceRecord,\n                    initials : resourceRecord.initials,\n                    color    : resourceRecord.color,\n                    iconCls  : resourceRecord.iconCls,\n                    imageUrl : resourceRecord.image === false ? null : (resourceRecord.imageUrl || ((taskBoard.resourceImagePath || '') + (resourceRecord.image || ''))),\n                    dataset  : {\n                        btip : StringHelper.encodeHtml(resourceRecord.name)\n                    }\n                })).outerHTML;\n            }\n        },\n\n        avatarRendering : {\n            value   : true,\n            $config : 'nullify'\n        }\n    };\n\n    get innerElements() {\n        // See if we have an uningested truthy multiSelect configuration, or we have already set it.\n        if (this.peekConfig('multiSelect') || this._multiSelect) {\n            return super.innerElements;\n        }\n\n        // Add element that we can render an avatar into when not using a chipview\n        return [\n            { reference : 'avatarContainer' },\n            this.inputElement\n        ];\n    }\n\n    syncInputFieldValue(...args) {\n        const me = this;\n\n        // No chipview when not multi selecting, render single avatar\n        if (!me.multiSelect) {\n            const resourceRecord = me.record;\n\n            if (resourceRecord) {\n                DomSync.sync({\n                    targetElement : me.avatarContainer,\n                    domConfig     : {\n                        className : 'b-resourcescombo-avatar-container',\n                        children  : [\n                            me.avatarRendering.getResourceAvatar({\n                                resourceRecord,\n                                initials : resourceRecord.initials,\n                                color    : resourceRecord.color,\n                                iconCls  : resourceRecord.iconCls,\n                                imageUrl : resourceRecord.image === false ? null : (resourceRecord.imageUrl || ((me.taskBoard.resourceImagePath || '') + (resourceRecord.image || ''))),\n                                dataset  : {\n                                    btip : StringHelper.encodeHtml(resourceRecord.name)\n                                }\n                            })\n                        ]\n                    }\n                });\n            }\n        }\n\n        super.syncInputFieldValue(...args);\n    }\n\n    changeStore() {\n        return this.taskBoard.project.resourceStore.chain();\n    }\n\n    changeAvatarRendering(value, old) {\n        old?.destroy();\n\n        if (value) {\n            return new AvatarRendering({\n                element : this.element\n            });\n        }\n    }\n}\n\nResourcesCombo.initClass();\n", "import ColorBoxCombo from './base/ColorBoxCombo.js';\n\n/**\n * @module TaskBoard/widget/SwimlaneCombo\n */\n\n/**\n * A combo populated with the {@link TaskBoard.view.TaskBoard#property-swimlanes} of a {@link TaskBoard.view.TaskBoard}.\n * If a swimlane has a {@link TaskBoard.model.SwimlaneModel#field-color} defined, that color will be displayed in the\n * combo and its picker.\n *\n * Used in {@link TaskBoard.widget.TaskEditor} to pick which swimlane a task belongs to (\"Prio\" below):\n *\n * {@inlineexample TaskBoard/widget/ColumnCombo.js}\n *\n * @classtype swimlanecombo\n * @extends TaskBoard/widget/base/ColorBoxCombo\n * @inputfield\n */\nexport default class SwimlaneCombo extends ColorBoxCombo {\n    static $name = 'SwimlaneCombo';\n\n    static type = 'swimlanecombo';\n\n    changeStore() {\n        return this.taskBoard.swimlanes.chain();\n    }\n}\n\nSwimlaneCombo.initClass();\n", "import ColorPicker from '../../Core/widget/ColorPicker.js';\n\n/**\n * @module TaskBoard/widget/TaskColorPicker\n */\n\n/**\n * A color picker that displays a list of available task colors which the user can select by using mouse or keyboard.\n * See {@link TaskBoard.model.TaskModel#field-eventColor} for default available colors.\n *\n * {@inlineexample TaskBoard/widget/TaskColorPicker.js}\n *\n * ```javascript\n * new TaskColorPicker({\n *    appendTo : 'container',\n *    width    : '10em',\n *    onColorSelected() {\n *        console.log(...arguments);\n *    }\n * });\n * ```\n *\n * @classType colorpicker\n *\n * @extends Core/widget/ColorPicker\n */\nexport default class TaskColorPicker extends ColorPicker {\n    static $name = 'TaskColorPicker';\n\n    static type = 'taskcolorpicker';\n\n    static configurable = {\n\n        // These are the colors available by default for TaskBoard\n        colorClasses : [\n            { color : 'red', text : 'Red' },\n            { color : 'pink', text : 'Pink' },\n            { color : 'purple', text : 'Purple' },\n            { color : 'deep-purple', text : 'Deep purple' },\n            { color : 'indigo', text : 'Indigo' },\n            { color : 'blue', text : 'Blue' },\n            { color : 'light-blue', text : 'Light blue' },\n            { color : 'cyan', text : 'Cyan' },\n            { color : 'teal', text : 'Teal' },\n            { color : 'green', text : 'Green' },\n            { color : 'light-green', text : 'Light green' },\n            { color : 'lime', text : 'Lime' },\n            { color : 'yellow', text : 'Yellow' },\n            { color : 'amber', text : 'Amber' },\n            { color : 'orange', text : 'Orange' },\n            { color : 'deep-orange', text : 'Deep orange' }\n        ],\n\n        colorClassPrefix : 'b-taskboard-background-color-',\n\n        /**\n         * @hideconfigs colors\n         */\n\n        colors : null\n    };\n}\n\nTaskColorPicker.initClass();\n", "import ColorField from '../../Core/widget/ColorField.js';\nimport './TaskColorPicker.js';\n\n/**\n * @module TaskBoard/widget/TaskColorCombo\n */\n\n/**\n * A combo populated with predefined colors usable by a task, see {@link TaskBoard.model.TaskModel#field-eventColor}.\n *\n * Used in {@link TaskBoard.widget.TaskEditor} to pick a color for a task. Double click a task to try it:\n *\n * {@inlineexample TaskBoard/widget/TaskColorCombo.js}\n *\n * @classtype taskcolorcombo\n * @extends Core/widget/ColorField\n * @inputfield\n */\nexport default class TaskColorCombo extends ColorField {\n    static $name = 'TaskColorCombo';\n\n    static type = 'taskcolorcombo';\n\n    static configurable = {\n        picker : {\n            type : 'taskcolorpicker'\n        },\n        name      : 'eventColor',\n        clearable : true\n    };\n}\n\nTaskColorCombo.initClass();\n", "import StringHelper from '../../Core/helper/StringHelper.js';\nimport Popup from '../../Core/widget/Popup.js';\nimport '../../Core/widget/TextAreaField.js';\nimport '../../Core/widget/TextField.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\nimport './ColumnCombo.js';\nimport './ResourcesCombo.js';\nimport './SwimlaneCombo.js';\nimport './TaskColorCombo.js';\n\n/**\n * @module TaskBoard/widget/TaskEditor\n */\n\n/**\n * Popup used to edit tasks. Normally displayed using the {@link TaskBoard.feature.TaskEdit TaskEdit feature}.\n *\n * By default, the editor live updates the task being edited. If you prefer to use buttons to save/cancel the edit,\n * set {@link #config-autoUpdateRecord} to `false`.\n *\n * ## Items\n *\n * By default, it displays the following items:\n *\n * | Ref         | Type                                                   | Weight | Comment                                                                   |\n * |-------------|--------------------------------------------------------|--------|---------------------------------------------------------------------------|\n * | name        | {@link Core.widget.TextField text}                     | 100    | Task {@link TaskBoard.model.TaskModel#field-name}                         |\n * | description | {@link Core.widget.TextAreaField textarea}             | 200    | Task {@link TaskBoard.model.TaskModel#field-description}                  |\n * | resources   | {@link TaskBoard.widget.ResourcesCombo resourcescombo} | 300    | Assigned resources                                                        |\n * | color       | {@link TaskBoard.widget.TaskColorCombo taskcolorcombo} | 400    | Task {@link TaskBoard.model.TaskModel#field-eventColor}                   |\n * | column      | {@link TaskBoard.widget.ColumnCombo columncombo}       | 500    | Bound to configured {@link TaskBoard.view.TaskBoard#config-columnField}   |\n * | swimlane    | {@link TaskBoard.widget.SwimlaneCombo swimlanecombo}   | 600    | Bound to configured {@link TaskBoard.view.TaskBoard#config-swimlaneField} |\n *\n * If configured with `autoUpdateRecord: false` it also displays a bottom toolbar with the following items:\n *\n * | Ref          | Type                              | Weight | Comment          |\n * |--------------|-----------------------------------|--------|------------------|\n * | saveButton   | {@link Core.widget.Button button} | 100    | Save             |\n * | cancelButton | {@link Core.widget.Button button} | 200    | Cancel           |\n *\n * ## Customization\n *\n * Popup and its items can be customized through the feature (see {@link TaskBoard.feature.TaskEdit} fore more info):\n *\n * {@inlineexample TaskBoard/widget/TaskEditorCustomized.js}\n *\n * Or by subclassing and instructing the feature to display the new editor:\n *\n * {@inlineexample TaskBoard/widget/TaskEditorSubclassed.js}\n *\n * @classtype taskboardtaskeditor\n * @extends Core/widget/Popup\n */\nexport default class TaskEditor extends Popup.mixin(TaskBoardLinked) {\n    static $name = 'TaskEditor';\n\n    static type = 'taskboardtaskeditor';\n\n    static configurable = {\n\n        /**\n         * Center the editor in browser viewport space. Defaults to true for desktop browsers using a pointer device\n         * @config {Boolean}\n         * @default\n         * @category Common\n         */\n        centered : true,\n\n        /**\n         * Show an opaque mask below the editor when shown.\n         *\n         * Clicking the mask closes the editor.\n         *\n         * @config {Boolean}\n         * @default true\n         * @category Common\n         */\n        modal : { closeOnMaskTap : true },\n\n        /**\n         * Shows a tool used to close the editor in the header.\n         * @config {Boolean}\n         * @default\n         * @category Common\n         */\n        closable : true,\n\n        /**\n         * By default the editor automatically updates the edited task when a field is changed. Set this to `false`\n         * to show Save / Cancel buttons and take manual control of the updating.\n         *\n         * @config {Boolean}\n         * @default\n         * @category Common\n         */\n        autoUpdateRecord : true,\n\n        /**\n         * Update fields if the {@link #config-record} changes\n         * @config {Boolean}\n         */\n        autoUpdateFields : true,\n\n        /**\n         * True to save and close the editor if ENTER is pressed.\n         * (The save part only applies when configured with `autoUpdateRecord : false`)\n         *\n         * @config {Boolean}\n         * @default\n         * @category Common\n         */\n        saveAndCloseOnEnter : true,\n\n        draggable : {\n            handleSelector : '.b-panel-header'\n        },\n\n        autoShow : false,\n\n        anchor : true,\n\n        closeAction : 'destroy',\n\n        scrollAction : 'realign',\n\n        title : 'L{TaskBoard.editTask}',\n\n        defaults : {\n            labelWidth : '30%'\n        },\n\n        width : '30em',\n\n        items : {\n            name        : { type : 'text', label : 'L{TaskBoard.name}', weight : 100 },\n            description : { type : 'textarea', label : 'L{TaskBoard.description}', height : '5em', weight : 200 },\n            resources   : { type : 'resourcescombo', label : 'L{TaskBoard.resources}', weight : 300 },\n            color       : { type : 'taskcolorcombo', label : 'L{TaskBoard.color}', name : 'eventColor', weight : 400 },\n            column      : { type : 'columncombo', weight : 500 },\n            swimlane    : { type : 'swimlanecombo', weight : 600 }\n        },\n\n        bbar : {\n            hidden : true,\n            items  : {\n                saveButton   : { text : 'L{TaskBoard.save}', onClick : 'up.onSaveClick', weight : 100 },\n                cancelButton : { text : 'L{TaskBoard.cancel}', onClick : 'up.onCancelClick', weight : 200 }\n            }\n        },\n\n        // We want to maximize on phones and tablets\n        maximizeOnMobile : true\n    };\n\n    changeItems(items, old) {\n        const\n            { taskBoard }                   = this,\n            { column, swimlane, resources } = items;\n\n        if (taskBoard) {\n            // Hook column field up to correct record field\n            if (column) {\n                if (!column.name) {\n                    column.name = taskBoard.columnField;\n                }\n\n                if (!column.label) {\n                    column.label = StringHelper.capitalize(taskBoard.columnField);\n                }\n            }\n\n            if (swimlane) {\n                // Take the swimlane field out if not using swimlanes\n                if (!taskBoard.swimlaneField || !taskBoard.swimlanes) {\n                    items.swimlane = null;\n                }\n                // Otherwise hook it up with correct record field\n                else {\n                    if (!swimlane.name) {\n                        swimlane.name = taskBoard.swimlaneField;\n                    }\n\n                    if (!swimlane.label) {\n                        swimlane.label = StringHelper.capitalize(taskBoard.swimlaneField);\n                    }\n                }\n            }\n\n            // Remove resources field if there are no resources\n            if (!taskBoard.project.resourceStore.count) {\n                items.resources = null;\n            }\n\n            // Prevent multi selection if using single assignment mode\n            if (taskBoard.project.eventStore.usesSingleAssignment && resources) {\n                resources.multiSelect = false;\n            }\n        }\n        else {\n            items.column = items.swimlane = items.resources = null;\n        }\n\n        return super.changeItems(items, old);\n    }\n\n    processItemsObject(items, namedItems, result) {\n        // Use ref as name if not explicitly set\n        for (const ref in items) {\n            const item = items[ref];\n\n            if (item && !('name' in item)) {\n                item.name = ref;\n            }\n        }\n\n        return super.processItemsObject(items, namedItems, result);\n    }\n\n    updateAutoUpdateRecord(autoUpdate) {\n        this.bbar.hidden = autoUpdate;\n    }\n\n    updateRecord(record) {\n        super.updateRecord(record);\n\n        if (record) {\n            // Tag along task id, mainly for tests\n            this.element.dataset.taskId = record.id;\n        }\n    }\n\n    onSaveClick() {\n        const\n            me                       = this,\n            { record, owner }        = me,\n            { resources, ...values } = me.values;\n\n        if (me.isValid) {\n            /**\n             * Fires on the owning TaskBoard when user clicks `Save`, before changes are saved.\n             * Returning `false` from a listener prevents saving and keeps the editor open.\n             * @event beforeSave\n             * @on-owner\n             * @preventable\n             * @param {TaskBoard.view.TaskBoard} source The taskboard\n             * @param {TaskBoard.widget.TaskEditor} editor The editor\n             * @param {TaskBoard.model.TaskModel} record The task record\n             * @param {Object} values The task editor field values\n             */\n            if (owner?.trigger('beforeSave', { record, values : me.values, editor : me }) === false) {\n                return;\n            }\n\n            /**\n             * Fires on the owning TaskBoard when user clicks `Save`, after changes are saved.\n             * @event save\n             * @on-owner\n             * @param {TaskBoard.view.TaskBoard} source The taskboard\n             * @param {TaskBoard.widget.TaskEditor} editor The editor\n             * @param {TaskBoard.model.TaskModel} record The task record\n             * @param {Object} values The task editor field values\n             */\n            owner?.trigger('save', { record, values : me.values, editor : me });\n\n            // Close first to avoid focus restoring issues if the edit element gets removed by the operations below\n            me.close();\n\n            record.set(values);\n\n            if (resources) {\n                // Does not work when passed through set, handle it separately\n                record.resources = resources;\n            }\n        }\n    }\n\n    onCancelClick() {\n        const me = this;\n        /**\n         * Fires on the owning TaskBoard when user clicks 'Cancel'.\n         * Returning `false` from a listener prevents canceling and keeps the editor open.\n         * @event beforeCancel\n         * @preventable\n         * @param {TaskBoard.view.TaskBoard} source The taskboard\n         * @param {TaskBoard.widget.TaskEditor} editor The editor\n         */\n        if (me.owner?.trigger('beforeCancel', { editor : me }) === false) {\n            return;\n        }\n        /**\n         * Fires on the owning TaskBoard when user clicks 'Cancel', after the editor closed.\n         * @event cancel\n         * @preventable\n         * @param {TaskBoard.view.TaskBoard} source The taskboard\n         * @param {TaskBoard.widget.TaskEditor} editor The editor\n         */\n        me.owner?.trigger('cancel', { editor : me });\n\n        me.close();\n    }\n\n    onInternalKeyDown(event) {\n        const me = this;\n\n        if (me.saveAndCloseOnEnter && !me.readOnly && event.key === 'Enter') {\n            // Need to prevent this key events from being fired on whatever receives focus after the editor is hidden\n            event.preventDefault();\n\n            if (me.autoUpdateRecord) {\n                if (me.isValid) {\n                    // Blur to get a change event before closing, to be sure record is up to date\n                    event.target.blur();\n                    me.close();\n                }\n            }\n            else {\n                me.onSaveClick();\n            }\n        }\n\n        super.onInternalKeyDown(event);\n    }\n}\n\nTaskEditor.initClass();\n", "import Widget from '../../Core/widget/Widget.js';\nimport BrowserHelper from '../../Core/helper/BrowserHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport TaskBoardFeature from './TaskBoardFeature.js';\nimport Scroller from '../../Core/helper/util/Scroller.js';\nimport '../widget/TaskEditor.js';\n// Ensure SlideToggle is present so that type : 'checkbox' can be switched out on mobile\nimport '../../Core/widget/SlideToggle.js';\n\n/**\n * @module TaskBoard/feature/TaskEdit\n */\n\n/**\n * This features allows the user to edit tasks in a popup editor that can either be shown centered on screen (the\n * default, double click a task to show the editor):\n *\n * {@inlineexample TaskBoard/feature/TaskEdit.js}\n *\n * Or anchored to a task:\n *\n * {@inlineexample TaskBoard/feature/TaskEditAnchored.js}\n *\n * ## Default items\n *\n * By default it displays the following items:\n *\n * | Ref           | Type                                                   | Weight | Comment                                                                   |\n * |---------------|--------------------------------------------------------|--------|---------------------------------------------------------------------------|\n * | `name`        | {@link Core.widget.TextField text}                     | 100    | Task {@link TaskBoard.model.TaskModel#field-name}                         |\n * | `description` | {@link Core.widget.TextAreaField textarea}             | 200    | Task {@link TaskBoard.model.TaskModel#field-description}                  |\n * | `resources`*  | {@link TaskBoard.widget.ResourcesCombo resourcescombo} | 300    | Assigned resources                                                        |\n * | `color`       | {@link TaskBoard.widget.TaskColorCombo taskcolorcombo} | 400    | Task {@link TaskBoard.model.TaskModel#field-eventColor}                   |\n * | `column`      | {@link TaskBoard.widget.ColumnCombo columncombo}       | 500    | Bound to configured {@link TaskBoard.view.TaskBoard#config-columnField}   |\n * | `swimlane`*   | {@link TaskBoard.widget.SwimlaneCombo swimlanecombo}   | 600    | Bound to configured {@link TaskBoard.view.TaskBoard#config-swimlaneField} |\n * <sup>*</sup> Only shown when using resources / swimlanes respectively\n *\n * You can modify or remove the default items and add new custom items to the editor either at config time by using the\n * {@link #config-items items config} or at runtime by using the {@link #config-processItems processItems config}.\n *\n * ## Customize when configuring\n *\n * The {@link #config-items items config} accepts an object keyed by item ref (as listed in the table above). This\n * object will be merged with default items and the end result will determine which items are shown and how they are\n * configured.\n *\n * ### To remove a default item\n *\n * Set a ref to `null` to remove the item from the editor:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *    features : {\n *        taskEdit : {\n *            items : {\n *                // Remove the color field\n *                color : null\n *            }\n *        }\n *    }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/feature/TaskEditRemove.js}\n *\n * ### To modify a default item\n *\n * Supply an object with the configs you want to change for a ref to modify the corresponding field:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *    features : {\n *        taskEdit : {\n *            items : {\n *                // Change label of the description field and move it to the bottom\n *                description : {\n *                    label : 'Comment',\n *                    weight : 700\n *                }\n *            }\n *        }\n *    }\n * });\n * ```\n *\n *  {@inlineexample TaskBoard/feature/TaskEditModify.js}\n *\n * ### To add a custom item\n *\n * Supply a config object for the new item, using a ref that is not used by any default item:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *    features : {\n *        taskEdit : {\n *            items : {\n *                // Change label of the description field and move it to the bottom\n *                deadline : {\n *                    type   : 'date',\n *                    label  : 'Deadline',\n *                    weight : 300,\n *                    name   : 'deadline' // Bound field. If it matches the ref (key) for the field, it can be left out\n *                }\n *            }\n *        }\n *    }\n * });\n * ```\n *\n *  {@inlineexample TaskBoard/feature/TaskEditAdd.js}\n *\n * ## Customize at runtime\n *\n * By supplying a function to {@link #config-processItems} you gain runtime control over which items are shown and how\n * they are configured:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *    features : {\n *        taskEdit : {\n *            processItems({ taskRecord, items }) {\n *                // Hide description for tasks that are done\n *                if (taskRecord.status === 'done') {\n *                    items.description = null;\n *                }\n *\n *                // Modify the label for the name field\n *                items.name.label = 'Title';\n *\n *                // Add a custom item for high prio tasks\n *                if (taskRecord.prio === 'high') {\n *                    items.severity = { type : 'number', name : 'severity', label : 'Severity' }\n *                }\n *            }\n *        }\n *    }\n * });\n * ```\n *\n * You can also use `processItems` to prevent the editor from being shown for certain tasks, by returning `false` from\n * the function.\n *\n * {@inlineexample TaskBoard/feature/TaskEditProcessItems.js}\n *\n * ## Customizing other aspects of the editor\n *\n * By supplying an {@link #config-editorConfig} you can customize other aspects of the editor, such as its size, how\n * it is anchored, its title etc.\n *\n * {@inlineexample TaskBoard/feature/TaskEditEditorConfig.js}\n *\n * This feature is **enabled** by default.\n *\n * @extends TaskBoard/feature/TaskBoardFeature\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype taskEdit\n * @feature\n */\nexport default class TaskEdit extends TaskBoardFeature {\n    static $name = 'TaskEdit';\n\n    static type = 'taskEdit';\n\n    static configurable = {\n        /**\n         * Type of widget to use as the editor. Should point to a subclass of {@link TaskBoard.widget.TaskEditor} or\n         * a widget mimicking its API.\n         * @config {String}\n         * @default\n         * @category Customization\n         */\n        editorType : 'taskboardtaskeditor',\n\n        /**\n         * Config object merged with the default configuration of the editor (by default a\n         * {@link TaskBoard.widget.TaskEditor}).\n         *\n         * Can be used to configure any aspect of the editor:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     features : {\n         *         taskEdit : {\n         *             editorConfig : {\n         *                 modal    : false,\n         *                 centered : false\n         *             }\n         *         }\n         *     }\n         * });\n         * ```\n         * To customize the items in the editor, using {@link #config-items} is preferable.\n         * @config {TaskEditorConfig}\n         * @category Customization\n         */\n        editorConfig : {},\n\n        /**\n         * Items definition passed on to the configured editor (by default a {@link TaskBoard.widget.TaskEditor}).\n         *\n         * Can be used to add new items or modify and remove predefined items. To remove, supply `null` as the value.\n         *\n         * @config {Object<String,ContainerItemConfig|Boolean|null>}\n         * @category Customization\n         */\n        items : {},\n\n        /**\n         * A function called before displaying the editor that allows manipulation of its items.\n         * Returning `false` from this function prevents the editor from being shown.\n         *\n         * ```javascript\n         * features         : {\n         *    taskEdit : {\n         *         processItems({ items, taskRecord, columnRecord, swimlaneRecord }) {\n         *             // Manipulate existing items here as needed\n         *             items.name.label = taskRecord.type === 'task' ? 'Task' : 'Issue';\n         *\n         *            // Remove column field when editing tasks that are done\n         *            if (columnRecord.id === 'done') {\n         *                items.column = false\n         *            }\n         *         }\n         *     }\n         * },\n         * ```\n         *\n         * @param {Object} context An object with information about the editor being shown\n         * @param {Object<String,ContainerItemConfig>} context.items An object containing the editor item configs keyed by ref\n         * @param {TaskBoard.model.TaskModel} context.taskRecord Record representing task being edited\n         * @param {TaskBoard.model.ColumnModel} context.columnRecord Record representing tasks column\n         * @param {TaskBoard.model.SwimlaneModel} context.swimlaneRecord Record representing tasks swimlane\n         * @config {Function}\n         * @preventable\n         */\n        processItems : null\n\n        // /**\n        //  * The event that shall trigger showing the editor. Defaults to `eventdblclick`, set to `` or null to disable editing of existing events.\n        //  * @config {String}\n        //  * @default\n        //  * @category Editor\n        //  */\n        // triggerEvent : 'eventdblclick',\n\n        // /**\n        //  * Specify `true` to put the editor in read only mode.\n        //  * @config {Boolean}\n        //  * @default false\n        //  */\n        // readOnly : null,\n    };\n\n    editor = null;\n\n    static pluginConfig = {\n        assign : ['editTask'],\n        chain  : ['onActivateTask', 'populateTaskMenu']\n    };\n\n    doDestroy() {\n        this.editor?.destroy();\n    }\n\n    //region Type assertions\n\n    changeEditorConfig(editorConfig) {\n        ObjectHelper.assertObject(editorConfig, 'features.taskEdit.editorConfig');\n\n        return editorConfig;\n    }\n\n    changeEditorType(editorType) {\n        ObjectHelper.assertString(editorType, 'features.taskEdit.editorType');\n\n        return editorType;\n    }\n\n    changeItems(items) {\n        ObjectHelper.assertObject(items, 'features.taskEdit.items');\n\n        return items;\n    }\n\n    changeProcessItems(processItems) {\n        ObjectHelper.assertFunction(processItems, 'features.taskEdit.processItems');\n\n        return processItems;\n    }\n\n    //endregion\n\n    /**\n     * Edit the supplied task in the task editor.\n     *\n     * ```javascript\n     * taskBoard.editTask(taskStore.first);\n     * ```\n     *\n     * @param {TaskBoard.model.TaskModel} taskRecord Task to edit\n     * @param {HTMLElement} [element] Optionally an element to align to, by default it tries to resolve one from the\n     * supplied task when the editor is configured to not be centered.\n     * @on-owner\n     * @category Common\n     */\n    async editTask(taskRecord, element = null) {\n        const\n            me             = this,\n            { client }     = me,\n            columnRecord   = client.getColumn(taskRecord),\n            swimlaneRecord = client.swimlaneField && client.swimlanes?.getById(taskRecord.getValue(client.swimlaneField));\n\n        if (me.disabled) {\n            return;\n        }\n\n        /**\n         * Fires on the owning TaskBoard before a task is displayed in an editor.\n         *\n         * Returning `false` or a promise that resolves to `false` stops the default editing UI from being shown.\n         *\n         * ```javascript\n         * taskBoard.on({\n         *     beforeTaskEdit({ taskRecord }) {\n         *         return await userCanEdit(taskRecord);\n         *     }\n         * }\n         * ```\n         *\n         * @event beforeTaskEdit\n         * @param {TaskBoard.view.TaskBoard} source The owning TaskBoard\n         * @param {TaskBoard.model.TaskModel} taskRecord The record about to be shown in the task editor\n         * @on-owner\n         * @preventable\n         * @async\n         */\n        if (await client.trigger('beforeTaskEdit', { taskRecord }) === false) {\n            return;\n        }\n\n        if (me.isEditing) {\n            me.cancelEdit();\n        }\n\n        // <remove-on-release>\n        // TODO: Ask Don about combinedItems\n        // </remove-on-release>\n        const\n            editorClass   = Widget.resolveType(me.editorType),\n            // Combine items defined on the feature with those defined on the editor\n            combinedItems = editorClass.mergeConfigs(editorClass.$meta.config.items, me.items),\n            // Allow user supplied fn to process the items, returning false will abort edit\n            processResult = me.processItems?.({ items : combinedItems, taskRecord, columnRecord, swimlaneRecord });\n\n        if (processResult === false) {\n            return;\n        }\n\n        const editor = me.editor = editorClass.new({\n            items    : combinedItems,\n            owner    : client,\n            readOnly : taskRecord.readOnly\n        }, me.editorConfig);\n\n        /**\n         * Fires on the owning TaskBoard when the editor for a task is available, but before it is populated with data\n         * and shown. Allows manipulating fields etc.\n         *\n         * ```javascript\n         * taskBoard.on({\n         *     beforeTaskEditShow({ taskRecord, editor }) {\n         *         editor.title = `Editing \"${taskRecord.name}\"`;\n         *     }\n         * }\n         * ```\n         *\n         * @event beforeTaskEditShow\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source The owning TaskBoard\n         * @param {TaskBoard.model.TaskModel} taskRecord The record about to be shown in the task editor\n         * @param {TaskBoard.widget.TaskEditor} editor The editor\n         */\n        client.trigger('beforeTaskEditShow', { taskRecord, editor });\n\n        editor.record = taskRecord;\n\n        if (editor.centered || !BrowserHelper.isHoverableDevice) {\n            editor.show();\n        }\n        else {\n            Scroller.scrollIntoView(element ?? client.getTaskElement(taskRecord));\n            editor.showBy(element ?? client.getTaskElement(taskRecord));\n        }\n\n        editor.isVisible && editor.ion({\n            hide    : me.onEditorHide,\n            thisObj : me\n        });\n    }\n\n    cancelEdit() {\n\n    }\n\n    onActivateTask({ taskRecord, event }) {\n        if (!event.defaultPrevented) {\n            this.editTask(taskRecord);\n        }\n    }\n\n    populateTaskMenu({ items, taskRecord }) {\n        if (!this.client.readOnly && !this.disabled) {\n            items.editTask = {\n                text     : 'L{TaskBoard.editTask}',\n                icon     : 'b-fw-icon b-icon-edit',\n                weight   : 100,\n                onItem   : () => this.editTask(taskRecord),\n                disabled : taskRecord.readOnly\n            };\n        }\n    }\n\n    onEditorHide() {\n        this.client.getTaskElement(this.editor.record)?.focus();\n    }\n}\n\nTaskEdit.initClass();\n", "import TaskBoardFeature from './TaskBoardFeature.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport ContextMenuBase from '../../Core/feature/base/ContextMenuBase.js';\nimport AvatarRendering from '../../Core/widget/util/AvatarRendering.js';\n\n/**\n * @module TaskBoard/feature/TaskMenu\n */\n\n/**\n * Displays a context menu for tasks. Items are populated by other features and/or application code.\n *\n * {@inlineexample TaskBoard/feature/TaskMenu.js}\n *\n * You can optionally also use a {@link TaskBoard/view/item/TaskMenuItem} button to display the menu.\n *\n * ## Default items\n *\n * These are the default items provided by TaskBoard features:\n *\n * | Reference    | Weight | Feature                            | Description                                      |\n * |--------------|--------|------------------------------------|--------------------------------------------------|\n * | `editTask`   | 100    | {@link TaskBoard.feature.TaskEdit} | Open task editor. Hidden when read-only          |\n * | `resources`  | 200    | *This feature*                     | Assign/unassign resources. Hidden when read-only |\n * | `column`     | 300    | *This feature*                     | Move to column. Hidden when read-only            |\n * | `swimlane`   | 400    | *This feature*                     | Move to swimlane. Hidden when read-only          |\n * | `removeTask` | 500    | *This feature*                     | Remove task. Hidden when read-only               |\n *\n * Default items in the menu can be changed or removed and new items can be added. This is handled using the\n * {@link #config-items} config of the feature.\n *\n * ## Add items\n *\n * Add menu items for all tasks by adding a key (used as menu item {@link Core/widget/Widget#config-ref}) with a\n * {@link Core/widget/MenuItem#configs config object for a menu item} as the value to the {@link #config-items} config:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     features : {\n *         taskMenu : {\n *             items : {\n *                 flagTask : {\n *                     text : 'Flag task',\n *                     icon : 'b-fa-fw b-fa-flag',\n *                     onItem({ taskRecord }) {\n *                         taskRecord.flagged = true;\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/feature/TaskMenuAdd.js}\n *\n * ## Remove items\n *\n * To remove default items, configure them as `null` in the {@link #config-items} config:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     features : {\n *         taskMenu : {\n *             items : {\n *                 removeTask : null,\n *                 resources : null\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/feature/TaskMenuRemove.js}\n *\n * ## Customize items\n *\n * To customize default items, supply a new config object for them in the {@link #config-items} config. It will merge\n * with the default config object:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     features : {\n *         taskMenu : {\n *             items : {\n *                 removeTask : {\n *                     text : 'Delete card'\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/feature/TaskMenuCustomize.js}\n *\n * ## Manipulating items at runtime\n *\n * Manipulate items for all tasks or specific tasks at runtime by supplying a {@link #config-processItems} function:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     features : {\n *         taskMenu : {\n *             // Process items before menu is shown\n *             processItems({ taskRecord, items }) {\n *                  // Push an extra item for done tasks\n *                  if (taskRecord.status === 'done') {\n *                      items.archive = {\n *                          text : 'Archive',\n *                          icon : 'b-fa-fw b-fa-archive'\n *                          onItem({ taskRecord }) {\n *                              taskRecord.archived = true;\n *                          }\n *                      };\n *                  }\n *\n *                  // Do not show menu for low prio tasks\n *                  if (taskRecord.prio === 'low') {\n *                      return false;\n *                  }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/feature/TaskMenuProcessItems.js}\n *\n * This feature is **enabled** by default.\n *\n * ## Keyboard shortcuts\n * This feature has the following default keyboard shortcuts:\n *\n * | Keys           | Action                 | Action description                               |\n * |----------------|------------------------|--------------------------------------------------|\n * | `Space`        | *showContextMenuByKey* | Shows context menu for currently focused task    |\n * | `Ctrl`+`Space` | *showContextMenuByKey* | Shows context menu for currently focused task    |\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#TaskBoard/guides/customization/keymap.md).\n *\n * @extends TaskBoard/feature/TaskBoardFeature\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype taskMenu\n * @feature\n */\nexport default class TaskMenu extends ContextMenuBase {\n\n    static $name = 'TaskMenu';\n\n    static type = 'taskMenu';\n\n    static configurable = {\n        /**\n         * A function called before displaying the menu that allows manipulations of its items.\n         * Returning `false` from this function prevents the menu from being shown.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *   features         : {\n         *       taskMenu : {\n         *           processItems({ taskRecord, items }) {\n         *              // Add a custom menu item for tasks with progress greater than 90\n         *              if (taskRecord.progress > 90) {\n         *                  items.close = {\n         *                      text : 'Close',\n         *                      icon : 'b-fa-fw b-fa-check',\n         *                      onItem({ taskRecord }) {\n         *                          taskRecord.done = true;\n         *                      }\n         *                  }\n         *              }\n         *           }\n         *       }\n         *   }\n         * });\n         * ```\n         *\n         * @param {Object} context An object with information about the menu being shown\n         * @param {TaskBoard.model.TaskModel} context.taskRecord The task for which the menu will be shown\n         * @param {Object<string,MenuItemConfig>} context.items An object containing the\n         * {@link Core.widget.MenuItem menu item} configs keyed by their id\n         * @param {Event} context.event The DOM event object that triggered the show\n         * @config {Function}\n         * @preventable\n         */\n        processItems : null,\n\n        /**\n         * This is a preconfigured set of items used to create the default context menu.\n         *\n         * The `items` provided by this feature are listed in the intro section of this class. You can configure\n         * existing items by passing a configuration object to the keyed items.\n         *\n         * To remove existing items, set corresponding keys to `null`:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     features : {\n         *         taskMenu : {\n         *             items : {\n         *                 editTask : null\n         *             }\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * See the feature config in the above example for details.\n         *\n         * @config {Object<string,MenuItemConfig|Boolean|null>} items\n         */\n        items : null,\n\n        type : 'task',\n\n        /**\n         * The mouse / touch gesture which should show this context menu (e.g. 'taskClick' or 'taskContextMenu').\n         * Set to `false` to never trigger it from UI.\n         * @default\n         * @config {String|Boolean}\n         */\n        triggerEvent : 'taskContextMenu',\n\n        /**\n         * Show avatars/initials in the resource picker menu\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     features : {\n         *         taskMenu : {\n         *             showAvatars : false\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * @config {Boolean}\n         * @default true\n         */\n        showAvatars : {\n            value   : true,\n            $config : 'nullify'\n        },\n\n        menu : {\n            align  : 't90-b90',\n            anchor : true\n        }\n\n        /**\n         * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n         * @config {Object<string,string>} keyMap\n         */\n\n        /**\n         * @hideconfigs type\n         */\n    };\n\n    static get pluginConfig() {\n        const config = super.pluginConfig;\n\n        config.chain.push('populateTaskMenu');\n\n        return config;\n    }\n\n    //region Type assertions\n\n    changeItems(items) {\n        ObjectHelper.assertObject(items, 'features.taskMenu.items');\n\n        return items;\n    }\n\n    changeProcessItems(processItems) {\n        ObjectHelper.assertFunction(processItems, 'features.taskMenu.processItems');\n\n        return processItems;\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * This event fires on the owning TaskBoard before the context menu is shown for a task.\n     * Allows manipulation of the items to show in the same way as in the {@link #config-processItems}.\n     *\n     * Returning `false` from a listener prevents the menu from being shown.\n     *\n     * @event taskMenuBeforeShow\n     * @on-owner\n     * @preventable\n     * @param {TaskBoard.view.TaskBoard} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Object<string,MenuItemConfig>} items Menu item configs\n     * @param {TaskBoard.model.TaskModel} taskRecord The task\n     * @on-owner\n     */\n\n    /**\n     * This event fires on the owning TaskBoard after the context menu is shown for a task.\n     * @event taskMenuShow\n     * @on-owner\n     * @param {TaskBoard.view.TaskBoard} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Object<string,MenuItemConfig>} items Menu item configs\n     * @param {TaskBoard.model.TaskModel} taskRecord The task\n     * @on-owner\n     */\n\n    /**\n     * This event fires on the owning TaskBoard when an item is selected in the task context menu.\n     * @event taskMenuItem\n     * @on-owner\n     * @param {TaskBoard.view.TaskBoard} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Core.widget.MenuItem} item Selected menu item\n     * @param {TaskBoard.model.TaskModel} taskRecord The task\n     * @on-owner\n     */\n\n    /**\n     * This event fires on the owning TaskBoard when a check item is toggled in the task context menu.\n     * @event taskMenuToggleItem\n     * @on-owner\n     * @param {TaskBoard.view.TaskBoard} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Core.widget.MenuItem} item Selected menu item\n     * @param {TaskBoard.model.TaskModel} taskRecord The task\n     * @param {Boolean} checked Checked or not\n     * @on-owner\n     */\n\n    //endregion\n\n    updateTriggerEvent(triggerEvent) {\n        this.detachListeners('triggerEvent');\n        if (triggerEvent) {\n            this.client.ion({\n                name           : 'triggerEvent',\n                [triggerEvent] : 'onTriggerEvent',\n                thisObj        : this\n            });\n        }\n    }\n\n    doDisable(disable) {\n        super.doDisable(disable);\n\n        !this.isConfiguring && this.client.recompose();\n    }\n\n    onTriggerEvent({ event }) {\n        this.internalShowContextMenu(event);\n    }\n\n    /**\n     * Show the context menu for a specific task, aligned to its card. Optionally aligned to an element in the card, using the supplied CSS selector.\n     *\n     * @param {TaskBoard.model.TaskModel} taskRecord Task to show the menu for\n     * @param {String} [selector] CSS selector, to align to a specific element in the task's card\n     */\n    showMenuFor(taskRecord, selector = '.b-taskboard-task-menu') {\n        const\n            targetElement = this.client.getTaskElement(taskRecord),\n            buttonElement = targetElement.querySelector(selector),\n            eventParams   = { taskRecord, columnRecord : this.client.getColumn(taskRecord), targetElement };\n\n        let alignSpec = null;\n\n        // <remove-on-release>\n        // TODO: Call something on the button instead?\n        // </remove-on-release>\n        if (buttonElement) {\n            eventParams.targetElement = buttonElement;\n            alignSpec = {\n                target : buttonElement\n            };\n        }\n\n        this.showContextMenu(eventParams, alignSpec);\n    }\n\n    showContextMenu(eventParams, ...args) {\n        if (!this.client.isSelected(eventParams.taskRecord)) {\n            this.client.selectTask(eventParams.taskRecord);\n        }\n\n        super.showContextMenu(eventParams, ...args);\n    }\n\n    getDataFromEvent(event) {\n        return ObjectHelper.assign(super.getDataFromEvent(event), event.taskBoardData);\n    }\n\n    populateTaskMenu({ items, taskRecord }) {\n        const { client, disabled } = this;\n\n        if (!client.readOnly && !disabled) {\n            const\n                { columnField, swimlaneField, selectedTasks } = client,\n                { resourceStore, eventStore }                 = client.project,\n                isSelected                                    = selectedTasks.includes(taskRecord);\n\n            items.column = {\n                text     : `L{TaskBoard.changeColumn} ${columnField}`,\n                icon     : 'b-fw-icon b-icon-move-left-right',\n                weight   : 300,\n                disabled : taskRecord.readOnly,\n                menu     : client.columns.map(col => ({\n                    ref         : col.id,\n                    text        : StringHelper.encodeHtml(col.text),\n                    cls         : 'b-column-menu-item',\n                    isColumn    : true,\n                    checked     : taskRecord.getValue(columnField) === col.id,\n                    // Close menu when task is moved to a new column, looks weird to keep it open\n                    closeParent : true\n                })),\n                onItem({ item }) {\n                    if (item.isColumn) {\n                        taskRecord.setValue(columnField, item.ref);\n\n                        item.parent.items.forEach(sibling => {\n                            if (sibling !== item) {\n                                sibling.checked = false;\n                            }\n                        });\n                    }\n                }\n            };\n\n            if (client.swimlanes?.count && swimlaneField) {\n                items.swimlane = {\n                    text     : StringHelper.xss`L{TaskBoard.changeSwimlane} ${swimlaneField}`,\n                    icon     : 'b-fw-icon b-icon-move-up-down',\n                    weight   : 400,\n                    disabled : taskRecord.readOnly,\n                    menu     : client.swimlanes.map(lane => ({\n                        ref         : lane.id,\n                        text        : StringHelper.encodeHtml(lane.text),\n                        isSwimlane  : true,\n                        checked     : taskRecord.getValue(swimlaneField) === lane.id,\n                        // Close menu when task is moved to a new swimlane, looks weird to keep it open\n                        closeParent : true\n                    })),\n                    onItem({ item }) {\n                        if (item.isSwimlane) {\n                            taskRecord.setValue(swimlaneField, item.ref);\n\n                            item.parent.items.forEach(sibling => {\n                                if (sibling !== item) {\n                                    sibling.checked = false;\n                                }\n                            });\n                        }\n                    }\n                };\n            }\n\n            if (resourceStore.count) {\n                items.resources = {\n                    text     : 'L{TaskBoard.resources}',\n                    icon     : 'b-fw-icon b-icon-user',\n                    weight   : 200,\n                    disabled : taskRecord.readOnly,\n                    menu     : resourceStore.map(resource => {\n                        const avatar = this.avatarRendering?.getResourceAvatar({\n                            resourceRecord : resource,\n                            initials       : resource.initials,\n                            color          : resource.color,\n                            iconCls        : resource.iconCls,\n                            imageUrl       : resource.imageUrl || ((client.resourceImagePath || '') + (resource.image || ''))\n                        });\n\n                        return {\n                            ref  : resource.id,\n                            cls  : 'b-resource-menu-item',\n                            text : avatar ? {\n                                className : 'b-resource-menu-item-inner',\n                                children  : [\n                                    avatar,\n                                    StringHelper.encodeHtml(resource.name)\n                                ]\n                            } : StringHelper.encodeHtml(resource.name),\n                            resource,\n                            checked     : taskRecord.resources.includes(resource),\n                            // Only allow single pick in single assignment mode\n                            toggleGroup : eventStore.usesSingleAssignment ? 'single' : null\n                        };\n                    }\n                    ),\n                    onItem({ item }) {\n                        if (item.resource) {\n                            taskRecord[item.checked ? 'assign' : 'unassign'](item.resource);\n                        }\n                    }\n                };\n            }\n\n            items.removeTask = {\n                text     : isSelected && selectedTasks.length > 1 ? 'L{TaskBoard.removeTasks}' : 'L{TaskBoard.removeTask}',\n                icon     : 'b-fw-icon b-icon-trash',\n                cls      : 'b-separator',\n                weight   : 500,\n                disabled : taskRecord.readOnly,\n                onItem   : () => client.removeTask(isSelected ? selectedTasks : taskRecord)\n            };\n        }\n    }\n\n    get showMenu() {\n        return true;\n    }\n\n    updateShowAvatars(value) {\n        this.avatarRendering?.destroy();\n\n        if (value) {\n            this.avatarRendering = new AvatarRendering({\n                element : this.client.element\n            });\n        }\n    }\n}\n\n// Register this feature type with its Factory\nTaskBoardFeature.register(TaskMenu.type, TaskMenu);\n", "import ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\nimport TaskBoardFeature from './TaskBoardFeature.js';\n\n/**\n * @module TaskBoard/feature/TaskTooltip\n */\n\n/**\n * Displays a tooltip when hovering a task. By default the tooltip displays:\n *\n * * task name\n * * task column\n * * task swimlane (if using swimlanes)\n * * names of assigned resources (if any)\n *\n * {@inlineexample TaskBoard/feature/TaskTooltip.js}\n *\n * To customize the contents, supply your own {@link #config-template}:\n *\n * {@inlineexample TaskBoard/feature/TaskTooltipTemplate.js}\n *\n * This feature is **disabled** by default.\n *\n * @extends TaskBoard/feature/TaskBoardFeature\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype taskTooltip\n * @feature\n */\nexport default class TaskTooltip extends TaskBoardFeature {\n\n    static $name = 'TaskTooltip';\n\n    static type = 'taskTooltip';\n\n    static configurable = {\n        /**\n         * Tooltip config object used to override the defaults, see {@link Core.widget.Tooltip#configs} for available\n         * configs.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     features : {\n         *         taskTooltip : {\n         *             tooltip : {\n         *                 hoverDelay : 100,\n         *                 hideDelay  : 500\n         *             }\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * @config {TooltipConfig}\n         */\n        tooltip : {\n            value : {},\n\n            // Lazy, pulled in on render to have element available\n            $config : ['lazy', 'nullify']\n        },\n\n        /**\n         * Function used to populate the tooltip, supply your own to override the default contents of the tooltip.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     features : {\n         *         taskTooltip : {\n         *             template({ taskRecord }) {\n         *                 return `<b>${taskRecord.name}</b>`\n         *             }\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * @param {Object} tipData\n         * @param {TaskBoard.model.TaskModel} tipData.taskRecord Hovered task\n         * @param {TaskBoard.model.ColumnModel} tipData.columnRecord The task's column\n         * @param {TaskBoard.model.SwimlaneModel} tipData.swimlaneRecord The task's swimlane (if used)\n         * @returns {String|DomConfig} Return an HTML string or a DOM config object\n         * @config {Function}\n         */\n        template : null\n    };\n\n    static pluginConfig = {\n        chain : ['render']\n    };\n\n    //region Type assertions\n\n    changeTemplate(template) {\n        ObjectHelper.assertFunction(template, 'features.taskTooltip.template');\n\n        return template;\n    }\n\n    //endregion\n\n    doDisable(disable) {\n        super.doDisable(disable);\n\n        if (this._tooltip) {\n            this.tooltip.disabled = disable;\n        }\n    }\n\n    changeTooltip(tooltip, oldTooltip) {\n        const\n            me         = this,\n            { client } = me;\n\n        ObjectHelper.assertObject(tooltip, 'features.taskTooltip.tooltip');\n\n        oldTooltip?.destroy();\n\n        if (tooltip) {\n\n            return new Tooltip(ObjectHelper.assign({\n                axisLock       : 'flexible',\n                cls            : 'b-taskboard-tooltip',\n                forSelector    : '.b-taskboardbase:not(.b-draghelper-active) .b-taskboard-card',\n                scrollAction   : 'realign',\n                forElement     : client.element,\n                showOnHover    : true,\n                hoverDelay     : 0,\n                hideDelay      : 100,\n                anchorToTarget : true,\n                allowOver      : Boolean(me.config.items || me.config.tools),\n                getHtml        : me.getTipHtml.bind(me),\n                disabled       : me.disabled,\n                textContent    : false\n            }, tooltip));\n        }\n    }\n\n    getTipHtml({ tip, activeTarget }) {\n        const\n            { client }     = this,\n            taskRecord     = client.resolveTaskRecord(activeTarget),\n            columnRecord   = client.resolveColumnRecord(activeTarget),\n            swimlaneRecord = client.resolveSwimlaneRecord(activeTarget);\n\n        if (this.template) {\n            return this.template({ tip, taskRecord, columnRecord, swimlaneRecord, activeTarget });\n        }\n\n        const children = [\n            {\n                class : 'b-taskboard-tooltip-title',\n                text  : taskRecord.name\n            },\n            {\n                class : 'b-taskboard-tooltip-label',\n                text  : StringHelper.capitalize(client.columnField)\n            },\n            {\n                class : 'b-taskboard-tooltip-value',\n                text  : columnRecord.text\n            }\n        ];\n\n        if (swimlaneRecord) {\n            children.push(\n                {\n                    class : 'b-taskboard-tooltip-label',\n                    text  : StringHelper.capitalize(client.swimlaneField)\n                },\n                {\n                    class : 'b-taskboard-tooltip-value',\n                    text  : swimlaneRecord.text\n                }\n            );\n        }\n\n        if (taskRecord.resources.length) {\n            children.push(\n                {\n                    class : 'b-taskboard-tooltip-label',\n                    text  : this.L('L{TaskBoard.resources}')\n                },\n                {\n                    class : 'b-taskboard-tooltip-value',\n                    text  : taskRecord.resources.map(resourceRecord => resourceRecord.name).join(', ')\n                }\n            );\n        }\n\n        return {\n            children\n        };\n    }\n\n    render() {\n        // Element is now available, pull in tooltip to have it correctly wired up\n        this.getConfig('tooltip');\n    }\n}\n\nTaskTooltip.initClass();\n", "import Model from '../../Core/data/Model.js';\n\n/**\n * @module TaskBoard/model/ColumnModel\n */\n\n/**\n * Represents a single column on a TaskBoard.\n *\n * When creating a TaskBoard, you supply an initial set of columns. These columns are either defined as plain strings,\n * ColumnModel data objects or ColumnModel records (or a mix thereof). When using strings, the string will be used as is\n * as the column's id and capitalized as its text.\n *\n * ```javascript\n * const doneColumn = new ColumnModel({\n *     id   : 'done',\n *     text : 'Done'\n * });\n *\n * const taskBoard = new TaskBoard({\n *     columns : [\n *         // String, equal to passing { id : 'todo', text : 'Todo' }\n *         'todo',\n *         // Data object, in this case with a fixed width and not collapsible from the UI\n *         { id : 'doing', text : 'Doing', width : 200, collapsible : false }\n *         // Record, not commonly used since it is easier to supply the data object directly\n *         doneColumn\n *     ]\n * });\n * ```\n *\n * @extends Core/data/Model\n * @uninherit Core/data/mixin/TreeNode\n */\nexport default class ColumnModel extends Model {\n\n    static $name = 'ColumnModel';\n\n    static fields = [\n        /**\n         * This column's unique id, used to match a task to a column (which field on a task to match is specified using\n         * then {@link TaskBoard.view.TaskBoardBase#config-columnField} config on TaskBoard).\n         * @field {String|Number} id\n         */\n\n        /**\n         * Text displayed in the column header.\n         * @field {String} text\n         */\n        'text',\n\n        /**\n         * A tooltip string to show when hovering the column header\n         * @field {String} tooltip\n         */\n        'tooltip',\n\n        /**\n         * Color, named colors are applied as a `b-taskboard-color-{color}` (for example `b-taskboard-color-red`) CSS\n         * class to the column. Colors specified as hex, `rgb()` etc. are applied as `style.color` to the column.\n         *\n         * By default it does not visually affect the UI, but it applies a color to the column that applications can\n         * leverage using `currentColor` to style it in the desired way.\n         *\n         * Using named colors:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     columns : [\n         *         { id : 'todo', text : 'Todo', color : 'orange', tooltip : 'These are items to be done' }\n         *     ]\n         * });\n         * ```\n         *\n         * Will result in:\n         *\n         * ```html\n         * <div class=\"b-taskboard-column b-taskboard-color-orange\">\n         * ```\n         *\n         * Which can the be used for example like:\n         *\n         * ```css\n         * .b-taskboard-column-header {\n         *     border-left : 5px solid currentColor; // where currentColor is the color defined by b-taskboard-color-orange\n         * }\n         * ```\n         *\n         * Using non-named colors:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     columns : [\n         *         { id : 'todo', text : 'Todo', color : 'hsl(229deg 66% 42%)' }\n         *     ]\n         * });\n         * ```\n         *\n         * Will result in:\n         *\n         * ```html\n         * <div class=\"b-taskboard-column\" style=\"color: hsl(229deg 66% 42%)\">\n         * ```\n         *\n         * Predefined named colors (actual color might vary by theme):\n         * <div class=\"b-colorbox b-inline b-taskboard-color-red\"></div>red,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-pink\"></div>pink,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-purple\"></div>purple,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-deep-purple\"></div>deep-purple,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-indigo\"></div>indigo,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-blue\"></div>blue,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-light-blue\"></div>light-blue,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-cyan\"></div>cyan,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-teal\"></div>teal,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-green\"></div>green,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-light-green\"></div>light-green,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-lime\"></div>lime,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-yellow\"></div>yellow,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-amber\"></div>amber,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-orange\"></div>orange,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-deep-orange\"></div>deep-orange\n         *\n         * @field {String} color\n         */\n        { name : 'color', type : 'string' },\n\n        /**\n         * Number of tasks per row to display in this column. Leave blank to use the setting from the\n         * {@link TaskBoard.view.TaskBoardBase#config-tasksPerRow} config on TaskBoard.\n         * @field {Number} tasksPerRow\n         */\n        'tasksPerRow',\n\n        /**\n         * Allow collapsing this column\n         * @field {Boolean} collapsible=true\n         */\n        { name : 'collapsible', type : 'boolean', defaultValue : true },\n\n        /**\n         * Collapsed (`true`) or expanded (`false`)\n         *\n         * To expand or collapse, use {@link #function-expand} and  {@link #function-collapse} functions.\n         *\n         * @field {Boolean} collapsed\n         * @readonly\n         */\n        { name : 'collapsed', type : 'boolean' },\n\n        /**\n         * Set to `true` to hide the column, `false` to show it again.\n         * @field {Boolean} hidden\n         */\n        { name : 'hidden', type : 'boolean' },\n\n        /**\n         * Column width in px.\n         * @field {Number} width\n         */\n        { name : 'width', type : 'number' },\n\n        /**\n         * Column flex, affects width.\n         * @field {Number} flex\n         */\n        { name : 'flex', type : 'number' },\n\n        /**\n         * Column min-width in px. To override the default min-width specified in CSS.\n         * @field {Number} minWidth\n         */\n        { name : 'minWidth', type : 'number' }\n\n    ];\n\n    /**\n     * Get the tasks in this column in visual order.\n     * @property {TaskBoard.model.TaskModel[]}\n     * @readonly\n     */\n    get tasks() {\n        return this.taskBoard.getColumnTasks(this, true);\n    }\n\n    get taskBoard() {\n        return this.firstStore.taskBoard;\n    }\n\n    /**\n     * Collapse this column.\n     *\n     * Uses a transition by default, await the call to be certain that it has finished.\n     *\n     * @category Expand/collapse\n     * @returns {Promise} A promise which is resolved when the column is collapsed\n     */\n    async collapse() {\n        return this.taskBoard.collapse(this);\n    }\n\n    /**\n     * Expand this column.\n     *\n     * Uses a transition by default, await the call to be certain that it has finished.\n     *\n     * @category Expand/collapse\n     * @returns {Promise} A promise which is resolved when the column is expanded\n     */\n    async expand() {\n        return this.taskBoard.expand(this);\n    }\n}\n", "import EventModel from '../../Scheduler/model/EventModel.js';\n\n/**\n * @module TaskBoard/model/TaskModel\n */\n\n/**\n * Represents a single task on your TaskBoard, usually added to a {@link TaskBoard/store/TaskStore}.\n *\n * ## Customizing Task fields\n *\n * The TaskModel has a few predefined fields as seen under Fields below. If you want to add new fields or change\n * existing fields, you can do that by subclassing this class:\n *\n * ```javascript\n * class MyTask extends TaskModel {\n *\n *     static get fields() {\n *         return [\n *            // Add a new field\n *            { name: 'myField', type : 'number', defaultValue : 0 }\n *         ];\n *     }\n *\n *     ...\n * }\n *\n * // Instances of your class now has getters / setters defined for your field\n * const task = new MyTask();\n * console.log(task.myField); // => 0\n * ```\n *\n * If you want to use other names for any predefined field in your data, you can reconfigure them as seen below:\n *\n * ```javascript\n * class MyTask extends TaskModel {\n *\n *     static get fields() {\n *         return [\n *            // Remap status -> state\n *            { name: 'status', dataSource : 'state' }\n *         ];\n *     }\n *\n *     ...\n * }\n * ```\n *\n * ## Configuring the Project to use a custom task model\n *\n * Here's how you configure the {@link TaskBoard/model/ProjectModel Project} to use a certain Model class:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     // Configure the project to use our custom task model and to load data remotely\n *     project : {\n *         taskModelClass : MyTask,\n *\n *         autoLoad  : true\n *         transport : {\n *             load : {\n *                 url : 'data/data.json'\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * ## Read-only tasks\n *\n * A task can be flagged as read-only using the {@link #field-readOnly} field. This protects it from being edited in the\n * UI, but has no effect on the data layer.\n *\n * {@inlineexample TaskBoard/model/TaskModelReadOnly.js}\n *\n * Please refer to {@link Core/data/Model} for additional details.\n *\n * @extends Scheduler/model/EventModel\n */\nexport default class TaskModel extends EventModel {\n\n    static $name = 'TaskModel';\n\n    static fields = [\n        /**\n         * Task status, for example for linking to a column on the TaskBoard.\n         *\n         * @field {String} status\n         */\n        'status',\n\n        /**\n         * Task priority, for example for linking to a swimlane on the TaskBoard.\n         *\n         * @field {String|Number} prio\n         */\n        'prio',\n\n        /**\n         * Task description, by default shown in tasks body.\n         *\n         * @field {String} description\n         */\n        'description',\n\n        /**\n         * Color, named colors are applied as a `b-taskboard-color-{color}` (for example `b-taskboard-color-red`) CSS\n         * class to the tasks card. Colors specified as hex, `rgb()` etc. are applied as `style.color` to the card.\n         *\n         * If no color is specified, any color defined on the {@link TaskBoard/model/ColumnModel#field-color column} or\n         * {@link TaskBoard/model/SwimlaneModel#field-color swimlane} will apply instead.\n         *\n         * By default it does not visually affect the UI, but it applies a color to the task that applications can\n         * leverage using `currentColor` to style it in the desired way.\n         *\n         * Using named colors:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     project {\n         *         tasksData : [\n         *             { id : 1, name : 'Important task', eventColor : 'red' }\n         *         ]\n         *     }\n         * });\n         * ```\n         *\n         * Will result in:\n         *\n         * ```html\n         * <div class=\"b-taskboard-card b-taskboard-color-red\">\n         * ```\n         *\n         * Which can the be used for example like:\n         *\n         * ```css\n         * .b-taskboard-card {\n         *     // currentColor is the color defined by b-red\n         *     border-left : 5px solid currentColor;\n         * }\n         * ```\n         *\n         * Using non-named colors:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     project {\n         *         tasksData : [\n         *             { id : 1, name : 'Important task', eventColor : '#ff0000' }\n         *         ]\n         *     }\n         * });\n         * ```\n         *\n         * Will result in:\n         *\n         * ```html\n         * <div class=\"b-taskboard-card\" style=\"color: #ff0000\">\n         * ```\n         *\n         * Predefined named colors (actual color might vary by theme):\n         * <div class=\"b-colorbox b-inline b-taskboard-color-red\"></div>red,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-pink\"></div>pink,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-purple\"></div>purple,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-deep-purple\"></div>deep-purple,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-indigo\"></div>indigo,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-blue\"></div>blue,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-light-blue\"></div>light-blue,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-cyan\"></div>cyan,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-teal\"></div>teal,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-green\"></div>green,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-light-green\"></div>light-green,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-lime\"></div>lime,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-yellow\"></div>yellow,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-amber\"></div>amber,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-orange\"></div>orange,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-deep-orange\"></div>deep-orange,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-gray\"></div>gray,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-light-gray\"></div>light-gray\n         *\n         * @field {'red'|'pink'|'purple'|'deep-purple'|'indigo'|'blue'|'light-blue'|'cyan'|'teal'|'green'|'light-green'|'lime'|'yellow'|'amber'|'orange'|'deep-orange'|'gray'|'light-gray'|String|null} eventColor\n         */\n        'eventColor',\n\n        /**\n         * Task weight, used by default to determine its index in a column. Higher weights are displayed further down.\n         *\n         * The weight is applied as a default sorter to the {@link TaskBoard/store/TaskStore}.\n         *\n         * When no weights are defined, task order is determined by store order.\n         *\n         * @field {Number} weight\n         */\n        { name : 'weight', type : 'number' },\n\n        /**\n         * Set to `true` to make the task read-only, preventing it from being edited in the UI.\n         *\n         * See the class description above for a live demo.\n         *\n         * @field {Boolean} readOnly\n         */\n        { name : 'readOnly', type : 'boolean' }\n    ];\n}\n", "import EventStore from '../../Scheduler/data/EventStore.js';\nimport TaskModel from '../model/TaskModel.js';\n\n/**\n * @module TaskBoard/data/TaskStore\n */\n\n/**\n * Store that holds the tasks of a TaskBoard. By default configured to use {@link TaskBoard.model.TaskModel} for its\n * records.\n *\n * Loaded and handled as a part of a {@link TaskBoard.model.ProjectModel project}. For example using inline data:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     project : {\n *         // Data to load into the TaskStore\n *         tasksData : [\n *             { id : 1, name : 'Some task', status : 'todo', prio : 'low' }\n *         ]\n *     }\n * }\n * ```\n *\n * When loaded using the {@link Scheduler.data.mixin.ProjectCrudManager CrudManager} functionality of the project, it\n * is populated from the `'tasks'` property in the\n * response:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     project : {\n *         transport : {\n *             load : {\n *                 url : 'load.php'\n *             }\n *         },\n *\n *         autoLoad : true\n *     }\n * }\n * ```\n *\n * Expected response format to populate the TaskStore:\n *\n * ```json\n * {\n *     \"success\"     : true,\n *     \"tasks\"       : {\n *         \"rows\" : [\n *             {\n *                 \"id\"     : 1,\n *                 \"name\"   : \"Important task\",\n *                 \"status\" : \"todo\",\n *                 \"prio\"   : \"high\"\n *             },\n *             ...\n *         ]\n *     }\n * }\n * ```\n *\n * @extends Scheduler/data/EventStore\n */\nexport default class TaskStore extends EventStore {\n    static configurable = {\n\n        autoAssignWeight : true,\n\n        storeId : 'tasks',\n\n        /**\n         * Class used to represent records, defaults to {@link TaskBoard.model.TaskModel}\n         * @config {TaskBoard.model.TaskModel}\n         * @typings {typeof TaskModel}\n         * @category Common\n         */\n        modelClass : TaskModel,\n\n        /**\n         * Configure with `true` to also remove the event when removing the last assignment from the linked\n         * AssignmentStore.\n         *\n         * Defaults to `false` for TaskBoard since it is unexpected that a tasks disappears when unassigning the last\n         * resource from it.\n         *\n         * @config {Boolean}\n         * @default\n         * @category Common\n         */\n        removeUnassignedEvent : false,\n\n        /**\n         * Initial sorters, format is `[{ field: 'name', ascending: false }, ...]`.\n         *\n         * By default the TaskStore is sorted by `weight`, tasks with higher weights are displayed further down.\n         *\n         * @config {Sorter[]|String[]}\n         * @category Common\n         */\n        sorters : [\n            { field : 'weight', ascending : true }\n        ]\n    };\n\n    afterLoadData() {\n        const { records } = this;\n\n        if (this.autoAssignWeight && !records.some(r => r.weight != null)) {\n            for (let i = 0; i < records.length; i++) {\n                records[i].setData('weight', (i + 1) * 100);\n            }\n        }\n    }\n}\n", "import SchedulerProjectModel from '../../Scheduler/model/ProjectModel.js';\nimport ProjectCrudManager from '../../Scheduler/data/mixin/ProjectCrudManager.js';\nimport TaskStore from '../store/TaskStore.js';\nimport TaskModel from './TaskModel.js';\n\n/**\n * @module TaskBoard/model/ProjectModel\n */\n\n/**\n * This class represents a global project of your TaskBoard - a central place for all data.\n *\n * It holds and links the stores usually used by TaskBoard:\n *\n * - {@link TaskBoard.store.TaskStore}\n * - {@link Scheduler.data.ResourceStore}\n * - {@link Scheduler.data.AssignmentStore}\n *\n * ## Loading remote data\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     project : {\n *         // Project configuration\n *     }\n * });\n * ```\n *\n * ## Loading inline data\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     project : {\n *         // Project configuration\n *     }\n * });\n * ```\n *\n * ## Getting modifications\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     project : {\n *         // Project configuration\n *     }\n * });\n * ```\n *\n * ## Built in StateTrackingManager\n *\n * The project also has a built in {@link Core.data.stm.StateTrackingManager StateTrackingManager} (STM for short), that\n * handles undo/redo for the project stores (additional stores can also be added). You can enable it to track all\n * project store changes:\n *\n * ```javascript\n * // Turn on auto recording when you create your TaskBoard:\n * const taskBoard = new TaskBoard({\n *     project : {\n *         stm : {\n *             autoRecord : true\n *         }\n *     }\n * });\n *\n * // Undo a transaction\n * project.stm.undo();\n *\n * // Redo\n * project.stm.redo();\n * ```\n *\n * @extends Scheduler/model/ProjectModel\n * @mixes Scheduler/data/mixin/ProjectCrudManager\n *\n * @typings Scheduler.model.ProjectModel -> Scheduler.model.SchedulerProjectModel\n */\nexport default class ProjectModel extends SchedulerProjectModel.mixin(ProjectCrudManager) {\n\n    static configurable = {\n        /**\n         * Get/set {@link #property-taskStore} data.\n         *\n         * Always returns an array of {@link TaskBoard.model.TaskModel} but also accepts an array of\n         * its configuration objects as input.\n         *\n         * @member {TaskBoard.model.TaskModel[]} tasks\n         * @accepts {TaskBoard.model.TaskModel[]|TaskModelConfig[]}\n         * @category Inline data\n         */\n\n        /**\n         * The initial data, to fill the {@link #property-taskStore} with. Should be an array of\n         * {@link TaskBoard.model.TaskModel} or its configuration objects.\n         *\n         * @config {TaskBoard.model.TaskModel[]|TaskModelConfig[]} tasks\n         * @category Inline data\n         */\n\n        /**\n         * The initial data, to fill the {@link #property-taskStore} with.\n         * Should be an array of {@link TaskBoard.model.TaskModel} instances or its configuration objects.\n         *\n         * @config {TaskBoard.model.TaskModel[]|TaskModelConfig[]} tasksData\n         * @category Legacy inline data\n         */\n\n        /**\n         * The {@link TaskBoard.store.TaskStore store} holding the tasks information.\n         *\n         * See also {@link TaskBoard.model.TaskModel}\n         *\n         * @member {TaskBoard.store.TaskStore} taskStore\n         * @category Models & Stores\n         */\n\n        /**\n         * An {@link TaskBoard.store.TaskStore} instance or a config object.\n         * @config {TaskStoreConfig|TaskBoard.store.TaskStore} taskStore\n         * @category Models & Stores\n         */\n\n        /**\n         * @hideconfigs timeRanges\n         *              timeRangeStore,\n         *              timeRangesData,\n         *              timeRangeStoreClass,\n         *              resourceTimeRanges,\n         *              resourceTimeRangeStore,\n         *              resourceTimeRangesData,\n         *              resourceTimeRangeStoreClass,\n         *              eventStoreClass,\n         *              eventModelClass\n         */\n\n        /**\n         * @hideproperties timeRangeStore,\n         *                 resourceTimeRangeStore\n         */\n\n        eventStoreClass : TaskStore,\n        eventModelClass : TaskModel,\n\n        /**\n         * The constructor to create a task store instance with.\n         * Should be a class, subclassing the {@link TaskBoard.store.TaskStore}.\n         * @config {TaskBoard.store.TaskStore}\n         * @typings {typeof TaskStore}\n         * @category Models & Stores\n         */\n        taskStoreClass : TaskStore,\n\n        /**\n         * The constructor of the task model class, to be used in the project.\n         * Will be set as the {@link Core.data.Store#config-modelClass modelClass}\n         * property of the {@link #property-taskStore}.\n         * @config {TaskBoard.model.TaskModel}\n         * @typings {typeof TaskModel}\n         * @category Models & Stores\n         */\n        taskModelClass : TaskModel\n    };\n\n    construct(config) {\n        if (config.tasks) {\n            config.eventsData = config.tasks;\n        }\n\n        if (config.tasksData) {\n            config.eventsData = config.tasksData;\n        }\n\n        if (config.taskStore) {\n            config.eventStore = config.taskStore;\n        }\n\n        if (config.taskModelClass) {\n            config.eventModelClass = config.taskModelClass;\n        }\n\n        if (config.taskStoreClass) {\n            config.eventStoreClass = config.taskStoreClass;\n        }\n\n        super.construct(config);\n\n        const me = this;\n\n        me.addPrioritizedStore(me.assignmentStore);\n        me.addPrioritizedStore(me.resourceStore);\n        me.addPrioritizedStore(me.taskStore);\n    }\n\n    get taskStore() {\n        return this.eventStore;\n    }\n\n    set taskStore(store) {\n        this.eventStore = store;\n    }\n\n    get tasksData() {\n        return this.eventsData;\n    }\n\n    set tasksData(data) {\n        this.eventsData = data;\n    }\n\n    get tasks() {\n        return this.eventsData;\n    }\n\n    set tasks(data) {\n        this.eventsData = data;\n    }\n\n    /**\n     * Returns the data from the records of the projects stores, in a format that can be consumed by `loadInlineData()`.\n     *\n     * Used by JSON.stringify to correctly convert this project to json.\n     *\n     * ```javascript\n     * const project = new ProjectModel({\n     *     tasksData       : [...],\n     *     resourcesData   : [...],\n     *     assignmentsData : [...]\n     * });\n     *\n     * const json = project.toJSON();\n     *\n     * // Result:\n     * {\n     *     taskData : [...],\n     *     resourcesData : [...],\n     *     assignmentsData : [...]\n     * }\n     * ```\n     *\n     * Output can be consumed by `loadInlineData()`:\n     *\n     * ```javascript\n     * const json = project.toJSON();\n     *\n     * // Plug it back in later\n     * project.loadInlineData(json);\n     * ```\n     *\n     * @returns {Object}\n     * @category JSON\n     */\n    toJSON() {\n        const\n            { taskStore, assignmentStore, resourceStore } = this,\n            result = {\n                tasksData : taskStore.toJSON()\n            };\n\n        if (assignmentStore?.count) {\n            result.assignmentsData = assignmentStore.toJSON();\n        }\n\n        if (resourceStore?.count) {\n            result.resourcesData = resourceStore.toJSON();\n        }\n\n        return result;\n    }\n}\n", "import Model from '../../Core/data/Model.js';\n/**\n * @module TaskBoard/model/SwimlaneModel\n */\n\n/**\n * Represents a single swimlane on a TaskBoard.\n *\n * When creating a TaskBoard, you can optionally supply an initial set of swimlanes. These are either defined as plain\n * strings, SwimlaneModel data objects or SwimlaneModel records (or a mix thereof). When using strings, the string will\n * be used as is as the swimlane's id and capitalized as its text.\n *\n * ```javascript\n * const highPrio = new SwimlaneModel({\n *     id   : 'high',\n *     text : 'High prio'\n * });\n *\n * const taskBoard = new TaskBoard({\n *     swimlanes : [\n *         // String, equal to passing { id : 'low', text : 'Low' }\n *         'low',\n *         // Data object, in this case with a fixed height and not collapsible from the UI\n *         { id : 'medium', text : 'Medium', height : 200, collapsible : false }\n *         // Record, not commonly used since it is easier to supply the data object directly\n *         highPrio\n *     ]\n * });\n * ```\n *\n * @extends Core/data/Model\n * @uninherit Core/data/mixin/TreeNode\n */\nexport default class SwimlaneModel extends Model {\n\n    static $name = 'SwimlaneModel';\n\n    static fields = [\n        /**\n         * The swimlane's unique id, used to match a task to a swimlane (which field on a task to match is specified\n         * using then {@link TaskBoard.view.TaskBoardBase#config-swimlaneField} config on TaskBoard).\n         * @field {String|Number} id\n         */\n\n        /**\n         * Text displayed in the swimlane header.\n         * @field {String} text\n         */\n        { name : 'text', type : 'string' },\n\n        /**\n         * Color, named colors are applied as a `b-taskboard-color-{color}` (for example `b-taskboard-color-red`) CSS\n         * class to the swimlane. Colors specified as hex, `rgb()` etc. are applied as `style.color` to the swilane.\n         *\n         * By default it does not visually affect the UI, but it applies a color to the swimlane that applications can\n         * leverage using `currentColor` to style it in the desired way.\n         *\n         * Using named colors:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     swimlanes : [\n         *         { id : 'high', text : 'High', color : 'red' }\n         *     ]\n         * });\n         * ```\n         *\n         * Will result in:\n         *\n         * ```html\n         * <div class=\"b-taskboard-swimlane b-taskboard-color-red\">\n         * ```\n         *\n         * Which can the be used for example like:\n         *\n         * ```css\n         * .b-taskboard-swimlane-header {\n         *     border-left : 5px solid currentColor; // where currentColor is the color defined by b-red\n         * }\n         * ```\n         *\n         * Using non-named colors:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     swimlanes : [\n         *         { id : 'high', text : 'High', color : 'hsl(229deg 66% 42%)' }\n         *     ]\n         * });\n         * ```\n         *\n         * Will result in:\n         *\n         * ```html\n         * <div class=\"b-taskboard-swimlane\" style=\"color: hsl(229deg 66% 42%)\">\n         * ```\n         *\n         * Predefined named colors (actual color might vary by theme):\n         * <div class=\"b-colorbox b-inline b-taskboard-color-red\"></div>red,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-pink\"></div>pink,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-purple\"></div>purple,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-deep-purple\"></div>deep-purple,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-indigo\"></div>indigo,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-blue\"></div>blue,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-light-blue\"></div>light-blue,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-cyan\"></div>cyan,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-teal\"></div>teal,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-green\"></div>green,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-light-green\"></div>light-green,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-lime\"></div>lime,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-yellow\"></div>yellow,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-amber\"></div>amber,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-orange\"></div>orange,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-deep-orange\"></div>deep-orange\n         *\n         * @field {String} color\n         */\n        { name : 'color', type : 'string' },\n\n        /**\n         * Allow collapsing this swimlane\n         * @field {Boolean} collapsible=true\n         */\n        { name : 'collapsible', type : 'boolean', defaultValue : true },\n\n        /**\n         * Collapsed (true) or expanded (False).\n         *\n         * To expand or collapse, use TaskBoards {@link TaskBoard.view.mixin.ExpandCollapse#function-expand} and\n         * {@link TaskBoard.view.mixin.ExpandCollapse#function-collapse} functions.\n         *\n         * @field {Boolean} collapsed\n         * @readonly\n         */\n        { name : 'collapsed', type : 'boolean' },\n\n        /**\n        * Set to `true` to hide the swimlane, `false` to show it again.\n        * @field {Boolean} hidden\n        */\n        { name : 'hidden', type : 'boolean' },\n\n        /**\n         * Swimlane height in px.\n         * @field {Number} height\n         */\n        { name : 'height', type : 'number' },\n\n        /**\n         * Swimlane flex, affects height.\n         * @field {Number} flex\n         */\n        { name : 'flex', type : 'number' },\n\n        /**\n         * Number of tasks per row to display in this swimlane. Leave blank to use the setting from the\n         * {@link TaskBoard.view.TaskBoardBase#config-tasksPerRow} config on TaskBoard.\n         * @field {Number} tasksPerRow\n         */\n        'tasksPerRow'\n    ];\n\n    get taskBoard() {\n        return this.firstStore.taskBoard;\n    }\n\n    /**\n     * Collapse this swimlane.\n     *\n     * Uses a transition by default, await the call to be certain that it has finished.\n     *\n     * @category Expand/collapse\n     * @returns {Promise} A promise which is resolved when the column is collapsed\n     */\n    async collapse() {\n        this.taskBoard.collapse(this);\n    }\n\n    /**\n     * Expand this swimlane.\n     *\n     * Uses a transition by default, await the call to be certain that it has finished.\n     *\n     * @category Expand/collapse\n     * @returns {Promise} A promise which is resolved when the column is expanded\n     */\n    async expand() {\n        return this.taskBoard.expand(this);\n    }\n\n    /**\n     * Get tasks in this swimlane.\n     * @property {TaskBoard.model.TaskModel[]}\n     * @readonly\n     */\n    get tasks() {\n        return [...(this.taskBoard.getSwimlaneTasks(this) || [])];\n    }\n}\n", "import Base from '../../../Core/Base.js';\nimport DomSync from '../../../Core/helper/DomSync.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\n\n/**\n * @module TaskBoard/view/mixin/ExpandCollapse\n */\n\n/**\n * Mixin that handles expanding and collapsing swimlanes and columns on the TaskBoard.\n *\n * {@inlineexample TaskBoard/view/mixin/ExpandCollapse.js}\n *\n * Users can expand and collapse using the UI. To do it programmatically, see:\n *\n * * {@link #function-collapse collapse()}\n * * {@link #function-expand expand()}\n * * {@link #function-toggleCollapse toggleCollapse()}\n *\n * Each of them accepts a column or a swimlane to expand/collapse. For example\n *\n * ```javascript\n * taskBoard.collapse(taskBoard.columns.todo);\n * taskBoard.expand(taskBoard.swimlanes.high);\n * ```\n *\n * For convenience, the functions are also callable directly on columns/swimlanes:\n *\n * ```javascript\n * taskBoard.columns.todo.expand();\n * taskBoard.swimlanes.high.collapse();\n * ```\n *\n * Expanding/collapsing is by default transitioned, `await` the calls to be certain that the UI is up to date:\n *\n * ```javascript\n * await taskBoard.collapse(taskBoard.columns.todo);\n * await taskBoard.columns.todo.expand();\n * ```\n *\n * @mixin\n */\nexport default Target => class ExpandCollapse extends (Target || Base) {\n\n    //region Config\n\n    static $name = 'ExpandCollapse';\n\n    static configurable = {\n        /**\n         * Show an icon to expand/collapse columns and swimlanes in their headers.\n         *\n         * Programmatic expand/collapse works independently of this setting, it only affects the UI.\n         *\n         * @config {Boolean}\n         * @default\n         * @category Common\n         */\n        showCollapseInHeader : true,\n\n        /**\n         * Specify `true` to hide the column title instead of rotating it on collapse.\n         *\n         * Used by default with swimlanes, since the title will overlap the swimlane header otherwise.\n         *\n         * @config {Boolean}\n         * @default\n         * @category Misc\n         */\n        collapseTitle : false,\n\n        /**\n         * By default, a tooltip showing `Expand XX`/`Collapse XX` is shown when hovering the expand/collapse icon for\n         * a column or swimlane. To disable the tooltip, set this to `false`.\n         * @prp {Boolean}\n         * @default\n         * @category Misc\n         */\n        showCollapseTooltip : true\n    };\n\n    get widgetClass() {}\n\n    //endregion\n\n    //region Type assertions\n\n    changeShowCollapseInHeader(showCollapseInHeader) {\n        ObjectHelper.assertBoolean(showCollapseInHeader, 'showCollapseInHeader');\n\n        return showCollapseInHeader;\n    }\n\n    //endregion\n\n    //region Toggling\n\n    /**\n     * Collapse a swimlane or column.\n     *\n     * Await the call to be certain that the collapse transition has ended.\n     *\n     * ```javascript\n     * await taskBoard.collapse(taskBoard.columns.first);\n     * ```\n     *\n     * @param {TaskBoard.model.SwimlaneModel|TaskBoard.model.ColumnModel} record Swimlane or column\n     * @category Expand & collapse\n     */\n    async collapse(record) {\n        return this.toggleCollapse(record, true);\n    }\n\n    /**\n     * Expand a swimlane or column.\n     *\n     * Await the call to be certain that the expand transition has ended.\n     *\n     * ```javascript\n     * await taskBoard.expand(taskBoard.columns.first);\n     * ```\n     *\n     * @param {TaskBoard.model.SwimlaneModel|TaskBoard.model.ColumnModel} record Swimlane or column\n     * @category Expand & collapse\n     */\n    async expand(record) {\n        return this.toggleCollapse(record, false);\n    }\n\n    /**\n     * Expand or collapse a swimlane or column.\n     *\n     * Await the call to be certain that the expand/collapse transition has ended.\n     *\n     * ```javascript\n     * // Toggle\n     * await taskBoard.toggleCollapse(taskBoard.columns.first);\n     * // Force collapse\n     * await taskBoard.toggleCollapse(taskBoard.columns.first, true);\n     * // Force expand\n     * await taskBoard.toggleCollapse(taskBoard.columns.first, false);\n     * ```\n     *\n     * @param {TaskBoard.model.SwimlaneModel|TaskBoard.model.ColumnModel} record Swimlane or column\n     * @param {Boolean} [collapse] Specify to force a certain state, leave out to toggle\n     * @category Expand & collapse\n     */\n    async toggleCollapse(record, collapse = !record.collapsed) {\n        if (record.isSwimlaneModel) {\n            await this.toggleSwimlaneCollapse(record, collapse);\n        }\n        else {\n            await this.toggleColumnCollapse(record, collapse);\n        }\n    }\n\n    async toggleSwimlaneCollapse(swimlaneRecord, collapse = !swimlaneRecord.collapsed) {\n        return new Promise(resolve => {\n            const\n                me              = this,\n                swimlaneElement = me.getSwimlaneElement(swimlaneRecord),\n                swimlaneBody    = DomSync.getChild(swimlaneElement, 'body');\n\n            // Set a height on collapse, to transition down from -> 0\n            if (collapse) {\n                swimlaneBody.style.height = `${swimlaneBody.getBoundingClientRect().height}px`;\n            }\n\n            EventHelper.onTransitionEnd({\n                element  : swimlaneBody,\n                property : 'height',\n                handler() {\n                    // Remove that height on expand, after it has transitioned from 0 to it\n                    if (!collapse) {\n                        swimlaneBody.style.height = '';\n                    }\n\n                    swimlaneElement.classList.remove(collapse ? 'b-collapsing' : 'b-expanding');\n\n                    // Make sure UI is up to date when promise is resolved\n                    me.recompose.flush();\n\n                    resolve();\n                },\n                thisObj : me\n            });\n\n            swimlaneElement.classList.add(collapse ? 'b-collapsing' : 'b-expanding');\n\n            me.suspendDomTransition();\n\n            // This will trigger the recompose\n            swimlaneRecord.collapsed = collapse;\n\n            me.resumeDomTransition();\n        });\n    }\n\n    async toggleColumnCollapse(columnRecord, collapse = !columnRecord.collapsed) {\n        return new Promise(resolve => {\n            const\n                me               = this,\n                { documentRoot } = me,\n                columnElements   = me.getColumnElements(columnRecord),\n                headerElement    = DomSync.getChild(me.bodyElement, `header.${columnRecord.domId}`),\n                // For columns that already has a width specified we won't need to measure and apply current width\n                hasFixedWidth    = columnRecord.width && !columnRecord.flex,\n                cardElements     = documentRoot.querySelectorAll(`.b-taskboard-card[data-column=\"${columnRecord.domId}\"]`),\n                cardWidth        = `${cardElements[0]?.getBoundingClientRect().width}px`,\n                columnWidth      = `${columnElements[0]?.getBoundingClientRect().width}px`;\n\n            // Fix card widths on collapse, to not have their contents reflow during the collapse\n            cardElements.forEach(card => {\n                if (collapse) {\n                    card.style.width = cardWidth;\n                }\n            });\n\n            columnElements.unshift(headerElement);\n\n            columnElements.forEach(element => {\n                // Set a width on collapse, to transition down from -> 0\n                if (collapse) {\n                    if (!hasFixedWidth) {\n                        element.style.width = columnWidth;\n                    }\n\n                    element.classList.add('b-collapsing');\n                }\n                // Add cls to keep flex away a bit longer on expand\n                else {\n                    element.classList.add('b-expanding');\n                }\n            });\n\n            EventHelper.onTransitionEnd({\n                element  : headerElement,\n                property : 'width',\n                handler() {\n                    // Unfix card widths when fully expanded again\n                    cardElements.forEach(card => {\n                        if (!collapse) {\n                            card.style.width = '';\n                        }\n                    });\n\n                    // Remove that width on expand, after it has transitioned from 0 to it\n                    columnElements.forEach(element => {\n                        if (!collapse) {\n                            // Restore width and flex from css\n                            if (!hasFixedWidth) {\n                                element.style.width = '';\n                            }\n                            element.classList.remove('b-expanding');\n                        }\n                        else {\n                            element.classList.remove('b-collapsing');\n                        }\n                    });\n\n                    // Make sure UI is up to date when promise is resolved\n                    me.recompose.flush();\n\n                    // Scroller is not aware of that expanding/collapsing might change overflow state, inform it...\n                    me.scrollable.syncOverflowState();\n\n                    resolve();\n                },\n                thisObj : me\n            });\n\n            // Force browser to reevaluate, for transition to trigger\n            headerElement.offsetWidth;\n\n            me.suspendDomTransition();\n            // This will trigger the recompose\n            columnRecord.collapsed = collapse;\n\n            me.resumeDomTransition();\n        });\n    }\n\n    //endregion\n\n    //region Rendering\n\n    // Inject expander icon + expand/collapsed state cls in column headers\n    populateColumnHeader(args) {\n        super.populateColumnHeader?.(args);\n\n        const\n            { showCollapseInHeader, collapseTitle, hasSwimlanes, showCollapseTooltip } = this,\n            { columnRecord, columnHeaderConfig }                                       = args,\n            { text, collapsed, collapsible }                                           = columnRecord;\n\n        DomHelper.merge(columnHeaderConfig, {\n            class : {\n                'b-collapsed'    : collapsed,\n                'b-rotate-title' : collapsed && !collapseTitle && !hasSwimlanes\n            },\n            children : {\n                padder : {\n                    children : {\n                        expander : showCollapseInHeader && collapsible && {\n                            tag   : 'button',\n                            class : {\n                                'b-taskboard-column-expander' : 1,\n                                'b-fw-icon'                   : 1,\n                                'b-icon-expand-column'        : 1\n                            },\n                            dataset : {\n                                btip : showCollapseTooltip\n                                    ? StringHelper.xss`${this.L(collapsed ? 'L{TaskBoard.expand}' : 'L{TaskBoard.collapse}', text)}`\n                                    : null\n                            }\n                        }\n                    }\n                }\n            }\n        });\n    }\n\n    // Inject expand/collapsed state cls in columns\n    populateColumn(args) {\n        super.populateColumn?.(args);\n\n        const\n            { columnRecord, columnConfig } = args,\n            { collapsed }                  = columnRecord;\n\n        columnConfig.class['b-collapsed'] = collapsed;\n    }\n\n    // Inject expander icon + expand/collapsed state cls in swimlanes\n    populateSwimlane(args) {\n        super.populateColumn?.(args);\n\n        const { swimlaneRecord, swimlaneConfig } = args;\n\n        if (swimlaneRecord) {\n            const\n                { showCollapseInHeader, showCollapseTooltip } = this,\n                { text, collapsed, collapsible }              = swimlaneRecord;\n\n            DomHelper.merge(swimlaneConfig, {\n                class : {\n                    'b-collapsed'   : collapsed,\n                    'b-collapsible' : collapsible\n                },\n                children : {\n                    header : {\n                        children : {\n                            title : {\n                                children : {\n                                    // Before text\n                                    'expander > text' : showCollapseInHeader && collapsible && {\n                                        tag   : 'button',\n                                        class : {\n                                            'b-taskboard-swimlane-expander' : 1,\n                                            'b-icon'                        : 1,\n                                            'b-icon-expand-row'             : 1\n                                        },\n                                        dataset : {\n                                            btip : showCollapseTooltip\n                                                ? StringHelper.xss`${this.L(collapsed ? 'L{TaskBoard.expand}' : 'L{TaskBoard.collapse}', text)}`\n                                                : null\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    body : {\n                        [collapsed ? 'inert' : null] : true\n                    }\n                }\n            });\n        }\n    }\n\n    //endregion\n\n    //region Listeners\n\n    onColumnHeaderClick({ event, columnRecord }) {\n        if (event.target.matches('.b-taskboard-column-expander') || columnRecord.collapsed) {\n            this.toggleCollapse(columnRecord);\n        }\n    }\n\n    onColumnClick({ columnRecord }) {\n        if (columnRecord.collapsed) {\n            this.toggleCollapse(columnRecord);\n        }\n    }\n\n    onSwimlaneHeaderClick({ swimlaneRecord }) {\n        this.toggleCollapse(swimlaneRecord);\n    }\n\n    //endregion\n\n};\n", "import Base from '../../../Core/Base.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n\n/**\n * @module TaskBoard/view/mixin/ResponsiveCards\n */\n\n/**\n * An object that describes a card size level.\n *\n * @typedef {Object} CardSize\n * @property {String} name Level name, applied to the columns element as CSS class `b-[name]-cards`\n * @property {Number} maxWidth Express in px. This level applies above the previous levels maxWidth and up to this value\n * @property {Number} maxAvatars Max number of resource avatars to render, when that feature is used\n * @property {Object<String,TaskItemOptions>} headerItems A config object for items in a card's header, merges with\n * {@link TaskBoard.view.TaskBoard#config-headerItems} to determine items for this card size\n * @property {Object<String,TaskItemOptions>} bodyItems A config object for items in a card's header, merges with\n * {@link TaskBoard.view.TaskBoard#config-bodyItems} to determine items for this card size\n * @property {Object<String,TaskItemOptions>} footerItems A config object for items in a card's header, merges with\n * {@link TaskBoard.view.TaskBoard#config-footerItems} to determine items for this card size\n */\n\n/**\n * Mixin that allows responsive card behaviours.\n *\n * {@inlineexample TaskBoard/view/mixin/ResponsiveCards.js}\n *\n * It monitors column sizes using a ResizeObserver. When a columns width changes, it calculates the width of the cards\n * in that column based on the columns width and the configured number of tasks per row (see\n * {@link TaskBoard.view.TaskBoard#config-tasksPerRow}).\n *\n * The card width is then used to pick a {@link #config-cardSizes}, which applies CSS and might also affect task items.\n *\n * By default the following levels are defined:\n *\n * | Width | Name   | Cls            | Avatars | Items                       |\n * |-------|--------|----------------|---------|-----------------------------|\n * | < 50  | micro  | b-micro-cards  | 1       | Only resource avatars shown |\n * | < 75  | tiny   | b-tiny-cards   | 1       |                             |\n * | < 175 | small  | b-small-cards  | 1       |                             |\n * | < 300 | medium | b-medium-cards | 3       |                             |\n * | > 300 | large  | b-large-cards  | 7       |                             |\n *\n * If for example cards in a column are above 50px and below 75px wide, that column will have the `b-tiny-cards` CSS\n * class applied to its element. Use it to style the cards in a suitable way for your application, perhaps by applying\n * a smaller font size, hiding images etc.\n *\n * @mixin\n */\nexport default Target => class ResponsiveCards extends (Target || Base) {\n\n    //region Config\n\n    static $name = 'ResponsiveCards';\n\n    static configurable = {\n        /**\n         * An array of {@link CardSize} objects to use as responsive levels based on card widths.\n         *\n         * By default, the following levels are defined:\n         *\n         * | Width | Name   | Cls            | Avatars | Items                       |\n         * |-------|--------|----------------|---------|-----------------------------|\n         * | < 50  | micro  | b-micro-cards  | 1       | Only resource avatars shown |\n         * | < 75  | tiny   | b-tiny-cards   | 1       | Body text hidden            |\n         * | < 175 | small  | b-small-cards  | 2       | Body text hidden            |\n         * | < 300 | medium | b-medium-cards | 3       |                             |\n         * | > 300 | large  | b-large-cards  | 7       |                             |\n         *\n         * @config {CardSize}\n         * @category Common\n         */\n        cardSizes : [\n            {\n                maxWidth    : 50,\n                name        : 'micro',\n                maxAvatars  : 1,\n                headerItems : {\n                    text : null\n                },\n                bodyItems : {\n                    text : null\n                }\n            },\n            {\n                maxWidth   : 75,\n                name       : 'tiny',\n                maxAvatars : 1,\n                bodyItems  : {\n                    text : null\n                }\n            },\n            {\n                maxWidth   : 175,\n                name       : 'small',\n                maxAvatars : 2,\n                bodyItems  : {\n                    text : null\n                }\n            },\n            { maxWidth : 250, name : 'medium', maxAvatars : 3 },\n            { name : 'large', maxAvatars : 7 }\n        ],\n\n        resizeObserver : {\n            value   : true,\n            $config : ['nullify']\n        }\n    };\n\n    get widgetClass() {}\n\n    //endregion\n\n    //region Type assertions\n\n    changeCardSizes(cardSizes) {\n        ObjectHelper.assertArray(cardSizes, 'cardSizes');\n\n        return cardSizes;\n    }\n\n    //endregion\n\n    //region Suspend/resume responsiveness\n\n    responsivenessSuspended = 0;\n\n    suspendResponsiveness() {\n        this.responsivenessSuspended++;\n    }\n\n    resumeResponsiveness() {\n        this.responsivenessSuspended--;\n    }\n\n    //endregion\n\n    //region Calculate card size\n\n    // Get a card size entity, very similar to a responsive level in Grid\n    getCardSize(columnRecord, swimlaneRecord) {\n        const\n            me            = this,\n            { cardSizes } = me,\n            perRow        = me.getTasksPerRow(columnRecord, swimlaneRecord),\n            columnWidth   = me.getColumnWidth(columnRecord),\n            // Three cards on a row shares the column width with 2 gaps.\n            // Column padding is not measured and thus not part of calc\n            // |               |\n            // | █ gap █ gap █ |\n            // |               |\n            cardWidth     = (columnWidth - me.cardGap * (perRow - 1)) / perRow;\n\n        // <remove-on-release>\n        // TODO: Cache until next resize\n        // </remove-on-release>\n\n        return cardSizes?.find(size => cardWidth < size.maxWidth) || cardSizes?.[cardSizes.length - 1];\n    }\n\n    // Get the last reported width for a column, set by the ResizeObserver\n    getColumnWidth(columnRecord) {\n        return columnRecord.instanceMeta(this).width;\n    }\n\n    // Number of tasks per row to render for the requested column / swimlane intersection.\n    // Prio order is columns config, swimlanes config and lastly taskboards config\n    getTasksPerRow(columnRecord, swimlaneRecord) {\n        return columnRecord.tasksPerRow || swimlaneRecord?.tasksPerRow || this.tasksPerRow;\n    }\n\n    //endregion\n\n    //region ResizeObserver\n\n    // ResizeObserver callback for column size changes\n    onChildResize(entries) {\n        const me = this;\n\n        if (me.recompose.suspended || me.responsivenessSuspended) {\n            return;\n        }\n\n        // If any columns width changed enough for it to change card size level (medium -> large etc) we need to\n        // recompose to allow UI to react\n        let shouldRecompose = false;\n\n        for (const entry of entries) {\n            const { target, contentRect } = entry;\n\n            // Only care about width\n            if (target.observedWidth !== contentRect.width) {\n                const\n                    columnRecord   = me.resolveColumnRecord(target),\n                    // We are observing the headers, but need to calculate card size per column / swimlane intersection\n                    columnElements = columnRecord && me.columns.includes(columnRecord) && me.getColumnElements(columnRecord);\n\n                // Bail out when collapsing or hiding the column or if we did not get any record, which can happen\n                // during recompose when switching column set\n                if (!columnRecord || columnRecord.collapsed || columnRecord.hidden || !columnElements) {\n                    return;\n                }\n\n                // Cache width on element and column record (for easy lookup later)\n                columnRecord.instanceMeta(me).width = target.observedWidth = contentRect.width;\n\n                for (const columnElement of columnElements) {\n                    const\n                        swimlaneRecord = me.resolveSwimlaneRecord(columnElement),\n                        cardSize       = me.getCardSize(columnRecord, swimlaneRecord);\n\n                    // Was the size change enough to take us to a new card size level?\n                    if (cardSize && columnElement.elementData.cardSize !== cardSize.name) {\n                        shouldRecompose = true;\n                    }\n                }\n            }\n        }\n\n        if (shouldRecompose) {\n            me.recompose.now();\n            me.scrollable.syncOverflowState();\n        }\n    }\n\n    // ResizeObserver used to monitor column size, observing set up in domSyncCallback\n    changeResizeObserver(observer, oldObserver) {\n        oldObserver?.disconnect();\n\n        // Resize observer could be set to null for FireFox testing\n        return this.isDestroying || !ResizeObserver ? null : new ResizeObserver(this.onChildResize.bind(this));\n    }\n\n    //endregion\n\n    //region Rendering\n\n    populateColumn(args) {\n        super.populateColumn?.(args);\n\n        const\n            { columnRecord, swimlaneRecord, columnConfig } = args,\n            // Tag cardSize along with args, to be reachable from renderer\n            cardSize = args.cardSize                       = this.getCardSize(columnRecord, swimlaneRecord);\n\n        if (cardSize) {\n            columnConfig.class[`b-${cardSize.name}-cards`] = cardSize;\n            columnConfig.elementData.cardSize = cardSize.name;\n        }\n    }\n\n    //endregion\n\n};\n", "import Base from '../../../Core/Base.js';\nimport Store from '../../../Core/data/Store.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport ColumnModel from '../../model/ColumnModel.js';\n\n/**\n * @module TaskBoard/view/mixin/TaskBoardColumns\n */\n\nconst transitionChangeActions = {\n    remove : 1,\n    move   : 1,\n    update : 1,\n    filter : 1\n};\n\n/**\n * Mixin that handles columns for the TaskBoard.\n *\n * @mixin\n */\nexport default Target => class TaskBoardColumns extends (Target || Base) {\n\n    //region Config\n\n    static $name = 'TaskBoardColumns';\n\n    static configurable = {\n        /**\n         * Store containing the TaskBoard columns.\n         *\n         * @member {Core.data.Store} columns\n         * @category Common\n         */\n        /**\n         * Store containing the TaskBoard columns. A tasks {@link #config-columnField} is matched against the `id` of a\n         * column to determine in which column it is displayed.\n         *\n         * Accepts an array of column records/objects/strings, a store instance, a store id or a store config object\n         * used to create a new store.\n         *\n         * When supplying an array, a store configured with {Core.data.mixin.StoreProxy#config-objectify} is\n         * automatically created. Using that config allows for a nicer interaction syntax with the columns:\n         *\n         * ```javascript\n         * // Without objectify:\n         * taskBoard.columns.getById('done').text = 'Finished';\n         *\n         * // With objectify:\n         * taskBoard.columns.done.text = 'Finished';\n         * ```\n         *\n         * When supplying strings, the raw string will be used as the columns `id` and a capitalized version of it is\n         * used as the columns text:\n         *\n         * ```javascript\n         * taskBoard = new TaskBoard({\n         *    columns : [\n         *        'doing',\n         *        'done'\n         *    ]\n         * });\n         * ```\n         *\n         * Is equivalent to:\n         *\n         * ```javascript\n         * taskBoard = new TaskBoard({\n         *    columns : [\n         *        { id : 'doing', text : 'Doing' },\n         *        { id : 'done', text : 'Done' }\n         *    ]\n         * });\n         * ```\n         *\n         * @config {TaskBoard.model.ColumnModel[]|ColumnModelConfig[]|String[]|Core.data.Store|String|StoreConfig}\n         * @category Common\n         */\n        columns : {},\n\n        /**\n         * Set to `true` to auto generate columns when {@link #config-columns} is undefined.\n         *\n         * A column will be created for each distinct value of {@link #config-columnField} on the tasks. The columns\n         * will be sorted in alphabetical order. The following snippet will yield two columns, Q1 and Q2:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    columnField : 'quarter',\n         *\n         *    autoGenerateColumns : true,\n         *\n         *    project : {\n         *        tasksData : [\n         *            { id : 1, name : 'Inform tenants', quarter : 'Q1' },\n         *            { id : 2, name : 'Renovate roofs', quarter : 'Q2' }\n         *        ]\n         *    }\n         * });\n         * ```\n         *\n         * @config {Boolean}\n         * @category Advanced\n         */\n        autoGenerateColumns : false,\n\n        /**\n         * Field on a task record used to determine which column the task belongs to.\n         *\n         * ```javascript\n         * taskBoard.columnField = 'category';\n         * ```\n         *\n         * @member {String} columnField\n         * @category Common\n         */\n        /**\n         * Field on a task record used to determine which column the task belongs to.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    columnField : 'status',\n         *\n         *    columns : [\n         *        'todo',\n         *        'done'\n         *    ],\n         *\n         *    project : {\n         *        tasksData : [\n         *            // Linked using the status field, to the done column\n         *            { id : 1, name : 'Fun task', status : 'done' }\n         *        ]\n         *    }\n         * });\n         * ```\n         *\n         * @config {String}\n         * @category Common\n         */\n        columnField : null\n    };\n\n    static properties = {\n        shouldAutoGenerateColumns : false\n    };\n\n    get widgetClass() {}\n\n    //endregion\n\n    //region Type assertions\n\n    changeAutoGenerateColumns(autoGenerateColumns) {\n        ObjectHelper.assertBoolean(autoGenerateColumns, 'autoGenerateColumns');\n\n        return autoGenerateColumns;\n    }\n\n    changeColumnField(columnField) {\n        ObjectHelper.assertString(columnField, 'columnField');\n\n        return columnField;\n    }\n\n    //endregion\n\n    //region Config - columnField\n\n    updateColumnField(field, old) {\n        if (old) {\n            const { storage } = this.project.taskStore;\n\n            if (old !== this.swimlaneField) {\n                storage.removeIndex(old);\n            }\n            storage.addIndex({ property : field, unique : false });\n        }\n\n        this.shouldAutoGenerateColumns = field && this.autoGenerateColumns;\n    }\n\n    //endregion\n\n    //region Config - columns\n\n    changeColumns(columns) {\n        return Store.from(columns, { objectify : true, modelClass : ColumnModel }, column => {\n            if (typeof column === 'string') {\n                return { id : column, text : StringHelper.capitalize(column) };\n            }\n\n            return column;\n        });\n    }\n\n    updateColumns(columns) {\n        this.detachListeners('columns');\n\n        if (columns) {\n            // Link to us to be able to retrieve tasks in visual order\n            // $store is the store instance of an objectified store\n            (columns.$store || columns).taskBoard = this;\n\n            columns.ion({\n                change  : 'onColumnsChange',\n                refresh : 'onColumnsChange',\n                thisObj : this\n            });\n        }\n    }\n\n    get columns() {\n        const\n            me            = this,\n            { taskStore } = me.project;\n\n        // If there are no columns defined but we have a column field configured and we have tasks loaded, generate\n        // columns from the tasks\n        if (me.shouldAutoGenerateColumns && taskStore.count) {\n            me.columns = taskStore.getDistinctValues(me.columnField).sort();\n            me.shouldAutoGenerateColumns = false;\n        }\n\n        return me._columns;\n    }\n\n    onColumnsChange({ action }) {\n        // CRUD invalidates column/swimlane intersection index\n        if (action === 'add' || action === 'remove' || action === 'removeAll' || action === 'update') {\n            this.project.taskStore.storage.invalidateIndices();\n        }\n\n        if (transitionChangeActions[action]) {\n            const options = {};\n\n            if (action === 'update' || action === 'remove') {\n                options.addTransition = { width : 1, opacity : 1 };\n                options.removeTransition = { width : 1, opacity : 1 };\n            }\n\n            this.recomposeWithDomTransition(options);\n        }\n        else {\n            this.recompose();\n        }\n    }\n\n    //endregion\n\n    //region Data\n\n    // <remove-on-release>\n    // TODO: Move to datalayer\n    // </remove-on-release>\n    getColumnTasks(columnRecord, inVisualOrder = false) {\n        const\n            me            = this,\n            { taskStore } = me.project,\n            set           = taskStore.storage.findItem(me.columnField, columnRecord.id),\n            tasks         = set ? [...set] : [];\n\n        if (inVisualOrder && set) {\n            if (me.swimlanes) {\n                const\n                    { swimlaneField } = me,\n                    swimlanes         = me.swimlanes.map(r => r.id);\n\n                tasks.sort((a, b) => {\n                    // First sort by swimlane\n                    const swimlaneDelta = swimlanes.indexOf(a[swimlaneField]) - swimlanes.indexOf(b[swimlaneField]);\n\n                    if (swimlaneDelta !== 0) {\n                        return swimlaneDelta;\n                    }\n\n                    // And within a swimlane sort by weight order\n                    if (a.weight != null || b.weight != null) {\n                        return a.weight - b.weight;\n                    }\n\n                    // Fall back to store order\n                    return taskStore.indexOf(a) - taskStore.indexOf(b);\n                });\n\n                // Only include tasks for available swimlanes, if used\n                if (swimlanes.length && swimlaneField) {\n                    return tasks.filter(task => swimlanes.includes(task[swimlaneField]));\n                }\n            }\n            else {\n                // Sort by weight within column\n                tasks.sort((a, b) => a.weight - b.weight);\n            }\n        }\n\n        return tasks;\n    }\n\n    getColumn(taskRecord) {\n        return this.columns.getById(taskRecord.getValue(this.columnField));\n    }\n\n    // Next task in the same column as supplied task\n    getNextTask(taskRecord, wrap = true) {\n        const\n            columnRecord = this.getColumn(taskRecord),\n            columnTasks  = columnRecord.tasks;\n\n        let nextTaskIndex = columnTasks.indexOf(taskRecord) + 1;\n\n        if (nextTaskIndex === columnTasks.length) {\n            if (wrap) {\n                nextTaskIndex = 0;\n            }\n            else {\n                return null;\n            }\n        }\n\n        return columnTasks[nextTaskIndex];\n    }\n\n    // Prev task in the same column as supplied task\n    getPreviousTask(taskRecord, wrap = true) {\n        const\n            columnRecord = this.getColumn(taskRecord),\n            columnTasks  = columnRecord.tasks;\n\n        let prevTaskIndex = columnTasks.indexOf(taskRecord) - 1;\n\n        if (prevTaskIndex < 0) {\n            if (wrap) {\n                prevTaskIndex = columnTasks.length - 1;\n            }\n            else {\n                return null;\n            }\n        }\n\n        return columnTasks[prevTaskIndex];\n    }\n\n    //endregion\n\n};\n", "import Base from '../../../Core/Base.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport DomSync from '../../../Core/helper/DomSync.js';\n\n/**\n * @module TaskBoard/view/mixin/TaskBoardDom\n */\n\n/**\n * Mixin that handles resolving elements from records and vice versa.\n *\n * ```javascript\n * // Resolve task record from an element\n * const task = taskBoard.resolveTaskRecord(someElement);\n *\n * // Get tasks element\n * const element = taskBoard.getTaskElement(taskBoard.taskStore.first);\n * ```\n *\n * @mixin\n */\nexport default Target => class TaskBoardDom extends (Target || Base) {\n\n    //region Config\n\n    static $name = 'TaskBoardDom';\n\n    get widgetClass() {}\n\n    //endregion\n\n    //region Resolve record from element\n\n    /**\n     * Retrieves a task record corresponding to the supplied element. Has to be a `.b-taskboard-card` element or\n     * descendant thereof.\n     *\n     * ```javascript\n     * const taskRecord = taskBoard.resolveTaskRecord(taskElement);\n     * ```\n     *\n     * @param {HTMLElement} element\n     * @returns {TaskBoard.model.TaskModel}\n     * @category DOM\n     */\n    resolveTaskRecord(element) {\n        element = element.closest('.b-taskboard-card');\n        // If element is a drop indicator, it wont have elementData\n        return element && this.project.taskStore.getById(element.elementData?.taskId);\n    }\n\n    /**\n     * Retrieves a column record resolved from the supplied element. Has to be a `.b-taskboard-column` element or\n     * descendant thereof (such as a card).\n     *\n     * ```javascript\n     * const columnRecord = taskBoard.resolveColumnRecord(taskElement);\n     * ```\n     *\n     * @param {HTMLElement} element\n     * @returns {TaskBoard.model.ColumnModel}\n     * @category DOM\n     */\n    resolveColumnRecord(element) {\n        element = element.closest('.b-taskboard-column, .b-taskboard-column-header');\n        // Headers are b-taskboard-column but without elementData, for now\n        return element && this.columns.getById(element.elementData?.columnId);\n    }\n\n    /**\n     * Retrieves a swimlane record resolved from the supplied element. Has to be a `.b-taskboard-swimlane` element or\n     * descendant thereof.\n     *\n     * ```javascript\n     * const swimlaneRecord = taskBoard.resolveSwimlaneRecord(taskElement);\n     * ```\n     *\n     * @param {HTMLElement} element\n     * @returns {TaskBoard.model.SwimlaneModel}\n     * @category DOM\n     */\n    resolveSwimlaneRecord(element) {\n        element = element.closest('.b-taskboard-swimlane');\n        return element && this.swimlanes?.getById(element.elementData.laneId);\n    }\n\n    //endregion\n\n    //region Get element from record\n\n    /**\n     * Retrieves the task element (card) corresponding to the supplied task record.\n     *\n     * ```javascript\n     * const cardElement = taskBoard.getTaskElement(taskRecord);\n     * ```\n     *\n     * @param {TaskBoard.model.TaskModel} taskRecord\n     * @returns {HTMLElement}\n     * @category DOM\n     */\n    getTaskElement(taskRecord) {\n        const taskColumnElement = this.getTaskColumnElement(taskRecord);\n        return taskColumnElement && DomSync.getChild(taskColumnElement, `body.inner.${taskRecord.domId}`);\n    }\n\n    /**\n     * Retrieves the element for the column that holds the supplied task record.\n     *\n     * ```javascript\n     * const columnElement = taskBoard.getColumnElement(taskRecord);\n     * ```\n     *\n     * @param {TaskBoard.model.TaskModel} taskRecord\n     * @returns {HTMLElement}\n     * @category DOM\n     */\n    getTaskColumnElement(taskRecord) {\n        const columnRecord = this.columns.getById(taskRecord.getValue(this.columnField));\n        return columnRecord && DomSync.getChild(this.getTaskSwimlaneElement(taskRecord), `body.${columnRecord.domId}`);\n    }\n\n    /**\n     * Retrieves the element for the swimlane that holds the supplied task record.\n     *\n     * ```javascript\n     * const swimlaneElement = taskBoard.getTaskSwimlaneElement(taskRecord);\n     * ```\n     *\n     * @param {TaskBoard.model.TaskModel} taskRecord\n     * @returns {HTMLElement}\n     * @category DOM\n     */\n    getTaskSwimlaneElement(taskRecord) {\n        // When not using swimlanes, we still create one called 'default'\n        const laneId = this.swimlanes?.count\n            ? this.swimlanes.getById(taskRecord.getValue(this.swimlaneField))?.domId\n            : 'default';\n\n        return DomSync.getChild(this.bodyElement, laneId);\n    }\n\n    /**\n     * Retrieves the element for the supplied swimlane.\n     *\n     * ```javascript\n     * const swimlaneElement = taskBoard.getSwimlaneElement(taskBoard.swimlanes.first);\n     * ```\n     *\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord\n     * @returns {HTMLElement}\n     * @category DOM\n     */\n    getSwimlaneElement(swimlaneRecord) {\n        // Get a swimlane element, does not query DOM and is thus cheap\n        return DomSync.getChild(this.bodyElement, swimlaneRecord.domId);\n    }\n\n    /**\n     * Retrieves the element for the supplied swimlane / column intersection.\n     *\n     * ```javascript\n     * const element = taskBoard.getSwimlaneColumnElement(taskBoard.swimlanes.first, taskBoard.columns.last);\n     * ```\n     *\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord\n     * @param {TaskBoard.model.ColumnModel} columnRecord\n     * @returns {HTMLElement}\n     * @category DOM\n     */\n    getSwimlaneColumnElement(swimlaneRecord, columnRecord) {\n        // Called with a swimlaneRecord (public API)\n        if (swimlaneRecord) {\n            // Get the column element for specified column / swimlane intersection, does not query DOM and is thus cheap\n            return DomSync.getChild(this.getSwimlaneElement(swimlaneRecord), `body.${columnRecord.domId}`);\n        }\n        // Called without, happens internally when not using swimlanes - to have simpler code paths\n        else {\n            return this.getColumnElement(columnRecord);\n        }\n    }\n\n    /**\n     * Retrieves the element for the supplied column.\n     *\n     * Only applicable when not using swimlanes. If you are using swimlanes, see {@link #function-getColumnElements}.\n     *\n     * @param {TaskBoard.model.ColumnModel} columnRecord\n     * @returns {HTMLElement}\n     * @category DOM\n     */\n    getColumnElement(columnRecord) {\n        return this.getColumnElements(columnRecord)?.[0];\n    }\n\n    /**\n     * Retrieves the elements for the supplied column. When using swimlanes, a column has one element per swimlane.\n     *\n     * @param {TaskBoard.model.ColumnModel} columnRecord\n     * @returns {HTMLElement}\n     * @category DOM\n     */\n    getColumnElements(columnRecord) {\n        // A column can span multiple swimlanes, it will have one element per swimlane.\n        // If we have multiple swimlanes, iterate them and retrieve column elements.\n        // This approach avoids querying DOM and is thus cheap\n        if (this.swimlanes?.count) {\n            return this.swimlanes.reduce((result, lane) => {\n                if (!lane.hidden) {\n                    result.push(this.getSwimlaneColumnElement(lane, columnRecord));\n                }\n                return result;\n            }, []);\n        }\n\n        // No swimlanes, still return as array for consistency\n        return [this.getSwimlaneColumnElement({ domId : 'default' }, columnRecord)];\n    }\n\n    /**\n     * Retrieves the header element for the supplied column.\n     *\n     * @param {TaskBoard.model.ColumnModel} columnRecord\n     * @returns {HTMLElement}\n     * @category DOM\n     */\n    getColumnHeaderElement(columnRecord) {\n        return DomSync.getChild(this.bodyElement, `header.${columnRecord.domId}`);\n    }\n\n    //endregion\n\n    //region Position based\n\n    /**\n     * Get the card element at (x, y)\n     * @param {Number} x\n     * @param {Number} y\n     * @param {String} cardSelector\n     * @returns {HTMLElement}\n     * @internal\n     */\n    getCardAt(x, y, cardSelector = '.b-taskboard-card') {\n        return this.documentRoot.elementFromPoint(x, y)?.closest(cardSelector);\n    }\n\n    //endregion\n\n    //region Cached measurements\n\n    // <remove-on-release>\n    // TODO: Reset on CSS var change somehow? Or perhaps not likely to be needed\n    // </remove-on-release>\n\n    cacheCSSVar(name, defaultValue) {\n        const me = this;\n\n        let size = me[`_${name}`];\n\n        if (size == null) {\n            const value = me.css[name];\n\n            size  = DomHelper.measureSize(value || defaultValue, me.element);\n\n            if (value) {\n                me[`_${name}`] = size;\n            }\n        }\n\n        return size;\n    }\n\n    // Cached card gap\n    get cardGap() {\n        return this.cacheCSSVar('cardGap', '1em');\n    }\n\n    //endregion\n\n};\n", "import Base from '../../../Core/Base.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\n\n/**\n * @module TaskBoard/view/mixin/TaskBoardDomEvents\n */\n\n/**\n * Mixin that handles dom events (click etc) for the TaskBoard and its columns and cards.\n *\n * {@inlineexample TaskBoard/view/mixin/TaskBoardDomEvents.js}\n *\n * Snippet showing two ways to add listeners:\n *\n * ```javascript\n * // Listener defined as part of config\n * const taskBoard = new TaskBoard({\n *     listeners : {\n *        taskClick({ taskRecord }) {\n *            Toast.show(`Clicked on ${taskRecord.name}`);\n *        }\n *     }\n * });\n *\n * // Listener added at runtime\n * taskBoard.on('taskDblClick', ({ taskRecord }) => { ... });\n * ```\n *\n * @mixin\n */\nexport default Target => class TaskBoardDomEvents extends (Target || Base) {\n\n    //region Config\n\n    static $name = 'TaskBoardDomEvents';\n\n    static configurable = {\n        /**\n         * The name of the event that should activate a task and trigger editing (if an editing feature is active).\n         * Available options are: 'taskClick', 'taskDblClick' or null (disable)\n         * @default\n         * @config {'taskClick'|'taskDblClick'|null}\n         * @category Advanced\n         */\n        activateTaskEvent : 'taskDblClick',\n\n        domEvents : {\n            click       : 'click',\n            dblclick    : 'dblClick',\n            mouseup     : 'mouseUp',\n            mousedown   : 'mouseDown',\n            mousemove   : 'mouseMove',\n            mouseover   : 'mouseOver',\n            mouseout    : 'mouseOut',\n            keydown     : 'keyDown',\n            contextmenu : 'contextMenu'\n        },\n\n        domListeners : {}\n    };\n\n    #hoveredCardElement = null;\n\n    get widgetClass() {}\n\n    //endregion\n\n    //region Events\n\n    /**\n     * Triggered when a card is clicked.\n     *\n     * ```javascript\n     * taskBoard.on('taskClick', ({ taskRecord }) => {\n     *    Toast.show(`Clicked on ${taskRecord.name}`);\n     * });\n     * ```\n     *\n     * @event taskClick\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.TaskModel} taskRecord Task record\n     * @param {TaskBoard.model.ColumnModel} columnRecord Column record for the tasks column\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record for the tasks swimlane (if used)\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered when a card is double clicked\n     *\n     * ```javascript\n     * taskBoard.on('taskDblClick', ({ taskRecord }) => {\n     *    Toast.show(`Double clicked on ${taskRecord.name}`);\n     * });\n     * ```\n     *\n     * @event taskDblClick\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.TaskModel} taskRecord Task record\n     * @param {TaskBoard.model.ColumnModel} columnRecord Column record for the tasks column\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record for the tasks swimlane (if used)\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered when the mouse enters a card\n     *\n     * ```javascript\n     * taskBoard.on('taskMouseEnter', ({ taskRecord }) => {\n     *    Toast.show(`Mouse entered ${taskRecord.name}`);\n     * });\n     * ```\n     *\n     * @event taskMouseEnter\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.TaskModel} taskRecord Task record\n     * @param {TaskBoard.model.ColumnModel} columnRecord Column record for the tasks column\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record for the tasks swimlane (if used)\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered when the mouse leaves a card\n     *\n     * ```javascript\n     * taskBoard.on('taskMouseLeave', ({ taskRecord }) => {\n     *    Toast.show(`Mouse left ${taskRecord.name}`);\n     * });\n     * ```\n     *\n     * @event taskMouseLeave\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.TaskModel} taskRecord Task record\n     * @param {TaskBoard.model.ColumnModel} columnRecord Column record for the tasks column\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record for the tasks swimlane (if used)\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered when a task is \"activated\" by pressing `Enter` or double clicking it.\n     *\n     * By default this leads to the task editor being shown.\n     *\n     * ```javascript\n     * taskBoard.on('activateTask', ({ taskRecord }) => {\n     *    Toast.show(`Activated ${taskRecord.name}`);\n     * });\n     * ```\n     *\n     * @event activateTask\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.TaskModel} taskRecord Task record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered when a task is rendered.\n     *\n     * This happens on initial render, when a task is added or when the task element is updated.\n     *\n     * Listening to this event allows you to manipulate the tasks element directly after it has been updated. Please\n     * note that we strongly recommend using a `taskRenderer` to manipulate the DomConfig used to update the task for\n     * most scenarios.\n     *\n     * If you listen for this event and manipulate the element in some way, you should also listen for\n     * `removeTaskElement` and revert/clean up the changes there.\n     *\n     * @event renderTask\n     * @param {TaskBoard.view.TaskBoard} source TaskBoard instance\n     * @param {TaskBoard.model.TaskModel} taskRecord Task being rendered\n     * @param {Boolean} isRefresh `true` if the element was updated, `false` if it was added\n     * @param {HTMLElement} element Tasks element\n     */\n\n    /**\n     * Triggered when all tasks in the task board are rendered\n     * @event renderTasks\n     * @param {TaskBoard.view.TaskBoard} source TaskBoard instance\n     * @param {TaskBoard.model.TaskModel[]} taskRecords Tasks being rendered\n     */\n\n    /**\n     * Triggered when a tasks element is removed.\n     *\n     * This happens when a task is removed or when it is move to another swimlane / column (in which case a `renderTask`\n     * event is triggered for the new element).\n     *\n     * If you used listener for `renderTask` to alter the element of tasks, you should also listen for this event to\n     * clean that modification up.\n     *\n     * @event removeTaskElement\n     * @param {TaskBoard.view.TaskBoard} source TaskBoard instance\n     * @param {String|Number} taskId Id of the task (not the record itself since it might be removed)\n     * @param {HTMLElement} element Tasks element\n     */\n\n    //endregion\n\n    //region Triggering\n\n    // Sets the domListeners up, all relayed to triggerDomEvent()\n    changeDomListeners(domListeners) {\n        if (domListeners) {\n            for (const eventName in this.domEvents) {\n                domListeners[eventName] = 'triggerDomEvent';\n            }\n        }\n\n        return domListeners;\n    }\n\n    // Resolve records from the passed event\n    resolveEvent(event) {\n        const\n            { target }     = event,\n            taskRecord     = this.resolveTaskRecord(target),\n            columnRecord   = this.resolveColumnRecord(target),\n            swimlaneRecord = this.resolveSwimlaneRecord(target);\n\n        return { taskRecord, columnRecord, swimlaneRecord, event };\n    }\n\n    // \"Re-trigger\" a dom event as one of ours, populated with records and prefixed with either 'task'  or 'column'\n    // depending on event target\n    triggerDomEvent(event) {\n        const\n            me         = this,\n            args       = me.resolveEvent(event),\n            name       = me.domEvents[event.type],\n            { target } = event;\n\n        // Bail out for fields on a card, or if we are scrolling (_element to not trigger a recompose)\n        if (me.isScrolling || target.closest('.b-widget') !== me._element) {\n            return;\n        }\n\n        // Decorate the event for easy access later\n        event.taskBoardData = args;\n\n        let result;\n\n        // Trigger taskDblClick or columnDblClick, depending on what was resolved\n        if (args.taskRecord) {\n            const eventName = `task${StringHelper.capitalize(name)}`;\n\n            result = me.trigger(eventName, args);\n\n            if (eventName === me.activateTaskEvent && !event.defaultPrevented) {\n                me.trigger('activateTask', { taskRecord : args.taskRecord, event });\n            }\n        }\n        else if (args.columnRecord) {\n            if (target.closest('.b-taskboard-column-header')) {\n                result = me.trigger(`columnHeader${StringHelper.capitalize(name)}`, args);\n            }\n            else {\n                result = me.trigger(`column${StringHelper.capitalize(name)}`, args);\n            }\n        }\n        else if (args.swimlaneRecord) {\n            if (target.closest('.b-taskboard-swimlane-header')) {\n                result = me.trigger(`swimlaneHeader${StringHelper.capitalize(name)}`, args);\n            }\n            else {\n                result = me.trigger(`swimlane${StringHelper.capitalize(name)}`, args);\n            }\n        }\n\n        // Allow returning false from taskClick, onTaskClick etc. to prevent triggering 'click'\n        if (result === false) {\n            return;\n        }\n\n        me.trigger(name, args);\n\n        // Conjure up mouseEnter and mouseLeave events from mouseOver/mouseOut\n        if ((name === 'mouseOver' || name === 'mouseOut') && args.taskRecord) {\n            const cardElement = target.closest('.b-taskboard-card');\n\n            if (name === 'mouseOver' && cardElement !== me.#hoveredCardElement) {\n                me.#hoveredCardElement = cardElement;\n\n                me.trigger('taskMouseEnter', args);\n            }\n\n            if (name === 'mouseOut' && !cardElement.contains(event.relatedTarget)) {\n                me.#hoveredCardElement = null;\n\n                me.trigger('taskMouseLeave', args);\n            }\n        }\n    }\n\n    // Called as DomSync syncs elements\n    domSyncCallback({ action, domConfig, lastDomConfig, targetElement : element, syncId }) {\n        const\n            me              = this,\n            { elementType } = domConfig?.elementData ?? {},\n            isRefresh       = action === 'reuseOwnElement';\n\n        // Safeguard against other non dom synced elements being cleaned up\n        if (domConfig) {\n            // Card element synced\n            if (elementType === 'task') {\n                const\n                    { taskId } = domConfig.elementData,\n                    taskRecord = me.project.taskStore.getById(taskId);\n\n                if (action === 'newElement') {\n                    me.cardIntersectionObserver?.observe(element);\n                }\n\n                if (action === 'newElement' || action === 'reuseOwnElement') {\n                    (!me.isVirtualized || taskRecord.instanceMeta(me).intersects) && me.trigger('renderTask', { taskRecord, element, isRefresh });\n                }\n                else if (action === 'removeElement') {\n                    me.cardIntersectionObserver?.unobserve(element);\n                    me.trigger('removeTaskElement', { taskId, element });\n                }\n            }\n\n            // Column\n            else if (elementType === 'column') {\n                const\n                    { columnId, laneId } = domConfig.elementData,\n                    columnRecord         = me.columns.getById(columnId),\n                    swimlaneRecord       = laneId != null && me.swimlanes?.getById(laneId);\n\n                if (action === 'newElement' || action === 'reuseOwnElement') {\n                    me.trigger('renderColumn', { columnRecord, swimlaneRecord, element, isRefresh });\n                }\n                else if (action === 'removeElement') {\n                    me.trigger('removeColumnElement', { columnId, swimlaneRecord, element });\n                }\n            }\n\n            // Swimlane\n            else if (elementType === 'swimlane') {\n                const\n                    { laneId }     = domConfig.elementData,\n                    swimlaneRecord = laneId != null && laneId !== 'default' && me.swimlanes?.getById(laneId);\n\n                // Using swimlanes is optional\n                if (laneId !== 'default') {\n                    if (action === 'newElement' || action === 'reuseOwnElement') {\n                        me.trigger('renderSwimlane', { swimlaneRecord, element, isRefresh });\n                    }\n                    else if (action === 'removeElement') {\n                        me.trigger('removeSwimlaneElement', { swimlaneId : laneId, element });\n                    }\n                }\n            }\n\n            // Column header padder, for resize monitoring\n            else if (domConfig.class?.['b-taskboard-column-header-padder'] && me.resizeObserver) {\n                if (action === 'newElement') {\n                    if (!element.isResizeObserved) {\n                        me.resizeObserver.observe(element);\n                        element.isResizeObserved = true;\n                    }\n                }\n\n                if (action === 'removeElement') {\n                    if (element.isResizeObserved) {\n                        me.resizeObserver.unobserve(element);\n                        delete element.isResizeObserved;\n                    }\n                }\n            }\n\n        }\n    }\n\n    //endregion\n\n    //region Chainable handlers\n\n    onClick() {}\n\n    onMouseMove() {}\n\n    onMouseUp() {}\n\n    onTaskMouseDown() {}\n\n    onTaskClick() {}\n\n    onTaskDblClick() {}\n\n    onTaskContextMenu() {}\n\n    onColumnMouseDown() {}\n\n    onColumnHeaderClick(...args) {\n        super.onColumnHeaderClick(...args);\n    }\n\n    onSwimlaneHeaderClick(...args) {\n        super.onSwimlaneHeaderClick(...args);\n    }\n\n    onActivateTask() {}\n\n    //endregion\n\n};\n", "import Base from '../../../Core/Base.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport VersionHelper from '../../../Core/helper/VersionHelper.js';\nimport Scroller from '../../../Core/helper/util/Scroller.js';\n\n/**\n * @module TaskBoard/view/mixin/TaskBoardScroll\n */\n\n/**\n * Mixin that handles scrolling to tasks, columns and swimlanes.\n *\n * {@inlineexample TaskBoard/view/mixin/TaskBoardScroll.js}\n *\n * @mixin\n */\nexport default Target => class TaskBoardScroll extends (Target || Base) {\n\n    //region Config\n\n    static $name = 'TaskBoardScroll';\n\n    static configurable = {\n        /**\n         * Default scroll options, see the options for {@link Core.helper.util.Scroller#function-scrollIntoView}\n         *\n         * Defaults to:\n         *\n         * ```javascript\n         * scrollOptions : {\n         *     animate   : true,\n         *     block     : 'nearest',\n         *     highlight : true\n         * }\n         * ```\n         *\n         * Can be overridden per call for all scroll functions.\n         *\n         * @config {ScrollOptions}\n         * @category Advanced\n         */\n        scrollOptions : {\n            animate   : true,\n            block     : 'nearest',\n            highlight : true\n        },\n\n        testConfig : {\n            scrollOptions : {\n                animate : false,\n                block   : 'nearest'\n            }\n        }\n    };\n\n    get widgetClass() {}\n\n    static delayable = {\n        onScrollEnd : VersionHelper.isTestEnv ? 300 : 100\n    };\n\n    //endregion\n\n    //region Scroll tracking\n\n    onPaint({ firstPaint }) {\n        if (firstPaint) {\n            const me = this;\n\n            EventHelper.on({\n                element : me.element,\n                scroll() {\n                    me.isScrolling = true;\n                    me.onScrollEnd();\n                },\n                capture : true,\n                thisObj : me\n            });\n        }\n    }\n\n    onScrollEnd() {\n        this.isScrolling = false;\n\n        if (this.recomposeOnScrollEnd) {\n            this.recompose();\n            this.recomposeOnScrollEnd = false;\n        }\n    }\n\n    //endregion\n\n    //region Type assertions\n\n    changeScrollOptions(scrollOptions) {\n        ObjectHelper.assertObject(scrollOptions, 'scrollOptions');\n\n        return scrollOptions;\n    }\n\n    //endregion\n\n    //region Scroll to\n\n    /**\n     * Scroll specified swimlane into view.\n     *\n     * ```javascript\n     * taskBoard.scrollToSwimlane('high');\n     * taskBoard.scrollToSwimlane(taskBoard.swimlanes.last);\n     * ```\n     *\n     * @param {TaskBoard.model.SwimlaneModel|Number|String} swimlaneOrId Swimlane or its id\n     * @param {ScrollOptions} [options] Scroll options, see {@link #config-scrollOptions}\n     * @category Scrolling\n     */\n    async scrollToSwimlane(swimlaneOrId, options = this.scrollOptions) {\n        const\n            swimlane        = this.swimlanes.getById(swimlaneOrId),\n            swimlaneElement = swimlane && this.getSwimlaneElement(swimlane);\n\n        if (swimlaneElement) {\n            options = ObjectHelper.assign({\n                x       : false,\n                animate : options?.animate || options?.behavior === 'smooth'\n            }, options);\n\n            // <remove-on-release>\n            // TODO: Own a scroller not bound to a specific element to not have to pass rtl on each call?\n            // </remove-on-release>\n            return Scroller.scrollIntoView(swimlaneElement, options, this.rtl);\n        }\n    }\n\n    /**\n     * Scroll specified column into view.\n     *\n     * ```javascript\n     * taskBoard.scrollToColumn('backlog');\n     * taskBoard.scrollToColumn(taskBoard.columns.first);\n     * ```\n     *\n     * @param {TaskBoard.model.ColumnModel|Number|String} columnOrId Column or its id\n     * @param {ScrollOptions} [options] Scroll options, see {@link #config-scrollOptions}\n     * @category Scrolling\n     */\n    async scrollToColumn(columnOrId, options = this.scrollOptions) {\n        const\n            column        = this.columns.getById(columnOrId),\n            columnElement = column && this.getColumnHeaderElement(column);\n\n        if (columnElement) {\n            // Only scroll in the X axis.\n            options = ObjectHelper.assign({\n                animate : options?.animate || options?.behavior === 'smooth',\n                y       : false\n            }, options);\n            return Scroller.scrollIntoView(columnElement, options, this.rtl);\n        }\n    }\n\n    /**\n     * Scroll to the intersection between specified swimlane and column.\n     *\n     * ```javascript\n     * taskBoard.scrollToIntersection('high', 'done');\n     * taskBoard.scrollToIntersection(taskBoard.swimlanes.low, taskBoard.columns.todo);\n     * ```\n     *\n     * @param {TaskBoard.model.SwimlaneModel|Number|String} swimlaneOrId Swimlane or its id\n     * @param {TaskBoard.model.ColumnModel|Number|String} columnOrId Column or its id\n     * @param {ScrollOptions} [options] Scroll options, see {@link #config-scrollOptions}\n     * @category Scrolling\n     */\n    async scrollToIntersection(swimlaneOrId, columnOrId, options = this.scrollOptions) {\n        const\n            swimlane = this.swimlanes.getById(swimlaneOrId),\n            column   = this.columns.getById(columnOrId),\n            target   = swimlane && column && this.getSwimlaneColumnElement(swimlane, column);\n\n        if (target) {\n            options = ObjectHelper.assign({\n                animate    : options?.animate || options?.behavior === 'smooth',\n                edgeOffset : 10\n            }, options);\n            return Scroller.scrollIntoView(target, options, this.rtl);\n        }\n    }\n\n    /**\n     * Scroll the specified task into view.\n     *\n     * ```javascript\n     * taskBoard.scrollToTask(10);\n     * taskBoard.scrollToTask(taskStore.first);\n     * ```\n     *\n     * @param {TaskBoard.model.TaskModel|Number|String} taskOrId\n     * @param {ScrollOptions} [options] Scroll options, see {@link #config-scrollOptions}\n     * @category Scrolling\n     */\n    async scrollToTask(taskOrId, options = this.scrollOptions) {\n        const\n            me          = this,\n            taskRecord  = me.project.taskStore.getById(taskOrId),\n            taskElement = taskRecord && me.getTaskElement(taskRecord);\n\n        if (taskElement) {\n            const edgeOffset = { start : 10, end : 10, top : 10, bottom : 10 };\n\n            // Make sure we don't end up under column or swimlane headers when using sticky headers\n            if (me.stickyHeaders) {\n                if (me.hasSwimlanes) {\n                    edgeOffset.top += me.getTaskSwimlaneElement(taskRecord).syncIdMap.header.offsetHeight;\n                }\n\n                edgeOffset.top += me.bodyElement.syncIdMap.header.offsetHeight;\n            }\n\n            if (me.isVirtualized && !me.getTaskHeight) {\n                // Rely on native scrolling for cards at an unknown position, due to unknown heights of cards above it.\n                // Native scrolling is able to somewhat compensate for changing heights during the scroll (seems to\n                // always scroll it slightly intersecting the view, no matter which settings)\n                taskElement.scrollIntoView();\n\n                // Wait until the task is rendered\n                await new Promise((resolve, reject) => {\n                    const detach = me.ion({\n                        renderTask({ taskRecord : renderedTaskRecord }) {\n                            if (renderedTaskRecord === taskRecord) {\n                                detach();\n                                resolve();\n                            }\n                        },\n                        expires : {\n                            delay : 200,\n                            alt   : reject\n                        }\n                    });\n                });\n            }\n\n            options = ObjectHelper.assign({\n                animate : options?.animate || options?.behavior === 'smooth',\n                edgeOffset\n            }, options);\n            return Scroller.scrollIntoView(taskElement, options, me.rtl);\n        }\n    }\n\n    //endregion\n\n};\n", "import Base from '../../../Core/Base.js';\nimport ArrayHelper from '../../../Core/helper/ArrayHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport ProjectModel from '../../model/ProjectModel.js';\n\n/**\n * @module TaskBoard/view/mixin/TaskBoardStores\n */\n\n/**\n * Mixin that handles TaskBoards stores, managed by a {@link TaskBoard.model.ProjectModel project}.\n *\n * @mixin\n */\nexport default Target => class TaskBoardStores extends (Target || Base) {\n\n    //region Config\n\n    static $name = 'TaskBoardStores';\n\n    static configurable = {\n        projectModelClass : ProjectModel,\n\n        /**\n         * The {@link TaskBoard.model.ProjectModel} instance, containing the data visualized by the TaskBoard.\n         * @member {TaskBoard.model.ProjectModel} project\n         * @accepts {TaskBoard.model.ProjectModel|ProjectModelConfig} project\n         * @category Common\n         */\n        /**\n         * A {@link TaskBoard.model.ProjectModel#configs project config object} or an instance that holds all stores and\n         * data used by the TaskBoard.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     project : {\n         *         // Use a custom task model\n         *         taskModelClass : MyTaskModel,\n         *\n         *         // Supply inline data\n         *         tasksData : [\n         *             { id : 1, name: 'Task 1', ... },\n         *             ...\n         *         ]\n         * });\n         * ```\n         *\n         * Project has built in crud manager functionality to handle syncing with a backend:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     project : {\n         *         transport : {\n         *             load : {\n         *                 url : 'data/data.json'\n         *             }\n         *     },\n         *     autoLoad : true\n         * });\n         *\n         * Also has built in state tracking manager functionality to handle undo/redo:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     stm : {\n         *         autoRecord : true,\n         *         disabled   : false\n         *     }\n         * });\n         *\n         * @config {TaskBoard.model.ProjectModel|ProjectModelConfig}\n         * @category Data\n         */\n        project : {},\n\n        /**\n         * Inline {@link Scheduler.model.AssignmentModel assignments}, will be loaded into an internally created\n         * {@link Scheduler.data.AssignmentStore}  as a part of a {@link TaskBoard.model.ProjectModel project}.\n         * @prp {Scheduler.model.AssignmentModel[]|Object[]} assignments\n         * @category Data\n         */\n        assignments : null,\n\n        /**\n         * Inline {@link Scheduler.model.ResourceModel resources}, will be loaded into an internally created\n         * {@link Scheduler.data.ResourceStore} as a part of a {@link TaskBoard.model.ProjectModel project}.\n         * @prp {Scheduler.model.ResourceModel[]|Object[]} resources\n         * @category Data\n         */\n        resources : null,\n\n        /**\n         * Inline {@link TaskBoard.model.TaskModel tasks}, will be loaded into an internally created\n         * {@link TaskBoard.store.TaskStore} as a part of a {@link TaskBoard.model.ProjectModel project}.\n         * @prp {TaskBoard.model.TaskModel[]|Object[]} tasks\n         * @category Data\n         */\n        tasks : null,\n\n        /**\n         * Default values to apply to task records created by task boards features (such as the column header menu and\n         * the column toolbar)\n         *\n         * @config {TaskModelConfig}\n         * @category Data\n         */\n        newTaskDefaults : {},\n\n        loadMaskDefaults : {\n            useTransition : true,\n            showDelay     : 100\n        },\n\n        /**\n         * TaskBoard does not use a sync mask by default. If you want one, see\n         * {@link Core.mixin.LoadMaskable#config-syncMask} for configuration options.\n         *\n         * @config {String|Object|null}\n         * @default null\n         * @category Masking\n         */\n        syncMask : null\n    };\n\n    get widgetClass() {}\n\n    //endregion\n\n    //#region Inline data\n\n    get assignments() {\n        return this.project.assignmentStore.records;\n    }\n\n    updateAssignments(records) {\n        this.project.assignmentStore.data = records;\n    }\n\n    get resources() {\n        return this.project.resourceStore.records;\n    }\n\n    updateResources(records) {\n        this.project.resourceStore.data = records;\n    }\n\n    get tasks() {\n        return this.project.taskStore.records;\n    }\n\n    updateTasks(records) {\n        this.project.taskStore.data = records;\n    }\n\n    //#endregion\n\n    //region Type assertions\n\n    changeNewTaskDefaults(newTaskDefaults) {\n        ObjectHelper.assertObject(newTaskDefaults, 'newTaskDefaults');\n\n        return newTaskDefaults;\n    }\n\n    //endregion\n\n    //region Project\n\n    changeProject(project) {\n        if (project && !project.isModel) {\n            project = this.projectModelClass.new(project);\n        }\n\n        this.attachToProject(project);\n\n        return project;\n    }\n\n    attachToProject(project) {\n        const me = this;\n\n        // Enable masking with CrudManagerView\n        me.bindCrudManager(project);\n\n        if (project) {\n            const { taskStore } = project;\n\n            // Set up indices for the configured columnField & optional swimlaneField, for faster lookups\n            if (taskStore) {\n                const { storage } = taskStore;\n\n                storage.addIndex({ property : me.columnField, unique : false });\n\n                if (me.swimlaneField) {\n                    storage.addIndex({ property : me.swimlaneField, unique : false });\n                }\n\n                // For quicker lookup of tasks in a swimlane/column intersection\n                Reflect.defineProperty(taskStore.$master.modelClass.prototype, 'columnSwimlaneIntersection', {\n                    get() {\n                        return this.buildIndexKey({\n                            [me.columnField]   : this[me.columnField],\n                            [me.swimlaneField] : this[me.swimlaneField]\n                        });\n                    }\n                });\n\n                taskStore.$master.modelClass.prototype.buildIndexKey = function(data) {\n                    return `${data[me.columnField]}-/-${(me.swimlanes?.count && data[me.swimlaneField]) || 'default'}`;\n                };\n\n                storage.addIndex({ property : 'columnSwimlaneIntersection', unique : false, dependentOn : { [me.swimlaneField] : true, [me.columnField] : true } });\n            }\n\n            // Setup store listeners, mostly just recompose\n            me.attachToProjectStore(project.taskStore, {\n                change          : 'onTaskStoreChange',\n                changePreCommit : 'onTaskStoreEarlyChange',\n                refresh         : 'onTaskStoreRefresh'\n            });\n            me.attachToProjectStore(project.assignmentStore);\n            me.attachToProjectStore(project.resourceStore);\n        }\n    }\n\n    // Most store changes leads to a recompose, with exception of some TaskStore changes that are transitioned\n    attachToProjectStore(store, listenersConfig = {}) {\n        this.detachListeners(store.$name);\n\n        store?.ion({\n            name    : store.$name,\n            change  : 'recompose',\n            refresh : 'recompose',\n            thisObj : this,\n\n            ...listenersConfig\n        });\n    }\n\n    //endregion\n\n    //region Listeners\n\n    onTaskStoreEarlyChange({ action }) {\n        if (action === 'add') {\n            this.recomposeWithDomTransition({\n                addTransition : {\n                    height  : 1,\n                    opacity : 1\n                }\n            });\n        }\n    }\n\n    onTaskStoreChange({ action, changes }) {\n        const { columnField, swimlaneField } = this;\n\n        // Task removal and column/swimlane changes are transitioned\n        if (\n            action === 'remove' ||\n            action === 'filter' ||\n            (action === 'update' && (changes[columnField] || (swimlaneField && changes[swimlaneField])))\n        ) {\n            this.recomposeWithDomTransition({\n                removeTransition : {\n                    height  : 1,\n                    opacity : 1\n                }\n            });\n        }\n        else {\n            this.recompose();\n        }\n    }\n\n    onTaskStoreRefresh({ action }) {\n        if (action === 'sort') {\n            // Ignore sort if we override it anyway\n            !this.taskSorterFn && this.recomposeWithDomTransition();\n        }\n        else {\n            this.recompose();\n        }\n    }\n\n    //endregion\n\n    //region Utility\n\n    /**\n     * Add a new task to the specified column / swimlane intersection (swimlane is optional), scroll it into view and\n     * start editing it (if an editing feature is enabled).\n     *\n     * By default the task is created using the data defined in the {@link #config-newTaskDefaults} combined with values\n     * for the `columnField`, the `swimlaneField` and a generated `weight` to place it last. To override these or to\n     * supply your own values for any field, pass the `taskData` argument.\n     *\n     * If project is configured to auto sync changes to backend, the sync request will be awaited before editing starts.\n     *\n     * @param {TaskBoard.model.ColumnModel} columnRecord Column to add the task to\n     * @param {TaskBoard.model.ColumnModel} [swimlaneRecord] Swimlane to add the task to\n     * @param {Object} [taskData] Data for the new task\n     * @category Common\n     */\n    async addTask(columnRecord, swimlaneRecord = null, taskData = {}) {\n        const\n            me         = this,\n            {\n                swimlaneField,\n                swimlanes,\n                project\n            }          = me,\n            columnBody = me.getColumnElement(columnRecord).syncIdMap.body,\n            lastCard   = columnBody.lastElementChild,\n            data       = {\n                [me.columnField] : columnRecord.id,\n                name             : me.L('L{TaskBoard.newTaskName}'),\n                weight           : (project.taskStore.max('weight') ?? 0) + 100,\n                ...me.newTaskDefaults,\n                ...taskData\n            };\n\n        let suspended = false;\n\n        if (swimlaneField) {\n            if (swimlaneRecord) {\n                data[swimlaneField] = swimlaneRecord.id;\n            }\n            else if (swimlanes?.count) {\n                data[swimlaneField] = swimlanes.first.id;\n            }\n        }\n\n        // If add is likely to cause a scroll, opt out of add transition and only animated the scroll\n        if (lastCard && lastCard.offsetTop + lastCard.offsetHeight > columnBody.clientHeight - 100) {\n            me.suspendDomTransition();\n            suspended = true;\n        }\n\n        const\n            // A sync will be scheduled on the add below if using autoSync, catch that\n            synced       = project.autoSync && project.await('sync', false),\n            [taskRecord] = project.taskStore.add(data);\n\n        // To have new tasks element available when trying to scroll to it\n        me.recompose.now();\n\n        // Await transition used when adding tasks, to be certain task is at correct pos\n        if (me.useDomTransition && !me.domTransitionSuspended) {\n            await me.await('transitionedRecompose', false);\n        }\n\n        if (me.isDestroyed) {\n            return;\n        }\n\n        // Await scroll to make sure inline editing works as expected\n        await me.scrollToTask(taskRecord, ObjectHelper.assign({}, me.scrollOptions, { highlight : false, block : 'nearest' }));\n\n        if (me.isDestroyed) {\n            return;\n        }\n\n        // Await any autoSync that we caught above\n        if (synced) {\n            await synced;\n\n            if (me.isDestroyed) {\n                return;\n            }\n\n            // Sync likely assigned a new id, make sure we are using that in DOM right away\n            me.recompose.now();\n        }\n\n        suspended && me.resumeDomTransition();\n\n        if (me.features.simpleTaskEdit) {\n            me.editTask(taskRecord);\n        }\n\n        return taskRecord;\n    }\n\n    /**\n     * Removes one or more tasks from the linked task store (and thus the TaskBoard).\n     *\n     * First fires a `'beforeTaskRemove'` event, which is preventable and async. Return `false` or a promise that\n     * resolves to `false` from a listener to prevent the operation.\n     *\n     * ```javascript\n     * taskBoard.on({\n     *     async beforeRemoveTask() {\n     *         const result = await askForConfirmation();\n     *         return result;\n     *     }\n     * });\n     *\n     * taskBoard.remove(myTask);\n     * ```\n     *\n     * @param {TaskBoard.model.TaskModel|TaskBoard.model.TaskModel[]} taskRecord A single task or an array thereof to\n     * remove from the task store.\n     * @returns {Boolean} Returns `true` if the tasks were removed, `false` if the operation was prevented.\n     * @category Common\n     */\n    async removeTask(taskRecord) {\n        const taskRecords = ArrayHelper.asArray(taskRecord);\n\n        /**\n         * Triggered when one or more tasks are to be removed by a call to `removeTask()`.\n         *\n         * The UI routes through `removeTask()` (currently only the task menu offers task removal), this event can be\n         * used to add a confirmation flow or similar to those actions.\n         *\n         * Return `false` or a promise that resolves to `false` in a listener to prevent removal.\n         *\n         * ```javascript\n         * taskBoard.on({\n         *     async beforeRemoveTask() {\n         *         const result = await askForConfirmation();\n         *         return result;\n         *     }\n         * });\n         * ```\n         *\n         * @event beforeTaskRemove\n         * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n         * @param {TaskBoard.model.TaskModel[]} taskRecords Task records to be removed\n         * @preventable\n         * @async\n         */\n        if (await this.trigger('beforeTaskRemove', { taskRecords }) !== false) {\n            this.project.taskStore.remove(taskRecords);\n            return true;\n        }\n\n        return false;\n    }\n\n    //endregion\n};\n", "import Base from '../../../Core/Base.js';\nimport Store from '../../../Core/data/Store.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport SwimlaneModel from '../../model/SwimlaneModel.js';\n\n/**\n * @module TaskBoard/view/mixin/TaskBoardSwimlanes\n */\n\n/**\n * Mixin that handles swimlanes for the TaskBoard.\n *\n * @mixin\n */\nexport default Target => class TaskBoardSwimlanes extends (Target || Base) {\n\n    //region Config\n\n    static $name = 'TaskBoardSwimlanes';\n\n    static configurable = {\n        /**\n         * Store containing the TaskBoard swimlanes.\n         *\n         * @member {Core.data.Store} swimlanes\n         * @category Common\n         */\n        /**\n         * Store containing the TaskBoard swimlanes. A tasks {@link #config-swimlaneField} is matched against the `id`\n         * of a swimlane to determine in which swimlane it is displayed.\n         *\n         * Accepts an array of swimlane records/objects, a store instance, a store id or a store config object used to\n         * create a new store.\n         *\n         * When supplying an array, a store configured with {@link Core.data.mixin.StoreProxy#config-objectify} is\n         * automatically created. Using that config allows for a nicer interaction syntax with the swimlanes:\n         *\n         * ```javascript\n         * // Without objectify:\n         * taskBoard.swimlanes.getById('highprio').text = 'Important!';\n         *\n         * // With objectify:\n         * taskBoard.swimlanes.done.text = 'Finished';\n         * ```\n         *\n         * When supplying strings, the raw string will be used as the swimlanes `id` and a capitalized version of it is\n         * used as the swimlanes text:\n         *\n         * ```javascript\n         * taskBoard = new TaskBoard({\n         *    swimlanes : [\n         *        'high',\n         *        'low'\n         *    ]\n         * });\n         * ```\n         *\n         * Is equivalent to:\n         *\n         * ```javascript\n         * taskBoard = new TaskBoard({\n         *    swimlanes : [\n         *        { id : 'high', text : 'High' },\n         *        { id : 'low', text : 'Low' }\n         *    ]\n         * });\n         * ```\n         *\n         * @config {TaskBoard.model.SwimlaneModel[]|SwimlaneModelConfig[]|Core.data.Store|String|StoreConfig}\n         * @category Common\n         */\n        swimlanes : {},\n\n        /**\n         * Set to `true` to auto generate swimlanes when {@link #config-swimlanes} is undefined.\n         *\n         * A swimlane will be created for each distinct value of {@link #config-swimlaneField} on the tasks. The\n         * swimlanes will be sorted in alphabetical order. The following snippet will yield two swimlanes, Q1 and Q2:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    swimlaneField : 'quarter',\n         *\n         *    autoGenerateSwimlanes : true,\n         *\n         *    project : {\n         *        tasksData : [\n         *            { id : 1, name : 'Inform tenants', quarter : 'Q1' },\n         *            { id : 2, name : 'Renovate roofs', quarter : 'Q2' }\n         *        ]\n         *    }\n         * });\n         * ```\n         *\n         * @config {Boolean}\n         * @category Advanced\n         */\n        autoGenerateSwimlanes : false,\n\n        /**\n         * Field on a task record used to determine which swimlane the task belongs to.\n         *\n         * ```javascript\n         * taskBoard.swimlaneField = 'category';\n         * ```\n         *\n         * @member {String} swimlaneField\n         * @category Common\n         */\n        /**\n         * Field on a task record used to determine which swimlane the task belongs to.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    // Use the \"prio\" field of tasks to determie which swimlane a task belongs to\n         *    swimlaneField : 'prio',\n         *\n         *    swimlanes : [\n         *        'high',\n         *        'low'\n         *    ],\n         *\n         *    project : {\n         *        tasksData : [\n         *            // Linked using the prio field, to the high swimlane\n         *            { id : 1, name : 'Fun task', prio : 'high' }\n         *        ]\n         *    }\n         * });\n         * ```\n         *\n         * @config {String}\n         * @category Common\n         */\n        swimlaneField : null\n    };\n\n    static properties = {\n        shouldAutoGenerateSwimlanes : false\n    };\n\n    get widgetClass() {}\n\n    //endregion\n\n    //region Type assertions\n\n    changeAutoGenerateSwimlanes(autoGenerateSwimlanes) {\n        ObjectHelper.assertBoolean(autoGenerateSwimlanes, 'autoGenerateSwimlanes');\n\n        return autoGenerateSwimlanes;\n    }\n\n    changeSwimlaneField(swimlaneField) {\n        ObjectHelper.assertString(swimlaneField, 'swimlaneField');\n\n        return swimlaneField;\n    }\n\n    //endregion\n\n    //region Config - swimlaneField\n\n    updateSwimlaneField(field, old) {\n        if (old) {\n            const { storage } = this.project.taskStore;\n\n            if (old !== this.columnField) {\n                storage.removeIndex(old);\n            }\n            storage.addIndex({ property : field, unique : false });\n        }\n\n        this.shouldAutoGenerateSwimlanes = field && this.autoGenerateSwimlanes;\n    }\n\n    //endregion\n\n    //region Config - swimlanes\n\n    changeSwimlanes(swimlanes) {\n        return Store.from(swimlanes, { objectify : true, modelClass : SwimlaneModel }, lane => {\n            if (typeof lane === 'string') {\n                return { id : lane, text : StringHelper.capitalize(lane) };\n            }\n\n            return lane;\n        });\n    }\n\n    updateSwimlanes(swimlanes) {\n        this.detachListeners('swimlanes');\n\n        if (swimlanes) {\n            // Link to us to be able to retrieve tasks in visual order\n            // $store is the store instance of an objectified store\n            (swimlanes.$store || swimlanes).taskBoard = this;\n\n            swimlanes.ion({\n                change  : 'onSwimlanesChange',\n                refresh : 'onSwimlanesChange',\n                thisObj : this\n            });\n        }\n    }\n\n    get swimlanes() {\n        const\n            me            = this,\n            { taskStore } = me.project;\n\n        // If there are no swimlanes defined but we have a swimlane field configured and we have tasks loaded, generate\n        // swimlanes from the tasks\n        if (me.shouldAutoGenerateSwimlanes && taskStore.count) {\n            me.swimlanes = taskStore.getDistinctValues(me.swimlaneField).sort();\n            me.shouldAutoGenerateSwimlanes = false;\n        }\n\n        return me._swimlanes;\n    }\n\n    onSwimlanesChange({ action }) {\n        // CRUD invalidates column/swimlane intersection index\n        if (action === 'add' || action === 'remove' || action === 'removeAll' || action === 'update') {\n            this.project.taskStore.storage.invalidateIndices();\n        }\n\n        if (action === 'remove' ||  action === 'update' || action === 'filter') {\n            const options = {};\n\n            if (action === 'update') {\n                options.addTransition = { height : 1, opacity : 1 };\n                options.removeTransition = { height : 1, opacity : 1 };\n            }\n\n            this.recomposeWithDomTransition(options);\n            return;\n        }\n\n        this.recompose();\n    }\n\n    //endregion\n\n    //region Data\n\n    get hasSwimlanes() {\n        return Boolean(this.swimlaneField && this.swimlanes?.count);\n    }\n\n    getSwimlaneTasks(swimlaneRecord) {\n        return this.project.taskStore.storage.findItem(this.swimlaneField, swimlaneRecord.id);\n    }\n\n    getSwimlane(taskRecord) {\n        return this.swimlaneField && this.swimlanes?.getById(taskRecord.getValue(this.swimlaneField));\n    }\n\n    //endregion\n\n};\n", "import Base from '../../../Core/Base.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n\n/**\n * @module TaskBoard/view/mixin/TaskBoardVirtualization\n */\n\n/**\n * Mixin that handles partial virtualization for the TaskBoard.\n * See class docs for {@link TaskBoard/view/TaskBoard} for more information.\n *\n * @mixin\n */\nexport default Target => class TaskBoardVirtualization extends (Target || Base) {\n\n    //region Config\n\n    static $name = 'TaskBoardVirtualization';\n\n    static configurable = {\n        /**\n         * The function is called for each task as part of the render loop, and is expected to return the height in\n         * pixels for the task. Using this function is only recommended when using partial virtualized rendering, see\n         * the {@link #config-virtualize} setting.\n         *\n         * How the height is determined is up to the application, it could for example return a fixed value:\n         *\n         * ```javascript\n         * taskBoard = new TaskBoard({\n         *     getTaskHeight() {\n         *         return 150;\n         *     }\n         * }\n         * ```\n         *\n         * Or get the height from data:\n         *\n         * ```javascript\n         * taskBoard = new TaskBoard({\n         *     getTaskHeight({ taskRecord }) {\n         *         return taskRecord.myTaskHeight;\n         *     }\n         * }\n         * ```\n         *\n         * Or use some custom application logic:\n         *\n         * ```javascript\n         * taskBoard = new TaskBoard({\n         *     getTaskHeight({ taskRecord }) {\n         *         if (taskRecord.isCollapsed) {\n         *             return 20;\n         *         }\n         *\n         *         return taskRecord.myTaskHeight;\n         *     }\n         * }\n         * ```\n         *\n         * @prp {Function}\n         * @param {Object} data\n         * @param {TaskBoard.model.TaskModel} data.taskRecord The task record\n         * @return {Number} The height of the task in pixels\n         * @category Advanced\n         */\n        getTaskHeight : null,\n\n        /**\n         * By turning on this setting you enable partial virtualized rendering for the board, which reduces initial\n         * rendering time and makes interaction less sluggish when using thousands of tasks. The tradeoff is that\n         * scrolling in most cases will be slower.\n         *\n         * For a nice UX, it is strongly recommended to also implement a {@link #config-getTaskHeight} function. Without\n         * it, the height of tasks out of view will be unknown and the behaviour when scrolling will be less than ideal.\n         *\n         * <div class=\"note\">Note that for normal datasets (depending on machine, but roughly <1000 tasks) performance\n         * might be better without partial virtualized rendering, since it adds some overhead.</div>\n         *\n         * <div class=\"note\">Also note that as part of the optimizations for partial virtualized rendering, the inner\n         * element in columns that contain cards is absolutely positioned. This leads to column not being able to\n         * automatically shrink wrap the cards, you will have to set a height on the swimlane (or task board if not\n         * using swimlanes) to size things correctly.</div>\n         *\n         * @prp {Boolean}\n         */\n        virtualize : {\n            value   : null,\n            $config : 'nullify'\n        },\n\n        /**\n         * Whether to draw cards on scroll, or only when scrolling ends.\n         *\n         * Only applies when using partial virtualized rendering (see {@link #config-getTaskHeight}).\n         *\n         * Setting this to `false` will boost scroll performance, but cards scrolled into view will be empty outlines\n         * until scrolling ends.\n         *\n         * @prp {Boolean}\n         */\n        drawOnScroll : true\n    };\n\n    get widgetClass() {}\n\n    //endregion\n\n    //region Type assertions and changers/updaters\n\n    changeVirtualize(virtualize) {\n        ObjectHelper.assertBoolean(virtualize, 'virtualize');\n\n        return virtualize;\n    }\n\n    updateVirtualize(virtualize) {\n        const me = this;\n\n        me.cardIntersectionObserver?.disconnect();\n        me.cardIntersectionObserver = null;\n\n        if (virtualize) {\n            // Observes cards coming into / out of view.\n            // Elements to observe are added from TaskBoardDomEvents#domSyncCallback\n            me.cardIntersectionObserver = new IntersectionObserver(entries => {\n                for (const entry of entries) {\n                    me.onCardIntersection(entry.target, entry.isIntersecting, entry);\n                }\n            });\n        }\n\n        // Allow toggling at runtime (mainly for bigdataset demo)\n        if (!this.isConfiguring && !this.isDestroying) {\n            this.refreshVirtualizedCards();\n        }\n    }\n\n    refreshVirtualizedCards() {\n        const me = this;\n\n        me.recompose.now();\n\n        if (me.cardIntersectionObserver) {\n            for (const taskElement of me.element.querySelectorAll('.b-taskboard-card')) {\n                me.cardIntersectionObserver.observe(taskElement);\n            }\n        }\n    }\n\n    changeGetTaskHeight(getTaskHeight) {\n        getTaskHeight && ObjectHelper.assertFunction(getTaskHeight, 'getTaskHeight');\n\n        return getTaskHeight;\n    }\n\n    updateGetTaskHeight(fn) {\n        // Allow toggling at runtime (mainly for bigdataset demo)\n        if (!this.isConfiguring && !this.isDestroying) {\n            this.refreshVirtualizedCards();\n        }\n    }\n\n    //endregion\n\n    compose(domConfig) {\n        domConfig.class['b-virtualized'] = this.isVirtualized;\n\n        return super.compose(domConfig);\n    }\n\n    get isVirtualized() {\n        return Boolean(this.cardIntersectionObserver);\n    }\n\n    // Flag cards as in view or out of view when their elements are intersecting the viewport (or not anymore)\n    onCardIntersection(cardElement, isIntersecting, entry) {\n        const\n            me              = this,\n            { taskRecord }  = cardElement.elementData,\n            instanceMeta    = taskRecord.instanceMeta(me),\n            wasIntersecting = instanceMeta.intersects;\n\n        if (wasIntersecting !== isIntersecting) {\n            instanceMeta.intersects = isIntersecting;\n            if (!isIntersecting && wasIntersecting) {\n                instanceMeta.lastHeight = entry.boundingClientRect.height;\n            }\n            // Recompose affected column right away if not scrolling, or if configured to draw on scroll\n            if (!me.isScrolling || me.drawOnScroll) {\n                me.queueColumnRecompose(me.getColumn(taskRecord), me.getSwimlane(taskRecord));\n            }\n\n            // Always do a full recompose when scrolling ends, to have all lastDomConfigs up to date\n            if (me.isScrolling) {\n                me.recomposeOnScrollEnd = true;\n            }\n        }\n    }\n\n    //region Rendering\n\n    // Creates a DOM config for the outline of a single card\n    renderCardOutline(taskRecord, columnRecord, swimlaneRecord) {\n        const\n            me                    = this,\n            { id, domId, weight } = taskRecord;\n\n        return {\n            id    : `${me.id}-card-${domId}`,\n            class : {\n                'b-taskboard-card' : true,\n                'b-out-of-view'    : true\n            },\n            tabIndex : 0,\n            dataset  : {\n                task          : domId,\n                column        : columnRecord.id,\n                lane          : swimlaneRecord?.id,\n                weight,\n                domTransition : true\n            },\n            elementData : {\n                elementType : 'task',\n                taskId      : id,\n                taskRecord,\n                columnRecord,\n                swimlaneRecord\n            },\n            style : {\n                height : me.getTaskHeight?.(taskRecord) || taskRecord.instanceMeta(me).lastHeight\n            }\n        };\n    }\n\n    // Overrides renderCard in TaskBoardBase, rendering outlines for cards out of view\n    renderCard(taskRecord, columnRecord, swimlaneRecord) {\n        const\n            { isVirtualized } = this,\n            meta              = taskRecord.instanceMeta(this);\n\n        // Render outlines for cards out of view when using virtualization\n        if (isVirtualized && !meta.dragging && !meta.intersects && !this.isSelected(taskRecord)) {\n            return this.renderCardOutline(taskRecord, columnRecord, swimlaneRecord);\n        }\n    }\n\n    //endregion\n};\n", "import TaskItem from './TaskItem.js';\n\n/**\n * @module TaskBoard/view/item/TextItem\n */\n\n/**\n * Item that displays the value of the configured {@link #config-field} in a XSS safe way.\n *\n * {@inlineexample TaskBoard/view/item/TextItem.js}\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classType text\n */\nexport default class TextItem extends TaskItem {\n    static $name = 'TextItem';\n\n    static type = 'text';\n\n    static render({ domConfig, value, taskRecord, config }) {\n        // Special handling when bound to id\n        if (config.field === 'id' && taskRecord.hasGeneratedId) {\n            domConfig.class['b-generated-id'] = 1;\n            domConfig.text = '✻';\n        }\n        else {\n            domConfig.text = taskRecord.getFieldDefinition(config.field).print(value);\n        }\n    }\n}\n\nTextItem.initClass();\n", "import TaskItem from './TaskItem.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport AvatarRendering from '../../../Core/widget/util/AvatarRendering.js';\n\n/**\n * @module TaskBoard/view/item/ResourceAvatarsItem\n */\n\n/**\n * Item displaying avatars or initials for a tasks assigned resources.\n *\n * {@inlineexample TaskBoard/view/item/ResourceAvatarsItem.js}\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classType resourceAvatars\n */\nexport default class ResourceAvatarsItem extends TaskItem {\n    static $name = 'ResourceAvatarsItem';\n\n    static type = 'resourceAvatars';\n\n    /**\n     * Maximum avatars to display by default. The last avatar will render an overflow indicator if the task has more\n     * resources assigned.\n     *\n     * ```javascript\n     * const taskBoard = new TaskBoard({\n     *     headerItems : {\n     *         resources : {\n     *             type       : 'resourceAvatars',\n     *             maxAvatars : 5\n     *         }\n     *     }\n     * });\n     * ```\n     *\n     * Overridden by card size based settings, see {@link TaskBoard.view.mixin.ResponsiveCards}.\n     *\n     * @config {Number} maxAvatars\n     * @default 7\n     * @category Common\n     */\n\n    /**\n     * Specify `true` to slightly overlap avatars for tasks that have multiple resources assigned. By default, they are\n     * displayed side by side.\n     *\n     * ```javascript\n     * const taskBoard = new TaskBoard({\n     *     headerItems : {\n     *         resources : {\n     *             overlap : true\n     *         }\n     *     }\n     * });\n     * ```\n     *\n     * @config {Boolean} overlap\n     */\n\n    /**\n     * Widget type or config to use as the editor for this item. Used in the inline task editor.\n     *\n     * Defaults to use a {@link TaskBoard.widget.ResourcesCombo}.\n     *\n     * @config {String|Object} editor\n     * @default resourcescombo\n     * @category Common\n     */\n    static defaultEditor = { type : 'resourcescombo', pickerWidth : '13em' };\n\n    static render({ taskBoard, domConfig, config, taskRecord, cardSize }) {\n        const\n            maxAvatars            = cardSize?.maxAvatars ?? config.maxAvatars ?? 7,\n            { resourceImagePath } = taskBoard,\n            { resources }         = taskRecord,\n            hasOverflow           = resources.length > maxAvatars,\n            overflowCount         = resources.length - maxAvatars + 1,\n            lastResource          = resources[maxAvatars];\n\n        let { avatarRendering } = taskBoard;\n\n        if (!avatarRendering) {\n            avatarRendering = taskBoard.avatarRendering = new AvatarRendering({\n                element     : taskBoard.element,\n                colorPrefix : 'b-taskboard-background-color-'\n            });\n        }\n\n        if (!taskBoard.project.resourceStore.count) {\n            return false;\n        }\n\n        ObjectHelper.merge(domConfig, {\n            class : {\n                'b-overlap' : config.overlap\n            },\n            children : [\n                // \"Normal\" avatars\n                ...resources\n                    // Want a stable order for resource to not move around on changes\n                    .sort((a, b) => a.name.localeCompare(b.name))\n                    .slice(0, maxAvatars - (hasOverflow ? 1 : 0)) // -1 for the overflow indicator\n                    .map((resource, i) => ({\n                        class : {\n                            'b-taskboard-resource-avatar-wrap' : 1\n                        },\n                        dataset : {\n                            resourceId : resource.id\n                        },\n                        children : [\n                            avatarRendering.getResourceAvatar({\n                                resourceRecord : resource,\n                                imageUrl       : resource.image === false ? null : (resource.imageUrl || resource.image && ((resourceImagePath || '') + resource.image)),\n                                initials       : resource.initials,\n                                color          : resource.eventColor,\n                                dataset        : {\n                                    btip : StringHelper.encodeHtml(resource.name)\n                                }\n                            })\n                        ]\n                    })),\n                // Overflow indicating avatar\n                hasOverflow && {\n                    class : {\n                        'b-taskboard-resource-avatar-overflow' : 1\n                    },\n                    dataset : {\n                        resourceId : '$overflow',\n                        btip       : resources.slice(-overflowCount).map(r => StringHelper.encodeHtml(r.name)).join(', '),\n                        count      : overflowCount\n                    },\n                    children : [\n                        avatarRendering.getResourceAvatar({\n                            resourceRecord : lastResource,\n                            imageUrl       : lastResource.image === false ? null : (lastResource.imageUrl || lastResource.image && (resourceImagePath + lastResource.image)),\n                            initials       : lastResource.initials\n                        })\n                    ]\n                }\n            ],\n            syncOptions : {\n                syncIdField : 'resourceId'\n            }\n        });\n    }\n\n    static onClick({ source : taskBoard, taskRecord, event }) {\n        const element = event.target.closest('.b-resource-avatar, .b-taskboard-resource-avatar-overflow');\n\n        if (element) {\n            if (element.matches('.b-resource-avatar')) {\n                const resourceRecord = taskBoard.project.resourceStore.getById(element.dataset.resourceId);\n                taskBoard.trigger('resourceAvatarClick', { resourceRecord, taskRecord, element, event });\n            }\n            else {\n                taskBoard.trigger('resourceAvatarOverflowClick', { taskRecord, element, event });\n            }\n\n            return false;\n        }\n    }\n}\n\nResourceAvatarsItem.initClass();\n", "import Base from '../../../Core/Base.js';\nimport TaskItem from '../item/TaskItem.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\n\n// Items used by default\nimport '../item/TextItem.js';\nimport '../item/ResourceAvatarsItem.js';\n\n/**\n * @module TaskBoard/view/mixin/TaskItems\n */\n\nconst\n    fieldLess        = {\n        resourceAvatars : 1,\n        separator       : 1,\n        taskMenu        : 1\n    },\n    taskItemSelector = '.b-taskboard-taskitem',\n    afterRe          = /\\s*<\\s*/,\n    beforeRe         = /\\s*>\\s*/;\n\n/**\n * Mixin that allows adding multiple predefined items (sort of like task widgets) to tasks:\n *\n * {@inlineexample TaskBoard/view/mixin/TaskItems.js}\n *\n * You can pick from the following item types:\n *\n * * {@link TaskBoard/view/item/ImageItem image}\n * * {@link TaskBoard/view/item/ProgressItem progress}\n * * {@link TaskBoard/view/item/RatingItem rating}\n * * {@link TaskBoard/view/item/ResourceAvatarsItem resourceAvatars}\n * * {@link TaskBoard/view/item/SeparatorItem separator}\n * * {@link TaskBoard/view/item/TagsItem tags}\n * * {@link TaskBoard/view/item/TemplateItem template}\n * * {@link TaskBoard/view/item/TextItem text}\n * * {@link TaskBoard/view/item/TodoListItem todoList}\n *\n * All of which are included in this demo:\n *\n * {@inlineexample TaskBoard/view/mixin/TaskItemsAll.js}\n *\n * ## Configuring which items to use\n *\n * Task cards are divided into three sections, header, body and footer. Each section can hold items. The following items\n * are defined by default:\n *\n * | Section     | Key             | Type                                                            | Bound to           |\n * |-------------|-----------------|-----------------------------------------------------------------|--------------------|\n * | headerItems | text            | {@link TaskBoard/view/item/TextItem text}                       | name               |\n * | bodyItems   | text            | {@link TaskBoard/view/item/TextItem text}                       | description        |\n * | footerItems | resourceAvatars | {@link TaskBoard/view/item/ResourceAvatarsItem resourceAvatars} | assigned resources |\n *\n * Add items to tasks by supplying the {@link #config-bodyItems bodyItems config} (the other sections work the same):\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     bodyItems : {\n *         // Will use \"prio\" as its field\n *         prio  : { type : 'text' },\n *         // Will use \"status\" as its field\n *         state : { type : 'text', field : 'status' }\n *     }\n * });\n * ```\n *\n * The items you supply are merged with the predefined items (as listed in the table above).\n *\n * The only always required config for new items is `type`, which determines what kind of task item to use. Which other\n * configs you can use depends on the item type.\n *\n * By default the key in the `items` object will be used to link the item to a field on a task. You can override the\n * default by using the `field` config.\n *\n * To rearrange items, specify the {@link TaskBoard/view/item/TaskItem#config-order} config of each item. Applied as\n * flex order.\n *\n * You can also add items to a tasks header and footer, using {@link #config-headerItems} and\n * {@link #config-footerItems}.\n *\n * ## Manipulating items per task\n *\n * You can manipulate which items are shown for a task by supplying a {@link #config-processItems} function. It will be\n * called during rendering for each task and in it you can manipulate the passed `bodyItems` object. Set a property of\n * it to `null` to remove that item for that task:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     bodyItems : {\n *         progress  : { type : 'progress' }\n *     },\n *\n *     processItems({ taskRecord, bodyItems }) {\n *         if (taskRecord.status === 'done') {\n *             bodyItems.progress = null;\n *         }\n *     }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/view/mixin/TaskItemsProcessItems.js}\n *\n * @mixin\n */\nexport default Target => class TaskItems extends (Target || Base) {\n\n    //region Config\n\n    static $name = 'TaskItems';\n\n    static configurable = {\n        /**\n         * Items in card header.\n         *\n         * As an object keyed by field names, values are {@link TaskBoard/view/item/TaskItem#configs TaskItem configs}.\n         *\n         * Reassigning this property merges the supplied object with the configured items:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    headerItems : {\n         *        status : { type : 'text' }\n         *    }\n         * });\n         *\n         * taskBoard.headerItems = {\n         *     status : { hidden : true },\n         *     tags   : { type : 'tags' }\n         * };\n         *\n         * // Results in:\n         * //\n         * // headerItems = {\n         * //     status : { type : 'text', hidden: true }\n         * //     tags   : { type : 'tags' }\n         * // }\n         * }\n         * ```\n         *\n         * @member {Object<String,TaskItemOptions>} headerItems\n         * @category Task content\n         */\n\n        /**\n         * Items to add to each card's header.\n         *\n         * Supplied keys are used to bind to a field on the {@link TaskBoard/model/TaskModel task record}, supplied\n         * values are used to configure the {@link TaskBoard/view/item/TaskItem#configs items}.\n         *\n         * You are always required to supply a `type`, see the docs for each item type for more information on available\n         * configs.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    headerItems : {\n         *        status : { type : 'text' }\n         *    }\n         * });\n         * ```\n         *\n         * For more information, see the {@link #class-description class description} above.\n         *\n         * @config {Object<String,TaskItemOptions>}\n         * @category Task content\n         */\n        headerItems : {\n            value : {\n                text : { type : 'text', field : 'name' }\n            },\n\n            $config : {\n                merge : 'items'\n            }\n        },\n\n        /**\n         * Items to add to each card's body.\n         *\n         * As an object keyed by field names, values are {@link TaskBoard/view/item/TaskItem#configs TaskItem configs}.\n         *\n         * Reassigning this property merges the supplied object with the configured items:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    bodyItems : {\n         *        status : { type : 'text' }\n         *    }\n         * });\n         *\n         * taskBoard.bodyItems = {\n         *     status : { hidden : true },\n         *     tags   : { type : 'tags' }\n         * };\n         *\n         * // Results in:\n         * //\n         * // bodyItems = {\n         * //     status : { type : 'text', hidden: true }\n         * //     tags   : { type : 'tags' }\n         * // }\n         * }\n         * ```\n         *\n         * @member {Object<String,TaskItemOptions>} bodyItems\n         * @category Task content\n         */\n\n        /**\n         * Items to add to each card's body.\n         *\n         * Supplied keys are used to bind to a field on the {@link TaskBoard/model/TaskModel task record}, supplied\n         * values are used to configure the {@link TaskBoard/view/item/TaskItem#configs items}.\n         *\n         * You are always required to supply a `type`, see the docs for each item type for more information on available\n         * configs.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    bodyItems : {\n         *        status : { type : 'text' }\n         *    }\n         * });\n         * ```\n         *\n         * For more information, see the {@link #class-description class description} above.\n         *\n         * @config {Object<String,TaskItemOptions>}\n         * @category Task content\n         */\n        bodyItems : {\n            value : {\n                text : { type : 'text', field : 'description' }\n            },\n\n            $config : {\n                merge : 'items'\n            }\n        },\n\n        /**\n         * Items in card footer.\n         *\n         * As an object keyed by field names, values are {@link TaskBoard/view/item/TaskItem#configs TaskItem configs}.\n         *\n         * Reassigning this property merges the supplied object with the configured items:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    footerItems : {\n         *        status : { type : 'text' }\n         *    }\n         * });\n         *\n         * taskBoard.footerItems = {\n         *     status : { hidden : true },\n         *     tags   : { type : 'tags' }\n         * };\n         *\n         * // Results in:\n         * //\n         * // footerItems = {\n         * //     status : { type : 'text', hidden: true }\n         * //     tags   : { type : 'tags' }\n         * // }\n         * }\n         * ```\n         *\n         * @member {Object<String,TaskItemOptions>} footerItems\n         * @category Task content\n         */\n\n        /**\n         * Items to add to each card's footer.\n         *\n         * Supplied keys are used to bind to a field on the {@link TaskBoard/model/TaskModel task record}, supplied\n         * values are used to configure the {@link TaskBoard/view/item/TaskItem#configs items}.\n         *\n         * You are always required to supply a `type`, see the docs for each item type for more information on available\n         * configs.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    footerItems : {\n         *        status : { type : 'text' }\n         *    }\n         * });\n         * ```\n         *\n         * For more information, see the {@link #class-description class description} above.\n         *\n         * @config {Object<String,TaskItemOptions>}\n         * @category Task content\n         */\n        footerItems : {\n            value : {\n                resourceAvatars : { type : 'resourceAvatars', field : 'resources' }\n            },\n\n            $config : {\n                merge : 'items'\n            }\n        },\n\n        /**\n         * A function called on each render before adding items to a tasks card, allowing runtime manipulation of them.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     processItems({ bodyItems, taskRecord }) {\n         *        // Remove the progress item for done tasks\n         *        if (taskRecord.status === 'done') {\n         *            bodyItems.progress = null;\n         *        }\n         *     }\n         * });\n         * ```\n         *\n         * NOTE: The function is only intended for manipulating the passed items, you should not update the passed\n         * `taskRecord` in it since updating records triggers another round of rendering.\n         *\n         * @param {Object} context\n         * @param {Object<String,TaskItemOptions>} context.headerItems Item config objects for the task header, keyed by ref\n         * @param {Object<String,TaskItemOptions>} context.bodyItems Item config objects for the task body, keyed by ref\n         * @param {Object<String,TaskItemOptions>} context.footerItems Item config objects for the task footer, keyed by ref\n         * @param {TaskBoard.model.TaskModel} context.taskRecord Record representing task to be rendered\n         * @config {Function}\n         * @category Task content\n         */\n        processItems : null\n    };\n\n    get widgetClass() {}\n\n    //endregion\n\n    //region Type assertions\n\n    changeProcessItems(processItems) {\n        ObjectHelper.assertFunction(processItems, 'processItems');\n\n        return processItems;\n    }\n\n    //endregion\n\n    // region Configuring items\n\n    // <remove-on-release>\n    // TODO: Discuss with Don. Cant the merge on the config be active always?\n    // </remove-on-release>\n    mergeItems(items, old) {\n        if (old && items) {\n            items = ObjectHelper.mergeItems(old, items);\n        }\n\n        return items;\n    }\n\n    // Needed to allow reconfiguring on the fly (for responsive)\n    changeHeaderItems(items, old) {\n        ObjectHelper.assertObject(items, 'headerItems');\n\n        return this.mergeItems(items, old);\n    }\n\n    // Needed to allow reconfiguring on the fly (for responsive)\n    changeBodyItems(items, old) {\n        ObjectHelper.assertObject(items, 'bodyItems');\n\n        return this.mergeItems(items, old);\n    }\n\n    // Needed to allow reconfiguring on the fly (for responsive)\n    changeFooterItems(items, old) {\n        ObjectHelper.assertObject(items, 'footerItems');\n\n        return this.mergeItems(items, old);\n    }\n\n    //endregion\n\n    //region Rendering\n\n    // Render items to header, body or footer of the supplied task\n    renderItems(taskRecord, items, target, cardSize) {\n        for (const key in items) {\n            const config = items[key];\n            if (config && !config.hidden) {\n                // Defaults to use the key as the field, but allows overriding it using the field config\n                if (!('field' in config)) {\n                    if (key.includes('>')) {\n                        [config.field] = key.split(beforeRe);\n                    }\n                    else if (key.includes('<')) {\n                        [, config.field] = key.split(afterRe);\n                    }\n                    else {\n                        config.field = key;\n                    }\n                }\n\n                const\n                    { field } = config,\n                    value     = taskRecord.getValue(field);\n\n                // Most fields render nothing if they have no value, some are excluded from that logic (separator etc)\n                if (value != null || fieldLess[config.type]) {\n                    const\n                        // TaskItem implements factoryable, we are not using instances but rather static items to avoid\n                        // creating one instance per card. Thus we only use the lookup functionality of factoryable\n                        item      = TaskItem.resolveType(config.type),\n                        typeCls   = `b-taskboard-${StringHelper.hyphenate(config.type)}`,\n                        // Base DomConfig, shared by all task items\n                        domConfig = {\n                            class : {\n                                'b-taskboard-taskitem' : 1,\n                                [typeCls]              : 1,\n                                [config.cls]           : config.cls,\n                                'b-editable'           : !taskRecord.readOnly && item.getEditorConfig({ config, item })\n                            },\n                            dataset : {\n                                role : `item-${field}`,\n                                field,\n                                ref  : key\n                            },\n                            elementData : {\n                                item,\n                                taskRecord,\n                                config\n                            },\n                            style : {\n                                order : config.order,\n                                style : config.style\n                            }\n                        },\n                        // Call items (static) renderer, further populating the DomConfig from above\n                        result    = item.render({ taskBoard : this, domConfig, value, config, taskRecord, cardSize });\n\n                    // Returning false from an items renderer prevents it from being shown\n                    if (result !== false) {\n                        target.children[key] = domConfig;\n                    }\n                }\n            }\n        }\n    }\n\n    // Hook into card rendering\n    populateCard(args) {\n        super.populateCard?.(args);\n\n        const\n            me                                   = this,\n            { processItems }                     = me,\n            { taskRecord, cardConfig, cardSize } = args,\n            {\n                headerItems : sizeHeaderItems,\n                bodyItems   : sizeBodyItems,\n                footerItems : sizeFooterItems\n            }                                    = cardSize || {},\n            { header, body, footer }             = cardConfig.children;\n\n        let { headerItems, bodyItems, footerItems } = me;\n\n        // Items are shared between all cards, clone before processing to only affect the set for this card\n        if (sizeHeaderItems || processItems) {\n            headerItems = ObjectHelper.clone(headerItems);\n        }\n\n        if (sizeBodyItems || processItems) {\n            bodyItems = ObjectHelper.clone(bodyItems);\n        }\n\n        if (sizeFooterItems || processItems) {\n            footerItems = ObjectHelper.clone(footerItems);\n        }\n\n        // Apply any card size specific items\n        sizeHeaderItems && ObjectHelper.merge(headerItems, sizeHeaderItems);\n        sizeBodyItems && ObjectHelper.merge(bodyItems, sizeBodyItems);\n        sizeFooterItems && ObjectHelper.merge(footerItems, sizeFooterItems);\n\n        // Allow app a shot at processing the items before they are shown. Can be used to add or remove items and\n        // manipulate configs\n        processItems?.({ headerItems, bodyItems, footerItems, taskRecord, cardSize });\n\n        // Render items into card header, body and footer\n        me.renderItems(taskRecord, headerItems, header, cardSize);\n        me.renderItems(taskRecord, bodyItems, body, cardSize);\n        me.renderItems(taskRecord, footerItems, footer, cardSize);\n    }\n\n    //endregion\n\n    //region Listeners\n\n    resolveTaskItem(element) {\n        // First look up, if inside an item. Then looks down, in case given a card or similar\n        const taskItemElement = element.closest(taskItemSelector) || element.querySelector(`:scope > * > ${taskItemSelector}, :scope > ${taskItemSelector}`);\n\n        if (taskItemElement) {\n            return {\n                ...taskItemElement.elementData,\n                element : taskItemElement\n            };\n        }\n\n        return null;\n    }\n\n    // Relay clicks to items\n    onTaskClick(args) {\n        const taskItem = this.resolveTaskItem(args.event.target);\n\n        if (taskItem) {\n            const { config, item  } = taskItem;\n\n            item.onClick?.({\n                config,\n                ...args\n            });\n        }\n\n        super.onTaskClick(args);\n    }\n\n    // Relay double clicks to items\n    onTaskDblClick(args) {\n        const taskItem = this.resolveTaskItem(args.event.target);\n\n        if (taskItem) {\n            const { config, item  } = taskItem;\n\n            item.onDblClick?.({\n                config,\n                ...args\n            });\n        }\n\n        super.onTaskDblClick(args);\n    }\n\n    //endregion\n\n};\n", "import Base from '../../../Core/Base.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\n\n/**\n * @module TaskBoard/view/mixin/TaskNavigation\n */\n\nconst navigationActions = ['navigateDown', 'navigateLeft', 'navigateUp', 'navigateRight', 'activate'];\n\n/**\n * Mixin that handles keyboard navigation for the TaskBoard.\n *\n * See {@link TaskBoard.view.TaskBoard#keyboard-shortcuts} for information on keyboard navigation.\n *\n * @mixin\n */\nexport default Target => class TaskNavigation extends (Target || Base) {\n\n    //region Config\n\n    static $name = 'TaskNavigation';\n\n    static configurable = {\n        // Documented on TaskBoard\n        keyMap : {\n            ArrowDown  : 'navigateDown',\n            ArrowLeft  : 'navigateLeft',\n            ArrowUp    : 'navigateUp',\n            ArrowRight : 'navigateRight',\n            Enter      : 'activate'\n        },\n\n        navigateable : true,\n\n        /**\n         * Configure with `true` to change the default behaviour of keyboard navigation from moving focus to selecting\n         * tasks:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     selectOnNavigation : true\n         * });\n         * ```\n         *\n         * @config {Boolean|String}\n         * @default\n         * @category Selection\n         */\n        selectOnNavigation : false\n    };\n\n    get widgetClass() {}\n\n    //endregion\n\n    //region Utility\n\n    getTaskNear(x, y) {\n        const\n            { documentRoot } = this,\n            gap              = DomHelper.measureSize(\n                this.css.cardGap || '1em',\n                this.bodyElement.querySelector('.b-taskboard-swimlane-body .b-taskboard-column')\n            );\n\n        let task = documentRoot.elementFromPoint(x, y)?.closest('.b-taskboard-card');\n\n        // Nothing there, might have hit a gap, look up\n        if (!task) {\n            task = documentRoot.elementFromPoint(x, y - gap)?.closest('.b-taskboard-card');\n        }\n\n        // Still nothing, look down\n        if (!task) {\n            task = documentRoot.elementFromPoint(x, y + gap)?.closest('.b-taskboard-card');\n        }\n\n        return task;\n    }\n\n    //endregion\n\n    //region Navigation\n\n    focusAndOptionallySelect(taskElement, forceSelect) {\n        if (taskElement) {\n            const\n                me                   = this,\n                currentlyFocusedTask = me.resolveTaskRecord(document.activeElement);\n\n            // If a task is focused but not selected and we navigate away from it holding SPACE we want that task to\n            // become selected in addition to the newly focused task\n            if (forceSelect && currentlyFocusedTask && !me.isSelected(currentlyFocusedTask)) {\n                me.selectTask(currentlyFocusedTask, true);\n            }\n\n            // When configured with `selectOnNavigation : true` we should move the selection. If user holds SHIFT we\n            // should always extend it\n            if (me.selectOnNavigation || forceSelect) {\n                const taskToFocus = me.resolveTaskRecord(taskElement);\n                // Newly focused task is not selected, always select it (optionally extending the selection)\n                if (!me.isSelected(taskToFocus)) {\n                    me.selectTask(taskToFocus, forceSelect);\n                }\n                // Newly focused task already selected, deselect current if SHIFT is pressed (to allow extending and\n                // shrinking selection holding SHIFT)\n                else if (forceSelect) {\n                    me.deselectTask(currentlyFocusedTask);\n                }\n            }\n\n            // Always move focus\n            taskElement.focus();\n        }\n    }\n\n    // To task at same Y in next column\n    navigateNext(keyEvent, select) {\n        const\n            me                                           = this,\n            { taskRecord, swimlaneRecord, columnRecord } = keyEvent.taskBoardData,\n            taskElement                                  = me.getTaskElement(taskRecord);\n\n        let\n            found = null,\n            nextColumnRecord = columnRecord;\n\n        do {\n            nextColumnRecord = me.columns.getNext(nextColumnRecord, true);\n\n            if (!nextColumnRecord.hidden) {\n                const\n                    nextColumnElement = me.getSwimlaneColumnElement(swimlaneRecord, nextColumnRecord),\n                    x                 = Rectangle.from(nextColumnElement, null, true).center.x,\n                    y                 = Rectangle.from(taskElement, null, true).center.y;\n\n                found = me.getTaskNear(x, y);\n            }\n        }\n        while (!found && nextColumnRecord !== columnRecord);\n\n        me.focusAndOptionallySelect(found, select);\n    }\n\n    // To task at same Y in prev column\n    navigatePrev(keyEvent, select) {\n        const\n            me                                           = this,\n            { taskRecord, swimlaneRecord, columnRecord } = keyEvent.taskBoardData,\n            taskElement                                  = me.getTaskElement(taskRecord);\n\n        let\n            found = null,\n            prevColumnRecord = columnRecord;\n\n        do {\n            prevColumnRecord = me.columns.getPrev(prevColumnRecord, true);\n\n            if (!prevColumnRecord.hidden) {\n                const\n                    prevColumnElement = me.getSwimlaneColumnElement(swimlaneRecord, prevColumnRecord),\n                    x                 = Rectangle.from(prevColumnElement, null, true).center.x,\n                    y                 = Rectangle.from(taskElement, null, true).center.y;\n\n                found = me.getTaskNear(x, y);\n            }\n        }\n        while (!found && prevColumnRecord !== columnRecord);\n\n        me.focusAndOptionallySelect(found, select);\n    }\n\n    // Right navigates to next column for LTR and previous for RTL\n    navigateRight(event, select = false) {\n        this['navigate' + (this.rtl ? 'Prev' : 'Next')](event, select);\n    }\n\n    // Left navigates to previous column for LTR and next for RTL\n    navigateLeft(event, select = false) {\n        this['navigate' + (this.rtl ? 'Next' : 'Prev')](event, select);\n    }\n\n    // Find next task in same column (might be in next swimlane)\n    navigateDown(keyEvent, select = false) {\n        const\n            { taskRecord } = keyEvent.taskBoardData,\n            nextTask       = this.getNextTask(taskRecord, true);\n\n        this.focusAndOptionallySelect(this.getTaskElement(nextTask), select);\n    }\n\n    // Find prev task in same column (might be in prev swimlane)\n    navigateUp(keyEvent, select = false) {\n        const\n            { taskRecord } = keyEvent.taskBoardData,\n            prevTask       = this.getPreviousTask(taskRecord, true);\n\n        this.focusAndOptionallySelect(this.getTaskElement(prevTask), select);\n    }\n\n    // Activate (show editor)\n    activate(event) {\n        const { taskRecord } = this.resolveEvent(event);\n        // Only care about ENTER on a task\n        taskRecord && this.trigger('activateTask', { taskRecord, event });\n    }\n\n    isActionAvailable({ action, event }) {\n        const taskBoardData = this.resolveEvent(event);\n\n        event.taskBoardData = taskBoardData;\n\n        // Block activating if a task item has focus (eg. a button in the card)\n        if (action === 'activate' && taskBoardData.taskRecord && event.target !== this.getTaskElement(taskBoardData.taskRecord)) {\n            return false;\n        }\n\n        return Boolean((this.navigateable || !navigationActions.includes(action)) && taskBoardData?.taskRecord);\n    }\n\n    //endregion\n\n};\n", "import Base from '../../../Core/Base.js';\nimport ArrayHelper from '../../../Core/helper/ArrayHelper.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n\n/**\n * @module TaskBoard/view/mixin/TaskSelection\n */\n\n/**\n * Mixin that handles card selection for the TaskBoard.\n *\n * By default tasks can be selected using mouse clicks and the keyboard. To enable marquee selection, see\n * {@link TaskBoard.feature.TaskDragSelect}.\n *\n * ## Mouse selection\n *\n * Select and deselect cards using the mouse, using a modifier key to do multi selection:\n *\n * * Click on a card to focus and select it, deselecting any previously selected card.\n * * `CMD`/`CTRL` + click on a card to add or remove it from the selection.\n *\n * See {@link TaskBoard.view.TaskBoard#keyboard-shortcuts} for more information on selecting cards using the keyboard.\n *\n * @mixin\n */\nexport default Target => class TaskSelection extends (Target || Base) {\n\n    //region Config\n\n    static $name = 'TaskSelection';\n\n    static configurable = {\n        /**\n         * Selected tasks.\n         * @prp {TaskBoard.model.TaskModel[]} selectedTasks\n         * @category Common\n         */\n        selectedTasks : [],\n\n        /**\n         * A template method (empty by default) allowing you to control if a task can be selected or not.\n         *\n         * ```javascript\n         * new TaskBoard({\n         *     isTaskSelectable(taskRecord) {\n         *         return taskRecord.status !== 'done';\n         *     }\n         * })\n         * ```\n         *\n         * @param {TaskBoard.model.TaskModel} taskRecord The task record\n         * @returns {Boolean} `true` if the task can be selected, otherwise `false`\n         * @prp {Function}\n         * @category Selection\n         */\n        isTaskSelectable : null,\n\n        keyMap : {\n            ' '                : 'keyboardSelect',\n            'Ctrl+ '           : 'keyboardToggleSelect',\n            'Shift+ArrowDown'  : 'selectDown',\n            'Shift+ArrowLeft'  : 'selectLeft',\n            'Shift+ArrowUp'    : 'selectUp',\n            'Shift+ArrowRight' : 'selectRight'\n        }\n    };\n\n    get widgetClass() {}\n\n    //endregion\n\n    //region Type assertions\n\n    changeSelectedTasks(selectedTasks) {\n        ObjectHelper.assertArray(selectedTasks, 'selectedTasks');\n\n        return selectedTasks.filter(task => this.isTaskSelectable?.(task) !== false);\n    }\n\n    //endregion\n\n    //region Programmatic selection\n\n    toggleTaskSelection(taskRecord, add = false, forceSelect = null) {\n        const me = this;\n\n        // Toggle\n        if (forceSelect == null) {\n            if (me.isSelected(taskRecord)) {\n                // Clicked on a selected task without modifier key, select only it\n                if (!add) {\n                    me.selectTask(taskRecord, add);\n                }\n                // Using modifier key, deselect instead\n                else {\n                    me.deselectTask(taskRecord);\n                }\n            }\n            else {\n                me.selectTask(taskRecord, add);\n            }\n        }\n        // Force select\n        else if (forceSelect) {\n            me.selectTask(taskRecord, add);\n        }\n        // Force deselect\n        else {\n            me.deselectTask(taskRecord);\n        }\n    }\n\n    /**\n     * Select the supplied task, deselecting any previously selected by default.\n     * @param {TaskBoard.model.TaskModel} taskRecord Task to select\n     * @param {Boolean} [add] Specify `true` to add to selection instead of replacing it\n     * @category Selection\n     */\n    selectTask(taskRecord, add = false) {\n        const\n            { selectedTasks } = this,\n            event             = {\n                action : 'select',\n                select : [taskRecord]\n            };\n\n        // Abort if not selectable\n        if (this.isTaskSelectable?.(taskRecord) === false) {\n            return;\n        }\n\n        if (!add) {\n            event.deselect = selectedTasks.slice();\n            selectedTasks.length = 0;\n        }\n\n        ArrayHelper.include(selectedTasks, taskRecord);\n\n        this.triggerSelectionChange(event);\n\n        this.recompose();\n    }\n\n    /**\n     * Deselect the supplied task.\n     * @param {TaskBoard.model.TaskModel} taskRecord\n     * @category Selection\n     */\n    deselectTask(taskRecord) {\n        ArrayHelper.remove(this.selectedTasks, taskRecord);\n\n        this.triggerSelectionChange({\n            action   : 'deselect',\n            deselect : [taskRecord]\n        });\n\n        this.recompose();\n    }\n\n    /**\n     * Deselect all tasks.\n     * @category Selection\n     */\n    deselectAll() {\n        const { selectedTasks } = this;\n\n        if (selectedTasks.length) {\n            const deselect = selectedTasks.slice();\n\n            selectedTasks.length = 0;\n\n            this.triggerSelectionChange({\n                action : 'deselect',\n                deselect\n            });\n\n            this.recompose();\n        }\n    }\n\n    /**\n     * Check if the supplied task is selected or not\n     * @param {TaskBoard.model.TaskModel} taskRecord\n     * @returns {Boolean} Returns `true` if it is selected, `false` if not\n     * @category Selection\n     */\n    isSelected(taskRecord) {\n        return this.selectedTasks.includes(taskRecord);\n    }\n\n    triggerSelectionChange(event) {\n        /**\n         * Triggered when task selection changes.\n         *\n         * @event selectionChange\n         * @param {TaskBoard.view.TaskBoard} source TaskBoard instance\n         * @param {'select'|'deselect'} action Either 'select' or 'deselect', depending on operation\n         * @param {TaskBoard.model.TaskModel[]} selection All currently selected tasks\n         * @param {TaskBoard.model.TaskModel[]} select Tasks selected by the operation\n         * @param {TaskBoard.model.TaskModel[]} deselect Tasks deselected by the operation\n         */\n        this.trigger('selectionChange', Object.assign({\n            selection : this.selectedTasks,\n            select    : [],\n            deselect  : []\n        }, event));\n    }\n\n    //endregion\n\n    //region Listeners\n\n    onTaskClick(bryntumEvent) {\n        super.onTaskClick(bryntumEvent);\n\n        const { event, taskRecord } = bryntumEvent;\n\n        if (!event.defaultPrevented) {\n            this.toggleTaskSelection(taskRecord, event.ctrlKey);\n        }\n    }\n\n    keyboardSelect(keyEvent) {\n        if (!DomHelper.isEditable(keyEvent.target)) {\n            const { taskRecord } = this.resolveEvent(keyEvent);\n            if (taskRecord) {\n                this.toggleTaskSelection(taskRecord, false);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    keyboardToggleSelect(keyEvent) {\n        const { taskRecord } = this.resolveEvent(keyEvent);\n        if (taskRecord) {\n            this.toggleTaskSelection(taskRecord, true);\n        }\n    }\n\n    onClick(event) {\n        super.onClick(event);\n\n        if (!event.taskRecord && this.navigateable) {\n            this.deselectAll();\n        }\n    }\n\n    selectUp(event) {\n        this.navigateUp(event, true);\n    }\n\n    selectDown(event) {\n        this.navigateDown(event, true);\n    }\n\n    selectLeft(event) {\n        this.navigateLeft(event, true);\n    }\n\n    selectRight(event) {\n        this.navigateRight(event, true);\n    }\n\n    //endregion\n\n    //region Rendering\n\n    populateCard(args) {\n        super.populateCard?.(args);\n\n        const { taskRecord, cardConfig } = args;\n\n        cardConfig.class['b-selected'] = this.isSelected(taskRecord);\n    }\n\n    populateBody(args) {\n        super.populateBody?.(args);\n\n        const { bodyConfig } = args;\n\n        bodyConfig.class['b-has-selection'] = Boolean(this.selectedTasks.length);\n    }\n\n    //endregion\n\n};\n", "import TaskItem from './TaskItem.js';\n\n/**\n * @module TaskBoard/view/item/ImageItem\n */\n\n/**\n * Item displaying an image.\n *\n * Loaded from the configured {@link #config-field}, optionally prepended with a {@link #config-baseUrl}.\n *\n * {@inlineexample TaskBoard/view/item/ImageItem.js}\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classType image\n */\nexport default class ImageItem extends TaskItem {\n    static $name = 'ImageItem';\n\n    static type = 'image';\n\n    /**\n     * Url prepended to this items value.\n     *\n     * ```javascript\n     * const taskBoard = new TaskBoard({\n     *    bodyItems : {\n     *        picture : { type : 'image', baseUrl : 'images/' }\n     *    },\n     *\n     *    project : {\n     *        tasksData : [\n     *            { id : 1, name : 'Task #1', picture : 'photo.jpg' },\n     *            { id : 2, name : 'Task #2', picture : 'image.jpg' }\n     *        ]\n     *    }\n     * });\n     *\n     * // Card for task #1 will render image \"images/photo.jpg\"\n     * // Card for task #2 will render image \"images/image.jpg\"\n     * ```\n     *\n     * @config {String} baseUrl\n     * @category Common\n     */\n\n    /**\n     * Widget type or config to use as the editor for this item. Used in the inline task editor.\n     *\n     * ImageItems are un-editable by default.\n     *\n     * @config {String|Object} editor\n     * @default null\n     * @category Common\n     */\n\n    static defaultEditor = null;\n\n    static render({ domConfig, value, config }) {\n        // Skip drawing when `image === false` or not assigned\n        if (value) {\n            Object.assign(domConfig, {\n                tag       : 'img',\n                src       : (config.baseUrl || '') + value,\n                draggable : false\n            });\n        }\n    }\n}\n\nImageItem.initClass();\n", "import TaskItem from './TaskItem.js';\n\n/**\n * @module TaskBoard/view/item/ProgressItem\n */\n\n/**\n * Item displaying a progress bar.\n *\n * Progress is determined by the value of the configured {@link #config-field}. A max value (defaults to 100) can be\n * configured using the {@link #config-max} config.\n *\n * {@inlineexample TaskBoard/view/item/ProgressItem.js}\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classType progress\n */\nexport default class ProgressItem extends TaskItem {\n    static $name = 'ProgressItem';\n\n    static type = 'progress';\n\n    static configurable = {\n        /**\n         * Max value, at which the bar is full.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    bodyItems : {\n         *        progress : { type : 'progress', max : 10 }\n         *    },\n         *\n         *    project : {\n         *        tasksData : [\n         *            { id : 1, name : 'Task #1', progress : 9 }\n         *        ]\n         *    }\n         * });\n         *\n         * // Task #1 bar is 9/10 filled\n         * ```\n         *\n         * @config {Number} max\n         * @default 100\n         * @category Common\n         */\n    };\n\n    /**\n     * Widget type or config to use as the editor for this item. Used in the inline task editor.\n     *\n     * ProgressItems are un-editable by default.\n     *\n     * @config {String|Object} editor\n     * @default null\n     * @category Common\n     */\n\n    static defaultEditor = null;\n\n    static render({ domConfig, value, config }) {\n        const percent = Math.round(100 * value / (config.max || 100)) + '%';\n\n        domConfig.children = [\n            {\n                class   : 'b-taskboard-progress-outline',\n                dataset : {\n                    percent\n                },\n                children : [\n                    {\n                        class : 'b-taskboard-progress-progress',\n                        style : {\n                            width : percent\n                        },\n                        dataset : {\n                            percent\n                        }\n                    }\n                ]\n            }\n        ];\n\n        domConfig.dataset.percent = domConfig.dataset.btip = percent;\n    }\n}\n\nProgressItem.initClass();\n", "import TaskItem from './TaskItem.js';\n\n/**\n * @module TaskBoard/view/item/RatingItem\n */\n\n/**\n * Item displaying a star rating.\n *\n * Rating is determined by the value of the configured {@link #config-field}. A max rating can be configured using the\n * {@link #config-max} config.\n *\n * {@inlineexample TaskBoard/view/item/RatingItem.js}\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classType rating\n */\nexport default class RatingItem extends TaskItem {\n    static $name = 'RatingItem';\n\n    static type = 'rating';\n\n    /**\n     * Max rating.\n     *\n     * ```javascript\n     * const taskBoard = new TaskBoard({\n     *    bodyItems : {\n     *       grade : { type : 'ratingitem', max : 5 }\n     *    },\n     *\n     *    project : {\n     *        tasksData : [\n     *            { id : 1, name : 'Task #1', grade : 3 }\n     *        ]\n     *    }\n     * });\n     *\n     * // Card for task #1 will render 3 full stars and 2 faded,\n     * // for a total of 5 stars\n     * ```\n     *\n     * @config {Number} max\n     * @category Common\n     */\n\n    /**\n     * Widget type or config to use as the editor for this item. Used in the inline task editor.\n     *\n     * RatingItems are un-editable by default.\n     *\n     * @config {String|Object} editor\n     * @default null\n     * @category Common\n     */\n\n    static defaultEditor = null;\n\n    static render({ domConfig, value, config }) {\n        const { max = value } = config;\n\n        domConfig.children = [];\n\n        for (let i = 0; i < max; i++) {\n            domConfig.children.push({\n                tag   : 'i',\n                class : {\n                    'b-icon b-icon-star' : 1,\n                    'b-filled'           : i < value\n                }\n            });\n        }\n    }\n}\n\nRatingItem.initClass();\n", "import TaskItem from './TaskItem.js';\n\n/**\n * @module TaskBoard/view/item/SeparatorItem\n */\n\n/**\n * Item displaying a horizontal divider.\n *\n * {@inlineexample TaskBoard/view/item/SeparatorItem.js}\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classType separator\n */\nexport default class SeparatorItem extends TaskItem {\n    static $name = 'SeparatorItem';\n\n    static type = 'separator';\n\n    /**\n     * @hideconfigs editor\n     */\n\n    static defaultEditor = null;\n\n    static render({ domConfig }) {\n        domConfig.tag = 'hr';\n    }\n}\n\nSeparatorItem.initClass();\n", "import Combo from '../../Core/widget/Combo.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n\n/**\n * @module TaskBoard/widget/TagCombo\n */\n\n/**\n * A combo for picking tags. Works well to edit fields displayed by a {@link TaskBoard/view/item/TagsItem}, if data\n * uses strings to represent tags:\n *\n * {@inlineexample TaskBoard/widget/TagCombo.js}\n *\n * Consumes and outputs and array of strings, or if configured with a {@link #config-separator} a single string.\n *\n * If not seeded with any items/store, it tries to extract tags from the task store by collecting distinct values for\n * the field it is linked to (by {@link #config-name}).\n *\n * @classtype tagcombo\n * @extends Core/widget/Combo\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @inputfield\n */\nexport default class TagCombo extends Combo.mixin(TaskBoardLinked) {\n    static $name = 'TagCombo';\n\n    static type = 'tagcombo';\n\n    static configurable = {\n        multiSelect : true,\n        editable    : false,\n\n        /**\n         * Separator used to split a string into tags. Required if data format uses a single string to represent tags.\n         * @config {String}\n         * @default\n         */\n        separator : ',',\n\n        picker : {\n            cls : 'b-tag-picker'\n        },\n\n        chipView : {\n            closable : false\n        }\n    };\n\n    afterConfigure() {\n        const me = this;\n\n        // Populate with tags from the task store\n        if (!me.store?.count && me.taskBoard && me.name) {\n            const\n                { name, separator } = me,\n                tags                = [];\n\n            me.taskBoard.project.taskStore.forEach(task => {\n                const taskTags = task[name];\n                if (taskTags) {\n                    if (typeof taskTags === 'string') {\n                        tags.push(...taskTags.split(separator));\n                    }\n                    else {\n                        tags.push(...taskTags);\n                    }\n                }\n            });\n\n            me.items = [...new Set(tags)].sort();\n        }\n    }\n\n    changeValue(value, old) {\n        this.$expectsString = false;\n\n        if (this.separator && typeof value === 'string') {\n            value = value.split(this.separator);\n            this.$expectsString = true;\n        }\n\n        super.changeValue(value, old);\n    }\n\n    get value() {\n        const value = super.value;\n\n        if (this.$expectsString) {\n            return value.join(this.separator);\n        }\n\n        return value;\n    }\n\n    set value(value) {\n        super.value = value;\n    }\n}\n\nTagCombo.initClass();\n", "import TaskItem from './TaskItem.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport '../../widget/TagCombo.js';\n\n/**\n * @module TaskBoard/view/item/TagsItem\n */\n\n/**\n * Item displaying tags, either from string split into tags, an array of strings or by plucking a value from an array of\n * objects.\n *\n * Using a string, split into tags using the configured {@link #config-separator}:\n *\n * {@inlineexample TaskBoard/view/item/TagsItem.js}\n *\n * Using an array of strings, each entry is turned into a tag:\n *\n * {@inlineexample TaskBoard/view/item/TagsItemStringArray.js}\n *\n * Using an array of objects, gives you the most control over the tags. Requires configuring a\n * {@link #config-textProperty} and optionally a {@link #config-clsProperty}:\n *\n * {@inlineexample TaskBoard/view/item/TagsItemObjectArray.js}\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classType tags\n */\nexport default class TagsItem extends TaskItem {\n    static $name = 'TagsItem';\n\n    static type = 'tags';\n\n    /**\n     * Property used to determine the text for the tag. It is plucked from an array of objects that is used as the value\n     * for this item.\n     *\n     * ```javascript\n     * const taskBoard = new TaskBoard({\n     *    bodyItems : {\n     *       tags : { type : 'TagsItem', textProperty : 'title' }\n     *    },\n     *\n     *    project : {\n     *        tasksData : [{\n     *            id : 1,\n     *            name : 'Issue #1',\n     *            tags : [\n     *                { title : 'bug', color : 'orange' },\n     *                { title : 'important', color : 'red' }\n     *            ]\n     *        }]\n     *    }\n     * });\n     *\n     * // Card for Issue #1 will render 2 tags, 'bug' and 'important'\n     * ```\n     *\n     * @config {String} textProperty\n     * @category Common\n     */\n\n    /**\n     * Property used to add a CSS class to each tag. It is plucked from an array of objects that is used as the value\n     * for this item.\n     *\n     * ```javascript\n     * const taskBoard = new TaskBoard({\n     *    bodyItems : {\n     *       tags : { type : 'TagsItem', clsProperty : 'color' }\n     *    },\n     *\n     *    project : {\n     *        tasksData : [{\n     *            id : 1,\n     *            name : 'Issue #1',\n     *            tags : [\n     *                { title : 'bug', color : 'orange' },\n     *                { title : 'important', color : 'red' }\n     *            ]\n     *        }]\n     *    }\n     * });\n     *\n     * // Card for Issue #1 will render 2 tags, one with cls 'orange' and one with cls 'red'\n     * ```\n     *\n     * @config {String} clsProperty\n     * @category Common\n     */\n\n    /**\n     * Property used to split a value string into tags.\n     *\n     * ```javascript\n     * const taskBoard = new TaskBoard({\n     *    bodyItems : {\n     *       tags : { type : 'TagsItem', separator : ';' }\n     *    },\n     *\n     *    project : {\n     *        tasksData : [{\n     *            id : 1,\n     *            name : 'Issue #1',\n     *            tags : 'bug;important'\n     *        }]\n     *    }\n     * });\n     *\n     * // Card for Issue #1 will render 2 tags, 'bug' and 'important'\n     * ```\n     *\n     * @config {String} separator\n     * @default ,\n     * @category Common\n     */\n\n    /**\n     * Widget type or config to use as the editor for this item. Used in the inline task editor.\n     *\n     * Defaults to use a {@link TaskBoard.widget.TagCombo}.\n     *\n     * @config {String|Object} editor\n     * @default tagcombo\n     * @category Common\n     */\n    static defaultEditor = { type : 'tagcombo', pickerWidth : '10em' };\n\n    static render({ domConfig, value, config }) {\n        let tags;\n\n        if (value) {\n            if (typeof value === 'string') {\n                tags = value.split(config.separator || ',').map(str => ({ text : str }));\n            }\n            else if (Array.isArray(value)) {\n                tags = value.map(entry => {\n                    if (typeof entry === 'string') {\n                        return { text : entry };\n                    }\n                    else {\n                        return {\n                            text : config.textProperty && entry[config.textProperty],\n                            cls  : config.clsProperty && entry[config.clsProperty]\n                        };\n                    }\n                });\n            }\n\n            if (tags) {\n                domConfig.children = tags.map(tag => {\n                    const cls = ('cls' in tag) ? tag.cls : DomHelper.makeValidId(tag.text, '-').toLowerCase();\n                    return {\n                        class : {\n                            'b-taskboard-tags-tag' : 1,\n                            [cls]                  : Boolean(cls)\n                        },\n                        text : tag.text\n                    };\n                });\n            }\n        }\n    }\n}\n\nTagsItem.initClass();\n", "import ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport TaskItem from './TaskItem.js';\n\n/**\n * @module TaskBoard/view/item/TemplateItem\n */\n\n/**\n * Item displaying content generated by a template function, see {@link #config-template}\n *\n * {@inlineexample TaskBoard/view/item/TemplateItem.js}\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classType template\n */\nexport default class TemplateItem extends TaskItem {\n    static $name = 'TemplateItem';\n\n    static type = 'template';\n\n    /**\n     * Template function used to generate task content.\n     *\n     * Return an HTML string or a DomConfig object from the function:\n     *\n     * ```javascript\n     * const taskBoard = new TaskBoard({\n     *    bodyItems : {\n     *        prio : {\n     *          type     : 'template',\n     *          template : ({ taskRecord }) => `<i class=\"b-fa b-fa-tarffic-light\"></i> ${taskRecord.prio}`\n     *        }\n     *    }\n     * });\n     * ```\n     *\n     * @config {Function} template\n     * @param {TaskBoard.model.TaskModel} taskRecord Task record\n     * @param {TemplateItemConfig} config Item config\n     * @param {Object} value Value of the configured field\n     * @returns {String|DomConfig|DomConfig[]} HTML string, DomConfig or DomConfig array\n     * @category Common\n     */\n\n    /**\n     * Widget type or config to use as the editor for this item. Used in the inline task editor.\n     *\n     * TemplateItems are un-editable by default.\n     *\n     * @config {String|Object} editor\n     * @default null\n     * @category Common\n     */\n\n    static defaultEditor = null;\n\n    static render({ domConfig, value, config, taskRecord }) {\n        const html = config.template({ taskRecord, config, value });\n\n        if (typeof html === 'string') {\n            domConfig.html = html;\n        }\n        else if (ObjectHelper.isObject(html)) {\n            ObjectHelper.merge(domConfig, html);\n        }\n        else if (Array.isArray(html)) {\n            domConfig.children = html;\n        }\n    }\n}\n\nTemplateItem.initClass();\n", "import TaskItem from './TaskItem.js';\n\n/**\n * @module TaskBoard/view/item/TodoListItem\n */\n\n/**\n * Item displaying a list of todo items with associated checkboxes. It allows users to toggle the checkbox for each item\n * on the card to indicate if that item is completed or not. By adding a {@link TaskBoard/widget/TodoListField} to the\n * task editor users can also add, edit and remove todo items.\n *\n * {@inlineexample TaskBoard/view/item/TodoListItem.js}\n *\n * It consumes an array of objects representing todo items. For this item to work as indented, that array has to be\n * supplied by a task field using `type : 'array'`. It is also important to configure the {@link #config-textField} and\n * {@link #config-checkedField} to match properties of the objects in that array. This snippet illustrates a possible\n * setup:\n *\n * ```javascript\n * // Custom task model with a todo field of array type\n * class MyTask extends TaskModel {\n *     static fields = [\n *        { name : 'todo', type : 'array' }\n *     ];\n * }\n *\n * const taskBoard = new TaskBoard({\n *    project : {\n *        // Use the custom task model defined above\n *        taskModelClass : MyTask,\n *\n *        tasksData : [\n *            {\n *              id : 1,\n *              name : 'Order software',\n *              // The custom field, accepts an array\n *              todo : [\n *                  { title : 'Sketchup Pro', done : false },\n *                  { title : 'AutoCAD LT', done : true },\n *                  { title : 'Inventor', done : false }\n *              ]\n *            }\n *        ]\n *    },\n *\n *    bodyItems : {\n *        todo : {\n *            // Add a todo list item to card body\n *            type         : 'todoList',\n *            // Map text to the \"title\" field\n *            textField    : 'text',\n *            // Map checkbox to the \"done\" field\n *            checkedField : 'done'\n *        }\n *    }\n * });\n * ```\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classType todoList\n */\nexport default class TodoListItem extends TaskItem {\n    static $name = 'TodoListItem';\n\n    static type = 'todoList';\n\n    /**\n     * Name of a property on a todo item to display as its text.\n     *\n     * @config {String} textField\n     * @category Common\n     * @default text\n     */\n\n    /**\n     * Name of a property on a todo item to use for the checkbox. The property is expected to be a boolean.\n     *\n     * @config {String} checkedField\n     * @category Common\n     * @default checked\n     */\n\n    /**\n     * Name of a property on a todo item whose value will be added as a CSS class to the todo item.\n     *\n     * @config {String} clsField\n     * @category Common\n     * @default cls\n     */\n\n    // private for now:\n    // checkedIcon\n    // uncheckedIcon\n\n    /**\n     * @hideconfigs editor\n     */\n\n    static defaultEditor = null;\n\n    static render({ domConfig, value, config, taskRecord }) {\n        if (value) {\n            const {\n                textField = 'text',\n                checkedField = 'checked',\n                clsField = 'cls',\n                checkedIcon = 'b-icon b-icon-checked',\n                uncheckedIcon = 'b-icon b-icon-unchecked'\n            } = config;\n\n            if (this.firstRender !== false) {\n                const dataField = taskRecord.getFieldDefinition(config.field);\n                if (!dataField.isArrayDataField) {\n                    throw new Error('TodoListItem has to be mapped to a field with `type : \"array\"`');\n                }\n\n            }\n\n            domConfig.children = value.map((todo, index) => ({\n                class : {\n                    'b-taskboard-todolist-todo' : 1,\n                    [todo[clsField]]            : todo[clsField],\n                    'b-checked'                 : todo[checkedField]\n                },\n                children : {\n                    icon : {\n                        tag   : 'i',\n                        class : todo[checkedField] ? checkedIcon : uncheckedIcon\n                    },\n                    text : {\n                        tag  : 'span',\n                        text : todo[textField]\n                    }\n                },\n                elementData : {\n                    index\n                }\n            }));\n\n            this.firstRender = false;\n        }\n    }\n\n    static onClick({ source : taskBoard, taskRecord, event, config }) {\n        const element = event.target.closest('.b-taskboard-todolist-todo');\n\n        if (element && !taskRecord.readOnly) {\n            const\n                { checkedField = 'checked', field } = config,\n                { index }                           = element.elementData,\n                // array fields has to be assigned a new array to detect a change, hence the slice\n                clone                               = taskRecord.getValue(field).slice(),\n                todo                                = clone[index];\n\n            // Toggle the mapped fields value\n            todo[checkedField] = !todo[checkedField];\n\n            // Assign the cloned array to the task record\n            taskRecord.setValue(field, clone);\n\n            taskBoard.trigger('todoToggle', { taskRecord, todo, checked : todo[checkedField], element, event });\n\n            // Don't want the click to select the task, feels a bit awkward when it does\n            event.preventDefault();\n        }\n    }\n\n    // Prevent editor from opening when dbl clicking a todo item\n    static onDblClick({ event }) {\n        event.preventDefault();\n    }\n\n}\n\nTodoListItem.initClass();\n", "import LocaleHelper from '../../Core/localization/LocaleHelper.js';\nimport '../../Core/localization/En.js';\n\nconst locale = {\n\n    localeName : 'En',\n    localeDesc : 'English (US)',\n    localeCode : 'en-US',\n\n    GridBase : {\n        loadFailedMessage : 'Data loading failed!',\n        syncFailedMessage : 'Data synchronization failed!'\n    },\n\n    CrudManagerView : {\n        serverResponseLabel : 'Server response:'\n    },\n\n    TaskBoard : {\n        column           : 'column',\n        columns          : 'columns',\n        Columns          : 'Columns',\n        swimlane         : 'swimlane',\n        swimlanes        : 'swimlanes',\n        Swimlanes        : 'Swimlanes',\n        task             : 'task',\n        tasks            : 'tasks',\n        addTask          : 'Add L{TaskBoard.task}',\n        cancel           : 'Cancel',\n        changeColumn     : 'Change L{TaskBoard.column}',\n        changeSwimlane   : 'Change L{TaskBoard.swimlane}',\n        collapse         : text => `Collapse ${text}`,\n        color            : 'Color',\n        description      : 'Description',\n        editTask         : 'Edit L{TaskBoard.task}',\n        expand           : text => `Expand ${text}`,\n        filterColumns    : 'Filter L{TaskBoard.columns}',\n        filterSwimlanes  : 'Filter L{TaskBoard.swimlanes}',\n        filterTasks      : 'Filter L{TaskBoard.tasks}',\n        moveColumnLeft   : 'Move L{TaskBoard.column} left',\n        moveColumnRight  : 'Move L{TaskBoard.column} right',\n        name             : 'Name',\n        newTaskName      : 'New L{TaskBoard.task}',\n        removeTask       : 'Remove L{TaskBoard.task}',\n        removeTasks      : 'Remove L{TaskBoard.tasks}',\n        resources        : 'Resources',\n        save             : 'Save',\n        scrollToColumn   : 'Scroll to L{TaskBoard.column}',\n        scrollToSwimlane : 'Scroll to L{TaskBoard.swimlane}',\n        zoom             : 'Zoom'\n    },\n\n    TodoListField : {\n        add     : 'Add',\n        newTodo : 'New todo'\n    },\n\n    UndoRedo : {\n        UndoLastAction : 'Undo',\n        RedoLastAction : 'Redo'\n    }\n};\n\nexport default LocaleHelper.publishLocale(locale);\n", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\nimport Featureable from '../../Core/mixin/Featureable.js';\nimport Pluggable from '../../Core/mixin/Pluggable.js';\nimport State from '../../Core/mixin/State.js';\nimport ScrollManager from '../../Core/util/ScrollManager.js';\nimport Responsive from '../../Core/widget/mixin/Responsive.js';\nimport Styleable from '../../Core/widget/mixin/Styleable.js';\nimport Panel from '../../Core/widget/Panel.js';\n\nimport CrudManagerView from '../../Scheduler/crud/mixin/CrudManagerView.js';\n\nimport TaskBoardFeature from '../feature/TaskBoardFeature.js';\nimport ExpandCollapse from './mixin/ExpandCollapse.js';\nimport ResponsiveCards from './mixin/ResponsiveCards.js';\nimport TaskBoardColumns from './mixin/TaskBoardColumns.js';\nimport TaskBoardDom from './mixin/TaskBoardDom.js';\nimport TaskBoardDomEvents from './mixin/TaskBoardDomEvents.js';\nimport TaskBoardScroll from './mixin/TaskBoardScroll.js';\nimport TaskBoardStores from './mixin/TaskBoardStores.js';\nimport TaskBoardSwimlanes from './mixin/TaskBoardSwimlanes.js';\nimport TaskBoardVirtualization from './mixin/TaskBoardVirtualization.js';\nimport TaskItems from './mixin/TaskItems.js';\nimport TaskNavigation from './mixin/TaskNavigation.js';\n\nimport TaskSelection from './mixin/TaskSelection.js';\nimport '../localization/En.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\n\n/**\n * @module TaskBoard/view/TaskBoardBase\n */\n\nconst weightSorter = (a, b) => a.weight - b.weight;\n\n/**\n * A thin base class for {@link TaskBoard.view.TaskBoard}. Does not include any features by default, allowing smaller\n * custom-built bundles if used in place of {@link TaskBoard.view.TaskBoard}.\n *\n * **NOTE:** In most scenarios you probably want to use TaskBoard instead of TaskBoardBase.\n *\n * @extends Core/widget/Panel\n *\n * @mixes Core/mixin/Pluggable\n * @mixes Core/mixin/State\n * @mixes Core/widget/mixin/Responsive\n * @mixes Core/widget/mixin/Styleable\n * @mixes Scheduler/crud/mixin/CrudManagerView\n * @mixes TaskBoard/view/mixin/ExpandCollapse\n * @mixes TaskBoard/view/mixin/ResponsiveCards\n * @mixes TaskBoard/view/mixin/TaskBoardColumns\n * @mixes TaskBoard/view/mixin/TaskBoardDom\n * @mixes TaskBoard/view/mixin/TaskBoardDomEvents\n * @mixes TaskBoard/view/mixin/TaskBoardScroll\n * @mixes TaskBoard/view/mixin/TaskBoardStores\n * @mixes TaskBoard/view/mixin/TaskBoardSwimlanes\n * @mixes TaskBoard/view/mixin/TaskBoardVirtualization\n * @mixes TaskBoard/view/mixin/TaskItems\n * @mixes TaskBoard/view/mixin/TaskNavigation\n * @mixes TaskBoard/view/mixin/TaskSelection\n *\n * @features TaskBoard/feature/ColumnDrag\n * @features TaskBoard/feature/ColumnHeaderMenu\n * @features TaskBoard/feature/ColumnToolbars\n * @features TaskBoard/feature/SimpleTaskEdit\n * @features TaskBoard/feature/SwimlaneDrag\n * @features TaskBoard/feature/TaskDrag\n * @features TaskBoard/feature/TaskDragSelect\n * @features TaskBoard/feature/TaskEdit\n * @features TaskBoard/feature/TaskMenu\n * @features TaskBoard/feature/TaskTooltip\n * @widget\n */\nexport default class TaskBoardBase extends Panel.mixin(\n    Pluggable,\n    State,\n    Featureable,\n    Styleable,\n    CrudManagerView,\n    ExpandCollapse,\n    Responsive,\n    ResponsiveCards,\n    TaskBoardColumns,\n    TaskBoardDom,\n    TaskBoardDomEvents,\n    TaskBoardScroll,\n    TaskBoardStores,\n    TaskBoardSwimlanes,\n    TaskBoardVirtualization,\n    TaskItems,\n    TaskNavigation,\n    TaskSelection\n) {\n\n    // <debug>\n    // region Localization test\n    static localization = [\n        'L{TaskBoard.task}',\n        'L{TaskBoard.tasks}',\n        'L{TaskBoard.column}',\n        'L{TaskBoard.columns}',\n        'L{TaskBoard.swimlane}',\n        'L{TaskBoard.swimlanes}'\n    ];\n    // endregion\n    // </debug>\n\n    //region Config\n\n    static $name = 'TaskBoardBase';\n    static type = 'taskboardbase';\n\n    static featureable = {\n        factory : TaskBoardFeature\n    };\n\n    static configurable = {\n        /** @hideconfigs autoUpdateRecord, defaultFocus, trapFocus, showTooltipWhenDisabled */\n        /** @hideproperties firstItem, lastItem, cellInfo, visibleChildCount */\n        /** @hidefunctions getAt */\n\n        layout : 'vbox',\n\n        /**\n         * An object containing Feature configuration objects (or `true` if no configuration is required)\n         * keyed by the Feature class name in all lowercase.\n         * @config {Object}\n         * @category Common\n         */\n        features : true,\n\n        /**\n         * An empty function by default, but provided so that you can override it. This function is called each time\n         * a task is rendered into the task board. It allows you to manipulate the DOM config object used for the card\n         * before it is synced to DOM, thus giving you control over styling and contents.\n         *\n         * NOTE: The function is intended for formatting, you should not update records in it since updating records\n         * triggers another round of rendering.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    taskRenderer({ taskRecord, cardConfig }) {\n         *        // Add an icon to all tasks header\n         *        cardConfig.children.header.children.icon = {\n         *            tag   : 'i',\n         *            class : 'b-fa b-fa-beer'\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * For more information, see the [Customize task contents guide](#TaskBoard/guides/customization/taskcontents.md).\n         *\n         * @config {Function}\n         * @param {Object} detail An object containing the information needed to render a task.\n         * @param {TaskBoard.model.TaskModel} detail.taskRecord The task record.\n         * @param {TaskBoard.model.ColumnModel} detail.columnRecord The column the task will be displayed in.\n         * @param {TaskBoard.model.SwimlaneModel} detail.swimlaneRecord The swimlane the task will be displayed in.\n         * @param {DomConfig} detail.cardConfig DOM config object for the cards element\n         * @category Task content\n         */\n        taskRenderer : null,\n\n        /**\n         * An empty function by default, but provided so that you can override it. This function is called each time\n         * a swimlane is rendered into the task board. It allows you to manipulate the DOM config object used for the\n         * swimlane before it is synced to DOM, thus giving you control over styling and contents.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    swimlaneRenderer({ swimlaneRecord, swimlaneConfig }) {\n         *        // Add an icon to all swimlane headers\n         *        swimlaneConfig.children.header.children.icon = {\n         *            tag   : 'i',\n         *            class : 'b-fa b-fa-dog'\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @config {Function}\n         * @param {Object} detail An object containing the information needed to render a swimlane.\n         * @param {TaskBoard.model.SwimlaneModel} detail.swimlaneRecord The swimlane.\n         * @param {DomConfig} detail.swimlaneConfig DOM config object for the swimlane\n         * @category Advanced\n         */\n        swimlaneRenderer : null,\n\n        /**\n         * Controls how many cards are rendered to a row in each column. Can be controlled on a per column basis by\n         * setting {@link TaskBoard.model.ColumnModel#field-tasksPerRow}\n         *\n         * ```javascript\n         * new TaskBoard({\n         *   tasksPerRow : 3\n         * });\n         * ```\n         *\n         * @config {Number}\n         * @category Common\n         */\n        tasksPerRow : 1,\n\n        /**\n         * Setting this will cause cards to expand to share the available width if there are fewer than\n         * {@link #config-tasksPerRow}.\n         *\n         * By default, the {@link #config-tasksPerRow} always applies, and if it is 3, then a single\n         * card in a column will be 33% of the available width.\n         *\n         * To have fewer cards than the {@link #config-tasksPerRow} evenly share available column width,\n         * configure this as `true`;\n         * @prp {Boolean}\n         * @category Common\n         */\n        stretchCards : null,\n\n        /**\n         * Show task count for a column in its header, appended after the title\n         *\n         * ```javascript\n         * new TaskBoard({\n         *   showCountInHeader : false\n         * });\n         * ```\n         *\n         * @config {Boolean}\n         * @default\n         * @category Common\n         */\n        showCountInHeader : true,\n\n        /**\n         * Makes column and swimlane headers sticky\n         *\n         * ```javascript\n         * new TaskBoard({\n         *   stickyHeaders : true\n         * });\n         * ```\n         *\n         * @config {Boolean}\n         * @default\n         * @category Common\n         */\n        stickyHeaders : false,\n\n        /**\n         * Experimental, animate actions that cannot be animated using CSS transitions. Currently includes:\n         * * Programmatically moving tasks\n         * * Moving tasks using the task editor\n         * * Adding tasks\n         * * Removing tasks\n         * * Sorting tasks\n         * * Hiding/showing/filtering columns\n         * * Hiding/showing/filtering swimlanes\n         *\n         * ```javascript\n         * new TaskBoard({\n         *   useDomTransition : true\n         * });\n         * ```\n         * **NOTE**: This flag is not supported for Lightning Web Components\n         * @config {Boolean}\n         * @category Experimental\n         */\n        useDomTransition : false,\n\n        /**\n         * Path to load resource images from. Used by the for example the resource picker in the task editor and by the\n         * ResourceAvatars task item. Set this to display miniature images for each resource using their `image` field.\n         *\n         * **NOTE**: The path should end with a `/`:\n         *\n         * ```javascript\n         * new TaskBoard({\n         *   resourceImagePath : 'images/resources/'\n         * });\n         * ```\n         *\n         * @config {String}\n         * @category Common\n         */\n        resourceImagePath : null,\n\n        /**\n         * CSS variable prefix, appended to the keys used in {@link #config-css}.\n         *\n         * Normally you do not need to change this value.\n         *\n         * @default\n         * @config {String}\n         * @category CSS\n         */\n        cssVarPrefix : 'taskboard',\n\n        /**\n         * Configuration values for the {@link Core.util.ScrollManager} class. It is used to manage column/body\n         * scrolling during task, column or swimlane drag.\n         * ```javascript\n         * new TaskBoard({\n         *     scrollManager : {\n         *         zoneWidth   : 100, // increase zone size\n         *         scrollSpeed : 3    // and scroll speed\n         *     }\n         * })\n         * ```\n         * @config {ScrollManagerConfig}\n         * @category Scrolling\n         */\n        scrollManager : {\n            value : {},\n\n            $config : ['nullify', 'lazy']\n        },\n\n        /**\n         * Allows sorting tasks in the UI independent of how they are sorted in the task store.\n         *\n         * Specify `true` to force sorting tasks by {@link TaskBoard/model/TaskModel#field-weight}.\n         *\n         * Supply a [sort](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)\n         * function to force a custom sort order.\n         *\n         * This is likely something you will want to use if combining TaskBoard with other products, sharing the\n         * project. Without this, sorting tasks in for example Gantt will also rearrange the cards on the board.\n         *\n         * As described above it accepts either a boolean or a Function, but it always returns a sorter function.\n         *\n         * @member {Function} taskSorterFn\n         * @accepts {Boolean|Function}\n         * @category Advanced\n         */\n        /**\n         * Allows sorting tasks in the UI independent of how they are sorted in the task store.\n         *\n         * Specify `true` to force sorting tasks by {@link TaskBoard/model/TaskModel#field-weight}.\n         *\n         * Supply a [sort](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)\n         * function to force a custom sort order.\n         *\n         * This is likely something you will want to use if combining TaskBoard with other products, sharing the\n         * project. Without this, sorting tasks in for example Gantt will also rearrange the cards on the board.\n         *\n         * @config {Boolean|Function}\n         * @category Advanced\n         */\n        taskSorterFn : null,\n\n        /**\n         * See {@link TaskBoard.view.TaskBoard#keyboard-shortcuts Keyboard shortcuts} for details\n         * @config {Object<String,String>} keyMap\n         * @category Common\n         */\n\n        contentElMutationObserver : false,\n\n        textContent : false,\n\n        // We can scroll in both axes.\n        // Scrollable also syncs the b-horizontal-overflow and b-vertical-overflow classes\n        // to allow styles to depend upon overflow state.\n        scrollable : true\n    };\n\n    isInitiallyComposed    = false;\n    domTransitionSuspended = 0;\n    columnRecomposeQueue   = new Map();\n\n    static delayable = {\n        recomposeColumns : 'raf'\n    };\n\n    //endregion\n\n    //region Overrides\n\n    onPaintOverride() {\n        // Internal procedure used for paint method overrides\n        // Not used in onPaint() because it may be chained on instance and Override won't be applied\n    }\n\n    onPaint(...args) {\n        if (this.onPaintOverride()) {\n            return;\n        }\n        super.onPaint(...args);\n    }\n\n    //endregion\n\n    //region Type assertions and changers/updaters\n\n    changeResourceImagePath(resourceImagePath) {\n        ObjectHelper.assertString(resourceImagePath, 'resourceImagePath');\n\n        return resourceImagePath;\n    }\n\n    changeUseDomTransition(useDomTransition) {\n        ObjectHelper.assertBoolean(useDomTransition, 'useDomTransition');\n\n        return useDomTransition;\n    }\n\n    changeStickyHeaders(stickyHeaders) {\n        ObjectHelper.assertBoolean(stickyHeaders, 'stickyHeaders');\n\n        return stickyHeaders;\n    }\n\n    changeScrollManager(scrollManager, oldScrollManager) {\n        oldScrollManager?.destroy();\n\n        if (scrollManager) {\n            return ScrollManager.new({\n                element : this.element,\n                owner   : this\n            }, scrollManager);\n        }\n\n        return null;\n    }\n\n    changeShowCountInHeader(showCountInHeader) {\n        ObjectHelper.assertBoolean(showCountInHeader, 'showCountInHeader');\n\n        return showCountInHeader;\n    }\n\n    changeTasksPerRow(tasksPerRow) {\n        ObjectHelper.assertNumber(tasksPerRow, 'tasksPerRow');\n\n        return tasksPerRow;\n    }\n\n    changeSwimlaneRenderer(swimlaneRenderer) {\n        ObjectHelper.assertFunction(swimlaneRenderer, 'swimlaneRenderer');\n\n        return swimlaneRenderer;\n    }\n\n    changeTaskRenderer(taskRenderer) {\n        ObjectHelper.assertFunction(taskRenderer, 'taskRenderer');\n\n        return taskRenderer;\n    }\n\n    changeTaskSorterFn(fn) {\n        if (fn === true) {\n            return weightSorter;\n        }\n\n        fn && ObjectHelper.assertFunction(fn, 'taskSorterFn');\n\n        return fn;\n    }\n\n    //endregion\n\n    //region Recompose columns\n\n    // Queue a column for recomposition on next frame\n    queueColumnRecompose(columnRecord, swimlaneRecord) {\n        this.columnRecomposeQueue.set(`${columnRecord.id}.-.${swimlaneRecord?.id}`, { columnRecord, swimlaneRecord });\n        this.recomposeColumns();\n    }\n\n    // RAF function to recompose all queued columns\n    recomposeColumns() {\n        for (const [, { columnRecord, swimlaneRecord }] of this.columnRecomposeQueue) {\n            this.recomposeColumn(columnRecord, swimlaneRecord);\n        }\n        this.columnRecomposeQueue.clear();\n    }\n\n    // Recompose a single column / swimlane intersection\n    recomposeColumn(columnRecord, swimlaneRecord) {\n        const\n            element   = this.getSwimlaneColumnElement(swimlaneRecord, columnRecord),\n            domConfig = DomHelper.normalizeChildren(this.renderColumn(swimlaneRecord, columnRecord));\n\n        domConfig.onlyChildren = true;\n\n        DomSync.sync({\n            targetElement : element,\n            domConfig,\n            callback      : this.domSyncCallback,\n            syncOptions   : {\n                syncIdField      : 'column',\n                releaseThreshold : 0\n            }\n        });\n    }\n\n    //endregion\n\n    //region Render\n\n    // Creates a DOM config for a single card, calling any configured taskRenderer() in the process\n    renderCard(taskRecord, columnRecord, swimlaneRecord) {\n        // Allow mixins to fully control card rendering (used by TaskBoardVirtualization)\n        const overriddenCard = super.renderCard(taskRecord, columnRecord, swimlaneRecord);\n        if (overriddenCard) {\n            return overriddenCard;\n        }\n\n        const\n            me                                = this,\n            { id, domId, eventColor, weight } = taskRecord,\n            color                             = eventColor || swimlaneRecord?.color || columnRecord.color,\n            namedColor                        = DomHelper.isNamedColor(color) ? color : null,\n            cardSize                          = me.getCardSize(columnRecord, swimlaneRecord),\n            cardConfig                        = {\n                id    : `${me.id}-card-${domId}`,\n                class : {\n                    'b-taskboard-card'                  : true,\n                    [`b-taskboard-color-${namedColor}`] : namedColor,\n                    'b-readonly'                        : taskRecord.readOnly,\n                    ...taskRecord.cls\n                },\n                tabIndex : 0,\n                dataset  : {\n                    task          : domId,\n                    column        : columnRecord.id,\n                    lane          : swimlaneRecord?.id,\n                    weight,\n                    domTransition : true\n                },\n                style : {\n                    color  : namedColor ? null : color,\n                    height : me.getTaskHeight?.(taskRecord) ?? null\n                },\n                elementData : {\n                    elementType : 'task',\n                    taskId      : id,\n                    taskRecord,\n                    columnRecord,\n                    swimlaneRecord\n                },\n                children : {\n                    header : {\n                        tag   : 'header',\n                        class : {\n                            'b-taskboard-card-header' : 1\n                        },\n                        children    : {},\n                        syncOptions : {\n                            syncIdField : 'role'\n                        }\n                    },\n                    body : {\n                        tag   : 'section',\n                        class : {\n                            'b-taskboard-card-body' : 1\n                        },\n                        children    : {},\n                        syncOptions : {\n                            syncIdField : 'role'\n                        }\n                    },\n                    footer : {\n                        tag   : 'footer',\n                        class : {\n                            'b-taskboard-card-footer' : 1\n                        },\n                        children    : {},\n                        syncOptions : {\n                            syncIdField : 'role'\n                        }\n                    }\n                }\n            },\n            { children }             = cardConfig,\n            { header, body, footer } = children;\n\n        // Chained by features\n        me.populateCard({\n            taskRecord,\n            columnRecord,\n            swimlaneRecord,\n            cardConfig,\n            cardSize\n        });\n\n        // Supplied by app\n        me.taskRenderer?.({\n            taskRecord,\n            columnRecord,\n            swimlaneRecord,\n            cardConfig,\n            cardSize\n        });\n\n        // <remove-on-release>\n        // TODO: headerRenderer, bodyRenderer, footerRenderer?\n        // </remove-on-release>\n\n        // Remove unused parts of the card\n        if (header.html == null && header.text == null && (!header.children || Object.keys(header.children).length === 0)) {\n            children.header = null;\n        }\n\n        if (body.html == null && body.text == null && (!body.children || Object.keys(body.children).length === 0)) {\n            children.body = null;\n        }\n\n        if (footer.html == null && footer.text == null && (!footer.children || Object.keys(footer.children).length === 0)) {\n            children.footer = null;\n        }\n\n        return cardConfig;\n    }\n\n    renderColumnHeader(columnRecord) {\n        const\n            me                 = this,\n            { text, id, domId, width, flex, minWidth, color, tooltip } = columnRecord,\n            namedColor         = DomHelper.isNamedColor(color) ? color : null,\n            columnHeaderConfig = {\n                id    : `${me.id}-column-header-${domId}`,\n                class : {\n                    'b-taskboard-column-header'         : 1,\n                    'b-fixed-width'                     : width && !flex,\n                    [`b-taskboard-color-${namedColor}`] : namedColor,\n                    'b-last'                            : columnRecord === this.columns.last\n                },\n                style : {\n                    color : namedColor ? null : color,\n                    width,\n                    flex,\n                    minWidth\n                },\n                children : {\n                    padder : {\n                        class : {\n                            'b-taskboard-column-header-padder' : 1\n                        },\n                        children : {\n                            title : {\n                                class : {\n                                    'b-taskboard-column-title' : 1\n                                },\n                                dataset : {\n                                    btip : tooltip\n                                },\n                                children : [\n                                    {\n                                        tag   : 'span',\n                                        class : 'b-column-title-text',\n                                        text\n                                    },\n                                    me.showCountInHeader && {\n                                        tag   : 'span',\n                                        class : {\n                                            'b-taskboard-column-count' : 1\n                                        },\n                                        html : `(${me.getColumnTasks(columnRecord)?.length ?? 0})`\n                                    }\n                                ]\n                            }\n                        }\n                    }\n                },\n                dataset : {\n                    column        : domId,\n                    domTransition : true\n                },\n                elementData : {\n                    elementType : 'columnHeader',\n                    columnId    : id\n                }\n            };\n\n        Tooltip.showOverflow = true;\n\n        // Chained by features\n        me.populateColumnHeader({\n            columnRecord,\n            columnHeaderConfig\n        });\n\n        // Supplied by app\n        me.columnHeaderRenderer?.({\n            columnRecord,\n            columnHeaderConfig\n        });\n\n        return columnHeaderConfig;\n    }\n\n    renderColumn(swimlaneRecord, columnRecord) {\n        const\n            me            = this,\n            {\n                taskSorterFn,\n                stretchCards,\n                columnField,\n                swimlaneField\n            }             = me,\n            {\n                width,\n                flex,\n                id,\n                domId,\n                minWidth,\n                color\n            }             = columnRecord,\n            { taskStore } = me.project,\n            // Tasks in this column / swimlane intersection. Fetched using an index for better performance, except when\n            // using a tree store, since only the expended tasks are indexed then (only those are in storage)\n            tasks         = taskStore.isTree\n                ? taskStore.query(r =>\n                    r[columnField] === id &&\n                    (!swimlaneField || !swimlaneRecord || r[swimlaneField] === swimlaneRecord.id) // Might have no lanes\n                )\n                : Array.from(taskStore.storage.findItem(\n                    'columnSwimlaneIntersection',\n                    `${columnRecord.id}-/-${swimlaneRecord?.id ?? 'default'}`\n                ) || []),\n            perRow       = me.getTasksPerRow(columnRecord, swimlaneRecord),\n            elementId    = `${me.id}-column-${swimlaneRecord?.domId ?? 'default'}-${domId}`,\n            namedColor   = DomHelper.isNamedColor(color) ? color : null,\n            columnConfig = {\n                id    : elementId,\n                class : {\n                    'b-taskboard-column'                                 : 1,\n                    'b-fixed-width'                                      : width && !flex,\n                    [`b-${perRow}-task${perRow > 1 ? 's' : ''}-per-row`] : 1,\n                    'b-inline'                                           : perRow > 1,\n                    [`b-taskboard-color-${namedColor}`]                  : namedColor,\n                    'b-last'                                             : columnRecord === this.columns.last\n                },\n                style : {\n                    color : namedColor ? null : color,\n                    width,\n                    flex,\n                    minWidth\n                },\n                dataset : {\n                    column        : domId,\n                    lane          : swimlaneRecord?.id,\n                    domTransition : true\n                },\n                elementData : {\n                    elementType : 'column',\n                    columnId    : id,\n                    laneId      : swimlaneRecord?.id\n                },\n                // Cards\n                children : {\n                    body : {\n                        id    : `${elementId}-body`,\n                        class : {\n                            'b-taskboard-column-body' : 1\n                        },\n                        dataset : {\n                            role          : 'body',\n                            domTransition : true\n                        },\n                        children : [\n                            {\n                                class : {\n                                    'b-taskboard-column-body-inner' : 1\n                                },\n                                style : {\n                                    'grid-template-columns' : `repeat(${stretchCards ? Math.min(perRow, tasks.length) : perRow}, 1fr)`\n                                },\n                                dataset : {\n                                    role          : 'inner',\n                                    domTransition : true\n                                },\n                                children : (() => {\n                                    // Optionally force sort order\n                                    if (taskSorterFn) {\n                                        tasks.sort(taskSorterFn);\n                                    }\n                                    // Otherwise match store order, Set is unordered\n                                    else {\n                                        tasks.sort((a, b) => taskStore.indexOf(a) - taskStore.indexOf(b));\n                                    }\n\n                                    return tasks.map(taskRecord => me.renderCard(taskRecord, columnRecord, swimlaneRecord));\n                                })(),\n                                syncOptions : {\n                                    syncIdField      : 'task',\n                                    releaseThreshold : me.isVirtualized ? 1000 : 0\n                                }\n                            }\n                        ],\n                        syncOptions : {\n                            syncIdField : 'role'\n                        }\n                    }\n                },\n                syncOptions : {\n                    syncIdField : 'role'\n                }\n            };\n\n        // Chained by features\n        me.populateColumn({\n            columnRecord,\n            swimlaneRecord,\n            columnConfig\n        });\n\n        // Supplied by app\n        me.columnRenderer?.({\n            columnRecord,\n            swimlaneRecord,\n            columnConfig\n        });\n\n        return columnConfig;\n    }\n\n    renderSwimlane(swimlaneRecord) {\n        const\n            me                             = this,\n            { showCountInHeader, columns } = me,\n            {\n                id = 'default',\n                domId = 'default',\n                text,\n                height,\n                flex,\n                color\n            }                              = swimlaneRecord || {},\n            elementId                      = `${me.id}-swimlane-${domId}`,\n            namedColor                     = DomHelper.isNamedColor(color) ? color : null,\n            swimlaneConfig                 = {\n                id    : elementId,\n                class : {\n                    'b-taskboard-swimlane'              : 1,\n                    'b-fixed-height'                    : height && !flex,\n                    'b-last'                            : !swimlaneRecord || swimlaneRecord === me.swimlanes.last,\n                    [`b-taskboard-color-${namedColor}`] : namedColor\n                },\n                style : {\n                    color : namedColor ? null : color,\n                    height,\n                    flex\n                },\n                dataset : {\n                    lane          : domId,\n                    domTransition : true\n                },\n                elementData : {\n                    elementType : 'swimlane',\n                    laneId      : id\n                },\n                children : {\n                    // If a lane is defined, it has a header\n                    header : swimlaneRecord && {\n                        id    : `${elementId}-header`,\n                        tag   : 'header',\n                        class : {\n                            'b-taskboard-swimlane-header' : 1\n                        },\n                        dataset : {\n                            role          : 'header',\n                            domTransition : 'preserve-padding'\n                        },\n                        children : {\n                            title : {\n                                class : {\n                                    'b-taskboard-swimlane-title' : 1\n                                },\n                                children : {\n                                    text,\n                                    count : showCountInHeader && {\n                                        tag   : 'span',\n                                        class : {\n                                            'b-taskboard-swimlane-count' : 1\n                                        },\n                                        text : `(${me.getSwimlaneTasks(swimlaneRecord)?.size ?? 0})`\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    // Lane or no lane, there is always a body to contain columns\n                    body : {\n                        id    : `${elementId}-body`,\n                        class : {\n                            'b-taskboard-swimlane-body' : 1\n                        },\n                        dataset : {\n                            role          : 'body',\n                            domTransition : true\n                        },\n                        // Columns within the lane\n                        children : columns.map(column =>\n                            !column.hidden && me.renderColumn(swimlaneRecord, column)\n                        ),\n                        syncOptions : {\n                            syncIdField      : 'column',\n                            releaseThreshold : 0\n                        }\n                    }\n                },\n                syncOptions : {\n                    syncIdField : 'role'\n                }\n            };\n\n        me.populateSwimlane({\n            swimlaneRecord,\n            swimlaneConfig\n        });\n\n        // Supplied by app\n        me.swimlaneRenderer?.({\n            swimlaneRecord,\n            swimlaneConfig\n        });\n\n        return swimlaneConfig;\n    }\n\n    // Creates a DOM config for the entire TaskBoard, rendered to panels body\n    get bodyConfig() {\n        const\n            me = this,\n            // <remove-on-release>\n            // TODO: Ask Don about a better way\n            // </remove-on-release>\n            // Pull in configs that affect rendering, even if not used here to prime them\n            {\n                /* eslint-disable no-unused-vars */\n                stickyHeaders,\n                showCountInHeader,\n                columns,\n                columnField,\n                swimlaneField,\n                tasksPerRow,\n                headerItems,\n                bodyItems,\n                footerItems,\n                selectedTasks,\n                showCollapseInHeader,\n                showCollapseTooltip,\n                taskSorterFn,\n                stretchCards\n                /* eslint-enable no-unused-vars */\n            }  = me;\n\n        // On first compose, supply a minimal body to have element ready when features inject their contents on next\n        // compose. Allows us to avoid using hacks to pull features in early\n        if (!me.rendered) {\n            // Queue up another recompose after the minimal bootstrap, to render columns while loading\n            me.setTimeout(() => me.recompose(), 0);\n\n            return {\n                // Required by panel, it expects a bodyElement reference\n                reference : 'bodyElement',\n                // Listeners are only set up on first sync, has to go here (not internalListeners no purpose, these are\n                // EventHelper listeners)\n                // eslint-disable-next-line bryntum/no-listeners-in-lib\n                listeners : ObjectHelper.assign({ thisObj : me }, me.domListeners)\n            };\n        }\n\n        // We get here on second compose, features are now pulled in and we have an outer element ready\n        const bodyConfig = {\n            // Save some processing by not cloning the config, it is regenerated on every compose anyway\n            skipClone : true,\n            reference : 'bodyElement',\n            class     : {\n                'b-taskboard-body' : 1,\n                'b-sticky-headers' : stickyHeaders\n            },\n            children : [\n                // Column headers\n                {\n                    tag   : 'header',\n                    id    : `${me.id}-column-headers`,\n                    class : {\n                        'b-taskboard-column-headers' : 1\n                    },\n                    children : columns.map(column => !column.hidden && me.renderColumnHeader(column)),\n                    dataset  : {\n                        lane          : 'header',\n                        domTransition : true\n                    },\n                    syncOptions : {\n                        syncIdField : 'column'\n                    }\n                }\n            ],\n            syncOptions : {\n                syncIdField      : 'lane',\n                releaseThreshold : 0,\n                ignoreRefs       : 'children' // References in \"children\" should not be hoisted to the panel\n            }\n        };\n\n        let { swimlanes } = me;\n\n        // There is always a swimlane\n        if (!swimlanes?.count) {\n            swimlanes = [null];\n        }\n\n        // Swimlanes\n        for (const lane of swimlanes) {\n            if (!lane?.hidden) {\n                bodyConfig.children.push(me.renderSwimlane(lane));\n            }\n        }\n\n        me.populateBody({\n            bodyConfig\n        });\n\n        me.isComposed = true;\n\n        return bodyConfig;\n    }\n\n    // For chaining, to decorate dom config\n    populateCard(args) {\n        super.populateCard?.(args);\n    }\n\n    populateColumn(args) {\n        super.populateColumn?.(args);\n    }\n\n    populateColumnHeader(args) {\n        super.populateColumnHeader?.(args);\n    }\n\n    populateSwimlane(args) {\n        super.populateSwimlane?.(args);\n    }\n\n    populateBody(args) {\n        super.populateBody?.(args);\n    }\n\n    afterRecompose() {\n        super.afterRecompose();\n\n        const me = this;\n\n        if (!me.isInitiallyComposed && me.isComposed) {\n            me.isInitiallyComposed = true;\n            me.initialCompose();\n        }\n\n        if (me.project.taskStore.count > 0) {\n            me.trigger('renderTasks', { taskRecords : me.project.taskStore.allRecords });\n        }\n\n        me.transitionRecompose = null;\n    }\n\n    // For chaining, replaces render() since we don't do full compose on render\n    initialCompose() {\n        this.trigger('initialCompose');\n    }\n\n    // For chaining, to react to element changes\n    onRenderColumn() {}\n\n    onRemoveColumnElement() {}\n\n    onRenderSwimlane() {}\n\n    onRemoveSwimlaneElement() {}\n\n    //endregion\n\n    //region Transition - experimental\n\n    // Prevent dom transitions until resumed\n    suspendDomTransition() {\n        this.domTransitionSuspended++;\n    }\n\n    // Resume dom transitions\n    resumeDomTransition() {\n        this.domTransitionSuspended--;\n    }\n\n    // Recompose transitioning dom\n    recomposeWithDomTransition(options) {\n        const me = this;\n\n        if (me.useDomTransition && !me.domTransitionSuspended) {\n            me.transitionRecompose = {\n                selector : '[data-dom-transition]',\n                duration : 300,\n                element  : me._bodyElement, // _ needed to not flush recompose if we are dirty\n                ...options\n            };\n        }\n\n        // Transitioned recompose takes a bit of time, if we are requested to recompose again while it is ongoing,\n        // we queue up another recompose to run after the transition is done\n        if (me.recompose.suspended) {\n            me._recomposeQueued = true;\n        }\n        else {\n            me.recompose();\n        }\n    }\n\n    resumeRecompose() {\n        super.resumeRecompose();\n\n        // Kick of another recompose if needed, see comment in recomposeWithDomTransition() above\n        if (this._recomposeQueued) {\n            this._recomposeQueued = null;\n            this.recompose();\n        }\n    }\n\n    //endregion\n\n    //region Extract configs\n\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    // It extracts the current configs for the task board, with special handling for columns\n    getCurrentConfig(options) {\n        const result = super.getCurrentConfig(options);\n\n        if (result.columns) {\n            delete result.columns.modelClass;\n        }\n\n        return result;\n    }\n\n    //endregion\n\n    // Expected by CrudManagerView\n    refresh() {\n        this.recompose();\n    }\n}\n\nTaskBoardBase.initClass();\nVersionHelper.setVersion('taskboard', '5.5.0');\n", "import TaskItem from './TaskItem.js';\n\n/**\n * @module TaskBoard/view/item/TaskMenuItem\n */\n\n/**\n * Item that adds a `···` button hooked up to display the {@link TaskBoard/feature/TaskMenu} on click.\n *\n * Requires the {@link TaskBoard/feature/TaskMenu} to work as intended.\n *\n * {@inlineexample TaskBoard/view/item/TaskMenuItem.js}\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classType taskMenu\n */\nexport default class TaskMenuItem extends TaskItem {\n    static $name = 'TaskMenuItem';\n\n    static type = 'taskMenu';\n\n    /**\n     * @hideconfigs editor\n     */\n\n    static defaultEditor = null;\n\n    static render({ taskBoard, domConfig }) {\n        if (!taskBoard.features.taskMenu || taskBoard.features.taskMenu.disabled) {\n            return false;\n        }\n\n        domConfig.tag = 'button';\n        domConfig.class['b-icon b-icon-menu-horizontal'] = 1;\n    }\n\n    static onClick({ source : taskBoard, event }) {\n        taskBoard.features.taskMenu?.showContextMenu(event, { target : event.target });\n    }\n}\n\nTaskMenuItem.initClass();\n", "import TaskBoardBase from './TaskBoardBase.js';\n\nimport '../feature/ColumnHeaderMenu.js';\nimport '../feature/ColumnToolbars.js';\nimport '../feature/TaskDrag.js';\nimport '../feature/TaskDragSelect.js';\nimport '../feature/TaskEdit.js';\nimport '../feature/TaskMenu.js';\n\nimport './item/ImageItem.js';\nimport './item/ProgressItem.js';\nimport './item/RatingItem.js';\nimport './item/ResourceAvatarsItem.js';\nimport './item/SeparatorItem.js';\nimport './item/TagsItem.js';\nimport './item/TaskMenuItem.js';\nimport './item/TemplateItem.js';\nimport './item/TodoListItem.js';\n\n/**\n * @module TaskBoard/view/TaskBoard\n */\n\n/**\n * A kanban board widget that allows you to visualize and mange tasks.\n *\n * {@inlineexample TaskBoard/view/TaskBoardBasic.js}\n *\n * ## Datalayer\n *\n * TaskBoards datalayer is based on Schedulers. It consumes a {@link TaskBoard.model.ProjectModel project} that holds\n * stores that in turn holds records. The stores used by default are:\n *\n * * {@link TaskBoard.store.TaskStore} - Store holding tasks, which are instances of {@link TaskBoard.model.TaskModel}\n * * {@link Scheduler.store.ResourceStore} - Holds resources, see {@link Scheduler.model.ResourceModel}\n * * {@link Scheduler.store.AssignmentStore} - Holds assignments, links between resources and tasks, see {@link Scheduler.model.AssignmentModel}\n *\n * Data can be supplied inline or loaded using the projects {@link Scheduler.data.mixin.ProjectCrudManager CrudManager}\n * capabilities. Example using inline data:\n *\n * {@frameworktabs}\n * {@js}\n *\n * ```javascript\n * new TaskBoard({\n *     project : {\n *         tasksData : [\n *             { id : 1, name : 'Try TaskBoard' }\n *         ]\n *     }\n * });\n * ```\n *\n * {@endjs}\n * {@react}\n *\n * ```jsx\n * const App = props => {\n *     const project = useRef();\n *\n *     const [tasks] = useState([\n *          { id : 1, name : 'Try TaskBoard' }\n *     ]);\n *\n *     return (\n *         <>\n *             <BryntumProjectModel ref={project} tasks={tasks} />\n *             <BryntumTaskBoard project={project} />\n *         </>\n *     )\n * }\n * ```\n *\n * {@endreact}\n * {@vue}\n *\n * ```html\n * <bryntum-project-model ref=\"project\" :tasks=\"tasks\" />\n * <bryntum-task-board :project=\"project\" />\n * ```\n *\n * ```javascript\n * export default {\n *    setup() {\n *      return {\n *         tasks : reactive([\n *             { id : 1, name : 'Try TaskBoard' }\n *         ])\n *      };\n *    }\n * }\n * ```\n *\n * {@endvue}\n * {@angular}\n *\n * ```html\n * <bryntum-project-model #project [tasks]=\"tasks\"></bryntum-project-model>\n * <bryntum-task-board [project]=\"project\"></bryntum-task-board>\n * ```\n *\n * ```typescript\n * export class AppComponent {\n *     tasks = [\n *         { id : 1, name : 'Try TaskBoard' }\n *     ]\n *  }\n * ```\n *\n * {@endangular}\n * {@endframeworktabs}\n *\n * And using CrudManager to load remote data:\n *\n * {@frameworktabs}\n * {@js}\n *\n * ```javascript\n * new TaskBoard({\n *     project : {\n *         loadUrl : 'data/load.php',\n *         autoLoad : true\n *     }\n * });\n * ```\n *\n * {@endjs}\n * {@react}\n *\n * ```jsx\n * const App = props => {\n *     const project = useRef();\n *\n *     return (\n *         <>\n *             <BryntumProjectModel ref={project} loadUrl=\"data/load.php\" />\n *             <BryntumTaskBoard project={project} />\n *         </>\n *     )\n * }\n * ```\n *\n * {@endreact}\n * {@vue}\n *\n * ```html\n * <bryntum-project-model ref=\"project\" :load-url=\"loadUrl\" />\n * <bryntum-task-board :project=\"project\" />\n * ```\n *\n * ```javascript\n * export default {\n *    setup() {\n *      return {\n *         loadUrl : 'data/load.php'\n *      };\n *    }\n * }\n * ```\n *\n * {@endvue}\n * {@angular}\n *\n * ```html\n * <bryntum-project-model #project [loadUrl]=\"loadUrl\"></bryntum-project-model>\n * <bryntum-task-board [project]=\"project\"></bryntum-task-board>\n * ```\n *\n * ```typescript\n * export class AppComponent {\n *     loadUrl = 'data/load.php'\n *  }\n * ```\n *\n * {@endangular}\n * {@endframeworktabs}\n *\n * ## Columns\n *\n * The tasks are displayed in columns. Which column a task belongs to is determined by the tasks value for the\n * configured {@link #config-columnField}. Columns can be defined as strings or as {@link TaskBoard.model.ColumnModel}\n * data objects, supplied to the {@link #config-columns columns config}. This snippet illustrates it:\n *\n * {@frameworktabs}\n * {@js}\n *\n * ```javascript\n * new TaskBoard({\n *     // The status field of tasks will be used to link a task to a column\n *     columnField : 'status',\n *\n *     // Columns as strings or objects\n *     columns : [\n *         'todo', // Will be displayed as Todo\n *         { id : 'done', text : 'Done!' }\n *     ],\n *\n *     // TaskBoard data\n *     project : {\n *         tasksData : [\n *             // Since we use the \"status\" field to determine column,\n *             // this task will belong to the \"done\" column\n *             { id : 1, name : 'Create mockup', status : 'done' },\n *             // And this one to \"todo\"\n *             { id : 2, name : 'Write docs', status : 'todo' }\n *         ]\n *     }\n * });\n * ```\n *\n * {@endjs}\n * {@react}\n *\n * ```jsx\n * const App = props => {\n *     const project = useRef();\n *\n *     // TaskBoard data\n *     const [tasks] = useState([\n *         // Since we use the \"status\" field to determine column,\n *         // this task will belong to the \"done\" column\n *         { id : 1, name : 'Create mockup', status : 'done' },\n *        // And this one to \"todo\"\n *        { id : 2, name : 'Write docs', status : 'todo' }\n *     ]);\n *\n *     // Columns as strings or objects\n *     const columns = [\n *        'todo', // Will be displayed as Todo\n *         { id : 'done', text : 'Done!' }\n *     ];\n *\n *     // The status field of tasks will be used to link a task to a column\n *     const columnField = 'status';\n *\n *     return (\n *         <>\n *             <BryntumProjectModel ref={project} tasks={tasks} />\n *             <BryntumTaskBoard\n *                 project={project}\n *                 columns={columns}\n *                 columnField={columnField}\n *                 />\n *         </>\n *     )\n * }\n * ```\n *\n * {@endreact}\n * {@vue}\n *\n * ```html\n * <bryntum-project-model ref=\"project\" :tasks=\"tasks\" />\n * <bryntum-task-board\n *     :project=\"project\"\n *     :columns=\"columns\"\n *     :columnField=\"columnField\"\n *     />\n * ```\n *\n * ```javascript\n * export default {\n *     setup() {\n *         return {\n *             // TaskBoard data\n *             tasks : reactive([\n *                 // Since we use the \"status\" field to determine column,\n *                 // this task will belong to the \"done\" column\n *                 { id : 1, name : 'Create mockup', status : 'done' },\n *                 // And this one to \"todo\"\n *                 { id : 2, name : 'Write docs', status : 'todo' }\n *             ]),\n *\n *             // Columns as strings or objects\n *             columns : [\n *                 'todo', // Will be displayed as Todo\n *                 { id : 'done', text : 'Done!' }\n *             ],\n *\n *             // The status field of tasks will be used to link a task to a column\n *             columnField : 'status'\n *         };\n *     }\n * }\n * ```\n *\n * {@endvue}\n * {@angular}\n *\n * ```html\n * <bryntum-project-model #project [tasks]=\"tasks\"></bryntum-project-model>\n * <bryntum-task-board\n *     [project]=\"project\"\n *     [columns]=\"columns\"\n *     [columnField]=\"columnField\"\n *     >\n * </bryntum-task-board>\n * ```\n *\n * ```typescript\n * export class AppComponent {\n *     // TaskBoard data\n *     tasks = reactive([\n *         // Since we use the \"status\" field to determine column,\n *         // this task will belong to the \"done\" column\n *         { id : 1, name : 'Create mockup', status : 'done' },\n *         // And this one to \"todo\"\n *         { id : 2, name : 'Write docs', status : 'todo' }\n *     ])\n *\n *     // Columns as strings or objects\n *     columns = [\n *         'todo', // Will be displayed as Todo\n *         { id : 'done', text : 'Done!' }\n *     ]\n *\n *     // The status field of tasks will be used to link a task to a column\n *     columnField = 'status'\n *  }\n * ```\n *\n * {@endangular}\n * {@endframeworktabs}\n *\n * The supplied columns are loaded into an internal store, named {@link #property-columns}. You can use it at runtime\n * to access, add, remove and filter columns.\n *\n * ## Swimlanes\n *\n * The TaskBoard can optionally be divided into horizontal swimlanes.\n *\n * {@inlineexample TaskBoard/view/TaskBoardSwimlanes.js}\n *\n * They are defined and populated in a very similar manner to columns:\n *\n * {@frameworktabs}\n * {@js}\n *\n * ```javascript\n * new TaskBoard({\n *     // The prio field of tasks will be used to link a task to a swimlane\n *     swimlaneField : 'prio',\n *\n *     // Swimlanes as strings or objects\n *     swimlanes : [\n *         'low', // Will be displayed as Low\n *         { id : 'high', text : 'High!' }\n *     ],\n *\n *     // TaskBoard data\n *     project : {\n *         tasksData : [\n *             // Since we use the \"prio\" field to determine swimlane,\n *             // this task will belong to the \"high\" lane\n *             { id : 1, name : 'Create mockup', status : 'done', prio : 'high' },\n *\n *             // And this one to \"low\"\n *             { id : 2, name : 'Write docs', status : 'todo', prio : 'low' }\n *         ]\n *     }\n * });\n * ```\n *\n * {@endjs}\n * {@react}\n *\n * ```jsx\n * const App = props => {\n *     const project = useRef();\n *\n *     // TaskBoard data\n *     const [tasks] = useState([\n *         // Since we use the \"prio\" field to determine swimlane,\n *         // this task will belong to the \"high\" lane\n *         { id : 1, name : 'Create mockup', status : 'done', prio : 'high' },\n *\n *         // And this one to \"low\"\n *         { id : 2, name : 'Write docs', status : 'todo', prio : 'low' }\n *     ]);\n *\n *     // Swimlanes as strings or objects\n *     const swimlanes = [\n *        'low', // Will be displayed as Low\n *         { id : 'high', text : 'High!' }\n *     ];\n *\n *     // The prio field of tasks will be used to link a task to a swimlane\n *     const swimlaneField = 'prio';\n *\n *     return (\n *         <>\n *             <BryntumProjectModel ref={project} tasks={tasks} />\n *             <BryntumTaskBoard\n *                 project={project}\n *                 swimlanes={swimlanes}\n *                 swimlaneField={swimlaneField}\n *                 />\n *         </>\n *     )\n * }\n * ```\n *\n * {@endreact}\n * {@vue}\n *\n * ```html\n * <bryntum-project-model ref=\"project\" :tasks=\"tasks\" />\n * <bryntum-task-board\n *     :project=\"project\"\n *     :swimlanes=\"swimlanes\"\n *     :swimlaneField=\"swimlaneField\"\n *     />\n * ```\n *\n * ```javascript\n * export default {\n *     setup() {\n *         return {\n *             // TaskBoard data\n *             tasks : reactive([\n *                 // Since we use the \"prio\" field to determine swimlane,\n *                 // this task will belong to the \"high\" lane\n *                 { id : 1, name : 'Create mockup', status : 'done', prio : 'high' },\n *\n *                 // And this one to \"low\"\n *                 { id : 2, name : 'Write docs', status : 'todo', prio : 'low' }\n *             ]),\n *\n *             // Swimlanes as strings or objects\n *             swimlane : [\n *                 'low', // Will be displayed as Low\n *                 { id : 'high', text : 'High!' }\n *             ],\n *\n *             // The prio field of tasks will be used to link a task to a swimlane\n *             swimlanenField : 'prio'\n *         };\n *     }\n * }\n * ```\n *\n * {@endvue}\n * {@angular}\n *\n * ```html\n * <bryntum-project-model #project [tasks]=\"tasks\"></bryntum-project-model>\n * <bryntum-task-board\n *     [project]=\"project\"\n *     [swimlanes]=\"swimlanes\"\n *     [swimlaneField]=\"swimlaneField\"\n *     >\n * </bryntum-task-board>\n * ```\n *\n * ```typescript\n * export class AppComponent {\n *     // TaskBoard data\n *     tasks = [\n *         // Since we use the \"prio\" field to determine swimlane,\n *         // this task will belong to the \"high\" lane\n *         { id : 1, name : 'Create mockup', status : 'done', prio : 'high' },\n *\n *         // And this one to \"low\"\n *         { id : 2, name : 'Write docs', status : 'todo', prio : 'low' }\n *     ]\n *\n *     // Swimlanes as strings or objects\n *     swimlanes = [\n *         'low', // Will be displayed as Low\n *         { id : 'high', text : 'High!' }\n *     ]\n *\n *     // The prio field of tasks will be used to link a task to a swimlane\n *     swimlaneField = 'prio'\n *  }\n * ```\n *\n * {@endangular}\n * {@endframeworktabs}\n *\n * ## Task order\n *\n * The order of tasks in a column is determined by their order in the task store. By default the store is sorted by\n * {@link TaskBoard/model/TaskModel#field-weight}. Changing store sorting will rearrange the tasks:\n *\n * ```javascript\n * // Rearrange tasks by name\n * taskBoard.project.taskStore.sort('name');\n * ```\n *\n * When loading tasks that has no weights specified a generated weight (index * 100) will be silently assigned.\n *\n * Dragging and dropping tasks changes their weight and resorts the store. Note that if you want to sort by something\n * other than weight and still want a task to stay where it is dropped you will have to opt out of the default\n * behaviour by configuring {@link TaskBoard/feature/TaskDrag#config-reorderTaskRecords} as `true`.\n *\n * If you programmatically change a weight you have to manually sort the store for the task to move:\n *\n * ```javascript\n * // Programmatic change of weight requires resorting manually\n * taskBoard.project.taskStore.first.weight = 1000;\n * taskBoard.project.taskStore.sort();\n * ```\n *\n * ## Sharing a project\n *\n * When consuming a project from a different product (for example Gantt), you will likely want the cards on the board\n * to have a stable order no matter how data is sorted in the other product. This can be achieved by configuring a\n * {@link #config-taskSorterFn}, which is then applied on the UI layer to resort tasks before rendering their cards.\n * You can use it to enforce sorting by weight:\n *\n * ```javascript\n * // Shortcut to always enforce sorting by weight\n * const taskBoard = new TaskBoard({\n *    taskSorterFn : true\n * });\n * ```\n *\n * Or supply a custom [Array sort](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)\n * function:\n *\n * ```javascript\n * // Custom sorting fn\n * const taskBoard = new TaskBoard({\n *    taskSorterFn(a, b) {\n *        return a.name.localeCompare(b.name);\n *    }\n * });\n * ```\n *\n * <div class=\"note\">\n * When consuming a non-TaskBoard project no weights will be assigned by default, make sure your data has weights if\n * you want stable task ordering.\n * </div>\n *\n * ## Customizing task content\n *\n * Task contents can be easily customized using {@link TaskBoard/view/mixin/TaskItems task items}, lightweight\n * \"widgets\" that can be added to a tasks header, body and footer.\n *\n * For more control over what gets rendered into a task, you can supply a {@link #config-taskRenderer} function. It is\n * called prior to updating the DOM for each task, allowing you to directly manipulate what ends up there.\n *\n * For more information see:\n *\n * * [Styling guide](#TaskBoard/guides/customization/styling.md)\n * * [Customize task contents guide](#TaskBoard/guides/customization/taskcontents.md)\n *\n * ## Large data sets\n *\n * Having a large number of cards rendered to DOM simultaneously can lead to poor performance. To address this issue,\n * TaskBoard supports partial virtualized rendering. This means that only the cards that are visible in the viewport\n * are fully rendered, cards outside the viewport are only outlined.\n *\n * When enabled, the board displays faster and is more responsive with big data sets, but it also means that scrolling\n * is more costly since cards coming into view has to be rendered. And since it is not fully virtualized, the board will\n * still be slow with very large data sets.\n *\n * <div class=\"note\">A Kanban board is best suited for using with a smaller set of tasks (hundreds rather than\n * thousands). Before enabling partial virtualized rendering we strongly recommend you consider restructuring the\n * application. Could it for example filter the tasks based on user, project or similar to work on a subset?</div>\n *\n * To enable partial virtualized rendering, the height of all tasks must be known. To communicate this to the TaskBoard,\n * implement a {@link #config-getTaskHeight getTaskHeight()} function. See its documentation for more information and\n * snippets.\n *\n * <div class=\"note\">Note that as part of the optimizations for partial virtualized rendering, the inner element in\n * columns that contain cards is absolutely positioned. This leads to column not being able to automatically shrink wrap\n * the cards, you will have to set a height on the swimlane (or task board if not using swimlanes) to size things\n * correctly.</div>\n *\n * {@region Keyboard shortcuts}\n * TaskBoard has the following default keyboard shortcuts:\n * <div class=\"compact\">\n *\n * | Keys                 | Action                 | Action description                                                         |\n * |----------------------|------------------------|----------------------------------------------------------------------------|\n * | `ArrowDown`          | *navigateDown*         | Moves focus to task below currently focused element                        |\n * | `ArrowLeft`          | *navigateLeft*         | Moves focus to task to the left of currently focused element               |\n * | `ArrowUp`            | *navigateUp*           | Moves focus to task above currently focused element                        |\n * | `ArrowRight`         | *navigateRight*        | Moves focus to task to the right of currently focused element              |\n * | `Enter`              | *activate*             | Show the Task Editor for currently focused task                            |\n * | `Space`              | *keyboardSelect*       | This selects or deselects the focused card (deselecting all others)        |\n * | `Ctrl`+`Space`       | *keyboardToggleSelect* | This selects or deselects the focused card, preserving any other selection |\n * | `Shift`+`ArrowDown`  | *selectDown*           | Hold `Shift` when keyboard navigating to extend selection                  |\n * | `Shift`+`ArrowLeft`  | *selectLeft*           | Hold `Shift` when keyboard navigating to extend selection                  |\n * | `Shift`+`ArrowUp`    | *selectUp*             | Hold `Shift` when keyboard navigating to extend selection                  |\n * | `Shift`+`ArrowRight` | *selectRight*          | Hold `Shift` when keyboard navigating to extend selection                  |\n *\n * </div>\n *\n * <div class=\"note\" style=\"font-size:0.9em\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * If you prefer for selection to always move with the arrow keys, see\n * {@link TaskBoard.view.mixin.TaskNavigation#config-selectOnNavigation}.\n *\n * The following TaskBoard features has their own keyboard shortcuts. Follow the links for details.\n * * {@link TaskBoard.feature.ColumnHeaderMenu#keyboard-shortcuts ColumnHeaderMenu}\n * * {@link TaskBoard.feature.SimpleTaskEdit#keyboard-shortcuts SimpleTaskEdit}\n * * {@link TaskBoard.feature.TaskMenu#keyboard-shortcuts TaskMenu}\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#TaskBoard/guides/customization/keymap.md).\n * {@endregion}\n *\n * ## Find out more\n *\n * * {@link TaskBoard.view.mixin.ExpandCollapse Expanding and collapsing columns and swimlanes}\n * * {@link TaskBoard.view.mixin.ResponsiveCards Responsive behaviour for cards}\n * * {@link TaskBoard.view.mixin.TaskBoardDom Resolving elements <-> records}\n * * {@link TaskBoard.view.mixin.TaskBoardDomEvents Handling card events}\n * * {@link TaskBoard.view.mixin.TaskBoardScroll Scrolling to tasks, columns and swimlanes}\n * * {@link TaskBoard.view.mixin.TaskItems Add content to task cards}\n * * {@link TaskBoard.view.mixin.TaskNavigation Keyboard navigation}\n * * {@link TaskBoard.view.mixin.TaskSelection Selection tasks using mouse and keyboard}\n *\n * @extends TaskBoard/view/TaskBoardBase\n *\n * @classType taskboard\n * @widget\n */\nexport default class TaskBoard extends TaskBoardBase {\n    static $name = 'TaskBoard';\n    static type = 'taskboard';\n\n    static configurable = {\n        //region Hidden members\n\n        /**\n         * @hideconfigs crudManager, crudManagerClass, contentElementCls, htmlCls, defaults, hideWhenEmpty, itemCls, items, layout, layoutStyle, lazyItems, namedItems, textContent, content, html, defaultBindProperty, monitorResize, ripple, tooltip, tag, textAlign, preventTooltipOnTouch\n         */\n\n        /**\n         * @hideproperties $name, isSettingValues, isValid, items, layout, record, values, content, contentElement, focusElement, html, overflowElement, layoutStyle, tooltip, scrollable\n         */\n\n        /**\n         * @hidefunctions attachTooltip, isOfTypeName, mixin, optionalL, callback, resolveCallback, add, getWidgetById, insert, processWidgetConfig, remove, removeAll, construct, doDestroy, updateLocalization, compose, eachAncestor, eachWidget, query, queryAll, L\n         */\n\n        /**\n         * @event beforeSetRecord\n         * @hide\n         */\n\n        //endregion\n\n        features : {\n            columnHeaderMenu : true,\n            columnToolbars   : true,\n            taskDrag         : true,\n            taskDragSelect   : true,\n            taskEdit         : true,\n            taskMenu         : true\n        }\n    };\n}\n\nTaskBoard.initClass();\n", "import FilterField from '../../Core/widget/FilterField.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n\n/**\n * @module TaskBoard/widget/ColumnFilterField\n */\n\n/**\n * A field that filters the columns of a linked {@link TaskBoard.view.TaskBoard} when typing into it.\n *\n * {@inlineexample TaskBoard/widget/ColumnFilterField.js}\n *\n * When used within a TaskBoard, it connects to it automatically:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     tbar : [\n *         { type : 'columnfilterfield' }\n *     ]\n * });\n * ```\n *\n * When used outside of a TaskBoard, it will query globally to find one but if there are multiple on page it might have\n * to be linked to one manually (see {@link TaskBoard/widget/mixin/TaskBoardLinked#config-taskBoard}:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({});\n *\n * const picker = new ColumnFilterField({\n *    taskBoard // Link it to the taskBoard instance created above\n * });\n * ```\n *\n * @classtype columnfilterfield\n * @extends Core/widget/FilterField\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @widget\n */\nexport default class ColumnFilterField extends FilterField.mixin(TaskBoardLinked) {\n    static $name = 'ColumnFilterField';\n\n    static type = 'columnfilterfield';\n\n    static configurable = {\n\n        /**\n         * @hideconfigs store, filterFunction\n         */\n\n        store : 'this.taskBoard.columns',\n\n        /**\n         * The ColumnModel field name to filter by, defaults to `'text'`.\n         * @config {String}\n         * @default\n         * @category Common\n         */\n        field : 'text',\n\n        /**\n         * Label, defaults to a localized version of `'Filter columns'`.\n         *\n         * Content is determined by the `TaskBoard.filterColumns` key in the applied locale.\n         *\n         * @config {String}\n         * @category Label\n         */\n        label : 'L{TaskBoard.filterColumns}',\n\n        width : '20em',\n\n        triggers : {\n            filter : {\n                cls   : 'b-icon b-icon-filter',\n                align : 'start'\n            }\n        }\n    };\n}\n\nColumnFilterField.initClass();\n", "import StringHelper from '../../Core/helper/StringHelper.js';\nimport Button from '../../Core/widget/Button.js';\nimport '../../Core/widget/Menu.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n\n/**\n * @module TaskBoard/widget/ColumnPickerButton\n */\n\n/**\n * A button with a menu allowing the user to toggle which columns are shown on the {@link TaskBoard.view.TaskBoard}.\n *\n * {@inlineexample TaskBoard/widget/ColumnPickerButton.js}\n *\n * Click to display a menu populated with the columns held in {@link TaskBoard.view.TaskBoard#property-columns}.\n *\n * When used within a TaskBoard, it connects to it automatically:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     tbar : [\n *         { type : 'columnpickerbutton' }\n *     ]\n * });\n * ```\n *\n * When used outside of a TaskBoard, it will query globally to find one but if there are multiple on page it might have\n * to be linked to one manually (see {@link TaskBoard/widget/mixin/TaskBoardLinked#config-taskBoard}:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({});\n *\n * const picker = new ColumnPickerButton({\n *    taskBoard // Link it to the taskBoard instance created above\n * });\n * ```\n *\n * @classtype columnpickerbutton\n * @extends Core/widget/Button\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @widget\n */\nexport default class ColumnPickerButton extends Button.mixin(TaskBoardLinked) {\n    static $name = 'ColumnPickerButton';\n\n    static type = 'columnpickerbutton';\n\n    static configurable = {\n        text        : 'L{TaskBoard.Columns}',\n        icon        : 'b-icon-picker',\n        pressedIcon : 'b-icon-picker-rotated',\n        iconAlign   : 'end',\n        menuIcon    : null,\n        // items null needed to not be considered an object holding menu items\n        menu        : { items : null }\n    };\n\n    onToggleColumn({ item }) {\n        item.column.hidden = !item.checked;\n    }\n\n    // Populate menu before each show to make sure it is up to date\n    onMenuBeforeShow(info) {\n        super.onMenuBeforeShow(info);\n\n        info.source.items = this.taskBoard.columns.map(column => ({\n            ref     : column.id,\n            text    : StringHelper.encodeHtml(column.text),\n            checked : !column.hidden,\n            column,\n            onItem  : 'up.onToggleColumn'\n        }));\n    }\n}\n\nColumnPickerButton.initClass();\n", "import StringHelper from '../../Core/helper/StringHelper.js';\nimport Button from '../../Core/widget/Button.js';\nimport '../../Core/widget/Menu.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n\n/**\n * @module TaskBoard/widget/ColumnScrollButton\n */\n\n/**\n * A button with a menu allowing the user to pick a column to scroll to.\n *\n * {@inlineexample TaskBoard/widget/ColumnScrollButton.js}\n *\n * When used within a TaskBoard, it connects to it automatically:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     tbar : [\n *         { type : 'columnscrollbutton' }\n *     ]\n * });\n * ```\n *\n * When used outside of a TaskBoard, it will query globally to find one but if there are multiple on page it might have\n * to be linked to one manually (see {@link TaskBoard/widget/mixin/TaskBoardLinked#config-taskBoard}:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({});\n *\n * const picker = new ColumnScrollButton({\n *    taskBoard // Link it to the taskBoard instance created above\n * });\n * ```\n *\n * @classtype columnScrollButton\n * @extends Core/widget/Button\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @widget\n */\nexport default class ColumnScrollButton extends Button.mixin(TaskBoardLinked) {\n    static $name = 'ColumnScrollButton';\n\n    static type = 'columnscrollbutton';\n\n    static configurable = {\n        text        : 'L{TaskBoard.scrollToColumn}',\n        icon        : 'b-icon-picker',\n        pressedIcon : 'b-icon-picker-rotated',\n        iconAlign   : 'end',\n        menuIcon    : null,\n        menu        : []\n    };\n\n    onClickColumn({ item }) {\n        this.setTimeout(() => this.taskBoard?.scrollToColumn(item.column), 100);\n    }\n\n    changeMenu(menu) {\n        // Nullified on destroy\n        if (menu) {\n            menu = this.taskBoard.columns.map(column => ({\n                ref    : column.id,\n                text   : StringHelper.encodeHtml(column.text),\n                column,\n                onItem : 'up.onClickColumn'\n            }));\n        }\n\n        return super.changeMenu(menu);\n    }\n}\n\nColumnScrollButton.initClass();\n", "import SchedulerProjectCombo from '../../Scheduler/widget/ProjectCombo.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n\n/**\n * @module TaskBoard/widget/ProjectCombo\n */\n\n/**\n * Combo that allows picking a dataset to use for a {@link TaskBoard.model.ProjectModel}. Each item holds a title and\n * a load url to reconfigure the project with.\n *\n * {@inlineexample TaskBoard/widget/ProjectCombo.js}\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     tbar : [\n *         {\n *             type : 'taskboardprojectcombo',\n *             items : [\n *                 { title : 'Important project', url : 'data/load.php?id=1' },\n *                 { title : 'Another project', url : 'data/load.php?id=2' }\n *             ]\n *         }\n *     ],\n *\n *     project : {\n *         transport : {\n *             load : {\n *                 url : 'data/load.php?id=1'\n *             }\n *         },\n *\n *         autoLoad : true\n *     }\n * });\n * ```\n *\n * @extends Scheduler/widget/ProjectCombo\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @classType taskboardprojectcombo\n * @widget\n *\n * @typings Scheduler.widget.ProjectCombo -> Scheduler.widget.SchedulerProjectCombo\n */\nexport default class ProjectCombo extends SchedulerProjectCombo.mixin(TaskBoardLinked) {\n    static $name = 'ProjectCombo';\n    static type = 'taskboardprojectcombo';\n\n    static configurable = {\n        /**\n         * Project to reconfigure when picking an item. Resolved automatically if a TaskBoard is configured or detected.\n         * @config {TaskBoard.model.ProjectModel}\n         * @category Common\n         */\n        project : null\n    };\n\n    updateTaskBoard(taskBoard) {\n        if (taskBoard) {\n            this.project = taskBoard.project;\n        }\n    }\n\n    afterConfigure() {\n        // Force linking to project if TaskBoard is auto detected\n        if (!this._taskBoard) {\n            this.updateTaskBoard(this.taskBoard);\n        }\n    }\n}\n\n// Register this widget type with its Factory\nProjectCombo.initClass();\n", "import FilterField from '../../Core/widget/FilterField.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n\n/**\n * @module TaskBoard/widget/SwimlaneFilterField\n */\n\n/**\n * A field that filters the swimlanes of a linked {@link TaskBoard.view.TaskBoard} when typing into it.\n *\n * {@inlineexample TaskBoard/widget/SwimlaneFilterField.js}\n *\n * When used within a TaskBoard, it connects to it automatically:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     tbar : [\n *         { type : 'swimlanefilterfield' }\n *     ]\n * });\n * ```\n *\n * When used outside of a TaskBoard, it will query globally to find one but if there are multiple on page it might have\n * to be linked to one manually (see {@link TaskBoard/widget/mixin/TaskBoardLinked#config-taskBoard}:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({});\n *\n * const picker = new SwimlaneFilterField({\n *    taskBoard // Link it to the taskBoard instance created above\n * });\n * ```\n *\n * @classtype swimlanefilterfield\n * @extends Core/widget/FilterField\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @widget\n */\nexport default class SwimlaneFilterField extends FilterField.mixin(TaskBoardLinked) {\n    static $name = 'SwimlaneFilterField';\n\n    static type = 'swimlanefilterfield';\n\n    static configurable = {\n        store : 'this.taskBoard.swimlanes',\n\n        field : 'text',\n\n        label : 'L{TaskBoard.filterSwimlanes}',\n\n        width : '20em',\n\n        triggers : {\n            filter : {\n                cls   : 'b-icon b-icon-filter',\n                align : 'start'\n            }\n        }\n    };\n}\n\nSwimlaneFilterField.initClass();\n", "import StringHelper from '../../Core/helper/StringHelper.js';\nimport Button from '../../Core/widget/Button.js';\nimport '../../Core/widget/Menu.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n\n/**\n * @module TaskBoard/widget/SwimlanePickerButton\n */\n\n/**\n * A button with a menu allowing the user to toggle which swimlanes are shown on the {@link TaskBoard.view.TaskBoard}.\n *\n * {@inlineexample TaskBoard/widget/SwimlanePickerButton.js}\n *\n * Click to display a menu populated with the swimlanes held in {@link TaskBoard.view.TaskBoard#property-swimlanes}.\n *\n * When used within a TaskBoard, it connects to it automatically:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     tbar : [\n *         { type : 'swimlanepickerbutton' }\n *     ]\n * });\n * ```\n *\n * When used outside of a TaskBoard, it will query globally to find one but if there are multiple on page it might have\n * to be linked to one manually (see {@link TaskBoard/widget/mixin/TaskBoardLinked#config-taskBoard}:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({});\n *\n * const picker = new SwimlanePickerButton({\n *    taskBoard // Link it to the taskBoard instance created above\n * });\n * ```\n *\n * @classtype swimlanepickerbutton\n * @extends Core/widget/Button\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @widget\n */\nexport default class SwimlanePickerButton extends Button.mixin(TaskBoardLinked) {\n    static $name = 'SwimlanePickerButton';\n\n    static type = 'swimlanepickerbutton';\n\n    static configurable = {\n        text        : 'L{TaskBoard.Swimlanes}',\n        icon        : 'b-icon-picker',\n        pressedIcon : 'b-icon-picker-rotated',\n        iconAlign   : 'end',\n        menuIcon    : null,\n        // items null needed to not be considered an object holding menu items\n        menu        : { items : null }\n    };\n\n    onToggleSwimlane({ item }) {\n        item.swimlane.hidden = !item.checked;\n    }\n\n    // Populate menu before each show to make sure it is up to date\n    onMenuBeforeShow(info) {\n        super.onMenuBeforeShow(info);\n\n        info.source.items = this.taskBoard.swimlanes.map(swimlane => ({\n            ref     : swimlane.id,\n            text    : StringHelper.encodeHtml(swimlane.text),\n            checked : !swimlane.hidden,\n            swimlane,\n            onItem  : 'up.onToggleSwimlane'\n        }));\n    }\n}\n\nSwimlanePickerButton.initClass();\n", "import StringHelper from '../../Core/helper/StringHelper.js';\nimport Button from '../../Core/widget/Button.js';\nimport '../../Core/widget/Menu.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n\n/**\n * @module TaskBoard/widget/SwimlaneScrollButton\n */\n\n/**\n * A button with a menu allowing the user to pick a swimlane to scroll to.\n *\n * {@inlineexample TaskBoard/widget/SwimlaneScrollButton.js}\n *\n * When used within a TaskBoard, it connects to it automatically:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     tbar : [\n *         { type : 'swimlanescrollbutton' }\n *     ]\n * });\n * ```\n *\n * When used outside of a TaskBoard, it will query globally to find one but if there are multiple on page it might have\n * to be linked to one manually (see {@link TaskBoard/widget/mixin/TaskBoardLinked#config-taskBoard}:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({});\n *\n * const picker = new SwimlaneScrollButton({\n *    taskBoard // Link it to the taskBoard instance created above\n * });\n * ```\n *\n * @classtype swimlaneScrollButton\n * @extends Core/widget/Button\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @widget\n */\nexport default class SwimlaneScrollButton extends Button.mixin(TaskBoardLinked) {\n    static $name = 'SwimlaneScrollButton';\n\n    static type = 'swimlanescrollbutton';\n\n    static configurable = {\n        text        : 'L{TaskBoard.scrollToSwimlane}',\n        icon        : 'b-icon-picker',\n        pressedIcon : 'b-icon-picker-rotated',\n        iconAlign   : 'end',\n        menuIcon    : null,\n        menu        : []\n    };\n\n    onClickSwimlane({ item }) {\n        this.setTimeout(() => this.taskBoard?.scrollToSwimlane(item.swimlane), 100);\n    }\n\n    changeMenu(menu) {\n        // Nullified on destroy\n        if (menu) {\n            menu = this.taskBoard.swimlanes.map(swimlane => ({\n                ref    : swimlane.id,\n                text   : StringHelper.encodeHtml(swimlane.text),\n                swimlane,\n                onItem : 'up.onClickSwimlane'\n            }));\n        }\n\n        return super.changeMenu(menu);\n    }\n}\n\nSwimlaneScrollButton.initClass();\n", "import FilterField from '../../Core/widget/FilterField.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n\n/**\n * @module TaskBoard/widget/TaskFilterField\n */\n\n/**\n * A field that filters the tasks of a linked {@link TaskBoard.view.TaskBoard} when typing into it.\n *\n * {@inlineexample TaskBoard/widget/TaskFilterField.js}\n *\n * When used within a TaskBoard, it connects to it automatically:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     tbar : [\n *         { type : 'taskfilterfield' }\n *     ]\n * });\n * ```\n *\n * When used outside of a TaskBoard, it will query globally to find one but if there are multiple on page it might have\n * to be linked to one manually (see {@link TaskBoard/widget/mixin/TaskBoardLinked#config-taskBoard}:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({});\n *\n * const picker = new TaskFilterField({\n *    taskBoard // Link it to the taskBoard instance created above\n * });\n * ```\n *\n * @classtype taskfilterfield\n * @extends Core/widget/FilterField\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @widget\n */\nexport default class TaskFilterField extends FilterField.mixin(TaskBoardLinked) {\n    static $name = 'TaskFilterField';\n\n    static type = 'taskfilterfield';\n\n    static configurable = {\n        store : 'this.taskBoard.project.taskStore',\n\n        field : 'name',\n\n        label : 'L{TaskBoard.filterTasks}',\n\n        width : '20em',\n\n        triggers : {\n            filter : {\n                cls   : 'b-icon b-icon-filter',\n                align : 'start'\n            }\n        }\n    };\n}\n\nTaskFilterField.initClass();\n", "import ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport Editor from '../../Core/widget/Editor.js';\nimport Field from '../../Core/widget/Field.js';\nimport Widget from '../../Core/widget/Widget.js';\nimport '../../Core/widget/List.js';\nimport '../../Core/widget/Button.js';\n\n/**\n * @module TaskBoard/widget/TodoListField\n */\n\n/**\n * A field that displays, and also lets users edit, a list of todo items. Each item has a checkbox to mark if the item\n * is completed or not and a button to edit its text/remove it. Designed to be used in the task editor, to work in\n * tandem with the {@link TaskBoard.view.item.TodoListItem}.\n *\n * {@inlineexample TaskBoard/widget/TodoListField.js}\n *\n * To hook it up, add it to the task editors items and link it to a field on your task model declared with\n * `type : 'array'`. The fields data is expected to be an array of objects. Configure {@link #config-textField} and\n * {@link #config-checkedField} to match the names used by the objects in your array.\n *\n * This snippet illustrates basic usage:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *    features : {\n *        taskEdit : {\n *            items : {\n *                todo : {\n *                    type         : 'todolist',\n *                    label        : 'Todo',\n *                    field        : 'todo',\n *                    // \"title\" property will be used as the todo item text\n *                    textField    : 'title',\n *                    // \"done\" property will drive the checkbox\n *                    checkedField : 'done'\n *                }\n *            }\n *        }\n *    },\n *\n *    project : {\n *        taskStore : {\n *            fields : [ { name : 'todo', type : 'array' } ]\n *        }\n *\n *        tasksData : [\n *            {\n *                id   : 1,\n *                name : 'Important task',\n *                todo : [\n *                    { title : 'Fix this', done : true },\n *                    { title : 'Fix that', done : false }\n *                ]\n *            }\n *        ]\n *    }\n * });\n * ```\n *\n * @classtype todolistfield\n * @extends Core/widget/Field\n * @inputfield\n */\nexport default class TodoListField extends Field {\n    static $name = 'TodoListField';\n    static type = 'todolistfield';\n    static alias = 'todolist';\n\n    static configurable = {\n        /**\n         * Name of a property on a todo item to display as its text.\n         *\n         * @config {String}\n         * @category Common\n         * @default\n         */\n        textField : 'text',\n\n        /**\n         * Name of a property on a todo item to use for the checkbox. The property is expected to be a boolean.\n         *\n         * @config {String}\n         * @category Common\n         * @default\n         */\n        checkedField : 'checked',\n\n        /**\n         * Configure as `false` to hide the per item edit button and the add item button. Users can still check/uncheck\n         * items.\n         *\n         * @config {Boolean}\n         * @default\n         */\n        editableItems : true,\n\n        list : {\n            type : 'list',\n\n            multiSelect : true,\n\n            store : {\n                fields : []\n            },\n\n            itemIconTpl() {\n                return `<i class=\"b-todo-checkbox b-icon\"></i>`;\n            }\n        },\n\n        addButton : {\n            type : 'button',\n            cls  : 'b-todo-add',\n            icon : 'b-icon-add',\n            text : 'L{TodoListField.add}'\n        },\n\n        role : null\n    };\n\n    compose() {\n        const { editableItems } = this;\n\n        return {\n            class : {\n                'b-editable' : editableItems\n            }\n        };\n    }\n\n    changeList(list) {\n        return Widget.create(ObjectHelper.assign({\n            // List does not support remapping out of the box\n            itemTpl : record => StringHelper.xss`<div class=\"b-todo-text\">${record.getValue(this.textField)}</div><i class='b-todo-edit b-icon b-icon-edit' data-noselect></i>`\n        }, list));\n    }\n\n    updateList(list) {\n        // Detect click on edit icon\n        list.ion({\n            item    : 'onItemClick',\n            thisObj : this\n        });\n\n        // Detect check/uncheck\n        list.selected.ion({\n            change  : 'onSelectionChange',\n            thisObj : this\n        });\n    }\n\n    changeAddButton(button) {\n        const result = Widget.create(button);\n\n        this.ariaElement = result.element;\n\n        return result;\n    }\n\n    updateAddButton(button) {\n        button.ion({\n            click   : 'onAddClick',\n            thisObj : this\n        });\n    }\n\n    get childItems() {\n        return [this.list, this.addButton];\n    }\n\n    get inputElement() {\n        return this.list.element;\n    }\n\n    get innerElements() {\n        return super.innerElements.concat(this.addButton.element);\n    }\n\n    changeValue(value) {\n        value = value || [];\n\n        let autoUpdate = false;\n\n        // Auto update original array if we are used in an auto updating container\n        this.eachAncestor(a => {\n            if (a.autoUpdateRecord) {\n                autoUpdate = true;\n                return false;\n            }\n        });\n\n        // Original value (or a clone thereof if we are not live updating) is kept up to date on later modifications\n        this.originalValue = autoUpdate ? value : ObjectHelper.clone(value);\n\n        if (value) {\n            // Clone original value as our value, to not pollute the original value\n            value = ObjectHelper.clone(value);\n\n            value.forEach((v, i) => {\n                // id required by list\n                v.id = i + 1;\n                // map back to original value\n                v.originalIndex = i;\n            });\n        }\n\n        return value;\n    }\n\n    updateValue(value) {\n        if (value) {\n            const me = this;\n\n            // Populate the list with our value clone\n            me.list.items = value;\n\n            // Selection is used to check/uncheck items. Set flag to prevent updating original at this stage\n            me.isSettingValue = true;\n            me.list.selected.values = value.filter(v => v[me.checkedField]);\n            me.isSettingValue = false;\n        }\n    }\n\n    get value() {\n        // Always return a new array, required to flag array data field as modified / for UI to update\n        return this.originalValue.slice();\n    }\n\n    set value(value) {\n        super.value = value;\n    }\n\n    // Cant be invalid currently\n    get isValid() {\n        return true;\n    }\n\n    // Edit a todo item, using overlaid editor\n    editItem(record, element) {\n        const\n            me     = this,\n            // Always creating a new editor, destroyed when editing finishes\n            editor = new Editor({\n                appendTo   : me.element,\n                owner      : me,\n                cls        : 'b-todo-editor',\n                inputField : {\n                    type     : 'text',\n                    triggers : {\n                        remove : {\n                            cls : 'b-todo-remove b-icon-trash',\n                            handler() {\n                                me.removeItem(record);\n                                editor.cancelEdit();\n                            }\n                        }\n                    }\n                },\n                // Above modal\n                style             : 'z-index : 20000',\n                internalListeners : {\n                    complete({ value }) {\n                        me.originalValue[record.originalIndex][me.textField] = value;\n                        me.triggerFieldChange({ value : me.value, userAction : true });\n                    },\n                    finishEdit() {\n                        editor.destroy();\n                    },\n                    thisObj : me\n                }\n            });\n\n        // Start editing using configured field mapping\n        editor.startEdit({\n            target : element,\n            record,\n            field  : me.textField\n        });\n    }\n\n    // Remove a todo item, updating both the list and the original value\n    removeItem(record) {\n        const\n            me                = this,\n            { originalIndex } = record;\n\n        // Move following items up one notch to match position in originalValue after the splice below\n        me.list.store.forEach(r => {\n            if (r.parentIndex > record.parentIndex) {\n                r.originalIndex--;\n            }\n        });\n\n        me.list.store.remove(record);\n\n        me.originalValue.splice(originalIndex, 1);\n\n        me.triggerFieldChange({ value : me.value, userAction : true });\n    }\n\n    // Lists selection model is used to check/uncheck todo items. React on changes here\n    onSelectionChange() {\n        const\n            me       = this,\n            { list } = me;\n\n        if (!me.isSettingValue) {\n            me.originalValue.forEach((v, i) => {\n                const listRecord = list.store.getAt(i);\n                // Selection might change as a reaction to an item being removed = no listRecord\n                if (listRecord) {\n                    v[me.checkedField] = list.selected.includes(listRecord);\n                }\n            });\n\n            me.triggerFieldChange({ value : me.value, userAction : true });\n        }\n    }\n\n    // Clicked on a list item, react if it is on the edit icon\n    onItemClick({ record, event }) {\n        if (event.target.matches('.b-todo-edit')) {\n            this.editItem(record, event.target.closest('.b-list-item'));\n        }\n    }\n\n    // Clicked the add button, add to original value and then plug it back in to not have to care about syncing it with\n    // lists store\n    onAddClick() {\n        const me = this;\n\n        me.originalValue.push({\n            [me.textField]    : me.L('L{newTodo}'),\n            [me.checkedField] : false\n        });\n\n        me.value = me.originalValue;\n\n        me.triggerFieldChange({ value : me.value, userAction : true });\n    }\n}\n\nTodoListField.initClass();\n", "import UndoRedoBase from '../../Core/widget/base/UndoRedoBase.js';\nimport '../../Core/widget/Combo.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n\n/**\n * @module TaskBoard/widget/UndoRedo\n */\n\n/**\n * A widget encapsulating undo/redo functionality for the {@link TaskBoard.model.ProjectModel project} of a TaskBoard.\n *\n * To make use of this, the project must be configured with a\n * {@link Scheduler.model.mixin.ProjectModelMixin#config-stm State Tracking Manager}.\n *\n * If inserted into a TaskBoard (such as into a `tbar`, or `bbar`), the project of the that TaskBoard will be used.\n *\n * If this widget is to be used \"standalone\" (rendered into the DOM outside of a TaskBoard), this must be configured\n * with a reference the TaskBoard.\n *\n * There are three child widgets encapsulated which may be referenced through the {@link Core.widget.Container#property-widgetMap}:\n *\n * - `undoBtn` - The button which operates the undo operation\n * - `transactionsCombo` - A combobox into which is pushed the list of transactions,\n * - `redoBtn` - The button which operates the redo operation\n *\n * The transactionsCombo may be configured away if only the buttons are required:\n *\n * ```javascript\n * {\n *     type      : 'undoredo',\n *     items     : {\n *         transactionsCombo : null\n *     }\n * }\n * ```\n *\n * The example below illustrated how to embed an `undoredo` widget in the top toolbar of a TaskBoard:\n *\n * {@inlineexample TaskBoard/widget/UndoRedo.js}\n *\n * @extends Core/widget/base/UndoRedoBase\n * @classType taskboardundoredo\n * @demo TaskBoard/undo-redo\n * @widget\n */\nexport default class UndoRedo extends UndoRedoBase.mixin(TaskBoardLinked) {\n\n    static $name = 'UndoRedo';\n\n    static type = 'taskboardundoredo';\n\n    construct() {\n        super.construct(...arguments);\n\n        this.stm = this.taskBoard.project.stm;\n    }\n}\n\nUndoRedo.initClass();\n", "import Slider from '../../Core/widget/Slider.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n\n/**\n * @module TaskBoard/widget/ZoomSlider\n */\n\n/**\n * A slider that controls the {@link TaskBoard/view/TaskBoardBase#config-tasksPerRow} config of TaskBoard.\n *\n * {@inlineexample TaskBoard/widget/ZoomSlider.js}\n *\n * When used within a TaskBoard, it connects to it automatically:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     tbar : [\n *         { type : 'zoomslider' }\n *     ]\n * });\n * ```\n *\n * When used outside of a TaskBoard, it will query globally to find one but if there are multiple on page it might have\n * to be linked to one manually (see {@link TaskBoard/widget/mixin/TaskBoardLinked#config-taskBoard}:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({});\n *\n * const picker = new ZoomSlider({\n *    taskBoard // Link it to the taskBoard instance created above\n * });\n * ```\n *\n * @classtype zoomslider\n * @extends Core/widget/Slider\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @widget\n */\nexport default class ZoomSlider extends Slider.mixin(TaskBoardLinked) {\n    static $name = 'ZoomSlider';\n\n    static type = 'zoomslider';\n\n    static configurable = {\n        text : 'L{TaskBoard.zoom}',\n\n        max   : 10,\n        min   : 1,\n        // Override default to avoid hitting updater, value set in afterConstruct\n        value : null,\n\n        showValue : false\n    };\n\n    calculateValue(input) {\n        return this.max - input + 1;\n    }\n\n    afterConstruct() {\n        this.value = this.calculateValue(this.taskBoard.tasksPerRow);\n    }\n\n    onInput({ value }) {\n        this.taskBoard.tasksPerRow = this.calculateValue(value);\n    }\n\n    updateValue(value) {\n        super.updateValue(value);\n\n        this.onInput({ value });\n    }\n\n    getTooltipHtml(value) {\n        const tasksPerRow = this.calculateValue(value);\n\n        return `${tasksPerRow} card${tasksPerRow === 1 ? '' : 's'} per row`;\n    }\n}\n\nZoomSlider.initClass();\n", "// feature\nexport { default as ColumnDrag } from '../lib/TaskBoard/feature/ColumnDrag.js';\nexport { default as ColumnHeaderMenu } from '../lib/TaskBoard/feature/ColumnHeaderMenu.js';\nexport { default as ColumnToolbars } from '../lib/TaskBoard/feature/ColumnToolbars.js';\nexport { default as SimpleTaskEdit } from '../lib/TaskBoard/feature/SimpleTaskEdit.js';\nexport { default as SwimlaneDrag } from '../lib/TaskBoard/feature/SwimlaneDrag.js';\nexport { default as TaskBoardFeature } from '../lib/TaskBoard/feature/TaskBoardFeature.js';\nexport { default as TaskDrag } from '../lib/TaskBoard/feature/TaskDrag.js';\nexport { default as TaskDragSelect } from '../lib/TaskBoard/feature/TaskDragSelect.js';\nexport { default as TaskEdit } from '../lib/TaskBoard/feature/TaskEdit.js';\nexport { default as TaskMenu } from '../lib/TaskBoard/feature/TaskMenu.js';\nexport { default as TaskTooltip } from '../lib/TaskBoard/feature/TaskTooltip.js';\n\n// model\nexport { default as ColumnModel } from '../lib/TaskBoard/model/ColumnModel.js';\nexport { default as ProjectModel } from '../lib/TaskBoard/model/ProjectModel.js';\nexport { default as SwimlaneModel } from '../lib/TaskBoard/model/SwimlaneModel.js';\nexport { default as TaskModel } from '../lib/TaskBoard/model/TaskModel.js';\n\n// store\nexport { default as TaskStore } from '../lib/TaskBoard/store/TaskStore.js';\n\n// view/mixins\nexport { default as ExpandCollapse } from '../lib/TaskBoard/view/mixin/ExpandCollapse.js';\nexport { default as ResponsiveCards } from '../lib/TaskBoard/view/mixin/ResponsiveCards.js';\nexport { default as TaskBoardColumns } from '../lib/TaskBoard/view/mixin/TaskBoardColumns.js';\nexport { default as TaskBoardDom } from '../lib/TaskBoard/view/mixin/TaskBoardDom.js';\nexport { default as TaskBoardDomEvents } from '../lib/TaskBoard/view/mixin/TaskBoardDomEvents.js';\nexport { default as TaskBoardScroll } from '../lib/TaskBoard/view/mixin/TaskBoardScroll.js';\nexport { default as TaskBoardStores } from '../lib/TaskBoard/view/mixin/TaskBoardStores.js';\nexport { default as TaskBoardSwimlanes } from '../lib/TaskBoard/view/mixin/TaskBoardSwimlanes.js';\nexport { default as TaskBoardVirtualization } from '../lib/TaskBoard/view/mixin/TaskBoardVirtualization.js';\nexport { default as TaskItems } from '../lib/TaskBoard/view/mixin/TaskItems.js';\nexport { default as TaskNavigation } from '../lib/TaskBoard/view/mixin/TaskNavigation.js';\nexport { default as TaskSelection } from '../lib/TaskBoard/view/mixin/TaskSelection.js';\n\n// view/items\nexport { default as ImageItem } from '../lib/TaskBoard/view/item/ImageItem.js';\nexport { default as ProgressItem } from '../lib/TaskBoard/view/item/ProgressItem.js';\nexport { default as RatingItem } from '../lib/TaskBoard/view/item/RatingItem.js';\nexport { default as ResourceAvatarsItem } from '../lib/TaskBoard/view/item/ResourceAvatarsItem.js';\nexport { default as SeparatorItem } from '../lib/TaskBoard/view/item/SeparatorItem.js';\nexport { default as TagsItem } from '../lib/TaskBoard/view/item/TagsItem.js';\nexport { default as TaskItem } from '../lib/TaskBoard/view/item/TaskItem.js';\nexport { default as TemplateItem } from '../lib/TaskBoard/view/item/TemplateItem.js';\nexport { default as TextItem } from '../lib/TaskBoard/view/item/TextItem.js';\nexport { default as TodoListItem } from '../lib/TaskBoard/view/item/TodoListItem.js';\n\n// view\nexport { default as TaskBoard } from '../lib/TaskBoard/view/TaskBoard.js';\nexport { default as TaskBoardBase } from '../lib/TaskBoard/view/TaskBoardBase.js';\n\n// widget base\nexport { default as ColorBoxCombo } from '../lib/TaskBoard/widget/base/ColorBoxCombo.js';\n\n// widget mixin\nexport { default as TaskBoardLinked } from '../lib/TaskBoard/widget/mixin/TaskBoardLinked.js';\n\nexport { default as ColumnCombo } from '../lib/TaskBoard/widget/ColumnCombo.js';\nexport { default as ColumnFilterField } from '../lib/TaskBoard/widget/ColumnFilterField.js';\nexport { default as ColumnPickerButton } from '../lib/TaskBoard/widget/ColumnPickerButton.js';\nexport { default as ColumnScrollButton } from '../lib/TaskBoard/widget/ColumnScrollButton.js';\nexport { default as ProjectCombo } from '../lib/TaskBoard/widget/ProjectCombo.js';\nexport { default as ResourcesCombo } from '../lib/TaskBoard/widget/ResourcesCombo.js';\nexport { default as SwimlaneCombo } from '../lib/TaskBoard/widget/SwimlaneCombo.js';\nexport { default as SwimlaneFilterField } from '../lib/TaskBoard/widget/SwimlaneFilterField.js';\nexport { default as SwimlanePickerButton } from '../lib/TaskBoard/widget/SwimlanePickerButton.js';\nexport { default as SwimlaneScrollButton } from '../lib/TaskBoard/widget/SwimlaneScrollButton.js';\nexport { default as TagCombo } from '../lib/TaskBoard/widget/TagCombo.js';\nexport { default as TaskColorPicker } from '../lib/TaskBoard/widget/TaskColorPicker.js';\nexport { default as TaskColorCombo } from '../lib/TaskBoard/widget/TaskColorCombo.js';\nexport { default as TaskEditor } from '../lib/TaskBoard/widget/TaskEditor.js';\nexport { default as TaskFilterField } from '../lib/TaskBoard/widget/TaskFilterField.js';\nexport { default as TodoListField } from '../lib/TaskBoard/widget/TodoListField.js';\nexport { default as UndoRedo } from '../lib/TaskBoard/widget/UndoRedo.js';\nexport { default as ZoomSlider } from '../lib/TaskBoard/widget/ZoomSlider.js';\n"],
  "mappings": "2rDAWe,MAAMA,UAAyBC,GAAeC,MAAMC,EAAW,CAAE,CAI5EC,eAAeC,EAAM,CACb,CAAC,KAAKC,eAAiB,CAAC,KAAKC,cAC7B,KAAKC,OAAOC,UAAS,EAEzB,MAAML,eAAeC,CAAI,CAC7B,CACJ,CATIK,EADiBV,EACVW,cAAc,CAAA,GACrBD,EAFiBV,EAEVY,eAAe,CAAA,GAS1BZ,EAAiBa,OAAS,mBCuBX,MAAMC,WAAmBd,CAAiB,CAMrDe,gBAAiB,CACb,MAAMC,EAAK,KAEXA,EAAGC,UAAYC,GAAWC,IAAI,CAC1BC,gBAAkBJ,EAAGK,SAAW,KAAOL,EAAGR,OAAOc,gBACjDC,gBAAkBP,EAAGR,OAAOc,gBAC5BE,MAAkBR,EAClBS,kBAAoB,CAChBC,gBAAkB,oBAClBC,UAAkB,cAClBC,QAAkBZ,CACtB,CACJ,EAAGA,EAAGC,SAAS,CACnB,CACAY,WAAY,CAAA,IAAAC,GACRA,EAAI,KAACb,aAAS,MAAAa,IAAA,QAAdA,EAAgBC,QAAO,EACvB,MAAMF,UAAS,CACnB,CACAG,UAAUC,EAAS,CACf,MAAMD,UAAUC,CAAO,EACnB,KAAKhB,YACL,KAAKA,UAAUG,gBAAkBa,EAAU,KAAO,KAAKzB,OAAOc,gBAEtE,CACAY,SAASC,EAAc,CACnB,KAAM,CAAEC,QAAAA,GAAY,KAAK5B,OACzB4B,EAAQC,KAAKF,EAAcC,EAAQE,QAAQH,CAAY,CAAC,CAC5D,CACAI,SAASJ,EAAc,CACnB,KACI,CAAEC,QAAAA,GAAY,KAAK5B,OACnBgC,EAAcC,KAAKC,IAAIN,EAAQO,QAAQR,CAAY,EAAI,EAAGC,EAAQQ,KAAK,EAC3ER,EAAQC,KAAKF,EAAcC,EAAQS,MAAML,CAAW,CAAC,CACzD,CACAM,yBAAyB,CAAEC,MAAAA,EAAOZ,aAAAA,CAAa,EAAG,CAC9C,KACI,CAAE3B,OAAAA,CAAO,EAAU,KACnB,CAAE4B,QAAAA,EAASY,IAAAA,CAAI,EAAIxC,EACnB,CAACA,EAAOyC,UAAY,CAAC,KAAK5B,WAC1B0B,EAAMG,eAAiB,CACnBC,KAAW,8BACXC,KAAW,wBACX/B,SAAWc,IAAiBC,EAAQY,EAAM,OAAS,OAAO,EAC1DK,OAAW,IACXC,OAAWA,IAAM,KAAK,QAAUN,EAAM,OAAS,OAAO,EAAEb,CAAY,GAExEY,EAAMQ,gBAAkB,CACpBJ,KAAW,+BACXC,KAAW,yBACX/B,SAAWc,IAAiBC,EAAQY,EAAM,QAAU,MAAM,EAC1DK,OAAW,IACXC,OAAWA,IAAM,KAAK,QAAUN,EAAM,OAAS,OAAO,EAAEb,CAAY,GAGhF,CACAqB,kBAAkB,CAAEC,KAAAA,EAAMC,MAAAA,CAAM,EAAG,CAS/B,OAAO,KAAKlD,OAAOmD,QAAQ,mBAAoB,CAAEF,KAAAA,EAAMC,MAAAA,EAAOvB,aAAesB,EAAKtB,YAAa,CAAC,CACpG,CACAyB,YAAY,CAAEH,KAAAA,EAAMC,MAAAA,CAAM,EAAG,CAQzB,OAAO,KAAKlD,OAAOmD,QAAQ,kBAAmB,CAAEF,KAAAA,EAAMC,MAAAA,EAAOvB,aAAesB,EAAKtB,YAAa,CAAC,CACnG,CACJ,CAjFIzB,EADiBI,GACV+C,QAAQ,cACfnD,EAFiBI,GAEVgD,OAAO,cACdpD,EAHiBI,GAGViD,eAAe,CAClBC,MAAQ,CAAC,iBAAkB,0BAA0B,IA+E7DlD,GAAWmD,UAAS,EACpB,MAAM/C,WAAmBgD,EAAKhE,MAAMiE,GAAWC,GAAWC,EAAM,CAAE,CAC9D,WAAWzD,cAAe,CACtB,MAAO,CACH0D,aAAmB,2DACnBC,iBAAmB,6BAEnBC,gBAAkB,KAClBC,UAAY,CACRX,KAAO,UACP,MAAMY,KAAKjB,EAAM,CACb,KACI,CAAEjC,MAAAA,CAAM,EAAO,KACf,CACImD,YAAAA,EACAC,WAAAA,EACAzC,aAAAA,CACJ,EAAesB,EACfoB,EAAerD,EAAMA,MAAMhB,OAC3BsE,EAAeC,EAAUC,KAAKL,EAAanD,EAAMJ,eAAe,EAEhE6D,EAAeC,EAAYC,eAAeP,CAAU,EAAEQ,SAASN,CAAY,EAE3EO,EAAeC,EAAUC,cAAc,CACnCC,UAAY,gCACZC,OAAYjE,EAAMJ,gBAClBsE,MAAY,CAERC,IAAQb,EAAac,EAErBC,KAAQX,EAAYC,eAAeP,CAAU,EAAEkB,UAAUb,EAAY,CAAC,EAAG,CAAC,EAAEc,EAE5EC,MAAQrB,EAAYsB,sBAAqB,EAAGD,OAGhDE,cAAgB,EACpB,CAAC,EAEDC,EAAe,CAACxB,EAAa,GAAGE,EAAUuB,kBAAkBjE,CAAY,CAAC,EAE7EkE,OAAOC,OAAO7C,EAAM,CAChB4B,MAAAA,EACAc,SAAAA,EACAlB,YAAAA,CACJ,CAAC,EAEDkB,EAASI,QAAQ,CAACC,EAASC,IAAM,CAC7B,MACIC,EAAcF,EAAQG,UAAU,EAAI,EACpCC,EAAcJ,EAAQP,sBAAqB,EAK/C,GAHAO,EAAQK,cAAgBD,EAAOZ,MAC/BQ,EAAQM,eAAiBF,EAAOG,OAE5BP,EAAQQ,QAAQ,qBAAqB,EAAG,CACxC,MACIC,EAAgBT,EAAQU,QAAQ,uBAAuB,EACvDC,EAAgBC,EAAQC,SAASJ,EAAU,QAAQ,EACnDK,EAAgBF,EAAQC,SAASJ,EAAU,MAAM,EACjDM,EAAgBN,EAASN,UAAS,EAClCa,EAAgBL,GAAM,KAAA,OAANA,EAAQR,UAAU,EAAI,EACtCc,EAAgBH,EAAKX,UAAS,EAClC,IAAII,EAASE,EAAShB,sBAAqB,EAAGc,OAE9C,GAAIN,IAAMN,EAASuB,OAAS,EAAG,CAC3B,MAAMC,EAAgBrC,EAAUsC,cAAcpB,EAAQqB,cAAe,gBAAgB,EACrFd,GAAUe,WAAWH,CAAa,EAItCJ,EAAc7B,MAAMqC,KAAQ,OAAMhB,MAClCS,GAAeD,EAAcS,YAAYR,CAAW,EACpDC,EAAUO,YAAYtB,CAAW,EACjCa,EAAcS,YAAYP,CAAS,EACnCpC,EAAM2C,YAAYT,CAAa,OAI/BlC,EAAM2C,YAAYtB,CAAW,EAGjCF,EAAQyB,UAAUC,IAAI,iBAAiB,CAC3C,CAAC,GAELC,SAAS,CAAE9C,MAAAA,EAAO3B,MAAAA,EAAOuB,YAAAA,CAAY,EAAG,CAEpC,MAAMmD,EAAWlD,EAAYC,eAAezB,CAAK,EAAEoC,UAAUb,EAAY,CAAC,EAAG,CAAC,EAC9EI,EAAMK,MAAMG,KAAQ,GAAEuC,EAASrC,KACnC,CACJ,EAER,CACAsC,iBAAiB3E,EAAO,CACpB,MACI4E,EAAS,MAAMD,iBAAiB3E,CAAK,EACrC,CAAElD,OAAAA,GAAW,KAAKgB,MACtB8G,OAAAA,EAAOC,cAAgB/H,EAAO+H,cAC9BD,EAAOE,iBAAmB,CACtBC,YAAc,CAAC,CACXjC,QAAYhG,EAAOkI,YACnBC,UAAY,aACf,GAEEL,CACX,CAEAM,UAAUnF,EAAM,CACZA,OAAAA,EAAKtB,aAAe,KAAKX,MAAMhB,OAAOqI,oBAAoBpF,EAAKkB,WAAW,EACnE,MAAMiE,UAAUnF,CAAI,CAC/B,CACA9B,UAAU8B,EAAM,CAGZ,KAAKjC,MAAMhB,OAAOsI,sBAAqB,EACvCrF,EAAKsF,WAAa,EACtB,CACAC,UAAUvF,EAAM,CAEZ,GAAI,CAACA,EAAKkB,YAAYqC,QAAQ,KAAKzC,gBAAgB,EAC/C,MAAO,GAGNd,EAAKwF,iBAENxF,EAAKwF,eAAiBxF,EAAK0C,SAAS+C,IAAI,CAAC1C,EAASC,IAAMnB,EAAUC,cAAc,CAC5EC,UAAc,oCACd2D,YAAc,CACVC,cAAgB,GAGhB5C,QAAAA,GAGJd,MAAQ,CACJM,MAASQ,EAAQK,cACjBE,OAASP,EAAQM,cACrB,CACJ,CAAC,CAAC,EACF,KAAKuC,qBAAqB5F,EAAMA,EAAKtB,YAAY,EAEzD,CACAkH,qBAAqB5F,EAAM6F,EAAoB,CAE3C,KACI,CAAE9I,OAAAA,GAAW,KAAKgB,MAClB+H,EAAa/I,EAAO4B,QAAQO,QAAQ2G,CAAkB,EAE1D7F,EAAKwF,eAAe1C,QAAQ,CAAC6C,EAAe3C,IAAM,OAE9C,GAAIA,IAAM,EAAG,CAET,MACI+C,EAAkBpC,EAAQC,SAAS7G,EAAOkI,YAAa,QAAQ,EAC/De,EAAkB,CAAC,GAAGD,EAAgBE,QAAQ,EAClDC,GAAYC,OAAOH,EAAeL,CAAa,EAC/CI,EAAgBK,aAAaT,EAAeK,EAAcF,CAAQ,CAAC,MAGlE,CAAA,IAAAO,EAED,MAEIC,GAAiBD,GAAAA,EAAAtJ,EAAOwJ,aAASF,MAAAA,IAAhBA,OAAAA,OAAAA,EAAkBjH,MAAM4D,EAAI,CAAC,IAA7BqD,KAAAA,EAAkC,CAAEG,MAAQ,WAC7DC,EAAiB9C,EAAQC,SAAS7G,EAAO2J,mBAAmBJ,CAAc,EAAG,MAAM,EACnFK,EAAiB,CAAC,GAAGF,EAAaR,QAAQ,EAC9CC,GAAYC,OAAOQ,EAAehB,CAAa,EAC/Cc,EAAaL,aAAaT,EAAegB,EAAcb,CAAQ,CAAC,EAExE,CAAC,CACL,CACAc,eAAe5G,EAAM6G,EAAO,CACxB7G,EAAK4B,MAAM4C,UAAUsC,OAAO,YAAa,CAACD,CAAK,EAC/C7G,EAAKwF,eAAe1C,QAAQ6C,GAAiBA,EAAcnB,UAAUsC,OAAO,YAAa,CAACD,CAAK,CAAC,EAChG7G,EAAK+G,QAAU,CAACF,CACpB,CACAnC,SAAS1E,EAAM,CAAA,IAAAgH,EACX,KACI,CAAEjK,OAAAA,GAAoB,KAAKgB,MAC3BkJ,EAAsBlK,EAAOkK,aAC7BC,EAAsB5F,EAAUC,KAAKvB,EAAK4B,MAAOuF,OAAW,EAAI,EAEhEC,EAAsBH,EAAaI,iBAAiBH,EAAYI,OAAOhF,EAAG4E,EAAY/E,CAAC,EACvFoF,EAAsBH,GAAW,KAAA,OAAXA,EAAa3D,QAAQ,4BAA4B,EAK3E,GAJIzD,EAAK+G,UACL/G,EAAK6G,MAAQ,IAGb,EAACO,GAAW,OAAAJ,EAAXI,EAAa1B,eAAW,MAAAsB,IAAxBA,QAAAA,EAA0BrB,gBAAiB4B,EAAqB,CACjE,MAAMC,EAAelG,EAAUC,KAAKgG,CAAmB,EAEvD,IAAIE,EAAe1K,EAAOqI,oBAAoBmC,CAAmB,EAE7DL,EAAYI,OAAOhF,EAAIkF,EAAaF,OAAOhF,IAC3CmF,EAAe1K,EAAO4B,QAAQ+I,QAAQD,CAAY,GAEtD,KAAK7B,qBAAqB5F,EAAMyH,CAAY,EAE5C,MAAME,EAAgB3H,EAAKyH,eAAiBA,EAE5C,GADAzH,EAAKyH,aAAeA,EAChBE,EAAe,CAyBf,MAAM9C,EAAS9H,EAAOmD,QAAQ,aAAc,CAAEF,KAAAA,EAAMtB,aAAesB,EAAKtB,aAAc+I,aAAAA,CAAa,CAAC,EACpG,KAAKb,eAAe5G,EAAM6E,IAAW,EAAK,GAGtD,CACA,MAAM+C,SAAS5H,EAAM,CAEjB,KACI,CAAEjD,OAAAA,GAAY,KAAKgB,MACnB,CAAEY,QAAAA,CAAQ,EAAI5B,EACd,CACI2B,aAAAA,EACA+I,aAAAA,EACA/E,SAAAA,EACA8C,eAAAA,EACA5D,MAAAA,CACJ,EAAc5B,EA8BdA,EAAK+G,SAAW,MAAMhK,EAAOmD,QAAQ,mBAAoB,CAAEF,KAAAA,EAAMtB,aAAAA,EAAc+I,aAAAA,EAAc,IAAM,GACnGzH,EAAK6G,MAAQ,GAGb7G,EAAK6H,UAAY,IAAIC,QAAQC,GAAW,CACpC,SAASC,GAAS,CAEdpG,EAAMuE,OAAM,EACZX,EAAe1C,QAAQ6C,GAAiBA,EAAcQ,OAAM,CAAE,EAE9DzD,EAASI,QAAQC,GAAWA,EAAQyB,UAAU2B,OAAO,iBAAiB,CAAC,EAEvEpJ,EAAOkL,qBAAoB,EAC3BR,IAAiBN,QAAaxI,EAAQC,KAAKF,EAAc+I,CAAY,EACrE1K,EAAOmL,oBAAmB,EAW1BnL,EAAOmD,QAAQ,aAAc,CAAEF,KAAAA,EAAMtB,aAAAA,EAAc+I,aAAAA,CAAa,CAAC,EAUjE1K,EAAOmD,QAAQ,gBAAiB,CAAEF,KAAAA,EAAMtB,aAAAA,EAAc+I,aAAAA,CAAa,CAAC,EACpE1K,EAAOoL,qBAAoB,EAC3BJ,EAAO,CACX,CAGAnG,EAAM4C,UAAUC,IAAI,YAAY,EAEhC5C,EAAUuG,QACNxG,EACAN,EAAUC,KAAKiE,EAAe,CAAC,EAAG2B,OAAW,EAAI,CACrD,EAEItF,EAAUwG,8BAA8BzG,EAAO,WAAW,EAC1DH,EAAY6G,gBAAgB,CACxBvF,QAAWnB,EACX2G,SAAW,YACXC,QAAWR,EACX7J,QAAWpB,CACf,CAAC,EAIDiL,EAAM,CAEd,CAAC,CAET,CACAS,UAAUzI,EAAM,CACZ,CAEJ0I,QAAQ1I,EAAM,CACV,KACI,CAAEjD,OAAAA,GAAkD,KAAKgB,MACzD,CAAEyH,eAAAA,EAAgB5D,MAAAA,EAAOlD,aAAAA,EAAcgE,SAAAA,CAAS,EAAI1C,EACxD,GAAI4B,EAAO,CACP,IAAS+G,EAAT,UAAyB,CAErB/G,EAAMuE,OAAM,EACZX,EAAe1C,QAAQ6C,GAAiBA,EAAcQ,OAAM,CAAE,EAE9DzD,EAASI,QAAQC,GAAWA,EAAQyB,UAAU2B,OAAO,iBAAiB,CAAC,EACvEpJ,EAAOmD,QAAQ,0BAA0B,CAC7C,EAEA0B,EAAM4C,UAAUC,IAAI,YAAY,EAEhCe,EAAe1C,QAAQ,CAAC6C,EAAe3C,IAAM,CACzC,MAAM4F,EAAW5I,EAAK0C,SAASM,CAAC,EAChC2C,EAAcnB,UAAU2B,OAAO,WAAW,EAC1CyC,EAASxE,cAAcgC,aAAaT,EAAeiD,CAAQ,CAC/D,CAAC,EAED/G,EAAUuG,QACNxG,EACAN,EAAUC,KAAKiE,EAAe,CAAC,EAAG2B,OAAW,EAAI,CACrD,EAEItF,EAAUwG,8BAA8BzG,EAAO,WAAW,EAC1DH,EAAY6G,gBAAgB,CACxBvF,QAAWnB,EACX2G,SAAW,YACXC,QAAWG,EACXxK,QAAWpB,CACf,CAAC,EAID4L,EAAa,EAWrB5L,EAAOmD,QAAQ,kBAAmB,CAAEF,KAAAA,EAAMtB,aAAAA,CAAa,CAAC,EACpDsB,EAAKsF,YAELvI,EAAOmD,QAAQ,gBAAiB,CAAEF,KAAAA,EAAMtB,aAAAA,CAAa,CAAC,CAE9D,CACAmK,QAAQ7I,EAAM,EAEN,CAACA,EAAK6G,OAAS7G,EAAK8I,UACpB,KAAKJ,QAAQ1I,CAAI,CAEzB,CACJ,CACA3C,GAAWD,OAAS,aC3XL,MAAM2L,UAAyBC,EAAgB,CA4E1D,WAAW1I,cAAe,CACtB,MAAM2I,EAAS,MAAM3I,aACrB2I,OAAAA,EAAOC,MAAMC,KAAS,2BAA4B,uBAAwB,qBAAsB,EACzFF,CACX,CAkDAG,YAAY9J,EAAO,CACf+J,OAAAA,EAAaC,aAAahK,EAAO,iCAAiC,EAC3DA,CACX,CACAiK,mBAAmBC,EAAI,CACnBH,OAAAA,EAAaI,eAAeD,EAAI,wCAAwC,EACjEA,CACX,CAGAE,qBAAqB,CAAEC,mBAAAA,CAAmB,EAAG,CACpC,KAAK/L,WACN+L,EAAmB1D,SAAS2D,OAAO3D,SAAS4D,KAAO,CAC/CC,IAAQ,SACRC,MAAQ,CACJ,yBAA0C,EAC1C,wCAA0C,EAC1C,YAA0C,EAC1C,yBAA0C,CAC9C,GAGZ,CAEAC,iBAAiB/J,EAAO,CACpB,OAAOoJ,EAAaxG,OAAO,MAAMmH,iBAAiB/J,CAAK,EAAGA,EAAMgK,aAAa,CACjF,CAEA5K,yBAAyB,CAAEC,MAAAA,EAAOZ,aAAAA,CAAa,EAAG,CAC9C,KAAM,CAAE3B,OAAAA,CAAO,EAAI,KACdA,EAAOyC,WACRF,EAAM4K,QAAU,CACZxK,KAAS,uBACTC,KAAS,uBACTC,OAAS,IACTC,QAAS,CACL9C,EAAOmN,QAAQxL,CAAY,CAC/B,GAGZ,CAEAyL,oBAAoBvN,EAAM,CACtB,KAAM,CAAEqD,MAAAA,CAAM,EAAIrD,EACdqD,EAAMmK,OAAO7G,QAAQ,yBAAyB,GAC9C,KAAK8G,gBAAgBpK,EAAO,CAAEmK,OAASnK,EAAMmK,OAAQE,MAAQ,SAAU,CAAC,CAEhF,CACA/L,UAAUC,EAAS,CACf,MAAMD,UAAUC,CAAO,EACvB,CAAC,KAAK3B,eAAiB,KAAKE,OAAOC,UAAS,CAChD,CACA,IAAIuN,UAAW,CACX,MAAO,EACX,CACJ,CAxLItN,EADiB8L,EACV3I,QAAQ,oBACfnD,EAFiB8L,EAEV1I,OAAO,oBACdpD,EAHiB8L,EAGV5L,eAAe,CAkClBqN,aAAe,KAyBflL,MAAQ,KACRuK,KAAO,CACHY,OAAS,IAEbpK,KAAO,eACPqK,aAAe,KAwHvBnO,EAAiBoO,SAAS5B,EAAiB1I,KAAM0I,CAAgB,EACjEA,EAAiB3L,OAAS,mBC1RX,MAAMwN,UAAuBrO,CAAiB,CAA9C,kCAkGXsO,EAAAA,iBAAY,IAAIC,KAIhB1M,WAAY,CACR,SAAW,CAAA,CAAG2M,CAAO,IAAK,KAAKF,UAC3BE,EAAQzM,QAAO,EAEnB,MAAMF,UAAS,CACnB,CAEA4M,eAAe1L,EAAO,CAClB+J,OAAAA,EAAaC,aAAahK,EAAO,kCAAkC,EAC5DA,CACX,CACA2L,kBAAkB3L,EAAO,CACrB+J,OAAAA,EAAaC,aAAahK,EAAO,qCAAqC,EAC/DA,CACX,CACAiK,mBAAmBC,EAAI,CACnBH,OAAAA,EAAaI,eAAeD,EAAI,sCAAsC,EAC/DA,CACX,CA8BA0B,WAAWC,EAAUzM,EAAc4H,EAAgB,OAC/C,MACI/I,EAAoC,KACpC,CAAEsN,UAAAA,EAAW9N,OAAAA,EAAQqO,WAAAA,CAAW,EAAI7N,EACpC+B,EAAoC/B,EAAI,GAAE4N,QAAe,EACzDE,EAAqC,GAAEF,OAAczM,EAAa8H,YAAWF,EAAAA,GAAc,KAAdA,OAAAA,EAAgBE,QAAhBF,KAAAA,EAAyB,YAC1G,IAAIyE,EAAUF,EAAUS,IAAID,CAAG,EAC/B,GAAI,CAACN,EAAS,CAAA,IAAAQ,EACV,MAAMC,EAAc,CAAA,EA0BpB,GAxBAnC,EAAaoC,cAAcnM,CAAK,EAAEmG,IAAIiG,GAAO,CACzC,MAEIC,EAAYP,EAAWM,CAAG,EAE1BE,EAAYtM,EAAMoM,CAAG,EACzBF,EAAYE,CAAG,EAAIrC,EAAawC,MAE5B,CACI7N,kBAAoB,CAChB8N,MAAU,UACVC,OAAU,WACV5N,QAAUZ,GAEdmB,aAAAA,EACA4H,eAAAA,GAGJqF,EAEAC,CACJ,CACJ,CAAC,IAEGL,EAAAhO,EAAGiN,gBAAY,MAAAe,IAAA,OAAA,OAAfA,EAAAS,KAAAzO,EAAkB,CAAE+B,MAAQkM,EAAaL,SAAAA,EAAUzM,aAAAA,EAAc4H,eAAAA,EAAgB,KAAM,GACvF,OAAO,KAGXyE,EAAUhO,EAAO0H,IAAI,CACjBpE,KAA4B,UAC5B4L,IAA6B,sBAAqBd,EAAS,CAAC,OAC5De,SAA4B,KAC5BC,cAA4B,GAC5BC,0BAA4B,GAC5B9M,MAA4BkM,EAC5Ba,QAA4B,CACxBC,KAAiB,GAAEnB,YACnBoB,cAAgB,EACpB,CACJ,CAAC,EACD1B,EAAU2B,IAAInB,EAAKN,CAAO,EAE9B,OAAOA,EAAQhI,OACnB,CACA0J,eAAe,CAAEC,aAAAA,EAAchO,aAAAA,EAAc4H,eAAAA,CAAe,EAAG,CAC3D,MAAM/I,EAAK,KACNA,EAAGK,WAEAyL,EAAaoC,cAAclO,EAAGoP,QAAQ,EAAE1I,QACxCpC,EAAUgK,MAAMa,EAAc,CAC1BzG,SAAW,CACP,cAAgB1I,EAAG2N,WAAW,MAAOxM,EAAc4H,CAAc,CACrE,CACJ,CAAC,EAGD+C,EAAaoC,cAAclO,EAAGqP,WAAW,EAAE3I,SAC3CyI,EAAazG,SAAS4G,KAAOtP,EAAG2N,WAAW,SAAUxM,EAAc4H,CAAc,GAG7F,CACAwG,oBAAoB3B,EAAU4B,EAAUC,EAAY,CAChD,KACI,CAAEnC,UAAAA,EAAW9N,OAAAA,CAAO,EAAI,KACxBsO,EAAyB,GAAEF,OAAc4B,OAAcC,IACvDjC,EAAwBF,EAAUS,IAAID,CAAG,EACzCN,IACAhO,EAAOoJ,OAAO4E,CAAO,EAGrBhO,EAAOkQ,WAAW,IAAMlC,EAAQzM,QAAO,EAAI,CAAC,EAC5CuM,EAAUqC,OAAO7B,CAAG,EAE5B,CACA8B,qBAAqBJ,EAAUC,EAAY,CACvC,KAAKF,oBAAoB,MAAOC,EAAUC,CAAU,EACpD,KAAKF,oBAAoB,SAAUC,EAAUC,CAAU,CAC3D,CACAI,sBAAsB,CAAEL,SAAAA,EAAUzG,eAAAA,CAAe,EAAG,OAChD,KAAK6G,qBAAqBJ,GAAUzG,EAAAA,EAAe+G,KAAf/G,KAAAA,EAAqB,SAAS,CACtE,CACAgH,wBAAwB,CAAEN,WAAAA,CAAW,EAAG,CACpC,UAAWO,KAAU,KAAKxQ,OAAO4B,QAC7B,KAAKwO,qBAAqBI,EAAOF,GAAIL,CAAU,CAEvD,CAGAQ,WAAW,CAAEC,OAAAA,CAAO,EAAG,CACnB,KAAK1Q,OAAOmN,QAAQuD,EAAO/O,aAAc+O,EAAOnH,cAAc,CAClE,CAGAoH,SAAS,CAAED,OAAAA,CAAO,EAAG,CACjB,KAAKvN,QAAQ,aAAc,CACvB0L,KAAiB6B,EACjB/O,aAAiB+O,EAAO/O,aACxB4H,eAAiBmH,EAAOnH,cAC5B,CAAC,CACL,CACAqH,QAAQ,CAAEF,OAAAA,CAAO,EAAG,CAChB,KAAKvN,QAAQ,YAAa,CACtB0L,KAAiB6B,EACjB/O,aAAiB+O,EAAO/O,aACxB4H,eAAiBmH,EAAOnH,cAC5B,CAAC,CACL,CAEJ,CA3QIrJ,EADiB2N,EACVxK,QAAQ,kBACfnD,EAFiB2N,EAEVvK,OAAO,kBACdpD,EAHiB2N,EAGVzN,eAAe,CAsBlBwP,SAAW,KAuBXC,YAAc,CACV1C,QAAU,IAGdkB,WAAa,CACTlB,QAAU,CACN7J,KAAoB,SACpBV,KAAoB,aACpBiO,QAAoB,uBACpBC,UAAoB,uBACpB7P,kBAAoB,CAChB8N,MAAQ,YACZ,CACJ,GAkCJtB,aAAe,OAInBvN,EAnGiB2N,EAmGVtK,eAAe,CAClB4I,MAAQ,CAAC,iBAAkB,wBAAyB,yBAAyB,IAyKrF0B,EAAepK,UAAS,EACxBoK,EAAexN,OAAS,iBC9RT,MAAM0Q,UAAiBrN,EAAKhE,MAAMC,EAAW,CAAE,CAuE1D,OAAOqR,gBAAgB,CAAE9E,OAAAA,EAAQ2C,KAAAA,CAAK,EAAG,CACrC,MAAMoC,EAAS/E,EAAO+E,SAAW,OAAS/E,EAAO+E,QAAUpC,EAAKqC,eAChE,OAAI,OAAOD,GAAW,SACX,CACH3N,KAAO2N,GAGRA,CACX,CACJ,CA/EI/Q,EADiB6Q,EACV5Q,cAAc,CAAA,GACrBD,EAFiB6Q,EAEV3Q,eAAe,IAoEtBF,EAtEiB6Q,EAsEVG,gBAAgB,CAAE5N,KAAO,SAWpCyN,EAAS1Q,OAAS,WCzEH,MAAM8Q,UAAuB3R,CAAiB,CAiCzD4R,kBAAkBC,EAAa,CAC3B/E,OAAAA,EAAagF,cAAcD,EAAa,qCAAqC,EACtEA,CACX,CAUAE,SAASC,EAAYxL,EAAS,CAC1B,MACIxF,EAAY,KACZ6D,EAAY7D,EAAGR,OAEdgG,IACDA,EAAU3B,EAAUoN,eAAeD,CAAU,GAEjD,MAEIE,EAAmBrN,EAAUsN,gBAAgB3L,CAAO,EACpD7B,EAAmBuN,EAAS1L,QAC5B4L,EAAmBb,EAASC,gBAAgBU,CAAQ,EAExD,GAAI,CAACE,EACD,MAAO,GA4BX,GACIpR,EAAGK,UAAY2Q,EAAW/O,UAC1B4B,EAAUlB,QAAQ,uBAAwB,CAAE0O,eAAiBrR,EAAIgR,WAAAA,EAAYM,MAAQJ,EAASxF,OAAO4F,MAAO,IAAM,GAElH,MAAO,GAGX9L,EAAQ+L,MAAK,EACb,MAAMd,EAASzQ,EAAGyQ,OAASe,GAAOrR,IAAI,CAClCK,MAAeqD,EACf4N,SAAe9N,EAAY+N,WAC3BC,aAAe,UACfjD,IAAe,uBACfkD,YAAe,KACfC,UAAe,KACfC,WAAe,CACXC,WAAa,GACbC,KAAad,EAASxF,OAAO4F,MAC7B,GAAGF,GAEPrE,MAAQ,CACJA,MAAiB,MACjBkF,eAAiB,IAErBxR,kBAAoB,CAChByR,SAAa,mBACbC,OAAa,iBACbC,WAAa,qBACbxR,QAAaZ,CACjB,CACJ,EAAGA,EAAGqS,YAAY,EAElBrS,EAAGsS,eAAiB3O,EAEpBA,EAAYsD,UAAUC,IAAI,WAAW,EAErC,MAAMqL,EAAQjO,EAAUsC,cAAcjD,EAAa,OAAO,EAC1D8M,OAAAA,EAAOjL,QAAQd,MAAM6N,MAAQA,EAC7B9B,EAAOqB,WAAWtM,QAAQd,MAAM6N,MAAQA,EAExC9B,EAAOjL,QAAQN,cAAgB,GAE/BrB,EAAUoN,eAAeD,CAAU,EAAEwB,eAAe,CAChDC,MAAQ,SACZ,CAAC,EAGD9O,EAAY6O,eAAe,CACvBC,MAAQ,SACZ,CAAC,EACDhC,EAAOiC,UAAU,CACb7F,OAASqE,EAAS1L,QAClBmN,OAAS3B,EACTM,MAASJ,EAASxF,OAAO4F,KAC7B,CAAC,EACM,EACX,CAEA,MAAMsB,aAAalQ,EAAO,CACtB,MACI1C,EAAqB,KACrB,CAAER,OAAAA,EAAQiR,OAAAA,CAAO,EAAIzQ,EACrBgR,EAAqBP,EAAOkC,OAC5BE,EAAqBrT,EAAOyR,eAAeD,CAAU,EACrD8B,EAAqBC,MAAM/O,KAAK6O,EAAYG,iBAAiB,kCAAkC,CAAC,EAChGC,EAAqBH,EAAanR,QAAQ3B,EAAGsS,cAAc,EAAI,EACnE,GAAI,MAAMtS,EAAGkS,SAASxP,CAAK,EAEvB,GAAIuQ,GAAS,EACTjT,EAAG+Q,SAASC,EAAY8B,EAAaG,CAAK,CAAC,MAG1C,CACD,MAAMC,EAAiB1T,EAAO2T,gBAAgBnC,EAAY,EAAK,EAE/D,GAAIkC,EAAgB,CAChB,MACIE,EAAmB5T,EAAOyR,eAAeiC,CAAc,EACvDG,EAAmBN,MAAM/O,KAAKoP,EAAgBJ,iBAAiB,kCAAkC,CAAC,EACtGhT,EAAG+Q,SAASmC,EAAgBG,EAAiBA,EAAiB3M,OAAS,CAAC,CAAC,GAIzF,CAEA,MAAM4M,SAAS5Q,EAAO,CAClB,MACI1C,EAAqB,KACrB,CAAER,OAAAA,EAAQiR,OAAAA,CAAO,EAAIzQ,EACrBgR,EAAqBP,EAAOkC,OAC5BE,EAAqBrT,EAAOyR,eAAeD,CAAU,EACrD8B,EAAqBC,MAAM/O,KAAK6O,EAAYG,iBAAiB,kCAAkC,CAAC,EAChGC,EAAqBH,EAAanR,QAAQ3B,EAAGsS,cAAc,EAAI,EACnE,GAAI,MAAMtS,EAAGkS,SAASxP,CAAK,EAEvB,GAAIuQ,EAAQH,EAAapM,OACrB1G,EAAG+Q,SAASC,EAAY8B,EAAaG,CAAK,CAAC,MAG1C,CACD,MAAMM,EAAiB/T,EAAOgU,YAAYxC,EAAY,EAAK,EAEvDuC,EACAvT,EAAG+Q,SAASwC,CAAc,EAGrBvT,EAAG6Q,aACRrR,EAAOmN,QAAQnN,EAAOiU,UAAUzC,CAAU,EAAGxR,EAAOkU,YAAY1C,CAAU,CAAC,EAI3F,CACAkB,SAASxP,EAAO,CACZ,OAAO,KAAK+N,OAAOkD,aAAa,KAAMjR,CAAK,CAC/C,CACAyP,OAAOzP,EAAO,CACV,KAAK+N,OAAOmD,WAAWlR,CAAK,CAChC,CAEAmR,eAAe,CAAE7C,WAAAA,EAAYtO,MAAAA,CAAM,EAAG,CAC9B,KAAKqO,SAASC,EAAYtO,EAAMmK,MAAM,GAEtCnK,EAAMoR,eAAc,CAE5B,CACAC,iBAAiB,CAAE7D,OAAAA,CAAO,EAAG,CAsBzB,KAAK1Q,OAAOmD,QAAQ,yBAA0B,CAAE0O,eAAiB,KAAML,WAAad,EAAOyC,OAAQrB,MAAQpB,EAAO8D,SAAW,CAAC,CAClI,CACAC,eAAe,CAAE/D,OAAAA,CAAO,EAAG,CAsBvB,KAAK1Q,OAAOmD,QAAQ,uBAAwB,CAAE0O,eAAiB,KAAML,WAAad,EAAOyC,OAAQrB,MAAQpB,EAAO8D,SAAW,CAAC,CAChI,CACAE,oBAAqB,CAEjB,MACIlU,EAAK,KACL,CAAEyQ,OAAAA,CAAO,EAAIzQ,EACjByQ,GAAM,MAANA,EAAQf,WAAW,IAAM,CAEjB1P,EAAGyQ,SAAWA,IACdzQ,EAAGsS,eAAiB,KACpBtS,EAAGyQ,OAAS,MAEhBA,EAAO1P,QAAO,GACf,CAAC,CACR,CAEAoT,mBAAoB,CAChB,MAAOC,EAAQ,KAAK3D,MACxB,CACJ,CAvRI/Q,EADiBiR,EACV9N,QAAQ,kBACfnD,EAFiBiR,EAEV7N,OAAO,kBACdpD,EAHiBiR,EAGV/Q,eAAe,CAMlBiR,YAAc,GAOdwB,aAAe,CAAA,EAKfgC,OAAS,CACLC,MAAgB,WAChBC,OAAgB,SAChB,aAAgB,WAChB,cAAgB,cACpB,IAEJ7U,EA5BiBiR,EA4BV5N,eAAe,CAClBuC,OAAS,CAAC,UAAU,EACpBkP,OAAS,CAAC,gBAAgB,IA2PlC7D,EAAe1N,UAAS,EACxB0N,EAAe9Q,OAAS,iBC/ST,MAAM4U,WAAqBzV,CAAiB,CAMvDe,gBAAiB,CACb,MAAMC,EAAS,KAEfA,EAAGC,UAAYyU,GAAavU,IAAI,CAC5BC,gBAAkBJ,EAAGK,SAAW,KAAOL,EAAGR,OAAOc,gBACjDC,gBAAkBP,EAAGR,OAAOc,gBAC5BE,MAAkBR,CACtB,EAAGA,EAAGC,SAAS,CACnB,CACAe,UAAUC,EAAS,CACf,MAAMD,UAAUC,CAAO,EACnB,KAAKhB,YACL,KAAKA,UAAUG,gBAAkBa,EAAU,KAAO,KAAKzB,OAAOc,gBAEtE,CACJ,CApBIZ,EADiB+U,GACV5R,QAAQ,gBACfnD,EAFiB+U,GAEV3R,OAAO,gBACdpD,EAHiB+U,GAGV1R,eAAe,CAClBC,MAAQ,CAAC,gBAAgB,IAkBjCyR,GAAaxR,UAAS,EACtB,MAAMyR,WAAqBxR,EAAKhE,MAAMiE,GAAWC,EAAS,CAAE,CACxD,WAAWxD,cAAe,CACtB,MAAO,CACH0D,aAAmB,+DACnBC,iBAAmB,+BACnBC,gBAAkB,KAClBC,UAAY,CACRX,KAAO,UACP,MAAMY,KAAKjB,EAAM,CACb,KACI,CAAEjC,MAAAA,CAAM,EAAU,KAClB,CACImD,YAAAA,EACAC,WAAAA,CACJ,EAAkBnB,EAClBoB,EAAkBrD,EAAMA,MAAMhB,OAC9BuJ,EAAkBlF,EAAU8Q,sBAAsBhR,CAAW,EAC7DiR,EAAkB/Q,EAAUsF,mBAAmBJ,CAAc,EAC7D8L,EAAkBvQ,EAAUsC,cACxBgO,EAAgBE,UAAUxO,KAC1B,CAAC,eAAgB,eAAe,CACpC,EACAV,EAAkB7B,EAAUC,KAAK4Q,EAAiBpU,EAAMJ,eAAe,EAAE2U,QACrE,EACAjO,WAAW+N,EAAQ,eAAe,CAAC,EACnC,EACA/N,WAAW+N,EAAQ,cAAc,CAAC,CACtC,EAEA5Q,EAAkBC,EAAYC,eAAeP,CAAU,EAAEQ,SAASwB,CAAM,EAExEvB,EAAkBC,EAAUC,cAAc,CACtCC,UAAY,kCACZC,OAAYjE,EAAMJ,gBAClBsE,MAAY,CAERC,IAAQT,EAAYC,eAAeP,CAAU,EAAEkB,UAAU,EAAGb,EAAY,CAAC,CAAC,EAAEW,EAE5EC,KAAQe,EAAOb,EAEfC,MAAQY,EAAOZ,OAGnBE,cAAgB,EACpB,CAAC,EAELG,OAAOC,OAAO7C,EAAM,CAChB4B,MAAAA,EACA0E,eAAAA,EACA6L,gBAAAA,EACA3Q,YAAAA,EAEA2B,OAAAA,CACJ,CAAC,EAED,MAAMW,EAAgBqO,EAAgBjP,UAAU,EAAI,EACpDtB,EAAM2C,YAAYT,CAAa,GAEnCY,SAAS,CAAE9C,MAAAA,EAAO3B,MAAAA,EAAOuB,YAAAA,CAAY,EAAG,CAEpC,MAAMmD,EAAWlD,EAAYC,eAAezB,CAAK,EAAEoC,UAAU,EAAGb,EAAY,CAAC,CAAC,EAC9EI,EAAMK,MAAMC,IAAO,GAAEyC,EAASxC,KAClC,CACJ,EAER,CACAyC,iBAAiB3E,EAAO,CACpB,MACI4E,EAAS,MAAMD,iBAAiB3E,CAAK,EACrC,CAAElD,OAAAA,GAAW,KAAKgB,MACtB8G,OAAAA,EAAOC,cAAgB/H,EAAO+H,cAC9BD,EAAOE,iBAAmB,CACtBC,YAAc,CAAC,CACXjC,QAAYhG,EAAOkI,YACnBC,UAAY,WACf,GAEEL,CACX,CACA3G,UAAU8B,EAAM,CACZ,CAEJuF,UAAUvF,EAAM,CAEZ,GAAI,CAACA,EAAKkB,YAAYqC,QAAQ,KAAKzC,gBAAgB,EAC/C,MAAO,GAGX,GAAI,CAACd,EAAK2F,cAAe,CACrB,KAAM,CAAExC,OAAAA,CAAO,EAAInD,EAEnBA,EAAK2F,cAAgB9D,EAAUC,cAAc,CACzCC,UAAc,sCACd2D,YAAc,CACVC,cAAgB,IAGpB1D,MAAQ,CACJM,MAASY,EAAOZ,MAChBe,OAASH,EAAOG,MACpB,CACJ,CAAC,EACD,KAAKiP,oBAAoBvS,EAAK2F,cAAe3F,EAAKsG,cAAc,EAChEtG,EAAKmS,gBAAgB3N,UAAUC,IAAI,iBAAiB,EAE5D,CACA8N,oBAAoB5M,EAAe6M,EAAsB,CACrD,KAAM,CAAEzV,OAAAA,GAAW,KAAKgB,MACxBhB,EAAOkI,YAAYmB,aACfT,EACA6M,GAAwBzV,EAAO2J,mBAAmB8L,CAAoB,CAC1E,CACJ,CACA,MAAM9N,SAAS1E,EAAM,CAAA,IAAAgH,EACjB,KACI,CAAEjK,OAAAA,GAAiB,KAAKgB,MACxB,CAAEkJ,aAAAA,CAAa,EAAIlK,EACnB0V,EAAmBnR,EAAUC,KAAKxE,EAAOgG,QAASoE,OAAW,EAAI,EACjED,EAAmB5F,EAAUC,KAAKvB,EAAK4B,MAAOuF,OAAW,EAAI,EAE7DC,EAAmBF,EAAYI,OAAOnF,EAAIsQ,EAAgBC,OACpDzL,EAAaI,iBAAiBH,EAAY5E,EAAG4E,EAAY/E,CAAC,EAC1D8E,EAAaI,iBAAiBH,EAAY5E,EAAG4E,EAAYI,OAAOnF,CAAC,EACvEgQ,EAAmB/K,GAAW,KAAA,OAAXA,EAAa3D,QAAQ,uBAAuB,EAEnE,GAAI,EAAC2D,GAAW,OAAAJ,EAAXI,EAAa1B,eAAW,MAAAsB,IAAxBA,QAAAA,EAA0BrB,gBAAiBwM,EAAiB,CAC7D,MAAM3K,EAAelG,EAAUC,KAAK4Q,EAAiBhL,OAAW,EAAI,EAEpE,IAAIwL,EAAiB5V,EAAOmV,sBAAsBC,CAAe,EAE7DjL,EAAYI,OAAOnF,EAAIqF,EAAaF,OAAOnF,IAC3CwQ,EAAiB5V,EAAOwJ,UAAUmB,QAAQiL,CAAc,GAE5D,KAAKJ,oBAAoBvS,EAAK2F,cAAegN,CAAc,EAC3D3S,EAAK2S,eAAiBA,EAE9B,CACA,MAAM/K,SAAS5H,EAAM,CAEjB,KACI,CAAEjD,OAAAA,GAAc,KAAKgB,MACrB,CAAEwI,UAAAA,CAAU,EAAIxJ,EAChB,CACIuJ,eAAAA,EACAqM,eAAAA,EACAR,gBAAAA,EACAxM,cAAAA,EACA/D,MAAAA,CACJ,EAAgB5B,EACpB,SAASgI,GAAS,CAEdpG,EAAMuE,OAAM,EACZR,EAAcQ,OAAM,EAEpBgM,EAAgB3N,UAAU2B,OAAO,iBAAiB,EAElDwM,IAAmBxL,QAAaZ,EAAU3H,KAAK0H,EAAgBqM,CAAc,EAC7E5V,EAAOmD,QAAQ,eAAgB,CAAEyS,eAAAA,EAAgB3S,KAAAA,CAAK,CAAC,CAC3D,CAGA4B,EAAM4C,UAAUC,IAAI,YAAY,EAEhC5C,EAAUuG,QACNxG,EACAN,EAAUC,KAAKoE,EAAewB,OAAW,EAAI,CACjD,EAEItF,EAAUwG,8BAA8BzG,EAAO,WAAW,EAC1DH,EAAY6G,gBAAgB,CACxBvF,QAAWnB,EACX2G,SAAW,YACXC,QAAWR,EACX7J,QAAWpB,CACf,CAAC,EAIDiL,EAAM,CAEd,CACAS,UAAUzI,EAAM,CACZ,CAER,CACAgS,GAAa5U,OAAS,eC1NtB,MACIwV,GAAe,sDAEf1T,GAAeA,CAAC6D,EAAS8P,EAAiB,KAAUhR,EAC/CoE,SAASlD,EAAQqB,cAAgB,oBAAmByO,EAAiB,yBAA2B,6BAA6B,EAC7H3T,QAAQ6D,CAAO,EAEpB+P,GAAetN,GAAkBA,EAAeuN,KAAK,CAACpN,EAAe3C,IAG7D2C,EAAcvB,gBAAkBuB,EAAcD,YAAYsN,eAEzDhQ,IAAM,GAAK9D,GAAQyG,EAAe,EAAI,IAAMA,EAAcD,YAAYuN,YAE9E,EAqCU,MAAMC,UAAiB3W,CAAiB,CAsBnDe,gBAAiB,CACb,MAAMC,EAAK,KAEXA,EAAGC,UAAY2V,GAASzV,IAAI,CACxBC,gBAAkBJ,EAAGK,SAAW,KAAOL,EAAGR,OAAOc,gBACjDC,gBAAkBP,EAAGR,OAAOc,gBAC5BE,MAAkBR,EAClBS,kBAAoB,CAChBC,gBAAkB,oBAClBC,UAAkB,cAClBC,QAAkBZ,CACtB,CACJ,EAAGA,EAAGC,SAAS,CACnB,CACAY,WAAY,CAAA,IAAAC,EACR,MAAMD,UAAS,GACfC,EAAI,KAACb,aAAS,MAAAa,IAAA,QAAdA,EAAgBC,QAAO,CAC3B,CACAC,UAAUC,EAAS,CACf,MAAMD,UAAUC,CAAO,EACnB,KAAKhB,YACL,KAAKA,UAAUG,gBAAkBa,EAAU,KAAO,KAAKzB,OAAOc,gBAEtE,CACAkC,kBAAkB,CAAEC,KAAAA,EAAMC,MAAAA,CAAM,EAAG,CAU/B,OAAO,KAAKlD,OAAOmD,QAAQ,iBAAkB,CAAEF,KAAAA,EAAMC,MAAAA,EAAOmT,SAAWnT,EAAOoT,YAAcrT,EAAKqT,WAAY,CAAC,CAClH,CACAlT,YAAY,CAAEH,KAAAA,EAAMC,MAAAA,CAAM,EAAG,CASzB,OAAO,KAAKlD,OAAOmD,QAAQ,gBAAiB,CAAEF,KAAAA,EAAMC,MAAAA,EAAOmT,SAAWnT,EAAOoT,YAAcrT,EAAKqT,WAAY,CAAC,CACjH,CACJ,CApEIpW,EADiBiW,EACV9S,QAAQ,YACfnD,EAFiBiW,EAEV7S,OAAO,YACdpD,EAHiBiW,EAGV5S,eAAe,CAClBC,MAAQ,CAAC,gBAAgB,IAE7BtD,EANiBiW,EAMV/V,eAAe,CAclBmW,mBAAqB,KAkD7BJ,EAAS1S,UAAS,EAClB,MAAM2S,WAAiB1S,EAAKhE,MAAMiE,GAAWC,GAAWC,EAAM,CAAE,CAC5D,WAAWzD,cAAe,CACtB,MAAO,CACH0D,aAAqB,qCACrBC,iBAAqB,qCAErByS,mBAAqB,mBAErBxS,gBAAkB,KAClBC,UAAY,CACRX,KAAO,UACP,MAAMY,KAAKjB,EAAM,CACb,KACI,CACIkB,YAAAA,EACAC,WAAAA,CACJ,EAAanB,EACboB,EAAa,KAAKrD,MAAMA,MAAMhB,OAC9ByW,EAAatS,EAAYuC,QAAQ,qBAAqB,EACtD8K,EAAanN,EAAUqS,kBAAkBvS,CAAW,EACpDU,EAAa5B,EAAK4B,MAAQC,EAAUC,cAAc,CAE9CC,UAAgB,0BAA4ByR,EAASzR,UACrDuK,KAAgB,eAEhB7J,cAAgB,EACpB,CAAC,EACDiR,EAAa,CAAA,EACjB,IAAIL,EAEAjS,EAAUuS,cAAcC,SAASrF,CAAU,EAC3C8E,EAAcjS,EAAUuS,cAAcE,OAAOC,GAAK,CAACA,EAAEtU,QAAQ,EAAEuU,KAAK,CAACC,EAAGC,IAAMD,EAAEE,YAAcD,EAAEC,WAAW,EAI3Gb,EAAc,CAAC9E,CAAU,EAE7B,MAAM4F,EAAed,EAAY5N,IAAI2O,GAAKhT,EAAUoN,eAAe4F,CAAC,CAAC,EACrExR,OAAOC,OAAO7C,EAAM,CAChBmU,aAAAA,EAEAE,YAAc,IAAIvJ,IAElBtJ,YAAcC,EACTC,eAAeP,CAAU,EACzBQ,SAASL,EAAUC,KAAKL,EAAa,KAAM,EAAI,CAAC,CACzD,CAAC,EAEDiT,EAAarR,QAAQwR,GAAe,CAAA,IAAAC,EAChC,KACI,CAAE7O,YAAAA,CAAY,EAAI4O,EAClBE,EAAkBF,EAAYpR,UAAU,EAAI,EAC5CC,EAAkB7B,EAAUC,KAAK+S,EAAapT,CAAW,EAE7DsT,EAAUvS,MAAMM,MAAQY,EAAOZ,MAAQ,KACvCiS,EAAUvS,MAAMqB,OAASH,EAAOG,OAAS,KACzCtD,EAAKqU,YAAY7H,IAAI8H,EAAanR,EAAOG,MAAM,EAE/CkR,EAAUvS,MAAMG,KAAOe,EAAOb,EAAI,KAClCkS,EAAUvS,MAAMC,IAAMiB,EAAOhB,EAAI,KACjCqS,EAAUF,YAAcA,EACxBE,EAAUjG,WAAa7I,EAAY6I,WACnCiG,EAAUC,gBAAgBF,EAAA7O,EAAYY,kBAAc,MAAAiO,IAA1BA,OAAAA,OAAAA,EAA4BzE,QAASpK,EAAYhH,aAAaoR,MACxFlO,EAAM2C,YAAYiQ,CAAS,EAC3Bd,EAAWvK,KAAKqL,CAAS,CAC7B,CAAC,EAGDL,EAAarR,QAAQwR,GAAeA,EAAY9P,UAAUC,IAAI,iBAAiB,CAAC,EAChF,MAAMiQ,GAAYC,eAAc,EAEhCjB,EAAW5Q,QAAQ,CAAC0R,EAAWxR,IAAM,CAC7BA,EAAI,GACJwR,EAAUvS,MAAMC,IAAO,GAAKc,EAAI,GAAM,KACtCwR,EAAUvS,MAAMG,KAAQ,GAAKY,EAAI,EAAK,OAGtCwR,EAAUvS,MAAMC,IAAM,EACtBsS,EAAUvS,MAAMG,KAAO,EAE/B,CAAC,GAELsC,SAAS,CAAE9C,MAAAA,EAAO3B,MAAAA,EAAOuB,YAAAA,CAAY,EAAG,CACpC,KACI,CAAE7D,gBAAAA,GAAoB,KAAKI,MAE3B6W,EAAsBjX,EAAgB6E,sBAAqB,EAE3DmC,EAAsBlD,EAAYC,eAAezB,CAAK,EAAEoC,UACpDb,EAAY,CAAC,EAAIoT,EAAaxS,KAAOzE,EAAgBkX,WACrDrT,EAAY,CAAC,EAAIoT,EAAa1S,IAAMvE,EAAgBmX,SACxD,EACJlT,EAAMK,MAAMC,IAAMyC,EAASxC,EAAI,KAC/BP,EAAMK,MAAMG,KAAOuC,EAASrC,EAAI,IAYpC,CACJ,EAER,CACAyS,mBAAmB/U,EAAM,CACrB,MAAMgV,EAAY,MAAMD,mBAAmB/U,CAAI,EAE/CgV,OAAAA,EAAUjS,QAAU,KAAKhF,MAAMhB,OAAOkY,YAC/BD,CACX,CACApQ,iBAAiB3E,EAAO,CACpB,MACI4E,EAAa,MAAMD,iBAAiB3E,CAAK,EACzC,CAAElD,OAAAA,GAAW,KAAKgB,MACtB8G,OAAAA,EAAOC,cAAgB/H,EAAO+H,cAC9BD,EAAOE,iBAAmB,CACtBC,YAAc,CACV,CACIjC,QAAY,2BACZmC,UAAY,UAChB,EACA,CACInC,QAAYhG,EAAOkI,YACnBC,UAAY,OACf,GAGFL,CACX,CAEAM,UAAUnF,EAAM,CACZ,KACI,CAAEkB,YAAAA,CAAY,EAAIlB,EAClBoB,EAAkB,KAAKrD,MAAMhB,OAC7BwR,EAAkBnN,EAAUqS,kBAAkBvS,CAAW,EAE7D,OAAIE,EAAU8T,WAAW3G,CAAU,EAC/BvO,EAAKqT,YAAcjS,EAAUuS,cAAcwB,MAAK,EAAGpB,KAAK,CAACC,EAAGC,IAAMD,EAAEE,YAAcD,EAAEC,WAAW,EAI/FlU,EAAKqT,YAAc,CAAC9E,CAAU,EAElCvO,EAAKoV,cAAgB7G,EACd,MAAMpJ,UAAUnF,CAAI,CAC/B,CACA9B,UAAU8B,EAAM,CACZ,KACI,CAAEjD,OAAAA,GAAY,KAAKgB,MAEnBsX,EAAcrV,EAAKkB,YAEvBlB,EAAKsF,WAAa,GAElBtF,EAAK2E,SAAW,QAChB3E,EAAKsV,iBAAmBtV,EAAKoV,cAC7B,UAAW7G,KAAcvO,EAAKqT,YAC1B9E,EAAWgH,aAAaxY,CAAM,EAAEyY,SAAW,GAG/CzY,EAAOc,gBAAgB0G,YAAYvE,EAAK4B,KAAK,EAE7C5B,EAAKwF,eAAiBxF,EAAKmU,aAAa1O,IAAI,CAAC6O,EAAatR,IAC/CnB,EAAUC,cAAc,CAC3BC,UAAY,CACR,kCAAoC,EACpC,yBAAoCiB,IAAM,GAE9Cf,MAAQ,CACJqB,OAAStD,EAAKqU,YAAY/I,IAAIgJ,CAAW,GAE7C5O,YAAc,CACVC,cAAgB,GAEhBqN,cAAgBsB,EAAYlQ,cAC5B6O,aAAgB/T,GAAQoV,CAAW,EAGnCA,YAAAA,GAEJ7R,cAAgB,GAChB4S,YAAAA,CACJ,CAAC,CACJ,EACDtY,EAAOgG,QAAQyB,UAAUC,IAAI,iBAAiB,CAClD,CACAc,UAAUvF,EAAM,CAEZ,GAAI,CAACA,EAAKkB,YAAYqC,QAAQ,KAAKzC,gBAAgB,EAC/C,MAAO,EAEf,CAEA2U,qBAAqBrR,EAAe,CAChC,UAAWrB,KAAWqB,EAAc6B,SAChC,GAAIlD,EAAQ2S,aACR,OAAO3S,CAGnB,CAEA4S,UAAUrT,EAAGH,EAAG,CACZ,OAAO,KAAKpE,MAAMhB,OAAO4Y,UAAUrT,EAAGH,EAAGyQ,EAAY,CACzD,CACAhM,eAAe5G,EAAM6G,EAAO,CACxB7G,EAAK4B,MAAM4C,UAAUsC,OAAO,YAAa,CAACD,CAAK,EAC/C7G,EAAKwF,eAAe1C,QAAQ6C,GAAiBA,EAAcnB,UAAUsC,OAAO,YAAa,CAACD,CAAK,CAAC,EAChG7G,EAAK+G,QAAU,CAACF,CACpB,CACAnC,SAAS1E,EAAM,OACX,MACIzC,EAAuC,KACvC,CAAER,OAAAA,GAAqCQ,EAAGQ,MAC1C,CAAEkC,MAAQmT,EAAU5N,eAAAA,CAAe,EAAIxF,EACvC,CAAE4V,QAAAA,EAASC,QAAAA,CAAQ,EAAoBzC,EACvChM,EAAuCrK,EAAOkK,aAAaI,iBAAiBuO,EAASC,CAAO,EAC5FC,EAAuCnS,EAAQC,SAASwD,GAAAA,KAAAA,OAAAA,EAAa3D,QAAQ,qBAAqB,EAAG,YAAY,EAIrH,GAHIzD,EAAK+G,UACL/G,EAAK6G,MAAQ,IAEb,EAACO,GAID0O,EAAe,CAAA,IAAAC,EACf,MACIC,EAAiBjZ,EAAOmV,sBAAsB9K,CAAW,EACzD6O,EAAiBlZ,EAAOqI,oBAAoBgC,CAAW,EACvD8O,EAAiBD,EAAaC,cAAeF,GAAc,KAAA,OAAdA,EAAgBE,cAAenZ,EAAOmZ,YACvF,IACI9F,EAAgBhJ,EAAY3D,QAAQmP,EAAY,EAEhDjL,EAAgBqO,IAAmBhW,EAAKgW,gBAAkBC,IAAiBjW,EAAKiW,aAKpF,GAHAjW,EAAKgW,eAAiBA,EACtBhW,EAAKiW,aAAeA,EAEhB,CAAC7F,EAAa,CACd,KACI,CAAE+F,QAAAA,CAAQ,EAAIpZ,EACdqZ,EAAc9U,EAAUC,KAAKuU,CAAa,EAC1CO,EAAc9Y,EAAGkY,qBAAqBK,CAAa,EACnD5T,GAAcmU,EAAAA,GAAO,KAAPA,OAAAA,EAAS7T,sBAAqB,EAAGN,MAAjCmU,KAAAA,EAAwC,KAC1D,GAAIH,IAAgB,EAEhB,GAAIhU,IAAQ,MAAQ2T,EAAU3T,EAC1BkO,EAAciG,MAEb,CACD,MACIC,EAAYF,EAAW9O,OAAOhF,EAE9BiU,EAAYhZ,EAAGoY,UAAUW,EAAST,EAAUM,CAAO,EAEnDK,EAAYjZ,EAAGoY,UAAUW,EAAST,EAAUM,CAAO,EAEvD/F,EAAcmG,GAAaC,MAG9B,CAED,MACIC,EAAqB1Z,EAAO2Z,eAAe1W,EAAKiW,YAAY,EAE5DU,GAAsBP,EAAW7T,MAAQkU,GAAsB,EAG/DG,EAAqBH,EAAqBP,EAE1C1F,EAAqBxR,KAAK6X,OAAOjB,EAAUQ,EAAWhU,MAAQwU,CAAgB,EAE9EN,GAAqBF,EAAWhU,KAAOuU,EAAgBC,GAAoBpG,EAAQ,IAEvF,GAAItO,IAAQ,MAAQ2T,EAAU3T,EAC1BkO,EAAc7S,EAAGoY,UAAUW,GAASpU,CAAG,MAEtC,CACD,MACIoU,GAAaF,EAAW9O,OAAOhF,EAE/BwU,GAAavZ,EAAGoY,UAAUW,GAAUH,EAASN,CAAO,EAEpDkB,GAAaxZ,EAAGoY,UAAUW,GAAUH,EAASN,CAAO,EAExDzF,EAAc0G,IAAcC,KAKxC,GAAI,GAAAhB,EAAC3F,KAAW2F,MAAAA,IAAXA,QAAAA,EAAarQ,YAAYC,eAAe,CAAA,IAAAqR,EAAAC,EACzC,IAAI7Q,EAAe,GAEnB,GAAIgK,EAAa,CACb,MACI8G,EAAmB5V,EAAUC,KAAK6O,CAAW,EAC7CkF,EAAmBvY,EAAO0W,kBAAkBrD,CAAW,EAItD8F,IAAgB,GAAKL,EAAUqB,EAAS5P,OAAOnF,GAE/C+T,EAAc,GAAKN,EAAUsB,EAAS5P,OAAOhF,GAE1CtC,EAAK2E,WAAa,WAClBgD,EAAgB,IAEpBvB,EAAegK,EACfpQ,EAAK2E,SAAW,WAIZ3E,EAAK2E,WAAa,UAClBgD,EAAgB,IAEpBvB,EAAegK,EAAY+G,mBAC3BnX,EAAK2E,SAAW,SAEhB2Q,IAAqBtV,EAAKsV,mBAC1B3N,EAAgB,IAEpB3H,EAAKsV,iBAAmBA,OAIpBtV,EAAK2E,WAAa,SAClBgD,EAAgB,IAEpB3H,EAAK2E,SAAW,OAChB3E,EAAKsV,iBAAmB,MAExB0B,EAAC5Q,KAAY4Q,MAAAA,IAAA,SAAAC,EAAZD,EAActR,eAAWuR,MAAAA,IAAA,QAAzBA,EAA2BtR,gBACxBS,IAAiB,GACjBZ,EAAe1C,QAAQ6C,GAAiB,CACpCmQ,GAAa,MAAbA,EAAevR,YAAYoB,CAAa,CAC5C,CAAC,EAGDH,EAAe1C,QAAQ6C,GAAiB,CAAA,IAAAyR,KACnCA,EAAAhR,KAAYgR,MAAAA,IAAA,OAAA,OAAZA,EAAchT,gBAAiB0R,GAAe1P,aAAaT,EAAeS,CAAY,CAC3F,CAAC,EAELpG,EAAKqX,gBAAkBjH,GAI/B,UAAWkH,KAAQtX,EAAK4B,MAAMqE,SAAU,CACpC,GAAI,CAACqR,EAAK/I,WAAWgJ,WAAY,CAAA,IAAAC,EAC7B,MAAM1H,IAAQ0H,EAAAxX,EAAKgW,kBAAc,MAAAwB,IAAnBA,OAAAA,OAAAA,EAAqB1H,QAAS9P,EAAKiW,aAAanG,MAC1DwH,EAAK7C,eACL6C,EAAK9S,UAAU2B,OAAQ,qBAAoBmR,EAAK7C,eAAe,EAE/D3E,IACAwH,EAAK7C,cAAgB3E,EACjBjO,EAAU4V,aAAa3H,CAAK,EAC5BwH,EAAK9S,UAAUC,IAAK,qBAAoBqL,GAAO,EAG/CwH,EAAKrV,MAAM6N,MAAQA,GAI3B9P,EAAKgW,iBACLsB,EAAKjL,QAAQqL,KAAO1X,EAAKgW,eAAe3I,IAE5CiK,EAAKjL,QAAQkB,OAASvN,EAAKiW,aAAa5I,GAE5C,GAAI1F,EAAe,CACf,KACI,CAAE0L,YAAAA,EAAaiC,iBAAAA,EAAkB3Q,SAAAA,CAAS,EAAI3E,EAgB9C6E,EAA8C9H,EAAOmD,QACjD,WACA,CAAEF,KAAAA,EAAMqT,YAAAA,EAAa2C,eAAAA,EAAgBC,aAAAA,EAAcX,iBAAAA,EAAkB3Q,SAAAA,EAAU1E,MAAQmT,EAAUA,SAAAA,CAAS,CAC9G,EACJ7V,EAAGqJ,eAAe5G,EAAM6E,IAAW,EAAK,GAGpD,CACA,MAAM+C,SAAS5H,EAAM,CACjB,MACIzC,EAAa,KACb,CAAER,OAAAA,GAAWQ,EAAGQ,MAChB,CACIyH,eAAAA,EACA6N,YAAAA,EACA2C,eAAAA,EACAC,aAAAA,EACAX,iBAAAA,EACArV,MAAQmT,CACZ,EAAapT,EACbC,EAAa,CAAED,KAAAA,EAAMoT,SAAAA,EAAUnT,MAAQmT,EAAUC,YAAAA,EAAa2C,eAAAA,EAAgBC,aAAAA,EAAcX,iBAAAA,GAkC5F,CAhCaxC,GAAWtN,CAAc,GAgC1B,CAACyQ,GAAgBjW,EAAK+G,SAAW,MAAMhK,EAAOmD,QAAQ,iBAAkBD,CAAK,IAAM,GAC/FD,EAAK6G,MAAQ,GAGb7G,EAAK6H,UAAY,IAAIC,QAAQC,GAAW,OAEpC,KACI,CACI4P,YAAAA,EACAC,cAAAA,CACJ,EAAkB7a,EAClB,CAAE8a,UAAAA,GAAgB9a,EAAO+a,QACzB,CACIlW,MAAAA,CACJ,EAAkB5B,EAClB+X,EAAkB9B,EAAa+B,MAC/BC,EAAkBjC,EACZ+B,GAAa,KAAA,OAAbA,EAAelE,OAAOqE,GAAQA,EAAKN,CAAa,IAAM5B,EAAe3I,EAAE,EACvE0K,EACNhR,EAAkB,CAACgR,EACvB,IAAII,EACJ,GAAI,CAACpR,EAED,GAAI/G,EAAKsV,kBAEL,GAAItV,EAAK2E,WAAa,SAClBwT,EAAa7C,UAGRtV,EAAK2E,WAAa,QAAS,CAChC,MAAM6L,EAAQyH,EAAgB/Y,QAAQoW,CAAgB,EACtD6C,GAAaF,EAAAA,EAAgBzH,EAAQ,CAAC,IAAzByH,KAAAA,EAA8B,WAI1CA,EAAgBhU,SACrBkU,EAAa,MAGrB,SAASnQ,GAAS,CAed,GAbApG,EAAMuE,OAAM,EACZX,EAAe1C,QAAQ6C,GAAiB,CACpC,KAAM,CAAE2O,YAAAA,GAAgB3O,EAAcD,YAEtCC,EAAcvB,cAAcgC,aAAakO,EAAa3O,CAAa,EAEnEA,EAAcvB,cAAciO,UAAUiC,EAAY5O,YAAY0S,MAAM,EAAI9D,EAExEA,EAAY9P,UAAU2B,OAAO,iBAAiB,EAC9CR,EAAcQ,OAAM,CACxB,CAAC,EACDpJ,EAAOkL,qBAAoB,EAEvB,CAAClB,EAAS,CACV,IAAIsR,EAEJ,GAAIF,EAAY,CACZ,MAEIG,EAAaL,EAAgB9C,MAAM8C,EAAgB/Y,QAAQiZ,CAAU,CAAC,EAEtEI,EAAYN,EAAgBA,EAAgB/Y,QAAQiZ,CAAU,EAAI,CAAC,EACvE,IAAIK,GAeJ,IAZID,GAEAC,GAAaxZ,KAAKyZ,IAAI,EAAGzZ,KAAK0Z,OAAOP,EAAWvY,OAAS2Y,EAAU3Y,QAAU,CAAC,CAAC,EAC/EyY,EAAYE,EAAU3Y,OAAS4Y,IAI/BH,EAAYrZ,KAAKyZ,IAAI,EAAGzZ,KAAK0Z,MAAMP,EAAWvY,OAAS,CAAC,CAAC,IAKtD+Y,EAAAL,EAAW,CAAC,KAACK,MAAAA,IAAA,OAAA,OAAbA,EAAe/Y,UAAWyY,GAAW,CAAA,IAAAM,EAExCH,GAAaF,EAAW,CAAC,EACnBtZ,KAAKyZ,IAAI,EAAGzZ,KAAK0Z,OAAOJ,EAAW,CAAC,EAAE1Y,OAASyY,GAAa,CAAC,CAAC,EAC9D,GACNA,EAAYC,EAAW,CAAC,EAAE1Y,OAASyY,EAAYG,GAC/CF,EAAWM,MAAK,QAKpBP,EAAYJ,EAAgBhU,OACtBgU,EAAgBA,EAAgBhU,OAAS,CAAC,EAAErE,OAAS,IACrD,IAEVyT,EAAYvQ,QAAQyL,GAAc,CAC9B,MAAMsK,EAAQ,CACV,CAAClB,CAAW,EAAI1B,EAAa5I,GAC7BzN,OAAgByY,GAEhBrC,IACA6C,EAAMjB,CAAa,EAAI5B,EAAe3I,IAGtCtQ,EAAO+b,SAASC,SAASzF,oBAAsB6E,IAAehR,QAC9D0Q,EAAUjZ,KAAK2P,EAAY4J,CAAU,EAEzC5J,EAAW/B,IAAIqM,CAAK,CACxB,CAAC,EAEG,CAAC9b,EAAO+b,SAASC,SAASzF,oBAAsB,CAACvW,EAAOic,cACxDjc,EAAO+a,QAAQD,UAAU9D,KAAI,EAGrChX,EAAOmL,oBAAmB,EAY1BnL,EAAOmD,QAAQ,WAAY,CAAEF,KAAAA,EAAMC,MAAQmT,EAAUC,YAAAA,EAAa2C,eAAAA,EAAgBC,aAAAA,EAAckC,WAAAA,EAAY/E,SAAAA,CAAS,CAAC,EAWtHrW,EAAOmD,QAAQ,cAAe,CAAEF,KAAAA,EAAMqT,YAAAA,EAAaD,SAAAA,CAAS,CAAC,EAE7DrW,EAAOgG,QAAQyB,UAAU2B,OAAO,iBAAiB,EAEjD,UAAWoI,KAAc8E,EACrB9E,EAAWgH,aAAaxY,CAAM,EAAEyY,SAAW,GAE/CzN,EAAO,CACX,CAEA,MAAM2L,EAAapD,MAAM/O,KAAKK,EAAMqE,QAAQ,EAE5CrE,EAAM4C,UAAUC,IAAI,gBAAgB,EACpCiP,EAAW,CAAC,EAAEuF,YAEdrX,EAAM4C,UAAUC,IAAI,YAAY,EAEhCiP,EAAW5Q,QAAQ,CAAC0R,EAAWxR,IAAM,CACjC,MAAMkW,EAAY1T,EAAexC,CAAC,EAClCnB,EAAUuG,QACNoM,EAEAlT,EAAUC,KAAK2X,EAAW/R,OAAW,EAAI,CAC7C,CACJ,CAAC,EAEGtF,EAAUwG,8BAA8BqL,EAAW,CAAC,EAAG,WAAW,EAClEjS,EAAY6G,gBAAgB,CACxBvF,QAAW2Q,EAAW,CAAC,EACvBnL,SAAW,YACXC,QAAWR,EACX7J,QAAWpB,CACf,CAAC,EAIDiL,EAAM,CAEd,CAAC,CAET,CACAS,UAAUzI,EAAM,CAEZA,EAAKwF,eAAe1C,QAAQ6C,GAAiB,CACzC,KAAM,CAAE2O,YAAAA,GAAgB3O,EAAcD,YACtC4O,EAAYlQ,cAAcgC,aAAaT,EAAe2O,CAAW,CACrE,CAAC,CACL,CACA5L,QAAQ1I,EAAM,CACV,KACI,CAAEjD,OAAAA,GAAuC,KAAKgB,MAC9C,CAAEyH,eAAAA,EAAgB5D,MAAAA,EAAOyR,YAAAA,CAAY,EAAIrT,EAC7C,GAAI4B,EAAO,CAEP,IAAS+G,EAAT,UAAyB,CAErB/G,EAAMuE,OAAM,EACZX,EAAe1C,QAAQ6C,GAAiB,CACpCA,EAAcD,YAAY4O,YAAY9P,UAAU2B,OAAO,iBAAiB,EACxER,EAAcQ,OAAM,CACxB,CAAC,EACDpJ,EAAOgG,QAAQyB,UAAU2B,OAAO,iBAAiB,EAEjD,UAAWoI,KAAc8E,EACrB9E,EAAWgH,aAAaxY,CAAM,EAAEyY,SAAW,GAE/CzY,EAAOmD,QAAQ,wBAAwB,CAC3C,EAdA,MAAMwT,EAAapD,MAAM/O,KAAKK,EAAMqE,QAAQ,EAgB5CrE,EAAM4C,UAAUC,IAAI,YAAY,EAEhCe,EAAe1C,QAAQ6C,GAAiB,CACpC,KAAM,CAAE2O,YAAAA,GAAgB3O,EAAcD,YACtCC,EAAcnB,UAAU2B,OAAO,WAAW,EAC1CmO,EAAYlQ,cAAcgC,aAAaT,EAAe2O,CAAW,CACrE,CAAC,EAEDZ,EAAW5Q,QAAQ,CAAC0R,EAAWxR,IAAM,CACjCnB,EAAUuG,QACNoM,EAEAlT,EAAUC,KAAKiE,EAAexC,CAAC,EAAGmE,OAAW,EAAI,CACrD,CACJ,CAAC,EAEGtF,EAAUwG,8BAA8BqL,EAAW,CAAC,EAAG,WAAW,EAClEjS,EAAY6G,gBAAgB,CACxBvF,QAAW2Q,EAAW,CAAC,EACvBnL,SAAW,YACXC,QAAWG,EACXxK,QAAWpB,CACf,CAAC,EAID4L,EAAa,EAWrB5L,EAAOmD,QAAQ,gBAAiB,CAAEF,KAAAA,EAAMqT,YAAAA,CAAY,CAAC,EACjDrT,EAAKsF,YAELvI,EAAOmD,QAAQ,cAAe,CAAEF,KAAAA,EAAMqT,YAAAA,CAAY,CAAC,CAE3D,CACAxK,QAAQ7I,EAAM,EAEN,CAACA,EAAK6G,OAAS7G,EAAK8I,UACpB,KAAKJ,QAAQ1I,CAAI,CAEzB,CACJ,CACAkT,EAAS9V,OAAS,WC3yBH,MAAM+b,UAAuB5c,CAAiB,CAA9C,kCAsBX6c,EAAAA,aAAQ,QAKRC,oBAAoBC,EAAW,CAC3BjQ,OAAAA,EAAakQ,aAAaD,EAAW,uCAAuC,EACrEA,CACX,CAEAE,qBAAqBvZ,EAAO,CACxB,MACI1C,EAAa,KACb,CAAER,OAAAA,CAAO,EAAIQ,EACjBA,EAAG4F,OAAS7B,EAAUC,KAAKxE,EAAOkI,YAAsC,EAAI,EAC5E1H,EAAGwF,QAAUlB,EAAUC,cAAc,CACjCgI,IAAY,MACZ/H,UAAY,mBAChB,EAAG,CAAE0X,UAAY,GAAM,EAAE,CAAC,EAC1B1c,EAAO2c,UAAUnV,YAAYhH,EAAGwF,OAAO,EACvChG,EAAOgG,QAAQyB,UAAUC,IAAI,iBAAiB,EAG9ClH,EAAGoc,eAAiBrJ,MAAM/O,KAAKxE,EAAOgG,QAAQwN,iBAAiB,mBAAmB,CAAC,EAAE9K,IAAImU,IAAO,CAC5FC,UAAYvY,EAAUC,KAAKqY,EAA6B,EAAI,EAC5D1J,OAAYnT,EAAO0W,kBAAkBmG,CAAE,CAC3C,EAAE,EACG3Z,EAAM6Z,SACP/c,EAAOgd,YAAW,EAGtBhd,EAAOid,aAAe,GACtBzc,EAAG6b,MAAQ,WACf,CAEAa,iBAAkB,CACd,KAAM,CAAEN,eAAAA,EAAgBE,UAAAA,EAAW9c,OAAAA,CAAO,EAAI,KAC9C,QAASiG,EAAI,EAAGkX,EAAMP,EAAe1V,OAAQjB,EAAIkX,EAAKlX,IAAK,CACvD,MACImX,EAAeR,EAAe3W,CAAC,EAC/BoX,EAAeP,EAAUQ,UAAUF,EAASN,UAAW,EAAI,EAC3DO,GAAgB,CAACD,EAASG,UAC1BH,EAASG,SAAW,GACpBvd,EAAOwd,WAAWJ,EAASjK,OAAQ,EAAI,GAElC,CAACkK,GAAgBD,EAASG,WAC/BH,EAASG,SAAW,GACpBvd,EAAOyd,aAAaL,EAASjK,MAAM,GAG/C,CAEAuK,kBAAkB,CAAExa,MAAAA,CAAM,EAAG,CACzB,MAAM1C,EAAK,KACP,CAACA,EAAGK,UAAYqC,EAAMya,SAAW,IACjCnd,EAAG6b,MAAQ,cACX7b,EAAGod,OAAS1a,EAAM2V,QAClBrY,EAAGqd,OAAS3a,EAAM4V,QAClBtY,EAAGsd,gBAAkBpZ,EAAYqZ,GAAG,CAChC/X,QAAUgY,SACVC,QAAU,YACV7c,QAAUZ,CACd,CAAC,EAET,CACA0d,YAAY,CAAEhb,MAAAA,CAAM,EAAG,CACnB,MACI1C,EAAuB,KACvB,CAAEod,OAAAA,EAAQC,OAAAA,CAAO,EAAMrd,EACvB,CAAEqY,QAAAA,EAASC,QAAAA,CAAQ,EAAI5V,EAC3B,GAAI1C,EAAG6b,QAAU,cAAe,CAC5B,MACI8B,EAASlc,KAAKmc,IAAIvF,EAAU+E,CAAM,EAClCS,EAASpc,KAAKmc,IAAItF,EAAU+E,CAAM,GAClCM,EAAS3d,EAAG8d,eAAiBD,EAAS7d,EAAG8d,gBACzC9d,EAAGic,qBAAqBvZ,CAAK,EAGrC,GAAI1C,EAAG6b,QAAU,YAAa,CAC1B,KACI,CAAErW,QAAAA,EAASI,OAAAA,CAAO,EAAI5F,EACtB+E,EAAsBtD,KAAKyZ,IAAI7C,EAASzS,EAAOf,IAAI,EACnDD,EAAsBnD,KAAKyZ,IAAI5C,EAAS1S,EAAOjB,GAAG,EAClDE,EAAsBpD,KAAKC,IAAI0b,EAAQrY,CAAC,EACxCJ,EAAsBlD,KAAKC,IAAI2b,EAAQzY,CAAC,EACxCI,EAAsBvD,KAAKmc,IAAIR,EAASrY,CAAC,EACzCgB,EAAsBtE,KAAKmc,IAAIP,EAASzY,CAAC,EACzCmZ,EAAsB,IAAIha,EAAUc,EAAMF,EAAKK,EAAOe,CAAM,EAAEiY,YAAYpY,CAAM,EACpFtB,EAAU2Z,eAAezY,EAASuY,EAAKlZ,KAAMkZ,EAAKpZ,GAAG,EACrDa,EAAQd,MAAMM,MAAS+Y,EAAK/Y,MAAQ,KACpCQ,EAAQd,MAAMqB,OAASgY,EAAKhY,OAAS,KACrC/F,EAAGsc,UAAYyB,EACf/d,EAAG0c,gBAAe,EAE1B,CACAwB,WAAY,CAAA,IAAAC,EACR,MACIne,EAAoB,KACpB,CAAER,OAAAA,EAAQqc,MAAAA,CAAM,EAAI7b,EAExB,GAAI6b,IAAU,YAAa,CAAA,IAAAuC,GACvBA,EAAApe,EAAGwF,WAAO,MAAA4Y,IAAA,QAAVA,EAAYxV,OAAM,EAClBpJ,EAAOgG,QAAQyB,UAAU2B,OAAO,iBAAiB,EAEjDpJ,EAAOkQ,WAAW,IAAMlQ,EAAOid,aAAe,GAAM,GAAG,GAEvDZ,IAAU,aAAeA,IAAU,iBACnC7b,EAAG6b,MAAQ,OACX7b,EAAGod,OAASpd,EAAGqd,OAASrd,EAAGsc,UAAYtc,EAAG4F,OAAS,OAEvDuY,EAAAne,EAAGsd,mBAAe,MAAAa,IAAA,QAAlBA,EAAA1P,KAAAzO,CAAqB,CACzB,CAEJ,CAtIIN,EADiBkc,EACV/Y,QAAS,kBAChBnD,EAFiBkc,EAEV9Y,OAAO,kBACdpD,EAHiBkc,EAGVhc,eAAe,CAiBlBke,cAAgB,IAGpBpe,EAvBiBkc,EAuBV7Y,eAAe,CAClB4I,MAAQ,CAAC,oBAAqB,aAAa,IAgHnDiQ,EAAe3Y,UAAS,EACxB2Y,EAAe/b,OAAS,iBCpJxB,IAAAwe,EAAeC,GAAM,OAAI,OAAAC,EAAA,cAA+BD,GAAUpb,EAAM,CAoBpE,IAAIW,WAAY,CACZ,OAAO,KAAK2a,YAAc,KAAKC,GAAGC,GAAUA,EAAOC,eAAe,GAAKC,GAAOC,MAAMH,GAAUA,EAAOC,eAAe,CACxH,CACAG,gBAAgBjb,EAAW,CACvB,GAAIA,GAAa,CAACA,EAAUkb,YACxB,MAAM,IAAIC,MAAO,kFAAiF,EAEtG,OAAOnb,CACX,CACJ,EA5BInE,EADqB6e,EACd1b,QAAQ,mBACfnD,EAFqB6e,EAEd3e,eAAe,CAgBlBiE,UAAY,OAlBK0a,GCKV,MAAMU,UAAsBC,GAAMhgB,MAAMmf,CAAe,CAAE,CAwBpEc,gBAAiB,CACT,CAAC,KAAKC,mBAAqB,CAAC,KAAKC,OACjC,KAAK7Z,QAAQyB,UAAUC,IAAI,aAAa,CAEhD,CACAoY,uBAAuBjgB,EAAM,CACzB,MACIW,EAAY,KACZ,CAAEuS,MAAAA,CAAM,EAAIvS,EAAG2S,QAAU,CAAA,EAC7B,IAAInO,EAAY,aACZ+N,IACIjO,EAAU4V,aAAa3H,CAAK,EAC5B/N,GAAc,sBAAqB+N,IAGnCvS,EAAGuf,SAAS7a,MAAM6N,MAAQA,GAGlCvS,EAAGuf,SAAS/a,UAAYA,EACnBxE,EAAGof,mBACJpf,EAAGwF,QAAQyB,UAAUsC,OAAO,cAAe,CAACgJ,CAAK,EAErD,MAAM+M,oBAAoB,GAAGjgB,CAAI,CACrC,CACA,IAAImgB,eAAgB,CAChB,MAAO,CACH,CACIC,UAAY,WACZjb,UAAY,YAChB,EACA,GAAG,MAAMgb,aAAa,CAE9B,CACJ,CAxDI9f,EADiBuf,EACVpc,QAAQ,iBACfnD,EAFiBuf,EAEVnc,OAAO,iBACdpD,EAHiBuf,EAGVrf,eAAe,CAClB8f,aAAoB,OACpBC,WAAoB,KACpBC,SAAoB,GACpBR,kBAAoB,GACpBS,YAAY,CAAE1d,KAAAA,EAAMoQ,MAAAA,CAAM,EAAG,CACzB,IAAIuN,EAAOC,EAAaC,WAAW7d,CAAI,EACvC,OAAIoQ,IACIjO,EAAU4V,aAAa3H,CAAK,EAC5BuN,EAAQ,4CAA2CvN,YAAkBuN,EAGrEA,EAAQ,0CAAyCvN,YAAkBuN,GAGpEA,GAEXG,OAAS,CACLvR,IAAM,mBACV,IAoCRuQ,EAAcpf,OAAS,gBCxDR,MAAMqgB,WAAoBjB,CAAc,CAGnDkB,aAAc,CACV,OAAO,KAAKtc,UAAUzC,QAAQuK,MAAK,CACvC,CACJ,CALIjM,EADiBwgB,GACVrd,QAAQ,eACfnD,EAFiBwgB,GAEVpd,OAAO,eAKlBod,GAAYjd,UAAS,EACrBid,GAAYrgB,OAAS,cCHN,MAAMugB,WAAuBlB,GAAMhgB,MAAMmf,CAAe,CAAE,CA0CrE,IAAImB,eAAgB,CAEhB,OAAI,KAAKa,WAAW,aAAa,GAAK,KAAKC,aAChC,MAAMd,cAGV,CACH,CAAEC,UAAY,iBAAkB,EAChC,KAAKc,YAAY,CAEzB,CACAjB,uBAAuBjgB,EAAM,CACzB,MAAMW,EAAK,KAEX,GAAI,CAACA,EAAGwgB,YAAa,CACjB,MAAMC,EAAiBzgB,EAAG2S,OACtB8N,GACAra,EAAQsa,KAAK,CACTC,cAAgB3gB,EAAG4gB,gBACnBC,UAAgB,CACZrc,UAAY,oCACZkE,SAAY,CACR1I,EAAG8gB,gBAAgBC,kBAAkB,CACjCN,eAAAA,EACAO,SAAWP,EAAeO,SAC1BzO,MAAWkO,EAAelO,MAC1B0O,QAAWR,EAAeQ,QAC1BC,SAAWT,EAAeU,QAAU,GAAQ,KAAQV,EAAeS,WAAclhB,EAAG6D,UAAUud,mBAAqB,KAAOX,EAAeU,OAAS,IAClJrS,QAAW,CACPuS,KAAOtB,EAAaC,WAAWS,EAAezO,IAAI,CACtD,CACJ,CAAC,CAAC,CAEV,CACJ,CAAC,EAGT,MAAMsN,oBAAoB,GAAGjgB,CAAI,CACrC,CACA8gB,aAAc,CACV,OAAO,KAAKtc,UAAU0W,QAAQ+G,cAAc3V,MAAK,CACrD,CACA4V,sBAAsBlC,EAAOmC,EAAK,CAE9B,GADAA,GAAG,MAAHA,EAAKzgB,QAAO,EACRse,EACA,OAAO,IAAIoC,GAAgB,CACvBjc,QAAU,KAAKA,OACnB,CAAC,CAET,CACJ,CA3FI9F,EADiB0gB,GACVvd,QAAQ,kBACfnD,EAFiB0gB,GAEVtd,OAAO,kBACdpD,EAHiB0gB,GAGVxgB,eAAe,CAClB8f,aAAe,OACfC,WAAe,KACfa,YAAe,GACfZ,SAAe,GACfC,YAAYY,EAAgB,CACxB,KAAM,CAAEK,gBAAAA,EAAiBjd,UAAAA,GAAc,KAAKrD,MAC5C,OAAO8D,EAAUC,cAAcuc,EAAgBC,kBAAkB,CAC7DN,eAAAA,EACAO,SAAWP,EAAeO,SAC1BzO,MAAWkO,EAAelO,MAC1B0O,QAAWR,EAAeQ,QAC1BC,SAAWT,EAAeU,QAAU,GAAQ,KAAQV,EAAeS,WAAcrd,EAAUud,mBAAqB,KAAOX,EAAeU,OAAS,GACnJ,CAAC,CAAC,EAAEO,UAAY3B,EAAaC,WAAWS,EAAezO,IAAI,GAE/DiO,OAAS,CACLvR,IAAM,sBAEViT,SAAW,CACPC,WAAa,KACbC,QAAQpB,EAAgB,CACpB,KAAM,CAAEK,gBAAAA,EAAiBjd,UAAAA,GAAc,KAAKrD,MAC5C,OAAO8D,EAAUC,cAAcuc,EAAgBC,kBAAkB,CAC7DN,eAAAA,EACAO,SAAWP,EAAeO,SAC1BzO,MAAWkO,EAAelO,MAC1B0O,QAAWR,EAAeQ,QAC1BC,SAAWT,EAAeU,QAAU,GAAQ,KAAQV,EAAeS,WAAcrd,EAAUud,mBAAqB,KAAOX,EAAeU,OAAS,IAC/IrS,QAAW,CACPuS,KAAOtB,EAAaC,WAAWS,EAAezO,IAAI,CACtD,EACH,CAAC,EAAE0P,SACR,GAEJZ,gBAAkB,CACdzB,MAAU,GACVyC,QAAU,SACd,IAqDR1B,GAAend,UAAS,EACxBmd,GAAevgB,OAAS,iBCnGT,MAAMkiB,WAAsB9C,CAAc,CAGrDkB,aAAc,CACV,OAAO,KAAKtc,UAAUmF,UAAU2C,MAAK,CACzC,CACJ,CALIjM,EADiBqiB,GACVlf,QAAQ,iBACfnD,EAFiBqiB,GAEVjf,OAAO,iBAKlBif,GAAc9e,UAAS,EACvB8e,GAAcliB,OAAS,gBCDR,MAAMmiB,WAAwBC,EAAY,CA6BzD,CA5BIviB,EADiBsiB,GACVnf,QAAQ,mBACfnD,EAFiBsiB,GAEVlf,OAAO,mBACdpD,EAHiBsiB,GAGVpiB,eAAe,CAElBsiB,aAAe,CACX,CAAE3P,MAAQ,MAAOpQ,KAAO,KAAM,EAC9B,CAAEoQ,MAAQ,OAAQpQ,KAAO,MAAO,EAChC,CAAEoQ,MAAQ,SAAUpQ,KAAO,QAAS,EACpC,CAAEoQ,MAAQ,cAAepQ,KAAO,aAAc,EAC9C,CAAEoQ,MAAQ,SAAUpQ,KAAO,QAAS,EACpC,CAAEoQ,MAAQ,OAAQpQ,KAAO,MAAO,EAChC,CAAEoQ,MAAQ,aAAcpQ,KAAO,YAAa,EAC5C,CAAEoQ,MAAQ,OAAQpQ,KAAO,MAAO,EAChC,CAAEoQ,MAAQ,OAAQpQ,KAAO,MAAO,EAChC,CAAEoQ,MAAQ,QAASpQ,KAAO,OAAQ,EAClC,CAAEoQ,MAAQ,cAAepQ,KAAO,aAAc,EAC9C,CAAEoQ,MAAQ,OAAQpQ,KAAO,MAAO,EAChC,CAAEoQ,MAAQ,SAAUpQ,KAAO,QAAS,EACpC,CAAEoQ,MAAQ,QAASpQ,KAAO,OAAQ,EAClC,CAAEoQ,MAAQ,SAAUpQ,KAAO,QAAS,EACpC,CAAEoQ,MAAQ,cAAepQ,KAAO,aAAc,CAAC,EAEnDggB,iBAAmB,gCAInBC,OAAS,OAGjBJ,GAAgB/e,UAAS,EACzB+e,GAAgBniB,OAAS,kBCvCV,MAAMwiB,WAAuBC,EAAW,CAUvD,CATI5iB,EADiB2iB,GACVxf,QAAQ,kBACfnD,EAFiB2iB,GAEVvf,OAAO,kBACdpD,EAHiB2iB,GAGVziB,eAAe,CAClBqgB,OAAS,CACLnd,KAAO,mBAEXkP,KAAY,aACZuQ,UAAY,KAGpBF,GAAepf,UAAS,EACxBof,GAAexiB,OAAS,iBCuBT,MAAM2iB,WAAmBC,GAAMvjB,MAAMmf,CAAe,CAAE,CAiFjExS,YAAY9J,EAAOyf,EAAK,CACpB,KACI,CAAE3d,UAAAA,CAAU,EAAsB,KAClC,CAAEmM,OAAAA,EAAQ/J,SAAAA,EAAUyc,UAAAA,CAAU,EAAI3gB,EACtC,OAAI8B,GAEImM,IACKA,EAAOgC,OACRhC,EAAOgC,KAAOnO,EAAUuW,aAEvBpK,EAAO2S,QACR3S,EAAO2S,MAAQ5C,EAAa6C,WAAW/e,EAAUuW,WAAW,IAGhEnU,IAEI,CAACpC,EAAUwW,eAAiB,CAACxW,EAAUmF,UACvCjH,EAAMkE,SAAW,MAIZA,EAAS+L,OACV/L,EAAS+L,KAAOnO,EAAUwW,eAEzBpU,EAAS0c,QACV1c,EAAS0c,MAAQ5C,EAAa6C,WAAW/e,EAAUwW,aAAa,KAKvExW,EAAU0W,QAAQ+G,cAAc1f,QACjCG,EAAM2gB,UAAY,MAGlB7e,EAAU0W,QAAQsI,WAAWC,sBAAwBJ,IACrDA,EAAUlC,YAAc,KAI5Bze,EAAMiO,OAASjO,EAAMkE,SAAWlE,EAAM2gB,UAAY,KAE/C,MAAM7W,YAAY9J,EAAOyf,CAAG,CACvC,CACAuB,mBAAmBhhB,EAAO8L,EAAYvG,EAAQ,CAE1C,UAAW6G,KAAOpM,EAAO,CACrB,MAAMsM,EAAOtM,EAAMoM,CAAG,EAClBE,GAAQ,EAAE,SAAUA,KACpBA,EAAK2D,KAAO7D,GAGpB,OAAO,MAAM4U,mBAAmBhhB,EAAO8L,EAAYvG,CAAM,CAC7D,CACA0b,uBAAuBC,EAAY,CAC/B,KAAK3T,KAAK4T,OAASD,CACvB,CACAE,aAAaxQ,EAAQ,CACjB,MAAMwQ,aAAaxQ,CAAM,EACrBA,IAEA,KAAKnN,QAAQsJ,QAAQ+L,OAASlI,EAAO7C,GAE7C,CACAsT,aAAc,CACV,MACIpjB,EAA2B,KAC3B,CAAE2S,OAAAA,EAAQnS,MAAAA,CAAM,EAAWR,EAC3B,CAAE0iB,UAAAA,EAAW,GAAGW,GAAWrjB,EAAGqjB,OAClC,GAAIrjB,EAAGsjB,QAAS,CAYZ,IAAI9iB,GAAK,KAAA,OAALA,EAAOmC,QAAQ,aAAc,CAAEgQ,OAAAA,EAAQ0Q,OAASrjB,EAAGqjB,OAAQ5S,OAASzQ,EAAI,KAAM,GAC9E,OAWJQ,GAAK,MAALA,EAAOmC,QAAQ,OAAQ,CAAEgQ,OAAAA,EAAQ0Q,OAASrjB,EAAGqjB,OAAQ5S,OAASzQ,CAAG,CAAC,EAElEA,EAAGujB,MAAK,EACR5Q,EAAO1D,IAAIoU,CAAM,EACbX,IAEA/P,EAAO+P,UAAYA,GAG/B,CACAc,eAAgB,CAAA,IAAAC,EAAAC,EACZ,MAAM1jB,EAAK,OASPyjB,EAAAzjB,EAAGQ,SAAK,MAAAijB,IAAA,OAAA,OAARA,EAAU9gB,QAAQ,eAAgB,CAAE8N,OAASzQ,EAAI,KAAM,MAU3D0jB,EAAA1jB,EAAGQ,SAAK,MAAAkjB,IAAA,QAARA,EAAU/gB,QAAQ,SAAU,CAAE8N,OAASzQ,CAAG,CAAC,EAC3CA,EAAGujB,MAAK,EACZ,CACAI,kBAAkBjhB,EAAO,CACrB,MAAM1C,EAAK,KACPA,EAAG4jB,qBAAuB,CAAC5jB,EAAGiC,UAAYS,EAAMoL,MAAQ,UAExDpL,EAAMoR,eAAc,EAChB9T,EAAG6jB,iBACC7jB,EAAGsjB,UAEH5gB,EAAMmK,OAAOiX,KAAI,EACjB9jB,EAAGujB,MAAK,GAIZvjB,EAAGojB,YAAW,GAGtB,MAAMO,kBAAkBjhB,CAAK,CACjC,CACJ,CA/NIhD,EADiB8iB,GACV3f,QAAQ,cACfnD,EAFiB8iB,GAEV1f,OAAO,uBACdpD,EAHiB8iB,GAGV5iB,eAAe,CAOlBmkB,SAAW,GAUXC,MAAQ,CAAEC,eAAiB,IAO3BC,SAAW,GASXL,iBAAmB,GAKnBM,iBAAmB,GASnBP,oBAAsB,GACtB3jB,UAAY,CACRmkB,eAAiB,mBAErBC,SAAW,GACXnX,OAAS,GACToX,YAAc,UACd3S,aAAe,UACf4S,MAAQ,wBACRC,SAAW,CACPC,WAAa,OAEjBzf,MAAQ,OACRjD,MAAQ,CACJiQ,KAAc,CAAElP,KAAO,OAAQ6f,MAAQ,oBAAqBtgB,OAAS,KACrEqiB,YAAc,CAAE5hB,KAAO,WAAY6f,MAAQ,2BAA4B5c,OAAS,MAAO1D,OAAS,KAChGqgB,UAAc,CAAE5f,KAAO,iBAAkB6f,MAAQ,yBAA0BtgB,OAAS,KACpFkQ,MAAc,CAAEzP,KAAO,iBAAkB6f,MAAQ,qBAAsB3Q,KAAO,aAAc3P,OAAS,KACrG2N,OAAc,CAAElN,KAAO,cAAeT,OAAS,KAC/C4D,SAAc,CAAEnD,KAAO,gBAAiBT,OAAS,GAAI,GAEzDiN,KAAO,CACH4T,OAAS,GACTnhB,MAAS,CACL4iB,WAAe,CAAExiB,KAAO,oBAAqBiO,QAAU,iBAAkB/N,OAAS,KAClFuiB,aAAe,CAAEziB,KAAO,sBAAuBiO,QAAU,mBAAoB/N,OAAS,GAAI,CAC9F,GAGJwiB,iBAAmB,KAkJ3BrC,GAAWvf,UAAS,EACpBuf,GAAW3iB,OAAS,aCxHL,MAAMilB,UAAiB9lB,CAAiB,CAAxC,kCAuFXyR,EAAAA,cAAS,MAKT5P,WAAY,CAAA,IAAAkkB,GACRA,EAAI,KAACtU,UAAM,MAAAsU,IAAA,QAAXA,EAAahkB,QAAO,CACxB,CAEAikB,mBAAmB3S,EAAc,CAC7BvG,OAAAA,EAAaC,aAAasG,EAAc,gCAAgC,EACjEA,CACX,CACA4S,iBAAiBC,EAAY,CACzBpZ,OAAAA,EAAaqZ,aAAaD,EAAY,8BAA8B,EAC7DA,CACX,CACArZ,YAAY9J,EAAO,CACf+J,OAAAA,EAAaC,aAAahK,EAAO,yBAAyB,EACnDA,CACX,CACAiK,mBAAmBiB,EAAc,CAC7BnB,OAAAA,EAAaI,eAAee,EAAc,gCAAgC,EACnEA,CACX,CAeA,MAAM8D,SAASC,EAAYxL,EAAU,KAAM,CAAA,IAAAsD,EAAAkF,EACvC,MACIhO,EAAiB,KACjB,CAAER,OAAAA,CAAO,EAAQQ,EACjBmB,EAAiB3B,EAAOiU,UAAUzC,CAAU,EAC5CjI,EAAiBvJ,EAAO6a,iBAAavR,EAAItJ,EAAOwJ,aAASF,MAAAA,IAAA,OAAA,OAAhBA,EAAkBsc,QAAQpU,EAAWqU,SAAS7lB,EAAO6a,aAAa,CAAC,GAwBhH,GAvBIra,EAAGK,UAuBH,MAAMb,EAAOmD,QAAQ,iBAAkB,CAAEqO,WAAAA,EAAY,IAAM,GAC3D,OAEAhR,EAAGslB,WACHtlB,EAAG4T,WAAU,EAEjB,MACI2R,EAAgB3G,GAAO4G,YAAYxlB,EAAGklB,UAAU,EAEhDO,EAAgBF,EAAYG,aAAaH,EAAYI,MAAMja,OAAO3J,MAAO/B,EAAG+B,KAAK,EAGrF,KADiBiM,EAAGhO,EAAGiN,gBAAY,MAAAe,IAAA,OAAA,OAAfA,EAAAS,KAAAzO,EAAkB,CAAE+B,MAAQ0jB,EAAezU,WAAAA,EAAY7P,aAAAA,EAAc4H,eAAAA,CAAe,CAAC,KACnF,GAClB,OAEJ,MAAM0H,EAASzQ,EAAGyQ,OAAS8U,EAAYplB,IAAI,CACvC4B,MAAW0jB,EACXjlB,MAAWhB,EACXyC,SAAW+O,EAAW/O,QAC1B,EAAGjC,EAAGqS,YAAY,EAmBlB7S,EAAOmD,QAAQ,qBAAsB,CAAEqO,WAAAA,EAAYP,OAAAA,CAAO,CAAC,EAC3DA,EAAOkC,OAAS3B,EACZP,EAAOsT,UAAY,CAAC6B,EAAcC,kBAClCpV,EAAOqV,KAAI,GAGXC,GAASvT,eAAehN,GAAAA,KAAAA,EAAWhG,EAAOyR,eAAeD,CAAU,CAAC,EACpEP,EAAOuV,OAAOxgB,GAAAA,KAAAA,EAAWhG,EAAOyR,eAAeD,CAAU,CAAC,GAE9DP,EAAOwV,WAAaxV,EAAOyV,IAAI,CAC3BC,KAAUnmB,EAAGomB,aACbxlB,QAAUZ,CACd,CAAC,CACL,CACA4T,YAAa,CAAA,CAEbC,eAAe,CAAE7C,WAAAA,EAAYtO,MAAAA,CAAM,EAAG,CAC7BA,EAAM2jB,kBACP,KAAKtV,SAASC,CAAU,CAEhC,CACAsV,iBAAiB,CAAEvkB,MAAAA,EAAOiP,WAAAA,CAAW,EAAG,CAChC,CAAC,KAAKxR,OAAOyC,UAAY,CAAC,KAAK5B,WAC/B0B,EAAMgP,SAAW,CACb5O,KAAW,wBACXC,KAAW,wBACXC,OAAW,IACXC,OAAWA,IAAM,KAAKyO,SAASC,CAAU,EACzC3Q,SAAW2Q,EAAW/O,UAGlC,CACAmkB,cAAe,CAAA,IAAAG,GACXA,EAAA,KAAK/mB,OAAOyR,eAAe,KAAKR,OAAOkC,MAAM,KAAC,MAAA4T,IAAA,QAA9CA,EAAgDhV,MAAK,CACzD,CACJ,CAnOI7R,EADiBolB,EACVjiB,QAAQ,YACfnD,EAFiBolB,EAEVhiB,OAAO,YACdpD,EAHiBolB,EAGVllB,eAAe,CAQlBslB,WAAa,sBAuBb7S,aAAe,CAAA,EASftQ,MAAQ,CAAA,EA6BRkL,aAAe,OAgBnBvN,EAxFiBolB,EAwFV/hB,eAAe,CAClBuC,OAAS,CAAC,UAAU,EACpBqG,MAAS,CAAC,iBAAkB,kBAAkB,IA2ItDmZ,EAAS7hB,UAAS,EAClB6hB,EAASjlB,OAAS,WC7OH,MAAM2mB,UAAiB/a,EAAgB,CAuGlD,WAAW1I,cAAe,CACtB,MAAM2I,EAAS,MAAM3I,aACrB2I,OAAAA,EAAOC,MAAMC,KAAK,kBAAkB,EAC7BF,CACX,CAEAG,YAAY9J,EAAO,CACf+J,OAAAA,EAAaC,aAAahK,EAAO,yBAAyB,EACnDA,CACX,CACAiK,mBAAmBiB,EAAc,CAC7BnB,OAAAA,EAAaI,eAAee,EAAc,gCAAgC,EACnEA,CACX,CAkDAwZ,mBAAmBtZ,EAAc,CAC7B,KAAKuZ,gBAAgB,cAAc,EAC/BvZ,GACA,KAAK3N,OAAO0mB,IAAI,CACZlU,KAAiB,eACjB,CAAC7E,CAAY,EAAI,iBACjBvM,QAAiB,IACrB,CAAC,CAET,CACAI,UAAUC,EAAS,CACf,MAAMD,UAAUC,CAAO,EACvB,CAAC,KAAK3B,eAAiB,KAAKE,OAAOC,UAAS,CAChD,CACAknB,eAAe,CAAEjkB,MAAAA,CAAM,EAAG,CACtB,KAAKkkB,wBAAwBlkB,CAAK,CACtC,CAOAmkB,YAAY7V,EAAY8V,EAAW,yBAA0B,CACzD,MACInG,EAAgB,KAAKnhB,OAAOyR,eAAeD,CAAU,EACrD+V,EAAgBpG,EAAcqG,cAAcF,CAAQ,EACpDG,EAAgB,CAAEjW,WAAAA,EAAY7P,aAAe,KAAK3B,OAAOiU,UAAUzC,CAAU,EAAG2P,cAAAA,GACpF,IAAIuG,EAAY,KACZH,IACAE,EAAYtG,cAAgBoG,EAC5BG,EAAY,CACRra,OAASka,IAGjB,KAAKja,gBAAgBma,EAAaC,CAAS,CAC/C,CACApa,gBAAgBma,KAAgB5nB,EAAM,CAC7B,KAAKG,OAAOmY,WAAWsP,EAAYjW,UAAU,GAC9C,KAAKxR,OAAOwd,WAAWiK,EAAYjW,UAAU,EAEjD,MAAMlE,gBAAgBma,EAAa,GAAG5nB,CAAI,CAC9C,CACAoN,iBAAiB/J,EAAO,CACpB,OAAOoJ,EAAaxG,OAAO,MAAMmH,iBAAiB/J,CAAK,EAAGA,EAAMgK,aAAa,CACjF,CACA4Z,iBAAiB,CAAEvkB,MAAAA,EAAOiP,WAAAA,CAAW,EAAG,CACpC,KAAM,CAAExR,OAAAA,EAAQa,SAAAA,CAAS,EAAI,KAC7B,GAAI,CAACb,EAAOyC,UAAY,CAAC5B,EAAU,CAAA,IAAAyI,EAC/B,KACI,CAAEsR,YAAAA,EAAaC,cAAAA,EAAejE,cAAAA,CAAc,EAAI5W,EAChD,CAAE8hB,cAAAA,EAAeuB,WAAAA,GAA+BrjB,EAAO+a,QACvD5C,EAAgDvB,EAAcC,SAASrF,CAAU,EACrFjP,EAAMiO,OAAS,CACX7N,KAAY,6BAA4BiY,IACxChY,KAAW,mCACXC,OAAW,IACXhC,SAAW2Q,EAAW/O,SACtBqK,KAAW9M,EAAO4B,QAAQ8G,IAAIif,IAAQ,CAClChZ,IAAcgZ,EAAIrX,GAClB3N,KAAc4d,EAAaC,WAAWmH,EAAIhlB,IAAI,EAC9CuM,IAAc,qBACd0Y,SAAc,GACdC,QAAcrW,EAAWqU,SAASjL,CAAW,IAAM+M,EAAIrX,GAEvDwX,YAAc,EAClB,EAAE,EACFhlB,OAAO,CAAE+L,KAAAA,CAAK,EAAG,CACTA,EAAK+Y,WACLpW,EAAWuW,SAASnN,EAAa/L,EAAKF,GAAG,EACzCE,EAAK5J,OAAO1C,MAAMwD,QAAQiiB,GAAW,CAC7BA,IAAYnZ,IACZmZ,EAAQH,QAAU,GAE1B,CAAC,EAET,IAEAve,EAAAtJ,EAAOwJ,aAAS,MAAAF,IAAA,QAAhBA,EAAkBlH,OAASyY,IAC3BtY,EAAMkE,SAAW,CACb9D,KAAW4d,EAAa0H,kCAAkCpN,IAC1DjY,KAAW,gCACXC,OAAW,IACXhC,SAAW2Q,EAAW/O,SACtBqK,KAAW9M,EAAOwJ,UAAUd,IAAIiS,IAAS,CACrChM,IAAcgM,EAAKrK,GACnB3N,KAAc4d,EAAaC,WAAW7F,EAAKhY,IAAI,EAC/CulB,WAAc,GACdL,QAAcrW,EAAWqU,SAAShL,CAAa,IAAMF,EAAKrK,GAE1DwX,YAAc,EAClB,EAAE,EACFhlB,OAAO,CAAE+L,KAAAA,CAAK,EAAG,CACTA,EAAKqZ,aACL1W,EAAWuW,SAASlN,EAAehM,EAAKF,GAAG,EAC3CE,EAAK5J,OAAO1C,MAAMwD,QAAQiiB,GAAW,CAC7BA,IAAYnZ,IACZmZ,EAAQH,QAAU,GAE1B,CAAC,EAET,IAGJ/F,EAAc1f,QACdG,EAAM2gB,UAAY,CACdvgB,KAAW,yBACXC,KAAW,wBACXC,OAAW,IACXhC,SAAW2Q,EAAW/O,SACtBqK,KAAWgV,EAAcpZ,IAAIyf,GAAY,CAAA,IAAAC,EACrC,MAAMC,GAAMD,EAAG,KAAK9G,mBAAe,MAAA8G,IAAA,OAAA,OAApBA,EAAsB7G,kBAAkB,CACnDN,eAAiBkH,EACjB3G,SAAiB2G,EAAS3G,SAC1BzO,MAAiBoV,EAASpV,MAC1B0O,QAAiB0G,EAAS1G,QAC1BC,SAAiByG,EAASzG,WAAc1hB,EAAO4hB,mBAAqB,KAAOuG,EAASxG,OAAS,GACjG,CAAC,EACD,MAAO,CACHhT,IAAOwZ,EAAS7X,GAChBpB,IAAO,uBACPvM,KAAO0lB,EAAS,CACZrjB,UAAY,6BACZkE,SAAY,CACRmf,EACA9H,EAAaC,WAAW2H,EAAS3V,IAAI,CAAC,GAE1C+N,EAAaC,WAAW2H,EAAS3V,IAAI,EACzC2V,SAAAA,EACAN,QAAcrW,EAAW0R,UAAUrM,SAASsR,CAAQ,EAEpDG,YAAcjF,EAAWC,qBAAuB,SAAW,KAEnE,CACA,EACAxgB,OAAO,CAAE+L,KAAAA,CAAK,EAAG,CACTA,EAAKsZ,UACL3W,EAAW3C,EAAKgZ,QAAU,SAAW,UAAU,EAAEhZ,EAAKsZ,QAAQ,CAEtE,IAGR5lB,EAAMgmB,WAAa,CACf5lB,KAAWwV,GAAcvB,EAAc1P,OAAS,EAAI,2BAA6B,0BACjFtE,KAAW,yBACXsM,IAAW,cACXrM,OAAW,IACXhC,SAAW2Q,EAAW/O,SACtBK,OAAWA,IAAM9C,EAAOuoB,WAAWpQ,EAAavB,EAAgBpF,CAAU,GAGtF,CACA,IAAIhE,UAAW,CACX,MAAO,EACX,CACAgb,kBAAkB3I,EAAO,CAAA,IAAA4I,GACrBA,EAAI,KAACnH,mBAAe,MAAAmH,IAAA,QAApBA,EAAsBlnB,QAAO,EACzBse,IACA,KAAKyB,gBAAkB,IAAIW,GAAgB,CACvCjc,QAAU,KAAKhG,OAAOgG,OAC1B,CAAC,EAET,CACJ,CAxUI9F,EADiB8mB,EACV3jB,QAAQ,YACfnD,EAFiB8mB,EAEV1jB,OAAO,YACdpD,EAHiB8mB,EAGV5mB,eAAe,CAkClBqN,aAAe,KAyBflL,MAAQ,KACRe,KAAO,OAOPqK,aAAe,kBAiBf+a,YAAc,CACV7I,MAAU,GACVyC,QAAU,WAEdxV,KAAO,CACHS,MAAS,UACTG,OAAS,EACb,IA6ORlO,EAAiBoO,SAASoZ,EAAS1jB,KAAM0jB,CAAQ,EACjDA,EAAS3mB,OAAS,WCrcH,MAAMsoB,UAAoBnpB,CAAiB,CAwDtDopB,eAAeC,EAAU,CACrBvc,OAAAA,EAAaI,eAAemc,EAAU,+BAA+B,EAC9DA,CACX,CAEArnB,UAAUC,EAAS,CACf,MAAMD,UAAUC,CAAO,EACnB,KAAKqnB,WACL,KAAKjY,QAAQhQ,SAAWY,EAEhC,CACAsnB,cAAclY,EAASmY,EAAY,CAC/B,MACIxoB,EAAa,KACb,CAAER,OAAAA,CAAO,EAAIQ,EAGjB,GAFA8L,EAAaC,aAAasE,EAAS,8BAA8B,EACjEmY,GAAU,MAAVA,EAAYznB,QAAO,EACfsP,EACA,OAAO,IAAIoY,GAAQ3c,EAAaxG,OAAO,CACnCojB,SAAiB,WACjBha,IAAiB,sBACjBia,YAAiB,+DACjBhX,aAAiB,UACjBiX,WAAiBppB,EAAOgG,QACxBqjB,YAAiB,GACjBC,WAAiB,EACjBC,UAAiB,IACjBC,eAAiB,GACjBC,UAAiB7U,GAAQpU,EAAG0L,OAAO3J,OAAS/B,EAAG0L,OAAOwd,OACtDC,QAAiBnpB,EAAGopB,WAAWC,KAAKrpB,CAAE,EACtCK,SAAiBL,EAAGK,SACpBipB,YAAiB,IAClBjZ,CAAO,CAAC,CAEnB,CACA+Y,WAAW,CAAEG,IAAAA,EAAKC,aAAAA,CAAa,EAAG,CAC9B,KACI,CAAEhqB,OAAAA,CAAO,EAAQ,KACjBwR,EAAiBxR,EAAO0W,kBAAkBsT,CAAY,EACtDroB,EAAiB3B,EAAOqI,oBAAoB2hB,CAAY,EACxDzgB,EAAiBvJ,EAAOmV,sBAAsB6U,CAAY,EAC9D,GAAI,KAAKnB,SACL,OAAO,KAAKA,SAAS,CAAEkB,IAAAA,EAAKvY,WAAAA,EAAY7P,aAAAA,EAAc4H,eAAAA,EAAgBygB,aAAAA,CAAa,CAAC,EAExF,MAAM9gB,EAAW,CACb,CACI8D,MAAQ,4BACRrK,KAAQ6O,EAAWgB,IACvB,EACA,CACIxF,MAAQ,4BACRrK,KAAQ4d,EAAa6C,WAAWpjB,EAAO4a,WAAW,CACtD,EACA,CACI5N,MAAQ,4BACRrK,KAAQhB,EAAagB,IACzB,CAAC,EAEL,OAAI4G,GACAL,EAASkD,KACL,CACIY,MAAQ,4BACRrK,KAAQ4d,EAAa6C,WAAWpjB,EAAO6a,aAAa,CACxD,EACA,CACI7N,MAAQ,4BACRrK,KAAQ4G,EAAe5G,IAC3B,CACJ,EAEA6O,EAAW0R,UAAUhc,QACrBgC,EAASkD,KACL,CACIY,MAAQ,4BACRrK,KAAQ,KAAKsnB,EAAE,wBAAwB,CAC3C,EACA,CACIjd,MAAQ,4BACRrK,KAAQ6O,EAAW0R,UAAUxa,IAAIuY,GAAkBA,EAAezO,IAAI,EAAE0X,KAAK,IAAI,CACrF,CACJ,EAEG,CACHhhB,SAAAA,EAER,CACAihB,QAAS,CAEL,KAAKC,UAAU,SAAS,CAC5B,CACJ,CAjJIlqB,EADiByoB,EACVtlB,QAAQ,eACfnD,EAFiByoB,EAEVrlB,OAAO,eACdpD,EAHiByoB,EAGVvoB,eAAe,CAoBlByQ,QAAU,CACNgP,MAAQ,CAAA,EAERyC,QAAU,CAAC,OAAQ,SAAS,GAwBhCuG,SAAW,OAEf3oB,EApDiByoB,EAoDVplB,eAAe,CAClB4I,MAAQ,CAAC,QAAQ,IA8FzBwc,EAAYllB,UAAS,EACrBklB,EAAYtoB,OAAS,cCjJN,MAAMgqB,WAAoBC,EAAM,CAoI3C,IAAIrP,OAAQ,CACR,OAAO,KAAK5W,UAAUkmB,eAAe,KAAM,EAAI,CACnD,CACA,IAAIlmB,WAAY,CACZ,OAAO,KAAKmmB,WAAWnmB,SAC3B,CASA,MAAMomB,UAAW,CACb,OAAO,KAAKpmB,UAAUomB,SAAS,IAAI,CACvC,CASA,MAAMC,QAAS,CACX,OAAO,KAAKrmB,UAAUqmB,OAAO,IAAI,CACrC,CACJ,CA/JIxqB,EADiBmqB,GACVhnB,QAAQ,eACfnD,EAFiBmqB,GAEVM,SAAS,CAUZ,OAKA,UAoEA,CAAEnY,KAAO,QAASlP,KAAO,UAMzB,cAKA,CAAEkP,KAAO,cAAelP,KAAO,UAAWsnB,aAAe,IASzD,CAAEpY,KAAO,YAAalP,KAAO,WAK7B,CAAEkP,KAAO,SAAUlP,KAAO,WAK1B,CAAEkP,KAAO,QAASlP,KAAO,UAKzB,CAAEkP,KAAO,OAAQlP,KAAO,UAKxB,CAAEkP,KAAO,WAAYlP,KAAO,QAAS,CAAC,GAoC9C+mB,GAAYhqB,OAAS,cCpHN,MAAMwqB,UAAkBC,EAAW,CAsHlD,CArHI5qB,EADiB2qB,EACVxnB,QAAQ,aACfnD,EAFiB2qB,EAEVF,SAAS,CAMZ,SAMA,OAMA,cA8EA,aAUA,CAAEnY,KAAO,SAAUlP,KAAO,UAQ1B,CAAEkP,KAAO,WAAYlP,KAAO,SAAU,CAAC,GAG/CunB,EAAUxqB,OAAS,YCvIJ,MAAM0qB,WAAkBC,EAAW,CAmC9CC,eAAgB,CACZ,KAAM,CAAEC,QAAAA,CAAQ,EAAI,KACpB,GAAI,KAAKC,kBAAoB,CAACD,EAAQlV,KAAKqB,GAAKA,EAAExU,QAAU,IAAI,EAC5D,QAASoD,EAAI,EAAGA,EAAIilB,EAAQhkB,OAAQjB,IAChCilB,EAAQjlB,CAAC,EAAEmlB,QAAQ,UAAWnlB,EAAI,GAAK,GAAG,CAGtD,CACJ,CA1CI/F,EADiB6qB,GACV3qB,eAAe,CAClB+qB,iBAAmB,GACnBE,QAAU,QAOVC,WAAaT,EAYbU,sBAAwB,GASxBC,QAAU,CACN,CAAE1Z,MAAQ,SAAU2Z,UAAY,GAAM,IAYlDV,GAAU1qB,OAAS,YClCJ,MAAMqrB,WAAqBC,GAAsBjsB,MAAMksB,EAAkB,CAAE,CA2EtFC,UAAU3f,EAAQ,CACVA,EAAO+O,QACP/O,EAAO4f,WAAa5f,EAAO+O,OAE3B/O,EAAO6f,YACP7f,EAAO4f,WAAa5f,EAAO6f,WAE3B7f,EAAO4O,YACP5O,EAAOmX,WAAanX,EAAO4O,WAE3B5O,EAAO8f,iBACP9f,EAAO+f,gBAAkB/f,EAAO8f,gBAEhC9f,EAAOggB,iBACPhgB,EAAOigB,gBAAkBjgB,EAAOggB,gBAEpC,MAAML,UAAU3f,CAAM,EACtB,MAAM1L,EAAK,KACXA,EAAG4rB,oBAAoB5rB,EAAG6rB,eAAe,EACzC7rB,EAAG4rB,oBAAoB5rB,EAAGshB,aAAa,EACvCthB,EAAG4rB,oBAAoB5rB,EAAGsa,SAAS,CACvC,CACA,IAAIA,WAAY,CACZ,OAAO,KAAKuI,UAChB,CACA,IAAIvI,UAAUwR,EAAO,CACjB,KAAKjJ,WAAaiJ,CACtB,CACA,IAAIP,WAAY,CACZ,OAAO,KAAKD,UAChB,CACA,IAAIC,UAAUQ,EAAM,CAChB,KAAKT,WAAaS,CACtB,CACA,IAAItR,OAAQ,CACR,OAAO,KAAK6Q,UAChB,CACA,IAAI7Q,MAAMsR,EAAM,CACZ,KAAKT,WAAaS,CACtB,CAmCAC,QAAS,CACL,KACI,CAAE1R,UAAAA,EAAWuR,gBAAAA,EAAiBvK,cAAAA,CAAc,EAAI,KAChDha,EAAS,CACLikB,UAAYjR,EAAU0R,OAAM,GAEpC,OAAIH,GAAAA,MAAAA,EAAiBjqB,QACjB0F,EAAO2kB,gBAAkBJ,EAAgBG,OAAM,GAE/C1K,GAAAA,MAAAA,EAAe1f,QACf0F,EAAO4kB,cAAgB5K,EAAc0K,OAAM,GAExC1kB,CACX,CACJ,CAlKI5H,EADiBwrB,GACVtrB,eAAe,CAsDlB+rB,gBAAkBpB,GAClBkB,gBAAkBpB,EAQlBqB,eAAiBnB,GASjBiB,eAAiBnB,IA2FzBa,GAAarrB,OAAS,eC3MP,MAAMssB,WAAsBrC,EAAM,CAsH7C,IAAIjmB,WAAY,CACZ,OAAO,KAAKmmB,WAAWnmB,SAC3B,CASA,MAAMomB,UAAW,CACb,KAAKpmB,UAAUomB,SAAS,IAAI,CAChC,CASA,MAAMC,QAAS,CACX,OAAO,KAAKrmB,UAAUqmB,OAAO,IAAI,CACrC,CAMA,IAAIzP,OAAQ,CACR,MAAO,CAAC,GAAI,KAAK5W,UAAUuoB,iBAAiB,IAAI,GAAK,CAAA,CAAG,CAC5D,CACJ,CAtJI1sB,EADiBysB,GACVtpB,QAAQ,iBACfnD,EAFiBysB,GAEVhC,SAAS,CAUZ,CAAEnY,KAAO,OAAQlP,KAAO,UAoExB,CAAEkP,KAAO,QAASlP,KAAO,UAKzB,CAAEkP,KAAO,cAAelP,KAAO,UAAWsnB,aAAe,IAUzD,CAAEpY,KAAO,YAAalP,KAAO,WAK7B,CAAEkP,KAAO,SAAUlP,KAAO,WAK1B,CAAEkP,KAAO,SAAUlP,KAAO,UAK1B,CAAEkP,KAAO,OAAQlP,KAAO,UAMxB,aAAa,GAoCrBqpB,GAActsB,OAAS,gBC7IvB,IAAAwsB,GAAe/N,GAAM,OAAI,OAAAC,EAAA,cAA8BD,GAAUpb,EAAM,CAiCnE,IAAIopB,aAAc,CAAA,CAGlBC,2BAA2BC,EAAsB,CAC7C1gB,OAAAA,EAAagF,cAAc0b,EAAsB,sBAAsB,EAChEA,CACX,CAeA,MAAMvC,SAAStX,EAAQ,CACnB,OAAO,KAAK8Z,eAAe9Z,EAAQ,EAAI,CAC3C,CAaA,MAAMuX,OAAOvX,EAAQ,CACjB,OAAO,KAAK8Z,eAAe9Z,EAAQ,EAAK,CAC5C,CAmBA,MAAM8Z,eAAe9Z,EAAQsX,EAAW,CAACtX,EAAO+Z,UAAW,CACnD/Z,EAAOga,gBACP,MAAM,KAAKC,uBAAuBja,EAAQsX,CAAQ,EAGlD,MAAM,KAAK4C,qBAAqBla,EAAQsX,CAAQ,CAExD,CACA,MAAM2C,uBAAuB7jB,EAAgBkhB,EAAW,CAAClhB,EAAe2jB,UAAW,CAC/E,OAAO,IAAIniB,QAAQC,GAAW,CAC1B,MACIxK,EAAkB,KAClB4U,EAAkB5U,EAAGmJ,mBAAmBJ,CAAc,EACtDG,EAAkB9C,EAAQC,SAASuO,EAAiB,MAAM,EAE1DqV,IACA/gB,EAAaxE,MAAMqB,OAAU,GAAEmD,EAAajE,sBAAqB,EAAGc,YAExE7B,EAAY6G,gBAAgB,CACxBvF,QAAW0D,EACX8B,SAAW,SACXC,SAAU,CAEDgf,IACD/gB,EAAaxE,MAAMqB,OAAS,IAEhC6O,EAAgB3N,UAAU2B,OAAOqhB,EAAW,eAAiB,aAAa,EAE1EjqB,EAAGP,UAAUqtB,MAAK,EAClBtiB,EAAO,GAEX5J,QAAUZ,CACd,CAAC,EACD4U,EAAgB3N,UAAUC,IAAI+iB,EAAW,eAAiB,aAAa,EACvEjqB,EAAG0K,qBAAoB,EAEvB3B,EAAe2jB,UAAYzC,EAC3BjqB,EAAG2K,oBAAmB,CAC1B,CAAC,CACL,CACA,MAAMkiB,qBAAqB1rB,EAAc8oB,EAAW,CAAC9oB,EAAaurB,UAAW,CACzE,OAAO,IAAIniB,QAAQC,GAAW,CAAA,IAAAuiB,EAAAC,EAC1B,MACIhtB,EAAmB,KACnB,CAAE0J,aAAAA,CAAa,EAAI1J,EACnBitB,EAAmBjtB,EAAGoF,kBAAkBjE,CAAY,EACpD+rB,EAAmB9mB,EAAQC,SAASrG,EAAG0H,YAAc,UAASvG,EAAa8H,OAAO,EAElFkkB,EAAmBhsB,EAAa6D,OAAS,CAAC7D,EAAa4F,KACvDqmB,EAAmB1jB,EAAasJ,iBAAkB,kCAAiC7R,EAAa8H,SAAS,EACzGokB,EAAoB,IAAAN,EAAEK,EAAa,CAAC,KAAC,MAAAL,IAAA,OAAA,OAAfA,EAAiB9nB,sBAAqB,EAAGD,UAC/DsoB,EAAoB,IAAAN,EAAEC,EAAe,CAAC,KAAC,MAAAD,IAAA,OAAA,OAAjBA,EAAmB/nB,sBAAqB,EAAGD,UAErEooB,EAAa7nB,QAAQwU,GAAQ,CACrBkQ,IACAlQ,EAAKrV,MAAMM,MAAQqoB,EAE3B,CAAC,EACDJ,EAAeM,QAAQL,CAAa,EACpCD,EAAe1nB,QAAQC,GAAW,CAE1BykB,GACKkD,IACD3nB,EAAQd,MAAMM,MAAQsoB,GAE1B9nB,EAAQyB,UAAUC,IAAI,cAAc,GAIpC1B,EAAQyB,UAAUC,IAAI,aAAa,CAE3C,CAAC,EACDhD,EAAY6G,gBAAgB,CACxBvF,QAAW0nB,EACXliB,SAAW,QACXC,SAAU,CAENmiB,EAAa7nB,QAAQwU,GAAQ,CACpBkQ,IACDlQ,EAAKrV,MAAMM,MAAQ,GAE3B,CAAC,EAEDioB,EAAe1nB,QAAQC,GAAW,CACzBykB,EAQDzkB,EAAQyB,UAAU2B,OAAO,cAAc,GANlCukB,IACD3nB,EAAQd,MAAMM,MAAQ,IAE1BQ,EAAQyB,UAAU2B,OAAO,aAAa,EAK9C,CAAC,EAED5I,EAAGP,UAAUqtB,MAAK,EAElB9sB,EAAG4hB,WAAW4L,kBAAiB,EAC/BhjB,EAAO,GAEX5J,QAAUZ,CACd,CAAC,EAEDktB,EAAcxR,YACd1b,EAAG0K,qBAAoB,EAEvBvJ,EAAaurB,UAAYzC,EACzBjqB,EAAG2K,oBAAmB,CAC1B,CAAC,CACL,CAIAwB,qBAAqB9M,EAAM,CAAA,IAAAouB,GACvBA,EAAA,MAAMthB,wBAAoBshB,MAAAA,IAA1BA,QAAAA,EAAAhf,KAA6BpP,KAAAA,CAAI,EACjC,KACI,CAAEmtB,qBAAAA,EAAsBkB,cAAAA,EAAeC,aAAAA,EAAcC,oBAAAA,CAAoB,EAAI,KAC7E,CAAEzsB,aAAAA,EAAciL,mBAAAA,CAAmB,EAA0C/M,EAC7E,CAAE8C,KAAAA,EAAMuqB,UAAAA,EAAWmB,YAAAA,CAAY,EAA8C1sB,EACjFmD,EAAUgK,MAAMlC,EAAoB,CAChCI,MAAQ,CACJ,cAAmBkgB,EACnB,iBAAmBA,GAAa,CAACgB,GAAiB,CAACC,GAEvDjlB,SAAW,CACP2D,OAAS,CACL3D,SAAW,CACPolB,SAAWtB,GAAwBqB,GAAe,CAC9CthB,IAAQ,SACRC,MAAQ,CACJ,8BAAgC,EAChC,YAAgC,EAChC,uBAAgC,GAEpCsC,QAAU,CACNuS,KAAOuM,EACD7N,EAAa0H,MAAM,KAAKgC,EAAEiD,EAAY,sBAAwB,wBAAyBvqB,CAAI,IAC3F,IACV,CACJ,CACJ,CACJ,CACJ,CACJ,CAAC,CACL,CAEA+M,eAAe7P,EAAM,CAAA,IAAA0uB,GACjBA,EAAA,MAAM7e,kBAAc6e,MAAAA,IAApBA,QAAAA,EAAAtf,KAAuBpP,KAAAA,CAAI,EAC3B,KACI,CAAE8B,aAAAA,EAAcgO,aAAAA,CAAa,EAAI9P,EACjC,CAAEqtB,UAAAA,CAAU,EAAqBvrB,EACrCgO,EAAa3C,MAAM,aAAa,EAAIkgB,CACxC,CAEAsB,iBAAiB3uB,EAAM,CAAA,IAAA4uB,GACnBA,EAAA,MAAM/e,kBAAc+e,MAAAA,IAApBA,QAAAA,EAAAxf,KAAuBpP,KAAAA,CAAI,EAC3B,KAAM,CAAE0J,eAAAA,EAAgBmlB,eAAAA,CAAe,EAAI7uB,EAC3C,GAAI0J,EAAgB,CAChB,KACI,CAAEyjB,qBAAAA,EAAsBoB,oBAAAA,CAAoB,EAAI,KAChD,CAAEzrB,KAAAA,EAAMuqB,UAAAA,EAAWmB,YAAAA,CAAY,EAAiB9kB,EACpDzE,EAAUgK,MAAM4f,EAAgB,CAC5B1hB,MAAQ,CACJ,cAAkBkgB,EAClB,gBAAkBmB,GAEtBnlB,SAAW,CACPvC,OAAS,CACLuC,SAAW,CACP6b,MAAQ,CACJ7b,SAAW,CAEP,kBAAoB8jB,GAAwBqB,GAAe,CACvDthB,IAAQ,SACRC,MAAQ,CACJ,gCAAkC,EAClC,SAAkC,EAClC,oBAAkC,GAEtCsC,QAAU,CACNuS,KAAOuM,EACD7N,EAAa0H,MAAM,KAAKgC,EAAEiD,EAAY,sBAAwB,wBAAyBvqB,CAAI,IAC3F,IACV,CACJ,CACJ,CACJ,CACJ,GAEJmE,KAAO,CACH,CAAComB,EAAY,QAAU,IAAI,EAAI,EACnC,CACJ,CACJ,CAAC,EAET,CAGA9f,oBAAoB,CAAElK,MAAAA,EAAOvB,aAAAA,CAAa,EAAG,EACrCuB,EAAMmK,OAAO7G,QAAQ,8BAA8B,GAAK7E,EAAaurB,YACrE,KAAKD,eAAetrB,CAAY,CAExC,CACAgtB,cAAc,CAAEhtB,aAAAA,CAAa,EAAG,CACxBA,EAAaurB,WACb,KAAKD,eAAetrB,CAAY,CAExC,CACAitB,sBAAsB,CAAErlB,eAAAA,CAAe,EAAG,CACtC,KAAK0jB,eAAe1jB,CAAc,CACtC,CAEJ,EA7SIrJ,EAFqB6e,EAEd1b,QAAQ,kBACfnD,EAHqB6e,EAGd3e,eAAe,CAUlB4sB,qBAAuB,GAUvBkB,cAAgB,GAQhBE,oBAAsB,KA/BLrP,GCGzB8P,GAAe/P,GAAM,OAAI,OAAAC,EAAA,cAA+BD,GAAUpb,EAAM,CAA/C,kCAiErBorB,EAAAA,+BAA0B,GAT1B,IAAIhC,aAAc,CAAA,CAGlBiC,gBAAgBC,EAAW,CACvB1iB,OAAAA,EAAa2iB,YAAYD,EAAW,WAAW,EACxCA,CACX,CAIA1mB,uBAAwB,CACpB,KAAKwmB,yBACT,CACA1jB,sBAAuB,CACnB,KAAK0jB,yBACT,CAIAI,YAAYvtB,EAAc4H,EAAgB,CACtC,MACI/I,EAAgB,KAChB,CAAEwuB,UAAAA,CAAU,EAAIxuB,EAChB2uB,EAAgB3uB,EAAG4uB,eAAeztB,EAAc4H,CAAc,EAC9DukB,EAAgBttB,EAAGmZ,eAAehY,CAAY,EAM9CksB,GAAiBC,EAActtB,EAAG4Y,SAAW+V,EAAS,IAAMA,EAChE,OAAOH,GAAAA,KAAAA,OAAAA,EAAWK,KAAKC,GAAQzB,EAAYyB,EAAKC,QAAQ,KAAKP,GAAS,KAAA,OAATA,EAAYA,EAAU9nB,OAAS,CAAC,EACjG,CAEAyS,eAAehY,EAAc,CACzB,OAAOA,EAAa6W,aAAa,IAAI,EAAEhT,KAC3C,CAGA4pB,eAAeztB,EAAc4H,EAAgB,CACzC,OAAO5H,EAAawX,cAAe5P,GAAAA,KAAAA,OAAAA,EAAgB4P,cAAe,KAAKA,WAC3E,CAIAqW,cAAcC,EAAS,CACnB,MAAMjvB,EAAK,KACX,GAAIA,EAAGP,UAAUyvB,WAAalvB,EAAGsuB,wBAC7B,OAIJ,IAAIa,EAAkB,GACtB,UAAWC,KAASH,EAAS,CACzB,KAAM,CAAEpiB,OAAAA,EAAQwiB,YAAAA,CAAY,EAAID,EAEhC,GAAIviB,EAAOyiB,gBAAkBD,EAAYrqB,MAAO,CAC5C,MACI7D,EAAiBnB,EAAG6H,oBAAoBgF,CAAM,EAE9CogB,EAAiB9rB,GAAgBnB,EAAGoB,QAAQiV,SAASlV,CAAY,GAAKnB,EAAGoF,kBAAkBjE,CAAY,EAG3G,GAAI,CAACA,GAAgBA,EAAaurB,WAAavrB,EAAa+hB,QAAU,CAAC+J,EACnE,OAGJ9rB,EAAa6W,aAAahY,CAAE,EAAEgF,MAAQ6H,EAAOyiB,cAAgBD,EAAYrqB,MACzE,UAAWuT,KAAiB0U,EAAgB,CACxC,MACIlkB,EAAiB/I,EAAG2U,sBAAsB4D,CAAa,EACvDgX,EAAiBvvB,EAAG0uB,YAAYvtB,EAAc4H,CAAc,EAE5DwmB,GAAYhX,EAAcpQ,YAAYonB,WAAaA,EAASvd,OAC5Dmd,EAAkB,MAK9BA,IACAnvB,EAAGP,UAAU+vB,IAAG,EAChBxvB,EAAG4hB,WAAW4L,kBAAiB,EAEvC,CAEAiC,qBAAqBC,EAAUC,EAAa,CACxCA,OAAAA,GAAW,MAAXA,EAAaC,WAAU,EAEhB,KAAKrwB,cAAgB,CAACswB,eAAiB,KAAO,IAAIA,eAAe,KAAKb,cAAc3F,KAAK,IAAI,CAAC,CACzG,CAGAna,eAAe7P,EAAM,CAAA,IAAAouB,GACjBA,EAAA,MAAMve,kBAAcue,MAAAA,IAApBA,QAAAA,EAAAhf,KAAuBpP,KAAAA,CAAI,EAC3B,KACI,CAAE8B,aAAAA,EAAc4H,eAAAA,EAAgBoG,aAAAA,CAAa,EAAI9P,EAEjDkwB,EAAWlwB,EAAKkwB,SAAiC,KAAKb,YAAYvtB,EAAc4H,CAAc,EAC9FwmB,IACApgB,EAAa3C,MAAO,KAAI+iB,EAASvd,YAAY,EAAIud,EACjDpgB,EAAahH,YAAYonB,SAAWA,EAASvd,KAErD,CAEJ,EA9JItS,EAFqB6e,EAEd1b,QAAQ,mBACfnD,EAHqB6e,EAGd3e,eAAe,CAiBlB4uB,UAAY,CACR,CACIO,SAAc,GACd/c,KAAc,QACd8d,WAAc,EACdC,YAAc,CACV5tB,KAAO,MAEX6tB,UAAY,CACR7tB,KAAO,IACX,CACJ,EACA,CACI4sB,SAAa,GACb/c,KAAa,OACb8d,WAAa,EACbE,UAAa,CACT7tB,KAAO,IACX,CACJ,EACA,CACI4sB,SAAa,IACb/c,KAAa,QACb8d,WAAa,EACbE,UAAa,CACT7tB,KAAO,IACX,CACJ,EACA,CAAE4sB,SAAW,IAAK/c,KAAO,SAAU8d,WAAa,CAAE,EAClD,CAAE9d,KAAO,QAAS8d,WAAa,CAAE,CAAC,EAEtCG,eAAiB,CACb5Q,MAAU,GACVyC,QAAU,CAAC,SAAS,CACxB,IAtDiBvD,GCtCzB,MAAM2R,GAA0B,CAC5BtnB,OAAS,EACTvH,KAAS,EACT8uB,OAAS,EACT7Z,OAAS,CACb,EAMA,IAAA8Z,GAAe9R,GAAM,OAAI,OAAAC,EAAA,cAAgCD,GAAUpb,EAAM,CAuHrE,IAAIopB,aAAc,CAAA,CAGlB+D,0BAA0BC,EAAqB,CAC3CxkB,OAAAA,EAAagF,cAAcwf,EAAqB,qBAAqB,EAC9DA,CACX,CACAC,kBAAkBnW,EAAa,CAC3BtO,OAAAA,EAAaqZ,aAAa/K,EAAa,aAAa,EAC7CA,CACX,CAGAoW,kBAAkBlf,EAAOkQ,EAAK,CAC1B,GAAIA,EAAK,CACL,KAAM,CAAEiP,QAAAA,CAAQ,EAAI,KAAKlW,QAAQD,UAC7BkH,IAAQ,KAAKnH,eACboW,EAAQC,YAAYlP,CAAG,EAE3BiP,EAAQE,SAAS,CAAE3lB,SAAWsG,EAAOsf,OAAS,EAAM,CAAC,EAEzD,KAAKC,0BAA4Bvf,GAAS,KAAKgf,mBACnD,CAGAQ,cAAc1vB,EAAS,CACnB,OAAO2vB,GAAM/sB,KAAK5C,EAAS,CAAE4vB,UAAY,GAAMlG,WAAajB,IAAe7Z,GACnE,OAAOA,GAAW,SACX,CAAEF,GAAKE,EAAQ7N,KAAO4d,EAAa6C,WAAW5S,CAAM,GAExDA,CACV,CACL,CACAihB,cAAc7vB,EAAS,CACnB,KAAKslB,gBAAgB,SAAS,EAC1BtlB,KAGCA,EAAQ8vB,QAAU9vB,GAASyC,UAAY,KACxCzC,EAAQ8kB,IAAI,CACR1X,OAAU,kBACV2iB,QAAU,kBACVvwB,QAAU,IACd,CAAC,EAET,CACA,IAAIQ,SAAU,CACV,MACIpB,EAAgB,KAChB,CAAEsa,UAAAA,GAActa,EAAGua,QAGvB,OAAIva,EAAG6wB,2BAA6BvW,EAAU1Y,QAC1C5B,EAAGoB,QAAUkZ,EAAU8W,kBAAkBpxB,EAAGoa,WAAW,EAAE5D,KAAI,EAC7DxW,EAAG6wB,0BAA4B,IAE5B7wB,EAAGqxB,QACd,CACAC,gBAAgB,CAAEC,OAAAA,CAAO,EAAG,CAKxB,IAHIA,IAAW,OAASA,IAAW,UAAYA,IAAW,aAAeA,IAAW,WAChF,KAAKhX,QAAQD,UAAUmW,QAAQe,kBAAiB,EAEhDtB,GAAwBqB,CAAM,EAAG,CACjC,MAAME,EAAU,CAAA,GACZF,IAAW,UAAYA,IAAW,YAClCE,EAAQC,cAAgB,CAAE1sB,MAAQ,EAAG2sB,QAAU,GAC/CF,EAAQG,iBAAmB,CAAE5sB,MAAQ,EAAG2sB,QAAU,IAEtD,KAAKE,2BAA2BJ,CAAO,OAGvC,KAAKhyB,UAAS,CAEtB,CAGAsqB,eAAe5oB,EAAc2wB,EAAgB,GAAO,CAChD,MACI9xB,EAAgB,KAChB,CAAEsa,UAAAA,GAActa,EAAGua,QACnBtL,EAAgBqL,EAAUmW,QAAQsB,SAAS/xB,EAAGoa,YAAajZ,EAAa2O,EAAE,EAC1E2K,EAAgBxL,EAAM,CAAC,GAAGA,CAAG,EAAI,CAAA,EACrC,GAAI6iB,GAAiB7iB,EACjB,GAAIjP,EAAGgJ,UAAW,CACd,KACI,CAAEqR,cAAAA,CAAc,EAAIra,EACpBgJ,EAAoBhJ,EAAGgJ,UAAUd,IAAI2O,GAAKA,EAAE/G,EAAE,EAelD,GAdA2K,EAAMjE,KAAK,CAACC,EAAGC,IAAM,CAEjB,MAAMsb,EAAgBhpB,EAAUrH,QAAQ8U,EAAE4D,CAAa,CAAC,EAAIrR,EAAUrH,QAAQ+U,EAAE2D,CAAa,CAAC,EAC9F,OAAI2X,IAAkB,EACXA,EAGPvb,EAAEpU,QAAU,MAAQqU,EAAErU,QAAU,KACzBoU,EAAEpU,OAASqU,EAAErU,OAGjBiY,EAAU3Y,QAAQ8U,CAAC,EAAI6D,EAAU3Y,QAAQ+U,CAAC,CACrD,CAAC,EAEG1N,EAAUtC,QAAU2T,EACpB,OAAOI,EAAMnE,OAAOqE,GAAQ3R,EAAUqN,SAASsE,EAAKN,CAAa,CAAC,CAAC,OAKvEI,EAAMjE,KAAK,CAACC,EAAGC,IAAMD,EAAEpU,OAASqU,EAAErU,MAAM,EAGhD,OAAOoY,CACX,CACAhH,UAAUzC,EAAY,CAClB,OAAO,KAAK5P,QAAQgkB,QAAQpU,EAAWqU,SAAS,KAAKjL,WAAW,CAAC,CACrE,CAEA5G,YAAYxC,EAAYihB,EAAO,GAAM,CACjC,MACI9wB,EAAe,KAAKsS,UAAUzC,CAAU,EACxCkhB,EAAe/wB,EAAasZ,MAChC,IAAI0X,EAAgBD,EAAYvwB,QAAQqP,CAAU,EAAI,EACtD,GAAImhB,IAAkBD,EAAYxrB,OAC9B,GAAIurB,EACAE,EAAgB,MAGhB,QAAO,KAGf,OAAOD,EAAYC,CAAa,CACpC,CAEAhf,gBAAgBnC,EAAYihB,EAAO,GAAM,CACrC,MACI9wB,EAAe,KAAKsS,UAAUzC,CAAU,EACxCkhB,EAAe/wB,EAAasZ,MAChC,IAAI2X,EAAgBF,EAAYvwB,QAAQqP,CAAU,EAAI,EACtD,GAAIohB,EAAgB,EAChB,GAAIH,EACAG,EAAgBF,EAAYxrB,OAAS,MAGrC,QAAO,KAGf,OAAOwrB,EAAYE,CAAa,CACpC,CAEJ,EA1QI1yB,EAFqB6e,EAEd1b,QAAQ,oBACfnD,EAHqB6e,EAGd3e,eAAe,CAmDlBwB,QAAU,CAAA,EAyBVkvB,oBAAsB,GAmCtBlW,YAAc,OAElB1a,EApHqB6e,EAoHd8T,aAAa,CAChBxB,0BAA4B,KArHXtS,GCAzB+T,GAAehU,GAAM,OAAI,OAAAC,EAAA,cAA4BD,GAAUpb,EAAM,CAGjE,IAAIopB,aAAc,CAAA,CAelBpW,kBAAkB1Q,EAAS,CAAA,IAAA+sB,EACvB/sB,OAAAA,EAAUA,EAAQU,QAAQ,mBAAmB,EAEtCV,GAAW,KAAK+U,QAAQD,UAAU8K,SAAOmN,EAAC/sB,EAAQ2C,eAAW,MAAAoqB,IAAnBA,OAAAA,OAAAA,EAAqB1X,MAAM,CAChF,CAaAhT,oBAAoBrC,EAAS,CAAA,IAAAgtB,EACzBhtB,OAAAA,EAAUA,EAAQU,QAAQ,iDAAiD,EAEpEV,GAAW,KAAKpE,QAAQgkB,SAAOoN,EAAChtB,EAAQ2C,eAAWqqB,MAAAA,IAAA,OAAA,OAAnBA,EAAqBhjB,QAAQ,CACxE,CAaAmF,sBAAsBnP,EAAS,CAAA,IAAAitB,EAC3BjtB,OAAAA,EAAUA,EAAQU,QAAQ,uBAAuB,EAC1CV,KAAOitB,EAAI,KAAKzpB,aAASypB,MAAAA,IAAA,OAAA,OAAdA,EAAgBrN,QAAQ5f,EAAQ2C,YAAYuqB,MAAM,EACxE,CAcAzhB,eAAeD,EAAY,CACvB,MAAM2hB,EAAoB,KAAKC,qBAAqB5hB,CAAU,EAC9D,OAAO2hB,GAAqBvsB,EAAQC,SAASssB,EAAoB,cAAa3hB,EAAW/H,OAAO,CACpG,CAYA2pB,qBAAqB5hB,EAAY,CAC7B,MAAM7P,EAAe,KAAKC,QAAQgkB,QAAQpU,EAAWqU,SAAS,KAAKjL,WAAW,CAAC,EAC/E,OAAOjZ,GAAgBiF,EAAQC,SAAS,KAAKwsB,uBAAuB7hB,CAAU,EAAI,QAAO7P,EAAa8H,OAAO,CACjH,CAYA4pB,uBAAuB7hB,EAAY,CAAA,IAAA8hB,EAAAC,EAE/B,MAAML,GAASI,EAAA,KAAK9pB,aAAS,MAAA8pB,IAAA,QAAdA,EAAgBlxB,OAAKmxB,EAC9B,KAAK/pB,UAAUoc,QAAQpU,EAAWqU,SAAS,KAAKhL,aAAa,CAAC,KAAC,MAAA0Y,IAAA,OAAA,OAA/DA,EAAiE9pB,MACjE,UACN,OAAO7C,EAAQC,SAAS,KAAKqB,YAAagrB,CAAM,CACpD,CAYAvpB,mBAAmBJ,EAAgB,CAE/B,OAAO3C,EAAQC,SAAS,KAAKqB,YAAaqB,EAAeE,KAAK,CAClE,CAaA+pB,yBAAyBjqB,EAAgB5H,EAAc,CAEnD,OAAI4H,EAEO3C,EAAQC,SAAS,KAAK8C,mBAAmBJ,CAAc,EAAI,QAAO5H,EAAa8H,OAAO,EAItF,KAAKgqB,iBAAiB9xB,CAAY,CAEjD,CAUA8xB,iBAAiB9xB,EAAc,CAAA,IAAA+xB,EAC3B,OAAAA,EAAO,KAAK9tB,kBAAkBjE,CAAY,KAAC,MAAA+xB,IAAA,OAAA,OAApCA,EAAuC,CAAC,CACnD,CAQA9tB,kBAAkBjE,EAAc,CAAA,IAAAgyB,EAI5B,OAAAA,EAAI,KAAKnqB,aAASmqB,MAAAA,IAAdA,QAAAA,EAAgBvxB,MACT,KAAKoH,UAAUoqB,OAAO,CAAC9rB,EAAQ6S,KAC7BA,EAAK+I,QACN5b,EAAOsE,KAAK,KAAKonB,yBAAyB7Y,EAAMhZ,CAAY,CAAC,EAE1DmG,GACR,CAAA,CAAE,EAGF,CAAC,KAAK0rB,yBAAyB,CAAE/pB,MAAQ,WAAa9H,CAAY,CAAC,CAC9E,CAQAkyB,uBAAuBlyB,EAAc,CACjC,OAAOiF,EAAQC,SAAS,KAAKqB,YAAc,UAASvG,EAAa8H,OAAO,CAC5E,CAWAmP,UAAUrT,EAAGH,EAAGyQ,EAAe,oBAAqB,CAAA,IAAAie,EAChD,OAAAA,EAAO,KAAK5pB,aAAaI,iBAAiB/E,EAAGH,CAAC,KAAC,MAAA0uB,IAAxCA,OAAAA,OAAAA,EAA0CptB,QAAQmP,CAAY,CACzE,CAGAke,YAAYvhB,EAAMoY,EAAc,CAC5B,MAAMpqB,EAAK,KACX,IAAI8uB,EAAO9uB,EAAI,IAAGgS,GAAM,EACxB,GAAI8c,GAAQ,KAAM,CACd,MAAMzP,EAAQrf,EAAGwzB,IAAIxhB,CAAI,EACzB8c,EAAQxqB,EAAUmvB,YAAYpU,GAAS+K,EAAcpqB,EAAGwF,OAAO,EAC3D6Z,IACArf,EAAI,IAAGgS,GAAM,EAAI8c,GAGzB,OAAOA,CACX,CAEA,IAAIlW,SAAU,CACV,OAAO,KAAK2a,YAAY,UAAW,KAAK,CAC5C,CAEJ,EA1NI7zB,EAFqB6e,EAEd1b,QAAQ,gBAFM0b,GCSzBmV,GAAepV,GAAM,SAAI,OAAAC,EAAA,cAAkCD,GAAUpb,EAAM,CAAlD,kCAyBrBywB,GAAA,KAAAC,EAAsB,MACtB,IAAItH,aAAc,CAAA,CA4HlBuH,mBAAmBC,EAAc,CAC7B,GAAIA,EACA,UAAWC,KAAa,KAAKC,UACzBF,EAAaC,CAAS,EAAI,kBAGlC,OAAOD,CACX,CAEAG,aAAavxB,EAAO,CAChB,KACI,CAAEmK,OAAAA,CAAO,EAAQnK,EACjBsO,EAAiB,KAAKkF,kBAAkBrJ,CAAM,EAC9C1L,EAAiB,KAAK0G,oBAAoBgF,CAAM,EAChD9D,EAAiB,KAAK4L,sBAAsB9H,CAAM,EACtD,MAAO,CAAEmE,WAAAA,EAAY7P,aAAAA,EAAc4H,eAAAA,EAAgBrG,MAAAA,EACvD,CAGAwxB,gBAAgBxxB,EAAO,CACnB,MACI1C,EAAa,KACbX,EAAaW,EAAGi0B,aAAavxB,CAAK,EAClCsP,EAAahS,EAAGg0B,UAAUtxB,EAAMI,IAAI,EACpC,CAAE+J,OAAAA,CAAO,EAAInK,EAEjB,GAAI1C,EAAGm0B,aAAetnB,EAAO3G,QAAQ,WAAW,IAAMlG,EAAGo0B,SACrD,OAGJ1xB,EAAMgK,cAAgBrN,EACtB,IAAIiI,EAEJ,GAAIjI,EAAK2R,WAAY,CACjB,MAAM+iB,EAAa,OAAMhU,EAAa6C,WAAW5Q,CAAI,IACrD1K,EAAStH,EAAG2C,QAAQoxB,EAAW10B,CAAI,EAC/B00B,IAAc/zB,EAAGq0B,mBAAqB,CAAC3xB,EAAM2jB,kBAC7CrmB,EAAG2C,QAAQ,eAAgB,CAAEqO,WAAa3R,EAAK2R,WAAYtO,MAAAA,CAAM,CAAC,OAGjErD,EAAK8B,aACN0L,EAAO3G,QAAQ,4BAA4B,EAC3CoB,EAAStH,EAAG2C,QAAS,eAAcod,EAAa6C,WAAW5Q,CAAI,IAAK3S,CAAI,EAGxEiI,EAAStH,EAAG2C,QAAS,SAAQod,EAAa6C,WAAW5Q,CAAI,IAAK3S,CAAI,EAGjEA,EAAK0J,iBACN8D,EAAO3G,QAAQ,8BAA8B,EAC7CoB,EAAStH,EAAG2C,QAAS,iBAAgBod,EAAa6C,WAAW5Q,CAAI,IAAK3S,CAAI,EAG1EiI,EAAStH,EAAG2C,QAAS,WAAUod,EAAa6C,WAAW5Q,CAAI,IAAK3S,CAAI,GAI5E,GAAIiI,IAAW,KAGftH,EAAG2C,QAAQqP,EAAM3S,CAAI,GAEhB2S,IAAS,aAAeA,IAAS,aAAe3S,EAAK2R,YAAY,CAClE,MAAM6B,EAAchG,EAAO3G,QAAQ,mBAAmB,EAClD8L,IAAS,aAAea,IAAgB7S,GAAAA,EAAG4zB,KAC3C5zB,GAAAA,EAAG4zB,EAAsB/gB,GACzB7S,EAAG2C,QAAQ,iBAAkBtD,CAAI,GAEjC2S,IAAS,YAAc,CAACa,EAAYyhB,SAAS5xB,EAAM6xB,aAAa,IAChEv0B,GAAAA,EAAG4zB,EAAsB,MACzB5zB,EAAG2C,QAAQ,iBAAkBtD,CAAI,GAG7C,CAEAm1B,gBAAgB,CAAEjD,OAAAA,EAAQ1Q,UAAAA,EAAW4T,cAAAA,EAAe9T,cAAgBnb,EAASkvB,OAAAA,CAAO,EAAG,OACnF,MACI10B,EAAkB,KAClB,CAAE20B,YAAAA,IAAgB9T,EAAAA,GAAAA,KAAAA,OAAAA,EAAW1Y,cAAX0Y,KAAAA,EAA0B,CAAA,EAC5C+T,EAAkBrD,IAAW,kBAEjC,GAAI1Q,EAAW,CAAA,IAAAgU,EAEX,GAAIF,IAAgB,OAAQ,CACxB,KACI,CAAE9Z,OAAAA,GAAWgG,EAAU1Y,YACvB6I,EAAahR,EAAGua,QAAQD,UAAU8K,QAAQvK,CAAM,EACpD,GAAI0W,IAAW,aAAc,CAAA,IAAAuD,GACzBA,EAAA90B,EAAG+0B,4BAAwB,MAAAD,IAAA,QAA3BA,EAA6BE,QAAQxvB,CAAO,EAEhD,GAAI+rB,IAAW,cAAgBA,IAAW,mBACrC,CAACvxB,EAAGi1B,eAAiBjkB,EAAWgH,aAAahY,CAAE,EAAEk1B,aAAel1B,EAAG2C,QAAQ,aAAc,CAAEqO,WAAAA,EAAYxL,QAAAA,EAASovB,UAAAA,CAAU,CAAC,UAEvHrD,IAAW,gBAAiB,CAAA,IAAA4D,GACjCA,EAAAn1B,EAAG+0B,4BAAwB,MAAAI,IAAA,QAA3BA,EAA6BC,UAAU5vB,CAAO,EAC9CxF,EAAG2C,QAAQ,oBAAqB,CAAEkY,OAAAA,EAAQrV,QAAAA,CAAQ,CAAC,WAIlDmvB,IAAgB,SAAU,CAAA,IAAAU,EAC/B,KACI,CAAE7lB,SAAAA,EAAUkjB,OAAAA,GAAW7R,EAAU1Y,YACjChH,EAAuBnB,EAAGoB,QAAQgkB,QAAQ5V,CAAQ,EAClDzG,EAAuB2pB,GAAU,QAAI2C,EAAIr1B,EAAGgJ,aAAS,MAAAqsB,IAAZA,OAAAA,OAAAA,EAAcjQ,QAAQsN,CAAM,GACrEnB,IAAW,cAAgBA,IAAW,kBACtCvxB,EAAG2C,QAAQ,eAAgB,CAAExB,aAAAA,EAAc4H,eAAAA,EAAgBvD,QAAAA,EAASovB,UAAAA,CAAU,CAAC,EAE1ErD,IAAW,iBAChBvxB,EAAG2C,QAAQ,sBAAuB,CAAE6M,SAAAA,EAAUzG,eAAAA,EAAgBvD,QAAAA,CAAQ,CAAC,UAItEmvB,IAAgB,WAAY,CAAA,IAAAW,EACjC,KACI,CAAE5C,OAAAA,GAAe7R,EAAU1Y,YAC3BY,EAAiB2pB,GAAU,MAAQA,IAAW,aAAS4C,EAAIt1B,EAAGgJ,aAAS,MAAAssB,IAAA,OAAA,OAAZA,EAAclQ,QAAQsN,CAAM,GAEvFA,IAAW,YACPnB,IAAW,cAAgBA,IAAW,kBACtCvxB,EAAG2C,QAAQ,iBAAkB,CAAEoG,eAAAA,EAAgBvD,QAAAA,EAASovB,UAAAA,CAAU,CAAC,EAE9DrD,IAAW,iBAChBvxB,EAAG2C,QAAQ,wBAAyB,CAAE8M,WAAaijB,EAAQltB,QAAAA,CAAQ,CAAC,QAKvEqvB,EAAAhU,EAAUrU,SAAKqoB,MAAAA,IAAfA,QAAAA,EAAkB,kCAAkC,GAAK70B,EAAGiwB,iBAC7DsB,IAAW,eACN/rB,EAAQ+vB,mBACTv1B,EAAGiwB,eAAe+E,QAAQxvB,CAAO,EACjCA,EAAQ+vB,iBAAmB,KAG/BhE,IAAW,iBACP/rB,EAAQ+vB,mBACRv1B,EAAGiwB,eAAemF,UAAU5vB,CAAO,EACnC,OAAOA,EAAQ+vB,mBAKnC,CAGAnlB,SAAU,CAAA,CACVsN,aAAc,CAAA,CACdQ,WAAY,CAAA,CACZsX,iBAAkB,CAAA,CAClBC,aAAc,CAAA,CACdC,gBAAiB,CAAA,CACjBC,mBAAoB,CAAA,CACpBzY,mBAAoB,CAAA,CACpBtQ,uBAAuBvN,EAAM,CACzB,MAAMuN,oBAAoB,GAAGvN,CAAI,CACrC,CACA+uB,yBAAyB/uB,EAAM,CAC3B,MAAM+uB,sBAAsB,GAAG/uB,CAAI,CACvC,CACAwU,gBAAiB,CAAA,CAErB,EA9RI+f,EAAA,YAvBAl0B,EAFqB6e,EAEd1b,QAAQ,sBACfnD,EAHqB6e,EAGd3e,eAAe,CAQlBy0B,kBAAoB,eACpBL,UAAY,CACRzlB,MAAc,QACdqnB,SAAc,WACdnY,QAAc,UACdoY,UAAc,YACdC,UAAc,YACdC,UAAc,YACdC,SAAc,WACdC,QAAc,UACdC,YAAc,eAElBpC,aAAe,CAAA,IAvBEvV,GCbzB4X,GAAe7X,GAAM,OAAI,OAAAC,EAAA,cAA+BD,GAAUpb,EAAM,CAkCpE,IAAIopB,aAAc,CAAA,CAMlB8J,QAAQ,CAAEC,WAAAA,CAAW,EAAG,CACpB,GAAIA,EAAY,CACZ,MAAMr2B,EAAK,KACXkE,EAAYqZ,GAAG,CACX/X,QAAUxF,EAAGwF,QACb8wB,QAAS,CACLt2B,EAAGm0B,YAAc,GACjBn0B,EAAGu2B,YAAW,GAElBC,QAAU,GACV51B,QAAUZ,CACd,CAAC,EAET,CACAu2B,aAAc,CACV,KAAKpC,YAAc,GACf,KAAKsC,uBACL,KAAKh3B,UAAS,EACd,KAAKg3B,qBAAuB,GAEpC,CAGAC,oBAAoBC,EAAe,CAC/B7qB,OAAAA,EAAaC,aAAa4qB,EAAe,eAAe,EACjDA,CACX,CAeA,MAAMC,iBAAiBC,EAAcpF,EAAU,KAAKkF,cAAe,CAC/D,MACI1wB,EAAkB,KAAK+C,UAAUoc,QAAQyR,CAAY,EACrDjiB,EAAkB3O,GAAY,KAAKkD,mBAAmBlD,CAAQ,EAClE,GAAI2O,EAAiB,CAAA,IAAAkiB,EAAAC,EACjBtF,OAAAA,EAAU3lB,EAAaxG,OAAO,CAC1BP,EAAU,GACViyB,UAAUF,EAAArF,KAAOqF,MAAAA,IAAPA,OAAAA,OAAAA,EAASE,YAAWD,EAAAtF,KAAO,MAAAsF,IAAPA,OAAAA,OAAAA,EAASE,YAAa,UACrDxF,CAAO,EACH1L,GAASvT,eAAeoC,EAAiB6c,EAAS,KAAKzvB,GAAG,EAEzE,CAaA,MAAMk1B,eAAeC,EAAY1F,EAAU,KAAKkF,cAAe,CAC3D,MACI3mB,EAAgB,KAAK5O,QAAQgkB,QAAQ+R,CAAU,EAC/C5e,EAAgBvI,GAAU,KAAKqjB,uBAAuBrjB,CAAM,EAChE,GAAIuI,EAAe,CAAA,IAAA6e,EAAAC,EAEf5F,OAAAA,EAAU3lB,EAAaxG,OAAO,CAC1B0xB,UAAUI,EAAA3F,KAAO2F,MAAAA,IAAPA,OAAAA,OAAAA,EAASJ,YAAWK,EAAA5F,KAAO4F,MAAAA,IAAA,OAAA,OAAPA,EAASJ,YAAa,SACpDryB,EAAU,IACX6sB,CAAO,EACH1L,GAASvT,eAAe+F,EAAekZ,EAAS,KAAKzvB,GAAG,EAEvE,CAcA,MAAMs1B,qBAAqBT,EAAcM,EAAY1F,EAAU,KAAKkF,cAAe,CAC/E,MACI1wB,EAAW,KAAK+C,UAAUoc,QAAQyR,CAAY,EAC9C7mB,EAAW,KAAK5O,QAAQgkB,QAAQ+R,CAAU,EAC1CtqB,EAAW5G,GAAY+J,GAAU,KAAKgjB,yBAAyB/sB,EAAU+J,CAAM,EACnF,GAAInD,EAAQ,CAAA,IAAA0qB,EAAAC,EACR/F,OAAAA,EAAU3lB,EAAaxG,OAAO,CAC1B0xB,UAAaO,EAAA9F,KAAO8F,MAAAA,IAAPA,OAAAA,OAAAA,EAASP,YAAWQ,EAAA/F,KAAO+F,MAAAA,IAAA,OAAA,OAAPA,EAASP,YAAa,SACvDQ,WAAa,IACdhG,CAAO,EACH1L,GAASvT,eAAe3F,EAAQ4kB,EAAS,KAAKzvB,GAAG,EAEhE,CAaA,MAAM01B,aAAaC,EAAUlG,EAAU,KAAKkF,cAAe,CACvD,MACI32B,EAAc,KACdgR,EAAchR,EAAGua,QAAQD,UAAU8K,QAAQuS,CAAQ,EACnD5gB,EAAc/F,GAAchR,EAAGiR,eAAeD,CAAU,EAC5D,GAAI+F,EAAa,CAAA,IAAA6gB,EAAAC,EACb,MAAMJ,EAAa,CAAEK,MAAQ,GAAIC,IAAM,GAAIpzB,IAAM,GAAIwQ,OAAS,IAE9D,OAAInV,EAAGg4B,gBACCh4B,EAAG2tB,eACH8J,EAAW9yB,KAAO3E,EAAG6yB,uBAAuB7hB,CAAU,EAAE8D,UAAU3O,OAAO8xB,cAE7ER,EAAW9yB,KAAO3E,EAAG0H,YAAYoN,UAAU3O,OAAO8xB,cAElDj4B,EAAGi1B,eAAiB,CAACj1B,EAAGk4B,gBAIxBnhB,EAAYvE,eAAc,EAE1B,MAAM,IAAIjI,QAAQ,CAACC,EAAS2tB,IAAW,CACnC,MAAMC,EAASp4B,EAAGkmB,IAAI,CAClBmS,WAAW,CAAErnB,WAAasnB,CAAmB,EAAG,CACxCA,IAAuBtnB,IACvBonB,EAAM,EACN5tB,EAAO,IAGf+tB,QAAU,CACNC,MAAQ,IACRC,IAAQN,CACZ,CACJ,CAAC,CACL,CAAC,GAEL1G,EAAU3lB,EAAaxG,OAAO,CAC1B0xB,UAAUY,EAAAnG,KAAOmG,MAAAA,IAAPA,OAAAA,OAAAA,EAASZ,YAAWa,EAAApG,KAAOoG,MAAAA,IAAA,OAAA,OAAPA,EAASZ,YAAa,SACpDQ,WAAAA,GACDhG,CAAO,EACH1L,GAASvT,eAAeuE,EAAa0a,EAASzxB,EAAGgC,GAAG,EAEnE,CAEJ,EArMItC,EAFqB6e,EAEd1b,QAAQ,mBACfnD,EAHqB6e,EAGd3e,eAAe,CAmBlB+2B,cAAgB,CACZK,QAAY,GACZvkB,MAAY,UACZimB,UAAY,IAEhBC,WAAa,CACThC,cAAgB,CACZK,QAAU,GACVvkB,MAAU,SACd,CACJ,IAGJ/S,EAnCqB6e,EAmCdqa,YAAY,CACfrC,YAAcsC,EAAcC,UAAY,IAAM,MApC7Bva,GCHzBwa,GAAeza,GAAM,OAAI,OAAAC,EAAA,cAA+BD,GAAUpb,EAAM,CAmGpE,IAAIopB,aAAc,CAAA,CAGlB,IAAI0M,aAAc,CACd,OAAO,KAAKze,QAAQsR,gBAAgBnB,OACxC,CACAuO,kBAAkBvO,EAAS,CACvB,KAAKnQ,QAAQsR,gBAAgBE,KAAOrB,CACxC,CACA,IAAIhI,WAAY,CACZ,OAAO,KAAKnI,QAAQ+G,cAAcoJ,OACtC,CACAwO,gBAAgBxO,EAAS,CACrB,KAAKnQ,QAAQ+G,cAAcyK,KAAOrB,CACtC,CACA,IAAIjQ,OAAQ,CACR,OAAO,KAAKF,QAAQD,UAAUoQ,OAClC,CACAyO,YAAYzO,EAAS,CACjB,KAAKnQ,QAAQD,UAAUyR,KAAOrB,CAClC,CAGA0O,sBAAsBC,EAAiB,CACnCvtB,OAAAA,EAAaC,aAAastB,EAAiB,iBAAiB,EACrDA,CACX,CAGAC,cAAc/e,EAAS,CACnB,OAAIA,GAAW,CAACA,EAAQgf,UACpBhf,EAAU,KAAKif,kBAAkBr5B,IAAIoa,CAAO,GAEhD,KAAKkf,gBAAgBlf,CAAO,EACrBA,CACX,CACAkf,gBAAgBlf,EAAS,CACrB,MAAMva,EAAK,KAGX,GADAA,EAAG05B,gBAAgBnf,CAAO,EACtBA,EAAS,CACT,KAAM,CAAED,UAAAA,CAAU,EAAIC,EAEtB,GAAID,EAAW,CACX,KAAM,CAAEmW,QAAAA,CAAQ,EAAInW,EACpBmW,EAAQE,SAAS,CAAE3lB,SAAWhL,EAAGoa,YAAawW,OAAS,EAAM,CAAC,EAC1D5wB,EAAGqa,eACHoW,EAAQE,SAAS,CAAE3lB,SAAWhL,EAAGqa,cAAeuW,OAAS,EAAM,CAAC,EAGpE+I,QAAQC,eAAetf,EAAUuf,QAAQ/O,WAAWgP,UAAW,6BAA8B,CACzF/rB,KAAM,CACF,OAAO,KAAKgsB,cAAc,CACtB,CAAC/5B,EAAGoa,WAAW,EAAM,KAAKpa,EAAGoa,WAAW,EACxC,CAACpa,EAAGqa,aAAa,EAAI,KAAKra,EAAGqa,aAAa,CAC9C,CAAC,CACL,CACJ,CAAC,EACDC,EAAUuf,QAAQ/O,WAAWgP,UAAUC,cAAgB,SAAShO,EAAM,CAAA,IAAAsJ,EAClE,MAAQ,GAAEtJ,EAAK/rB,EAAGoa,WAAW,SAAQib,EAAAr1B,EAAGgJ,aAASqsB,MAAAA,IAAZA,OAAAA,OAAAA,EAAczzB,QAASmqB,EAAK/rB,EAAGqa,aAAa,GAAM,aAE3FoW,EAAQE,SAAS,CAAE3lB,SAAW,6BAA8B4lB,OAAS,GAAOoJ,YAAc,CAAE,CAACh6B,EAAGqa,aAAa,EAAI,GAAM,CAACra,EAAGoa,WAAW,EAAI,EAAK,CAAE,CAAC,EAGtJpa,EAAGi6B,qBAAqB1f,EAAQD,UAAW,CACvC9L,OAAkB,oBAClB0rB,gBAAkB,yBAClB/I,QAAkB,oBACtB,CAAC,EACDnxB,EAAGi6B,qBAAqB1f,EAAQsR,eAAe,EAC/C7rB,EAAGi6B,qBAAqB1f,EAAQ+G,aAAa,EAErD,CAEA2Y,qBAAqBnO,EAAOqO,EAAkB,CAAA,EAAI,CAC9C,KAAKzT,gBAAgBoF,EAAMjpB,KAAK,EAChCipB,GAAK,MAALA,EAAO5F,IAAI,CACPlU,KAAU8Z,EAAMjpB,MAChB2L,OAAU,YACV2iB,QAAU,YACVvwB,QAAU,KACV,GAAGu5B,CACP,CAAC,CACL,CAGAC,uBAAuB,CAAE7I,OAAAA,CAAO,EAAG,CAC3BA,IAAW,OACX,KAAKM,2BAA2B,CAC5BH,cAAgB,CACZ3rB,OAAU,EACV4rB,QAAU,CACd,CACJ,CAAC,CAET,CACA0I,kBAAkB,CAAE9I,OAAAA,EAAQ+I,QAAAA,CAAQ,EAAG,CACnC,KAAM,CAAElgB,YAAAA,EAAaC,cAAAA,CAAc,EAAI,KAGnCkX,IAAW,UACXA,IAAW,UACVA,IAAW,WAAa+I,EAAQlgB,CAAW,GAAMC,GAAiBigB,EAAQjgB,CAAa,GAExF,KAAKwX,2BAA2B,CAC5BD,iBAAmB,CACf7rB,OAAU,EACV4rB,QAAU,CACd,CACJ,CAAC,EAGD,KAAKlyB,UAAS,CAEtB,CACA86B,mBAAmB,CAAEhJ,OAAAA,CAAO,EAAG,CACvBA,IAAW,OAEX,CAAC,KAAK9V,cAAgB,KAAKoW,2BAA0B,EAGrD,KAAKpyB,UAAS,CAEtB,CAkBA,MAAMkN,QAAQxL,EAAc4H,EAAiB,KAAMyxB,EAAW,CAAA,EAAI,OAC9D,MACIx6B,EAAa,KACb,CACIqa,cAAAA,EACArR,UAAAA,EACAuR,QAAAA,CACJ,EAAava,EACby6B,EAAaz6B,EAAGizB,iBAAiB9xB,CAAY,EAAE2T,UAAUxO,KACzDo0B,EAAaD,EAAWE,iBACxB5O,EAAa,CACT,CAAC/rB,EAAGoa,WAAW,EAAIjZ,EAAa2O,GAChCkC,KAAmBhS,EAAGypB,EAAE,0BAA0B,EAClDpnB,SAAoBkY,EAAAA,EAAQD,UAAUY,IAAI,QAAQ,IAA9BX,KAAAA,EAAmC,GAAK,IAC5D,GAAGva,EAAGq5B,gBACN,GAAGmB,GAEX,IAAItL,EAAY,GACZ7U,IACItR,EACAgjB,EAAK1R,CAAa,EAAItR,EAAe+G,GAEhC9G,GAAS,MAATA,EAAWpH,QAChBmqB,EAAK1R,CAAa,EAAIrR,EAAU4xB,MAAM9qB,KAI1C4qB,GAAYA,EAASG,UAAYH,EAASzC,aAAewC,EAAWK,aAAe,MACnF96B,EAAG0K,qBAAoB,EACvBwkB,EAAY,IAEhB,MAEI6L,EAAexgB,EAAQygB,UAAYzgB,EAAQ0gB,MAAM,OAAQ,EAAK,EAC9D,CAACjqB,CAAU,EAAIuJ,EAAQD,UAAUpT,IAAI6kB,CAAI,EAO7C,GALA/rB,EAAGP,UAAU+vB,IAAG,EAEZxvB,EAAGk7B,kBAAoB,CAACl7B,EAAGm7B,wBAC3B,MAAMn7B,EAAGi7B,MAAM,wBAAyB,EAAK,EAE7Cj7B,CAAAA,EAAGo7B,cAIP,MAAMp7B,EAAG03B,aAAa1mB,EAAYlF,EAAaxG,OAAO,CAAA,EAAItF,EAAG22B,cAAe,CAAE+B,UAAY,GAAOjmB,MAAQ,SAAU,CAAC,CAAC,EACjHzS,CAAAA,EAAGo7B,aAIP,IAAIL,EAAQ,CAER,GADA,MAAMA,EACF/6B,EAAGo7B,YACH,OAGJp7B,EAAGP,UAAU+vB,IAAG,EAEpBN,OAAAA,GAAalvB,EAAG2K,oBAAmB,EAC/B3K,EAAGub,SAASlK,gBACZrR,EAAG+Q,SAASC,CAAU,EAEnBA,EACX,CAuBA,MAAM+W,WAAW/W,EAAY,CACzB,MAAM8E,EAAcnN,GAAY0yB,QAAQrqB,CAAU,EAwBlD,OAAI,MAAM,KAAKrO,QAAQ,mBAAoB,CAAEmT,YAAAA,EAAa,IAAM,IAC5D,KAAKyE,QAAQD,UAAU1R,OAAOkN,CAAW,EAClC,IAEJ,EACX,CAEJ,EApWIpW,EAFqB6e,EAEd1b,QAAQ,mBACfnD,EAHqB6e,EAGd3e,eAAe,CAClB45B,kBAAoBtO,GAmDpB3Q,QAAU,CAAA,EAOVye,YAAc,KAOdtW,UAAY,KAOZjI,MAAQ,KAQR4e,gBAAkB,CAAA,EAClBiC,iBAAmB,CACfC,cAAgB,GAChBC,UAAgB,KAUpBC,SAAW,OAjGMld,GCCzBmd,GAAepd,GAAM,OAAI,OAAAC,EAAA,cAAkCD,GAAUpb,EAAM,CAwHvE,IAAIopB,aAAc,CAAA,CAGlBqP,4BAA4BC,EAAuB,CAC/C9vB,OAAAA,EAAagF,cAAc8qB,EAAuB,uBAAuB,EAClEA,CACX,CACAC,oBAAoBxhB,EAAe,CAC/BvO,OAAAA,EAAaqZ,aAAa9K,EAAe,eAAe,EACjDA,CACX,CAGAyhB,oBAAoBxqB,EAAOkQ,EAAK,CAC5B,GAAIA,EAAK,CACL,KAAM,CAAEiP,QAAAA,CAAQ,EAAI,KAAKlW,QAAQD,UAC7BkH,IAAQ,KAAKpH,aACbqW,EAAQC,YAAYlP,CAAG,EAE3BiP,EAAQE,SAAS,CAAE3lB,SAAWsG,EAAOsf,OAAS,EAAM,CAAC,EAEzD,KAAKmL,4BAA8BzqB,GAAS,KAAKsqB,qBACrD,CAGAI,gBAAgBhzB,EAAW,CACvB,OAAO+nB,GAAM/sB,KAAKgF,EAAW,CAAEgoB,UAAY,GAAMlG,WAAaqB,IAAiBhS,GACvE,OAAOA,GAAS,SACT,CAAErK,GAAKqK,EAAMhY,KAAO4d,EAAa6C,WAAWzI,CAAI,GAEpDA,CACV,CACL,CACA8hB,gBAAgBjzB,EAAW,CACvB,KAAK0d,gBAAgB,WAAW,EAC5B1d,KAGCA,EAAUkoB,QAAUloB,GAAWnF,UAAY,KAC5CmF,EAAUkd,IAAI,CACV1X,OAAU,oBACV2iB,QAAU,oBACVvwB,QAAU,IACd,CAAC,EAET,CACA,IAAIoI,WAAY,CACZ,MACIhJ,EAAgB,KAChB,CAAEsa,UAAAA,GAActa,EAAGua,QAGvB,OAAIva,EAAG+7B,6BAA+BzhB,EAAU1Y,QAC5C5B,EAAGgJ,UAAYsR,EAAU8W,kBAAkBpxB,EAAGqa,aAAa,EAAE7D,KAAI,EACjExW,EAAG+7B,4BAA8B,IAE9B/7B,EAAGk8B,UACd,CACAC,kBAAkB,CAAE5K,OAAAA,CAAO,EAAG,CAK1B,IAHIA,IAAW,OAASA,IAAW,UAAYA,IAAW,aAAeA,IAAW,WAChF,KAAKhX,QAAQD,UAAUmW,QAAQe,kBAAiB,EAEhDD,IAAW,UAAaA,IAAW,UAAYA,IAAW,SAAU,CACpE,MAAME,EAAU,CAAA,EACZF,IAAW,WACXE,EAAQC,cAAgB,CAAE3rB,OAAS,EAAG4rB,QAAU,GAChDF,EAAQG,iBAAmB,CAAE7rB,OAAS,EAAG4rB,QAAU,IAEvD,KAAKE,2BAA2BJ,CAAO,EACvC,OAEJ,KAAKhyB,UAAS,CAClB,CAGA,IAAIkuB,cAAe,CAAA,IAAA8E,EACf,MAAOre,GAAQ,KAAKiG,gBAAaoY,GAAAA,EAAI,KAAKzpB,aAASypB,MAAAA,IAAA,SAAdA,EAAgB7wB,OACzD,CACAwqB,iBAAiBrjB,EAAgB,CAC7B,OAAO,KAAKwR,QAAQD,UAAUmW,QAAQsB,SAAS,KAAK1X,cAAetR,EAAe+G,EAAE,CACxF,CACA4D,YAAY1C,EAAY,CAAA,IAAA8hB,EACpB,OAAO,KAAKzY,iBAAayY,EAAI,KAAK9pB,aAAS,MAAA8pB,IAAA,OAAA,OAAdA,EAAgB1N,QAAQpU,EAAWqU,SAAS,KAAKhL,aAAa,CAAC,EAChG,CAEJ,EA5MI3a,EAFqB6e,EAEd1b,QAAQ,sBACfnD,EAHqB6e,EAGd3e,eAAe,CAmDlBoJ,UAAY,CAAA,EAyBZ4yB,sBAAwB,GAoCxBvhB,cAAgB,OAEpB3a,EArHqB6e,EAqHd8T,aAAa,CAChB0J,4BAA8B,KAtHbxd,GCFzB6d,GAAe9d,GAAM,OAAI,OAAAC,EAAA,cAAuCD,GAAUpb,EAAM,CAoF5E,IAAIopB,aAAc,CAAA,CAGlB+P,iBAAiBC,EAAY,CACzBxwB,OAAAA,EAAagF,cAAcwrB,EAAY,YAAY,EAC5CA,CACX,CACAC,iBAAiBD,EAAY,CAAA,IAAAxH,EACzB,MAAM90B,EAAK,MACX80B,EAAA90B,EAAG+0B,4BAAwB,MAAAD,IAAA,QAA3BA,EAA6BlF,WAAU,EACvC5vB,EAAG+0B,yBAA2B,KAC1BuH,IAGAt8B,EAAG+0B,yBAA2B,IAAIyH,qBAAqBvN,GAAW,CAC9D,UAAWG,KAASH,EAChBjvB,EAAGy8B,mBAAmBrN,EAAMviB,OAAQuiB,EAAMsN,eAAgBtN,CAAK,CAEvE,CAAC,GAGD,CAAC,KAAK9vB,eAAiB,CAAC,KAAKC,cAC7B,KAAKo9B,wBAAuB,CAEpC,CACAA,yBAA0B,CACtB,MAAM38B,EAAK,KAEX,GADAA,EAAGP,UAAU+vB,IAAG,EACZxvB,EAAG+0B,yBACH,UAAWhe,KAAe/W,EAAGwF,QAAQwN,iBAAiB,mBAAmB,EACrEhT,EAAG+0B,yBAAyBC,QAAQje,CAAW,CAG3D,CACA6lB,oBAAoB1E,EAAe,CAC/BA,OAAAA,GAAiBpsB,EAAaI,eAAegsB,EAAe,eAAe,EACpEA,CACX,CACA2E,oBAAoB5wB,EAAI,CAEhB,CAAC,KAAK3M,eAAiB,CAAC,KAAKC,cAC7B,KAAKo9B,wBAAuB,CAEpC,CAEAG,QAAQjc,EAAW,CACfA,OAAAA,EAAUrU,MAAM,eAAe,EAAI,KAAKyoB,cACjC,MAAM6H,QAAQjc,CAAS,CAClC,CACA,IAAIoU,eAAgB,CAChB,MAAO7gB,EAAQ,KAAK2gB,wBACxB,CAEA0H,mBAAmB5pB,EAAa6pB,EAAgBtN,EAAO,CACnD,MACIpvB,EAAkB,KAClB,CAAEgR,WAAAA,GAAgB6B,EAAY1K,YAC9B6P,EAAkBhH,EAAWgH,aAAahY,CAAE,EAC5C+8B,EAAkB/kB,EAAakd,WAC/B6H,IAAoBL,IACpB1kB,EAAakd,WAAawH,EACtB,CAACA,GAAkBK,IACnB/kB,EAAaglB,WAAa5N,EAAM6N,mBAAmBl3B,SAGnD,CAAC/F,EAAGm0B,aAAen0B,EAAGk9B,eACtBl9B,EAAGm9B,qBAAqBn9B,EAAGyT,UAAUzC,CAAU,EAAGhR,EAAG0T,YAAY1C,CAAU,CAAC,EAG5EhR,EAAGm0B,cACHn0B,EAAGy2B,qBAAuB,IAGtC,CAGA2G,kBAAkBpsB,EAAY7P,EAAc4H,EAAgB,CAAA,IAAAs0B,EACxD,MACIr9B,EAAwB,KACxB,CAAE8P,GAAAA,EAAI7G,MAAAA,EAAO5G,OAAAA,CAAO,EAAI2O,EAC5B,MAAO,CACHlB,GAAS,GAAE9P,EAAG8P,WAAW7G,IACzBuD,MAAQ,CACJ,mBAAqB,GACrB,gBAAqB,IAEzB8wB,SAAW,EACXxuB,QAAW,CACP6L,KAAgB1R,EAChB+G,OAAgB7O,EAAa2O,GAC7BqK,KAAgBpR,GAAc,KAAdA,OAAAA,EAAgB+G,GAChCzN,OAAAA,EACA2M,cAAgB,IAEpB7G,YAAc,CACVwsB,YAAc,OACd9Z,OAAc/K,EACdkB,WAAAA,EACA7P,aAAAA,EACA4H,eAAAA,GAEJrE,MAAQ,CACJqB,SAASs3B,EAAAr9B,EAAGk4B,iBAAa,MAAAmF,IAAA,OAAA,OAAhBA,EAAA5uB,KAAAzO,EAAmBgR,CAAU,IAAKA,EAAWgH,aAAahY,CAAE,EAAEg9B,UAC3E,EAER,CAEAO,WAAWvsB,EAAY7P,EAAc4H,EAAgB,CACjD,KACI,CAAEksB,cAAAA,CAAc,EAAI,KACpBuI,EAAoBxsB,EAAWgH,aAAa,IAAI,EAEpD,GAAIid,GAAiB,CAACuI,EAAKvlB,UAAY,CAACulB,EAAKtI,YAAc,CAAC,KAAKvd,WAAW3G,CAAU,EAClF,OAAO,KAAKosB,kBAAkBpsB,EAAY7P,EAAc4H,CAAc,CAE9E,CAEJ,EAvMIrJ,EAFqB6e,EAEd1b,QAAQ,2BACfnD,EAHqB6e,EAGd3e,eAAe,CA8ClBs4B,cAAgB,KAmBhBoE,WAAa,CACTjd,MAAU,KACVyC,QAAU,WAYdob,aAAe,KAlFE3e,GCCV,MAAMkf,WAAiBltB,CAAS,CAG3C,OAAOoZ,OAAO,CAAE9I,UAAAA,EAAWxB,MAAAA,EAAOrO,WAAAA,EAAYtF,OAAAA,CAAO,EAAG,CAEhDA,EAAO4F,QAAU,MAAQN,EAAW0sB,gBACpC7c,EAAUrU,MAAM,gBAAgB,EAAI,EACpCqU,EAAU1e,KAAO,UAGjB0e,EAAU1e,KAAO6O,EAAW2sB,mBAAmBjyB,EAAO4F,KAAK,EAAEssB,MAAMve,CAAK,CAEhF,CACJ,CAZI3f,EADiB+9B,GACV56B,QAAQ,YACfnD,EAFiB+9B,GAEV36B,OAAO,QAYlB26B,GAASx6B,UAAS,EAClBw6B,GAAS59B,OAAS,WCZH,MAAMg+B,WAA4BttB,CAAS,CAkDtD,OAAOoZ,OAAO,CAAE9lB,UAAAA,EAAWgd,UAAAA,EAAWnV,OAAAA,EAAQsF,WAAAA,EAAYue,SAAAA,CAAS,EAAG,SAClE,MACIO,GAAwBP,GAAAA,EAAAA,GAAQ,KAAA,OAARA,EAAUO,aAAVP,KAAAA,EAAwB7jB,EAAOokB,aAA/BP,KAAAA,EAA6C,EACrE,CAAEnO,kBAAAA,CAAkB,EAAIvd,EACxB,CAAE6e,UAAAA,CAAU,EAAY1R,EACxB8sB,EAAwBpb,EAAUhc,OAASopB,EAC3CiO,EAAwBrb,EAAUhc,OAASopB,EAAa,EACxDkO,EAAwBtb,EAAUoN,CAAU,EAChD,GAAI,CAAEhP,gBAAAA,CAAgB,EAAIjd,EAO1B,GANKid,IACDA,EAAkBjd,EAAUid,gBAAkB,IAAIW,GAAgB,CAC9Djc,QAAc3B,EAAU2B,QACxBy4B,YAAc,+BAClB,CAAC,GAED,CAACp6B,EAAU0W,QAAQ+G,cAAc1f,MACjC,MAAO,GAEXkK,EAAawC,MAAMuS,EAAW,CAC1BrU,MAAQ,CACJ,YAAcd,EAAOwyB,SAEzBx1B,SAAW,CAEP,GAAGga,EAEElM,KAAK,CAACC,EAAGC,IAAMD,EAAEzE,KAAKmsB,cAAcznB,EAAE1E,IAAI,CAAC,EAC3C4F,MAAM,EAAGkY,GAAcgO,EAAc,EAAI,EAAE,EAC3C51B,IAAI,CAACyf,EAAUliB,KAAO,CACnB+G,MAAQ,CACJ,mCAAqC,GAEzCsC,QAAU,CACNsvB,WAAazW,EAAS7X,IAE1BpH,SAAW,CACPoY,EAAgBC,kBAAkB,CAC9BN,eAAiBkH,EACjBzG,SAAiByG,EAASxG,QAAU,GAAQ,KAAQwG,EAASzG,UAAYyG,EAASxG,QAAWC,GAAqB,IAAMuG,EAASxG,MACjIH,SAAiB2G,EAAS3G,SAC1BzO,MAAiBoV,EAAS3N,WAC1BlL,QAAiB,CACbuS,KAAOtB,EAAaC,WAAW2H,EAAS3V,IAAI,CAChD,CACJ,CAAC,CAAC,CAEV,EAAE,EAEN8rB,GAAe,CACXtxB,MAAQ,CACJ,uCAAyC,GAE7CsC,QAAU,CACNsvB,WAAa,YACb/c,KAAaqB,EAAU9K,MAAM,CAACmmB,CAAa,EAAE71B,IAAI2O,GAAKkJ,EAAaC,WAAWnJ,EAAE7E,IAAI,CAAC,EAAE0X,KAAK,IAAI,EAChG9nB,MAAam8B,GAEjBr1B,SAAW,CACPoY,EAAgBC,kBAAkB,CAC9BN,eAAiBud,EACjB9c,SAAiB8c,EAAa7c,QAAU,GAAQ,KAAQ6c,EAAa9c,UAAY8c,EAAa7c,OAAUC,EAAoB4c,EAAa7c,MACzIH,SAAiBgd,EAAahd,QAClC,CAAC,CAAC,CAEV,CAAC,EAELqd,YAAc,CACVC,YAAc,YAClB,CACJ,CAAC,CACL,CACA,OAAOluB,QAAQ,CAAEF,OAASrM,EAAWmN,WAAAA,EAAYtO,MAAAA,CAAM,EAAG,CACtD,MAAM8C,EAAU9C,EAAMmK,OAAO3G,QAAQ,2DAA2D,EAChG,GAAIV,EAAS,CACT,GAAIA,EAAQQ,QAAQ,oBAAoB,EAAG,CACvC,MAAMya,EAAiB5c,EAAU0W,QAAQ+G,cAAc8D,QAAQ5f,EAAQsJ,QAAQsvB,UAAU,EACzFv6B,EAAUlB,QAAQ,sBAAuB,CAAE8d,eAAAA,EAAgBzP,WAAAA,EAAYxL,QAAAA,EAAS9C,MAAAA,CAAM,CAAC,OAGvFmB,EAAUlB,QAAQ,8BAA+B,CAAEqO,WAAAA,EAAYxL,QAAAA,EAAS9C,MAAAA,CAAM,CAAC,EAEnF,MAAO,GAEf,CACJ,CArIIhD,EADiBm+B,GACVh7B,QAAQ,uBACfnD,EAFiBm+B,GAEV/6B,OAAO,mBA+CdpD,EAjDiBm+B,GAiDVntB,gBAAgB,CAAE5N,KAAO,iBAAkBy7B,YAAc,SAsFpEV,GAAoB56B,UAAS,EAC7B46B,GAAoBh+B,OAAS,sBC7I7B,MACI2+B,GAAmB,CACfC,gBAAkB,EAClBC,UAAkB,EAClBC,SAAkB,GAEtBC,GAAmB,wBACnBC,GAAmB,UACnBC,GAAmB,UAoFvB,IAAAC,GAAezgB,GAAM,OAAI,OAAAC,EAAA,cAAyBD,GAAUpb,EAAM,CAsN9D,IAAIopB,aAAc,CAAA,CAGlBtgB,mBAAmBiB,EAAc,CAC7BnB,OAAAA,EAAaI,eAAee,EAAc,cAAc,EACjDA,CACX,CAGA+xB,WAAWj9B,EAAOyf,EAAK,CACnB,OAAIA,GAAOzf,IACPA,EAAQ+J,EAAakzB,WAAWxd,EAAKzf,CAAK,GAEvCA,CACX,CAEAk9B,kBAAkBl9B,EAAOyf,EAAK,CAC1B1V,OAAAA,EAAaC,aAAahK,EAAO,aAAa,EACvC,KAAKi9B,WAAWj9B,EAAOyf,CAAG,CACrC,CAEA0d,gBAAgBn9B,EAAOyf,EAAK,CACxB1V,OAAAA,EAAaC,aAAahK,EAAO,WAAW,EACrC,KAAKi9B,WAAWj9B,EAAOyf,CAAG,CACrC,CAEA2d,kBAAkBp9B,EAAOyf,EAAK,CAC1B1V,OAAAA,EAAaC,aAAahK,EAAO,aAAa,EACvC,KAAKi9B,WAAWj9B,EAAOyf,CAAG,CACrC,CAIA4d,YAAYpuB,EAAYjP,EAAO8K,EAAQ0iB,EAAU,CAC7C,UAAWzhB,KAAO/L,EAAO,CACrB,MAAM2J,EAAS3J,EAAM+L,CAAG,EACxB,GAAIpC,GAAU,CAACA,EAAOwX,OAAQ,CAEpB,UAAWxX,IACToC,EAAIuI,SAAS,GAAG,EAChB,CAAC3K,EAAO4F,KAAK,EAAIxD,EAAIuxB,MAAMP,EAAQ,EAE9BhxB,EAAIuI,SAAS,GAAG,EACrB,CAAA,CAAG3K,EAAO4F,KAAK,EAAIxD,EAAIuxB,MAAMR,EAAO,EAGpCnzB,EAAO4F,MAAQxD,GAGvB,KACI,CAAEwD,MAAAA,CAAM,EAAI5F,EACZ2T,EAAYrO,EAAWqU,SAAS/T,CAAK,EAEzC,GAAI+N,GAAS,MAAQmf,GAAU9yB,EAAO5I,IAAI,EAAG,CACzC,MAGIuL,EAAYkC,EAASiV,YAAY9Z,EAAO5I,IAAI,EAC5Cw8B,EAAa,eAAcvf,EAAawf,UAAU7zB,EAAO5I,IAAI,IAE7D+d,EAAY,CACRrU,MAAQ,CACJ,uBAAyB,EACzB,CAAC8yB,CAAO,EAAiB,EACzB,CAAC5zB,EAAOgD,GAAG,EAAchD,EAAOgD,IAChC,aAAyB,CAACsC,EAAW/O,UAAYoM,EAAKmC,gBAAgB,CAAE9E,OAAAA,EAAQ2C,KAAAA,EAAM,GAE1FS,QAAU,CACNC,KAAQ,QAAOuC,IACfA,MAAAA,EACAnD,IAAOL,GAEX3F,YAAc,CACVkG,KAAAA,EACA2C,WAAAA,EACAtF,OAAAA,GAEJhH,MAAQ,CACJ86B,MAAQ9zB,EAAO8zB,MACf96B,MAAQgH,EAAOhH,KACnB,GAGQ2J,EAAKsb,OAAO,CAAE9lB,UAAY,KAAMgd,UAAAA,EAAWxB,MAAAA,EAAO3T,OAAAA,EAAQsF,WAAAA,EAAYue,SAAAA,CAAS,CAAC,IAEjF,KACX1iB,EAAOnE,SAASoF,CAAG,EAAI+S,KAK3C,CAEA4e,aAAapgC,EAAM,CAAA,IAAAqgC,GACfA,EAAA,MAAMD,gBAAYC,MAAAA,IAAlBA,QAAAA,EAAAjxB,KAAqBpP,KAAAA,CAAI,EACzB,MACIW,EAAuC,KACvC,CAAEiN,aAAAA,CAAa,EAAwBjN,EACvC,CAAEgR,WAAAA,EAAY2uB,WAAAA,EAAYpQ,SAAAA,CAAS,EAAIlwB,EACvC,CACI0wB,YAAc6P,EACd5P,UAAc6P,EACdC,YAAcC,CAClB,EAAuCxQ,GAAY,CAAA,EACnD,CAAEppB,OAAAA,EAAQG,KAAAA,EAAM05B,OAAAA,GAAuBL,EAAWj3B,SACtD,GAAI,CAAEqnB,YAAAA,EAAaC,UAAAA,EAAW8P,YAAAA,CAAY,EAAI9/B,GAE1C4/B,GAAmB3yB,KACnB8iB,EAAcjkB,EAAam0B,MAAMlQ,CAAW,IAE5C8P,GAAiB5yB,KACjB+iB,EAAYlkB,EAAam0B,MAAMjQ,CAAS,IAExC+P,GAAmB9yB,KACnB6yB,EAAch0B,EAAam0B,MAAMH,CAAW,GAGhDF,GAAmB9zB,EAAawC,MAAMyhB,EAAa6P,CAAe,EAClEC,GAAiB/zB,EAAawC,MAAM0hB,EAAW6P,CAAa,EAC5DE,GAAmBj0B,EAAawC,MAAMwxB,EAAaC,CAAe,EAGlE9yB,GAAAA,MAAAA,EAAe,CAAE8iB,YAAAA,EAAaC,UAAAA,EAAW8P,YAAAA,EAAa9uB,WAAAA,EAAYue,SAAAA,CAAS,CAAC,EAE5EvvB,EAAGo/B,YAAYpuB,EAAY+e,EAAa5pB,EAAQopB,CAAQ,EACxDvvB,EAAGo/B,YAAYpuB,EAAYgf,EAAW1pB,EAAMipB,CAAQ,EACpDvvB,EAAGo/B,YAAYpuB,EAAY8uB,EAAaE,EAAQzQ,CAAQ,CAC5D,CAGApe,gBAAgB3L,EAAS,CAErB,MAAM06B,EAAkB16B,EAAQU,QAAQ04B,EAAgB,GAAKp5B,EAAQwhB,cAAe,gBAAe4X,gBAA8BA,IAAkB,EACnJ,OAAIsB,EACO,CACH,GAAGA,EAAgB/3B,YACnB3C,QAAU06B,GAGX,IACX,CAEAzK,YAAYp2B,EAAM,CACd,MAAM6R,EAAW,KAAKC,gBAAgB9R,EAAKqD,MAAMmK,MAAM,EACvD,GAAIqE,EAAU,CAAA,IAAAivB,EACV,KAAM,CAAEz0B,OAAAA,EAAQ2C,KAAAA,CAAM,EAAI6C,GAC1BivB,EAAA9xB,EAAK+B,WAAO,MAAA+vB,IAAA,QAAZA,EAAA1xB,KAAAJ,EAAe,CACX3C,OAAAA,EACA,GAAGrM,CACP,CAAC,EAEL,MAAMo2B,YAAYp2B,CAAI,CAC1B,CAEAq2B,eAAer2B,EAAM,CACjB,MAAM6R,EAAW,KAAKC,gBAAgB9R,EAAKqD,MAAMmK,MAAM,EACvD,GAAIqE,EAAU,CAAA,IAAAkvB,EACV,KAAM,CAAE10B,OAAAA,EAAQ2C,KAAAA,CAAM,EAAI6C,GAC1BkvB,EAAA/xB,EAAKgyB,cAAU,MAAAD,IAAA,QAAfA,EAAA3xB,KAAAJ,EAAkB,CACd3C,OAAAA,EACA,GAAGrM,CACP,CAAC,EAEL,MAAMq2B,eAAer2B,CAAI,CAC7B,CAEJ,EA1XIK,EAFqB6e,EAEd1b,QAAQ,aACfnD,EAHqB6e,EAGd3e,eAAe,CAsDlBmwB,YAAc,CACV1Q,MAAQ,CACJld,KAAO,CAAEW,KAAO,OAAQwO,MAAQ,MAAO,GAE3CwQ,QAAU,CACNxT,MAAQ,OACZ,GAuDJ0hB,UAAY,CACR3Q,MAAQ,CACJld,KAAO,CAAEW,KAAO,OAAQwO,MAAQ,aAAc,GAElDwQ,QAAU,CACNxT,MAAQ,OACZ,GAuDJwxB,YAAc,CACVzgB,MAAQ,CACJof,gBAAkB,CAAE37B,KAAO,kBAAmBwO,MAAQ,WAAY,GAEtEwQ,QAAU,CACNxT,MAAQ,OACZ,GA2BJrB,aAAe,OApNEsR,GChGzB,MAAM+hB,GAAoB,CAAC,eAAgB,eAAgB,aAAc,gBAAiB,UAAU,EAQpG,IAAAC,GAAejiB,GAAM,OAAI,OAAAC,EAAA,cAA8BD,GAAUpb,EAAM,CA6BnE,IAAIopB,aAAc,CAAA,CAGlBkU,YAAYz7B,EAAGH,EAAG,CAAA,IAAA67B,EACd,KACI,CAAE/2B,aAAAA,CAAa,EAAI,KACnBg3B,EAAmBp8B,EAAUmvB,YACzB,KAAKD,IAAI5a,SAAW,MACpB,KAAKlR,YAAYsf,cAAc,gDAAgD,CACnF,EACJ,IAAIrM,GAAI8lB,EAAG/2B,EAAaI,iBAAiB/E,EAAGH,CAAC,KAAC,MAAA67B,IAAnCA,OAAAA,OAAAA,EAAqCv6B,QAAQ,mBAAmB,EAE3E,GAAI,CAACyU,EAAM,CAAA,IAAAgmB,EACPhmB,GAAIgmB,EAAGj3B,EAAaI,iBAAiB/E,EAAGH,EAAI87B,CAAG,KAAC,MAAAC,IAAA,OAAA,OAAzCA,EAA2Cz6B,QAAQ,mBAAmB,EAGjF,GAAI,CAACyU,EAAM,CAAA,IAAAimB,EACPjmB,GAAIimB,EAAGl3B,EAAaI,iBAAiB/E,EAAGH,EAAI87B,CAAG,KAAC,MAAAE,IAAA,OAAA,OAAzCA,EAA2C16B,QAAQ,mBAAmB,EAEjF,OAAOyU,CACX,CAGAkmB,yBAAyB9pB,EAAa+pB,EAAa,CAC/C,GAAI/pB,EAAa,CACb,MACI/W,EAAuB,KACvB+gC,EAAuB/gC,EAAGkW,kBAAkBsH,SAASwjB,aAAa,EAQtE,GALIF,GAAeC,GAAwB,CAAC/gC,EAAG2X,WAAWopB,CAAoB,GAC1E/gC,EAAGgd,WAAW+jB,EAAsB,EAAI,EAIxC/gC,EAAGihC,oBAAsBH,EAAa,CACtC,MAAMI,EAAclhC,EAAGkW,kBAAkBa,CAAW,EAE/C/W,EAAG2X,WAAWupB,CAAW,EAKrBJ,GACL9gC,EAAGid,aAAa8jB,CAAoB,EALpC/gC,EAAGgd,WAAWkkB,EAAaJ,CAAW,EAS9C/pB,EAAYxF,MAAK,EAEzB,CAEA4vB,aAAaC,EAAUC,EAAQ,CAC3B,MACIrhC,EAA+C,KAC/C,CAAEgR,WAAAA,EAAYjI,eAAAA,EAAgB5H,aAAAA,GAAiBigC,EAAS10B,cACxDqK,EAA+C/W,EAAGiR,eAAeD,CAAU,EAC/E,IACIswB,EAAQ,KACRC,EAAmBpgC,EACvB,EAEI,IADAogC,EAAmBvhC,EAAGoB,QAAQ+I,QAAQo3B,EAAkB,EAAI,EACxD,CAACA,EAAiBre,OAAQ,CAC1B,MACIse,EAAoBxhC,EAAGgzB,yBAAyBjqB,EAAgBw4B,CAAgB,EAChFx8B,EAAoBhB,EAAUC,KAAKw9B,EAAmB,KAAM,EAAI,EAAEz3B,OAAOhF,EACzEH,EAAoBb,EAAUC,KAAK+S,EAAa,KAAM,EAAI,EAAEhN,OAAOnF,EACvE08B,EAAQthC,EAAGwgC,YAAYz7B,EAAGH,CAAC,QAG5B,CAAC08B,GAASC,IAAqBpgC,GACtCnB,EAAG6gC,yBAAyBS,EAAOD,CAAM,CAC7C,CAEAI,aAAaL,EAAUC,EAAQ,CAC3B,MACIrhC,EAA+C,KAC/C,CAAEgR,WAAAA,EAAYjI,eAAAA,EAAgB5H,aAAAA,GAAiBigC,EAAS10B,cACxDqK,EAA+C/W,EAAGiR,eAAeD,CAAU,EAC/E,IACIswB,EAAQ,KACRI,EAAmBvgC,EACvB,EAEI,IADAugC,EAAmB1hC,EAAGoB,QAAQE,QAAQogC,EAAkB,EAAI,EACxD,CAACA,EAAiBxe,OAAQ,CAC1B,MACIye,EAAoB3hC,EAAGgzB,yBAAyBjqB,EAAgB24B,CAAgB,EAChF38B,EAAoBhB,EAAUC,KAAK29B,EAAmB,KAAM,EAAI,EAAE53B,OAAOhF,EACzEH,EAAoBb,EAAUC,KAAK+S,EAAa,KAAM,EAAI,EAAEhN,OAAOnF,EACvE08B,EAAQthC,EAAGwgC,YAAYz7B,EAAGH,CAAC,QAG5B,CAAC08B,GAASI,IAAqBvgC,GACtCnB,EAAG6gC,yBAAyBS,EAAOD,CAAM,CAC7C,CAEAO,cAAcl/B,EAAO2+B,EAAS,GAAO,CACjC,KAAK,YAAc,KAAKr/B,IAAM,OAAS,OAAO,EAAEU,EAAO2+B,CAAM,CACjE,CAEAQ,aAAan/B,EAAO2+B,EAAS,GAAO,CAChC,KAAK,YAAc,KAAKr/B,IAAM,OAAS,OAAO,EAAEU,EAAO2+B,CAAM,CACjE,CAEAS,aAAaV,EAAUC,EAAS,GAAO,CACnC,KACI,CAAErwB,WAAAA,GAAeowB,EAAS10B,cAC1Bq1B,EAAiB,KAAKvuB,YAAYxC,EAAY,EAAI,EACtD,KAAK6vB,yBAAyB,KAAK5vB,eAAe8wB,CAAQ,EAAGV,CAAM,CACvE,CAEAW,WAAWZ,EAAUC,EAAS,GAAO,CACjC,KACI,CAAErwB,WAAAA,GAAeowB,EAAS10B,cAC1Bu1B,EAAiB,KAAK9uB,gBAAgBnC,EAAY,EAAI,EAC1D,KAAK6vB,yBAAyB,KAAK5vB,eAAegxB,CAAQ,EAAGZ,CAAM,CACvE,CAEAa,SAASx/B,EAAO,CACZ,KAAM,CAAEsO,WAAAA,CAAW,EAAI,KAAKijB,aAAavxB,CAAK,EAE9CsO,GAAc,KAAKrO,QAAQ,eAAgB,CAAEqO,WAAAA,EAAYtO,MAAAA,CAAM,CAAC,CACpE,CACAyR,kBAAkB,CAAEod,OAAAA,EAAQ7uB,MAAAA,CAAM,EAAG,CACjC,MAAMgK,EAAgB,KAAKunB,aAAavxB,CAAK,EAG7C,OAFAA,EAAMgK,cAAgBA,EAElB6kB,IAAW,YAAc7kB,EAAcsE,YAActO,EAAMmK,SAAW,KAAKoE,eAAevE,EAAcsE,UAAU,EAC3G,GAEJoD,IAAS,KAAKqI,cAAgB,CAAC6jB,GAAkBjqB,SAASkb,CAAM,KAAM7kB,GAAa,MAAbA,EAAesE,YAChG,CAEJ,EAhKItR,EAFqB6e,EAEd1b,QAAQ,kBACfnD,EAHqB6e,EAGd3e,eAAe,CAElByU,OAAS,CACL8tB,UAAa,eACbC,UAAa,eACbC,QAAa,aACbC,WAAa,gBACbhuB,MAAa,YAEjBmI,aAAe,GAefwkB,mBAAqB,KA3BJ1iB,GCUzBgkB,GAAejkB,GAAM,OAAI,OAAAC,EAAA,cAA6BD,GAAUpb,EAAM,CAoClE,IAAIopB,aAAc,CAAA,CAGlBkW,oBAAoBpsB,EAAe,CAC/BtK,OAAAA,EAAa2iB,YAAYrY,EAAe,eAAe,EAChDA,EAAcE,OAAOqE,GAAI,CAAA,IAAA8nB,EAAA,QAAIA,EAAA,KAAKC,oBAAgB,MAAAD,IAAA,OAAA,OAArBA,EAAAh0B,KAAI,KAAoBkM,CAAI,KAAM,GAAM,CAChF,CAGAgoB,oBAAoB3xB,EAAY9J,EAAM,GAAO45B,EAAc,KAAM,CAC7D,MAAM9gC,EAAK,KAEP8gC,GAAe,KACX9gC,EAAG2X,WAAW3G,CAAU,GAEnB9J,EAKDlH,EAAGid,aAAajM,CAAU,EAI9BhR,EAAGgd,WAAWhM,EAAY9J,CAAG,EAI5B45B,EACL9gC,EAAGgd,WAAWhM,EAAY9J,CAAG,EAI7BlH,EAAGid,aAAajM,CAAU,CAElC,CAOAgM,WAAWhM,EAAY9J,EAAM,GAAO,CAAA,IAAA07B,EAChC,KACI,CAAExsB,cAAAA,CAAc,EAAI,KACpB1T,EAAoB,CAChB6uB,OAAS,SACT8P,OAAS,CAACrwB,CAAU,KAGxB4xB,EAAA,KAAKF,oBAAgB,MAAAE,IAAA,OAAA,OAArBA,EAAAn0B,KAAI,KAAoBuC,CAAU,KAAM,KAGvC9J,IACDxE,EAAMmgC,SAAWzsB,EAAcwB,MAAK,EACpCxB,EAAc1P,OAAS,GAE3BiC,GAAYm6B,QAAQ1sB,EAAepF,CAAU,EAC7C,KAAK+xB,uBAAuBrgC,CAAK,EACjC,KAAKjD,UAAS,EAClB,CAMAwd,aAAajM,EAAY,CACrBrI,GAAYC,OAAO,KAAKwN,cAAepF,CAAU,EACjD,KAAK+xB,uBAAuB,CACxBxR,OAAW,WACXsR,SAAW,CAAC7xB,CAAU,CAC1B,CAAC,EACD,KAAKvR,UAAS,CAClB,CAKA+c,aAAc,CACV,KAAM,CAAEpG,cAAAA,CAAc,EAAI,KAC1B,GAAIA,EAAc1P,OAAQ,CACtB,MAAMm8B,EAAWzsB,EAAcwB,MAAK,EACpCxB,EAAc1P,OAAS,EACvB,KAAKq8B,uBAAuB,CACxBxR,OAAS,WACTsR,SAAAA,CACJ,CAAC,EACD,KAAKpjC,UAAS,EAEtB,CAOAkY,WAAW3G,EAAY,CACnB,OAAO,KAAKoF,cAAcC,SAASrF,CAAU,CACjD,CACA+xB,uBAAuBrgC,EAAO,CAW1B,KAAKC,QAAQ,kBAAmB0C,OAAOC,OAAO,CAC1C09B,UAAY,KAAK5sB,cACjBirB,OAAY,CAAA,EACZwB,SAAY,CAAA,GACbngC,CAAK,CAAC,CACb,CAGA+yB,YAAYwN,EAAc,CACtB,MAAMxN,YAAYwN,CAAY,EAC9B,KAAM,CAAEvgC,MAAAA,EAAOsO,WAAAA,CAAW,EAAIiyB,EACzBvgC,EAAM2jB,kBACP,KAAKsc,oBAAoB3xB,EAAYtO,EAAM6Z,OAAO,CAE1D,CACA2mB,eAAe9B,EAAU,CACrB,GAAI,CAAC98B,EAAU6+B,WAAW/B,EAASv0B,MAAM,EAAG,CACxC,KAAM,CAAEmE,WAAAA,CAAW,EAAI,KAAKijB,aAAamN,CAAQ,EACjD,GAAIpwB,EACA,YAAK2xB,oBAAoB3xB,EAAY,EAAK,EACnC,GAGf,MAAO,EACX,CACAoyB,qBAAqBhC,EAAU,CAC3B,KAAM,CAAEpwB,WAAAA,CAAW,EAAI,KAAKijB,aAAamN,CAAQ,EAC7CpwB,GACA,KAAK2xB,oBAAoB3xB,EAAY,EAAI,CAEjD,CACAZ,QAAQ1N,EAAO,CACX,MAAM0N,QAAQ1N,CAAK,EACf,CAACA,EAAMsO,YAAc,KAAKyL,cAC1B,KAAKD,YAAW,CAExB,CACA6mB,SAAS3gC,EAAO,CACZ,KAAKs/B,WAAWt/B,EAAO,EAAI,CAC/B,CACA4gC,WAAW5gC,EAAO,CACd,KAAKo/B,aAAap/B,EAAO,EAAI,CACjC,CACA6gC,WAAW7gC,EAAO,CACd,KAAKm/B,aAAan/B,EAAO,EAAI,CACjC,CACA8gC,YAAY9gC,EAAO,CACf,KAAKk/B,cAAcl/B,EAAO,EAAI,CAClC,CAGA+8B,aAAapgC,EAAM,CAAA,IAAAqgC,GACfA,EAAA,MAAMD,gBAAYC,MAAAA,IAAlBA,QAAAA,EAAAjxB,KAAqBpP,KAAAA,CAAI,EACzB,KAAM,CAAE2R,WAAAA,EAAY2uB,WAAAA,CAAW,EAAItgC,EACnCsgC,EAAWnzB,MAAM,YAAY,EAAI,KAAKmL,WAAW3G,CAAU,CAC/D,CACAyyB,aAAapkC,EAAM,CAAA,IAAAqkC,GACfA,EAAA,MAAMD,gBAAYC,MAAAA,IAAlBA,QAAAA,EAAAj1B,KAAqBpP,KAAAA,CAAI,EACzB,KAAM,CAAEskC,WAAAA,CAAW,EAAItkC,EACvBskC,EAAWn3B,MAAM,iBAAiB,EAAI4H,EAAQ,KAAKgC,cAAc1P,MACrE,CAEJ,EA9MIhH,EAFqB6e,EAEd1b,QAAQ,iBACfnD,EAHqB6e,EAGd3e,eAAe,CAMlBwW,cAAgB,CAAA,EAiBhBssB,iBAAmB,KACnBruB,OAAS,CACL,IAAqB,iBACrB,SAAqB,uBACrB,kBAAqB,aACrB,kBAAqB,aACrB,gBAAqB,WACrB,mBAAqB,aACzB,IAlCiBkK,GCVV,MAAMqlB,WAAkBrzB,CAAS,CAqC5C,OAAOoZ,OAAO,CAAE9I,UAAAA,EAAWxB,MAAAA,EAAO3T,OAAAA,CAAO,EAAG,CAEpC2T,GACAha,OAAOC,OAAOub,EAAW,CACrBtU,IAAY,MACZs3B,KAAan4B,EAAOo4B,SAAW,IAAMzkB,EACrCpf,UAAY,EAChB,CAAC,CAET,CACJ,CA9CIP,EADiBkkC,GACV/gC,QAAQ,aACfnD,EAFiBkkC,GAEV9gC,OAAO,SAkCdpD,EApCiBkkC,GAoCVlzB,gBAAgB,MAY3BkzB,GAAU3gC,UAAS,EACnB2gC,GAAU/jC,OAAS,YChDJ,MAAMkkC,UAAqBxzB,CAAS,CAsC/C,OAAOoZ,OAAO,CAAE9I,UAAAA,EAAWxB,MAAAA,EAAO3T,OAAAA,CAAO,EAAG,CACxC,MAAMs4B,EAAUviC,KAAK0Z,MAAM,IAAMkE,GAAS3T,EAAOwP,KAAO,IAAI,EAAI,IAChE2F,EAAUnY,SAAW,CACjB,CACI8D,MAAU,+BACVsC,QAAU,CACNk1B,QAAAA,GAEJt7B,SAAW,CACP,CACI8D,MAAQ,gCACR9H,MAAQ,CACJM,MAAQg/B,GAEZl1B,QAAU,CACNk1B,QAAAA,CACJ,EACH,CAET,CAAC,EAELnjB,EAAU/R,QAAQk1B,QAAUnjB,EAAU/R,QAAQuS,KAAO2iB,CACzD,CACJ,CA5DItkC,EADiBqkC,EACVlhC,QAAQ,gBACfnD,EAFiBqkC,EAEVjhC,OAAO,YACdpD,EAHiBqkC,EAGVnkC,eAAe,IAkCtBF,EArCiBqkC,EAqCVrzB,gBAAgB,MAyB3BqzB,EAAa9gC,UAAS,EACtB8gC,EAAalkC,OAAS,eC/DP,MAAMokC,WAAmB1zB,CAAS,CAoC7C,OAAOoZ,OAAO,CAAE9I,UAAAA,EAAWxB,MAAAA,EAAO3T,OAAAA,CAAO,EAAG,CACxC,KAAM,CAAEwP,IAAAA,EAAMmE,CAAM,EAAI3T,EACxBmV,EAAUnY,SAAW,CAAA,EACrB,QAASjD,EAAI,EAAGA,EAAIyV,EAAKzV,IACrBob,EAAUnY,SAASkD,KAAK,CACpBW,IAAQ,IACRC,MAAQ,CACJ,qBAAuB,EACvB,WAAuB/G,EAAI4Z,CAC/B,CACJ,CAAC,CAET,CACJ,CAhDI3f,EADiBukC,GACVphC,QAAQ,cACfnD,EAFiBukC,GAEVnhC,OAAO,UAiCdpD,EAnCiBukC,GAmCVvzB,gBAAgB,MAe3BuzB,GAAWhhC,UAAS,EACpBghC,GAAWpkC,OAAS,aCtDL,MAAMqkC,WAAsB3zB,CAAS,CAOhD,OAAOoZ,OAAO,CAAE9I,UAAAA,CAAU,EAAG,CACzBA,EAAUtU,IAAM,IACpB,CACJ,CATI7M,EADiBwkC,GACVrhC,QAAQ,iBACfnD,EAFiBwkC,GAEVphC,OAAO,aAIdpD,EANiBwkC,GAMVxzB,gBAAgB,MAK3BwzB,GAAcjhC,UAAS,EACvBihC,GAAcrkC,OAAS,gBCHR,MAAMskC,WAAiBjlB,GAAMhgB,MAAMmf,CAAe,CAAE,CAmB/D+lB,gBAAiB,CAAA,IAAAC,EACb,MAAMrkC,EAAK,KAEX,GAAI,GAAAqkC,EAACrkC,EAAG8rB,SAAK,MAAAuY,IAARA,QAAAA,EAAUziC,QAAS5B,EAAG6D,WAAa7D,EAAGgS,KAAM,CAC7C,KACI,CAAEA,KAAAA,EAAM0sB,UAAAA,CAAU,EAAI1+B,EACtBskC,EAAsB,CAAA,EAC1BtkC,EAAG6D,UAAU0W,QAAQD,UAAU/U,QAAQoV,GAAQ,CAC3C,MAAM4pB,EAAW5pB,EAAK3I,CAAI,EACtBuyB,IACI,OAAOA,GAAa,SACpBD,EAAK14B,KAAK,GAAG24B,EAASlF,MAAMX,CAAS,CAAC,EAGtC4F,EAAK14B,KAAK,GAAG24B,CAAQ,EAGjC,CAAC,EACDvkC,EAAG+B,MAAQ,CAAC,GAAG,IAAIyiC,IAAIF,CAAI,CAAC,EAAE9tB,KAAI,EAE1C,CACAiuB,YAAYplB,EAAOmC,EAAK,CACpB,KAAKkjB,eAAiB,GAClB,KAAKhG,WAAa,OAAOrf,GAAU,WACnCA,EAAQA,EAAMggB,MAAM,KAAKX,SAAS,EAClC,KAAKgG,eAAiB,IAE1B,MAAMD,YAAYplB,EAAOmC,CAAG,CAChC,CACA,IAAInC,OAAQ,CACR,MAAMA,EAAQ,MAAMA,MACpB,OAAI,KAAKqlB,eACErlB,EAAMqK,KAAK,KAAKgV,SAAS,EAE7Brf,CACX,CACA,IAAIA,MAAMA,EAAO,CACb,MAAMA,MAAQA,CAClB,CACJ,CAzDI3f,EADiBykC,GACVthC,QAAQ,YACfnD,EAFiBykC,GAEVrhC,OAAO,YACdpD,EAHiBykC,GAGVvkC,eAAe,CAClB4gB,YAAc,GACdZ,SAAc,GAMd8e,UAAY,IACZze,OAAS,CACLvR,IAAM,gBAEViT,SAAW,CACPuC,SAAW,EACf,IA0CRigB,GAASlhC,UAAS,EAClBkhC,GAAStkC,OAAS,WCvDH,MAAM8kC,WAAiBp0B,CAAS,CA8F3C,OAAOoZ,OAAO,CAAE9I,UAAAA,EAAWxB,MAAAA,EAAO3T,OAAAA,CAAO,EAAG,CACxC,IAAI44B,EACAjlB,IACI,OAAOA,GAAU,SACjBilB,EAAOjlB,EAAMggB,MAAM3zB,EAAOgzB,WAAa,GAAG,EAAEx2B,IAAI08B,IAAQ,CAAEziC,KAAOyiC,CAAI,EAAE,EAElE7xB,MAAM8xB,QAAQxlB,CAAK,IACxBilB,EAAOjlB,EAAMnX,IAAIknB,GACT,OAAOA,GAAU,SACV,CAAEjtB,KAAOitB,GAGT,CACHjtB,KAAOuJ,EAAOo5B,cAAgB1V,EAAM1jB,EAAOo5B,YAAY,EACvDp2B,IAAOhD,EAAOq5B,aAAe3V,EAAM1jB,EAAOq5B,WAAW,EAGhE,GAEDT,IACAzjB,EAAUnY,SAAW47B,EAAKp8B,IAAIqE,GAAO,CACjC,MAAMmC,EAAO,QAASnC,EAAOA,EAAImC,IAAMpK,EAAU0gC,YAAYz4B,EAAIpK,KAAM,GAAG,EAAE8iC,YAAW,EACvF,MAAO,CACHz4B,MAAQ,CACJ,uBAAyB,EACzB,CAACkC,CAAG,EAAqB0F,EAAQ1F,GAErCvM,KAAOoK,EAAIpK,KAEnB,CAAC,GAGb,CACJ,CA9HIzC,EADiBilC,GACV9hC,QAAQ,YACfnD,EAFiBilC,GAEV7hC,OAAO,QA2FdpD,EA7FiBilC,GA6FVj0B,gBAAgB,CAAE5N,KAAO,WAAYy7B,YAAc,SAmC9DoG,GAAS1hC,UAAS,EAClB0hC,GAAS9kC,OAAS,WC9IH,MAAMqlC,WAAqB30B,CAAS,CAoC/C,OAAOoZ,OAAO,CAAE9I,UAAAA,EAAWxB,MAAAA,EAAO3T,OAAAA,EAAQsF,WAAAA,CAAW,EAAG,CACpD,MAAM8O,EAAOpU,EAAO2c,SAAS,CAAErX,WAAAA,EAAYtF,OAAAA,EAAQ2T,MAAAA,CAAM,CAAC,EACtD,OAAOS,GAAS,SAChBe,EAAUf,KAAOA,EAEZhU,EAAaq5B,SAASrlB,CAAI,EAC/BhU,EAAawC,MAAMuS,EAAWf,CAAI,EAE7B/M,MAAM8xB,QAAQ/kB,CAAI,IACvBe,EAAUnY,SAAWoX,EAE7B,CACJ,CA/CIpgB,EADiBwlC,GACVriC,QAAQ,gBACfnD,EAFiBwlC,GAEVpiC,OAAO,YAiCdpD,EAnCiBwlC,GAmCVx0B,gBAAgB,MAc3Bw0B,GAAajiC,UAAS,EACtBiiC,GAAarlC,OAAS,eCJP,MAAMulC,WAAqB70B,CAAS,CA+B/C,OAAOoZ,OAAO,CAAE9I,UAAAA,EAAWxB,MAAAA,EAAO3T,OAAAA,EAAQsF,WAAAA,CAAW,EAAG,CACpD,GAAIqO,EAAO,CACP,KAAM,CACFgmB,UAAAA,EAAY,OACZC,aAAAA,EAAe,UACfC,SAAAA,EAAW,MACXC,YAAAA,EAAc,wBACdC,cAAAA,EAAgB,yBACpB,EAAI/5B,EACJ,GAAI,KAAKg6B,cAAgB,IAEjB,CADc10B,EAAW2sB,mBAAmBjyB,EAAO4F,KAAK,EAC7Cq0B,iBACX,MAAM,IAAI3mB,MAAM,gEAAgE,EAGxF6B,EAAUnY,SAAW2W,EAAMnX,IAAI,CAAC09B,EAAM3yB,KAAW,CAC7CzG,MAAQ,CACJ,4BAA8B,EAC9B,CAACo5B,EAAKL,CAAQ,CAAC,EAAeK,EAAKL,CAAQ,EAC3C,YAA8BK,EAAKN,CAAY,GAEnD58B,SAAW,CACPtG,KAAO,CACHmK,IAAQ,IACRC,MAAQo5B,EAAKN,CAAY,EAAIE,EAAcC,GAE/CtjC,KAAO,CACHoK,IAAO,OACPpK,KAAOyjC,EAAKP,CAAS,CACzB,GAEJl9B,YAAc,CACV8K,MAAAA,CACJ,CACJ,EAAE,EACF,KAAKyyB,YAAc,GAE3B,CACA,OAAOt1B,QAAQ,CAAEF,OAASrM,EAAWmN,WAAAA,EAAYtO,MAAAA,EAAOgJ,OAAAA,CAAO,EAAG,CAC9D,MAAMlG,EAAU9C,EAAMmK,OAAO3G,QAAQ,4BAA4B,EACjE,GAAIV,GAAW,CAACwL,EAAW/O,SAAU,CACjC,KACI,CAAEqjC,aAAAA,EAAe,UAAWh0B,MAAAA,CAAM,EAAI5F,EACtC,CAAEuH,MAAAA,GAAoCzN,EAAQ2C,YAE9C83B,EAAsCjvB,EAAWqU,SAAS/T,CAAK,EAAEsG,MAAK,EACtEguB,EAAsC3F,EAAMhtB,CAAK,EAErD2yB,EAAKN,CAAY,EAAI,CAACM,EAAKN,CAAY,EAEvCt0B,EAAWuW,SAASjW,EAAO2uB,CAAK,EAChCp8B,EAAUlB,QAAQ,aAAc,CAAEqO,WAAAA,EAAY40B,KAAAA,EAAMve,QAAUue,EAAKN,CAAY,EAAG9/B,QAAAA,EAAS9C,MAAAA,CAAM,CAAC,EAElGA,EAAMoR,eAAc,EAE5B,CAEA,OAAOusB,WAAW,CAAE39B,MAAAA,CAAM,EAAG,CACzBA,EAAMoR,eAAc,CACxB,CACJ,CA1FIpU,EADiB0lC,GACVviC,QAAQ,gBACfnD,EAFiB0lC,GAEVtiC,OAAO,YA4BdpD,EA9BiB0lC,GA8BV10B,gBAAgB,MA8D3B00B,GAAaniC,UAAS,EACtBmiC,GAAavlC,OAAS,eCtJtB,MAAMgmC,GAAS,CACXC,WAAa,KACbC,WAAa,eACbC,WAAa,QACbC,SAAW,CACPC,kBAAoB,uBACpBC,kBAAoB,gCAExBC,gBAAkB,CACdC,oBAAsB,oBAE1BC,UAAY,CACRt2B,OAAmB,SACnB5O,QAAmB,UACnBmlC,QAAmB,UACnBtgC,SAAmB,WACnB+C,UAAmB,YACnBw9B,UAAmB,YACnB7rB,KAAmB,OACnBF,MAAmB,QACnB9N,QAAmB,wBACnBwF,OAAmB,SACnBs0B,aAAmB,6BACnBC,eAAmB,+BACnBzc,SAAmB9nB,GAAS,YAAWA,IACvCoQ,MAAmB,QACnBmS,YAAmB,cACnB3T,SAAmB,yBACnBmZ,OAAmB/nB,GAAS,UAASA,IACrCwkC,cAAmB,8BACnBC,gBAAmB,gCACnBC,YAAmB,4BACnB3kC,eAAmB,gCACnBK,gBAAmB,iCACnByP,KAAmB,OACnB80B,YAAmB,wBACnB/e,WAAmB,2BACnBgf,YAAmB,4BACnBrkB,UAAmB,YACnBskB,KAAmB,OACnB9P,eAAmB,gCACnBN,iBAAmB,kCACnBqQ,KAAmB,QAEvBC,cAAgB,CACZhgC,IAAU,MACVigC,QAAU,YAEdC,SAAW,CACPC,eAAiB,OACjBC,eAAiB,MACrB,CACJ,EACeC,GAAaC,cAAc3B,EAAM,ECzBhD,MAAM4B,GAAeA,CAAChxB,EAAGC,IAAMD,EAAEpU,OAASqU,EAAErU,OAuC7B,MAAMqlC,UAAsBC,GAAMzoC,MAC7C0oC,GACAC,GACAC,GACAC,GACA3B,GACA/Z,GACA2b,GACA3Z,GACA+B,GACAkC,GACAoB,GACAyC,GACA4C,GACA2C,GACAU,GACA2C,GACAwB,GACAgC,EACJ,CAAE,CAnBa,kCAgQX0F,EAAAA,2BAAyB,IACzB9M,EAAAA,8BAAyB,GACzB+M,EAAAA,4BAAyB,IAAI36B,KAM7B46B,iBAAkB,CAEd,CAEJ/R,WAAW/2B,EAAM,CACT,KAAK8oC,gBAAe,GAGxB,MAAM/R,QAAQ,GAAG/2B,CAAI,CACzB,CAGA+oC,wBAAwBhnB,EAAmB,CACvCtV,OAAAA,EAAaqZ,aAAa/D,EAAmB,mBAAmB,EACzDA,CACX,CACAinB,uBAAuBnN,EAAkB,CACrCpvB,OAAAA,EAAagF,cAAcoqB,EAAkB,kBAAkB,EACxDA,CACX,CACAoN,oBAAoBtQ,EAAe,CAC/BlsB,OAAAA,EAAagF,cAAcknB,EAAe,eAAe,EAClDA,CACX,CACAuQ,oBAAoBhhC,EAAeihC,EAAkB,CAEjD,OADAA,GAAgB,MAAhBA,EAAkBznC,QAAO,EACrBwG,EACOkhC,GAActoC,IAAI,CACrBqF,QAAU,KAAKA,QACfhF,MAAU,MACX+G,CAAa,EAEb,IACX,CACAmhC,wBAAwBC,EAAmB,CACvC78B,OAAAA,EAAagF,cAAc63B,EAAmB,mBAAmB,EAC1DA,CACX,CACAC,kBAAkBjwB,EAAa,CAC3B7M,OAAAA,EAAakQ,aAAarD,EAAa,aAAa,EAC7CA,CACX,CACAkwB,uBAAuBC,EAAkB,CACrCh9B,OAAAA,EAAaI,eAAe48B,EAAkB,kBAAkB,EACzDA,CACX,CACAC,mBAAmBC,EAAc,CAC7Bl9B,OAAAA,EAAaI,eAAe88B,EAAc,cAAc,EACjDA,CACX,CACAC,mBAAmBh9B,EAAI,CACnB,OAAIA,IAAO,GACAw7B,IAEXx7B,GAAMH,EAAaI,eAAeD,EAAI,cAAc,EAC7CA,EACX,CAIAkxB,qBAAqBh8B,EAAc4H,EAAgB,CAC/C,KAAKm/B,qBAAqBj5B,IAAK,GAAE9N,EAAa2O,QAAQ/G,GAAc,KAAA,OAAdA,EAAgB+G,KAAM,CAAE3O,aAAAA,EAAc4H,eAAAA,CAAe,CAAC,EAC5G,KAAKmgC,iBAAgB,CACzB,CAEAA,kBAAmB,CACf,SAAW,CAAA,CAAG,CAAE/nC,aAAAA,EAAc4H,eAAAA,CAAe,CAAC,IAAK,KAAKm/B,qBACpD,KAAKiB,gBAAgBhoC,EAAc4H,CAAc,EAErD,KAAKm/B,qBAAqBkB,MAAK,CACnC,CAEAD,gBAAgBhoC,EAAc4H,EAAgB,CAC1C,MACIvD,EAAY,KAAKwtB,yBAAyBjqB,EAAgB5H,CAAY,EACtE0f,EAAYvc,EAAU+kC,kBAAkB,KAAKC,aAAavgC,EAAgB5H,CAAY,CAAC,EAC3F0f,EAAU0oB,aAAe,GACzBnjC,EAAQsa,KAAK,CACTC,cAAgBnb,EAChBqb,UAAAA,EACA2oB,SAAgB,KAAKhV,gBACrB6J,YAAgB,CACZC,YAAmB,SACnBmL,iBAAmB,CACvB,CACJ,CAAC,CACL,CAIAlM,WAAWvsB,EAAY7P,EAAc4H,EAAgB,OAAA,IAAAs0B,EAAAqM,EAEjD,MAAMC,EAAiB,MAAMpM,WAAWvsB,EAAY7P,EAAc4H,CAAc,EAChF,GAAI4gC,EACA,OAAOA,EAEX,MACI3pC,EAAoC,KACpC,CAAE8P,GAAAA,EAAI7G,MAAAA,EAAO+Q,WAAAA,EAAY3X,OAAAA,CAAO,EAAI2O,EACpCuB,EAAoCyH,IAAcjR,GAAAA,KAAAA,OAAAA,EAAgBwJ,QAASpR,EAAaoR,MACxFq3B,EAAoCtlC,EAAU4V,aAAa3H,CAAK,EAAIA,EAAQ,KAC5Egd,EAAoCvvB,EAAG0uB,YAAYvtB,EAAc4H,CAAc,EAC/E42B,EAAoC,CAChC7vB,GAAS,GAAE9P,EAAG8P,WAAW7G,IACzBuD,MAAQ,CACJ,mBAAsC,GACtC,CAAE,qBAAoBo9B,GAAY,EAAIA,EACtC,aAAsC54B,EAAW/O,SACjD,GAAG+O,EAAWtC,KAElB4uB,SAAW,EACXxuB,QAAW,CACP6L,KAAgB1R,EAChB+G,OAAgB7O,EAAa2O,GAC7BqK,KAAgBpR,GAAc,KAAdA,OAAAA,EAAgB+G,GAChCzN,OAAAA,EACA2M,cAAgB,IAEpBtK,MAAQ,CACJ6N,MAASq3B,EAAa,KAAOr3B,EAC7BxM,QAASs3B,GAAAA,EAAAr9B,EAAGk4B,iBAAamF,MAAAA,IAAhBA,OAAAA,OAAAA,EAAA5uB,KAAAzO,EAAmBgR,CAAU,IAA7BqsB,KAAAA,EAAkC,MAE/Cl1B,YAAc,CACVwsB,YAAc,OACd9Z,OAAc/K,EACdkB,WAAAA,EACA7P,aAAAA,EACA4H,eAAAA,GAEJL,SAAW,CACPvC,OAAS,CACLoG,IAAQ,SACRC,MAAQ,CACJ,0BAA4B,GAEhC9D,SAAc,CAAA,EACd21B,YAAc,CACVC,YAAc,MAClB,GAEJh4B,KAAO,CACHiG,IAAQ,UACRC,MAAQ,CACJ,wBAA0B,GAE9B9D,SAAc,CAAA,EACd21B,YAAc,CACVC,YAAc,MAClB,GAEJ0B,OAAS,CACLzzB,IAAQ,SACRC,MAAQ,CACJ,0BAA4B,GAEhC9D,SAAc,CAAA,EACd21B,YAAc,CACVC,YAAc,MAClB,CACJ,CACJ,GAEJ,CAAE51B,SAAAA,CAAS,EAAgBi3B,EAC3B,CAAEx5B,OAAAA,EAAQG,KAAAA,EAAM05B,OAAAA,CAAO,EAAIt3B,EAE/B1I,OAAAA,EAAGy/B,aAAa,CACZzuB,WAAAA,EACA7P,aAAAA,EACA4H,eAAAA,EACA42B,WAAAA,EACApQ,SAAAA,CACJ,CAAC,GAEDma,EAAA1pC,EAAGgpC,gBAAY,MAAAU,IAAA,QAAfA,EAAAj7B,KAAAzO,EAAkB,CACdgR,WAAAA,EACA7P,aAAAA,EACA4H,eAAAA,EACA42B,WAAAA,EACApQ,SAAAA,CACJ,CAAC,EAEGppB,EAAO2Z,MAAQ,MAAQ3Z,EAAOhE,MAAQ,OAAS,CAACgE,EAAOuC,UAAYrD,OAAOwkC,KAAK1jC,EAAOuC,QAAQ,EAAEhC,SAAW,KAC3GgC,EAASvC,OAAS,MAElBG,EAAKwZ,MAAQ,MAAQxZ,EAAKnE,MAAQ,OAAS,CAACmE,EAAKoC,UAAYrD,OAAOwkC,KAAKvjC,EAAKoC,QAAQ,EAAEhC,SAAW,KACnGgC,EAASpC,KAAO,MAEhB05B,EAAOlgB,MAAQ,MAAQkgB,EAAO79B,MAAQ,OAAS,CAAC69B,EAAOt3B,UAAYrD,OAAOwkC,KAAK7J,EAAOt3B,QAAQ,EAAEhC,SAAW,KAC3GgC,EAASs3B,OAAS,MAEfL,CACX,CACAmK,mBAAmB3oC,EAAc,OAAA,IAAA4oC,EAAAC,EAC7B,MACIhqC,EAAqB,KACrB,CAAEmC,KAAAA,EAAM2N,GAAAA,EAAI7G,MAAAA,EAAOjE,MAAAA,EAAO+B,KAAAA,EAAMkjC,SAAAA,EAAU13B,MAAAA,EAAOlC,QAAAA,CAAQ,EAAIlP,EAC7DyoC,EAAqBtlC,EAAU4V,aAAa3H,CAAK,EAAIA,EAAQ,KAC7DnG,EAAqB,CACjB0D,GAAS,GAAE9P,EAAG8P,oBAAoB7G,IAClCuD,MAAQ,CACJ,4BAAsC,EACtC,gBAAsCxH,GAAS,CAAC+B,EAChD,CAAE,qBAAoB6iC,GAAY,EAAIA,EACtC,SAAsCzoC,IAAiB,KAAKC,QAAQ8oC,MAExExlC,MAAQ,CACJ6N,MAAQq3B,EAAa,KAAOr3B,EAC5BvN,MAAAA,EACA+B,KAAAA,EACAkjC,SAAAA,GAEJvhC,SAAW,CACP2D,OAAS,CACLG,MAAQ,CACJ,mCAAqC,GAEzC9D,SAAW,CACP6b,MAAQ,CACJ/X,MAAQ,CACJ,2BAA6B,GAEjCsC,QAAU,CACNuS,KAAOhR,GAEX3H,SAAW,CACP,CACI6D,IAAQ,OACRC,MAAQ,sBACRrK,KAAAA,CACJ,EACAnC,EAAG2oC,mBAAqB,CACpBp8B,IAAQ,OACRC,MAAQ,CACJ,2BAA6B,GAEjCsT,KAAQ,KAAGiqB,GAAAA,EAAA/pC,EAAG+pB,eAAe5oB,CAAY,KAAC,MAAA4oC,IAAA,OAAA,OAA/BA,EAAiCrjC,SAAjCqjC,KAAAA,EAA2C,KACzD,CAET,CACJ,CACJ,GAEJj7B,QAAU,CACNkB,OAAgB/G,EAChB+F,cAAgB,IAEpB7G,YAAc,CACVwsB,YAAc,eACdnlB,SAAcM,CAClB,GAER2Y,OAAAA,GAAQ0hB,aAAe,GAEvBnqC,EAAGmM,qBAAqB,CACpBhL,aAAAA,EACAiL,mBAAAA,CACJ,CAAC,GAED49B,EAAAhqC,EAAGoqC,wBAAoB,MAAAJ,IAAA,QAAvBA,EAAAv7B,KAAAzO,EAA0B,CACtBmB,aAAAA,EACAiL,mBAAAA,CACJ,CAAC,EACMA,CACX,CACAk9B,aAAavgC,EAAgB5H,EAAc,SAAA,IAAAkpC,EACvC,MACIrqC,EAAgB,KAChB,CACIyb,aAAAA,EACA6uB,aAAAA,EACAlwB,YAAAA,EACAC,cAAAA,CACJ,EAAgBra,EAChB,CACIgF,MAAAA,EACA+B,KAAAA,EACA+I,GAAAA,EACA7G,MAAAA,EACAghC,SAAAA,EACA13B,MAAAA,CACJ,EAAgBpR,EAChB,CAAEmZ,UAAAA,GAActa,EAAGua,QAGnBE,EAAgBH,EAAUiwB,OACpBjwB,EAAUuE,MAAMhI,GACdA,EAAEuD,CAAW,IAAMtK,IAClB,CAACuK,GAAiB,CAACtR,GAAkB8N,EAAEwD,CAAa,IAAMtR,EAAe+G,GAC9E,EACEiD,MAAM/O,KAAKsW,EAAUmW,QAAQsB,SAC3B,6BACC,GAAE5wB,EAAa2O,SAAQ/G,EAAAA,GAAAA,KAAc,OAAdA,EAAgB+G,KAAhB/G,KAAAA,EAAsB,WAClD,GAAK,CAAA,CAAE,EACX4lB,EAAe3uB,EAAG4uB,eAAeztB,EAAc4H,CAAc,EAC7DyhC,EAAgB,GAAExqC,EAAG8P,cAAa/G,EAAAA,GAAc,KAAA,OAAdA,EAAgBE,QAAhBF,KAAAA,EAAyB,aAAaE,IACxE2gC,EAAetlC,EAAU4V,aAAa3H,CAAK,EAAIA,EAAQ,KACvDpD,EAAe,CACXW,GAAQ06B,EACRh+B,MAAQ,CACJ,qBAAuD,EACvD,gBAAuDxH,GAAS,CAAC+B,EACjE,CAAE,KAAI4nB,SAAcA,EAAS,EAAI,IAAM,YAAY,EAAI,EACvD,WAAuDA,EAAS,EAChE,CAAE,qBAAoBib,GAAY,EAAqBA,EACvD,SAAuDzoC,IAAiB,KAAKC,QAAQ8oC,MAEzFxlC,MAAQ,CACJ6N,MAAQq3B,EAAa,KAAOr3B,EAC5BvN,MAAAA,EACA+B,KAAAA,EACAkjC,SAAAA,GAEJn7B,QAAU,CACNkB,OAAgB/G,EAChBkR,KAAgBpR,GAAc,KAAdA,OAAAA,EAAgB+G,GAChCd,cAAgB,IAEpB7G,YAAc,CACVwsB,YAAc,SACdnlB,SAAcM,EACd4iB,OAAc3pB,GAAc,KAAA,OAAdA,EAAgB+G,IAGlCpH,SAAW,CACPpC,KAAO,CACHwJ,GAAS,GAAE06B,SACXh+B,MAAQ,CACJ,0BAA4B,GAEhCsC,QAAU,CACNC,KAAgB,OAChBC,cAAgB,IAEpBtG,SAAW,CACP,CACI8D,MAAQ,CACJ,gCAAkC,GAEtC9H,MAAQ,CACJ,wBAA2B,UAAS4lC,EAAe7oC,KAAKC,IAAIitB,EAAQlU,EAAM/T,MAAM,EAAIioB,WAExF7f,QAAU,CACNC,KAAgB,QAChBC,cAAgB,IAEpBtG,UAAY,KAEJ+S,EACAhB,EAAMjE,KAAKiF,CAAY,EAIvBhB,EAAMjE,KAAK,CAACC,EAAGC,IAAM4D,EAAU3Y,QAAQ8U,CAAC,EAAI6D,EAAU3Y,QAAQ+U,CAAC,CAAC,EAE7D+D,EAAMvS,IAAI8I,GAAchR,EAAGu9B,WAAWvsB,EAAY7P,EAAc4H,CAAc,CAAC,IACzF,EACDs1B,YAAc,CACVC,YAAmB,OACnBmL,iBAAmBzpC,EAAGi1B,cAAgB,IAAO,CACjD,CACJ,CAAC,EAELoJ,YAAc,CACVC,YAAc,MAClB,CACJ,GAEJD,YAAc,CACVC,YAAc,MAClB,GAGRt+B,OAAAA,EAAGkP,eAAe,CACd/N,aAAAA,EACA4H,eAAAA,EACAoG,aAAAA,CACJ,CAAC,GAEDk7B,EAAArqC,EAAGyqC,kBAAc,MAAAJ,IAAA,QAAjBA,EAAA57B,KAAAzO,EAAoB,CAChBmB,aAAAA,EACA4H,eAAAA,EACAoG,aAAAA,CACJ,CAAC,EACMA,CACX,CACAu7B,eAAe3hC,EAAgB,OAAA,IAAA4hC,EAAAC,EAC3B,MACI5qC,EAAiC,KACjC,CAAE2oC,kBAAAA,EAAmBvnC,QAAAA,CAAQ,EAAIpB,EACjC,CACI8P,GAAAA,EAAK,UACL7G,MAAAA,EAAQ,UACR9G,KAAAA,EACA4D,OAAAA,EACAgB,KAAAA,EACAwL,MAAAA,CACJ,EAAiCxJ,GAAkB,CAAA,EACnDyhC,EAAkC,GAAExqC,EAAG8P,eAAe7G,IACtD2gC,EAAiCtlC,EAAU4V,aAAa3H,CAAK,EAAIA,EAAQ,KACzE2b,EAAiC,CAC7Bpe,GAAQ06B,EACRh+B,MAAQ,CACJ,uBAAsC,EACtC,iBAAsCzG,GAAU,CAACgB,EACjD,SAAsC,CAACgC,GAAkBA,IAAmB/I,EAAGgJ,UAAUkhC,KACzF,CAAE,qBAAoBN,GAAY,EAAIA,GAE1CllC,MAAQ,CACJ6N,MAAQq3B,EAAa,KAAOr3B,EAC5BxM,OAAAA,EACAgB,KAAAA,GAEJ+H,QAAU,CACNqL,KAAgBlR,EAChB+F,cAAgB,IAEpB7G,YAAc,CACVwsB,YAAc,WACdjC,OAAc5iB,GAElBpH,SAAW,CAEPvC,OAAS4C,GAAkB,CACvB+G,GAAS,GAAE06B,WACXj+B,IAAQ,SACRC,MAAQ,CACJ,8BAAgC,GAEpCsC,QAAU,CACNC,KAAgB,SAChBC,cAAgB,oBAEpBtG,SAAW,CACP6b,MAAQ,CACJ/X,MAAQ,CACJ,6BAA+B,GAEnC9D,SAAW,CACPvG,KAAAA,EACAP,MAAQ+mC,GAAqB,CACzBp8B,IAAQ,OACRC,MAAQ,CACJ,6BAA+B,GAEnCrK,KAAQ,KAAGwoC,GAAAA,EAAA3qC,EAAGosB,iBAAiBrjB,CAAc,KAAC,MAAA4hC,IAAA,OAAA,OAAnCA,EAAqC7b,OAArC6b,KAAAA,EAA6C,IAC5D,CACJ,CACJ,CACJ,GAGJrkC,KAAO,CACHwJ,GAAS,GAAE06B,SACXh+B,MAAQ,CACJ,4BAA8B,GAElCsC,QAAU,CACNC,KAAgB,OAChBC,cAAgB,IAGpBtG,SAAWtH,EAAQ8G,IAAI8H,GACnB,CAACA,EAAOkT,QAAUljB,EAAGspC,aAAavgC,EAAgBiH,CAAM,CAC5D,EACAquB,YAAc,CACVC,YAAmB,SACnBmL,iBAAmB,CACvB,CACJ,GAEJpL,YAAc,CACVC,YAAc,MAClB,GAERt+B,OAAAA,EAAGguB,iBAAiB,CAChBjlB,eAAAA,EACAmlB,eAAAA,CACJ,CAAC,GAED0c,EAAA5qC,EAAG8oC,oBAAgB,MAAA8B,IAAA,QAAnBA,EAAAn8B,KAAAzO,EAAsB,CAClB+I,eAAAA,EACAmlB,eAAAA,CACJ,CAAC,EACMA,CACX,CAEA,IAAIyV,YAAa,CAAA,IAAAzH,EACb,MACIl8B,EAAK,KAEL,CAEIg4B,cAAAA,EACA2Q,kBAAAA,EACAvnC,QAAAA,EACAgZ,YAAAA,EACAC,cAAAA,EACA1B,YAAAA,EACAoX,YAAAA,EACAC,UAAAA,EACA8P,YAAAA,EACA1pB,cAAAA,EACAoW,qBAAAA,EACAoB,oBAAAA,EACAnS,aAAAA,EACA6uB,aAAAA,CAEJ,EAAKtqC,EAGT,GAAI,CAACA,EAAG6qC,SAEJ7qC,OAAAA,EAAG0P,WAAW,IAAM1P,EAAGP,UAAS,EAAI,CAAC,EAC9B,CAEHggB,UAAY,cAIZhI,UAAY3L,EAAaxG,OAAO,CAAE1E,QAAUZ,GAAMA,EAAG8zB,YAAY,GAIzE,MAAM6P,EAAa,CAEfmH,UAAY,GACZrrB,UAAY,cACZjT,MAAY,CACR,mBAAqB,EACrB,mBAAqBwrB,GAEzBtvB,SAAW,CAEP,CACI6D,IAAQ,SACRuD,GAAS,GAAE9P,EAAG8P,oBACdtD,MAAQ,CACJ,6BAA+B,GAEnC9D,SAAWtH,EAAQ8G,IAAI8H,GAAU,CAACA,EAAOkT,QAAUljB,EAAG8pC,mBAAmB95B,CAAM,CAAC,EAChFlB,QAAW,CACPqL,KAAgB,SAChBnL,cAAgB,IAEpBqvB,YAAc,CACVC,YAAc,QAClB,CACJ,CAAC,EAELD,YAAc,CACVC,YAAmB,OACnBmL,iBAAmB,EACnBsB,WAAmB,UACvB,GAEJ,GAAI,CAAE/hC,UAAAA,CAAU,EAAIhJ,GAEhBk8B,EAAClzB,KAAS,MAAAkzB,IAATA,QAAAA,EAAWt6B,QACZoH,EAAY,CAAC,IAAI,GAGrB,UAAWmR,KAAQnR,EACVmR,GAAAA,MAAAA,EAAM+I,QACPygB,EAAWj7B,SAASkD,KAAK5L,EAAG0qC,eAAevwB,CAAI,CAAC,EAGxDna,OAAAA,EAAGyjC,aAAa,CACZE,WAAAA,CACJ,CAAC,EACD3jC,EAAGgrC,WAAa,GACTrH,CACX,CAEAlE,aAAapgC,EAAM,CAAA,IAAAqgC,GACfA,EAAA,MAAMD,gBAAYC,MAAAA,IAAlBA,QAAAA,EAAAjxB,KAAqBpP,KAAAA,CAAI,CAC7B,CACA6P,eAAe7P,EAAM,CAAA,IAAAouB,GACjBA,EAAA,MAAMve,kBAAcue,MAAAA,IAApBA,QAAAA,EAAAhf,KAAuBpP,KAAAA,CAAI,CAC/B,CACA8M,qBAAqB9M,EAAM,CAAA,IAAA0uB,GACvBA,EAAA,MAAM5hB,wBAAoB4hB,MAAAA,IAA1BA,QAAAA,EAAAtf,KAA6BpP,KAAAA,CAAI,CACrC,CACA2uB,iBAAiB3uB,EAAM,CAAA,IAAA4rC,GACnBA,EAAA,MAAMjd,oBAAgBid,MAAAA,IAAtBA,QAAAA,EAAAx8B,KAAyBpP,KAAAA,CAAI,CACjC,CACAokC,aAAapkC,EAAM,CAAA,IAAAqkC,GACfA,EAAA,MAAMD,gBAAYC,MAAAA,IAAlBA,QAAAA,EAAAj1B,KAAqBpP,KAAAA,CAAI,CAC7B,CACA6rC,gBAAiB,CACb,MAAMA,eAAc,EACpB,MAAMlrC,EAAK,KACP,CAACA,EAAGioC,qBAAuBjoC,EAAGgrC,aAC9BhrC,EAAGioC,oBAAsB,GACzBjoC,EAAGD,eAAc,GAEjBC,EAAGua,QAAQD,UAAU1Y,MAAQ,GAC7B5B,EAAG2C,QAAQ,cAAe,CAAEmT,YAAc9V,EAAGua,QAAQD,UAAU6wB,UAAW,CAAC,EAE/EnrC,EAAGorC,oBAAsB,IAC7B,CAEArrC,gBAAiB,CACb,KAAK4C,QAAQ,gBAAgB,CACjC,CAEA0oC,gBAAiB,CAAA,CACjBx7B,uBAAwB,CAAA,CACxBy7B,kBAAmB,CAAA,CACnBv7B,yBAA0B,CAAA,CAI1BrF,sBAAuB,CACnB,KAAKywB,wBACT,CAEAxwB,qBAAsB,CAClB,KAAKwwB,wBACT,CAEAtJ,2BAA2BJ,EAAS,CAChC,MAAMzxB,EAAK,KACPA,EAAGk7B,kBAAoB,CAACl7B,EAAGm7B,yBAC3Bn7B,EAAGorC,oBAAsB,CACrBtkB,SAAW,wBACXykB,SAAW,IACX/lC,QAAWxF,EAAGwrC,aACd,GAAG/Z,IAKPzxB,EAAGP,UAAUyvB,UACblvB,EAAGyrC,iBAAmB,GAGtBzrC,EAAGP,UAAS,CAEpB,CACAisC,iBAAkB,CACd,MAAMA,gBAAe,EAEjB,KAAKD,mBACL,KAAKA,iBAAmB,KACxB,KAAKhsC,UAAS,EAEtB,CAKAksC,iBAAiBla,EAAS,CACtB,MAAMnqB,EAAS,MAAMqkC,iBAAiBla,CAAO,EAC7C,OAAInqB,EAAOlG,SACP,OAAOkG,EAAOlG,QAAQ0pB,WAEnBxjB,CACX,CAGA6pB,SAAU,CACN,KAAK1xB,UAAS,CAClB,CACJ,CA14BIC,EArBiBgoC,EAqBV7kC,QAAQ,iBACfnD,EAtBiBgoC,EAsBV5kC,OAAO,iBACdpD,EAvBiBgoC,EAuBVkE,cAAc,CACjBC,QAAU7sC,IAEdU,EA1BiBgoC,EA0BV9nC,eAAe,CAIlBksC,OAAS,OAOTvwB,SAAW,GA+BXytB,aAAe,KAwBfF,iBAAmB,KAcnBnwB,YAAc,EAad2xB,aAAe,KAcf3B,kBAAoB,GAcpB3Q,cAAgB,GAoBhBkD,iBAAmB,GAgBnB9Z,kBAAoB,KAUpB2qB,aAAe,YAefxkC,cAAgB,CACZ8X,MAAQ,CAAA,EACRyC,QAAU,CAAC,UAAW,MAAM,GAiChCrG,aAAe,KAMf5M,0BAA4B,GAC5Bya,YAAc,GAId1H,WAAa,KAKjBliB,EAnQiBgoC,EAmQV9O,YAAY,CACfsQ,iBAAmB,QA4pB3BxB,EAAczkC,UAAS,EACvB41B,EAAcmT,WAAW,YAAa,OAAO,EAC7CtE,EAAc7nC,OAAS,gBCz9BR,MAAMosC,WAAqB17B,CAAS,CAO/C,OAAOoZ,OAAO,CAAE9lB,UAAAA,EAAWgd,UAAAA,CAAU,EAAG,CACpC,GAAI,CAAChd,EAAU0X,SAASojB,UAAY96B,EAAU0X,SAASojB,SAASt+B,SAC5D,MAAO,GAEXwgB,EAAUtU,IAAM,SAChBsU,EAAUrU,MAAM,+BAA+B,EAAI,CACvD,CACA,OAAO4D,QAAQ,CAAEF,OAASrM,EAAWnB,MAAAA,CAAM,EAAG,CAAA,IAAAwpC,GAC1CA,EAAAroC,EAAU0X,SAASojB,YAAQuN,MAAAA,IAAA,QAA3BA,EAA6Bp/B,gBAAgBpK,EAAO,CAAEmK,OAASnK,EAAMmK,MAAO,CAAC,CACjF,CACJ,CAhBInN,EADiBusC,GACVppC,QAAQ,gBACfnD,EAFiBusC,GAEVnpC,OAAO,YAIdpD,EANiBusC,GAMVv7B,gBAAgB,MAY3Bu7B,GAAahpC,UAAS,EACtBgpC,GAAapsC,OAAS,eCykBP,MAAMymC,WAAkBoB,CAAc,CA4BrD,CA3BIhoC,EADiB4mC,GACVzjC,QAAQ,aACfnD,EAFiB4mC,GAEVxjC,OAAO,aACdpD,EAHiB4mC,GAGV1mC,eAAe,CAgBlB2b,SAAW,CACP4wB,iBAAmB,GACnBC,eAAmB,GACnB5wB,SAAmB,GACnB6wB,eAAmB,GACnBC,SAAmB,GACnB3N,SAAmB,EACvB,IAGR2H,GAAUrjC,UAAS,EACnBqjC,GAAUzmC,OAAS,YCpmBJ,MAAM0sC,WAA0BC,GAAYttC,MAAMmf,CAAe,CAAE,CAgClF,CA/BI3e,EADiB6sC,GACV1pC,QAAQ,qBACfnD,EAFiB6sC,GAEVzpC,OAAO,qBACdpD,EAHiB6sC,GAGV3sC,eAAe,CAIlBksB,MAAQ,yBAORxa,MAAQ,OASRqR,MAAQ,6BACR3d,MAAQ,OACRynC,SAAW,CACPn2B,OAAS,CACL5H,IAAQ,uBACR3B,MAAQ,OACZ,CACJ,IAGRw/B,GAAkBtpC,UAAS,EAC3BspC,GAAkB1sC,OAAS,oBC9BZ,MAAM6sC,WAA2BC,GAAOztC,MAAMmf,CAAe,CAAE,CAY1EuuB,eAAe,CAAEv+B,KAAAA,CAAK,EAAG,CACrBA,EAAK2B,OAAOkT,OAAS,CAAC7U,EAAKgZ,OAC/B,CAEAwlB,iBAAiBC,EAAM,CACnB,MAAMD,iBAAiBC,CAAI,EAC3BA,EAAK58B,OAAOnO,MAAQ,KAAK8B,UAAUzC,QAAQ8G,IAAI8H,IAAW,CACtD7B,IAAU6B,EAAOF,GACjB3N,KAAU4d,EAAaC,WAAWhQ,EAAO7N,IAAI,EAC7CklB,QAAU,CAACrX,EAAOkT,OAClBlT,OAAAA,EACA1N,OAAU,mBACd,EAAE,CACN,CACJ,CAzBI5C,EADiBgtC,GACV7pC,QAAQ,sBACfnD,EAFiBgtC,GAEV5pC,OAAO,sBACdpD,EAHiBgtC,GAGV9sC,eAAe,CAClBuC,KAAc,uBACdC,KAAc,gBACd2qC,YAAc,wBACdC,UAAc,MACdC,SAAc,KAEd3gC,KAAc,CAAEvK,MAAQ,IAAK,IAiBrC2qC,GAAmBzpC,UAAS,EAC5BypC,GAAmB7sC,OAAS,qBC9Bb,MAAMqtC,WAA2BP,GAAOztC,MAAMmf,CAAe,CAAE,CAW1E8uB,cAAc,CAAE9+B,KAAAA,CAAK,EAAG,CACpB,KAAKqB,WAAW,IAAA,CAAA,IAAA09B,EAAA,OAAAA,EAAM,KAAKvpC,aAASupC,MAAAA,IAAdA,OAAAA,OAAAA,EAAgBlW,eAAe7oB,EAAK2B,MAAM,CAAC,EAAE,GAAG,CAC1E,CACAq9B,WAAW/gC,EAAM,CAEb,OAAIA,IACAA,EAAO,KAAKzI,UAAUzC,QAAQ8G,IAAI8H,IAAW,CACzC7B,IAAS6B,EAAOF,GAChB3N,KAAS4d,EAAaC,WAAWhQ,EAAO7N,IAAI,EAC5C6N,OAAAA,EACA1N,OAAS,kBACb,EAAE,GAEC,MAAM+qC,WAAW/gC,CAAI,CAChC,CACJ,CAzBI5M,EADiBwtC,GACVrqC,QAAQ,sBACfnD,EAFiBwtC,GAEVpqC,OAAO,sBACdpD,EAHiBwtC,GAGVttC,eAAe,CAClBuC,KAAc,8BACdC,KAAc,gBACd2qC,YAAc,wBACdC,UAAc,MACdC,SAAc,KACd3gC,KAAc,CAAA,IAkBtB4gC,GAAmBjqC,UAAS,EAC5BiqC,GAAmBrtC,OAAS,qBCxBb,MAAMytC,WAAqBC,GAAsBruC,MAAMmf,CAAe,CAAE,CAWnFmvB,gBAAgB3pC,EAAW,CACnBA,IACA,KAAK0W,QAAU1W,EAAU0W,QAEjC,CACA6pB,gBAAiB,CAER,KAAK5lB,YACN,KAAKgvB,gBAAgB,KAAK3pC,SAAS,CAE3C,CACJ,CArBInE,EADiB4tC,GACVzqC,QAAQ,gBACfnD,EAFiB4tC,GAEVxqC,OAAO,yBACdpD,EAHiB4tC,GAGV1tC,eAAe,CAMlB2a,QAAU,OAelB+yB,GAAarqC,UAAS,EACtBqqC,GAAaztC,OAAS,eC/BP,MAAM4tC,WAA4BjB,GAAYttC,MAAMmf,CAAe,CAAE,CAepF,CAdI3e,EADiB+tC,GACV5qC,QAAQ,uBACfnD,EAFiB+tC,GAEV3qC,OAAO,uBACdpD,EAHiB+tC,GAGV7tC,eAAe,CAClBksB,MAAQ,2BACRxa,MAAQ,OACRqR,MAAQ,+BACR3d,MAAQ,OACRynC,SAAW,CACPn2B,OAAS,CACL5H,IAAQ,uBACR3B,MAAQ,OACZ,CACJ,IAGR0gC,GAAoBxqC,UAAS,EAC7BwqC,GAAoB5tC,OAAS,sBCbd,MAAM6tC,WAA6Bf,GAAOztC,MAAMmf,CAAe,CAAE,CAY5EsvB,iBAAiB,CAAEt/B,KAAAA,CAAK,EAAG,CACvBA,EAAKpI,SAASid,OAAS,CAAC7U,EAAKgZ,OACjC,CAEAwlB,iBAAiBC,EAAM,CACnB,MAAMD,iBAAiBC,CAAI,EAC3BA,EAAK58B,OAAOnO,MAAQ,KAAK8B,UAAUmF,UAAUd,IAAIjC,IAAa,CAC1DkI,IAAUlI,EAAS6J,GACnB3N,KAAU4d,EAAaC,WAAW/Z,EAAS9D,IAAI,EAC/CklB,QAAU,CAACphB,EAASid,OACpBjd,SAAAA,EACA3D,OAAU,qBACd,EAAE,CACN,CACJ,CAzBI5C,EADiBguC,GACV7qC,QAAQ,wBACfnD,EAFiBguC,GAEV5qC,OAAO,wBACdpD,EAHiBguC,GAGV9tC,eAAe,CAClBuC,KAAc,yBACdC,KAAc,gBACd2qC,YAAc,wBACdC,UAAc,MACdC,SAAc,KAEd3gC,KAAc,CAAEvK,MAAQ,IAAK,IAiBrC2rC,GAAqBzqC,UAAS,EAC9ByqC,GAAqB7tC,OAAS,uBC9Bf,MAAM+tC,WAA6BjB,GAAOztC,MAAMmf,CAAe,CAAE,CAW5EwvB,gBAAgB,CAAEx/B,KAAAA,CAAK,EAAG,CACtB,KAAKqB,WAAW,IAAA,CAAA,IAAA09B,EAAA,OAAAA,EAAM,KAAKvpC,aAASupC,MAAAA,IAAdA,OAAAA,OAAAA,EAAgBxW,iBAAiBvoB,EAAKpI,QAAQ,CAAC,EAAE,GAAG,CAC9E,CACAonC,WAAW/gC,EAAM,CAEb,OAAIA,IACAA,EAAO,KAAKzI,UAAUmF,UAAUd,IAAIjC,IAAa,CAC7CkI,IAASlI,EAAS6J,GAClB3N,KAAS4d,EAAaC,WAAW/Z,EAAS9D,IAAI,EAC9C8D,SAAAA,EACA3D,OAAS,oBACb,EAAE,GAEC,MAAM+qC,WAAW/gC,CAAI,CAChC,CACJ,CAzBI5M,EADiBkuC,GACV/qC,QAAQ,wBACfnD,EAFiBkuC,GAEV9qC,OAAO,wBACdpD,EAHiBkuC,GAGVhuC,eAAe,CAClBuC,KAAc,gCACdC,KAAc,gBACd2qC,YAAc,wBACdC,UAAc,MACdC,SAAc,KACd3gC,KAAc,CAAA,IAkBtBshC,GAAqB3qC,UAAS,EAC9B2qC,GAAqB/tC,OAAS,uBC9Bf,MAAMiuC,WAAwBtB,GAAYttC,MAAMmf,CAAe,CAAE,CAehF,CAdI3e,EADiBouC,GACVjrC,QAAQ,mBACfnD,EAFiBouC,GAEVhrC,OAAO,mBACdpD,EAHiBouC,GAGVluC,eAAe,CAClBksB,MAAQ,mCACRxa,MAAQ,OACRqR,MAAQ,2BACR3d,MAAQ,OACRynC,SAAW,CACPn2B,OAAS,CACL5H,IAAQ,uBACR3B,MAAQ,OACZ,CACJ,IAGR+gC,GAAgB7qC,UAAS,EACzB6qC,GAAgBjuC,OAAS,kBCWV,MAAMqnC,UAAsB6G,EAAM,CA+C7CjR,SAAU,CACN,KAAM,CAAEkR,cAAAA,CAAc,EAAI,KAC1B,MAAO,CACHxhC,MAAQ,CACJ,aAAewhC,CACnB,EAER,CACAC,WAAWC,EAAM,CACb,OAAOtvB,GAAOuvB,OAAOriC,EAAaxG,OAAO,CAErCuc,QAAUlP,GAAUoN,EAAa0H,+BAA+B9U,EAAO0S,SAAS,KAAKggB,SAAS,uEAC/F6I,CAAI,CAAC,CACZ,CACAE,WAAWF,EAAM,CAEbA,EAAKhoB,IAAI,CACL7X,KAAU,cACVzN,QAAU,IACd,CAAC,EAEDstC,EAAKnxB,SAASmJ,IAAI,CACd1X,OAAU,oBACV5N,QAAU,IACd,CAAC,CACL,CACAytC,gBAAgBlxB,EAAQ,CACpB,MAAM7V,EAASsX,GAAOuvB,OAAOhxB,CAAM,EACnC,YAAKmxB,YAAchnC,EAAO9B,QACnB8B,CACX,CACAinC,gBAAgBpxB,EAAQ,CACpBA,EAAO+I,IAAI,CACP3X,MAAU,aACV3N,QAAU,IACd,CAAC,CACL,CACA,IAAI4tC,YAAa,CACb,MAAO,CAAC,KAAKN,KAAM,KAAKO,SAAS,CACrC,CACA,IAAIluB,cAAe,CACf,OAAO,KAAK2tB,KAAK1oC,OACrB,CACA,IAAIga,eAAgB,CAChB,OAAO,MAAMA,cAAckvB,OAAO,KAAKD,UAAUjpC,OAAO,CAC5D,CACAi/B,YAAYplB,EAAO,CACfA,EAAQA,GAAS,CAAA,EACjB,IAAI4D,EAAa,GAEjB,YAAK0rB,aAAal4B,GAAK,CACnB,GAAIA,EAAEoN,iBACFZ,OAAAA,EAAa,GACN,EAEf,CAAC,EAED,KAAK2rB,cAAgB3rB,EAAa5D,EAAQvT,EAAam0B,MAAM5gB,CAAK,EAC9DA,IAEAA,EAAQvT,EAAam0B,MAAM5gB,CAAK,EAChCA,EAAM9Z,QAAQ,CAACspC,EAAGppC,IAAM,CAEpBopC,EAAE/+B,GAAKrK,EAAI,EAEXopC,EAAEC,cAAgBrpC,CACtB,CAAC,GAEE4Z,CACX,CACA0vB,YAAY1vB,EAAO,CACf,GAAIA,EAAO,CACP,MAAMrf,EAAK,KAEXA,EAAGkuC,KAAKnsC,MAAQsd,EAEhBrf,EAAGgvC,eAAiB,GACpBhvC,EAAGkuC,KAAKnxB,SAASsG,OAAShE,EAAM/I,OAAOu4B,GAAKA,EAAE7uC,EAAGslC,YAAY,CAAC,EAC9DtlC,EAAGgvC,eAAiB,GAE5B,CACA,IAAI3vB,OAAQ,CAER,OAAO,KAAKuvB,cAAch3B,MAAK,CACnC,CACA,IAAIyH,MAAMA,EAAO,CACb,MAAMA,MAAQA,CAClB,CAEA,IAAIiE,SAAU,CACV,MAAO,EACX,CAEA2rB,SAASt8B,EAAQnN,EAAS,CACtB,MACIxF,EAAS,KAETyQ,EAAS,IAAIe,GAAO,CAChBC,SAAazR,EAAGwF,QAChBhF,MAAaR,EACb0O,IAAa,gBACboD,WAAa,CACThP,KAAW,OACX2pC,SAAW,CACP7jC,OAAS,CACL8F,IAAM,6BACNzD,SAAU,CACNjL,EAAGkvC,WAAWv8B,CAAM,EACpBlC,EAAOmD,WAAU,CACrB,CACJ,CACJ,GAGJlP,MAAoB,kBACpBjE,kBAAoB,CAChByR,SAAS,CAAEmN,MAAAA,CAAM,EAAG,CAChBrf,EAAG4uC,cAAcj8B,EAAOm8B,aAAa,EAAE9uC,EAAGqlC,SAAS,EAAIhmB,EACvDrf,EAAGmvC,mBAAmB,CAAE9vB,MAAQrf,EAAGqf,MAAO+vB,WAAa,EAAK,CAAC,GAEjEh9B,YAAa,CACT3B,EAAO1P,QAAO,GAElBH,QAAUZ,CACd,CACJ,CAAC,EAELyQ,EAAOiC,UAAU,CACb7F,OAASrH,EACTmN,OAAAA,EACArB,MAAStR,EAAGqlC,SAChB,CAAC,CACL,CAEA6J,WAAWv8B,EAAQ,CACf,MACI3S,EAAoB,KACpB,CAAE8uC,cAAAA,CAAc,EAAIn8B,EAExB3S,EAAGkuC,KAAKpiB,MAAMvmB,QAAQsR,GAAK,CACnBA,EAAEF,YAAchE,EAAOgE,aACvBE,EAAEi4B,eAEV,CAAC,EACD9uC,EAAGkuC,KAAKpiB,MAAMljB,OAAO+J,CAAM,EAC3B3S,EAAG4uC,cAAcS,OAAOP,EAAe,CAAC,EACxC9uC,EAAGmvC,mBAAmB,CAAE9vB,MAAQrf,EAAGqf,MAAO+vB,WAAa,EAAK,CAAC,CACjE,CAEAE,mBAAoB,CAChB,MACItvC,EAAW,KACX,CAAEkuC,KAAAA,CAAK,EAAIluC,EACVA,EAAGgvC,iBACJhvC,EAAG4uC,cAAcrpC,QAAQ,CAACspC,EAAGppC,IAAM,CAC/B,MAAM8pC,EAAarB,EAAKpiB,MAAMjqB,MAAM4D,CAAC,EAEjC8pC,IACAV,EAAE7uC,EAAGslC,YAAY,EAAI4I,EAAKnxB,SAAS1G,SAASk5B,CAAU,EAE9D,CAAC,EACDvvC,EAAGmvC,mBAAmB,CAAE9vB,MAAQrf,EAAGqf,MAAO+vB,WAAa,EAAK,CAAC,EAErE,CAEAI,YAAY,CAAE78B,OAAAA,EAAQjQ,MAAAA,CAAM,EAAG,CACvBA,EAAMmK,OAAO7G,QAAQ,cAAc,GACnC,KAAKipC,SAASt8B,EAAQjQ,EAAMmK,OAAO3G,QAAQ,cAAc,CAAC,CAElE,CAGA+J,YAAa,CACT,MAAMjQ,EAAK,KACXA,EAAG4uC,cAAchjC,KAAK,CAClB,CAAC5L,EAAGqlC,SAAS,EAAOrlC,EAAGypB,EAAE,YAAY,EACrC,CAACzpB,EAAGslC,YAAY,EAAI,EACxB,CAAC,EACDtlC,EAAGqf,MAAQrf,EAAG4uC,cACd5uC,EAAGmvC,mBAAmB,CAAE9vB,MAAQrf,EAAGqf,MAAO+vB,WAAa,EAAK,CAAC,CACjE,CACJ,CAnOI1vC,EADiBwnC,EACVrkC,QAAQ,iBACfnD,EAFiBwnC,EAEVpkC,OAAO,iBACdpD,EAHiBwnC,EAGVuI,QAAQ,YACf/vC,EAJiBwnC,EAIVtnC,eAAe,CAQlBylC,UAAY,OAQZC,aAAe,UAQf0I,cAAgB,GAChBE,KAAO,CACHprC,KAAO,OACP0d,YAAc,GACdsL,MAAQ,CACJ3B,OAAS,CAAA,GAEbulB,aAAc,CACV,MAAQ,wCACZ,GAEJjB,UAAY,CACR3rC,KAAO,SACP4L,IAAO,aACPtM,KAAO,aACPD,KAAO,wBAEX4M,KAAO,OAwLfm4B,EAAcjkC,UAAS,EACvBikC,EAAcrnC,OAAS,gBC3PR,MAAMunC,WAAiBuI,GAAazwC,MAAMmf,CAAe,CAAE,CAGtEgN,WAAY,CACR,MAAMA,UAAU,GAAGukB,SAAS,EAC5B,KAAKC,IAAM,KAAKhsC,UAAU0W,QAAQs1B,GACtC,CACJ,CANInwC,EADiB0nC,GACVvkC,QAAQ,YACfnD,EAFiB0nC,GAEVtkC,OAAO,qBAMlBskC,GAASnkC,UAAS,EAClBmkC,GAASvnC,OAAS,WChBH,MAAMiwC,WAAmBC,GAAO7wC,MAAMmf,CAAe,CAAE,CAWlE2xB,eAAeC,EAAO,CAClB,OAAO,KAAK/0B,IAAM+0B,EAAQ,CAC9B,CACA9wB,gBAAiB,CACb,KAAKE,MAAQ,KAAK2wB,eAAe,KAAKnsC,UAAU8U,WAAW,CAC/D,CACAu3B,QAAQ,CAAE7wB,MAAAA,CAAM,EAAG,CACf,KAAKxb,UAAU8U,YAAc,KAAKq3B,eAAe3wB,CAAK,CAC1D,CACA0vB,YAAY1vB,EAAO,CACf,MAAM0vB,YAAY1vB,CAAK,EACvB,KAAK6wB,QAAQ,CAAE7wB,MAAAA,CAAM,CAAC,CAC1B,CACA8wB,eAAe9wB,EAAO,CAClB,MAAM1G,EAAc,KAAKq3B,eAAe3wB,CAAK,EAC7C,MAAQ,GAAE1G,SAAmBA,IAAgB,EAAI,GAAK,aAC1D,CACJ,CA3BIjZ,EADiBowC,GACVjtC,QAAQ,cACfnD,EAFiBowC,GAEVhtC,OAAO,cACdpD,EAHiBowC,GAGVlwC,eAAe,CAClBuC,KAAO,oBACP+Y,IAAQ,GACRxZ,IAAQ,EAER2d,MAAQ,KACR+wB,UAAY,KAoBpBN,GAAW7sC,UAAS,EACpB6sC,GAAWjwC,OAAS,cCYnB,IAAM,CAEH,MACIwwC,EAAmB,CACf,cACA,UACA,kBACA,gBACA,oBACA,sBACA,wBACA,uBACA,mBACA,qBACA,YAAY,EAGhBC,EAAmB,CAAA,EACvB,GAAI,CAACzX,EAAcC,YAAcuX,EAAM76B,KAAK+6B,GAAQ3iC,SAAS2iC,KAAKl6B,SAASk6B,CAAI,CAAC,GAAK,SAASC,KAAK5iC,SAAS6iC,IAAI,GAC5G,OAEJ,IAAIC,EACJ,SAASC,EAAiBnwC,EAAOowC,EAAW,CACnCF,IACDA,EAAc,GACdG,EAAaxlB,UAAU,CACnB3M,OAASle,CACb,CAAC,GAGLA,EAAMswC,MAAQ,aAClB,CAGA,MAAMD,CAAa,CACf,OAAOxlB,UAAU3f,EAAQ,CACrB,MACI1L,EAAgB,KAChB+wC,EAAgB,QAChBC,EAAgB,QAChBC,EAAgBpY,EAAcqY,WAAWH,CAAO,EAChDI,EAAgBtY,EAAcC,UAAY,IAAO,IAAO,GACxDsY,EAAgBxrB,EAAcyrB,YAAYD,SAC9C/rC,OAAOC,OAAOtF,EAAI,CACdixC,QAAAA,EACAF,QAAAA,EACAO,QAAmBN,EACnBO,UAAmB1Y,EAAcC,UAAYsY,EAAW,8BACxDI,QAAmB,GACnBC,iBAAmB,EACnBC,SAAoB,KAAIX,gBACxBY,gBAAoB,KAAIZ,iBACzBrlC,CAAM,EACJmtB,EAAcC,WACf8Y,QAAQC,IAAK,WAAUb,iBAA2B,EAEtDhxC,EAAG8xC,oBAAmB,EAClB9xC,EAAG+xC,YACCv0B,SAASw0B,aAAe,WACxBhyC,EAAGiyC,eAAc,EAGjBz0B,SAAS00B,iBAAiB,mBAAoB,IAAM,CAC5C10B,SAASw0B,aAAe,YACxBhyC,EAAGiyC,eAAc,CAEzB,CAAC,GAKTviC,WAAW,IAAM,CACb1P,EAAGmyC,oBAAmB,GACvBhB,CAAa,CACpB,CACA,OAAOW,qBAAsB,CACzB,MACI9xC,EAAa,KACboyC,EAAaxsB,EAAcysB,oBAAoBryC,EAAG0xC,QAAQ,EAC1DY,EAAaC,OAAOH,CAAU,EAC9BE,GAAQ,CAACE,MAAMF,CAAI,IACnBtyC,EAAGyyC,eAAiBH,GAExBtyC,EAAGyyC,eAAiBzyC,EAAGyyC,gBAAkBC,KAAKljB,IAAG,EAEjD5J,EAAc+sB,oBAAoB3yC,EAAG0xC,SAAU1xC,EAAGyyC,cAAc,CACpE,CACA,WAAWV,WAAY,CAAA,IAAAa,EAAAC,EACnB,OAAO,KAAKrB,SAAYkB,KAAKljB,IAAG,EAAK,KAAKijB,eAAiBK,MAAU,MAAGF,EAAIG,OAAOC,WAAO,MAAAJ,IAAAC,SAAAA,EAAdD,EAAiB,KAAK7B,OAAO,KAAC,MAAA8B,IAA9BA,OAAcA,OAAdA,EAAgCI,QAChH,CACA,OAAOd,qBAAsB,CACzB,MACInyC,EAAsB,KACtBkzC,EAAsBA,IAAMttB,EAAc+sB,oBAAoB3yC,EAAG2xC,gBAAiBe,KAAKljB,IAAG,CAAE,EAGhG,GAFAxvB,EAAGyxC,iBAAmBzxC,EAAGyxC,kBAAoB7rB,EAAcysB,oBAAoBryC,EAAG2xC,eAAe,GAAK,EAElG3xC,EAAAA,EAAGyxC,kBAAoBiB,KAAKljB,IAAG,EAAKxvB,EAAGyxC,iBAAmBqB,OAG9D,GAAI9yC,EAAGuxC,UAAW,CACd,MACI4B,EAASC,mBAAmBxlC,SAAS6iC,IAAI,EACzC4C,EAAU,GAAErzC,EAAGuxC,gBAAgBwB,OAAOC,QAAQM,eAAeH,IAC7DI,EAAS,IAAIC,MACjBD,EAAIE,OAAS,IAAM,CAEXF,EAAIG,eAAiB,EACrB1zC,EAAG2zC,WAAU,EAIbT,EAAmB,GAG3BK,EAAIK,QAAU,IAAM,CAChBV,EAAmB,GAEvBK,EAAI1P,IAAMwP,OAGVH,EAAmB,CAE3B,CACA,OAAOjB,gBAAiB,CACpB,MAAM4B,EAAS,KAAKn1B,OAAOhH,YACtB,KAAKo8B,kBACN,KAAKA,gBAAkB,GAClBjb,EAAcC,WACf8Y,QAAQmC,KAAM,WAAU,KAAKzC,qJAAqJ,EAEtLuC,EAAO13B,WAAa63B,GAAMluB,KAAK,CAC3BhG,KAAe,sBAAqB,KAAKwxB,gHACzC2C,QAAc,IACdv8B,YAAcm8B,CAClB,CAAC,GAELvvC,EAAU4vC,mBAAmBL,EAAQ,mBAAmB,EACxDvvC,EAAU6vC,gBAAgBN,EAAQ,eAAgBruC,GAAW,CACzD,MAAMkZ,EAASE,GAAOw1B,YAAY5uC,EAAS,QAAQ,EAC/C8qC,EAAiB96B,KAAK9G,GAAOgQ,aAAkBhQ,CAAG,GAClD,KAAK2lC,kBAAkB31B,CAAM,CAErC,CAAC,CACL,CACA,OAAOi1B,YAAa,CAChB,KAAKnC,QAAU,GAEf5rB,EAAc0uB,uBAAuB,KAAK3C,eAAe,EAEzD/rB,EAAc+sB,oBAAoB,KAAKjB,SAAU,CAAC,EAClD,KAAKO,eAAc,CACvB,CACA,OAAOoC,kBAAkB31B,EAAQ,CAC7BA,EAAO61B,KAAK,CACRpyC,KAAQ,oJACRC,KAAQ,kBACRU,KAAQ,QACR0xC,MAAQ,QACZ,CAAC,CACL,CACA,OAAOC,aAAajvC,EAAS,CACzBkvC,UAAAA,EAAY,4BACZC,WAAAA,EAAa,6BACb,CAAA,EAAI,CAAA,IAAAC,EAAAC,EAEJ,GAAIjvB,EAAcyrB,YAAYyD,OAAS,KACnC,OAEJ,MACIviC,GAAYqiC,EAAAtwC,EAAUywC,aAAS,MAAAH,IAAA,SAAAC,EAAnBD,EAAqB5iC,QAAI6iC,MAAAA,IAAzBA,QAAAA,EAA2B5P,YAAW,EAAG+P,SAAS,OAAO,EAAIN,EAAYC,EACrFM,EAAa;sLACyJ1iC;;;;;;;;;;;wBAY1K/M,EAAQd,MAAMwwC,gBAAmB,kCAAiCnC,OAAOoC,KAAKF,CAAS,KAC3F,CACJ,CAmCA,GAAI,OAAOvN,GAAkB,YAAa,CACtC4I,EAAiB1kC,KAAK87B,CAAa,EACnC,MAAM0N,EAAyBC,GAAa,CACxC,KACI,CAAE7vC,QAAAA,CAAQ,EAAK6vC,GACAvuB,GAAY,CAAC,GAAGthB,EAAQwN,iBAAiB8T,CAAQ,CAAC,EAC5DvhB,QAAQ8W,GACLw0B,EAAa4D,aAAap4B,EAAI,CAAEs4B,WAAa,2BAA4B,CACzE,CAAC,GACA,0BAA0B,GAE3CW,GAASC,MAAM,KAAM,CACjB,WAAW1oC,QAAS,CAChB,MAAO,CACHL,MAAQk7B,EAEhB,CACAnK,YAAa,CACT,GAAI,CAACsT,EAAakB,UACd,OAAO,KAAKyD,YAAYjY,WAAWgY,MAAM,KAAM3F,SAAS,CAEhE,CACAvE,gBAAiB,CACb,KAAKmK,YAAYnK,eAAekK,MAAM,KAAM3F,SAAS,EACrDwF,EAAuB,IAAI,CAC/B,CACAjN,iBAAkB,CACdwI,EAAiB,IAAmB,EAEpC8E,GAAal4B,GAAG,QAAS,IAAM,CAC3B63B,EAAuB,IAAI,CAC/B,CAAC,EACGvE,EAAakB,WACblB,EAAawD,kBAAkB,IAAI,CAE3C,CACJ,CAAC,EAET,GAAC,GACA,IAAM,CAEH,MAAMqB,EAAiB,wFAEvB,GAAI,CAACl4B,SAAS5P,UAAY8nC,EAAelF,KAAKhzB,SAAS5P,SAAS6iC,IAAI,GAAKsC,OAAOpuC,MAAQouC,OACpF,OAEJ,IAAIjjC,EACJ,MAAM6lC,EAAc,CAChB,cACA,SAAS,EAGTC,EAAa,CAAC,WAAY,OAAQ,QAAS,YAAa,eAAgB,WAAW,EACnFC,EAAa,CAAC,UAAW,QAAS,MAAO,OAAO,EACpDF,EAAYtG,OAAO,EAAG,EAAG,GAAGuG,EAAS1tC,IAAI4tC,GAAQD,EAAW3tC,IAAI6tC,GAAc,GAAEA,KAAaD,GAAM,CAAC,EAAEpH,OAAO,aAAa,EAAEsH,KAAI,CAAE,EAC9Hx4B,SAAS5P,SAAS2iC,KAAK0F,MAAMN,EAAYjsB,KAAK,GAAG,CAAC,EAClD5Z,EAAK,eAGLA,EAAK,eAET,MAAMomC,EAAY14B,SAASjZ,cAAc,QAAQ,EACjD2xC,EAAUzC,OAAS,UAAW,CAC1BV,OAAOoD,UAAYpD,OAAOoD,WAAa,CAAA,EACvC,SAASC,GAAO,CACZrD,OAAOoD,UAAUvqC,KAAKgkC,SAAS,CACnC,CACAwG,EAAK,KAAM,IAAI1D,IAAM,EACrB0D,EAAK,SAAUtmC,CAAE,GAErB0N,SAAS64B,KAAKrvC,YAAYkvC,CAAS,EACnCA,EAAUrS,IAAM,+CAAiD/zB,CACrE,GAAC",
  "names": ["TaskBoardFeature", "InstancePlugin", "mixin", "Factoryable", "onConfigChange", "args", "isConfiguring", "isDestroying", "client", "recompose", "__publicField", "factoryable", "configurable", "_$name", "ColumnDrag", "initialCompose", "me", "draggable", "ColumnZone", "new", "dragRootElement", "disabled", "bodyWrapElement", "dropRootElement", "owner", "internalListeners", "beforeDragStart", "dragStart", "thisObj", "doDestroy", "_this$draggable", "destroy", "doDisable", "disable", "movePrev", "columnRecord", "columns", "move", "getPrev", "moveNext", "beforeIndex", "Math", "min", "indexOf", "count", "getAt", "populateColumnHeaderMenu", "items", "rtl", "readOnly", "moveColumnLeft", "text", "icon", "weight", "onItem", "moveColumnRight", "onBeforeDragStart", "drag", "event", "trigger", "onDragStart", "$name", "type", "pluginConfig", "after", "initClass", "Base", "Draggable", "Droppable", "Events", "dragSelector", "dragItemSelector", "draggingItemCls", "dragProxy", "open", "itemElement", "startEvent", "taskBoard", "headerBounds", "Rectangle", "from", "proxyOffset", "EventHelper", "getClientPoint", "getDelta", "proxy", "DomHelper", "createElement", "className", "parent", "style", "top", "y", "left", "translate", "x", "width", "getBoundingClientRect", "retainElement", "elements", "getColumnElements", "Object", "assign", "forEach", "element", "i", "columnClone", "cloneNode", "bounds", "originalWidth", "originalHeight", "height", "matches", "swimlane", "closest", "header", "DomSync", "getChild", "body", "swimlaneClone", "headerClone", "bodyClone", "length", "paddingBottom", "getStyleValue", "parentElement", "parseFloat", "flex", "appendChild", "classList", "add", "dragMove", "position", "setupDragContext", "result", "scrollManager", "monitoringConfig", "scrollables", "bodyElement", "direction", "startDrag", "resolveColumnRecord", "suspendResponsiveness", "wasStarted", "dragEnter", "dropIndicators", "map", "elementData", "dropIndicator", "insertDropIndicators", "beforeColumnRecord", "insertAt", "headerContainer", "actualHeaders", "children", "ArrayHelper", "remove", "insertBefore", "_client$swimlanes", "swimlaneRecord", "swimlanes", "domId", "swimlaneBody", "getSwimlaneElement", "actualColumns", "updateValidity", "valid", "toggle", "invalid", "_overElement$elementD", "documentRoot", "proxyBounds", "undefined", "overElement", "elementFromPoint", "center", "columnHeaderElement", "targetBounds", "beforeColumn", "getNext", "shouldTrigger", "dragDrop", "finalizer", "Promise", "resolve", "commit", "suspendDomTransition", "resumeDomTransition", "resumeResponsiveness", "alignTo", "getPropertyTransitionDuration", "onTransitionEnd", "property", "handler", "dragLeave", "doAbort", "finalizeAbort", "original", "dragEnd", "aborted", "ColumnHeaderMenu", "ContextMenuBase", "config", "chain", "push", "changeItems", "ObjectHelper", "assertObject", "changeProcessItems", "fn", "assertFunction", "populateColumnHeader", "columnHeaderConfig", "padder", "menu", "tag", "class", "getDataFromEvent", "taskBoardData", "addTask", "onColumnHeaderClick", "target", "showContextMenu", "align", "showMenu", "processItems", "anchor", "triggerEvent", "register", "ColumnToolbars", "columnMap", "Map", "toolbar", "changeTopItems", "changeBottomItems", "getToolbar", "location", "namedItems", "key", "get", "_me$processItems", "clonedItems", "getTruthyKeys", "ref", "namedItem", "item", "merge", "click", "change", "call", "cls", "overflow", "monitorResize", "contentElMutationObserver", "dataset", "role", "domTransition", "set", "populateColumn", "columnConfig", "topItems", "bottomItems", "bbar", "removeColumnToolbar", "columnId", "swimlaneId", "setTimeout", "delete", "removeColumnToolbars", "onRemoveColumnElement", "id", "onRemoveSwimlaneElement", "column", "onAddClick", "source", "onChange", "onClick", "tooltip", "ariaLabel", "TaskItem", "getEditorConfig", "editor", "defaultEditor", "SimpleTaskEdit", "changeAddNewAtEnd", "addNewAtEnd", "assertBoolean", "editTask", "taskRecord", "getTaskElement", "taskItem", "resolveTaskItem", "itemEditorConfig", "simpleTaskEdit", "field", "focus", "Editor", "appendTo", "parentNode", "scrollAction", "completeKey", "cancelKey", "inputField", "autoSelect", "name", "allowTargetOut", "complete", "cancel", "finishEdit", "editorConfig", "currentElement", "color", "scrollIntoView", "block", "startEdit", "record", "editPrevious", "cardElement", "itemElements", "Array", "querySelectorAll", "index", "prevTaskRecord", "getPreviousTask", "prevCardElement", "prevItemElements", "editNext", "nextTaskRecord", "getNextTask", "getColumn", "getSwimlane", "completeEdit", "cancelEdit", "onActivateTask", "preventDefault", "onEditorComplete", "dataField", "onEditorCancel", "onEditorFinishEdit", "isActionAvailable", "Boolean", "keyMap", "Enter", "Escape", "before", "SwimlaneDrag", "SwimlaneZone", "resolveSwimlaneRecord", "swimlaneElement", "padding", "syncIdMap", "deflate", "insertDropIndicator", "beforeSwimlaneRecord", "taskBoardBounds", "bottom", "beforeSwimlane", "cardSelector", "ignoreOriginal", "hasChanged", "some", "initialParent", "initialIndex", "TaskDrag", "TaskZone", "domEvent", "taskRecords", "reorderTaskRecords", "dropTargetSelector", "columnEl", "resolveTaskRecord", "cardClones", "selectedTasks", "includes", "filter", "t", "sort", "a", "b", "parentIndex", "taskElements", "r", "taskHeights", "taskElement", "_elementData$swimlane", "cardClone", "originalColor", "AsyncHelper", "animationFrame", "parentBounds", "scrollLeft", "scrollTop", "configureListeners", "listeners", "rootElement", "isSelected", "slice", "initiatedFrom", "nextSibling", "targetTaskRecord", "instanceMeta", "dragging", "getFirstVisibleChild", "offsetParent", "getCardAt", "clientX", "clientY", "columnElement", "_cardElement", "targetSwimlane", "targetColumn", "tasksPerRow", "cardGap", "columnRect", "topCard", "centerX", "cardAbove", "cardBelow", "columnContentWidth", "getColumnWidth", "columnPadding", "innerColumnWidth", "floor", "cardBefore", "cardAfter", "_insertBefore", "_insertBefore$element", "cardRect", "nextElementSibling", "_insertBefore2", "lastCardElement", "card", "eventColor", "_drag$targetSwimlane", "isNamedColor", "lane", "columnField", "swimlaneField", "taskStore", "project", "columnRecords", "tasks", "swimlaneRecords", "task", "moveBefore", "taskId", "newWeight", "tasksBelow", "taskAbove", "weightDiff", "max", "round", "_tasksBelow$", "shift", "toSet", "features", "taskDrag", "taskSorterFn", "offsetWidth", "dropClone", "TaskDragSelect", "state", "changeDragThreshold", "threshold", "assertNumber", "initializeDragSelect", "returnAll", "floatRoot", "cardRectangles", "el", "rectangle", "ctrlKey", "deselectAll", "navigateable", "updateSelection", "len", "cardData", "shouldSelect", "intersect", "selected", "selectTask", "deselectTask", "onColumnMouseDown", "button", "startX", "startY", "mouseUpDetacher", "on", "document", "mouseup", "onMouseMove", "deltaX", "abs", "deltaY", "dragThreshold", "rect", "constrainTo", "setTranslateXY", "onMouseUp", "_me$mouseUpDetacher", "_me$element", "TaskBoardLinked", "Target", "_a", "_taskBoard", "up", "widget", "isTaskBoardBase", "Widget", "query", "changeTaskBoard", "isTaskBoard", "Error", "ColorBoxCombo", "Combo", "afterConstruct", "showBoxForNoColor", "value", "syncInputFieldValue", "colorBox", "innerElements", "reference", "displayField", "valueField", "editable", "listItemTpl", "html", "StringHelper", "encodeHtml", "picker", "ColumnCombo", "changeStore", "ResourcesCombo", "peekConfig", "_multiSelect", "inputElement", "multiSelect", "resourceRecord", "sync", "targetElement", "avatarContainer", "domConfig", "avatarRendering", "getResourceAvatar", "initials", "iconCls", "imageUrl", "image", "resourceImagePath", "btip", "resourceStore", "changeAvatarRendering", "old", "AvatarRendering", "outerHTML", "chipView", "scrollable", "itemTpl", "$config", "SwimlaneCombo", "TaskColorPicker", "ColorPicker", "colorClasses", "colorClassPrefix", "colors", "TaskColorCombo", "ColorField", "clearable", "TaskEditor", "Popup", "resources", "label", "capitalize", "eventStore", "usesSingleAssignment", "processItemsObject", "updateAutoUpdateRecord", "autoUpdate", "hidden", "updateRecord", "onSaveClick", "values", "isValid", "close", "onCancelClick", "_me$owner", "_me$owner2", "onInternalKeyDown", "saveAndCloseOnEnter", "autoUpdateRecord", "blur", "centered", "modal", "closeOnMaskTap", "closable", "autoUpdateFields", "handleSelector", "autoShow", "closeAction", "title", "defaults", "labelWidth", "description", "saveButton", "cancelButton", "maximizeOnMobile", "TaskEdit", "_this$editor", "changeEditorConfig", "changeEditorType", "editorType", "assertString", "getById", "getValue", "isEditing", "editorClass", "resolveType", "combinedItems", "mergeConfigs", "$meta", "BrowserHelper", "isHoverableDevice", "show", "Scroller", "showBy", "isVisible", "ion", "hide", "onEditorHide", "defaultPrevented", "populateTaskMenu", "_this$client$getTaskE", "TaskMenu", "updateTriggerEvent", "detachListeners", "onTriggerEvent", "internalShowContextMenu", "showMenuFor", "selector", "buttonElement", "querySelector", "eventParams", "alignSpec", "col", "isColumn", "checked", "closeParent", "setValue", "sibling", "xss", "isSwimlane", "resource", "_this$avatarRendering", "avatar", "toggleGroup", "removeTask", "updateShowAvatars", "_this$avatarRendering2", "showAvatars", "TaskTooltip", "changeTemplate", "template", "_tooltip", "changeTooltip", "oldTooltip", "Tooltip", "axisLock", "forSelector", "forElement", "showOnHover", "hoverDelay", "hideDelay", "anchorToTarget", "allowOver", "tools", "getHtml", "getTipHtml", "bind", "textContent", "tip", "activeTarget", "L", "join", "render", "getConfig", "ColumnModel", "Model", "getColumnTasks", "firstStore", "collapse", "expand", "fields", "defaultValue", "TaskModel", "EventModel", "TaskStore", "EventStore", "afterLoadData", "records", "autoAssignWeight", "setData", "storeId", "modelClass", "removeUnassignedEvent", "sorters", "ascending", "ProjectModel", "SchedulerProjectModel", "ProjectCrudManager", "construct", "eventsData", "tasksData", "taskModelClass", "eventModelClass", "taskStoreClass", "eventStoreClass", "addPrioritizedStore", "assignmentStore", "store", "data", "toJSON", "assignmentsData", "resourcesData", "SwimlaneModel", "getSwimlaneTasks", "ExpandCollapse", "widgetClass", "changeShowCollapseInHeader", "showCollapseInHeader", "toggleCollapse", "collapsed", "isSwimlaneModel", "toggleSwimlaneCollapse", "toggleColumnCollapse", "flush", "_cardElements$", "_columnElements$", "columnElements", "headerElement", "hasFixedWidth", "cardElements", "cardWidth", "columnWidth", "unshift", "syncOverflowState", "_super$populateColumn", "collapseTitle", "hasSwimlanes", "showCollapseTooltip", "collapsible", "expander", "_super$populateColumn2", "populateSwimlane", "_super$populateColumn3", "swimlaneConfig", "onColumnClick", "onSwimlaneHeaderClick", "ResponsiveCards", "responsivenessSuspended", "changeCardSizes", "cardSizes", "assertArray", "getCardSize", "perRow", "getTasksPerRow", "find", "size", "maxWidth", "onChildResize", "entries", "suspended", "shouldRecompose", "entry", "contentRect", "observedWidth", "cardSize", "now", "changeResizeObserver", "observer", "oldObserver", "disconnect", "ResizeObserver", "maxAvatars", "headerItems", "bodyItems", "resizeObserver", "transitionChangeActions", "update", "TaskBoardColumns", "changeAutoGenerateColumns", "autoGenerateColumns", "changeColumnField", "updateColumnField", "storage", "removeIndex", "addIndex", "unique", "shouldAutoGenerateColumns", "changeColumns", "Store", "objectify", "updateColumns", "$store", "refresh", "getDistinctValues", "_columns", "onColumnsChange", "action", "invalidateIndices", "options", "addTransition", "opacity", "removeTransition", "recomposeWithDomTransition", "inVisualOrder", "findItem", "swimlaneDelta", "wrap", "columnTasks", "nextTaskIndex", "prevTaskIndex", "properties", "TaskBoardDom", "_element$elementData", "_element$elementData2", "_this$swimlanes", "laneId", "taskColumnElement", "getTaskColumnElement", "getTaskSwimlaneElement", "_this$swimlanes2", "_this$swimlanes$getBy", "getSwimlaneColumnElement", "getColumnElement", "_this$getColumnElemen", "_this$swimlanes3", "reduce", "getColumnHeaderElement", "_this$documentRoot$el", "cacheCSSVar", "css", "measureSize", "TaskBoardDomEvents", "__privateAdd", "_hoveredCardElement", "changeDomListeners", "domListeners", "eventName", "domEvents", "resolveEvent", "triggerDomEvent", "isScrolling", "_element", "activateTaskEvent", "contains", "relatedTarget", "domSyncCallback", "lastDomConfig", "syncId", "elementType", "isRefresh", "_domConfig$class", "_me$cardIntersectionO", "cardIntersectionObserver", "observe", "isVirtualized", "intersects", "_me$cardIntersectionO2", "unobserve", "_me$swimlanes", "_me$swimlanes2", "isResizeObserved", "onTaskMouseDown", "onTaskClick", "onTaskDblClick", "onTaskContextMenu", "dblclick", "mousedown", "mousemove", "mouseover", "mouseout", "keydown", "contextmenu", "TaskBoardScroll", "onPaint", "firstPaint", "scroll", "onScrollEnd", "capture", "recomposeOnScrollEnd", "changeScrollOptions", "scrollOptions", "scrollToSwimlane", "swimlaneOrId", "_options", "_options2", "animate", "behavior", "scrollToColumn", "columnOrId", "_options3", "_options4", "scrollToIntersection", "_options5", "_options6", "edgeOffset", "scrollToTask", "taskOrId", "_options7", "_options8", "start", "end", "stickyHeaders", "offsetHeight", "getTaskHeight", "reject", "detach", "renderTask", "renderedTaskRecord", "expires", "delay", "alt", "highlight", "testConfig", "delayable", "VersionHelper", "isTestEnv", "TaskBoardStores", "assignments", "updateAssignments", "updateResources", "updateTasks", "changeNewTaskDefaults", "newTaskDefaults", "changeProject", "isModel", "projectModelClass", "attachToProject", "bindCrudManager", "Reflect", "defineProperty", "$master", "prototype", "buildIndexKey", "dependentOn", "attachToProjectStore", "changePreCommit", "listenersConfig", "onTaskStoreEarlyChange", "onTaskStoreChange", "changes", "onTaskStoreRefresh", "taskData", "columnBody", "lastCard", "lastElementChild", "first", "offsetTop", "clientHeight", "synced", "autoSync", "await", "useDomTransition", "domTransitionSuspended", "isDestroyed", "asArray", "loadMaskDefaults", "useTransition", "showDelay", "syncMask", "TaskBoardSwimlanes", "changeAutoGenerateSwimlanes", "autoGenerateSwimlanes", "changeSwimlaneField", "updateSwimlaneField", "shouldAutoGenerateSwimlanes", "changeSwimlanes", "updateSwimlanes", "_swimlanes", "onSwimlanesChange", "TaskBoardVirtualization", "changeVirtualize", "virtualize", "updateVirtualize", "IntersectionObserver", "onCardIntersection", "isIntersecting", "refreshVirtualizedCards", "changeGetTaskHeight", "updateGetTaskHeight", "compose", "wasIntersecting", "lastHeight", "boundingClientRect", "drawOnScroll", "queueColumnRecompose", "renderCardOutline", "_me$getTaskHeight", "tabIndex", "renderCard", "meta", "TextItem", "hasGeneratedId", "getFieldDefinition", "print", "ResourceAvatarsItem", "hasOverflow", "overflowCount", "lastResource", "colorPrefix", "overlap", "localeCompare", "resourceId", "syncOptions", "syncIdField", "pickerWidth", "fieldLess", "resourceAvatars", "separator", "taskMenu", "taskItemSelector", "afterRe", "beforeRe", "TaskItems", "mergeItems", "changeHeaderItems", "changeBodyItems", "changeFooterItems", "renderItems", "split", "typeCls", "hyphenate", "order", "populateCard", "_super$populateCard", "cardConfig", "sizeHeaderItems", "sizeBodyItems", "footerItems", "sizeFooterItems", "footer", "clone", "taskItemElement", "_item$onClick", "_item$onDblClick", "onDblClick", "navigationActions", "TaskNavigation", "getTaskNear", "_documentRoot$element", "gap", "_documentRoot$element2", "_documentRoot$element3", "focusAndOptionallySelect", "forceSelect", "currentlyFocusedTask", "activeElement", "selectOnNavigation", "taskToFocus", "navigateNext", "keyEvent", "select", "found", "nextColumnRecord", "nextColumnElement", "navigatePrev", "prevColumnRecord", "prevColumnElement", "navigateRight", "navigateLeft", "navigateDown", "nextTask", "navigateUp", "prevTask", "activate", "ArrowDown", "ArrowLeft", "ArrowUp", "ArrowRight", "TaskSelection", "changeSelectedTasks", "_this$isTaskSelectabl", "isTaskSelectable", "toggleTaskSelection", "_this$isTaskSelectabl2", "deselect", "include", "triggerSelectionChange", "selection", "bryntumEvent", "keyboardSelect", "isEditable", "keyboardToggleSelect", "selectUp", "selectDown", "selectLeft", "selectRight", "populateBody", "_super$populateBody", "bodyConfig", "ImageItem", "src", "baseUrl", "ProgressItem", "percent", "RatingItem", "SeparatorItem", "TagCombo", "afterConfigure", "_me$store", "tags", "taskTags", "Set", "changeValue", "$expectsString", "TagsItem", "str", "isArray", "textProperty", "clsProperty", "makeValidId", "toLowerCase", "TemplateItem", "isObject", "TodoListItem", "textField", "checkedField", "clsField", "checkedIcon", "uncheckedIcon", "firstRender", "isArrayDataField", "todo", "locale", "localeName", "localeDesc", "localeCode", "GridBase", "loadFailedMessage", "syncFailedMessage", "CrudManagerView", "serverResponseLabel", "TaskBoard", "Columns", "Swimlanes", "changeColumn", "changeSwimlane", "filterColumns", "filterSwimlanes", "filterTasks", "newTaskName", "removeTasks", "save", "zoom", "TodoListField", "newTodo", "UndoRedo", "UndoLastAction", "RedoLastAction", "LocaleHelper", "publishLocale", "weightSorter", "TaskBoardBase", "Panel", "Pluggable", "State", "Featureable", "Styleable", "Responsive", "isInitiallyComposed", "columnRecomposeQueue", "onPaintOverride", "changeResourceImagePath", "changeUseDomTransition", "changeStickyHeaders", "changeScrollManager", "oldScrollManager", "ScrollManager", "changeShowCountInHeader", "showCountInHeader", "changeTasksPerRow", "changeSwimlaneRenderer", "swimlaneRenderer", "changeTaskRenderer", "taskRenderer", "changeTaskSorterFn", "recomposeColumns", "recomposeColumn", "clear", "normalizeChildren", "renderColumn", "onlyChildren", "callback", "releaseThreshold", "_me$taskRenderer", "overriddenCard", "namedColor", "keys", "renderColumnHeader", "_me$getColumnTasks", "_me$columnHeaderRende", "minWidth", "last", "showOverflow", "columnHeaderRenderer", "_me$columnRenderer", "stretchCards", "isTree", "elementId", "columnRenderer", "renderSwimlane", "_me$getSwimlaneTasks", "_me$swimlaneRenderer", "rendered", "skipClone", "ignoreRefs", "isComposed", "_super$populateSwimla", "afterRecompose", "allRecords", "transitionRecompose", "onRenderColumn", "onRenderSwimlane", "duration", "_bodyElement", "_recomposeQueued", "resumeRecompose", "getCurrentConfig", "featureable", "factory", "layout", "cssVarPrefix", "setVersion", "TaskMenuItem", "_taskBoard$features$t", "columnHeaderMenu", "columnToolbars", "taskDragSelect", "taskEdit", "ColumnFilterField", "FilterField", "triggers", "ColumnPickerButton", "Button", "onToggleColumn", "onMenuBeforeShow", "info", "pressedIcon", "iconAlign", "menuIcon", "ColumnScrollButton", "onClickColumn", "_this$taskBoard", "changeMenu", "ProjectCombo", "SchedulerProjectCombo", "updateTaskBoard", "SwimlaneFilterField", "SwimlanePickerButton", "onToggleSwimlane", "SwimlaneScrollButton", "onClickSwimlane", "TaskFilterField", "Field", "editableItems", "changeList", "list", "create", "updateList", "changeAddButton", "ariaElement", "updateAddButton", "childItems", "addButton", "concat", "eachAncestor", "originalValue", "v", "originalIndex", "updateValue", "isSettingValue", "editItem", "removeItem", "triggerFieldChange", "userAction", "splice", "onSelectionChange", "listRecord", "onItemClick", "alias", "itemIconTpl", "UndoRedoBase", "arguments", "stm", "ZoomSlider", "Slider", "calculateValue", "input", "onInput", "getTooltipHtml", "showValue", "HOSTS", "EXPIRING_CLASSES", "host", "test", "href", "initialized", "initExpiryHelper", "baseClass", "ExpiryHelper", "__foo", "product", "productName", "version", "getVersion", "callHomeDelay", "blockUrl", "queryString", "Product", "verifyUrl", "blocked", "lastVersionCheck", "trialKey", "versionCheckKey", "console", "log", "cacheTrialStartTime", "isExpired", "readyState", "onTrialExpired", "addEventListener", "updateBlockedStatus", "timeString", "getLocalStorageItem", "time", "Number", "isNaN", "trialStartTime", "Date", "setLocalStorageItem", "_window$bryntum", "_window$bryntum$this$", "ONE_DAY", "window", "bryntum", "expired", "saveVersionCheckKey", "url", "encodeURIComponent", "logUrl", "license", "img", "Image", "onload", "naturalWidth", "blockTrial", "onerror", "rootEl", "expirationShown", "warn", "Toast", "timeout", "removeEachSelector", "forEachSelector", "fromElement", "maskExpiredWidget", "removeLocalStorageItem", "mask", "cover", "setWaterMark", "darkColor", "lightColor", "_DomHelper$themeInfo", "_DomHelper$themeInfo$", "thumb", "themeInfo", "endsWith", "svgString", "backgroundImage", "btoa", "watermarkTaskBoardBase", "taskboard", "Override", "apply", "_overridden", "GlobalEvents", "ignoreDomainRe", "websiteUrls", "products", "frameworks", "prod", "framework", "flat", "match", "newScript", "dataLayer", "gtag", "head"]
}
