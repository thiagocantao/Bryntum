/*!
 *
 * Bryntum Gantt 5.5.0
 *
 * Copyright(c) 2023 Bryntum AB
 * https://bryntum.com/contact
 * https://bryntum.com/license
 *
 */
var _globalThis$matchMedi;
/**
 * @module Core/helper/BrowserHelper
 */
/**
 * Static helper class that does browser or platform detection and provides other helper functions.
 */
class BrowserHelper {
  static supportsPointerEvents = Boolean(globalThis.PointerEvent || globalThis.MSPointerEvent);
  // Locker Service does not allow to instantiate PointerEvents. LWS apparently does, however.
  // https://github.com/bryntum/support/issues/5578
  static supportsPointerEventConstructor = typeof PointerEvent !== 'undefined';
  static PointerEventConstructor = globalThis.PointerEvent || globalThis.CustomEvent;
  //region Init
  /**
   * Yields `true` if the platform running is a phone (screen width or height <= 414 CSS pixels)
   * @property {Boolean}
   * @readonly
   * @static
   * @category Platform
   */
  static isPhone = (_globalThis$matchMedi = globalThis.matchMedia) === null || _globalThis$matchMedi === void 0 ? void 0 : _globalThis$matchMedi.call(globalThis, '(max-height:414px) or (max-width:414px)').matches;
  static cacheFlags(platform = navigator.platform, userAgent = navigator.userAgent) {
    const me = this;
    // os
    me._isLinux = Boolean(platform.match(/Linux/));
    me._isMac = Boolean(platform.match(/Mac/));
    me._isWindows = Boolean(platform.match(/Win32/));
    me._isMobile = Boolean(userAgent.match(/Mobile|Opera Mini|Opera Mobi|Puffin/) || typeof globalThis.orientation === 'number');
    // Edge user agent contains webkit too.
    // This is not a typo. Edge has "Safari/537.36 Edg/96.0.1054.34"
    me._isWebkit = Boolean(userAgent.match(/WebKit/) && !userAgent.match(/Edg/));
    me._firefoxVersion = me.getVersion(userAgent, /Firefox\/(\d+)\./);
    me._isFirefox = me._firefoxVersion > 0;
    me._chromeVersion = me.getVersion(userAgent, /Chrom(?:e|ium)\/(\d+)\./);
    me._isChrome = me._chromeVersion > 0;
    me._isSafari = Boolean(userAgent.match(/Safari/)) && !me._isChrome;
    me._isMobileSafari = Boolean(userAgent.match(/Mobile.*Safari/));
    me._safariVersion = me.getVersion(userAgent, /Version\/(.*).Safari/);
    me._isAndroid = Boolean(userAgent.match(/Android/g));
  }
  //endregion
  //region Device
  /**
   * Yields `true` if the current browser supports CSS style `overflow:clip`.
   * @property {Boolean}
   * @readonly
   * @internal
   */
  static get supportsOverflowClip() {
    if (this._supportsOverflowClip == null) {
      const div = document.createElement('div');
      div.style.overflow = 'clip';
      div.style.display = 'none';
      // If we're called before DOMContentLoaded, body won't be available.
      // HTML element works for style calcs.
      document.documentElement.appendChild(div);
      this._supportsOverflowClip = div.ownerDocument.defaultView.getComputedStyle(div).getPropertyValue('overflow') === 'clip';
      div.remove();
    }
    return this._supportsOverflowClip;
  }
  /**
   * Yields `true` if the current browser supports CSS style `position:sticky`.
   * @property {Boolean}
   * @readonly
   * @internal
   */
  static get supportsSticky() {
    return true;
  }
  /**
   * Returns matched version for userAgent.
   * @param {String} versionRe version match regular expression
   * @returns {Number} matched version
   * @readonly
   * @internal
   */
  static getVersion(userAgent, versionRe) {
    const match = userAgent.match(versionRe);
    return match ? parseFloat(match[1]) : 0;
  }
  /**
   * Determines if the user is using a touch device.
   * @property {Boolean}
   * @readonly
   * @internal
   */
  static get isTouchDevice() {
    // Allow tests or client code to set
    if (this._isTouchDevice === undefined) {
      this._isTouchDevice = globalThis.matchMedia('(pointer:coarse)').matches;
    }
    return this._isTouchDevice;
  }
  // Reports true by default for our tests
  static get isHoverableDevice() {
    if (this._isHoverableDevice === undefined) {
      this._isHoverableDevice = globalThis.matchMedia('(any-hover: hover)').matches;
    }
    return this._isHoverableDevice;
  }
  //endregion
  //region Platform
  static get isBrowserEnv() {
    // This window reference is left on purpose, globalThis is always defined
    // eslint-disable-next-line bryntum/no-window-in-lib
    return typeof window !== 'undefined';
  }
  /**
   * Checks if platform is Mac.
   * @property {Boolean}
   * @readonly
   * @category Platform
   */
  static get isMac() {
    return this._isMac;
  }
  /**
   * Checks if platform is Windows.
   * @property {Boolean}
   * @readonly
   * @category Platform
   */
  static get isWindows() {
    return this._isWindows;
  }
  /**
   * Checks if platform is Linux.
   * @property {Boolean}
   * @readonly
   * @category Platform
   */
  static get isLinux() {
    return this._isLinux;
  }
  /**
   * Checks if platform is Android.
   * @property {Boolean}
   * @readonly
   * @category Platform
   */
  static get isAndroid() {
    return this._isAndroid;
  }
  //endregion
  //region Browser
  /**
   * Checks if browser is Webkit.
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isWebkit() {
    return this._isWebkit;
  }
  /**
   * Checks if browser is Chrome or Chromium based browser.
   * Returns truthy value for Edge Chromium.
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isChrome() {
    return this._isChrome;
  }
  /**
   * Returns the major Chrome version or 0 for other browsers.
   * @property {Number}
   * @readonly
   * @category Browser
   */
  static get chromeVersion() {
    return this._chromeVersion;
  }
  /**
   * Checks if browser is Firefox.
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isFirefox() {
    return this._isFirefox;
  }
  /**
   * Returns the major Firefox version or 0 for other browsers.
   * @property {Number}
   * @readonly
   * @category Browser
   */
  static get firefoxVersion() {
    return this._firefoxVersion;
  }
  /**
   * Checks if browser is Safari.
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isSafari() {
    return this._isSafari;
  }
  static get safariVersion() {
    return this._safariVersion;
  }
  /**
   * Checks if browser is mobile Safari
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isMobileSafari() {
    return this._isMobileSafari;
  }
  /**
   * Checks if the active device is a mobile device
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isMobile() {
    return this._isMobile;
  }
  static get platform() {
    const me = this;
    return me._isLinux ? 'linux' : me._isMac ? 'mac' : me._isWindows ? 'windows' : me._isAndroid ? 'android' : me._isMobileSafari ? 'ios' : null;
  }
  /**
   * Returns `true` if the browser supports passive event listeners.
   * @property {Boolean}
   * @internal
   * @deprecated Since 5.0. All modern browsers now support passive event listeners.
   * @category Browser
   */
  static get supportsPassive() {
    return true;
  }
  // Only works in secure contexts
  static get supportsRandomUUID() {
    if (this._supportsRandomUUID === undefined) {
      try {
        this._supportsRandomUUID = Boolean(globalThis.crypto.randomUUID().length > 0);
      } catch (e) {
        this._supportsRandomUUID = false;
      }
    }
    return this._supportsRandomUUID;
  }
  //endregion
  //region Storage
  // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API
  static get storageAvailable() {
    let storage, x;
    try {
      storage = localStorage;
      x = '__storage_test__';
      storage.setItem(x, x);
      storage.removeItem(x);
      return true;
    } catch (e) {
      return e instanceof DOMException && (
      // everything except Firefox
      e.code === 22 ||
      // Firefox
      e.code === 1014 ||
      // test name field too, because code might not be present
      // everything except Firefox
      e.name === 'QuotaExceededError' ||
      // Firefox
      e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&
      // acknowledge QuotaExceededError only if there's something already stored
      storage.length !== 0;
    }
  }
  static setLocalStorageItem(key, value) {
    this.storageAvailable && localStorage.setItem(key, value);
  }
  static getLocalStorageItem(key) {
    return this.storageAvailable && localStorage.getItem(key);
  }
  static removeLocalStorageItem(key) {
    this.storageAvailable && localStorage.removeItem(key);
  }
  //endregion
  //region Helpers
  /**
   * Returns parameter value from search string by parameter name.
   * @param {String} paramName search parameter name
   * @param {String} [defaultValue] default value if parameter not found
   * @param {String} [search] search string. Defaults to `document.location.search`
   * @returns {String} search parameter string value
   * @category Helper
   */
  static searchParam(paramName, defaultValue = null, search = document.location.search) {
    const re = new RegExp(`[?&]${paramName}=?([^&]*)`),
      match = search.match(re);
    return match && match[1] || defaultValue;
  }
  /**
   * Returns cookie by name.
   * @param {String} name cookie name
   * @returns {String} cookie string value
   * @category Helper
   */
  static getCookie(name) {
    const nameEq = encodeURIComponent(name) + '=',
      cookieItems = document.cookie.split(';');
    for (let i = 0; i < cookieItems.length; i++) {
      let c = cookieItems[i];
      while (c.charAt(0) === ' ') {
        c = c.substring(1, c.length);
      }
      if (c.indexOf(nameEq) === 0) {
        return decodeURIComponent(c.substring(nameEq.length, c.length));
      }
    }
    return '';
  }
  /**
   * Triggers a download of a file with the specified name / URL.
   * @param {String} filename The filename of the file to be downloaded
   * @param {String} [url] The URL where the file is to be downloaded from
   * @internal
   * @category Download
   */
  static download(filename, url) {
    const a = document.createElement('a');
    a.download = filename;
    a.href = url || filename;
    a.style.cssText = 'display:none';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  }
  /**
   * Triggers a download of a Blob with the specified name.
   * @param {Blob} blob The Blob to be downloaded
   * @param {String} filename The filename of the file to be downloaded
   * @internal
   * @category Download
   */
  static downloadBlob(blob, filename) {
    const url = globalThis.URL.createObjectURL(blob);
    this.download(filename, url);
    globalThis.URL.revokeObjectURL(url);
  }
  static get queryString() {
    var _Object$fromEntries;
    // new URLSearchParams throws in salesforce
    // https://github.com/salesforce/lwc/issues/1812
    const params = new URL(globalThis.location.href).searchParams;
    // ?. to be nice to users with Chrome versions < 73
    return (_Object$fromEntries = Object.fromEntries) === null || _Object$fromEntries === void 0 ? void 0 : _Object$fromEntries.call(Object, params.entries());
  }
  // Used by docs fiddle
  static copyToClipboard(code) {
    let success = true;
    const textArea = document.createElement('textarea');
    textArea.value = code;
    textArea.style.height = textArea.style.width = 0;
    document.body.appendChild(textArea);
    textArea.select();
    try {
      document.execCommand('copy');
    } catch (e) {
      success = false;
    }
    textArea.remove();
    return success;
  }
  static isBryntumOnline(searchStrings) {
    var _searchStrings;
    searchStrings = Array.isArray(searchStrings) ? searchStrings : [searchStrings];
    return Boolean(/^(www\.)?bryntum\.com/.test(globalThis.location.host) || ((_searchStrings = searchStrings) === null || _searchStrings === void 0 ? void 0 : _searchStrings.some(str => this.queryString[str] != null)));
  }
  /**
   * Returns truthy value if page contains Content Security Policy meta tag or globalThis.bryntum.CSP is truthy value
   * @returns {Boolean}
   * @internal
   **/
  static get isCSP() {
    const {
      bryntum,
      document
    } = globalThis;
    if (bryntum.CSP == null) {
      bryntum.CSP = Boolean(document.querySelector('meta[http-equiv="Content-Security-Policy"]'));
    }
    return bryntum.CSP;
  }
  //endregion
}

if (BrowserHelper.isBrowserEnv) {
  BrowserHelper.cacheFlags();
}
BrowserHelper._$name = 'BrowserHelper';

// IMPORTANT - adding imports here can create problems for Base class
/**
 * @module Core/helper/StringHelper
 */
let charsToEncode, entitiesToDecode, htmlEncodeRe, htmlDecodeRe;
const camelLettersRe = /([a-z])([A-Z])/g,
  crlfRe = /[\n\r]/g,
  escapeRegExpRe = /[.*+?^${}()|[\]\\]/g,
  // same as NPM escape-string-regexp
  htmlRe$1 = /[&<]/,
  idRe = /(^[^a-z]+[^\w]+)/gi,
  whiteSpaceRe$1 = /\s+/,
  domIdRe = /^[^a-z]+|[^\w:.-]+/gi,
  htmlDecoder = (m, captured) => entitiesToDecode[captured.toLowerCase()] || String.fromCharCode(parseInt(captured.substr(2), 10)),
  htmlEncoder = (m, captured) => charsToEncode[captured],
  hyphenateCamelLetters = (all, g1, g2) => {
    return `${g1}-${g2.toLowerCase()}`;
  },
  separateCamelLetters = (all, g1, g2) => {
    return `${g1} ${g2.toLowerCase()}`;
  },
  replaceNonIdChar = c => {
    if (c) {
      return `_x${[...c].map(ch => ch.charCodeAt(0).toString(16)).join('')}`;
    }
    return '__blank__';
  },
  hyphenateCache = {},
  separatedCache = {};
/**
 * Helper for string manipulation.
 */
class StringHelper {
  //region Transform
  /**
   * Capitalizes the first letter of a string, "myString" -> "MyString".
   * @param {String} string The string to capitalize
   * @returns {String} The capitalized string or the value of `string` if falsy.
   * @category String formatting
   */
  static capitalize(string) {
    return string && string[0].toUpperCase() + string.substr(1);
  }
  /**
   * Makes the first letter of a string lowercase, "MyString" -> "myString".
   * @param {String} string The string to un-capitalize.
   * @returns {String} The un-capitalized string or the value of `string` if falsy.
   * @category String formatting
   */
  static uncapitalize(string) {
    return string && string[0].toLowerCase() + string.substr(1);
  }
  /**
   * Converts the passed camelCased string to a hyphen-separated string. eg "minWidth" -> "min-width"
   * @param {String} string The string to convert.
   * @returns {String} The string with adjoining lower and upper case letters
   * separated by hyphens and converted to lower case.
   * @category String formatting
   * @internal
   */
  static hyphenate(string) {
    // Cached since it is used heavily with DomHelper.sync()
    const cached = hyphenateCache[string];
    if (cached) {
      return cached;
    }
    return hyphenateCache[string] = string.replace(camelLettersRe, hyphenateCamelLetters);
  }
  /**
   * Converts the passed camelCased string to a capitalized, space-separated string. eg "startDate" -> "Start date".
   * @param {String} string The string to convert.
   * @returns {String} The string with spaces separating words.
   * @category String formatting
   * @internal
   */
  static separate(string) {
    // Cached since it may be used heavily
    const cached = separatedCache[string];
    if (cached) {
      return cached;
    }
    return separatedCache[string] = this.capitalize(string.replace(camelLettersRe, separateCamelLetters));
  }
  /**
   * Creates an alphanumeric identifier from any passed string. Encodes spaces and non-alpha characters.
   * @param {String} inString The string from which to strip non-identifier characters.
   * @returns {String}
   * @category Misc
   * @internal
   */
  static createId(inString) {
    return String(inString).replace(idRe, replaceNonIdChar);
  }
  static makeValidDomId(id, replaceValue = '') {
    if (id == null) {
      return null;
    }
    return String(id).replace(domIdRe, replaceValue);
  }
  //endregion
  //region Html
  static escapeRegExp(string, flags) {
    // $& means the whole matched string
    let ret = string.replace(escapeRegExpRe, '\\$&');
    if (flags !== undefined) {
      ret = new RegExp(ret, flags);
    }
    return ret;
  }
  /**
   * This method decodes HTML entities and returns the original HTML.
   *
   * See also {@link #function-encodeHtml-static}.
   * @param {String} str
   * @returns {String}
   * @category HTML
   */
  static decodeHtml(str) {
    return str && String(str).replace(htmlDecodeRe, htmlDecoder);
  }
  /**
   * This method encodes HTML entities and returns a string that can be placed in the document and produce the
   * original text rather than be interpreted as HTML. Using this method with user-entered values prevents those
   * values from executing as HTML (i.e., a cross-site scripting or "XSS" security issue).
   *
   * See also {@link #function-decodeHtml-static}.
   * @param {String} str
   * @returns {String}
   * @category HTML
   */
  static encodeHtml(str = '') {
    return str && String(str).replace(htmlEncodeRe, htmlEncoder);
  }
  /**
   * This method is similar to {@link #function-encodeHtml-static} except that `\n` and `\r` characters in the
   * given `str` are replaced by `<br>` tags _after_ first being encoded by {@link #function-encodeHtml-static}.
   * @param {String} str
   * @returns {String}
   * @category HTML
   * @internal
   */
  static encodeHtmlBR(str) {
    var _StringHelper$encodeH;
    return (_StringHelper$encodeH = StringHelper.encodeHtml(str)) === null || _StringHelper$encodeH === void 0 ? void 0 : _StringHelper$encodeH.replace(crlfRe, '<br>');
  }
  /**
   * Returns `true` if the provided `text` contains special HTML characters.
   * @param {String} text
   * @returns {Boolean}
   * @category HTML
   * @internal
   */
  static isHtml(text) {
    return typeof text === 'string' && htmlRe$1.test(text || '');
  }
  /**
   * Initializes HTML entities used by {@link #function-encodeHtml-static} and {@link #function-decodeHtml-static}.
   * @param {Object} [mappings] An object whose keys are characters that should be encoded and values are the HTML
   * entity for the character.
   * @private
   */
  static initHtmlEntities(mappings) {
    mappings = mappings || {
      '&': '&amp;',
      '>': '&gt;',
      '<': '&lt;',
      '"': '&quot;',
      "'": '&#39;'
    };
    const chars = Object.keys(mappings);
    // Maps '<' to '&lt;'
    charsToEncode = mappings;
    // Inverts the mapping so we can convert '&lt;' to '<'
    entitiesToDecode = chars.reduce((prev, val) => {
      prev[mappings[val]] = val;
      return prev;
    }, {});
    // Creates a regex char set like /([<&>])/g to match the characters that need to be encoded (escaping any of
    // the regex charset special chars '[', ']' and '-'):
    htmlEncodeRe = new RegExp(`([${chars.map(c => '[-]'.includes(c) ? '\\' + c : c).join('')}])`, 'g');
    // Creates a regex like /(&lt;|&amp;|&gt;)/ig to match encoded entities... good news is that (valid) HTML
    // entities do not contain any regex special characters:
    htmlDecodeRe = new RegExp(`(${Object.values(mappings).join('|')}|&#[0-9]+;)`, 'ig');
  }
  //endregion
  //region JSON
  /**
   * Parses JSON inside a try-catch block. Returns null if the string could not be parsed.
   *
   * @param {String} string String to parse
   * @returns {Object} Resulting object or `null` if parse failed
   * @category JSON
   */
  static safeJsonParse(string) {
    let parsed = null;
    try {
      parsed = JSON.parse(string);
    } catch (e) {}
    return parsed;
  }
  /**
   * Stringifies an object inside a try-catch block. Returns null if an exception is encountered.
   *
   * See [JSON.stringify on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)
   * for more information on the arguments.
   *
   * @param {Object} object The object to stringify
   * @param {Function|String[]|Number[]} [replacer] A function or array of string/number used to determine properties
   * to include in the JSON string
   * @param {String|Number} [space] Number of spaces to indent or string used as whitespace
   * @returns {String} Resulting object or null if stringify failed
   * @category JSON
   */
  static safeJsonStringify(object, replacer = null, space = null) {
    let result = null;
    try {
      result = JSON.stringify(object, replacer, space);
    } catch (e) {}
    return result;
  }
  //endregion
  //region Split & join
  /**
   * Joins all given paths together using the separator as a delimiter and normalizes the resulting path.
   * @param paths {Array} array of paths to join
   * @param pathSeparator [{String}] path separator. Default value is '/'
   * @returns {String}
   * @category Misc
   * @internal
   */
  static joinPaths(paths, pathSeparator = '/') {
    return paths.join(pathSeparator).replace(new RegExp('\\' + pathSeparator + '+', 'g'), pathSeparator);
  }
  /**
   * Returns the provided string split on whitespace. If the string is empty or consists of only whitespace, the
   * returned array will be empty. If `str` is not a string, it is simply returned. This allows `null` or already
   * split strings (arrays) to be passed through.
   *
   * For example:
   * ```
   *  console.log(StringHelper.split(' abc def xyz   '));
   *  > ['abc', 'def', 'xyz']
   *  console.log(StringHelper.split(''));
   *  > []
   * ```
   * Compare to the standard `split()` method:
   * ```
   *  console.log(' abc def xyz   '.split(/\s+/));
   *  > ['', 'abc', 'def', 'xyz', '']
   *  console.log(''.split(/\s+/));
   *  > ['']
   * ```
   * @param {String} str
   * @param {String|RegExp} delimiter
   * @returns {String[]}
   * @category Misc
   * @internal
   */
  static split(str, delimiter = whiteSpaceRe$1) {
    let ret = str;
    if (typeof ret === 'string') {
      ret = str.trim(); // w/o trim() whitespace on the ends will give us '' in the array
      ret = ret ? ret.split(delimiter) : []; // also ''.split() = ['']
    }

    return ret;
  }
  //endregion
  //region XSS
  /**
   * This is a tagged template function that performs HTML encoding on replacement values to avoid XSS (Cross-Site
   * Scripting) attacks.
   *
   * For example:
   *
   * ```javascript
   *  eventRenderer(eventRecord) {
   *      return StringHelper.xss`<span class="${eventRecord.attrib}">${eventRecord.name}</span>`;
   *  }
   * ```
   *
   * @param {TemplateStringsArray} strings The template string array
   * @param {...any} values The interpolated values in the template string
   * @returns {String} The encoded string
   * See {@link Core.helper.StringHelper#function-encodeHtml-static}.
   */
  static xss(strings, ...values) {
    const buf = [];
    let i = values.length;
    buf[i] = strings[i];
    while (i-- > 0) {
      buf[i] = strings[i] + StringHelper.encodeHtml(values[i]);
    }
    return buf.join('');
  }
  /**
   * This is a tagged template function that performs HTML encoding on replacement values to avoid XSS (Cross-Site
   * Scripting) attacks. Unlike {@link Core.helper.StringHelper#function-xss-static}, this method converts `\n` and
   * `\r` characters into `<br>` tags.
   *
   * For example:
   *
   * ```javascript
   *  eventRenderer(eventRecord) {
   *      return StringHelper.xssBR`<span class="${eventRecord.attrib}">${eventRecord.name}</span>`;
   *  }
   * ```
   *
   * See {@link Core.helper.StringHelper#function-encodeHtmlBR-static}.
   * @internal
   */
  static xssBR(strings, ...values) {
    const buf = [];
    let i = values.length;
    buf[i] = strings[i];
    while (i-- > 0) {
      buf[i] = strings[i] + StringHelper.encodeHtmlBR(values[i]);
    }
    return buf.join('');
  }
  //endregion
  //region JavaScript string
  /**
   * Converts a value to a JavaScript string (not JSON).
   *
   * For example a date to `"new Date(y, m, d)"`, an array to `"[...]"` etc.
   *
   * @param {*} value
   * @param {Object} [options]
   * @returns {String}
   * @internal
   */
  static toJavaScriptValue(value, options) {
    const type = Objects.typeOf(value);
    if (type === 'boolean' || type === 'string' || type === 'number' || value === null) {
      return StringHelper.safeJsonStringify(value);
    }
    if (value === globalThis) {
      return 'window';
    }
    if (type === 'date') {
      return `new Date(${value.getFullYear()}, ${value.getMonth()}, ${value.getDate()}, ${value.getHours()}, ${value.getMinutes()}, ${value.getSeconds()}, ${value.getMilliseconds()})`;
    }
    if (type === 'array') {
      return `[${value.map(v => StringHelper.toJavaScriptValue(v, options))}]`;
    }
    if (type === 'object' || type === 'instance') {
      return this.toJavaScriptString(value, options);
    }
    if (type === 'function') {
      let contents = value.toString();
      // async myFunction() {} => async function() {}
      if (contents.match(/^async (\w+?)\(/)) {
        contents = contents.replace(/^async (\w+?)\(/, 'async function(');
      }
      // Not an arrow fn? Replace name with function since we always add prop name prior to getting here
      // eventRenderer() {} -> function() {}
      else if (!contents.startsWith('async(') && contents.match(/^(\w+?)\(/)) {
        contents = contents.replace(/^(\w+?)\(/, 'function(');
      }
      return contents;
    }
    if (type === 'class') {
      if (value.toJavaScriptValue) {
        return value.toJavaScriptValue(options);
      }
      return Object.prototype.hasOwnProperty.call(value, '$name') ? value.$name : value.name;
    }
  }
  /**
   * Converts an object into a JavaScript string (not JSON).
   *
   * For example `{ a: 1, b: [2, 3] }` -> `"'{ a: 1, b: [2, 3] }'"`
   *
   * @param {Object} obj
   * @param {Object} [options]
   * @returns {String}
   * @internal
   */
  static toJavaScriptString(obj, options = {}) {
    const level = options.level ?? 0,
      intendSize = 2;
    // Not using template strings to have control over indentation
    return '{\n' + Object.keys(obj).map(key =>
    // All properties in an object are indented one step further than the object itself
    ' '.repeat((level + 1) * intendSize) + (key.match(/[- *]/) ? `"${key}"` : key) + `: ${StringHelper.toJavaScriptValue(obj[key], {
      ...options,
      level: level + 1
    })}`).join(',\n') +
    // Closing brace is indented to same level as the object
    '\n' + ' '.repeat(level * intendSize) + '}';
  }
  /**
   * Escapes " and \ in CSS attribute selectors, e.g. [data-id="somevalue"]
   *
   * Usage:
   * ```javascript
   * document.querySelector(StringHelper.cssAttributeQuery('data-id', 'id with & \\ chars'))
   * ```
   *
   * @param {String} attr
   * @param {String|Number} value
   * @returns {String}
   */
  static encodeAttributeSelector(attr, value) {
    return `[${attr}="${String(value).replace(/["\\]/g, '\\$&')}"]`;
  }
  //endregion
  //region UUID
  static fakeNodeUUIDIndex = 0;
  /**
   * Generates a UUID. Uses `Crypto.randomUUID()` if available, otherwise generates a random UUID using
   * `Crypto.getRandomValues()`.
   *
   * @returns {String}
   */
  static generateUUID() {
    var _globalThis$crypto;
    if (BrowserHelper.supportsRandomUUID) {
      return globalThis.crypto.randomUUID();
    }
    // Node does not have crypto built in
    if ((_globalThis$crypto = globalThis.crypto) !== null && _globalThis$crypto !== void 0 && _globalThis$crypto.getRandomValues) {
      // https://stackoverflow.com/questions/105034/how-do-i-create-a-guid-uuid
      return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ globalThis.crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
    }
    // Node specific code, should never get here outside of node. Not actually a UUID, but should still be unique
    // enough for our purposes, as long as value is not serialized
    return `${Date.now()}-${++StringHelper.fakeNodeUUIDIndex}`;
  }
  //endregion
}

StringHelper.initHtmlEntities();
StringHelper._$name = 'StringHelper';

// IMPORTANT - adding imports here can create problems for Base class
/**
 * @module Core/helper/util/Objects
 */
const {
    hasOwnProperty: hasOwnProperty$4,
    toString: toString$3
  } = Object.prototype,
  {
    isFrozen
  } = Object,
  afterRe = /\s*<\s*/,
  beforeRe = /\s*>\s*/,
  blendOptions = {},
  typeCache = {},
  emptyObject$8 = Object.freeze({});
// Static methods are not displayed in derived class documentation. Therefore, since this is an internal class, the
// workaround is to copy method documentation to ObjectHelper (the public interface). Also tried making ObjectHelper
// a singleton.
/**
 * Helper for low-level Object manipulation.
 *
 * While documented on {@link Core.helper.ObjectHelper}, the following static methods are implemented by this class:
 *
 * - `{@link Core.helper.ObjectHelper#function-assign-static}`
 * - `{@link Core.helper.ObjectHelper#function-assignIf-static}`
 * - `{@link Core.helper.ObjectHelper#function-clone-static}`
 * - `{@link Core.helper.ObjectHelper#function-createTruthyKeys-static}`
 * - `{@link Core.helper.ObjectHelper#function-getPath-static}`
 * - `{@link Core.helper.ObjectHelper#function-getTruthyKeys-static}`
 * - `{@link Core.helper.ObjectHelper#function-getTruthyValues-static}`
 * - `{@link Core.helper.ObjectHelper#function-isEmpty-static}`
 * - `{@link Core.helper.ObjectHelper#function-isObject-static}`
 * - `{@link Core.helper.ObjectHelper#function-merge-static}`
 * - `{@link Core.helper.ObjectHelper#function-setPath-static}`
 * - `{@link Core.helper.ObjectHelper#function-typeOf-static}`
 * @internal
 */
class Objects {
  static assign(dest, ...sources) {
    for (let source, key, i = 0; i < sources.length; i++) {
      source = sources[i];
      if (source) {
        for (key in source) {
          dest[key] = source[key];
        }
      }
    }
    return dest;
  }
  static assignIf(dest, ...sources) {
    for (let source, key, i = 0; i < sources.length; i++) {
      source = sources[i];
      if (source) {
        for (key in source) {
          if (!(key in dest) || dest[key] === undefined) {
            dest[key] = source[key];
          }
        }
      }
    }
    return dest;
  }
  static blend(dest, source, options) {
    options = options || blendOptions;
    dest = dest || {};
    const {
      clone = Objects.clone,
      merge = Objects.blend
    } = options;
    if (Array.isArray(source)) {
      if (source.length > 1) {
        source.forEach(s => {
          dest = Objects.blend(dest, s, options);
        });
        return dest;
      }
      source = source[0];
    }
    if (source) {
      let destValue, key, value;
      for (key in source) {
        value = source[key];
        if (value && Objects.isObject(value)) {
          destValue = dest[key];
          options.key = key;
          if (destValue && Objects.isObject(destValue)) {
            if (isFrozen(destValue)) {
              dest[key] = destValue = clone(destValue, options);
            }
            value = merge(destValue, value, options);
          } else {
            // We don't need to clone frozen objects, but we do clone mutable objects as they get
            // applied to the dest.
            value = isFrozen(value) ? value : clone(value, options);
          }
        }
        dest[key] = value;
      }
    }
    return dest;
  }
  static clone(value, handler) {
    let cloned = value,
      key;
    if (value && typeof value === 'object') {
      const options = handler && typeof handler === 'object' && handler;
      if (options) {
        // When using blend(), the 2nd argument is the options object, so ignore that case
        handler = null;
      }
      if (Objects.isObject(value)) {
        // When using DomSync, DomConfigs are usually recreated from scratch on each sync, we allow opting out
        // of cloning them (costly for many elements)
        if (value.skipClone) {
          cloned = value;
        } else {
          cloned = {};
          for (key in value) {
            cloned[key] = Objects.clone(value[key]);
          }
        }
      } else if (Array.isArray(value)) {
        cloned = [];
        // Loop backwards to:
        //  1. read source.length once
        //  2. get result array sized on first pass (avoid growing)
        for /* empty */
        (key = value.length; key-- > 0;) {
          cloned[key] = Objects.clone(value[key]);
        }
      } else if (Objects.isDate(value)) {
        cloned = new Date(value.getTime());
      } else if (handler) {
        // Allow other types to be handled (e.g., DOM nodes).
        cloned = handler(value);
      }
    }
    return cloned;
  }
  static createTruthyKeys(source) {
    const keys = StringHelper.split(source),
      result = keys && {};
    if (keys) {
      for (const key of keys) {
        // StringHelper.split won't return empty keys if passed a string, but we
        // could have been passed a String[]
        if (key) {
          result[key] = true;
        }
      }
    }
    return result;
  }
  /**
   * Returns value for a given path in the object
   * @param {Object} object Object to check path on
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @returns {*} Value associated with passed key
   */
  static getPath(object, path) {
    return path.split('.').reduce((result, key) => {
      return (result || emptyObject$8)[key];
    }, object);
  }
  /**
   * Returns value for a given path in the object, placing a passed default value in at the
   * leaf property and filling in undefined properties all the way down.
   * @param {Object} object Object to get path value for.
   * @param {String|Number|String[]|Number[]} path Dot-separated path, e.g. 'firstChild.childObject.someKey',
   * or the key path as an array, e.g. ['firstChild', 'childObject', 'someKey'].
   * @param {*} [defaultValue] Optionally the value to put in as the `someKey` property.
   * @returns {*} Value at the leaf position of the path.
   */
  static getPathDefault(object, path, defaultValue) {
    const keys = Array.isArray(path) ? path : typeof path === 'string' ? path.split('.') : [path],
      length = keys.length - 1;
    return keys.reduce((result, key, index) => {
      if (defaultValue && !(key in result)) {
        // Can't use emptyObject here, we are creating a node in the object tree
        result[key] = index === length ? defaultValue : {};
      }
      return (result || emptyObject$8)[key];
    }, object);
  }
  /**
   * Determines if the specified path exists
   * @param {Object} object Object to check path on
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @returns {Boolean}
   */
  static hasPath(object, path) {
    return path.split('.').every(key => {
      if (object && key in object) {
        object = object[key];
        return true;
      }
      return false;
    });
  }
  static getTruthyKeys(source) {
    const keys = [];
    for (const key in source) {
      if (source[key]) {
        keys.push(key);
      }
    }
    return keys;
  }
  static getTruthyValues(source) {
    const values = [];
    for (const key in source) {
      if (source[key]) {
        values.push(source[key]);
      }
    }
    return values;
  }
  static isClass(object) {
    var _object$prototype;
    if (typeof object === 'function' && ((_object$prototype = object.prototype) === null || _object$prototype === void 0 ? void 0 : _object$prototype.constructor) === object) {
      return true;
    }
    return false;
  }
  static isDate(object) {
    // A couple quick rejections but only sure way is typeOf:
    return Boolean(object === null || object === void 0 ? void 0 : object.getUTCDate) && Objects.typeOf(object) === 'date';
  }
  /**
   * Check if passed object is a Promise or contains `then` method.
   * Used to fix problems with detecting promises in code with `instance of Promise` when
   * Promise class is replaced with any other implementation like `ZoneAwarePromise` in Angular.
   * Related to these issues:
   * https://github.com/bryntum/support/issues/791
   * https://github.com/bryntum/support/issues/2990
   *
   * @param {Object} object object to check
   * @returns {Boolean} truthy value if object is a Promise
   * @internal
   */
  static isPromise(object) {
    if (Promise && Promise.resolve) {
      return Promise.resolve(object) === object || typeof (object === null || object === void 0 ? void 0 : object.then) === 'function';
    }
    throw new Error('Promise not supported in your environment');
  }
  static isEmpty(object) {
    if (object && typeof object === 'object') {
      // noinspection LoopStatementThatDoesntLoopJS
      for (const p in object) {
        // eslint-disable-line no-unused-vars,no-unreachable-loop
        return false;
      }
    }
    return true;
  }
  static isObject(value) {
    const C = value === null || value === void 0 ? void 0 : value.constructor;
    return Boolean(C
    // Most things have a .constructor property
    ?
    // An in-frame instance of Object
    C === Object ||
    // Detect cross-frame objects, but exclude instance of custom classes named Object. typeOf(value) is
    // "object" even for instances of a class and typeOf(C) is "function" for all constructors. We'll have
    // to settle for relying on the fact that getPrototypeOf(Object.prototype) === null.
    // NOTE: this issue does come up in Scheduler unit tests at least.
    C.getPrototypeOf && C.prototype && !Object.getPrototypeOf(C.prototype)

    // Since all classes have a constructor property, an object w/o one is likely from Object.create(null). Of
    // course, primitive types do not have ".constructor"
    : value && typeof value === 'object');
  }
  static isInstantiated(object) {
    return object ? typeof object === 'object' && !Objects.isObject(object) : false;
  }
  static merge(dest, ...sources) {
    return Objects.blend(dest, sources);
  }
  /**
   * Merges two "items" objects. An items object is a simple object whose keys act as identifiers and whose values
   * are "item" objects. An item can be any object type. This method is used to merge such objects while maintaining
   * their property order. Special key syntax is used to allow a source object to insert a key before or after a key
   * in the `dest` object.
   *
   * For example:
   * ```javascript
   *  let dest = {
   *      foo : {},
   *      bar : {},
   *      fiz : {}
   *  }
   *
   *  console.log(Object.keys(dest));
   *  > ["foo", "bar", "fiz"]
   *
   *  dest = mergeItems(dest, {
   *      'zip > bar' : {}    // insert "zip" before "bar"
   *      'bar < zap' : {}    // insert "zap" after "bar"
   *  });
   *
   *  console.log(Object.keys(dest));
   *  > ["foo", "zip", "bar", "zap", "fiz"]
   * ```
   *
   * @param {Object} dest The destination object.
   * @param {Object|Object[]} src The source object or array of source objects to merge into `dest`.
   * @param {Object} [options] The function to use to merge items.
   * @param {Function} [options.merge] The function to use to merge items.
   * @returns {Object} The merged object. This will be the `dest` object.
   * @internal
   */
  static mergeItems(dest, src, options) {
    options = options || blendOptions;
    let anchor, delta, index, indexMap, key, shuffle, srcVal;
    const {
      merge = Objects.blend
    } = options;
    dest = dest || {};
    if (Array.isArray(src)) {
      src.forEach(s => {
        dest = Objects.mergeItems(dest, s, options);
      });
    } else if (src) {
      // https://2ality.com/2015/10/property-traversal-order-es6.html
      // Bottom line: Object keys are iterated in declared/insertion order... unless the key is an integer or
      // Symbol, but we don't care about those generally.
      for (key in src) {
        srcVal = src[key];
        anchor = null;
        // Allow a key to be added before or after another:
        //
        //  {
        //      'foo > bar' : {
        //          ...
        //      },
        //      'bar < derp' : {
        //          ...
        //      }
        //  }
        //
        // The goal above is to add a 'foo' key before the existing 'bar' key while adding a 'derp' key after
        // 'bar'.
        if (key.includes('>')) {
          [key, anchor] = key.split(beforeRe);
          delta = 0;
        } else if (key.includes('<')) {
          [anchor, key] = key.split(afterRe);
          delta = 1;
        }
        if (key in dest) {
          // Changing the value of a key does not change its iteration order. Since "key in dest" we can do
          // what we need directly.
          if (srcVal && dest[key] && merge) {
            options.key = key;
            srcVal = merge(dest[key], srcVal, options);
          }
          dest[key] = srcVal;
        } else if (!anchor) {
          var _indexMap;
          dest[key] = srcVal;
          (_indexMap = indexMap) === null || _indexMap === void 0 ? void 0 : _indexMap.set(key, indexMap.size);
        } else {
          // Lazily sprout the item index map. When we first merge an item into an items object, we create this
          // Map to control the ordering. This is because any keys we add would necessarily be iterated after
          // the original properties.
          if (!indexMap) {
            indexMap = new Map();
            index = 0;
            for (const k in dest) {
              indexMap.set(k, index++);
            }
          }
          index = indexMap.get(anchor);
          dest[key] = srcVal;
          if (index == null && delta) {
            index = indexMap.size;
          } else {
            shuffle = shuffle || [];
            index = (index || 0) + delta;
            // Adjust all key indices >= index up by 1 to maintain integer indices (required by the above
            // use case).
            for (const item of indexMap) {
              const [k, v] = item;
              if (index <= v) {
                /*
                Consider object w/the following order:
                    {
                        foo : {}',
                        bar : {},
                        baz : {},
                        zip : {},
                        goo : {},
                        fiz : {}
                    }
                The indexMap is:
                    foo : 0
                    bar : 1
                    baz : 2
                    zip : 3
                    goo : 4
                    fiz : 5
                To insert before goo, we populate shuffle thusly (to set up for popping):
                    +-----+-----+
                    | fiz | goo |
                    +-----+-----+
                      0        1
                      =6-5-1   =6-4-1
                */
                shuffle && (shuffle[indexMap.size - v - 1] = k);
                indexMap.set(k, v + 1);
              }
            }
            // Delete and re-add the keys that should follow the new key to establish the iteration order
            // we need:
            if (shuffle) {
              while (shuffle.length) {
                const k = shuffle.pop(),
                  v = dest[k];
                delete dest[k];
                dest[k] = v;
              }
            }
          }
          indexMap.set(key, index);
        }
      }
    }
    return dest;
  }
  /**
   * Sets value for a given path in the object
   * @param {Object} object Target object
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @param {*} value Value for a given path
   * @returns {Object} Returns passed object
   */
  static setPath(object, path, value) {
    path.split('.').reduce((result, key, index, array) => {
      const isLast = index === array.length - 1;
      if (isLast) {
        return result[key] = value;
      } else if (!(result[key] instanceof Object)) {
        result[key] = {};
      }
      return result[key];
    }, object);
    return object;
  }
  static typeOf(value) {
    let trueType, type;
    if (value === null) {
      type = 'null';
    }
    // NaN is the only value that is !== to itself
    else if (value !== value) {
      // eslint-disable-line no-self-compare
      type = 'nan';
    } else {
      type = typeof value;
      if (type === 'object') {
        if (value.isBase) {
          type = 'instance';
        } else if (Array.isArray(value)) {
          type = 'array';
        } else if (!(type = typeCache[trueType = toString$3.call(value)])) {
          typeCache[trueType] = type = trueType.slice(8, -1).toLowerCase(); // '[object Date]' => 'date'
        }
      } else if (type === 'function' && value.isBase) {
        type = 'class';
      }
    }
    return type;
  }
}
Object.defineProperty(Objects, 'hasOwn', {
  // When available, this avoids an extra layer of function call around it:
  value: Object.hasOwn || ((object, property) => hasOwnProperty$4.call(object, property))
});
Objects._$name = 'Objects';

/**
 * @module Core/helper/VersionHelper
 */
/**
 * Helper for version handling
 * @private
 * @example
 *
 * VersionHelper.setVersion('grid', '1.5');
 *
 * if (VersionHelper.getVersion('grid').isNewerThan('1.0')) {
 *   ...
 * }
 */
class VersionHelper {
  /**
   * Set version for specified product
   * @private
   * @param {String} product
   * @param {String} version
   */
  static setVersion(product, version) {
    product = product.toLowerCase();
    VH[product] = {
      version,
      isNewerThan(otherVersion) {
        return VersionHelper.semanticCompareVersion(otherVersion, version, '<');
      },
      isOlderThan(otherVersion) {
        return VersionHelper.semanticCompareVersion(otherVersion, version, '>');
      }
    };
    let bundleFor = '';
    // Var productName is only defined in bundles, it is internal to bundle so not available on window. Used to
    // tell importing combinations of grid/scheduler/gantt bundles apart from loading same bundle twice
    if (typeof productName !== 'undefined') {
      // eslint-disable-next-line no-undef
      bundleFor = productName;
    }
    // Set "global" flag to detect bundle being loaded twice
    const globalKey = `${bundleFor}.${product}${version.replace(/\./g, '-')}`;
    if (BrowserHelper.isBrowserEnv && !globalThis.bryntum.silenceBundleException) {
      if (globalThis.bryntum[globalKey] === true) {
        if (this.isTestEnv) {
          globalThis.BUNDLE_EXCEPTION = true;
        } else {
          let errorProduct = bundleFor || product;
          if (errorProduct === 'core') {
            errorProduct = 'grid';
          }
          let capitalized = StringHelper.capitalize(errorProduct);
          if (errorProduct === 'schedulerpro') {
            capitalized = 'SchedulerPro';
          }
          throw new Error(`The Bryntum ${capitalized} bundle was loaded multiple times by the application.\n\n` + `Common reasons you are getting this error includes:\n\n` + `* Imports point to different types of the bundle (e.g. *.module.js and *.umd.js)\n` + `* Imports point to both sources and bundle\n` + `* Imports do not use the shortest relative path, JS treats them as different files\n` + `* Cache busters differ between imports, JS treats ${errorProduct}.module.js?1 and ${errorProduct}.module.js?2 as different files\n` + `* Imports missing file type, verify they all end in .js\n\n` + `See https://bryntum.com/products/${errorProduct}/docs/guide/${capitalized}/gettingstarted/es6bundle#troubleshooting for more information\n\n`);
        }
      } else {
        globalThis.bryntum[globalKey] = true;
      }
    }
  }
  /**
   * Get (previously set) version for specified product
   * @private
   * @param {String} product
   */
  static getVersion(product) {
    product = product.toLowerCase();
    if (!VH[product]) {
      throw new Error('No version specified! Please check that you import VersionHelper correctly into the class from where you call `deprecate` function.');
    }
    return VH[product].version;
  }
  /**
   * Checks the version1 against the passed version2 using the comparison operator.
   * Supports `rc`, `beta`, `alpha` release states. Eg. `1.2.3-alpha-1`.
   * State which is not listed above means some version below `alpha`.
   * @param {String} version1 The version to test against
   * @param {String} version2 The version to test against
   * @param {String} [comparison] The comparison operator, `<=`, `<`, `=`, `>` or `>=`.
   * @returns {Boolean} `true` if the test passes.
   * @internal
   */
  static semanticCompareVersion(version1, version2, comparison = '=') {
    version1 = version1 || '';
    version2 = version2 || '';
    const version1Arr = version1.split(/[-.]/),
      version2Arr = version2.split(/[-.]/),
      isLower = comparison.includes('<'),
      normalizeArr = (arr, maxLength) => {
        const states = ['rc', 'beta', 'alpha'],
          result = arr.map(v => {
            if (states.includes(v)) {
              return -states.indexOf(v) - 2;
            }
            const res = Number.parseInt(v);
            return Number.isNaN(res) ? -states.length : res;
          });
        while (result.length < maxLength) {
          result.push(-1);
        }
        return result;
      },
      compareArr = () => {
        const maxLength = Math.max(version1Arr.length, version2Arr.length),
          arr1 = normalizeArr(version1Arr, maxLength),
          arr2 = normalizeArr(version2Arr, maxLength);
        for (let i = 0; i < maxLength; i++) {
          if (arr1[i] !== arr2[i]) {
            return isLower ? arr1[i] < arr2[i] : arr1[i] > arr2[i];
          }
        }
        return true;
      };
    switch (comparison) {
      case '=':
        return version1 === version2;
      case '<=':
      case '>=':
        return version1 === version2 || compareArr();
      case '<':
      case '>':
        return version1 !== version2 && compareArr();
    }
    return false;
  }
  /**
   * Checks the passed product against the passed version using the passed test.
   * @param {String} product The name of the product to test the version of
   * @param {String} version The version to test against
   * @param {String} operator The test operator, `<=`, `<`, `=`, `>` or `>=`.
   * @returns {Boolean} `true` if the test passes.
   * @internal
   */
  static checkVersion(product, version, operator) {
    return VersionHelper.semanticCompareVersion(VH.getVersion(product), version, operator);
  }
  /**
   * Based on a comparison of current product version and the passed version this method either outputs a console.warn
   * or throws an error.
   * @param {String} product The name of the product
   * @param {String} invalidAsOfVersion The version where the offending code is invalid (when any compatibility layer
   * is actually removed).
   * @param {String} message Required! A helpful warning message to show to the developer using a deprecated API.
   * @internal
   */
  static deprecate(product, invalidAsOfVersion, message) {
    const justWarn = VH.checkVersion(product, invalidAsOfVersion, '<');
    if (justWarn) {
      // During the grace period (until the next major release following the deprecated code), just show a console warning
      console.warn(`Deprecation warning: You are using a deprecated API which will change in v${invalidAsOfVersion}. ${message}`);
    } else {
      throw new Error(`Deprecated API use. ${message}`);
    }
  }
  /**
   * Returns truthy value if environment is in testing mode
   * @returns {Boolean}
   * @internal
   **/
  static get isTestEnv() {
    var _globalThis$bryntum;
    const isTestEnv = Boolean((_globalThis$bryntum = globalThis.bryntum) === null || _globalThis$bryntum === void 0 ? void 0 : _globalThis$bryntum.isTestEnv);
    try {
      var _globalThis$parent, _globalThis$parent$br;
      return isTestEnv || Boolean((_globalThis$parent = globalThis.parent) === null || _globalThis$parent === void 0 ? void 0 : (_globalThis$parent$br = _globalThis$parent.bryntum) === null || _globalThis$parent$br === void 0 ? void 0 : _globalThis$parent$br.isTestEnv);
    } catch (e) {
      // Accessing parent may cause CORS violation
      return isTestEnv;
    }
  }
  static get isDebug() {
    let result = false;
    return result;
  }
}
const VH = VersionHelper;
if (BrowserHelper.isBrowserEnv) {
  if (VH.isTestEnv) {
    BrowserHelper._isHoverableDevice = true;
  }
  globalThis.bryntum = Object.assign(globalThis.bryntum || {}, {
    getVersion: VH.getVersion.bind(VH),
    checkVersion: VH.checkVersion.bind(VH),
    deprecate: VH.deprecate.bind(VH),
    license: 'bf757ffb-df5b-11e9-9294-d094663d5c88'
  });
}
VersionHelper._$name = 'VersionHelper';

// We cannot import ObjectHelper because of the import cycle:
//  ObjectHelper -> DateHelper -> LocaleManager -> Base -> us
/**
 * @module Core/Config
 */
const {
    defineProperty: defineProperty$6,
    getOwnPropertyDescriptor: getOwnPropertyDescriptor$1
  } = Reflect,
  {
    hasOwnProperty: hasOwnProperty$3,
    toString: toString$2
  } = Object.prototype,
  instancePropertiesSymbol$1 = Symbol('instanceProperties'),
  configuringSymbol$1 = Symbol('configuring'),
  lazyConfigValues = Symbol('lazyConfigValues'),
  DATE_TYPE$1 = toString$2.call(new Date()),
  whitespace = /\s+/,
  createClsProps = (result, cls) => {
    result[cls] = 1;
    return result;
  };
/**
 * This class holds the description of a config property. Only one instance of this class is needed for each config
 * name (e.g., "text"). If config options are supplied, however, they also contribute to the cached instance.
 *
 * Instances should always be retrieved by calling `Config.get()`.
 *
 * The **Configs** of this class correspond to `options` that can be supplied to the `get()` method. These affect the
 * behavior of the config property in some way, as descried by their respective documentation.
 *
 * This class is not used directly.
 *
 * ## The Setter
 * The primary functionality provided by `Config` is its standard setter. This setter function ensures consistent
 * behavior when modifying config properties.
 *
 * The standard setter algorithm is as follows (using the `'text'` config for illustration):
 *
 *  - If the class defines a `changeText()` method, call it passing the new value and the current value:
 *    `changeText(newText, oldText)`.<br>
 *    Then:
 *    * If `changeText()` exits without returning a value (i.e., `undefined`), exit and do nothing further. The
 *      assumption is that the changer method has done all that is required.
 *    * Otherwise, the return value of `changeText()` replaces the incoming value passed to the setter.
 *  - If the new value (or the value returned by `changeText()`) is `!==` to the current value:
 *    * Update the stored config value in `this._text`.
 *    * If the class defines an `updateText()` method, call it passing the new value and the previous value.
 *      `updateText(newText, oldText)`
 *    * If the class defines an `onConfigChange()` method, call it passing an object with the following properties:
 *        - `name` - The config's name
 *        - `value` - The new value
 *        - `was` - The previous value
 *        - `config` - The `Config` instance.
 *
 * NOTE: unlike `changeText()` and `updateText()`, the name of the `onConfigChange()` method is unaffected by the
 * config's name.
 *
 * @internal
 */
class Config {
  /**
   * Returns the `Config` instance for the given `name` and `options`.
   * @param {String} name The name of the config (e.g., 'text' for the text config).
   * @param {Object} [options] Config behavior options.
   * @returns {Core.Config}
   * @internal
   */
  static get(name, options) {
    const {
        cache
      } = this,
      baseCfg = cache[name] || (cache[name] = new Config(name));
    let cfg = baseCfg,
      key;
    if (options) {
      key = Config.makeCacheKey(name, options);
      if (!(cfg = key && cache[key])) {
        cfg = baseCfg.extend(options);
        if (key) {
          cache[key] = cfg;
        }
      }
    }
    return cfg;
  }
  constructor(name) {
    const me = this,
      cap = name[0].toUpperCase() + name.substr(1);
    me.base = me; // so extend()ed configs have a link to the base definition
    me.name = name;
    me.field = '_' + name;
    me.capName = cap;
    me.changer = 'change' + cap;
    me.initializing = 'initializing' + cap;
    me.updater = 'update' + cap;
  }
  /**
   * The descriptor to use with `Reflect.defineProperty()` for defining this config's getter and setter.
   * @property {Object}
   * @private
   */
  get descriptor() {
    let descriptor = this._descriptor;
    if (!descriptor || !hasOwnProperty$3.call(this, '_descriptor')) {
      // lazily make the descriptor
      this._descriptor = descriptor = this.makeDescriptor();
    }
    return descriptor;
  }
  /**
   * The descriptor to use with `Reflect.defineProperty()` for defining this config's initter.
   * @property {Object}
   * @private
   */
  get initDescriptor() {
    let descriptor = this._initDescriptor;
    if (!descriptor || !hasOwnProperty$3.call(this, '_initDescriptor')) {
      // lazily make the descriptor
      this._initDescriptor = descriptor = this.makeInitter();
    }
    return descriptor;
  }
  /**
   * This method compares two values for semantic equality. By default, this is based on the `===` operator. This
   * is often overridden for configs that accept `Date` or array values.
   * @param {*} value1
   * @param {*} value2
   * @returns {Boolean}
   * @internal
   */
  equal(value1, value2) {
    return value1 === value2;
  }
  /**
   * Extends this config with a given additional set of options. These objects are just prototype extensions of this
   * instance.
   * @param {Object} options
   * @returns {Core.Config}
   * @internal
   */
  extend(options) {
    const cfg = Object.assign(Object.create(this), options),
      {
        equal,
        merge
      } = options,
      {
        equalityMethods
      } = Config;
    if (typeof equal === 'string') {
      if (equal.endsWith('[]')) {
        cfg.equal = Config.makeArrayEquals(equalityMethods[equal.substr(0, equal.length - 2)]);
      } else {
        cfg.equal = equalityMethods[equal];
      }
    }
    if (typeof merge === 'string') {
      // Base uses { merge : 'replace' } for defaultConfig properties
      cfg.merge = Config.mergeMethods[merge];
    }
    return cfg;
  }
  /**
   * Defines the property on a given target object via `Reflect.defineProperty()`. If the object has its own getter,
   * it will be preserved. It is invalid to define a setter.
   * @param {Object} target
   * @internal
   */
  define(target) {
    const existing = getOwnPropertyDescriptor$1(target, this.name);
    let descriptor = this.descriptor;
    if (existing && existing.get) {
      descriptor = Object.assign({}, descriptor);
      descriptor.get = existing.get;
    }
    defineProperty$6(target, this.name, descriptor);
  }
  /**
   * Defines the property initter on the `target`. This is a property getter/setter that propagates the configured
   * value when the property is read.
   * @param {Object} target
   * @param {*} value
   * @internal
   */
  defineInitter(target, value) {
    const {
        name
      } = this,
      properties = target[instancePropertiesSymbol$1];
    let lazyValues, prop;
    // If there is an existing property with a getter/setter, *not* a value
    // defined on the object for this config we must call it in our injected getter/setter.
    if (!properties[name] && ( /* assign */prop = getOwnPropertyDescriptor$1(target, name)) && !('value' in prop)) {
      properties[name] = prop;
    }
    // Set up a temporary instance property which will pull in the value from the initialConfig if the getter
    // is called first.
    defineProperty$6(target, name, this.initDescriptor);
    if (this.lazy) {
      lazyValues = target[lazyConfigValues] || (target[lazyConfigValues] = new Map());
      lazyValues.set(name, value);
    }
  }
  /**
   * Returns an equality function for arrays of a base type, for example `'date'`.
   * @param {Function} [fn] The function to use to compare array elements. By default, operator `===` is used.
   * @returns {Function}
   * @private
   */
  static makeArrayEquals(fn) {
    return (value1, value2) => {
      let i,
        equal = value1 && value2 && value1.length === (i = value2.length);
      if (equal && Array.isArray(value1) && Array.isArray(value2)) {
        if (fn) {
          while (equal && i-- > 0) {
            equal = fn(value1[i], value2[i]);
          }
        } else {
          while (equal && i-- > 0) {
            equal = value1[i] === value2[i];
          }
        }
      } else {
        equal = fn ? fn(value1, value2) : value1 === value2;
      }
      return equal;
    };
  }
  /**
   * Returns the key to use in the Config `cache`.
   * @param {String} name The name of the config property.
   * @param {Object} options The config property options.
   * @returns {String}
   * @private
   */
  static makeCacheKey(name, options) {
    const keys = Object.keys(options).sort();
    for /* empty */
    (let key, type, value, i = keys.length; i-- > 0;) {
      value = options[key = keys[i]];
      if (value == null && value === false) {
        keys.splice(i, 1);
      } else {
        type = typeof value;
        if (type === 'function') {
          return null;
        }
        if (type === 'string') {
          keys[i] = `${key}:"${value}"`;
        } else if (type === 'number') {
          keys[i] = `${key}:${value}`;
        }
        // that leaves bool and object, but there are no (valid) config options that are objects... so ignore
      }
    }

    return keys.length ? `${name}>${keys.join('|')}` : name; // eg: 'text>render|merge:v => v|bar'
  }
  /**
   * Creates and returns a property descriptor for this config suitable to be passed to `Reflect.defineProperty()`.
   * @returns {Object}
   * @private
   */
  makeDescriptor() {
    const config = this,
      {
        base,
        field,
        changer,
        updater,
        name
      } = config;
    if (base !== config && base.equal === config.equal) {
      // At present only the equal option affects the setter, so all configs can share the
      // descriptor of the base-most config definition unless their equality test fns differ.
      return base.descriptor;
    }
    return {
      get() {
        var _this$configObserver;
        // Allow folks like Widget.compose() to monitor getter calls
        (_this$configObserver = this.configObserver) === null || _this$configObserver === void 0 ? void 0 : _this$configObserver.get(name, this);
        return this[field];
      },
      set(value) {
        const me = this;
        let was = me[field],
          applied,
          newValue;
        // Resolve values starting with 'up.' by traversing owners to find it
        if (typeof value === 'string') {
          let resolvedValue = value;
          if (value.startsWith('up.')) {
            var _me$owner;
            resolvedValue = (_me$owner = me.owner) === null || _me$owner === void 0 ? void 0 : _me$owner.resolveProperty(value.substr(3));
          } else if (value.startsWith('this.')) {
            resolvedValue = me.resolveProperty(value.substr(5));
          }
          if (resolvedValue !== undefined && typeof resolvedValue !== 'function') {
            value = resolvedValue;
          }
        }
        // If the "changeTitle()" fellow falls off the end, it must have changed all the needful things.
        // Otherwise, it returned the final config value (it may have changed it instead, for example, making
        // an instance from a config object).
        if (me[changer]) {
          applied = (newValue = me[changer](value, was)) === undefined;
          if (!applied) {
            value = newValue;
            was = me[field]; // in case it was modified by the changer fn...
          }
        }
        // inline the default equal() for better perf:
        if (!applied && !(config.equal === equal ? was === value : config.equal(was, value))) {
          var _me$updater;
          me[field] = value;
          applied = true;
          // Check for a "updateTitle()" method and call it if present.
          (_me$updater = me[updater]) === null || _me$updater === void 0 ? void 0 : _me$updater.call(me, value, was);
        }
        // Trigger config change if the value changed, and updater did not lead to our destruction
        if (applied && !me.isDestroyed && !me.onConfigChange.$nullFn) {
          me.onConfigChange({
            name,
            value,
            was,
            config
          });
        }
      }
    };
  }
  /**
   * Creates and returns a property descriptor for this config's initter suitable to pass to
   * `Reflect.defineProperty()`.
   * @returns {Object}
   * @private
   */
  makeInitter() {
    const config = this;
    if (config !== config.base) {
      if (config.lazy) {
        return config.makeLazyInitter();
      }
      // At present no other options affect the setter, so all configs can share the descriptor of the base-most
      // config definition.
      return config.base.initDescriptor;
    }
    return config.makeBasicInitter();
  }
  makeBasicInitter() {
    const config = this,
      {
        initializing,
        name
      } = config;
    return {
      configurable: true,
      get() {
        const me = this;
        config.removeInitter(me);
        // Set the value from the configuration.
        me[initializing] = true;
        me[name] = me[configuringSymbol$1][name];
        me[initializing] = false;
        // The property has been *pulled* from the configuration.
        // Prevent the setting loop in configure from setting it again.
        me.configDone[name] = true;
        // Finally, allow the prototype getter to return the value.
        return me[name];
      },
      set(value) {
        config.removeInitter(this);
        // The config has been set (some internal code may have called the setter)
        // so prevent it from being called again and overwritten with data from initialConfig.
        this.configDone[name] = true;
        // Set the property normally (Any prototype setter will be invoked)
        this[name] = value;
      }
    };
  }
  makeLazyInitter() {
    const config = this,
      {
        initializing,
        name
      } = config;
    return {
      configurable: true,
      get() {
        const me = this,
          value = me[lazyConfigValues].get(name);
        config.removeInitter(me);
        if (!me.isDestroying) {
          // Set the value from the lazy config object.
          me[initializing] = true;
          me[name] = value;
          me[initializing] = false;
        }
        // Finally, allow the prototype getter to return the value.
        return me[name];
      },
      set(value) {
        config.removeInitter(this);
        // Set the property normally (Any prototype setter will be invoked)
        this[name] = value;
      }
    };
  }
  /**
   * Removes the property initter and restores the instance to its original form.
   * @param {Object} instance
   * @private
   */
  removeInitter(instance) {
    const {
        name
      } = this,
      instanceProperty = instance[instancePropertiesSymbol$1][name],
      lazyValues = instance[lazyConfigValues];
    // If we took over from an instance property, replace it
    if (instanceProperty) {
      defineProperty$6(instance, name, instanceProperty);
    }
    // Otherwise just delete the instance property who's getter we are in.
    else {
      delete instance[name];
    }
    if (lazyValues !== null && lazyValues !== void 0 && lazyValues.delete(name) && !lazyValues.size) {
      // we delete the keys so that we can tell if this particular lazy config has been initialized
      delete instance[lazyConfigValues];
    }
  }
  setDefault(cls, value) {
    defineProperty$6(cls.prototype, this.field, {
      configurable: true,
      writable: true,
      // or else "this._value = x" will fail
      value
    });
  }
  /**
   * This method combines (merges) two config values. This is called in two cases:
   *
   *  - When a derived class specifies the value of a config defined in a super class.
   *  - When a value is specified in the instance config object.
   *
   * @param {*} newValue In the case of derived classes, this is the config value of the derived class. In the case
   * of the instance config, this is the instance config value.
   * @param {*} currentValue In the case of derived classes, this is the config value of the super class. In the case
   * of the instance config, this is the class config value.
   * @param {Object} metaNew The class meta object from which the `newValue` is coming. This parameter is `null` if
   * the `newValue` is from an instance configuration.
   * @param {Object} metaCurrent The class meta object from which the `currentValue` is coming. This parameter is
   * `null` if the `currentValue` is not from a class configuration.
   * @returns {*}
   * @internal
   */
  merge(newValue, currentValue) {
    if (currentValue && newValue && Objects.isObject(newValue)) {
      // If existing value is a class instance, clone and merge won't work. Set the configs.
      if (currentValue.isBase) {
        return currentValue.setConfig(newValue);
      }
      if (Objects.isObject(currentValue)) {
        newValue = Objects.merge(Objects.clone(currentValue), newValue);
      }
    }
    return newValue;
  }
}
const {
    prototype
  } = Config,
  {
    equal
  } = prototype;
Config.symbols = {
  configuring: configuringSymbol$1,
  instanceProperties: instancePropertiesSymbol$1,
  lazyConfigs: lazyConfigValues
};
/**
 * This object holds `Config` instances keyed by their name. For example:
 *
 * ```javascript
 *  Config.cache = {
 *      disabled : Config.get('disabled'),
 *      text     : Config.get('text'),
 *      title    : Config.get('title')
 *  };
 * ```
 *
 * @member {Object} cache
 * @static
 * @private
 */
Config.cache = Object.create(null); // object w/no properties not even inherited ones
/**
 * This object holds config value equality methods. By default, the `===` operator is used to compare config values for
 * semantic equality. When an `equal` option is specified as a string, that string is used as a key into this object.
 *
 * All equality methods in this object have the same signature as the {@link #function-equal equal()} method.
 *
 * This object has the following equality methods:
 *
 * - `array` : Compares arrays of values using `===` on each element.
 * - `date` : Compares values of `Date` type.
 * - `strict` : The default equal algorithm based on `===` operator.
 * @member {Object} equalityMethods
 * @static
 * @private
 */
Config.equalityMethods = {
  array: Config.makeArrayEquals(),
  date(value1, value2) {
    if (value1 === value2) {
      return true;
    }
    // see DateHelper.isDate() but cannot import due to circularity
    if (value1 && value2 && toString$2.call(value1) === DATE_TYPE$1 && toString$2.call(value2) === DATE_TYPE$1) {
      // https://jsbench.me/ltkb3vk0ji/1 - getTime is >2x faster vs valueOf/Number/op+
      return value1.getTime() === value2.getTime();
    }
    return false;
  },
  strict: Config.equal = equal
};
/**
 * This object holds config value merge methods. By default, {@link Core.helper.ObjectHelper#function-merge-static} is
 * used to merge object's by their properties. Config merge methods are used to combine config values from derived
 * classes with config values from super classes, as well as instance config values with those of the class.
 *
 * All merge methods in this object have the same signature as the {@link #function-merge merge()} method.
 *
 * This object has the following merge methods:
 *
 * - `distinct`   : Combines arrays of values ensuring that no value is duplicated. When given an object, its truthy
 *   keys are included, while its falsy keys are removed from the result.
 * - `merge`      : The default merge algorithm for `configurable()` properties, based on
 *   {@link Core.helper.ObjectHelper#function-merge-static}.
 * - `items`      : Similar to `merge`, but allows reordering (see `Objects.mergeItems`).
 * - `objects`    : The same as to `merge` except this method promotes `true` to an empty object.
 * - 'classList'  : Incoming strings are converted to an object where the string is a property name with a truthy value.
 * - `replace`    : Always returns `newValue` to replace the super class value with the derived class value, or the
 *   class value with the instance value.
 * @member {Object} mergeMethods
 * @static
 * @internal
 */
Config.mergeMethods = {
  distinct(newValue, oldValue) {
    let ret = oldValue ? oldValue.slice() : [];
    if (newValue != null) {
      if (Objects.isObject(newValue)) {
        if (oldValue === undefined) {
          ret = newValue;
        } else {
          let key, index;
          for (key in newValue) {
            index = ret.indexOf(key);
            if (newValue[key]) {
              if (index < 0) {
                ret.push(key);
              }
            } else if (index > -1) {
              ret.splice(index, 1);
            }
          }
        }
      } else if (Array.isArray(newValue)) {
        newValue.forEach(v => !ret.includes(v) && ret.push(v));
      } else if (!ret.includes(newValue)) {
        ret.push(newValue);
      }
    }
    return ret;
  },
  merge: Config.merge = prototype.merge,
  classList(newValue, oldValue) {
    // 'foo bar' -> { foo : 1, bar : 1 }
    if (typeof newValue === 'string') {
      if (!newValue.length) {
        return oldValue;
      }
      newValue = newValue.split(whitespace);
    }
    if (Array.isArray(newValue)) {
      newValue = newValue.reduce(createClsProps, {});
    }
    return Config.merge(newValue, oldValue);
  },
  objects(newValue, oldValue) {
    return newValue === true ? oldValue || {} : Config.merge(newValue, oldValue);
  },
  replace(newValue) {
    return newValue;
  },
  items(newValue, oldValue, metaNew, metaCurrent) {
    if (metaCurrent) {
      // When we have metaCurrent, we are merging with a class config object, so we apply the smart merge algo
      // only in that case. Merging instance configs would lose the 'clever > syntax' info needed when the
      // time comes to actually configure an instance.
      return Objects.mergeItems(oldValue, newValue, {
        merge: (oldValue, newValue) => prototype.merge(newValue, oldValue)
      });
    }
    return prototype.merge(newValue, oldValue);
  }
};
Object.assign(prototype, {
  _descriptor: null,
  _initDescriptor: null,
  /**
   * A function that compares values for equality. This test is used to determine if the `update` method should be
   * called when the setter is invoked.
   *
   * To handle `Date` values:
   * ```
   *  class Foo extends Base {
   *      static get configurable() {
   *          return {
   *              date : {
   *                  $config : {
   *                      equal : 'date'
   *                  },
   *
   *                  value : null
   *              }
   *          }
   *      }
   *
   *      updateDate(date) {
   *          // date has changed
   *      }
   *  }
   * ```
   *
   * Also useful for some configs:
   * ```
   *  class Foo extends Base {
   *      static get configurable() {
   *          return {
   *              bar : {
   *                  $config : {
   *                      equal : ObjectHelper.isEqual
   *                  },
   *
   *                  value : null
   *              }
   *          }
   *      }
   *
   *      updateBar(value) {
   *          // value has changed
   *      }
   *  }
   * ```
   * @config {Function} equal
   * @internal
   */
  /**
   * Indicates that this config property should not automatically initialize during construction. When this property
   * is set to `true`, initialization is triggered by the first use of the config property's getter.
   *
   * This property can alternatively be set to a string, in which case it can be initialized as a group using the
   * {@link Core.Base#function-triggerConfigs} method which will initialize all lazy configs with the same value for
   * this property. Note: the config will still initialize on first use if that occurs prior to the call to
   * `triggerConfigs`.
   * @config {Boolean|String}
   * @default
   * @internal
   */
  lazy: false,
  /**
   * Indicates that this config property should automatically be set to `null` on destroy.
   * @config {Boolean}
   * @default
   * @internal
   */
  nullify: false,
  /**
   * Indicates that this config participates in rendering. This has does not affect the behavior of the property
   * directly, but allows classes that perform rendering to detect which config changes will affect the rendered
   * result.
   * @config {Boolean}
   * @default
   * @internal
   */
  render: false
});
Config._$name = 'Config';

/**
 * @module Core/Base
 */
class MetaClass {
  constructor(options) {
    options && Object.assign(this, options);
  }
  getInherited(name, create = true) {
    let ret = this[name];
    // We use "in this" to allow the object to be set to null
    if (!(name in this)) {
      var _this$super;
      // If there is no object on this metaclass, but there may be one on a super class. If create=false, the
      // idea is that a super class object will be "properly" inherited but otherwise no object will be created.
      ret = (_this$super = this.super) === null || _this$super === void 0 ? void 0 : _this$super.getInherited(name, create);
      if (ret || create) {
        this[name] = ret = Object.create(ret || null);
      }
    }
    return ret;
  }
}
const // Using Object.getPrototypeOf instead of Reflect.getPrototypeOf because:
  // 1. They are almost the same, according to the MDN difference is handling getPrototypeOf('string')
  // 2. It allows us to pass security check in SalesForce environment
  {
    getPrototypeOf: getPrototypeOf$1
  } = Object,
  {
    hasOwn: hasOwn$3
  } = Objects,
  {
    defineProperty: defineProperty$5
  } = Reflect,
  metaSymbol = Symbol('classMetaData'),
  mixinTagSymbol = Symbol('mixinTag'),
  originalConfigSymbol = Symbol('originalConfig'),
  configuringSymbol = Config.symbols.configuring,
  instancePropertiesSymbol = Config.symbols.instanceProperties,
  lazyConfigsSymbol = Config.symbols.lazyConfigs,
  defaultConfigOptions = {
    merge: 'replace',
    simple: true
  },
  emptyFn$1 = () => {},
  newMeta = o => new MetaClass(o),
  setupNames = {/* foo : 'setupFoo' */},
  emptyObject$7 = Object.freeze({}),
  emptyArray$6 = Object.freeze([]);
/**
 * Base class for all configurable classes.
 *
 * Subclasses do not have to implement a constructor with its restriction of having to call super()
 * before there is a `this` reference. Subclasses instead implement a `construct` method which is
 * called by the `Base` constructor. This may call its `super` implementation at any time.
 *
 * The `Base` constructor applies all configs to properties of the new instance. The instance
 * will have been configured after the `super.construct(config)` is called.
 *
 * See the Class System documentation in the guides for more information.
 *
 * @abstract
 */
class Base {
  static get isBase() {
    return true;
  }
  get isBase() {
    return true;
  }
  // defaultConfig & properties made private to not spam all other classes
  /**
   * A class property getter to add additional, special class properties.
   *
   * For example, a class adds a `declarable` class property like so:
   * ```
   *  class Something extends Base {
   *      static get declarable() {
   *          return ['extra'];
   *      }
   *
   *      static setupExtra(cls, meta) {
   *          // use cls.extra
   *      }
   *  }
   * ```
   * A derived class can then specify this property like so:
   * ```
   *  class Derived extends Something {
   *      static get extra() {
   *          // return extra information
   *      }
   *  }
   * ```
   * When the `Derived` class is initialized, the `setupExtra()` method is called and `Derived` is passed as the
   * argument. It is also the `this` pointer, but the parameter is minifiable. The second argument passed is the
   * `$meta` object for the class.
   *
   * Classes are initialized at the first occurrence of the following:
   *
   * - An instance is created
   * - The class `$meta` property is accessed
   *
   * @member {String[]} declarable
   * @static
   * @category Configuration
   * @internal
   */
  static get declarable() {
    return ['declarable',
    /**
     * A class property getter for the configuration properties of the class, which can be overridden by
     * configurations passed at construction time.
     *
     * Unlike a normal `static` property, this property is only ever used for the class that defines it (as in,
     * `hasOwnProperty`). It is retrieved for all classes in a class hierarchy, to gather their configs
     * individually and then combine them with those of derived classes.
     *
     * For example, a `Label` might declare a `text` config like so:
     * ```javascript
     *  class Label extends Base {
     *      static get configurable() {
     *          return {
     *              text : null
     *          };
     *      }
     *  }
     * ```
     * The `text` config is automatically inherited by classes derived from Label. By implementing
     * `get configurable()`, derived classes can change the default value of inherited configs, or define new
     * configs, or both.
     *
     * When a config property is declared in this way, the class author can also implement either of two
     * special methods that will be called when the config property is assigned a new value:
     *
     *  - `changeText()`
     *  - `updateText()`
     *
     * In the example above, the `Label` class could implement a `changeText()` method, an `updateText()`
     * method, or both. The generated property setter ensures these methods will be called when the `text`
     * property is assigned.
     *
     * The generated setter (for `text` in this example) performs the following steps:
     *
     *  - If the class defines a `changeText()` method, call it passing the new value and the current value:
     *    `changeText(newText, oldText)`.<br>
     *    Then:
     *    * If `changeText()` exits without returning a value (i.e., `undefined`), exit and do nothing
     *      further. The assumption is that the changer method has done all that is required.
     *    * Otherwise, the return value of `changeText()` replaces the incoming value passed to the setter.
     *  - If the new value (or the value returned by `changeText()`) is `!==` to the current value:
     *    * Update the stored config value in `this._text`.
     *    * If the class defines an `updateText()` method, call it passing the new value and the previous value.
     *      `updateText(newText, oldText)`
     *
     * #### Resolving a value from an owner
     * By specifying a value starting with `'up.'` for a config, the config system will resolve that value by
     * examining the ownership hierarchy. It will walk up the hierarchy looking for a property matching the name
     * (or dot separated path) after 'up.'. If one is found, the value will be read and used as the initial
     * value.
     *
     * ```javascript
     * class Parent extends Base {
     *     static get configurable() {
     *         return [
     *           'importantValue'
     *         ]
     *     }
     * }
     *
     * class Child extends Base {
     *     static get configurable() {
     *         return [
     *           'value'
     *         ]
     *     }
     * }
     *
     * const parent = new Parent({
     *     importantValue : 123
     * });
     *
     * const child = new Child({
     *     owner : parent,
     *     // Will be resolved from the owner
     *     value : 'up.importantValue'
     * });
     *
     * console.log(child.value); // logs 123
     * ```
     * Please note that this is for now a one way one time binding, the value will only be read initially and
     * not kept up to date on later changes.
     *
     * #### Value Merging
     * When a config property value is an object, the value declared by the base class is merged with values
     * declared by derived classes and the value passed to the constructor.
     * ```javascript
     *  class Example extends Base {
     *      static get configurable() {
     *          return {
     *              config : {
     *                  foo : 1,
     *                  bar : 2
     *              }
     *          };
     *      }
     *  }
     *
     *  class Example2 extends Example {
     *      static get configurable() {
     *          return {
     *              config : {
     *                  bar : 42,
     *                  zip : 'abc'
     *              }
     *          };
     *      }
     *  }
     *
     *  let ex = new Example2({
     *      config : {
     *          zip : 'xyz'
     *      }
     *  });
     * ```
     * The result of the merge would set `config` to:
     * ```javascript
     *  ex.foo = {
     *      foo : 1,    // from Example
     *      bar : 42,   // from Example2
     *      zip : 'xyz' // from constructor
     *  }
     * ```
     *
     * #### Config Options
     * Some config properties require additional options such as declarative information about the config that
     * may be useful to automate some operation. Consider a `Button`. It could declare that its `text` config
     * affects the rendered HTML by applying a `render` property to the config definition. Its base class could
     * then examine the config definition to find this property.
     *
     * To support this, config options ca be declared like so:
     * ```javascript
     *  class Button extends Widget {
     *      static get configurable() {
     *          return {
     *              text : {
     *                  value   : null,
     *                  $config : {
     *                      render : true
     *                  }
     *              }
     *          };
     *      }
     *  }
     * ```
     * The `$config` property can alternatively be just the names of the options that should be enabled (set
     * to `true`).
     *
     * For example, the following is equivalent to the above:
     * ```javascript
     *  class Button extends Widget {
     *      static get configurable() {
     *          return {
     *              text : {
     *                  value   : null,
     *                  $config : 'render'
     *              }
     *          };
     *  }
     * ```
     *
     * #### Default Value
     * It is common to set a config to a `null` value to take advantage of internal optimizations for `null`
     * values. In most cases the fact that this produces `undefined` as the actual initial value of the config
     * is acceptable. When this is not acceptable, a config can be declared like so:
     * ```javascript
     *  class Widget {
     *      static get configurable() {
     *          return {
     *              disabled : {
     *                  $config : null,
     *                  value   : null,
     *                  default : false
     *              }
     *          };
     *  }
     * ```
     * The `default` property above determines the value of the config while still gaining the benefits of
     * minimal processing due to the `null` value of the `value` property.
     * @member {Object} configurable
     * @static
     * @category Configuration
     * @internal
     */
    'configurable',
    /**
     * A class property getter for the default configuration of the class, which can be overridden by
     * configurations passed at construction time.
     *
     * Unlike a normal `static` property, this property is only ever used for the class that defines it (as in,
     * `hasOwnProperty`). It is retrieved for all classes in a class hierarchy, to gather their configs
     * individually and then combine them with those of derived classes.
     *
     * For example, a `Store` might declare its `url` config like so:
     * ```
     *  class Store extends Base {
     *      static get defaultConfig() {
     *          return {
     *              url : null
     *          };
     *      }
     *  }
     * ```
     * The `url` config is automatically inherited by classes derived from Store. By implementing
     * `get defaultConfig()`, derived classes can change the default value of inherited configs, or define new
     * configs, or both. When defining new configs, however, `configurable` is preferred.
     *
     * Config properties introduced to a class by this declaration do not participate in value merging and do
     * not get a generated setter. Config properties introduced by a base class using `configurable` can be
     * set to a different value using `defaultConfig` and in doing so, the values will be merged as appropriate
     * for `configurable`.
     *
     * @member {Object} defaultConfig
     * @static
     * @category Configuration
     * @internal
     */
    'defaultConfig',
    /**
     * A class property getter for the default values of internal properties for this class.
     * @member {Object} properties
     * @static
     * @category Configuration
     * @internal
     */
    'properties',
    /**
     * A class property getter for properties that will be applied to the class prototype.
     * @member {Object} prototypeProperties
     * @static
     * @category Configuration
     * @internal
     */
    'prototypeProperties'];
  }
  /**
   * Base constructor, passes arguments to {@link #function-construct}.
   * @param {...Object} [args] Usually called with a config object, but accepts any params
   * @function constructor
   * @category Lifecycle
   * @advanced
   */
  constructor(...args) {
    const me = this,
      C = me.constructor;
    if (me.$meta.class !== C) {
      // This will happen only once for each class. We need to call the C.$meta getter which puts $meta on our
      // prototype. Since that alone would be optimized away (and would generate IDE and lint warnings), we call
      // emptyFn and simply pass the value.
      emptyFn$1(C.$meta);
    }
    // Allow subclasses to have a pseudo constructor with "this" already set:
    me.construct(...args);
    me.afterConstruct();
    me.isConstructing = false;
  }
  /**
   * Factory version of the Base constructor. Merges all arguments to create a config object that is passed along to
   * the constructor.
   * @param {...Object} [configs] Allows passing multiple config objects
   * @returns {Core.Base} New instance
   * @private
   */
  static new(...configs) {
    configs = configs.filter(c => c);
    return new this(configs.length > 1 ? this.mergeConfigs(...configs) : configs[0]);
  }
  /**
   * Base implementation applies configuration.
   *
   * Subclasses need only implement this if they have to initialize instance specific
   * properties required by the class. Often a `construct` method is
   * unnecessary. All initialization of incoming configuration properties can be
   * done in a `set propName` implementation.
   * @param {...Object} [args] Usually called with a config object, but accepts any params
   * @category Lifecycle
   * @advanced
   */
  construct(...args) {
    // Passing null to base construct means bypass the config system and stack creation (to gain performance)
    if (args[0] !== null) {
      this.configure(...args);
    }
    this.afterConfigure();
  }
  /**
   * Destroys the provided objects by calling their {@link #function-destroy} method.
   * Skips empty values or objects that are already destroyed.
   *
   * ```javascript
   * Base.destroy(myButton, toolbar1, helloWorldMessageBox);
   * ```
   * @param {...Object} [args] Objects to be destroyed
   * @category Lifecycle
   * @advanced
   */
  static destroy(...args) {
    const shredder = object => {
      if (object !== null && object !== void 0 && object.destroy) {
        object.destroy();
      } else if (Array.isArray(object)) {
        object.forEach(shredder);
      }
    };
    shredder(args);
  }
  /**
   * Destroys this object.
   *
   * {@advanced}
   * This is primarily accomplished by calling {@link #function-doDestroy}, however, prior to
   * calling `doDestroy`, {@link #property-isDestroying} is set to `true`. After {@link #function-doDestroy} returns,
   * {@link #property-isDestroyed} is set to `true`.
   *
   * Do not override this method in subclasses. To provide class-specific cleanup, implement {@link #function-doDestroy}
   * instead.
   * {/@advanced}
   *
   * @category Lifecycle
   */
  destroy() {
    const me = this,
      {
        id
      } = me;
    // Let everyone know the object is going inert:
    me.isDestroying = true;
    // Make calling destroy() harmless:
    me.destroy = emptyFn$1;
    me.doDestroy();
    Object.setPrototypeOf(me, null);
    // Clear all remaining instance properties.
    for (const key in me) {
      if (key !== 'destroy' && key !== 'isDestroying') {
        delete me[key];
      }
    }
    delete me[originalConfigSymbol];
    // Let everyone know the object is inert:
    me.isDestroyed = true;
    me.id = id; // for diagnostic reasons
  }
  /**
   * This method is required to help `unused` getters to survive production build process. Some tools, like angular,
   * will remove `unused` code in production build, making our side-effected getters behind, breaking code heavily.
   * @internal
   * @param getter Getter to evaluate
   */
  _thisIsAUsedExpression(getter) {}
  static get $$name() {
    return hasOwn$3(this, '$name') && this.$name ||
    // _$name is filled by webpack for every class (cls._$name = '...')
    hasOwn$3(this, '_$name') && this._$name || this.name;
  }
  get $$name() {
    return this.constructor.$$name;
  }
  /**
   * Base implementation so that all subclasses and mixins may safely call super.startConfigure.
   *
   * This is called by the Base class before setting configuration properties, but after
   * the active initial getters have been set, so all configurations are available.
   *
   * This method allows all classes in the hierarchy to force some configs to be evaluated before others.
   * @internal
   * @category Lifecycle
   * @params {Object} config The configuration object use to set the initial state.
   */
  startConfigure(config) {}
  /**
   * Base implementation so that all subclasses and mixins may safely call super.finishConfigure.
   *
   * This is called by the Base class before exiting the {@link #function-configure} method.
   *
   * At this point, all configs have been applied, but the `isConfiguring` property is still set.
   *
   * This method allows all classes in the hierarchy to inject functionality
   * into the config phase.
   * @internal
   * @category Lifecycle
   * @params {Object} config The configuration object use to set the initial state.
   */
  finishConfigure(config) {}
  /**
   * Base implementation so that all subclasses and mixins may safely call `super.afterConfigure`. This is called by the Base class after the {@link #function-configure} method has been
   * called. At this point, all configs have been applied.
   *
   * This method allows all classes in the hierarchy to inject functionality
   * either before or after the super.afterConstruct();
   * @internal
   * @category Lifecycle
   */
  afterConfigure() {}
  /**
   * Base implementation so that all subclasses and mixins may safely call super.afterConstruct.
   *
   * This is called by the Base class after the {@link #function-construct} method has been
   * called.
   *
   * At this point, all configs have been applied.
   *
   * This method allows all classes in the hierarchy to inject functionality
   * either before or after the super.afterConstruct();
   * @internal
   * @function afterConstructor
   * @category Lifecycle
   */
  afterConstruct() {}
  /**
   * Provides a way of calling callbacks which may have been specified as the _name_ of a function
   * and optionally adds scope resolution.
   *
   * For example, if the callback is specified as a string, then if it is prefixed with `'this.'`
   * then the function is resolved in this object. This is useful when configuring listeners
   * at the class level.
   *
   * If the callback name is prefixed with `'up.'` then the ownership hierarchy is queried
   * using the `owner` property until an object with the named function is present, then the
   * named function is called upon that object.
   *
   * If a named function is not found, an error is thrown. If the function should be only called when present,
   * and may not be present, add a `?` as a suffix.
   *
   * @param {String|Function} fn The function to call, or the name of the function to call.
   * @param {Object} thisObject The `this` object of the function.
   * @param {Object[]} args The argument list to pass.
   * @category Misc
   * @advanced
   */
  callback(fn, thisObject, args = emptyArray$6) {
    // Maintainer: do not make args ...args. This method may acquire more arguments
    const {
      handler,
      thisObj
    } = this.resolveCallback(fn, thisObject === 'this' ? this : thisObject) || emptyObject$7;
    return handler === null || handler === void 0 ? void 0 : handler.apply(thisObj, args);
  }
  resolveProperty(propertyPath) {
    let thisObj = this;
    while (thisObj) {
      if (Objects.hasPath(thisObj, propertyPath)) {
        return Objects.getPath(thisObj, propertyPath);
      }
      thisObj = thisObj.owner;
    }
    return undefined;
  }
  /**
   * Provides a way of locating callbacks which may have been specified as the _name_ of a function
   * and optionally adds scope resolution.
   *
   * For example, if the callback is specified as a string, then if it is prefixed with `'this.'`
   * then the function is resolved in this object. This is useful when configuring listeners
   * at the class level.
   *
   * If the callback name is prefixed with `'up.'` then the ownership hierarchy is queried
   * using the `owner` property until an object with the named function is present, then the
   * named function is called upon that object.
   * @param {String|Function} handler The function to call, or the name of the function to call.
   * @param {Object} thisObj The `this` object of the function.
   * @param {Boolean} [enforceCallability = true] Pass `false` if the function may not exist, and a null return value is acceptable.
   * @returns {Object} `{ handler, thisObj }`
   * @category Misc
   * @advanced
   */
  resolveCallback(handler, thisObj = this, enforceCallability = true) {
    var _handler;
    // It's a string, we find it in its own thisObj
    if ((_handler = handler) !== null && _handler !== void 0 && _handler.substring) {
      if (handler.endsWith('?')) {
        enforceCallability = false;
        handler = handler.substring(0, handler.length - 1);
      }
      if (handler.startsWith('up.')) {
        handler = handler.substring(3);
        // Empty loop until we find the function owner
        for (thisObj = this.owner; thisObj && !thisObj[handler]; thisObj = thisObj.owner);
        if (!thisObj) {
          return;
        }
      } else if (handler.startsWith('this.')) {
        handler = handler.substring(5);
        thisObj = this;
      }
      if (!thisObj || !(thisObj instanceof Object)) {
        return;
      }
      handler = thisObj[handler];
    }
    // Any other type than string or function results in unresolved callback
    if (typeof handler === 'function') {
      return {
        handler,
        thisObj
      };
    }
    if (enforceCallability) {
      throw new Error(`No method named ${handler} on ${thisObj.$$name || 'thisObj object'}`);
    }
  }
  bindCallback(inHandler, inThisObj = this) {
    if (inHandler) {
      const {
        handler,
        thisObj
      } = this.resolveCallback(inHandler, inThisObj);
      if (handler) {
        return handler.bind(thisObj);
      }
    }
  }
  /**
   * Delays the execution of the passed function by the passed time quantum, or if the time is omitted
   * or not a number, delays until the next animation frame. Note that this will use
   * {@link Core.mixin.Delayable#function-setTimeout} || {@link Core.mixin.Delayable#function-requestAnimationFrame}
   * if this class mixes in `Delayable`, otherwise it uses the global methods. The function will
   * be called using `this` object as its execution scope.
   * @param {Function} fn The function to call on a delay.
   * @param {Number} [delay] The number of milliseconds to delay.
   * @param {String} [name] The name of delay
   * @returns {Number} The created timeout id.
   * @private
   */
  delay(fn, delay, name = fn.name || fn) {
    // Force scope on the fn if we are not a Delayable
    fn = this.setTimeout ? fn : fn.bind(this);
    const invoker = this.setTimeout ? this : globalThis;
    return invoker[typeof delay === 'number' ? 'setTimeout' : 'requestAnimationFrame'](fn, delay, name);
  }
  /**
   * Classes implement this method to provide custom cleanup logic before calling `super.doDestroy()`. The general
   * pattern is as follows:
   *
   * ```javascript
   *  class Foo extends Base {
   *      doDestroy() {
   *          // perform custom cleanup
   *
   *          super.doDestroy();
   *      }
   *  }
   * ```
   *
   * This method is called by {@link #function-destroy} which also prevents multiple calls from reaching `doDestroy`.
   * Prior to calling `doDestroy`, {@link #property-isDestroying} is set to `true`. Upon return, the object is fully
   * destructed and {@link #property-isDestroyed} is set to `true`.
   *
   * Do not call this method directly. Instead call {@link #function-destroy}.
   * @category Lifecycle
   * @advanced
   */
  doDestroy() {
    const me = this,
      {
        nullify
      } = me.$meta;
    if (nullify) {
      for (let i = 0; i < nullify.length; ++i) {
        if (me[nullify[i].field] != null) {
          // if backing property is null/undefined then skip
          me[nullify[i].name] = null; // else, call setter to run through change/update
        }
      }
    }
  }
  /**
   * Destroys the named properties if they have been initialized, and if they have a `destroy` method.
   * Deletes the property from this object. For example:
   *
   *      this.destroyProperties('store', 'resourceStore', 'eventStore', 'dependencyStore', 'assignmentStore');
   *
   * @param {String} properties The names of the properties to destroy.
   * @internal
   * @category Lifecycle
   */
  destroyProperties(...properties) {
    const me = this;
    let key;
    for (key of properties) {
      // If the value has *not* been pulled in from the configuration object yet
      // we must not try to access it, as that will cause the property to be initialized.
      if (key in me && (!me[configuringSymbol] || !me[configuringSymbol][key])) {
        var _me$key, _me$key$destroy, _me$key2;
        (_me$key = me[key]) === null || _me$key === void 0 ? void 0 : (_me$key$destroy = (_me$key2 = _me$key).destroy) === null || _me$key$destroy === void 0 ? void 0 : _me$key$destroy.call(_me$key2);
        delete me[key];
      }
    }
  }
  /**
   * Called by the Base constructor to apply configs to this instance. This must not be called.
   * @param {Object} config The configuration object from which instance properties are initialized.
   * @private
   * @category Lifecycle
   */
  configure(config = {}) {
    const me = this,
      meta = me.$meta,
      {
        beforeConfigure
      } = config,
      configs = meta.configs,
      fullConfig = me.getDefaultConfiguration();
    let cfg, key, value;
    me.initialConfig = config;
    // Important flag for setters to know whether they are being called during
    // configuration when this object is not fully alive, or whether it's being reconfigured.
    me.isConfiguring = true;
    // Assign any instance properties declared by the class.
    Object.assign(me, me.getProperties());
    // Apply configuration to default from class definition. This is safe because it's either chained from or a
    // fork of the class values.
    for (key in config) {
      value = config[key];
      cfg = configs[key];
      fullConfig[key] = cfg ? cfg.merge(value, fullConfig[key], null, meta) : value;
    }
    if (beforeConfigure) {
      delete fullConfig.beforeConfigure;
      // noinspection JSValidateTypes
      beforeConfigure(me, fullConfig);
    }
    // Cache me.config for use by get config.
    me.setConfig(me[originalConfigSymbol] = fullConfig, true);
    me.isConfiguring = false;
  }
  /**
   * Returns the value of the specified config property. This is a method to allow
   * property getters to be explicitly called in a way that does not get optimized out.
   *
   * The following triggers the getter call, but optimizers will remove it:
   *
   *      inst.foo;   // also raises "expression has no side-effects" warning
   *
   * Instead, do the following to trigger a getter:
   *
   *      inst.getConfig('foo');
   *
   * @param {String} name
   * @internal
   * @category Configuration
   */
  getConfig(name) {
    return this[name];
  }
  /**
   * Sets configuration options this object with all the properties passed in the parameter object.
   * Timing is taken care of. If the setter of one config is called first, and references
   * the value of another config which has not yet been set, that config will be set just
   * in time, and the *new* value will be used.
   * @param {Object} config An object containing configurations to change.
   * @category Lifecycle
   * @advanced
   */
  setConfig(config, isConstructing) {
    const me = this,
      wasConfiguring = me[configuringSymbol],
      configDone = wasConfiguring ? me.configDone : me.configDone = {},
      configs = me.$meta.configs;
    let cfg, key;
    me[instancePropertiesSymbol] = {};
    // Cache configuration for use by injected property initializers.
    me[configuringSymbol] = wasConfiguring ? Object.setPrototypeOf(Object.assign({}, config), wasConfiguring) : config;
    // For each incoming non-null configuration, create a temporary getter which will
    // pull the value in from the initialConfig so that it doesn't matter in
    // which order properties are set. You can access any property at any time.
    for (key in config) {
      // Don't default null configs in unless it's a direct property of the
      // the passed configuration. When used at construct time, defaultConfigs
      // will be prototype-chained onto the config.
      if (config[key] != null || hasOwn$3(config, key)) {
        cfg = configs[key] || Config.get(key);
        cfg.defineInitter(me, config[key]);
        if (!isConstructing) {
          configDone[key] = false;
        }
        // else if (cfg.lazy) {
        //     // This was done originally to prevent our for-loop below from poking the value on the instance
        //     // at this stage. It was removed since it confused triggerConfig, and it just isn't true that the
        //     // lazy config is done...
        //     configDone[key] = true;
        // }
      } else {
        configDone[key] = true;
      }
    }
    if (isConstructing) {
      me.startConfigure(config);
    }
    // Set all our properties from the config object.
    // If one of the properties needs to access a property that has not
    // yet been set, the above temporary property will pull it through.
    // Can't use Object.assign because that only uses own properties.
    // config value blocks are prototype chained subclass->superclass
    for (key in config) {
      var _configs$key;
      // Only push the value through if the property initializer is still present.
      // If it gets triggered to pull the configuration value in, it deleted itself.
      if (!configDone[key] && !((_configs$key = configs[key]) !== null && _configs$key !== void 0 && _configs$key.lazy)) {
        me[key] = config[key];
      }
    }
    if (wasConfiguring) {
      me[configuringSymbol] = wasConfiguring;
    } else {
      delete me[configuringSymbol];
    }
    if (isConstructing) {
      me.finishConfigure(config);
    }
    return me;
  }
  /**
   * Returns `true` if this instance has a non-null value for the specified config. This will not activate a lazy
   * config.
   *
   * @param {String} name The name of the config property.
   * @returns {Boolean}
   * @internal
   */
  hasConfig(name) {
    var _me$lazyConfigsSymbol;
    const me = this,
      config = me[configuringSymbol];
    return Boolean(me['_' + name] != null ||
    // value has been assigned to backing property
    ((_me$lazyConfigsSymbol = me[lazyConfigsSymbol]) === null || _me$lazyConfigsSymbol === void 0 ? void 0 : _me$lazyConfigsSymbol.get(name)) != null ||
    // a lazy value is pending

    // config value has not been assigned but will be
    !me.configDone[name] && config && (config[name] != null || hasOwn$3(config, name)));
  }
  /**
   * Returns the value of an uningested config *without* ingesting the config or transforming
   * it from its raw value using its `changeXxxxx` method.
   *
   * @param {String} name The name of the config property.
   * @returns {*} The raw incoming config value.
   * @internal
   */
  peekConfig(name) {
    const me = this,
      lazyConfig = me[lazyConfigsSymbol],
      config = me[configuringSymbol];
    // It's waiting in the lazy configs
    if (lazyConfig !== null && lazyConfig !== void 0 && lazyConfig.has(name)) {
      return lazyConfig.get(name);
    }
    if (config && name in config) {
      // It's been read in, so use the current value
      if (me.configDone[name]) {
        return me[name];
      }
      if (config[name] != null || hasOwn$3(config, name)) {
        return config[name];
      }
    }
  }
  /**
   * Ensures that the specified config is initialized if it is needed. If there is a config value specified, and it
   * was initialized by this call, this method returns `true`. If there was a config value specified, and it was
   * already initialized, this method returns `false`. If there was no value specified for the given config, this
   * method returns `null`.
   *
   * This is not the same as just reading the property, because some property getters exist that do not actually just
   * read the config value back, but instead produce some result. Reading such properties to incidentally trigger a
   * possible config initializer can lead to incorrect results. For example, the Combo items config.
   *
   * @param {String} name The name of the config property.
   * @returns {Boolean}
   * @internal
   */
  triggerConfig(name) {
    const me = this,
      {
        configDone
      } = me,
      lazyConfig = me[lazyConfigsSymbol],
      config = me[configuringSymbol],
      triggered = lazyConfig !== null && lazyConfig !== void 0 && lazyConfig.has(name) || config && (config[name] != null || hasOwn$3(config, name)) ? !configDone[name] : null;
    if (triggered) {
      me.getConfig(name);
    }
    return triggered;
  }
  /**
   * This call will activate any pending {@link Core.Config#config-lazy} configs that were assigned a string value
   * equal to the `group` parameter.
   *
   * @param {String} group The config property group as defined by a matching {@link Core.Config#config-lazy} value.
   * @returns {String[]} The names of any configs triggered by this call or `null` if no configs were triggered.
   * @internal
   */
  triggerConfigs(group) {
    const me = this,
      configs = me.$meta.configs,
      lazyConfigs = me[lazyConfigsSymbol],
      triggered = lazyConfigs ? [...lazyConfigs.keys()].filter(k => configs[k].lazy === group) : emptyArray$6;
    for (const key of triggered) {
      me.triggerConfig(key);
    }
    return triggered.length ? triggered : null;
  }
  onConfigChange() {} // declared above because lint/IDE get angry about not declaring the args...
  /**
   * This method is called when any config changes.
   * @param {Object} info Object containing information regarding the config change.
   * @param {String} info.name The name of the config that changed.
   * @param {*} info.value The new value of the config.
   * @param {*} info.was The previous value of the config.
   * @param {Core.Config} info.config The `Config` object for the changed config property.
   * @method onConfigChange
   * @internal
   * @category Configuration
   */
  /**
   * Returns a *copy* of the full configuration which was used to configure this object.
   * @property {Object}
   * @category Lifecycle
   * @readonly
   * @advanced
   */
  get config() {
    const result = {},
      myConfig = this[originalConfigSymbol];
    // The configuration was created as a prototype chain of the class hierarchy's
    // defaultConfig values hanging off a copy of the initialConfig object, so
    // we must loop and copy since Object.assign only copies own properties.
    for (const key in myConfig) {
      result[key] = myConfig[key];
    }
    return result;
  }
  // region Extract config
  static processConfigValue(currentValue, options) {
    if (currentValue === globalThis) {
      return globalThis;
    } else if (Array.isArray(currentValue)) {
      return currentValue.map(v => Base.processConfigValue(v, options));
    }
    // Not using isBase to avoid classes (modelClass for example)
    else if (currentValue instanceof Base) {
      if (options.visited.has(currentValue)) {
        return;
      }
      return currentValue.getCurrentConfig(options);
    }
    // appendTo, floatRoot etc
    else if (currentValue instanceof HTMLElement || currentValue instanceof DocumentFragment) {
      return null;
    }
    // Go deeply into objects, might have instances of our classes in them
    else if (Objects.isObject(currentValue)) {
      const result = {};
      for (const key in currentValue) {
        // Only step "down", not "up"
        if (key !== 'owner') {
          result[key] = Base.processConfigValue(currentValue[key], options);
        }
      }
      return result;
    }
    return currentValue;
  }
  // Recursively get the value of a config. Only intended to be called by getCurrentConfig()
  getConfigValue(name, options) {
    var _me$$meta$configs$nam;
    const me = this,
      lazyConfigs = me[lazyConfigsSymbol];
    // Do not trigger lazy configs
    if (!((_me$$meta$configs$nam = me.$meta.configs[name]) !== null && _me$$meta$configs$nam !== void 0 && _me$$meta$configs$nam.lazy)) {
      return Base.processConfigValue(me[name], options);
    }
    // Instead pull their initial config in
    if (lazyConfigs !== null && lazyConfigs !== void 0 && lazyConfigs.has(name)) {
      return Base.processConfigValue(lazyConfigs.get(name), options);
    }
  }
  // Allows removing / adding configs before values are extracted
  preProcessCurrentConfigs() {}
  // Extract the current values for all initially used configs, in a format that can be used to create a new instance.
  // Not intended to be called by any other code than getConfigString()
  getCurrentConfig(options = {}) {
    const me = this,
      configs = options.configs === 'all' ? me.config : Objects.clone(me.initialConfig),
      visited = options.visited || (options.visited = new Set()),
      depth = options.depth || (options.depth = 0),
      result = {};
    if (visited.has(me)) {
      return undefined;
    }
    visited.add(me);
    this.preProcessCurrentConfigs(configs);
    for (const name in configs) {
      const value = me.getConfigValue(name, {
        ...options,
        depth: depth + 1
      });
      if (value !== undefined) {
        result[name] = value;
      }
    }
    return result;
  }
  // Extract the current values for all initially used configs and convert them to a JavaScript string
  getConfigString(options = {}) {
    return StringHelper.toJavaScriptString(this.getCurrentConfig(options));
  }
  // Experimental helper function, extracts the currently used configs and wraps them as an app, returning code as a
  // string.
  //
  // This function is intended to simplify creating test cases for issue reporting on Bryntum's support forum.
  //
  getTestCase(options = {}) {
    //<remove-on-lwc-release>
    const Product = this.isGantt ? 'Gantt' : this.isSchedulerPro ? 'SchedulerPro' : this.isCalendar ? 'Calendar' : this.isScheduler ? 'Scheduler' : this.isGrid ? 'Grid' : this.isTaskBoard ? 'TaskBoard' : null;
    if (Product) {
      const product = Product.toLowerCase(),
        // bundlePath = `https://bryntum.com/dist/${product}/build/${product}.module.js`,
        bundlePath = `../../build/${product}.module.js`;
      let preamble, postamble;
      if (options.import === 'static') {
        preamble = `import * as module from "${bundlePath}";` + 'Object.assign(window, module);'; // for (const c in module) window[c] = module[c];
        postamble = '';
      } else {
        preamble = `import("${bundlePath}").then(module => { Object.assign(window, module);\n`;
        postamble = '});';
      }
      const version = VersionHelper.getVersion(product);
      if (version) {
        preamble += `\nconsole.log('${Product} ${version}');\n`;
      }
      // De-indented on purpose
      return `${preamble}      \nconst ${product} = new ${Product}(${this.getConfigString(options)});\n${postamble}`;
    }
    //</remove-on-lwc-release>
  }
  /**
   * Experimental helper function, extracts the currently used configs and wraps them as an app, downloading the
   * resulting JS file.
   *
   * This function is intended to simplify creating test cases for issue reporting on Bryntum's support forum.
   * @category Misc
   */
  downloadTestCase(options = {}) {
    options.output = 'return';
    const app = this.getTestCase(options);
    BrowserHelper.download(`app.js`, 'data:application/javascript;charset=utf-8,' + escape(app));
  }
  //endregion
  /**
   * Registers this class type with its Factory
   * @category Misc
   * @advanced
   */
  static initClass() {
    return this.$meta.class;
  }
  /**
   * The class's {@link #property-$meta-static meta} object.
   * @member {Object} $meta
   * @internal
   * @category Misc
   */
  /**
   * An object owned by this class that does not share properties with its super class.
   *
   * This object may contain other properties which are added as needed and are not documented here.
   *
   * @property {Object} $meta The class meta object.
   * @property {Function} $meta.class The class constructor that owns the meta object.
   * @property {Object} $meta.super The `$meta` object for the super class. This is `null` for `Base`.
   * @property {Object} $meta.config The object holding the default configuration values for this class.
   * @property {Object} $meta.configs An object keyed by config name that holds the defined configs for the class.
   * The value of each property is a {@link Core/Config} instance.
   * @property {Boolean} $meta.forkConfigs This will be `true` if the default configuration values for this class
   * (in the `config` property of the meta object) must be forked to avoid object sharing, or if the object can be
   * passed to `Object.create()` for efficiency.
   * @property {Function[]} $meta.hierarchy The array of classes in the ancestry of this class. This will start with
   * `Base` at index 0 and ends with this class.
   * @property {Function[]} $meta.properties The array of classes that define a "static get properties()" getter.
   * @internal
   * @static
   * @category Misc
   */
  static get $meta() {
    const me = this;
    let meta = me[metaSymbol];
    if (!hasOwn$3(me, metaSymbol)) {
      me[metaSymbol] = meta = newMeta();
      meta.class = me;
      me.setupClass(meta);
    }
    return meta;
  }
  /**
   * This optional class method is called when a class is mixed in using the {@link #function-mixin-static mixin()}
   * method.
   * @internal
   */
  static onClassMixedIn() {
    // empty
  }
  /**
   * Returns the merge of the `baseConfig` and `config` config objects based on the configs defined by this class.
   * @param {Object} baseConfig The base config or defaults.
   * @param {...Object} configs One or more config objects that takes priority over `baseConfig`.
   * @returns {Object}
   * @internal
   */
  static mergeConfigs(baseConfig, ...configs) {
    const classConfigs = this.$meta.configs,
      result = Objects.clone(baseConfig) || {};
    let config, i, key, value;
    for (i = 0; i < configs.length; ++i) {
      config = configs[i];
      if (config) {
        for (key in config) {
          value = config[key];
          if (classConfigs[key]) {
            value = classConfigs[key].merge(value, result[key]);
          } else if (result[key] && value) {
            value = Config.merge(value, result[key]);
          }
          result[key] = value;
        }
      }
    }
    return result;
  }
  /**
   * Applies one or more `mixins` to this class and returns the produced class constructor.
   *
   * For example, instead of writing this:
   * ```
   *  class A extends Delayable(Events(Localizable(Base))) {
   *      // ...
   *  }
   * ```
   *
   * Using this method, one would write this:
   * ```
   *  class A extends Base.mixin(Localizable, Events, Delayable) {
   *      // ...
   *  }
   * ```
   * If one of the mixins specified has already been mixed into the class, it will be ignored and not mixed in a
   * second time.
   * @param {...Function} mixins
   * @returns {Function}
   * @category Misc
   * @advanced
   */
  static mixin(...mixins) {
    // Starting w/the first class C = this
    let C = this,
      i;
    // wrap each class C using mixins[i] to produce the next class
    for (i = 0; i < mixins.length; ++i) {
      const mixin = mixins[i],
        // Grab or create a unique Symbol for this mixin so we can tell if we've already mixed it in
        tag = mixin[mixinTagSymbol] || (mixin[mixinTagSymbol] = Symbol('mixinTag'));
      if (C[tag]) {
        continue;
      }
      C = mixin(C);
      C[tag] = true; // properties on the constructor are inherited to subclass constructors...
      if (hasOwn$3(C, 'onClassMixedIn')) {
        C.onClassMixedIn();
      }
    }
    return C;
  }
  /**
   * This method is called only once for any class. This can occur when the first instance is created or when the
   * `$meta` object is first requested.
   * @param {Object} meta The `$meta` object for the class.
   * @internal
   * @category Misc
   */
  static setupClass(meta) {
    var _base$nullify;
    const cls = meta.class,
      // Trigger setupClass on the super class (if it has yet to happen):
      base = getPrototypeOf$1(cls).$meta,
      name = cls.$$name,
      names = base.names,
      proto = cls.prototype;
    defineProperty$5(proto, '$meta', {
      value: meta
    });
    Object.assign(meta, {
      super: base,
      config: Object.create(base.config),
      configs: Object.create(base.configs),
      declarables: base.declarables,
      forkConfigs: base.forkConfigs,
      hierarchy: Object.freeze([...base.hierarchy, cls]),
      names: names.includes(name) ? names : Object.freeze([...names, name]),
      properties: base.properties,
      nullify: (_base$nullify = base.nullify) === null || _base$nullify === void 0 ? void 0 : _base$nullify.slice()
    });
    if (names !== meta.names) {
      const isName = `is${name}`,
        defineIsProperty = obj => {
          if (!hasOwn$3(obj, isName)) {
            defineProperty$5(obj, isName, {
              get() {
                return true;
              }
            });
          }
        };
      defineIsProperty(proto);
      defineIsProperty(cls);
    }
    // NOTE: we always use meta.declarables because setupDeclarable() can replace the array on the meta object
    // when new declarable properties are added...
    for (let decl, setupName, i = 0; i < meta.declarables.length; ++i) {
      decl = meta.declarables[i];
      if (hasOwn$3(cls, decl)) {
        setupName = setupNames[decl] || (setupNames[decl] = `setup${StringHelper.capitalize(decl)}`);
        cls[setupName](cls, meta);
      }
    }
    /*  Add slash to the front of this line to enable the diagnostic block:
    /**/
  }
  /**
   * This method is called as part of `setupClass()`. It will process the `configurable()` return object and the
   * `defaultConfig` return object.
   * @param {Object} meta The `meta` object for this class.
   * @param {Object} configs The config definition object.
   * @param {Boolean} simple `true` when processing `defaultConfig` and `false` when processing `configurable`.
   * @private
   * @category Configuration
   */
  static setupConfigs(meta, configs, simple) {
    const classConfigValues = meta.config,
      classConfigs = meta.configs,
      cls = meta.class,
      superMeta = meta.super;
    let {
        nullify
      } = meta,
      cfg,
      defaultValue,
      options,
      setDefault,
      value,
      wasNullify;
    for (const name in configs) {
      value = configs[name];
      if (simple) {
        // Using "defaultConfig"
        if (!(cfg = classConfigs[name])) {
          cfg = Config.get(name, defaultConfigOptions);
        } else {
          // The property may be declared in a base class using configurable(), so it may have special
          // merge processing:
          value = cfg.merge(value, classConfigValues[name], meta, superMeta);
        }
        /*  Add slash to the front of this line to enable the diagnostic block:
        /**/
      } else {
        // Using "configurable"
        defaultValue = options = setDefault = undefined;
        if (value && typeof value === 'object' && '$config' in value) {
          options = value.$config;
          if (options && !Objects.isObject(options)) {
            options = Objects.createTruthyKeys(options);
          }
          setDefault = 'default' in value;
          defaultValue = setDefault ? value.default : defaultValue;
          value = value.value;
        }
        if (!(cfg = classConfigs[name])) {
          cfg = Config.get(name, options);
          cfg.define(cls.prototype);
          setDefault = !(cfg.field in cls.prototype); // reduce object shape changes (helps JIT)
          wasNullify = false;
        } else {
          wasNullify = cfg.nullify;
          if (options) {
            // Defined by a base class, but maybe being adjusted by derived.
            cfg = cfg.extend(options);
            // In the future, we may need to redefine the property here if options affect the descriptor (such
            // as event firing)
          }

          value = cfg.merge(value, classConfigValues[name], meta, superMeta);
        }
        if (setDefault) {
          cfg.setDefault(cls, defaultValue);
        }
        if (cfg.nullify && !wasNullify) {
          (nullify || (nullify = meta.nullify || (meta.nullify = []))).push(cfg);
        }
      }
      // If any default properties are *mutable* Objects or Array we need to clone them.
      // so that instances do not share configured values.
      if (value && (Objects.isObject(value) || Array.isArray(value)) && !Object.isFrozen(value)) {
        meta.forkConfigs = true;
      }
      classConfigs[name] = cfg;
      classConfigValues[name] = value;
    }
  }
  static setupConfigurable(cls, meta) {
    cls.setupConfigs(meta, cls.configurable, false);
  }
  static setupDefaultConfig(cls, meta) {
    cls.setupConfigs(meta, cls.defaultConfig, true);
  }
  static setupDeclarable(cls, meta) {
    const declarable = cls.declarable;
    let all = meta.declarables,
      forked,
      i;
    for (i = 0; i < declarable.length; ++i) {
      if (!all.includes(declarable[i])) {
        if (!forked) {
          meta.declarables = forked = all = all.slice();
        }
        all.push(declarable[i]);
      }
    }
  }
  static setupProperties(cls, meta) {
    meta.properties = meta.super.properties.slice();
    meta.properties.push(cls);
    Object.freeze(meta.properties);
  }
  static setupPrototypeProperties(cls) {
    Object.assign(cls.prototype, cls.prototypeProperties);
  }
  /**
   * Gets the full {@link #property-defaultConfig-static} block for this object's entire inheritance chain
   * all the way up to but not including {@link Core.Base}
   * @returns {Object} All default config values for this class.
   * @private
   * @category Configuration
   */
  getDefaultConfiguration() {
    return this.constructor.getDefaultConfiguration();
  }
  /**
   * Gets the full {@link #property-defaultConfig-static} block for the entire inheritance chain for this class
   * all the way up to but not including {@link Core.Base}
   * @returns {Object} All default config values for this class.
   * @private
   * @category Configuration
   */
  static getDefaultConfiguration() {
    const meta = this.$meta,
      config = meta.forkConfigs ? Base.fork(meta.config) : Object.create(meta.config);
    if (VersionHelper.isTestEnv && BrowserHelper.isBrowserEnv && config.testConfig && globalThis.__applyTestConfigs) {
      for (const o in config.testConfig) {
        config[o] = config.testConfig[o];
      }
    }
    return config;
  }
  static fork(obj) {
    let ret = obj,
      key,
      value;
    if (obj && Objects.isObject(obj) && !Object.isFrozen(obj)) {
      ret = Object.create(obj);
      for (key in obj) {
        value = obj[key];
        if (value) {
          if (Objects.isObject(value)) {
            ret[key] = Base.fork(value);
          } else if (Array.isArray(value)) {
            ret[key] = value.slice();
          }
        }
      }
    }
    return ret;
  }
  /**
   * Gets the full {@link #property-properties-static} block for this class's entire inheritance chain
   * all the way up to but not including {@link Core.Base}
   * @returns {Object} All default config values for this class.
   * @private
   * @category Configuration
   */
  getProperties() {
    const
      // The meta.properties array is an array of classes that define "static get properties()"
      hierarchy = this.$meta.properties,
      result = {};
    for (let i = 0; i < hierarchy.length; i++) {
      // Gather the class result in top-down order so that subclass properties override superclass properties
      Object.assign(result, hierarchy[i].properties);
    }
    return result;
  }
  static get superclass() {
    return getPrototypeOf$1(this);
  }
  /**
   * Used by the Widget and GridFeatureManager class internally. Returns the class hierarchy of this object
   * starting from the `topClass` class (which defaults to `Base`).
   *
   * For example `classHierarchy(Widget)` on a Combo would yield `[Widget, Field, TextField, PickerField, Combo]`
   * @param {Function} [topClass] The topmost class constructor to start from.
   * @returns {Function[]} The class hierarchy of this instance.
   * @private
   * @category Configuration
   */
  classHierarchy(topClass) {
    const hierarchy = this.$meta.hierarchy,
      index = topClass ? hierarchy.indexOf(topClass) : 0;
    return index > 0 ? hierarchy.slice(index) : hierarchy;
  }
  /**
   * Checks if an obj is of type using object's $$name property and doing string comparison of the property with the
   * type parameter.
   *
   * @param {String} type
   * @returns {Boolean}
   * @category Misc
   * @advanced
   */
  static isOfTypeName(type) {
    return this.$meta.names.includes(type);
  }
  /**
   * Removes all event listeners that were registered with the given `name`.
   * @param {String|Symbol} name The name of the event listeners to be removed.
   * @category Events
   * @advanced
   */
  detachListeners(name) {
    var _detachers;
    let detachers = this.$detachers;
    detachers = (_detachers = detachers) === null || _detachers === void 0 ? void 0 : _detachers[name];
    if (detachers) {
      while (detachers.length) {
        detachers.pop()();
      }
    }
  }
  /**
   * Tracks a detacher function for the specified listener name.
   * @param {String} name The name assigned to the associated listeners.
   * @param {Function} detacher The detacher function.
   * @private
   */
  trackDetacher(name, detacher) {
    const detachers = this.$detachers || (this.$detachers = {}),
      bucket = detachers[name] || (detachers[name] = []);
    bucket.push(detacher);
  }
  /**
   * Removes all detacher functions for the specified `Events` object. This is called
   * by the `removeAllListeners` method on that object which is typically called by its
   * `destroy` invocation.
   * @param {Core.mixin.Events} eventer The `Events` instance to untrack.
   * @private
   */
  untrackDetachers(eventer) {
    const detachers = this.$detachers;
    if (detachers) {
      for (const name in detachers) {
        const bucket = detachers[name];
        for /* empty */
        (let i = bucket.length; i-- > 0;) {
          if (bucket[i].eventer === eventer) {
            bucket.splice(i, 1);
          }
        }
      }
    }
  }
}
const proto$1 = Base.prototype;
// Informs the standard config setter there is no need to call this fn:
proto$1.onConfigChange.$nullFn = emptyFn$1.$nullFn = true;
Base[metaSymbol] = proto$1.$meta = newMeta({
  class: Base,
  config: Object.freeze({}),
  configs: Object.create(null),
  declarables: Base.declarable,
  forkConfigs: false,
  hierarchy: Object.freeze([Base]),
  names: Object.freeze(['Base']),
  nullify: null,
  properties: Object.freeze([]),
  super: null
});
// Avoid some object shape changes:
Object.assign(proto$1, {
  $detachers: null,
  configObserver: null,
  /**
   * This property is set to `true` before the `constructor` returns.
   * @member {Boolean}
   * @readonly
   * @category Lifecycle
   * @advanced
   */
  isConstructing: true,
  /**
   * This property is set to `true` by {@link #function-destroy} after destruction.
   *
   * It is also one of the few properties that remains on the object after returning from `destroy()`. This property
   * is often checked in code paths that may encounter a destroyed object (like some event handlers) or in the
   * destruction path during cleanup.
   *
   * @member {Boolean}
   * @readonly
   * @category Lifecycle
   */
  isDestroyed: false,
  /**
   * This property is set to `true` on entry to the {@link #function-destroy} method. It remains on the objects after
   * returning from `destroy()`. If {@link #property-isDestroyed} is `true`, this property will also be `true`, so
   * there is no need to test for both (for example, `comp.isDestroying || comp.isDestroyed`).
   * @member {Boolean}
   * @readonly
   * @category Lifecycle
   * @advanced
   */
  isDestroying: false
});
Base.emptyFn = emptyFn$1;
VersionHelper.setVersion('core', '5.5.0');
Base._$name = 'Base';

/**
 * @module Core/helper/ArrayHelper
 */
/**
 * Helper with useful functions for handling Arrays
 * @internal
 */
class ArrayHelper {
  static clean(array) {
    return array.reduce((res, item) => {
      if (item !== null && item !== undefined && !(Array.isArray(item) && item.length === 0) && item !== '') res.push(item);
      return res;
    }, []);
  }
  /**
   * Similar to [`Array.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from)
   * this method creates an array from an `iterable` object. Where `Array.from()` accepts a mapper function as the
   * second argument, this method accepts a `filter` function as its second argument. If a mapper function is also
   * needed, it can be passed as the third argument. Unlike `Array.from()`, if this method is passed `null`, it will
   * return an empty array.
   * @param {Array} iterable The iterable object to convert (must support `for-of` loop iteration).
   * @param {Function} [filter] A function to apply to each item of the `iterable` which must return a truthy value
   * to include that item in the resulting array.
   * @param {Function} [map] A function to apply to each item of the `iterable` that returns the actual value to put
   * into the returned array. If a `filter` is also supplied, this method is only called for those items that pass
   * the filter test.
   * @returns {Array}
   */
  static from(iterable, filter, map) {
    const array = [];
    if (iterable) {
      for (const it of iterable) {
        if (!filter || filter(it)) {
          array.push(map ? map(it) : it);
        }
      }
    }
    return array;
  }
  /**
   * Remove one or more items from an array
   * @param {Array} array Array to remove from
   * @param {Object[]|Set} items One or more items to remove, or one Set containing items to remove
   * @returns {Boolean} Returns true if any item was removed
   */
  static remove(array, ...items) {
    let index,
      item,
      removed = false;
    items = items[0] instanceof Set ? [...items[0]] : items;
    for (let i = 0; i < items.length; i++) {
      item = items[i];
      if ((index = array.indexOf(item)) !== -1) {
        array.splice(index, 1);
        removed = true;
      }
    }
    return removed;
  }
  /**
   * Calculates the insertion index of a passed object into the passed Array according
   * to the passed comparator function. Note that the passed Array *MUST* already be ordered.
   * @param {Object} item The item to calculate the insertion index for.
   * @param {Array} array The array into which the item is to be inserted.
   * @param {Function} comparatorFn The comparison function. Must return -1 or 0 or 1.
   * @param {Object} comparatorFn.lhs The left object to compare.
   * @param {Object} comparatorFn.rhs The right object to compare.
   * @param {Number} index The possible correct index to try first before a binary
   * search is instigated.
   * @internal
   */
  static findInsertionIndex(item, array, comparatorFn = this.lexicalCompare, index) {
    const len = array.length;
    let beforeCheck, afterCheck;
    if (index < len) {
      beforeCheck = index > 0 ? comparatorFn(array[index - 1], item) : 0;
      afterCheck = index < len - 1 ? comparatorFn(item, array[index]) : 0;
      if (beforeCheck < 1 && afterCheck < 1) {
        return index;
      }
    }
    return this.binarySearch(array, item, comparatorFn);
  }
  /**
   * Similar to the native `Array.find()` call, but this finds the *last* element in the array for which
   * the passed function returns a truthy value.
   * @param {Object[]} array The array to find in.
   * @param {Function} fn The testing function.
   * @param {Object} [thisObj] The scope (`this` reference) in which to call the function.
   */
  static findLast(array, fn, thisObj) {
    for (let {
        length
      } = array, i = length - 1; i >= 0; i--) {
      if (fn.call(thisObj, array[i], i, array)) {
        return array[i];
      }
    }
  }
  /**
   * This method returns the index that a given item would be inserted into the
   * given (sorted) `array`. Note that the given `item` may or may not be in the
   * array. This method will return the index of where the item *should* be.
   *
   * For example:
   *
   *      var array = [ 'A', 'D', 'G', 'K', 'O', 'R', 'X' ];
   *      var index = ArrayHelper.binarySearch(array, 'E');
   *
   *      console.log('index: ' + index);
   *      // logs "index: 2"
   *
   *      array.splice(index, 0, 'E');
   *
   *      console.log('array : ' + array.join(''));
   *      // logs "array: ADEGKORX"
   *
   * @param {Object[]} array The array to search.
   * @param {Object} item The item that you want to insert into the `array`.
   * @param {Number} [begin=0] The first index in the `array` to consider.
   * @param {Number} [end=array.length] The index that marks the end of the range
   * to consider. The item at this index is *not* considered.
   * @param {Function} [compareFn] The comparison function that matches the sort
   * order of the `array`. The default `compareFn` compares items using less-than
   * and greater-than operators.
   * @returns {Number} The index for the given item in the given array based on
   * the passed `compareFn`.
   */
  static binarySearch(array, item, begin = 0, end = array.length, compareFn = this.lexicalCompare) {
    const length = array.length;
    let middle, comparison;
    if (begin instanceof Function) {
      compareFn = begin;
      begin = 0;
    } else if (end instanceof Function) {
      compareFn = end;
      end = length;
    }
    --end;
    while (begin <= end) {
      middle = begin + end >> 1;
      comparison = compareFn(item, array[middle]);
      if (comparison >= 0) {
        begin = middle + 1;
      } else if (comparison < 0) {
        end = middle - 1;
      }
    }
    return begin;
  }
  magnitudeCompare(lhs, rhs) {
    return lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
  }
  lexicalCompare(lhs, rhs) {
    lhs = String(lhs);
    rhs = String(rhs);
    return lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
  }
  /**
   * Similar to Array.prototype.fill(), but constructs a new array with the specified item count and fills it with
   * clones of the supplied item.
   * @param {Number} count Number of entries to create
   * @param {Object|Array} itemOrArray Item or array of items to clone (uses object spread to create shallow clone)
   * @param {Function} [fn] An optional function that is called for each item added, to allow processing
   * @returns {Array} A new populated array
   */
  static fill(count, itemOrArray = {}, fn = null) {
    const result = [],
      items = Array.isArray(itemOrArray) ? itemOrArray : [itemOrArray];
    for (let i = 0; i < count; i++) {
      for (const item of items) {
        // Using object spread here forces us to use more babel plugins and will make
        // react_typescript demo very difficult to setup
        const processedItem = Object.assign({}, item);
        if (fn) {
          fn(processedItem, i);
        }
        result.push(processedItem);
      }
    }
    return result;
  }
  /**
   * Populates an array with the return value from `fn`.
   * @param {Number} count Number of entries to create
   * @param {Function} fn A function that is called `count` times, return value is added to array
   * @param {Number} fn.index Current index in the array
   * @privateparam {Boolean} [oneBased] Add 1 to the index before calling the fn (making it 1 based)
   * @returns {Array} A new populated array
   */
  static populate(count, fn, oneBased = false) {
    const items = [];
    for (let i = 0; i < count; i++) {
      items.push(fn(i + (oneBased ? 1 : 0)));
    }
    return items;
  }
  /**
   * Pushes `item` on to the `array` if not already included
   * @param {Array}  array Array to push to
   * @param {...Object} items Item(s) to push if not already included
   */
  static include(array, ...items) {
    for (const item of items) {
      if (!array.includes(item)) {
        array.push(item);
      }
    }
  }
  /**
   * Returns a new array with the unique items from the supplied array.
   * @param {Array} array Input array
   * @returns {Array} New array with unique items
   */
  static unique(array) {
    return [...new Set(array)];
  }
  // Kept for future reference : Wanted to create an indexer on Stores.
  static allowNegative(array) {
    // From https://github.com/sindresorhus/negative-array
    return new Proxy(array, {
      get(target, name, receiver) {
        if (typeof name !== 'string') {
          return Reflect.get(target, name, receiver);
        }
        const index = Number(name);
        if (Number.isNaN(index)) {
          return Reflect.get(target, name, receiver);
        }
        return target[index < 0 ? target.length + index : index];
      },
      set(target, name, value, receiver) {
        if (typeof name !== 'string') {
          return Reflect.set(target, name, value, receiver);
        }
        const index = Number(name);
        if (Number.isNaN(index)) {
          return Reflect.set(target, name, value, receiver);
        }
        target[index < 0 ? target.length + index : index] = value;
        return true;
      }
    });
  }
  static delta(a, b, useRelativeNaming = false) {
    // Nicer syntax but about 40% slower (an extra iteration)
    // const
    //     onlyInA = a.filter(item => !b.includes(item)),
    //     onlyInB = b.filter(item => !a.includes(item)),
    //     inBoth  = a.filter(item => b.includes(item));
    // Quick bailout for nonexisting target array
    if (!b) {
      return useRelativeNaming ? {
        toAdd: a,
        toRemove: [],
        toKeep: []
      } : {
        onlyInA: a,
        onlyInB: [],
        inBoth: []
      };
    }
    const onlyInA = [],
      onlyInB = [],
      inBoth = new Set(),
      bSet = new Set(b);
    for (let i = 0; i < a.length; i++) {
      const item = a[i];
      if (bSet.has(item)) {
        inBoth.add(item);
      } else {
        onlyInA.push(item);
      }
    }
    for (let i = 0; i < b.length; i++) {
      const item = b[i];
      if (!inBoth.has(item)) {
        onlyInB.push(item);
      }
    }
    if (useRelativeNaming) {
      return {
        toAdd: onlyInA,
        toRemove: onlyInB,
        toKeep: inBoth
      };
    }
    return {
      onlyInA,
      onlyInB,
      inBoth: [...inBoth]
    };
  }
  /**
   * Returns the passed object wrapped in an array. Special handling of the following cases:
   * * Passing an array returns it as is
   * * Passing a `Set` returns it converted to an Array
   * * Passing `null`/`undefined` returns the passed value
   *
   * ```javascript
   * const records = ArrayHelper.asArray(record);
   *
   * // { id : 1 } -> [{ id : 1 }]
   * // [{ id : 1 }] -> [{ id : 1 }]
   * ```
   *
   * @param {*} arrayOrObject
   * @returns {Array|null}
   * @internal
   */
  static asArray(arrayOrObject) {
    if (arrayOrObject == null) {
      return arrayOrObject;
    }
    if (arrayOrObject instanceof Set) {
      return Array.from(arrayOrObject);
    }
    return Array.isArray(arrayOrObject) ? arrayOrObject : [arrayOrObject];
  }
  /**
   * Identity function that returns its input.
   * @param {*} Any value
   * @returns {*} The input value
   * @internal
   */
  static identity(x) {
    return x;
  }
  /**
   * Transform an array into a key:value dictionary using the specified
   * key and value getters. Does not group values, so only one result will
   * appear in the output for a given key.
   *
   * ```javascript
   * const input = [{
   *     id: '1',
   *     other: 'one'
   * },{
   *     id: '2',
   *     other: 'two'
   * }];
   *
   * keyBy(input, rec => rec.id)
   *
   * // {
   * //    '1': { id: '1', other: 'one' },
   * //    '2': { id: '2', other: 'two' }
   * // }
   * ```
   *
   * @param {Array} array Array from which to build dictionary
   * @param {Function|String} getKey Function to produce the key for a given array entry, or a string property name to read
   * @param {Function} getValue Optional function to transform array elements. Defaults to returning the element itself
   * @returns {Object} A key->value dictionary with keys as returned by `getKey` and values returned by `getValue`
   * @internal
   */
  static keyBy(array, keyGetter, valueGetter = ArrayHelper.identity) {
    const getKey = typeof keyGetter === 'string' ? o => o === null || o === void 0 ? void 0 : o[keyGetter] : keyGetter,
      getValue = typeof valueGetter === 'string' ? o => o === null || o === void 0 ? void 0 : o[valueGetter] : valueGetter;
    return array.reduce((dict, next) => {
      dict[getKey(next)] = getValue(next);
      return dict;
    }, {});
  }
  /**
   * Combines provided arrays of by aggregating their element values.
   * For example the below code sums up numeric elements of the arrays:
   *
   * ```javascript
   * ArrayHelper.aggregate(
   *     [
   *         [0,   1,  2, 33]
   *         [10,  1, -1],
   *         [100, 1, -1]
   *     ],
   *     entry => entry || 0, // "|| 0" here to make it work for different array sizes
   *     (aggregated, entry) => aggregated + entry, // aggregate by summing up
   *     () => 0 //initial value is zero
   * );
   *
   * // returns [111, 3, 0, 33] array
   * ```
   *
   * @param {Array[]} arrays Array to combine
   * @param {Function} getEntryValueFn Function that extracts an array entry for aggregating.
   * @param {Function} aggregatorFn A function to execute for each element in the arrays. It's purpose is to
   * aggregate the element value to the corresponding entry of the resulting array.
   * The function's return value becomes the value of the `aggregated` parameter on the next invocation of
   * `aggregatorFn`.
   * The function is called with the following arguments:
   *
   * @param {Object} aggregatorFn.aggregated Resulting array entry value. On the first call
   * `getInitialValueFn` result.
   * @param {Object} aggregatorFn.entry Current entry to aggregate into `aggregated`.
   * @param {Number} aggregatorFn.arrayIndex Index of current array (in the provided `arrays`).
   * @param {Object[]} aggregatorFn.entryIndex Index of the current entry.
   * @param {Object} aggregationContext A shared object providing extra aggregation call context.
   * @param {Function} getInitialValueFn Function that returns an initial value for the combined array entries.
   * @param {Object} [aggregationContext] Optional object that is passed to all of the above functions that can
   * be used for keeping some additional parameters used when aggregating.
   * Out of the box the object will contain `arrays` and `targetArray` properties containing
   * input and resulting arrays respectively.
   */
  static aggregate(arrays, getEntryValueFn, aggregatorFn, getInitialValueFn, aggregationContext = {}) {
    const rowLength = arrays.length,
      columnLength = arrays[0].length,
      result = [];
    // provide some context by default
    // the resulting array reference and list of array given for aggregating
    aggregationContext.targetArray = result;
    aggregationContext.arrays = arrays;
    for (let colIndex = 0; colIndex < columnLength; colIndex++) {
      aggregationContext.entryIndex = colIndex;
      result.push(getInitialValueFn(colIndex, aggregationContext));
    }
    // iterate provided arrays
    for (let rowIndex = 0; rowIndex < rowLength; rowIndex++) {
      const row = arrays[rowIndex];
      aggregationContext.rowIndex = rowIndex;
      for (let colIndex = 0; colIndex < columnLength; colIndex++) {
        aggregationContext.entryIndex = colIndex;
        const entryValue = getEntryValueFn(row[colIndex], aggregationContext);
        // aggregate them
        result[colIndex] = aggregatorFn(result[colIndex], entryValue, rowIndex, colIndex, aggregationContext);
      }
    }
    return result;
  }
  /**
   * Group an array by keys (either the values in a specified property name, or the results of a string-generating function accepting
   * an array entry as input), returning an Object with those keys, whose values are arrays containing the array entries that
   * produced that key.
   *
   * ```javascript
   * const input = [{
   *     id: 1,
   *     color: 'red'
   * },{
   *     id: 2,
   *     color: 'green'
   * },{
   *     id: 3,
   *     color: 'green'
   * }];
   *
   * groupBy(input, 'color')
   *
   * // {
   * //    'red': [ { id: '1', color: 'red' } ],
   * //    'green': [ { id: '2', color: 'green' }, { id: '3', color: 'green' } ]
   * // }
   *
   * groupBy(input, rec => rec.color?.substr(0, 1))
   *
   * // {
   * //    'r': [ { id: '1', color: 'red' } ],
   * //    'g': [ { id: '2', color: 'green' }, { id: '3', color: 'green' } ]
   * // }
   * ```
   *
   * @param {Object} array Array from which to build dictionary
   * @param {Function|String} getGroupKey Function to produce the key for a given array entry, or a string property name to read
   * @returns {Object} A key->value[] dictionary with keys as returned by `getKey` and arrays of matching items in original order as values
   * @internal
   */
  static groupBy(array, groupKeyGetter) {
    const getKey = typeof groupKeyGetter === 'string' ? o => o === null || o === void 0 ? void 0 : o[groupKeyGetter] : groupKeyGetter;
    return array.reduce((grouped, value) => {
      const key = getKey(value);
      (grouped[key] = grouped[key] || []).push(value);
      return grouped;
    }, {});
  }
}
ArrayHelper._$name = 'ArrayHelper';

/**
 * @module Core/helper/FunctionHelper
 */
const commaSepRe = /,\s*/,
  decompiledSym = Symbol('decompiled'),
  // [async] p => ...
  fnRe1 = /^\s*(async\s+)?([a-z_]\w*)\s*=>([\s\S]+)$/i,
  // [async] (p1?[, px]*) => ...
  fnRe2 = /^\s*(async\s*)?\s*\(((?:[a-z_]\w*(?:, [a-z_]\w*)*)?)\)\s+=>([\s\S]+)$/i,
  // [async] [function] [name] (p1?[, px]*) ...
  fnRe3 = /^(\s*async)?(?:\s*function)?(?:\s*([a-z_]\w*))?\s*\(((?:[a-z_]\w*(?:, [a-z_]\w*)*)?)\)([\s\S]+)$/i,
  {
    hasOwnProperty: hasOwnProperty$2
  } = Object.prototype;
/**
 * Provides functionality for working with functions
 * @internal
 */
class FunctionHelper {
  /**
   * Inserts a function after the specified `method` is called on an `object`. To remove this hook, invoke the
   * function returned by this method.
   * ```
   *  class A {
   *      method() {
   *          console.log('method');
   *      }
   *  }
   *
   *  let instance = new A();
   *
   *  let detach = FunctionHelper.after(instance, 'method', () => { console.log('after') });
   *
   *  instance.method();
   *  > method
   *  > after
   *
   *  detach();
   *  instance.method();
   *  > method
   * ```
   * The value returned by the original method is passed as the first argument to `fn` followed by all the arguments
   * passed by the caller.
   *
   * If `fn` returns a value (not `undefined`), that value is returned from the method call instead of the value
   * returned by the original method.
   * ```
   *  class A {
   *      method(x) {
   *          console.log('method', x);
   *          return x * 2
   *      }
   *  }
   *
   *  let instance = new A();
   *
   *  let detach = FunctionHelper.after(instance, 'method', (ret, x) => {
   *      console.log('after', ret, x);
   *      return x / 2;
   *  });
   *
   *  console.log(instance.method(50));
   *  > method 50
   *  > after 100 50
   *  > 25
   *
   *  detach();
   *  console.log(instance.method(50));
   *  > method 50
   *  > 100
   * ```
   *
   * @param {Object} object The object to hook.
   * @param {String} method The name of the method on `object` to hook.
   * @param {Function|String} fn The function or method name (on `thisObj`) to call after `method`.
   * @param {Object} [thisObj] The `this` pointer value for calling `fn`.
   * @param {Object} [options] Additional options
   * @param {Boolean} [options.return=true] Specify `false` to not include the return value of the hooked method as
   * the first argument to `fn`.
   * @returns {Function} The function to call to remove the hook.
   */
  static after(object, method, fn, thisObj, options) {
    const named = typeof fn === 'string',
      withReturn = (options === null || options === void 0 ? void 0 : options.return) !== false,
      hook = (...args) => {
        const
          // if object.destroy() occurs, our hook will be removed, so this fn won't be called in that case
          origResult = hook.$nextHook.call(object, ...args),
          hookResult = thisObj !== null && thisObj !== void 0 && thisObj.isDestroyed ? undefined : withReturn ? named ? thisObj[fn](origResult, ...args) : fn.call(thisObj, origResult, ...args) : named ? thisObj[fn](...args) : fn.call(thisObj, ...args);
        return hookResult === undefined ? origResult : hookResult;
      };
    return FunctionHelper.hookMethod(object, method, hook);
  }
  /**
   * Inserts a function before the specified `method` is called on an `object`. To remove this hook, invoke the
   * function returned by this method.
   * ```
   *  class A {
   *      method() {
   *          console.log('method');
   *      }
   *  }
   *
   *  let instance = new A();
   *
   *  let detach = FunctionHelper.before(instance, 'method', () => { console.log('before') });
   *
   *  instance.method();
   *  > before
   *  > method
   *
   *  detach();
   *  instance.method();
   *  > method
   * ```
   * If `fn` returns `false`, the original method is not invoked and `false` is returned to the caller.
   * ```
   *  class A {
   *      method(x) {
   *          console.log('method', x);
   *          return x * 2;
   *      }
   *  }
   *
   *  let instance = new A();
   *
   *  let detach = FunctionHelper.before(instance, 'method', x => {
   *      console.log('before', x);
   *      return false;
   *  });
   *
   *  console.log(instance.method(50));
   *  > before 50
   *  > false
   *
   *  detach();
   *  console.log(instance.method(50));
   *  > method 50
   *  > 100
   * ```
   *
   * @param {Object} object The object to hook.
   * @param {String} method The name of the method on `object` to hook.
   * @param {Function|String} fn The function or method name (on `thisObj`) to call before `method`.
   * @param {Object} [thisObj] The `this` pointer value for calling `fn`.
   * @returns {Function} The function to call to remove the hook.
   */
  static before(object, method, fn, thisObj) {
    const named = typeof fn === 'string',
      hook = (...args) => {
        const ret = thisObj !== null && thisObj !== void 0 && thisObj.isDestroyed ? 0 : named ? thisObj[fn](...args) : fn.call(thisObj, ...args);
        return ret === false ? ret : hook.$nextHook.call(object, ...args);
      };
    return FunctionHelper.hookMethod(object, method, hook);
  }
  static curry(func) {
    return function curried(...args) {
      if (args.length >= func.length) {
        return func.apply(this, args);
      } else {
        return function (...args2) {
          return curried.apply(this, args.concat(args2));
        };
      }
    };
  }
  static bindAll(obj) {
    for (const key in obj) {
      if (typeof obj[key] === 'function') {
        obj[key] = obj[key].bind(obj);
      }
    }
  }
  /**
   * Returns a function which calls the passed `interceptor` function first, and the passed `original` after
   * as long as the `interceptor` does not return `false`.
   * @param {Function} original The function to call second.
   * @param {Function} interceptor The function to call first.
   * @param {Object} [thisObj] The `this` reference when the functions are called.
   * @returns {Function} A function which yields the return value from the `original` function **if it was called**, else `false`.
   */
  static createInterceptor(original, interceptor, thisObj) {
    return function (...args) {
      const theThis = thisObj || this;
      if (interceptor.call(theThis, ...args) !== false) {
        return original.call(theThis, ...args);
      }
      return false;
    };
  }
  /**
   * Returns a function which calls the passed `sequence` function after calling
   * the passed `original`.
   * @param {Function} original The function to call first.
   * @param {Function} sequence The function to call second.
   * @param {Object} [thisObj] The `this` reference when the functions are called.
   * @returns {Function} A function which yields the value returned from the sequence if it returned a value, else the return
   * value from the original function.
   */
  static createSequence(original, sequence, thisObj) {
    return (...args) => {
      const origResult = original.call(thisObj, ...args),
        sequenceResult = sequence.call(thisObj, ...args);
      return sequenceResult === undefined ? origResult : sequenceResult;
    };
  }
  /**
   * Create a "debounced" function which will call on the "leading edge" of a timer period.
   * When first invoked will call immediately, but invocations after that inside its buffer
   * period will be rejected, and *one* invocation will be made after the buffer period has expired.
   *
   * This is useful for responding immediately to a first mousemove, but from then on, only
   * calling the action function on a regular timer while the mouse continues to move.
   *
   * @param {Function} fn The function to call.
   * @param {Number} buffer The milliseconds to wait after each execution before another execution takes place.
   * @param {Object} [thisObj] `this` reference for the function.
   * @param {Array} [extraArgs] The argument list to append to those passed to the function.
   * @param {Function} [alt] A function to call when the invocation is rejected due to buffer time not having expired.
   * @returns {Function} A function which calls the passed `fn` only if at least the passed `buffer`
   * milliseconds has elapsed since its last invocation.
   */
  static createThrottled(fn, buffer, thisObj, extraArgs, alt) {
    let lastCallTime = -Number.MAX_VALUE,
      callArgs,
      timerId;
    const invoke = () => {
        timerId = 0;
        lastCallTime = performance.now();
        callArgs.push.apply(callArgs, extraArgs);
        fn.apply(thisObj, callArgs);
      },
      result = function (...args) {
        const elapsed = performance.now() - lastCallTime;
        callArgs = args;
        // If it's been more then the buffer period since we invoked, we can call it now
        if (elapsed >= buffer) {
          clearTimeout(timerId);
          invoke();
        }
        // Otherwise, kick off a timer for the requested period.
        else {
          if (!timerId) {
            timerId = setTimeout(invoke, buffer - elapsed);
          }
          if (alt) {
            callArgs.push.apply(callArgs, extraArgs);
            alt.apply(thisObj, callArgs);
          }
        }
      };
    result.cancel = () => clearTimeout(timerId);
    return result;
  }
  /**
   * Create a "debounced" function which will call on the "trailing edge" of a timer period.
   * When first invoked will wait until the buffer period has expired to call the function, and
   * more calls within that time will restart the timer.
   *
   * This is useful for responding to keystrokes, but deferring action until the user pauses typing.
   *
   * @param {Function} fn The function to call.
   * @param {Number} buffer The milliseconds to wait after each execution before another execution takes place.
   * @param {Object} [thisObj] `this` reference for the function.
   * @param {Array} [args] The argument list to append to those passed to the function.
   * @returns {Function} A function which calls the passed `fn` when at least the passed `buffer`
   * milliseconds has elapsed since its last invocation.
   */
  static createBuffered(fn, buffer, thisObj, args) {
    let callArgs, timerId;
    const invoke = () => {
        timerId = 0;
        result.isPending = false;
        callArgs.push.apply(callArgs, args);
        fn.apply(thisObj, callArgs);
      },
      result = function (...args) {
        callArgs = args;
        // Cancel any impending invocation. It's pushed out for <buffer> ms from each call
        if (timerId) {
          clearTimeout(timerId);
        }
        result.isPending = true;
        timerId = setTimeout(invoke, buffer);
      };
    result.cancel = () => {
      result.isPending = false;
      clearTimeout(timerId);
    };
    return result;
  }
  static decompile(fn) {
    if (!(decompiledSym in fn)) {
      var _body, _body2;
      const code = fn.toString();
      let m = fnRe1.exec(code),
        args,
        body,
        name,
        decompiled,
        t;
      if (m) {
        // [async] p => ...
        //   [1]   [2]  [3]
        args = [m[2]];
        body = m[3];
      } else if (m /* assignment */ = fnRe2.exec(code)) {
        // [async] (p1?[, px]*) => ...
        //   [1]   [2]             [3]
        t = m[2].trim();
        args = t ? t.split(commaSepRe) : [];
        body = m[3];
      } else if (m /* assignment */ = fnRe3.exec(code)) {
        // [async] [function] [name] (p1?[, px]*) ...
        //   [1]              [2]     [3]         [4]
        name = m[2];
        t = m[3].trim();
        args = t ? t.split(commaSepRe) : [];
        body = m[4];
      }
      body = (_body = body) === null || _body === void 0 ? void 0 : _body.trim();
      fn[decompiledSym] = decompiled = m && {
        args,
        async: Boolean(m[1]),
        body: (_body2 = body) !== null && _body2 !== void 0 && _body2.startsWith('{') ? body.substring(1, body.length - 1).trim() : body
      };
      if (name) {
        decompiled.name = name;
      }
    }
    return fn[decompiledSym];
  }
  static hookMethod(object, method, hook) {
    hook.$nextHook = object[method];
    object[method] = hook;
    return () => {
      // Object will have no hooks on the instance if it is destroyed (perhaps other reasons too)
      if (hasOwnProperty$2.call(object, method)) {
        let f = object[method],
          next;
        if (f === hook) {
          var _Object$getPrototypeO;
          // When this is the outermost hook, we may be the last hook. If $nextHook is found on the object's
          // prototype, simply delete the slot to expose it. Otherwise, there's another hook, so make it the
          // outermost.
          if (((_Object$getPrototypeO = Object.getPrototypeOf(object)) === null || _Object$getPrototypeO === void 0 ? void 0 : _Object$getPrototypeO[method]) === hook.$nextHook) {
            delete object[method];
          } else {
            object[method] = hook.$nextHook;
          }
        } else {
          // Not being the outermost hook means we have outer hooks that should chain to the one we want to
          // remove. Be cautious because the object could be destroyed.
          for (; next = (_f = f) === null || _f === void 0 ? void 0 : _f.$nextHook; f = next) {
            var _f;
            if (next === hook) {
              f.$nextHook = hook.$nextHook;
              break;
            }
          }
        }
      }
    };
  }
  /**
   * Protects the specified `method` on a given `object` such that calling it will not throw exceptions.
   * @param {Object} object The object whose method is to be protected.
   * @param {String} method The name of the method to protect.
   * @param {Function} [handler] An optional function to call for any thrown exceptions.
   * @internal
   */
  static noThrow(object, method, handler) {
    const fn = object[method];
    object[method] = (...args) => {
      try {
        return fn.apply(object, args);
      } catch (e) {
        return handler === null || handler === void 0 ? void 0 : handler(e);
      }
    };
  }
  static returnTrue() {
    return true;
  }
  static animate(duration, fn, thisObj, easing = 'linear') {
    let cancel = false;
    const result = new Promise(resolve => {
      const start = performance.now(),
        iterate = () => {
          const progress = Math.min((performance.now() - start) / duration, 1),
            delayable = thisObj && thisObj.setTimeout ? thisObj : globalThis;
          if (!cancel) {
            if (fn.call(thisObj, this.easingFunctions[easing](progress)) === false) {
              resolve();
            }
          }
          if (cancel || progress === 1) {
            // Push resolution into the next animation frame so that
            // this frame completes before the resolution handler runs.
            delayable.requestAnimationFrame(() => resolve());
          } else {
            delayable.requestAnimationFrame(iterate);
          }
        };
      iterate();
    });
    result.cancel = () => {
      cancel = true;
      result.cancelled = true;
      return false;
    };
    return result;
  }
}
const half = 0.5,
  e1 = 1.70158,
  e2 = 7.5625,
  e3 = 1.525,
  e4 = 2 / 2.75,
  e5 = 2.25 / 2.75,
  e6 = 1 / 2.75,
  e7 = 1.5 / 2.75,
  e8 = 2.5 / 2.75,
  e9 = 2.625 / 2.75,
  e10 = 0.75,
  e11 = 0.9375,
  e12 = 0.984375,
  s1 = 1.70158,
  s2 = 1.70158;
FunctionHelper.easingFunctions = {
  linear: t => t,
  easeInQuad: t => Math.pow(t, 2),
  easeOutQuad: t => -(Math.pow(t - 1, 2) - 1),
  easeInOutQuad: t => (t /= half) < 1 ? half * Math.pow(t, 2) : -half * ((t -= 2) * t - 2),
  easeInCubic: t => Math.pow(t, 3),
  easeOutCubic: t => Math.pow(t - 1, 3) + 1,
  easeInOutCubic: t => (t /= half) < 1 ? half * Math.pow(t, 3) : half * (Math.pow(t - 2, 3) + 2),
  easeInQuart: t => Math.pow(t, 4),
  easeOutQuart: t => -(Math.pow(t - 1, 4) - 1),
  easeInOutQuart: t => (t /= half) < 1 ? half * Math.pow(t, 4) : -half * ((t -= 2) * Math.pow(t, 3) - 2),
  easeInQuint: t => Math.pow(t, 5),
  easeOutQuint: t => Math.pow(t - 1, 5) + 1,
  easeInOutQuint: t => (t /= half) < 1 ? half * Math.pow(t, 5) : half * (Math.pow(t - 2, 5) + 2),
  easeInSine: t => -Math.cos(t * (Math.PI / 2)) + 1,
  easeOutSine: t => Math.sin(t * (Math.PI / 2)),
  easeInOutSine: t => -half * (Math.cos(Math.PI * t) - 1),
  easeInExpo: t => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: t => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: t => t === 0 ? 0 : t === 1 ? 1 : (t /= half) < 1 ? half * Math.pow(2, 10 * (t - 1)) : half * (-Math.pow(2, -10 * --t) + 2),
  easeInCirc: t => -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: t => Math.sqrt(1 - Math.pow(t - 1, 2)),
  easeInOutCirc: t => (t /= half) < 1 ? -half * (Math.sqrt(1 - t * t) - 1) : half * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeOutBounce: t => t < e6 ? e2 * t * t : t < e4 ? e2 * (t -= e7) * t + e10 : t < e8 ? e2 * (t -= e5) * t + e11 : e2 * (t -= e9) * t + e12,
  easeInBack: t => t * t * ((e1 + 1) * t - e1),
  easeOutBack: t => (t = t - 1) * t * ((e1 + 1) * t + e1) + 1,
  easeInOutBack: t => {
    let v1 = s1;
    return (t /= half) < 1 ? half * (t * t * (((v1 *= e3) + 1) * t - v1)) : half * ((t -= 2) * t * (((v1 *= e3) + 1) * t + v1) + 2);
  },
  elastic: t => -1 * Math.pow(4, -8 * t) * Math.sin((t * 6 - 1) * (2 * Math.PI) / 2) + 1,
  swingFromTo: t => {
    let v2 = s2;
    return (t /= half) < 1 ? half * (t * t * (((v2 *= e3) + 1) * t - v2)) : half * ((t -= 2) * t * (((v2 *= e3) + 1) * t + v2) + 2);
  },
  swingFrom: t => t * t * ((e1 + 1) * t - e1),
  swingTo: t => (t -= 1) * t * ((e1 + 1) * t + e1) + 1,
  bounce: t => t < e6 ? e2 * t * t : t < e4 ? e2 * (t -= e7) * t + e10 : t < e8 ? e2 * (t -= e5) * t + e11 : e2 * (t -= e9) * t + e12,
  bouncePast: t => t < e6 ? e2 * t * t : t < e4 ? 2 - (e2 * (t -= e7) * t + e10) : t < e8 ? 2 - (e2 * (t -= e5) * t + e11) : 2 - (e2 * (t -= e9) * t + e12),
  easeFromTo: t => (t /= half) < 1 ? half * Math.pow(t, 4) : -half * ((t -= 2) * Math.pow(t, 3) - 2),
  easeFrom: t => Math.pow(t, 4),
  easeTo: t => Math.pow(t, 0.25)
};
FunctionHelper._$name = 'FunctionHelper';

/* eslint-disable bryntum/no-listeners-in-lib,bryntum/no-on-in-lib */
/**
 * @module Core/mixin/Events
 */
/**
 * @typedef {Object.<String,Function|Boolean|Object|Object[]|Number|String>} BryntumListenerConfig
 * @property {Object} [thisObj] The `this` reference for all listeners. May be overridden if a handler is specified in object form.
 * @property {Boolean} [once] Specify as `true` to remove the listener as soon as it is invoked.
 * @property {Number|Object} [expires] The listener only waits for a specified time before
 * being removed. The value may be a number or an object containing an expiry handler.
 * @property {Number} [expires.delay] How long to wait for the event for.
 * @property {String|Function} [expires.alt] The function to call when the listener expires **without having been triggered**.
 * @property {Object[]} [args] An array of arguments to be passed to the handler before the event object.
 * @property {Number} [prio] The priority for all listeners; higher priority listeners are called before lower.
 * @property {Number} [buffer] A buffer time in milliseconds to wait after last event trigger to call the handler, to reduce the amount of handler calls for frequent events.
 * @property {Number} [throttle] A millisecond timeout value to throttle event triggering. With it specified a handler
 * will be called once immediately and then all following calls during the timeout period will be grouped together into one call once per throttle period.
 */
const
  // Used by the config system to flatten configs from the class hierarchy.
  // In this case, a pure merge is not wanted. Listener definitions from
  // every class level are collected up into an array.
  // addListener iterates any passed array, adding each element.
  {
    isArray: isArray$1
  } = Array,
  {
    hasOwnProperty: hasOwnProperty$1
  } = Object.prototype,
  // Used to distinguish event names from listener options in addListener object config.
  specialProperties = {
    thisObj: 1,
    detachable: 1,
    once: 1,
    detacher: 1,
    prio: 1,
    args: 1,
    expires: 1,
    buffer: 1,
    throttle: 1,
    name: 1,
    $internal: 1
  },
  priorityComparator = (a, b) => b.prio - a.prio;
/**
 * Mix this into another class to enable event handling.
 *
 * ## Basic usage
 * Listeners can be added either through config:
 *
 * ```javascript
 * let button = new Button({
 *   listeners: {
 *     click: () => {},
 *     press: () => {},
 *     ...
 *   }
 * });
 * ```
 *
 * *NOTE*: Do not reuse listeners config object, use new every time:
 * ```javascript
 * // wrong
 * let config = { click : () => {} }
 * new Button({
 *     listeners : config
 * })
 * new Button({
 *     listeners : config
 * })
 * // right
 * new Button({
 *     listeners : { click : () => {} }
 * })
 * new Button({
 *     listeners : { click : () => {} }
 * })
 * ```
 *
 * Or by calling on()/addListener():
 *
 * ```javascript
 * let button = new Button();
 *
 * button.addListener('press', () => {});
 * // on is an alias for addListener
 * button.on('click', () => {});
 * ```
 *
 * This style also accepts multiple listeners in same way as when using config:
 *
 * ```javascript
 * button.on({
 *   click: () => {},
 *   press: () => {},
 *   ...
 * });
 * ```
 *
 * ### Handlers as function name
 *
 * Event handlers may be specified as a function __name__. If a string is specified, it is the name
 * of the function in the `thisObj` object.
 *
 * If the string begins with `up.`, the owning object's ownership hierarchy
 * (if present) is scanned for an object which implements that function name:
 *
 * ```javascript
 * new Popup({
 *     tbar : {
 *         items : {
 *             myCombo : {
 *                 type      : 'combo',
 *                 editable  : false,
 *                 label     : 'Type',
 *                 listeners : {
 *                     // Look in owner chain for this function name
 *                     change : 'up.onFilterChange'
 *                 },
 *                 items     : [
 *                     'Event',
 *                     'Task',
 *                     'Appointment'
 *                 ]
 *             }
 *         }
 *     },
 *     items : {
 *         ...
 *     },
 *     onFilterChange({ value }) {
 *         // Handle event type selection here
 *     }
 * });
 *```
 *
 * ## Listener options
 * ### Once
 * Listeners can be configured to automatically deregister after first trigger by specifying config option `once`:
 *
 * ```javascript
 * button.on({
 *   click: () => {},
 *   once: true
 * });
 * ```
 *
 * ### Priority
 * Specifying priority affects the order in which listeners are called when triggering an event. Higher priorities will be
 * called before lower. Default value is 0.
 *
 * ```javascript
 * button.on({
 *   click: this.onClick,
 *   prio: 1
 * });
 * ```
 *
 * ### This reference
 * If desired, you can specify thisObj when configuring listeners. There is no need if you are using arrow functions as
 * listeners, but might be handy in other cases. Of course, you can also use bind to set `this` reference.
 *
 * ```javascript
 * button.on({
 *   click: this.onClick,
 *   thisObj: this
 * });
 *
 * // or
 *
 * button.on({
 *   click: this.onClick.bind(this)
 * });
 * ```
 *
 * ### Buffering
 * By specifying a `buffer` events that fire frequently can be grouped together and delayed. A handler for the event will be called once only, when no new event has been fired during the specified buffer time:
 *
 * ```javascript
 * button.on({
 *   click  : this.onClick,
 *   buffer : 200 // in milliseconds
 * });
 * ```
 *
 * In this example, if a user clicked the button 6 times very fast (<200ms between each click),
 * the `this.onClick` handler would be called only once 200 milliseconds after the last click.
 *
 * ### Throttling
 * Create a "debounced" function which will call on the "leading edge" of a timer period.
 * When first invoked will call immediately, but invocations after that inside its buffer
 * period will be rejected, and *one* invocation will be made after the buffer period has expired.
 *
 * This is useful for responding immediately to a first mousemove, but from then on, only
 * calling the action function on a regular timer while the mouse continues to move.
 * ```javascript
 * button.on({
 *   click    : this.onClick,
 *   throttle : 200 // in milliseconds
 * });
 * ```
 *
 * In this example, if a user clicked the button 6 times very fast, the `this.onClick` handler would be called once immediately on the first click and a second time 200 milliseconds after the **first** click.
 * So in reality the `click` event handler will be called every 200ms independent of amount of click in a middle, if the event was triggered at least once during the `throttle` timeout.
 *
 * ### Detacher
 * A convenient way of unregistering events is to use a detacher, a function returned when adding listeners that you
 * call later to deregister them. As of version 1.0, detachable defaults to true.
 *
 * ```javascript
 * let detacher = button.on({
 *   click: () => {},
 *   press: () => {},
 *   detachable: true
 * });
 *
 * // when you want to detach, for example in destroy()
 * detacher();
 * ```
 *
 * ### Auto detaching
 * When listeners are bound to a class instance using `thisObj`, the `thisObj`'s `doDestroy` method
 * is overridden to remove the listeners before calling the overridden doDestroy.
 *
 * ```javascript
 * class MyClass extends Base {
 *   construct() {
 *     let button = new Button({
 *       listeners: {
 *         click: () => {},
 *         thisObj: this
 *       }
 *     });
 *   }
 *
 *   doDestroy() {
 *     // clean up stuff
 *   }
 * }
 *
 * let myObj = new MyClass();
 * // clean up, also removes listeners
 * myObj.destroy();
 * ```
 *
 * ### On-functions
 * When mixing Events into another class it can be configured to call on-functions when events are triggered.
 * On-functions are functions named 'onEventName', for example 'onClick', 'onPress' declared on the class triggering
 * the event.
 *
 * ```javascript
 * // mix Events in with on-functions activated
 * let button = new Button({
 *   callOnFunctions: true,
 *
 *   onClick: () => {}
 * });
 *
 * // or add a getter in class declaration
 * ```
 *
 * Returning `false` from an on-function will prevent triggering listeners for the event.
 *
 * ### Catching all events
 * By specifying a listener for {@link #event-catchAll catchAll} a function can be notified when any event is triggered:
 *
 * ```javascript
 * const button = new Button({
 *    listeners : {
 *        catchAll(event) {
 *            // All events on the button will pass through here
 *        }
 *    }
 * });
 * ```
 *
 * ## Preventable events
 *
 * By returning `false` from a listener for an event documented as `preventable` the action that would otherwise be
 * executed after the event is prevented. These events are usually named `beforeXX`, for example `beforeRemove`,
 * `beforeDragStart` etc.
 *
 * <div class="note">Note that Angular does not support return values from listeners. Instead, assign to
 * <code>event.returnValue</code> as shown in the Angular snippet below</div>
 *
 * {@frameworktabs}
 * {@js}
 * ```javascript
 * taskBoard.on({
 *     beforeColumnDrag({ columnRecord }) {
 *         if (columnRecord.locked) {
 *             return false;
 *         }
 *     }
 * });
 * ```
 *
 * {@endjs}
 * {@react}
 *
 * ```jsx
 * const App = props => {
 *     function onBeforeColumnDrag({ columnRecord }) {
 *         if (columnRecord.locked) {
 *             return false;
 *         }
 *     }
 *
 *     return (
 *         <>
 *             <BryntumTaskBoard onBeforeColumnDrag={onBeforeColumnDrag} />
 *         </>
 *     )
 * }
 * ```
 *
 * {@endreact}
 * {@vue}
 *
 * ```html
 * <bryntum-task-board @beforeColumnDrag="onBeforeColumnDrag" />
 * ```
 *
 * ```javascript
 * export default {
 *     methods : {
 *         onBeforeColumnDrag({ columnRecord }) {
 *             if (columnRecord.locked) {
 *                 return false;
 *             }
 *         }
 *    }
 * }
 * ```
 *
 * {@endvue}
 * {@angular}
 *
 * ```html
 * <bryntum-task-board (onBeforeColumnDrag)="onBeforeColumnDrag({event : $event})"></bryntum-task-board>
 * ```
 *
 * ```typescript
 * export class AppComponent {
 *     onBeforeColumnDrag({ event }: { event: any }): void {
 *         event.returnValue = !event.columnRecord.locked;
 *     }
 *  }
 * ```
 *
 * {@endangular}
 * {@endframeworktabs}
 *
 * @mixin
 */
var Events = (Target => class Events extends (Target || Base) {
  eventsSuspended = null;
  static get $name() {
    return 'Events';
  }
  //region Events
  /**
   * Fires before an object is destroyed.
   * @event beforeDestroy
   * @param {Core.Base} source The Object that is being destroyed.
   */
  /**
   * Fires when an object is destroyed.
   * @event destroy
   * @param {Core.Base} source The Object that is being destroyed.
   */
  /**
   * Fires when any other event is fired from the object.
   *
   * **Note**: `catchAll` is fired for both public and private events. Please rely on the public events only.
   * @event catchAll
   * @param {Object} event The Object that contains event details
   * @param {String} event.type The type of the event which is caught by the listener
   */
  //endregion
  static get declarable() {
    return [
    /**
     * The list of deprecated events as an object, where `key` is an event name which is deprecated and
     * `value` is an object which contains values for
     * {@link Core.helper.VersionHelper#function-deprecate-static VersionHelper}:
     * - product {String} The name of the product;
     * - invalidAsOfVersion {String} The version where the offending code is invalid (when any compatibility
     *   layer is actually removed);
     * - message {String} Warning message to show to the developer using a deprecated API;
     *
     * For example:
     *
     * ```javascript
     * return {
     *     click : {
     *         product            : 'Grid',
     *         invalidAsOfVersion : '1.0.0',
     *         message            : 'click is deprecated!'
     *     }
     * }
     * ```
     *
     * @name deprecatedEvents
     * @returns {Object}
     * @static
     * @internal
     */
    'deprecatedEvents'];
  }
  static setupDeprecatedEvents(cls, meta) {
    const all = meta.getInherited('deprecatedEvents'),
      add = cls.deprecatedEvents;
    for (const eventName in add) {
      // Event names are case-insensitive so build our map using toLowerCased names (but keep true case too):
      all[eventName.toLowerCase()] = all[eventName] = add[eventName];
    }
  }
  //region Config
  static get configurable() {
    return {
      /**
       * Set to true to call onXXX method names (e.g. `onShow`, `onClick`), as an easy way to listen for events.
       *
       * ```javascript
       * const container = new Container({
       *     callOnFunctions : true
       *
       *     onHide() {
       *          // Do something when the 'hide' event is fired
       *     }
       * });
       * ```
       *
       * @config {Boolean} callOnFunctions
       * @category Misc
       * @default false
       */
      /**
       * The listener set for this object.
       *
       * An object whose property names are the names of events to handle, or options which modifiy
       * __how__ the handlers are called.
       *
       * See {@link #function-addListener} for details about the options.
       *
       * Listeners can be specified in target class config and they will be merged with any listeners specified in
       * the instantiation config. Class listeners will be fired first:
       *
       * ```javascript
       * class MyStore extends Store({
       *     static get configurable() {
       *         return {
       *             listeners : {
       *                 myCustomEvent() {
       *                 },
       *                 load : {
       *                     prio : 10000,
       *                     fn() { // this load listener handles things first }
       *                 }
       *             }
       *         }
       *     }
       * });
       *
       * let store = new MyStore({
       *   listeners: {
       *     load: () => { // This load listener runs after the class's },
       *     ...
       *   }
       * });
       * ```
       *
       * ### Handlers as function name
       *
       * Object event handlers may be specified as a function __name__. If a string is specified, it is the name
       * of the function in the `thisObj` object.
       *
       * If the string begins with `up.`, this object's ownership hierarchy
       * (if present) is scanned for an object which implements that function name:
       *
       * ```javascript
       * new Popup({
       *     tbar : {
       *         items : {
       *             myCombo : {
       *                 type      : 'combo',
       *                 editable  : false,
       *                 label     : 'Type',
       *                 listeners : {
       *                     // Look in owner chain for this function name
       *                     change : 'up.onFilterChange'
       *                 },
       *                 items     : [
       *                     'Event',
       *                     'Task',
       *                     'Appointment'
       *                 ]
       *             }
       *         }
       *     },
       *     items : {
       *         ...
       *     },
       *     onFilterChange({ value }) {
       *         // Handle event type selection here
       *     }
       * });
       *```
       *
       * @config {Object}
       * @category Common
       */
      listeners: {
        value: null,
        $config: {
          merge(newValue, currentValue) {
            if (newValue !== null) {
              if (!newValue) {
                return currentValue;
              }
              if (currentValue) {
                newValue = newValue ? [newValue] : [];
                newValue.push[isArray$1(currentValue) ? 'apply' : 'call'](newValue, currentValue);
              }
            }
            return newValue;
          }
        }
      },
      /**
       * Internal listeners, that cannot be removed by the user.
       * @config {Object}
       * @internal
       */
      internalListeners: null,
      /**
       * An object where property names with a truthy value indicate which events should bubble up the ownership
       * hierarchy when triggered.
       *
       * ```javascript
       * const container = new Container({
       *     items : [
       *        { type : 'text', bubbleEvents : { change : true }}
       *     ],
       *
       *     listeners : {
       *         change() {
       *             // Will catch change event from the text field
       *         }
       *     }
       * });
       * ```
       *
       * @config {Object}
       * @category Misc
       */
      bubbleEvents: null
    };
  }
  destroy() {
    this.trigger('beforeDestroy');
    super.destroy();
  }
  //endregion
  //region Init
  construct(config, ...args) {
    var _config;
    // Configured listeners use this as the thisObj
    if (this.configuredListeners /* assignment */ = (_config = config) === null || _config === void 0 ? void 0 : _config.listeners) {
      // We have to copy in case listeners have been forked
      config = Objects.assign({}, config);
      delete config.listeners;
    }
    super.construct(config, ...args);
    // Apply configured listeners after construction.
    // Note that some classes invoke this during parts of their construction.
    // Store invokes this prior to setting data so that observers are notified of data load.
    this.processConfiguredListeners();
  }
  processConfiguredListeners() {
    // This can only happen once
    if (this.configuredListeners) {
      const me = this,
        {
          isConfiguring
        } = me;
      // If called from config ingestion during configuration, listeners must be added
      // so temporarily clear the isConfiguring flag.
      me.isConfiguring = false;
      me.listeners = me.configuredListeners;
      me.configuredListeners = null;
      me.isConfiguring = isConfiguring;
    }
  }
  /**
   * Auto detaches listeners registered from start, if set as detachable
   * @internal
   */
  doDestroy() {
    this.trigger('destroy');
    this.removeAllListeners(false);
    super.doDestroy();
  }
  static setupClass(meta) {
    super.setupClass(meta);
    Events.prototype.onListen.$nullFn = true;
    Events.prototype.onUnlisten.$nullFn = true;
  }
  //endregion
  //region Listeners
  /**
   * Adds an event listener. This method accepts parameters in the following format:
   *
   * ```javascript
   *  myObject.addListener({
   *      thisObj    : this,          // The this reference for the handlers
   *      eventname2 : 'functionName' // Resolved at invocation time using the thisObj,
   *      otherevent : {
   *          fn      : 'handlerFnName',
   *          once    : true          // Just this handler is auto-removed on fire
   *      },
   *      yetanother  : {
   *          fn      : 'yetAnotherHandler',
   *          args    : [ currentState1, currentState2 ] // Capture info to be passed to handler
   *      },
   *      prio        : 100           // Higher prio listeners are called before lower
   *  });
   * ```
   *
   * When listeners have a `thisObj` option, they are linked to the lifecycle of that object.
   * When it is destroyed, those listeners are removed.
   *
   * The `config` parameter allows supplying options for the listener(s), for available options see {@link #typedef-BryntumListenerConfig}.
   *
   * A simpler signature may be used when only adding a listener for one event and no extra options
   * (such as `once` or `delay`) are required:
   *
   * ```javascript
   * myObject.addListener('click', myController.handleClicks, myController);
   * ```
   *
   * The args in this simple case are `eventName`, `handler` and `thisObj`
   *
   * @param {BryntumListenerConfig|String} config An object containing listener definitions, or the event name to listen for
   * @param {Object|Function} [thisObj] Default `this` reference for all listeners in the config object, or the handler
   * function to call if providing a string as the first arg.
   * @param {Object} [oldThisObj] The `this` reference if the old signature starting with a string event name is used..
   * @returns {Function} Returns a detacher function unless configured with `detachable: false`. Call detacher to remove listeners
   */
  addListener(config, thisObj, oldThisObj) {
    if (isArray$1(config)) {
      for (let i = 0, {
          length
        } = config; i < length; i++) {
        this.addListener(config[i], thisObj);
      }
      return;
    }
    const me = this,
      deprecatedEvents = me.$meta.getInherited('deprecatedEvents');
    if (typeof config === 'string') {
      // arguments[2] is thisObj if (eventname, handler, thisObj) form called.
      // Note that the other side of the if compares to undefined, so this will work.
      return me.addListener({
        [config]: thisObj,
        detachable: thisObj.detachable !== false,
        thisObj: oldThisObj
      });
    } else {
      // Capture the default thisObj.
      thisObj = config.thisObj = config.thisObj !== undefined ? config.thisObj : thisObj;
      for (const key in config) {
        // Skip special properties or events without handlers (convenient syntax with optional handlers)
        if (!specialProperties[key] && config[key] != null) {
          var _me$afterAddListener;
          // comparing should be case insensitive
          const
            // comparing should be case insensitive
            eventName = key.toLowerCase(),
            deprecatedEvent = deprecatedEvents === null || deprecatedEvents === void 0 ? void 0 : deprecatedEvents[eventName],
            events = me.eventListeners || (me.eventListeners = {}),
            listenerSpec = config[key],
            expires = listenerSpec.expires || config.expires,
            listener = {
              fn: typeof listenerSpec === 'object' ? listenerSpec.fn : listenerSpec,
              thisObj: listenerSpec.thisObj !== undefined ? listenerSpec.thisObj : thisObj,
              args: listenerSpec.args || config.args,
              prio: listenerSpec.prio !== undefined ? listenerSpec.prio : config.prio !== undefined ? config.prio : 0,
              once: listenerSpec.once !== undefined ? listenerSpec.once : config.once !== undefined ? config.once : false,
              buffer: listenerSpec.buffer || config.buffer,
              throttle: listenerSpec.throttle || config.throttle,
              $internal: config.$internal,
              catchAll: key === 'catchAll'
            };
          if (deprecatedEvent) {
            const {
              product,
              invalidAsOfVersion,
              message
            } = deprecatedEvent;
            VersionHelper.deprecate(product, invalidAsOfVersion, message);
          }
          if (expires) {
            // Extract expires : { delay : 100, alt : 'onExpireFn' }
            const {
                alt
              } = expires,
              delay = alt ? expires.delay : expires,
              name = config.name || key,
              fn = () => {
                me.un(eventName, listener);
                // If we make it here and the handler has not been called, invoke the alt handler
                if (alt && !listener.called) {
                  me.callback(alt, thisObj);
                }
              };
            if (me.isDelayable) {
              me.setTimeout({
                fn,
                name,
                cancelOutstanding: true,
                delay
              });
            } else {
              globalThis.setTimeout(fn, delay);
            }
          }
          let listeners = events[eventName] || (events[eventName] = []);
          if (listeners.$firing) {
            events[eventName] = listeners = listeners.slice();
          }
          // Insert listener directly in prio order
          listeners.splice(ArrayHelper.findInsertionIndex(listener, listeners, priorityComparator, listeners.length), 0, listener);
          if (!me.onListen.$nullFn && listeners.length < 2) {
            me.onListen(eventName);
          }
          // Hook to call when a listener is added
          (_me$afterAddListener = me.afterAddListener) === null || _me$afterAddListener === void 0 ? void 0 : _me$afterAddListener.call(me, eventName, listener);
        }
      }
      if (config.relayAll) {
        me.relayAll(config.relayAll);
      }
      // Hook into the thisObj's destruction sequence to remove these listeners.
      // Pass the default thisObj in for use when it comes to destruction time.
      if (thisObj && thisObj !== me) {
        me.attachAutoDetacher(config, thisObj);
      }
      const detachable = config.detachable !== false,
        name = config.name,
        destroy = config.expires || detachable || name ? () => {
          // drop listeners if not destroyed yet
          if (!me.isDestroyed) {
            me.removeListener(config, thisObj);
          }
        } : null;
      if (destroy) {
        var _thisObj;
        destroy.eventer = me;
        destroy.listenerName = name;
        if (name && (_thisObj = thisObj) !== null && _thisObj !== void 0 && _thisObj.trackDetacher) {
          thisObj.trackDetacher(name, destroy);
        }
        if (config.expires) {
          // handle expires : { alt : timeoutHandler, delay : 2000 }
          me.delay(destroy, isNaN(config.expires) ? config.expires.delay : config.expires, name);
        }
        if (detachable) {
          return destroy;
        }
      }
    }
  }
  /**
   * Alias for {@link #function-addListener}. Adds an event listener. This method accepts parameters in the following format:
   *
   * ```javascript
   *  myObject.on({
   *      thisObj    : this,          // The this reference for the handlers
   *      eventname2 : 'functionName' // Resolved at invocation time using the thisObj,
   *      otherevent : {
   *          fn      : 'handlerFnName',
   *          once    : true          // Just this handler is auto-removed on fire
   *      },
   *      yetanother  : {
   *          fn      : 'yetAnotherHandler',
   *          args    : [ currentState1, currentState2 ] // Capture info to be passed to handler
   *      },
   *      prio        : 100           // Higher prio listeners are called before lower
   *  });
   * ```
   *
   * When listeners have a `thisObj` option, they are linked to the lifecycle of that object.
   * When it is destroyed, those listeners are removed.
   *
   * The `config` parameter allows supplying options for the listener(s), for available options see {@link #typedef-BryntumListenerConfig}.
   *
   * A simpler signature may be used when only adding a listener for one event and no extra options
   * (such as `once` or `delay`) are required:
   *
   * ```javascript
   * myObject.on('click', myController.handleClicks, myController);
   * ```
   *
   * The args in this simple case are `eventName`, `handler` and `thisObj`
   *
   * @param {BryntumListenerConfig|String} config An object containing listener definitions, or the event name to listen for
   * @param {Object|Function} [thisObj] Default `this` reference for all listeners in the config object, or the handler
   * function to call if providing a string as the first arg.
   * @param {Object} [oldThisObj] The `this` reference if the old signature starting with a string event name is used..
   * @returns {Function} Returns a detacher function unless configured with `detachable: false`. Call detacher to remove listeners
   */
  on(config, thisObj, oldThisObj) {
    return this.addListener(config, thisObj, oldThisObj);
  }
  /**
   * Internal convenience method for adding an internal listener, that cannot be removed by the user.
   *
   * Alias for `on({ $internal : true, ... })`. Only supports single argument form.
   *
   * @internal
   */
  ion(config) {
    config.$internal = true;
    return this.on(config);
  }
  /**
   * Shorthand for {@link #function-removeListener}
   * @param {Object|String} config A config object or the event name
   * @param {Object|Function} [thisObj] `this` reference for all listeners, or the listener function
   * @param {Object} [oldThisObj] `this` The `this` object for the legacy way of adding listeners
   */
  un(...args) {
    this.removeListener(...args);
  }
  updateInternalListeners(internalListeners, oldInternalListeners) {
    oldInternalListeners === null || oldInternalListeners === void 0 ? void 0 : oldInternalListeners.detach();
    if (internalListeners) {
      internalListeners.detach = this.ion(internalListeners);
    }
  }
  get listeners() {
    return this.eventListeners;
  }
  changeListeners(listeners) {
    // If we are receiving class listeners, add them early, and they do not become
    // the configured listeners, and are not removed by setting listeners during the lifecycle.
    if (this.isConfiguring) {
      // Pull in internal listeners first
      this.getConfig('internalListeners');
      if (listeners) {
        this.on(listeners, this);
      }
    }
    // Setting listeners after config time clears the old set and adds the new.
    // This will initially happen at the tail end of the constructor when config
    // listeners are set.
    else {
      // Configured listeners use this as the thisObj by default.
      // Flatten using Objects.assign because it may have been part of
      // a prototype chained default configuration of another object.
      // eg: the tooltip config of a Widget.
      // listener object blocks from multiple configuration levels are pushed
      // onto an array (see listeners merge function in configurable block above).
      // If this has happened, each entry must be processed like this.
      if (Array.isArray(listeners)) {
        for (let i = 0, l = listeners[0], {
            length
          } = listeners; i < length; l = listeners[++i]) {
          if (!('thisObj' in l)) {
            listeners[i] = Objects.assign({
              thisObj: this
            }, l);
          }
        }
      } else if (listeners && !('thisObj' in listeners)) {
        listeners = Objects.assign({
          thisObj: this
        }, listeners);
      }
      return listeners;
    }
  }
  updateListeners(listeners, oldListeners) {
    // Only configured listeners get here. Class listeners are added by changeListeners.
    oldListeners && this.un(oldListeners);
    listeners && this.on(listeners);
  }
  /**
   * Removes an event listener. Same API signature as {@link #function-addListener}
   * @param {Object|String} config A config object or the event name
   * @param {Object|Function} thisObj `this` reference for all listeners, or the listener function
   * @param {Object} oldThisObj `this` The `this` object for the legacy way of adding listeners
   */
  removeListener(config, thisObj = config.thisObj, oldThisObj) {
    const me = this;
    if (typeof config === 'string') {
      return me.removeListener({
        [config]: thisObj
      }, oldThisObj);
    }
    Object.entries(config).forEach(([eventName, listenerToRemove]) => {
      if (!specialProperties[eventName] && listenerToRemove != null) {
        eventName = eventName.toLowerCase();
        const {
            eventListeners
          } = me,
          index = me.findListener(eventName, listenerToRemove, thisObj);
        if (index >= 0) {
          var _me$afterRemoveListen;
          let listeners = eventListeners[eventName];
          // Hook to call when a listener is removed (slightly before removing for now)
          (_me$afterRemoveListen = me.afterRemoveListener) === null || _me$afterRemoveListen === void 0 ? void 0 : _me$afterRemoveListen.call(me, eventName, listeners[index]);
          if (listeners.length > 1) {
            if (listeners.$firing) {
              eventListeners[eventName] = listeners = listeners.slice();
            }
            // NOTE: we cannot untrack any detachers here because we may only be
            // removing some of its listeners
            listeners.splice(index, 1);
          } else {
            delete eventListeners[eventName];
            if (!me.onUnlisten.$nullFn) {
              me.onUnlisten(eventName);
            }
          }
        }
      }
    });
    if (config.thisObj && !config.thisObj.isDestroyed) {
      me.detachAutoDetacher(config);
    }
  }
  /**
   * Finds the index of a particular listener to the named event. Returns `-1` if the passed
   * function/thisObj listener is not present.
   * @param {String} eventName The name of an event to find a listener for.
   * @param {String|Function} listenerToFind The handler function to find.
   * @param {Object} defaultThisObj The `thisObj` for the required listener.
   * @internal
   */
  findListener(eventName, listenerToFind, defaultThisObj) {
    var _this$eventListeners;
    const eventListeners = (_this$eventListeners = this.eventListeners) === null || _this$eventListeners === void 0 ? void 0 : _this$eventListeners[eventName],
      fn = listenerToFind.fn || listenerToFind,
      thisObj = listenerToFind.thisObj || defaultThisObj;
    if (eventListeners) {
      for (let listenerEntry, i = 0, {
          length
        } = eventListeners; i < length; i++) {
        listenerEntry = eventListeners[i];
        if (listenerEntry.fn === fn && listenerEntry.thisObj === thisObj) {
          return i;
        }
      }
    }
    return -1;
  }
  /**
   * Check if any listener is registered for the specified eventName
   * @param {String} eventName
   * @returns {Boolean} `true` if listener is registered, otherwise `false`
   * @advanced
   */
  hasListener(eventName) {
    var _this$eventListeners2;
    return Boolean((_this$eventListeners2 = this.eventListeners) === null || _this$eventListeners2 === void 0 ? void 0 : _this$eventListeners2[eventName === null || eventName === void 0 ? void 0 : eventName.toLowerCase()]);
  }
  /**
   * Relays all events through another object that also implements Events mixin. Adds a prefix to the event name
   * before relaying, for example add -> storeAdd
   * ```
   * // Relay all events from store through grid, will make it possible to listen for store events prefixed on grid:
   * 'storeLoad', 'storeChange', 'storeRemoveAll' etc.
   * store.relayAll(grid, 'store');
   *
   * grid.on('storeLoad', () => console.log('Store loaded');
   * ```
   * @param {Core.mixin.Events} through Object to relay the events through, needs to mix Events mixin in
   * @param {String} prefix Prefix to add to event name
   * @param {Boolean} [transformCase] Specify false to prevent making first letter of event name uppercase
   * @advanced
   */
  relayAll(through, prefix, transformCase = true) {
    if (!this.relayAllTargets) {
      this.relayAllTargets = [];
    }
    const {
      relayAllTargets
    } = this;
    through.ion({
      beforeDestroy: ({
        source
      }) => {
        if (source === through) {
          const configs = relayAllTargets.filter(r => r.through === through);
          configs.forEach(config => ArrayHelper.remove(relayAllTargets, config));
        }
      }
    });
    relayAllTargets.push({
      through,
      prefix,
      transformCase
    });
  }
  /**
   * Removes all listeners registered to this object by the application.
   */
  removeAllListeners(preserveInternal = true) {
    const listeners = this.eventListeners;
    let i, thisObj;
    for (const event in listeners) {
      const bucket = listeners[event];
      // We iterate backwards since we call removeListener which will splice out of
      // this array as we go...
      for /* empty */
      (i = bucket.length; i-- > 0;) {
        const cfg = bucket[i];
        if (!cfg.$internal || !preserveInternal) {
          var _thisObj2, _thisObj2$untrackDeta, _thisObj3;
          this.removeListener(event, cfg);
          thisObj = cfg.thisObj;
          (_thisObj2 = thisObj) === null || _thisObj2 === void 0 ? void 0 : (_thisObj2$untrackDeta = (_thisObj3 = _thisObj2).untrackDetachers) === null || _thisObj2$untrackDeta === void 0 ? void 0 : _thisObj2$untrackDeta.call(_thisObj3, this);
        }
      }
    }
  }
  relayEvents(source, eventNames, prefix = '') {
    const listenerConfig = {
      detachable: true,
      thisObj: this
    };
    eventNames.forEach(eventName => {
      listenerConfig[eventName] = (event, ...params) => {
        return this.trigger(prefix + eventName, event, ...params);
      };
    });
    return source.on(listenerConfig);
  }
  /**
   * This method is called when the first listener for an event is added.
   * @param {String} eventName
   * @internal
   */
  onListen() {}
  /**
   * This method is called when the last listener for an event is removed.
   * @param {String} eventName
   * @internal
   */
  onUnlisten() {}
  destructorInterceptor() {
    const {
      autoDetachers,
      target,
      oldDestructor
    } = this;
    // Remove listeners first, so that they do not fire during destruction.
    // The observable being listened to by the thisObj may already have
    // been destroyed in a clean up sequence
    for (let i = 0; i < autoDetachers.length; i++) {
      const {
        dispatcher,
        config
      } = autoDetachers[i];
      if (!dispatcher.isDestroyed) {
        dispatcher.removeListener(config, target);
      }
    }
    oldDestructor.call(target);
  }
  /**
   * Internal function used to hook destroy() calls when using thisObj
   * @private
   */
  attachAutoDetacher(config, thisObj) {
    const target = config.thisObj || thisObj,
      // If it's a Bryntum Base subclass, hook doDestroy, otherwise, destroy
      destructorName = 'doDestroy' in target ? 'doDestroy' : 'destroy';
    if (destructorName in target) {
      let {
        $autoDetachers
      } = target;
      if (!$autoDetachers) {
        target.$autoDetachers = $autoDetachers = [];
      }
      if (!target.$oldDestructor) {
        target.$oldDestructor = target[destructorName];
        // Binding instead of using closure (used to use FunctionHelper.createInterceptor) to not retain target
        // when detaching manually
        target[destructorName] = this.destructorInterceptor.bind({
          autoDetachers: $autoDetachers,
          oldDestructor: target.$oldDestructor,
          target
        });
      }
      $autoDetachers.push({
        config,
        dispatcher: this
      });
    } else {
      target[destructorName] = () => {
        this.removeListener(config);
      };
    }
  }
  /**
   * Internal function used restore hooked destroy() calls when using thisObj
   * @private
   */
  detachAutoDetacher(config) {
    const target = config.thisObj;
    // Restore old destructor and remove from auto detachers only if we are not called as part of destruction.
    // (Altering $autoDetachers affects destruction iterating over them, breaking it. It is pointless to clean up
    // during destruction anyway, since everything gets removed)
    if (target.$oldDestructor && !target.isDestroying) {
      ArrayHelper.remove(target.$autoDetachers, target.$autoDetachers.find(detacher => detacher.config === config && detacher.dispatcher === this));
      if (!target.$autoDetachers.length) {
        target['doDestroy' in target ? 'doDestroy' : 'destroy'] = target.$oldDestructor;
        target.$oldDestructor = null;
      }
    }
  }
  //endregion
  //region Promise based workflow
  // experimental, used in tests to support async/await workflow
  await(eventName, options = {
    checkLog: true,
    resetLog: true,
    args: null
  }) {
    const me = this;
    if (options === false) {
      options = {
        checkLog: false
      };
    }
    const {
      args
    } = options;
    return new Promise(resolve => {
      var _me$_triggered;
      // check if previously triggered?
      if (options.checkLog && (_me$_triggered = me._triggered) !== null && _me$_triggered !== void 0 && _me$_triggered[eventName]) {
        // resolve immediately, no params though...
        resolve();
        // reset log to be able to await again
        if (options.resetLog) {
          me.clearLog(eventName);
        }
      }
      // This branch will listen for events until catches one with specific arguments
      if (args) {
        const detacher = me.on({
          [eventName]: (...params) => {
            // if args is a function use it to match arguments
            const argsOk = typeof args === 'function' ? args(...params) : Object.keys(args).every(key => {
              return key in params[0] && params[0][key] === args[key];
            });
            if (argsOk) {
              // resolve when event is fired with required arguments
              resolve(...params);
              // reset log to be able to await again
              if (options.resetLog) {
                me.clearLog(eventName);
              }
              detacher();
            }
          },
          prio: -10000 // Let others do their stuff first
        });
      } else {
        me.on({
          [eventName]: (...params) => {
            // resolve when event is caught
            resolve(...params);
            // reset log to be able to await again
            if (options.resetLog) {
              me.clearLog(eventName);
            }
          },
          prio: -10000,
          // Let others do their stuff first
          once: true // promises can only be resolved once anyway
        });
      }
    });
  }

  clearLog(eventName) {
    if (this._triggered) {
      if (eventName) {
        delete this._triggered[eventName];
      } else {
        this._triggered = {};
      }
    }
  }
  //endregion
  //region Trigger
  /**
   * Triggers an event, calling all registered listeners with the supplied arguments. Returning false from any listener
   * makes function return false.
   * @param {String} eventName Event name for which to trigger listeners
   * @param {Object} [param] Single parameter passed on to listeners, source property will be added to it (this)
   * @param {Boolean} [param.bubbles] Pass as `true` to indicate that the event will bubble up the widget
   * ownership hierarchy. For example up a `Menu`->`parent` Menu tree, or a `Field`->`Container` tree.
   * @typings param -> {{bubbles?: boolean, [key: string]: any}}
   * @returns {Boolean|Promise} Returns false if any listener returned `false`, or a `Promise` yielding
   * `true` / `false` based on what is returned from the async listener functions, otherwise `true`
   * @async
   * @advanced
   */
  trigger(eventName, param) {
    var _me$eventListeners, _me$eventListeners2, _me$bubbleEvents, _handlerPromises, _handlerPromises2;
    const me = this,
      name = eventName.toLowerCase(),
      {
        eventsSuspended,
        relayAllTargets,
        callOnFunctions
      } = me;
    let listeners = (_me$eventListeners = me.eventListeners) === null || _me$eventListeners === void 0 ? void 0 : _me$eventListeners[name],
      handlerPromises;
    // log trigger, used by experimental promise support to resolve immediately when needed
    if (!me._triggered) {
      me._triggered = {};
    }
    me._triggered[eventName] = true;
    if (eventsSuspended) {
      if (eventsSuspended.shouldQueue) {
        eventsSuspended.queue.push(arguments);
      }
      return true;
    }
    // Include catchall listener for all events.
    // Do not push the catchAll listeners onto the events own listener array.
    if ((_me$eventListeners2 = me.eventListeners) !== null && _me$eventListeners2 !== void 0 && _me$eventListeners2.catchall) {
      (listeners = listeners ? listeners.slice() : []).push(...me.eventListeners.catchall);
      // The catchAll listeners must honour their prio settings.
      listeners.sort(priorityComparator);
    }
    if (!listeners && !relayAllTargets && !callOnFunctions) {
      return true;
    }
    // default to include source : this in param
    if (param) {
      if (!('source' in param)) {
        if (Object.isExtensible(param)) {
          param.source = me;
        } else {
          param = Object.setPrototypeOf({
            source: me
          }, param);
        }
      }
    } else {
      param = {
        source: me
      };
    }
    // Lowercased event name should be the "type" property in keeping with DOM events.
    if (param.type !== name) {
      // Create instance property because "type" is read only
      if (param.constructor !== Object) {
        Reflect.defineProperty(param, 'type', {
          get: () => name
        });
      } else {
        param.type = name;
      }
    }
    param.eventName = eventName;
    // Bubble according to `bubbleEvents` config if `bubbles` is not explicitly set
    if (!('bubbles' in param) && (_me$bubbleEvents = me.bubbleEvents) !== null && _me$bubbleEvents !== void 0 && _me$bubbleEvents[eventName]) {
      param.bubbles = me.bubbleEvents[eventName];
    }
    if (callOnFunctions) {
      const fnName = 'on' + StringHelper.capitalize(eventName);
      if (fnName in me) {
        var _me$pluginFunctionCha;
        // Return true if the on[fnName] is not set to keep default behavior
        const result = me[fnName] ? me.callback(me[fnName], me, [param]) : true;
        let inhibit;
        if (Objects.isPromise(result)) {
          (handlerPromises || (handlerPromises = [])).push(result);
        } else {
          inhibit = result === false || inhibit;
        }
        // See if the called function was injected into the instance
        // masking an implementation in the prototype.
        // we must call the class's implementation after the injected one.
        // unless it's an injected chained function, in which case it will have been called above.
        // Note: The handler may have resulted in destruction.
        if (!me.isDestroyed && hasOwnProperty$1.call(me, fnName) && !((_me$pluginFunctionCha = me.pluginFunctionChain) !== null && _me$pluginFunctionCha !== void 0 && _me$pluginFunctionCha[fnName])) {
          const myProto = Object.getPrototypeOf(me);
          if (fnName in myProto) {
            const result = myProto[fnName].call(me, param);
            if (Objects.isPromise(result)) {
              (handlerPromises || (handlerPromises = [])).push(result);
            } else {
              inhibit = result === false || inhibit;
            }
            // A handler may have resulted in destruction.
            if (me.isDestroyed) {
              return;
            }
          }
        }
        // Returning false from an on-function prevents further triggering
        if (inhibit) {
          return false;
        }
      }
    }
    let ret;
    if (listeners) {
      let i = 0,
        internalAbort = false;
      // Let add/removeListener know that we're using the array to protect against a situation where an event
      // listener changes the listeners when triggering the event.
      listeners.$firing = true;
      // If any listener resulted in our destruction, abort.
      for (i; i < listeners.length && !me.isDestroyed && !internalAbort; i++) {
        const listener = listeners[i];
        // Previously, returning false would abort all further listeners. But now internal listeners
        // are allowed to run anyway
        if (ret === false && !listener.$internal) {
          continue;
        }
        let handler,
          thisObj = listener.thisObj;
        // Listeners that have thisObj are auto removed when thisObj is destroyed. If thisObj is destroyed from
        // a listener we might still end up here, since listeners are sliced and not affected by the removal
        if (!thisObj || !thisObj.isDestroyed) {
          // Flag for the expiry timer
          listener.called = true;
          if (listener.once) {
            me.removeListener(name, listener);
          }
          // prepare handler function
          if (typeof listener.fn === 'string') {
            if (thisObj) {
              handler = thisObj[listener.fn];
            }
            // keep looking for the callback in the hierarchy
            if (!handler) {
              const result = me.resolveCallback(listener.fn);
              handler = result.handler;
              thisObj = result.thisObj;
            }
          } else {
            handler = listener.fn;
          }
          // if `buffer` option is provided, the handler will be wrapped into buffer function,
          // but only once on the first call
          if (listener.buffer) {
            if (!listener.bufferFn) {
              const buffer = Number(listener.buffer);
              if (typeof buffer !== 'number' || isNaN(buffer)) {
                throw new Error(`Incorrect type for buffer, got "${buffer}" (expected a Number)`);
              }
              listener.bufferFn = FunctionHelper.createBuffered(handler, buffer, thisObj, listener.args);
            }
            handler = listener.bufferFn;
          }
          // if `throttle` option is provided, the handler will be called immediately, but all the rest calls
          // that happened during time specified in `throttle`, will be delayed and glued into 1 call
          if (listener.throttle) {
            const throttle = Number(listener.throttle);
            if (typeof throttle !== 'number' || isNaN(throttle)) {
              throw new Error(`Incorrect type for throttle, got "${throttle}" (expected a Number)`);
            }
            if (!listener.throttledFn) {
              listener.throttledFn = FunctionHelper.createThrottled(handler, throttle, thisObj, listener.args);
            }
            handler = listener.throttledFn;
          }
          const result = handler.call(thisObj || me, ...(listener.args || []), param);
          // Store result until we get a false return value, to mimic the old behavior from before we carried
          // on with calling internal listeners
          if (ret !== false) {
            ret = result;
          }
          if (listener.$internal && result === false) {
            internalAbort = true;
          }
          if (Objects.isPromise(result)) {
            result.$internal = listener.$internal;
            // If a handler is async (returns a Promise), then collect all Promises.
            // At the end we return a Promise which encapsulates all returned Promises
            // or, if only one handler was async, *the* Promise.
            // Don't allocate an Array until we have to.
            (handlerPromises || (handlerPromises = [])).push(result);
          }
        }
      }
      listeners.$firing = false;
      // An internal listener returned `false`, abort before relaying events etc.
      if (internalAbort) {
        return false;
      }
    }
    // relay all?
    relayAllTargets === null || relayAllTargets === void 0 ? void 0 : relayAllTargets.forEach(config => {
      let name = eventName;
      if (config.transformCase) {
        name = StringHelper.capitalize(name);
      }
      if (config.prefix) {
        name = config.prefix + name;
      }
      if (config.through.trigger(name, param) === false) {
        return false;
      }
    });
    // Use DOM standard event property name to indicate that the event
    // bubbles up the owner axis.
    // False from any handler cancels the bubble.
    // Must also avoid owner if any handlers destroyed the owner.
    if (param.bubbles && me.owner && !me.owner.isDestroyed) {
      return me.owner.trigger(eventName, param);
    }
    // Run internal promises even if external listener returned false
    handlerPromises = (_handlerPromises = handlerPromises) === null || _handlerPromises === void 0 ? void 0 : _handlerPromises.filter(p => ret !== false || p.$internal);
    // If any handlers were async functions (returned a Promise), then return a Promise
    // which resolves when they all resolve.
    if ((_handlerPromises2 = handlerPromises) !== null && _handlerPromises2 !== void 0 && _handlerPromises2.length) {
      return new Promise(resolve => {
        Promise.all(handlerPromises).then(promiseResults => {
          const finalResult = !promiseResults.some(result => result === false);
          resolve(finalResult);
        });
      });
    }
    return ret !== false;
  }
  /**
   * Prevents events from being triggered until {@link #function-resumeEvents()} is called. Optionally queues events that are triggered while
   * suspended. Multiple calls stack to require matching calls to `resumeEvents()` before actually resuming.
   * @param {Boolean} queue Specify true to queue events triggered while suspended
   * @advanced
   */
  suspendEvents(queue = false) {
    const eventsSuspended = this.eventsSuspended || (this.eventsSuspended = {
      shouldQueue: queue,
      queue: [],
      count: 0
    });
    eventsSuspended.count++;
  }
  /**
   * Resume event triggering after a call to {@link #function-suspendEvents()}. If any triggered events were queued they will be triggered.
   * @returns {Boolean} `true` if events have been resumed (multiple calls to suspend require an equal number of resume calls to resume).
   * @advanced
   */
  resumeEvents() {
    const suspended = this.eventsSuspended;
    if (suspended) {
      if (--suspended.count === 0) {
        this.eventsSuspended = null;
        if (suspended.shouldQueue) {
          for (const queued of suspended.queue) {
            this.trigger(...queued);
          }
        }
      }
    }
    return !Boolean(this.eventsSuspended);
  }
  //endregion
});

/**
 * @module Core/helper/AsyncHelper
 */
/**
 * A helper class to make asynchronous tasks `await` friendly.
 */
class AsyncHelper {
  /**
   * Returns a promise that resolves on next animation frame.
   * ```
   *  async method() {
   *      // do work
   *      await AsyncHelper.animationFrame();
   *      // do more work
   *  }
   * ```
   * @async
   */
  static animationFrame() {
    return new Promise(resolve => {
      requestAnimationFrame(resolve);
    });
  }
  /**
   * Returns a promise that resolves after a specified number of milliseconds.
   * ```
   *  async method() {
   *      await AsyncHelper.sleep(10);
   *      // ...
   *  }
   * ```
   * @param {Number} millis The number of milliseconds to sleep.
   * @async
   */
  static sleep(millis) {
    return new Promise(resolve => {
      setTimeout(() => {
        resolve();
      }, millis);
    });
  }
  /**
   * Returns a promise that resolves as soon as possible, allowing the browser to minimally process other messages.
   * This is the shortest possible delay the browser offers, so be aware that it does not necessarily allow the
   * browser to paint or reflow if used in a long loop. It does, however, allow other async methods to execute.
   * ```
   *  async method() {
   *      await AsyncHelper.yield();
   *      // ...
   *  }
   * ```
   * @async
   */
  static yield() {
    return Promise.resolve();
  }
}
AsyncHelper._$name = 'AsyncHelper';

/**
 * @module Core/helper/AjaxHelper
 */
/**
 * Options for the requests. Please see
 * [fetch API](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch) for details
 *
 * To set default values for the options please use {@link #property-DEFAULT_FETCH_OPTIONS-static} property:
 *
 * ```javascript
 * // enable passing parameters in request body by default
 * AjaxHelper.DEFAULT_FETCH_OPTIONS = { addQueryParamsToBody : true };
 * ```
 *
 * @typedef {Object} FetchOptions
 * @property {'GET'|'POST'|'PUT'|'PATCH'|'DELETE'} [method] The request method, e.g., `GET`, `POST`
 * @property {Object} [queryParams] A key-value pair Object containing the params to add to the query string
 * @property {Object} [headers] Any headers you want to add to your request, contained within a `Headers` object or an
 * object literal with ByteString values
 * @property {Object} [body] Any body that you want to add to your request: this can be a `Blob`, `BufferSource`,
 * `FormData`, `URLSearchParams`, or `USVString` object. Note that a request using the `GET` or `HEAD` method cannot have a body.
 * @property {Boolean} [addQueryParamsToBody=false] Indicates whether `queryParams` should be passed in the request
 * body. Adding them to the body applies for `application/x-www-form-urlencoded` and `multipart/form-data`
 * content types only, so make sure to pass corresponding `Content-Type` header to `headers`.
 *
 * When the argument is `true` and:
 * - if `application/x-www-form-urlencoded` content-type header is passed
 *   the method will make a `URLSearchParams` instance with `queryParams` and set it as the request body.
 *   And if `body` already has a `URLSearchParams` instance provided the parameters will be set there.
 * - if `multipart/form-data` content-type header is passed
 *   the method will make a `FormData` instance with `queryParams` and set it as the request body.
 *   And if `body` already has a `FormData` instance provided the parameters will be set there.
 *
 * Otherwise, `queryParams` are added to the query string.
 * @property {'cors'|'no-cors'|'same-origin'} [mode] The mode you want to use for the request, e.g., `'cors'`, `'no-cors'`, or `'same-origin'`.
 * @property {'omit'|'same-origin'|'include'} [credentials] The request credentials you want to use for the request: `'omit'`, `'same-origin'`, or
 * `'include'`. To automatically send cookies for the current domain, this option must be provided
 * @property {Boolean} [parseJson] Specify `true` to parses the response and attach the resulting object to the
 * `Response` object as `parsedJson`
 */
const paramValueRegExp = /^(\w+)=(.*)$/,
  parseParams = function (paramString) {
    const result = {},
      params = paramString.split('&');
    // loop through each 'filter={"field":"name","operator":"=","value":"Sweden","caseSensitive":true}' string
    // So we cannot use .split('=')
    for (const nameValuePair of params) {
      const [match, name, value] = paramValueRegExp.exec(nameValuePair),
        decodedName = decodeURIComponent(name),
        decodedValue = decodeURIComponent(value);
      if (match) {
        let paramValue = result[decodedName];
        if (paramValue) {
          if (!Array.isArray(paramValue)) {
            paramValue = result[decodedName] = [paramValue];
          }
          paramValue.push(decodedValue);
        } else {
          result[decodedName] = decodedValue;
        }
      }
    }
    return result;
  };
/**
 * Simplifies Ajax requests. Uses fetch & promises.
 *
 * ```javascript
 * AjaxHelper.get('some-url').then(response => {
 *     // process request response here
 * });
 * ```
 *
 * Uploading file to server via FormData interface.
 * Please visit [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) for details.
 *
 * ```javascript
 * const formData = new FormData();
 * formData.append('file', 'fileNameToUpload');
 * AjaxHelper.post('file-upload-url', formData).then(response => {
 *     // process request response here
 * });
 * ```
 *
 */
class AjaxHelper {
  /**
   * Sets default options for {@link #function-fetch-static AjaxHelper#fetch()} calls. Please see
   * {@link #typedef-FetchOptions} and
   * [fetch API](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch) for details.
   *
   * ```javascript
   * // default content-type for all requests will be "application/json"
   * AjaxHelper.DEFAULT_FETCH_OPTIONS = {
   *     headers : {
   *         'content-type' : 'application/json'
   *     }
   * };
   * ```
   * @member {FetchOptions} DEFAULT_FETCH_OPTIONS
   * @static
   */
  static DEFAULT_FETCH_OPTIONS = {};
  /**
   * Make a request (using GET) to the specified url.
   * @param {String} url URL to `GET` from
   * @param {FetchOptions} [options] The options for the `fetch` API
   * @returns {Promise} The fetch Promise, which can be aborted by calling a special `abort` method
   * @async
   */
  static get(url, options) {
    return this.fetch(url, options);
  }
  /**
   * POST data to the specified URL.
   * @param {String} url URL to `POST` to
   * @param {String|Object|FormData} payload The data to post. If an object is supplied, it will be stringified
   * @param {FetchOptions} [options] The options for the `fetch` API
   * @returns {Promise} The fetch Promise, which can be aborted by calling a special `abort` method
   * @async
   */
  static post(url, payload, options = {}) {
    if (!(payload instanceof FormData) && !(typeof payload === 'string')) {
      payload = JSON.stringify(payload);
      options.headers = options.headers || {};
      options.headers['Content-Type'] = options.headers['Content-Type'] || 'application/json';
    }
    return this.fetch(url, Object.assign({
      method: 'POST',
      body: payload
    }, options));
  }
  /**
   * Fetch the specified resource using the `fetch` API.
   * @param {String} url URL to fetch from
   * @param {FetchOptions} [options] The options for the `fetch` API
   * @returns {Promise} The fetch Promise, which can be aborted by calling a special `abort` method
   * @async
   */
  static fetch(url, options) {
    let controller;
    // inherit global options
    options = Objects.merge({}, AjaxHelper.DEFAULT_FETCH_OPTIONS, options);
    // AbortController is not supported by LockerService
    // https://github.com/bryntum/support/issues/3689
    if (typeof AbortController !== 'undefined') {
      controller = options.abortController = new AbortController();
      options.signal = controller.signal;
    }
    if (!('credentials' in options)) {
      options.credentials = 'include';
    }
    if (options.queryParams) {
      const params = Object.entries(options.queryParams);
      if (params.length) {
        let paramsAdded = false;
        // for some content types we are going to add parameters to body (if that's not disabled)
        if (options.headers && options.addQueryParamsToBody === true) {
          const contentType = new Headers(options.headers).get('Content-Type');
          let bodyClass;
          switch (contentType) {
            case 'application/x-www-form-urlencoded':
              bodyClass = URLSearchParams;
              break;
            case 'multipart/form-data':
              bodyClass = FormData;
              break;
          }
          // if that's one of supported content types
          if (bodyClass) {
            const body = options.body || (options.body = new bodyClass());
            // put parameters to body if it's of supported type
            if (body instanceof bodyClass) {
              params.forEach(([key, value]) => body.set(key, value));
              // remember parameters are already added
              paramsAdded = true;
            }
          }
        }
        // if parameters are not added yet append them to the query string
        if (!paramsAdded) {
          url += (url.includes('?') ? '&' : '?') + params.map(([param, value]) => `${param}=${encodeURIComponent(value)}`).join('&');
        }
      }
    }
    // Promise that will be resolved either when network request is finished or when json is parsed
    const promise = new Promise((resolve, reject) => {
      fetch(url, options).then(response => {
        if (options.parseJson) {
          response.json().then(json => {
            response.parsedJson = json;
            resolve(response);
          }).catch(error => {
            response.parsedJson = null;
            response.error = error;
            reject(response);
          });
        } else {
          resolve(response);
        }
      }).catch(error => {
        error.stack = promise.stack;
        reject(error);
      });
    });
    promise.stack = new Error().stack;
    promise.abort = function () {
      var _controller;
      (_controller = controller) === null || _controller === void 0 ? void 0 : _controller.abort();
    };
    return promise;
  }
  /**
   * Registers the passed URL to return the passed mocked up Fetch Response object to the
   * AjaxHelper's promise resolve function.
   * @param {String} url The url to return mock data for
   * @param {Object|Function} response A mocked up Fetch Response object which must contain
   * at least a `responseText` property, or a function to which the `url` and a `params` object
   * and the `Fetch` `options` object is passed which returns that.
   * @param {String} response.responseText The data to return.
   * @param {Boolean} [response.synchronous] resolve the Promise immediately
   * @param {Number} [response.delay=100] resolve the Promise after this number of milliseconds.
   */
  static mockUrl(url, response) {
    const me = this;
    (me.mockAjaxMap || (me.mockAjaxMap = {}))[url] = response;
    // Inject the override into the AjaxHelper instance
    if (!AjaxHelper.originalFetch) {
      AjaxHelper.originalFetch = AjaxHelper.fetch;
      AjaxHelper.fetch = me.mockAjaxFetch.bind(me);
    }
  }
  static async mockAjaxFetch(url, options) {
    const urlAndParams = url.split('?');
    let result = this.mockAjaxMap[urlAndParams[0]],
      parsedJson = null;
    if (result) {
      if (typeof result === 'function') {
        result = await result(urlAndParams[0], urlAndParams[1] && parseParams(urlAndParams[1]), options);
      }
      try {
        parsedJson = (options === null || options === void 0 ? void 0 : options.parseJson) && JSON.parse(result.responseText);
      } catch (error) {
        parsedJson = null;
        result.error = error;
      }
      result = Object.assign({
        status: 200,
        ok: true,
        headers: new Headers(),
        statusText: 'OK',
        url,
        parsedJson,
        text: () => new Promise(resolve => {
          resolve(result.responseText);
        }),
        json: () => new Promise(resolve => {
          resolve(parsedJson);
        })
      }, result);
      return new Promise(function (resolve, reject) {
        if (result.synchronous) {
          resolve(result);
        } else {
          setTimeout(function () {
            resolve(result);
          }, 'delay' in result ? result.delay : 100);
        }
      });
    } else {
      return AjaxHelper.originalFetch(url, options);
    }
  }
}
AjaxHelper._$name = 'AjaxHelper';

/**
 * @module Core/localization/LocaleHelper
 */
/**
 * @typedef {Object} LocaleKeys
 * Object which contains `key: value` localization pairs.
 * Key value may have `String`, `Function`, `LocaleKeys` or `Object` type.
 *
 * Example:
 *
 * ```javascript
 * {
 *     title   : 'Title',
 *     count   : number => `Count is ${number}`,
 *     MyClass : {
 *        foo : 'bar'
 *     }
 * }
 * ```
 *
 * @property {String|Function|LocaleKeys|Object} key localization key
 * @typings {[key: string]}:{string|number|Function|LocaleKeys|object}
 */
/**
 * @typedef {LocaleKeys} Locale
 * Locale configuration object which contains locale properties alongside with localization pairs.
 *
 * Example:
 *
 * ```javascript
 {
 *     localeName : 'En',
 *     localeDesc : 'English (US)',
 *     localeCode : 'en-US',
 *     ... (localization key:value pairs)
 * }
 * ```
 *
 * @property {String} localeName Locale name. For example: "En"
 * @property {String} localeDesc Locale description to be shown in locale picker list. For example: "English (US)"
 * @property {String} localeCode Locale code. Two letter locale code or two letter locale and two letter country code.
 * For example: "en" or 'en_US'
 * @property {String} [localePath] Locale path for asynchronous loading using
 * AjaxHelper {@link Core.helper.AjaxHelper#function-get-static} request
 */
/**
 * @typedef {Object} Locales
 * Object which contains locales. Each object key represents published locale by its `localeName`.
 *
 * Example:
 *
 * ```javascript
 * // This returns English locale.
 * const englishLocale = LocaleHelper.locales.En;
 * ```
 *
 * @property {Locale} key localization object
 * @typings {[key: string]}:{Locale}
 */
/**
 * Thin class which provides locale management methods.
 * Class doesn't import other API classes and can be used separately for publishing locales before importing product classes.
 *
 * Locale should be published with {@link ##function-publishLocale-static} method before it is available for localizing of Bryntum API classes and widgets.
 *
 * Example:
 *
 * ```javascript
 * LocaleHelper.publishLocale({
 *     localeName : 'En',
 *     localeDesc : 'English (US)',
 *     localeCode : 'en-US',
 *     ... (localization key:value pairs)
 * });
 * ```
 *
 * or for asynchronous loading from remote path on applying locale
 *
 * ```javascript
 *LocaleHelper.publishLocale({
 *     localeName : 'En',
 *     localeDesc : 'English (US)',
 *     localeCode : 'en-US',
 *     localePath : 'https://my-server/localization/en.js'
 * });
 * ```
 */
class LocaleHelper {
  static skipLocaleIntegrityCheck = false;
  /**
   * Merges all properties of provided locale objects into new locale object.
   * Locales are merged in order they provided and locales which go later replace
   * same properties of previous locales.
   * @param {...Object} locales Locales to merge
   * @returns {Object} Merged locale
   */
  static mergeLocales(...locales) {
    const result = {};
    locales.forEach(locale => {
      Object.keys(locale).forEach(key => {
        if (typeof locale[key] === 'object') {
          result[key] = {
            ...result[key],
            ...locale[key]
          };
        } else {
          result[key] = locale[key];
        }
      });
    });
    return result;
  }
  /**
   * Removes all properties from `locale` that are present in the provided `toTrim`.
   * @param {Object} locale Locale to process
   * @param {Object} toTrim Object enumerating properties that should be removed.
   * When `false` throws exceptions in such cases.
   */
  static trimLocale(locale, toTrim) {
    const remove = (key, subKey) => {
      if (locale[key]) {
        if (subKey) {
          if (locale[key][subKey]) {
            delete locale[key][subKey];
          }
        } else {
          delete locale[key];
        }
      }
    };
    Object.keys(toTrim).forEach(key => {
      if (Object.keys(toTrim[key]).length > 0) {
        Object.keys(toTrim[key]).forEach(subKey => remove(key, subKey));
      } else {
        remove(key);
      }
    });
  }
  /**
   * Normalizes locale object to {@link Locale} type.
   *
   * Supported configs:
   *
   * ```javascript
   * LocaleHelper.normalizeLocale({
   *     localeName : 'En',
   *     localeDesc : 'English (US)',
   *     localeCode : 'en-US',
   *     ... (localization key:value pairs)
   * });
   * ```
   *
   * and for backward compatibility
   *
   * ```javascript
   * LocaleHelper.normalizeLocale('En', {
   *     name : 'En',
   *     desc : 'English (US)',
   *     code : 'en-US',
   *     locale : {
   *         ... (localization key:value pairs)
   *     }
   * });
   * ```
   * @param {String|Object} nameOrConfig String name of locale or locale object
   * @param {Object} [config] Locale object
   * @returns {Locale} Locale object
   * @internal
   */
  static normalizeLocale(nameOrConfig, config) {
    if (!nameOrConfig) {
      throw new Error(`"nameOrConfig" parameter can not be empty`);
    }
    if (typeof nameOrConfig === 'string') {
      if (!config) {
        throw new Error(`"config" parameter can not be empty`);
      }
      if (config.locale) {
        // Matches legacy locale type
        config.name = nameOrConfig || config.name;
      } else {
        config.localeName = nameOrConfig;
      }
    } else {
      config = nameOrConfig;
    }
    let locale = {};
    if (config.name || config.locale) {
      // Matches legacy locale type
      locale = Object.assign({
        localeName: config.name
      }, config.locale);
      config.desc && (locale.localeDesc = config.desc);
      config.code && (locale.localeCode = config.code);
      config.path && (locale.localePath = config.path);
    } else {
      if (!config.localeName) {
        throw new Error(`"config" parameter doesn't have "localeName" property`);
      }
      // Extract locale config from name object
      locale = Object.assign({}, config);
    }
    // Cleanup result
    for (const key of ['name', 'desc', 'code', 'path']) {
      if (locale[key]) {
        delete locale[key];
      }
    }
    if (!locale.localeName) {
      throw new Error(`Locale name can not be empty`);
    }
    return locale;
  }
  /**
   * Get/set currently published locales.
   * Returns an object with locales.
   *
   * Example:
   *
   * ```javascript
   * const englishLocale = LocaleHelper.locales.En;
   * ```
   *
   * `englishLocale` contains {@link Locale} object.
   *
   * @readonly
   * @member {Locales} locales
   * @static
   */
  static get locales() {
    return globalThis.bryntum.locales || {};
  }
  static set locales(locales) {
    globalThis.bryntum.locales = locales;
  }
  /**
   * Get/set current locale name. Defaults to "En"
   * @member {String} localeName
   * @static
   */
  static get localeName() {
    return globalThis.bryntum.locale || 'En';
  }
  static set localeName(localeName) {
    globalThis.bryntum.locale = localeName || LocaleHelper.localeName;
  }
  /**
   * Get current locale config specified by {@link ##property-localeName-static}.
   * If no current locale specified, returns default `En` locale or first published locale
   * or empty locale object if no published locales found.
   * @readonly
   * @member {Locales} locale
   * @static
   */
  static get locale() {
    return LocaleHelper.localeName && this.locales[LocaleHelper.localeName] || this.locales.En || Object.values(this.locales)[0] || {
      localeName: '',
      localeDesc: '',
      localeCoode: ''
    };
  }
  /**
   * Publishes a locale to make it available for applying.
   * Published locales are available in {@link ##property-locales-static}.
   *
   * Recommended usage:
   *
   * ```javascript
   * LocaleHelper.publishLocale({
   *     localeName : 'En',
   *     localeDesc : 'English (US)',
   *     localeCode : 'en-US',
   *     ... (localization key:value pairs)
   * });
   * ```
   *
   * for backward compatibility (prior to `5.3.0` version):
   *
   * ```javascript
   * LocaleHelper.publishLocale('En', {
   *     name : 'En',
   *     desc : 'English (US)',
   *     code : 'en-US',
   *     locale : {
   *         ... (localization key:value pairs)
   *     }
   * });
   * ```
   *
   * Publishing a locale will automatically merge it's localization keys with existing locale matching by locale name,
   * replacing existing one with new. To replace existing locale entirely pass `true` to optional `config` parameter.
   *
   * Example:
   *
   * ```javascript
   * LocaleHelper.publishLocale({
   *     localeName : 'En',
   *     localeDesc : 'English (US)',
   *     localeCode : 'en-US',
   *     ... (localization key:value pairs)
   * }, true);
   * ```
   *
   * @param {String|Locale} nameOrConfig String name of locale (for example `En` or `SvSE`) or locale object
   * @param {Locale|Boolean} [config] Locale object.
   * Not used if locale object is passed as first method parameter.
   * Path `true` value and locale object as first method parameter to publish locale without merging with existing one.
   * @returns {Locale} Locale object
   */
  static publishLocale(nameOrConfig, config) {
    const {
        locales
      } = globalThis.bryntum,
      locale = LocaleHelper.normalizeLocale(nameOrConfig, config),
      {
        localeName
      } = locale;
    if (!locales[localeName] || config === true) {
      locales[localeName] = locale;
    } else {
      locales[localeName] = this.mergeLocales(locales[localeName] || {}, locale || {});
    }
    return locales[localeName];
  }
}
globalThis.bryntum = globalThis.bryntum || {};
globalThis.bryntum.locales = globalThis.bryntum.locales || {};
LocaleHelper._$name = 'LocaleHelper';

/**
 * @module Core/localization/LocaleManager
 */
// Documented at the export below, to work for singleton
class LocaleManager extends Events(Base) {
  static get defaultConfig() {
    return {
      // Enable strict locale checking by default for tests
      throwOnMissingLocale: VersionHelper.isTestEnv
    };
  }
  construct(...args) {
    const me = this;
    super.construct(...args);
    if (BrowserHelper.isBrowserEnv) {
      var _me$locale;
      // Try get locale name from script's `default-locale` tag
      const scriptTag = document.querySelector('script[data-default-locale]');
      if (scriptTag) {
        me.applyLocale(scriptTag.dataset.defaultLocale);
      } else if ((_me$locale = me.locale) !== null && _me$locale !== void 0 && _me$locale.localeName) {
        me.applyLocale(me.locale.localeName);
      }
    }
  }
  /**
   * Get/set currently registered locales.
   * Alias for {@link Core.localization.LocaleHelper#property-locales-static LocaleHelper.locales}.
   * @readonly
   * @member {Locales} locales
   */
  get locales() {
    return LocaleHelper.locales;
  }
  set locales(locales) {
    LocaleHelper.locales = locales;
  }
  /**
   * Get/set currently used locale.
   * Setter calls {@link #function-applyLocale}.
   * @member {Locales} locale
   * @accepts {String|Locale}
   */
  set locale(nameOrConfig) {
    this.applyLocale(nameOrConfig);
  }
  get locale() {
    return LocaleHelper.locale;
  }
  /**
   * Publishes a locale to make it available for applying.
   * @deprecated Since 5.3.0. Use {@link Core.localization.LocaleHelper#function-publishLocale-static LocaleHelper.publishLocale} instead.
   *
   * @param {String|Locale} nameOrConfig String name of locale (for example `En` or `SvSE`) or locale object.
   * @param {Locale} [config] Locale object. Not used if object is passed as first method parameter
   * @returns {Locale} published locale object is passed as first method parameter
   * @function registerLocale
   */
  registerLocale(nameOrConfig, config) {
    VersionHelper.deprecate('Core', '6.0.0', 'LocaleManager.registerLocale deprecated, use LocaleHelper.publishLocale instead');
    LocaleHelper.publishLocale(nameOrConfig, config);
  }
  /**
   * Extends locale specified by name to add additional translations and applies it.
   * @deprecated Since 5.3.0. Use {@link ##function-applyLocale} instead.
   *
   * @param {String} name Name of locale (for example `En` or `SvSE`).
   * @param {Locale} config Locale object
   * @returns {Locale|Promise} locale object or Promise which resolves with locale object after it was loaded
   * @function extendLocale
   */
  extendLocale(name, config) {
    VersionHelper.deprecate('Core', '6.0.0', 'LocaleManager.extendLocale deprecated, use LocaleManager.applyLocale instead');
    const locale = LocaleHelper.publishLocale(name, config);
    return this.applyLocale(locale, true);
  }
  /**
   * Applies a locale by string name or publishes new locale configuration with
   * {@link Core.localization.LocaleHelper#function-publishLocale-static} and applies it.
   * If locale is specified by string name, like 'En', it must be published before applying it.
   *
   * @param {String|Locale} nameOrConfig String name of locale (for example `En` or `SvSE`) or locale object
   * @param {Locale|Boolean} [config] Locale object. Pass `true` to reapply locale which is passed as first method parameter.
   * @returns {Locale|Promise} locale object or Promise which resolves with locale object after it was loaded
   * @fires locale
   * @async
   * @function applyLocale
   */
  applyLocale(nameOrConfig, config, ignoreError = false) {
    const me = this;
    let localeConfig;
    if (typeof nameOrConfig === 'string') {
      if (typeof config !== 'object') {
        localeConfig = me.locales[nameOrConfig];
        if (!localeConfig) {
          if (ignoreError) {
            return true;
          }
          throw new Error(`Locale "${nameOrConfig}" is not published. Publish with LocaleHelper.publishLocale() before applying.`);
        }
      } else {
        localeConfig = LocaleHelper.publishLocale(nameOrConfig, config);
      }
    } else {
      localeConfig = LocaleHelper.publishLocale(nameOrConfig);
    }
    if (me.locale.localeName && me.locale.localeName === localeConfig.localeName && config !== true) {
      // no need to apply same locale again
      return me.locale;
    }
    // Set current locale name
    LocaleHelper.localeName = localeConfig.localeName;
    const triggerLocaleEvent = () => {
      /**
       * Fires when a locale is applied
       * @event locale
       * @param {Core.localization.LocaleManager} source The Locale manager instance.
       * @param {Locale} locale Locale configuration
       */
      me.trigger('locale', localeConfig);
    };
    if (localeConfig.localePath) {
      return new Promise((resolve, reject) => {
        me.loadLocale(localeConfig.localePath).then(response => {
          response.text().then(text => {
            const parseLocale = new Function(text);
            parseLocale();
            if (BrowserHelper.isBrowserEnv) {
              localeConfig = me.locales[localeConfig.localeName];
              // Avoid loading next time
              if (localeConfig) {
                delete localeConfig.localePath;
              }
            }
            triggerLocaleEvent();
            resolve(localeConfig);
          });
        }).catch(response => reject(response));
      });
    }
    triggerLocaleEvent();
    return localeConfig;
  }
  /**
   * Loads a locale using AjaxHelper {@link Core.helper.AjaxHelper#function-get-static} request.
   * @private
   * @param {String} path Path to locale file
   * @async
   */
  loadLocale(path) {
    return AjaxHelper.get(path);
  }
  /**
   * Specifies if {@link Core.localization.Localizable#function-L-static Localizable.L()} function would throw error if no localization found at runtime.
   *
   * @member {Boolean} throwOnMissingLocale
   * @default false
   */
  set throwOnMissingLocale(value) {
    this._throwOnMissingLocale = value;
  }
  get throwOnMissingLocale() {
    return this._throwOnMissingLocale;
  }
}
const LocaleManagerSingleton = new LocaleManager();

/**
 * @module Core/localization/Localizable
 */
const ObjectProto = Object.getPrototypeOf(Object),
  localeRe = /L{.*?}/g,
  capturelocaleRe = /L{(.*?)}/g,
  classMatchRe = /((.*?)\.)?(.+)/g,
  escape$1 = txt => txt.replace(/{(\d+)}/gm, '[[$1]]'),
  unescape = txt => txt.replace(/\[\[(\d+)]]/gm, '{$1}'),
  emptyObject$6 = Object.freeze(Object.create(null));
/**
 * Mixin that provides localization functionality to a class.
 *
 * ```javascript
 * // Get localized string
 * grid.L('foo');
 * grid.L('L{foo}');
 * ```
 *
 * @mixin
 */
var Localizable = (Target => class Localizable extends (Target || Base) {
  static get $name() {
    return 'Localizable';
  }
  static get configurable() {
    return {
      /**
       * A class translations of which are used for translating this entity.
       * This is often used when translations of an item are defined on its container class.
       * For example:
       *
       * ```js
       * // Toolbar class that has some predefined items
       * class MyToolbar extends Toolbar {
       *
       *     static get $name() {
       *         return 'MyToolbar';
       *     }
       *
       *     static get defaultConfig() {
       *         return {
       *             // this specifies default configs for the items
       *             defaults : {
       *                 // will tell items to use the toolbar locale
       *                 localeClass : this
       *             },
       *
       *             items : [
       *                 // The toolbar has 2 buttons and translation for their texts will be searched in
       *                 // the toolbar locales
       *                 { text : 'Agree' },
       *                 { text : 'Disagree' }
       *             ]
       *         };
       *     }
       *
       *    ...
       * }
       * ```
       * So if one makes a locale for the `MyToolbar` class that will include `Agree` and `Disagree` string translations:
       * ```js
       *     ...
       *     MyToolbar : {
       *         Agree    : 'Yes, I agree',
       *         Disagree : 'No, I do not agree'
       *     }
       * ```
       * They will be used for the toolbar buttons and the button captions will say `Yes, I agree` and `No, I do not agree`.
       *
       * @config {Core.Base}
       * @typings {typeof Base}
       * @category Misc
       * @advanced
       */
      localeClass: null,
      /**
       * Set to `false` to disable localization of this object.
       * @config {Boolean}
       * @default true
       * @category Misc
       * @advanced
       */
      localizable: null,
      /**
       * List of properties which values should be translated automatically upon a locale applying.
       * In case there is a need to localize not typical value (not a String value or a field with re-defined setter/getter),
       * you could use 'localeKey' meta configuration.
       * Example:
       * ```js
       *  static get configurable() {
       *     return {
       *          localizableProperties : ['width'],
       *
       *          width : {
       *              value   : '54em', // default value here
       *              $config : {
       *                  localeKey : 'L{editorWidth}' // name of the property that will be used in localization file
       *              }
       *          }
       *      };
       *  }
       * ```
       * @config {String[]}
       * @category Misc
       * @advanced
       */
      localizableProperties: {
        value: [],
        $config: {
          merge: 'distinct'
        }
      }
    };
  }
  static clsName(cls) {
    var _cls$prototype, _cls$prototype2;
    return typeof cls === 'string' ? cls : cls === ObjectProto ? 'Object' : cls.$$name || cls.name || ((_cls$prototype = cls.prototype) === null || _cls$prototype === void 0 ? void 0 : _cls$prototype.$$name) || ((_cls$prototype2 = cls.prototype) === null || _cls$prototype2 === void 0 ? void 0 : _cls$prototype2.name);
  }
  static parseLocaleString(text) {
    var _text;
    const matches = [];
    let m;
    // Parse locale text in case it's wrapped with L{foo}
    if ((_text = text) !== null && _text !== void 0 && _text.includes('L{')) {
      // Escape fix for {1}, {2} etc. in locale str
      text = escape$1(text);
      capturelocaleRe.lastIndex = 0;
      while ((m = capturelocaleRe.exec(text)) != null) {
        classMatchRe.lastIndex = 0;
        // Support for parsing class namespace L{Class.foo}
        const classMatch = classMatchRe.exec(m[1]);
        matches.push({
          match: unescape(m[0]),
          localeKey: unescape(classMatch[3]),
          localeClass: classMatch[2]
        });
      }
    }
    return matches.length > 0 ? matches : [{
      match: text,
      localeKey: text,
      localeClass: undefined
    }];
  }
  construct(config = {}, ...args) {
    // Base class applies configs.
    super.construct(config, ...args);
    LocaleManagerSingleton.ion({
      locale: 'updateLocalization',
      thisObj: this
    });
    this.updateLocalization();
  }
  get localeClass() {
    return this._localeClass || null;
  }
  localizeProperty(property) {
    var _me$$meta$configs$pro, _me$fieldMap, _me$fieldMap$property;
    const me = this,
      currentValue = Objects.getPath(me, property),
      // Grid.column.Column is Localizable too. It uses fields, not configs
      localeKey = ((_me$$meta$configs$pro = me.$meta.configs[property]) === null || _me$$meta$configs$pro === void 0 ? void 0 : _me$$meta$configs$pro.localeKey) || ((_me$fieldMap = me.fieldMap) === null || _me$fieldMap === void 0 ? void 0 : (_me$fieldMap$property = _me$fieldMap[property]) === null || _me$fieldMap$property === void 0 ? void 0 : _me$fieldMap$property.defaultValue);
    let localizedValue;
    // check if localeKey is defined and try to translate it
    if (localeKey) {
      localizedValue = Localizable.localize(localeKey, me, me.localeClass || me);
      // if a user set value directly in class definition, his value has a prio
      if (localizedValue && !(property in (me.initialConfig || emptyObject$6))) {
        Objects.setPath(me.isColumn ? me.data : me, property, localizedValue);
      }
    } else if (typeof currentValue === 'string') {
      me.originalLocales = me.originalLocales || {};
      localizedValue = Objects.getPath(me.originalLocales, property);
      // If we haven't saved original values yet let's do that
      if (localizedValue === undefined) {
        Objects.setPath(me.originalLocales, property, currentValue);
        localizedValue = currentValue;
      }
      // Doing localization from the original values
      if (localizedValue) {
        Objects.setPath(me, property, localizedValue = me.optionalL(localizedValue, me));
      }
    }
    return localizedValue || currentValue;
  }
  /**
   * Method that is triggered when applying a locale to the instance
   * (happens on the instance construction steps and when switching to another locale).
   *
   * The method can be overridden to dynamically translate the instance when locale is switched.
   * When overriding the method please make sure you call `super.updateLocalization()`.
   * @category Misc
   * @advanced
   */
  updateLocalization() {
    if (this.localizable !== false) {
      var _this$localizableProp, _this$trigger;
      (_this$localizableProp = this.localizableProperties) === null || _this$localizableProp === void 0 ? void 0 : _this$localizableProp.forEach(this.localizeProperty, this);
      (_this$trigger = this.trigger) === null || _this$trigger === void 0 ? void 0 : _this$trigger.call(this, 'localized');
    }
  }
  static getTranslation(text, templateData, localeCls) {
    const locale = LocaleManagerSingleton.locale;
    let result = null,
      clsName,
      cls;
    if (locale) {
      // Iterate over all found localization entries
      for (const {
        match,
        localeKey,
        localeClass
      } of this.parseLocaleString(text)) {
        const translate = clsName => {
          var _locale$clsName;
          const translation = (_locale$clsName = locale[clsName]) === null || _locale$clsName === void 0 ? void 0 : _locale$clsName[localeKey];
          if (translation) {
            if (typeof translation === 'function') {
              result = templateData != null ? translation(templateData) : translation;
            } else if (typeof translation === 'object' || text === match) {
              result = translation;
            }
            // Likely string
            else {
              result = (result || text).replace(match, translation);
            }
            // Might have nested L{, recurse
            if (typeof translation === 'string' && translation.includes('L{')) {
              result = this.getTranslation(translation, templateData, localeCls);
            }
          }
          return translation;
        };
        // Translate order
        // 1. Try to translate for current class
        // 2. Try to translate by Class hierarchy traversing prototypes
        // 3. Try to translate if Class is in {Class.foo} format
        let success = false;
        for (cls = localeCls; cls && (clsName = Localizable.clsName(cls)); cls = Object.getPrototypeOf(cls)) {
          if (success = translate(clsName)) {
            break;
          } else if (typeof cls === 'string') {
            break;
          }
        }
        if (!success && localeClass) {
          translate(localeClass);
        }
      }
    }
    return result;
  }
  /**
   * Get localized string, returns `null` if no localized string found.
   * @param {String} text String key
   * @param {Object} [templateData] Data to supply to template if localized string is a function
   * @returns {String}
   * @internal
   */
  static localize(text, templateData = undefined, ...localeClasses) {
    var _localeClasses;
    // In case this static method is called directly third argument is not provided
    // just fallback to searching locales for the class itself
    if (((_localeClasses = localeClasses) === null || _localeClasses === void 0 ? void 0 : _localeClasses.length) === 0) {
      localeClasses = [this];
    }
    let translation = null;
    localeClasses.some(cls => {
      translation = Localizable.getTranslation(text, templateData, cls);
      return translation != null;
    });
    return translation;
  }
  /**
   * Get localized string, returns value of `text` if no localized string found.
   *
   * If {@link Core.localization.LocaleManager#property-throwOnMissingLocale LocaleManager.throwOnMissingLocale}
   * is `true` then calls to `L()` will throw `Localization is not found for 'text' in 'ClassName'` exception when no
   * localization is found.
   *
   * @param {String} text String key
   * @param {Object} [templateData] Data to supply to template if localized string is a function
   * @static
   * @returns {String}
   * @advanced
   */
  static L(text, templateData = undefined, ...localeClasses) {
    var _localeClasses2;
    // In case this static method is called directly third argument is not provided
    // just fallback to searching locales for the class itself
    if (((_localeClasses2 = localeClasses) === null || _localeClasses2 === void 0 ? void 0 : _localeClasses2.length) === 0) {
      localeClasses = [this];
    }
    const translation = this.localize(text, templateData, ...localeClasses);
    // Throw error if not localized and text matches `L{foo}`
    if (translation == null && LocaleManagerSingleton.throwOnMissingLocale && text.includes('L{')) {
      throw new Error(`Localization is not found for '${text}' in '${localeClasses.map(cls => Localizable.clsName(cls)).join(', ')}'. ${LocaleManagerSingleton.locale.localeName ? `Locale : ${LocaleManagerSingleton.locale.localeName}` : ''}`);
    }
    return translation ?? text;
  }
  /**
   * Convenience function that can be called directly on the class that mixes Localizable in
   *
   * ```javascript
   * button.text = grid.L('L{group}');
   * ```
   *
   * @param {String} text String key
   * @param {Object} [templateData] Data to supply to template if localized string is a function
   * @returns {String}
   * @category Misc
   * @advanced
   */
  L(text, templateData) {
    const {
      localeClass,
      constructor
    } = this;
    // If we have a different class set as translations provider
    // pass it first and use the class being translated as a fallback provider
    if (localeClass && Localizable.clsName(localeClass) !== Localizable.clsName(constructor)) {
      return Localizable.L(text, templateData, localeClass, constructor);
    } else {
      return Localizable.L(text, templateData, constructor);
    }
  }
  /**
   * Convenience function to get an optional translation. The difference compared to `L()` is that it won't throw
   * an error when the translation is missing even if configured with `throwOnMissingLocale`
   *
   * ```javascript
   * button.text = grid.optionalL('L{group}');
   * ```
   *
   * @param {String} text String key
   * @param {Object} [templateData] Data to supply to template if localized string is a function
   * @returns {String}
   * @static
   * @category Misc
   * @advanced
   */
  static optionalL(text, templateData = undefined, ...localeClasses) {
    var _localeClasses3;
    const shouldThrow = LocaleManagerSingleton.throwOnMissingLocale;
    LocaleManagerSingleton.throwOnMissingLocale = shouldThrow && localeRe.test(text);
    // In case this static method is called directly third argument is not provided
    // just fallback to searching locales for the class itself
    if (((_localeClasses3 = localeClasses) === null || _localeClasses3 === void 0 ? void 0 : _localeClasses3.length) === 0) {
      localeClasses = [this];
    }
    const result = Localizable.L(text, templateData, ...localeClasses);
    LocaleManagerSingleton.throwOnMissingLocale = shouldThrow;
    return result;
  }
  /**
   * Convenience function to get an optional translation. The difference compared to `L()` is that it won't throw
   * an error when the translation is missing even if configured with `throwOnMissingLocale`
   *
   * ```javascript
   * button.text = grid.optionalL('L{group}');
   * ```
   *
   * @param {String} text String key
   * @param {Object} [templateData] Data to supply to template if localized string is a function
   * @param {Boolean} [preventThrow] Prevent throwing error even if localized text matches `L{foo}`
   * @returns {String}
   * @category Misc
   * @internal
   */
  optionalL(text, templateData = this, preventThrow = false) {
    const shouldThrow = LocaleManagerSingleton.throwOnMissingLocale;
    // Optional locale text should not include L{}
    LocaleManagerSingleton.throwOnMissingLocale = shouldThrow && localeRe.test(text) && !preventThrow;
    const result = this.L(text, templateData);
    LocaleManagerSingleton.throwOnMissingLocale = shouldThrow;
    return result;
  }
  /**
   * Get the global LocaleManager
   * @property {Core.localization.LocaleManager}
   * @typings {typeof LocaleManager}
   * @category Misc
   * @readonly
   * @advanced
   */
  get localeManager() {
    return LocaleManagerSingleton;
  }
  /**
   * Get the global LocaleHelper
   * @property {Core.localization.LocaleHelper}
   * @typings {typeof LocaleHelper}
   * @category Misc
   * @readonly
   * @advanced
   */
  get localeHelper() {
    return LocaleHelper;
  }
});

const locale$1 = {
  localeName: 'En',
  localeDesc: 'English (US)',
  localeCode: 'en-US',
  Object: {
    Yes: 'Yes',
    No: 'No',
    Cancel: 'Cancel',
    Ok: 'OK',
    Week: 'Week'
  },
  ColorPicker: {
    noColor: 'No color'
  },
  Combo: {
    noResults: 'No results',
    recordNotCommitted: 'Record could not be added',
    addNewValue: value => `Add ${value}`
  },
  FilePicker: {
    file: 'File'
  },
  Field: {
    badInput: 'Invalid field value',
    patternMismatch: 'Value should match a specific pattern',
    rangeOverflow: value => `Value must be less than or equal to ${value.max}`,
    rangeUnderflow: value => `Value must be greater than or equal to ${value.min}`,
    stepMismatch: 'Value should fit the step',
    tooLong: 'Value should be shorter',
    tooShort: 'Value should be longer',
    typeMismatch: 'Value is required to be in a special format',
    valueMissing: 'This field is required',
    invalidValue: 'Invalid field value',
    minimumValueViolation: 'Minimum value violation',
    maximumValueViolation: 'Maximum value violation',
    fieldRequired: 'This field is required',
    validateFilter: 'Value must be selected from the list'
  },
  DateField: {
    invalidDate: 'Invalid date input'
  },
  DatePicker: {
    gotoPrevYear: 'Go to previous year',
    gotoPrevMonth: 'Go to previous month',
    gotoNextMonth: 'Go to next month',
    gotoNextYear: 'Go to next year'
  },
  NumberFormat: {
    locale: 'en-US',
    currency: 'USD'
  },
  DurationField: {
    invalidUnit: 'Invalid unit'
  },
  TimeField: {
    invalidTime: 'Invalid time input'
  },
  TimePicker: {
    hour: 'Hour',
    minute: 'Minute',
    second: 'Second'
  },
  List: {
    loading: 'Loading...',
    selectAll: 'Select All'
  },
  GridBase: {
    loadMask: 'Loading...',
    syncMask: 'Saving changes, please wait...'
  },
  PagingToolbar: {
    firstPage: 'Go to first page',
    prevPage: 'Go to previous page',
    page: 'Page',
    nextPage: 'Go to next page',
    lastPage: 'Go to last page',
    reload: 'Reload current page',
    noRecords: 'No records to display',
    pageCountTemplate: data => `of ${data.lastPage}`,
    summaryTemplate: data => `Displaying records ${data.start} - ${data.end} of ${data.allCount}`
  },
  PanelCollapser: {
    Collapse: 'Collapse',
    Expand: 'Expand'
  },
  Popup: {
    close: 'Close'
  },
  UndoRedo: {
    Undo: 'Undo',
    Redo: 'Redo',
    UndoLastAction: 'Undo last action',
    RedoLastAction: 'Redo last undone action',
    NoActions: 'No items in the undo queue'
  },
  FieldFilterPicker: {
    equals: 'equals',
    doesNotEqual: 'does not equal',
    isEmpty: 'empty',
    isNotEmpty: 'not empty',
    contains: 'contains',
    doesNotContain: 'does not contain',
    startsWith: 'starts with',
    endsWith: 'ends with',
    isOneOf: 'one of',
    isNotOneOf: 'not one of',
    isGreaterThan: 'greater than',
    isLessThan: 'less than',
    isGreaterThanOrEqualTo: 'greater than or equal to',
    isLessThanOrEqualTo: 'less than or equal to',
    isBetween: 'between',
    isNotBetween: 'not between',
    isBefore: 'before',
    isAfter: 'after',
    isToday: 'today',
    isTomorrow: 'tomorrow',
    isYesterday: 'yesterday',
    isThisWeek: 'this week',
    isNextWeek: 'next week',
    isLastWeek: 'last week',
    isThisMonth: 'this month',
    isNextMonth: 'next month',
    isLastMonth: 'last month',
    isThisYear: 'this year',
    isNextYear: 'next year',
    isLastYear: 'last year',
    isYearToDate: 'year to date',
    isTrue: 'true',
    isFalse: 'false',
    selectAProperty: 'Select a property',
    selectAnOperator: 'Select an operator',
    caseSensitive: 'Case-sensitive',
    and: 'and',
    dateFormat: 'D/M/YY',
    selectOneOrMoreValues: 'Select one or more values',
    enterAValue: 'Enter a value',
    enterANumber: 'Enter a number',
    selectADate: 'Select a date'
  },
  FieldFilterPickerGroup: {
    addFilter: 'Add filter'
  },
  DateHelper: {
    locale: 'en-US',
    weekStartDay: 0,
    nonWorkingDays: {
      0: true,
      6: true
    },
    weekends: {
      0: true,
      6: true
    },
    unitNames: [{
      single: 'millisecond',
      plural: 'ms',
      abbrev: 'ms'
    }, {
      single: 'second',
      plural: 'seconds',
      abbrev: 's'
    }, {
      single: 'minute',
      plural: 'minutes',
      abbrev: 'min'
    }, {
      single: 'hour',
      plural: 'hours',
      abbrev: 'h'
    }, {
      single: 'day',
      plural: 'days',
      abbrev: 'd'
    }, {
      single: 'week',
      plural: 'weeks',
      abbrev: 'w'
    }, {
      single: 'month',
      plural: 'months',
      abbrev: 'mon'
    }, {
      single: 'quarter',
      plural: 'quarters',
      abbrev: 'q'
    }, {
      single: 'year',
      plural: 'years',
      abbrev: 'yr'
    }, {
      single: 'decade',
      plural: 'decades',
      abbrev: 'dec'
    }],
    unitAbbreviations: [['mil'], ['s', 'sec'], ['m', 'min'], ['h', 'hr'], ['d'], ['w', 'wk'], ['mo', 'mon', 'mnt'], ['q', 'quar', 'qrt'], ['y', 'yr'], ['dec']],
    parsers: {
      L: 'MM/DD/YYYY',
      LT: 'HH:mm A',
      LTS: 'HH:mm:ss A'
    },
    ordinalSuffix: number => {
      const hasSpecialCase = ['11', '12', '13'].find(n => number.endsWith(n));
      let suffix = 'th';
      if (!hasSpecialCase) {
        const lastDigit = number[number.length - 1];
        suffix = {
          1: 'st',
          2: 'nd',
          3: 'rd'
        }[lastDigit] || 'th';
      }
      return number + suffix;
    }
  }
};
LocaleHelper.publishLocale(locale$1);

const {
    toString: toString$1
  } = Object.prototype,
  DATE_TYPE = toString$1.call(new Date()),
  tempDate = new Date(),
  MS_PER_HOUR = 1000 * 60 * 60,
  defaultValue = (value, defValue) => isNaN(value) || value == null ? defValue : value,
  rangeFormatPartRe = /([ES]){([^}]+)}/g,
  enOrdinalSuffix = number => {
    const hasSpecialCase = ['11', '12', '13'].find(n => number.endsWith(n));
    let suffix = 'th';
    if (!hasSpecialCase) {
      const lastDigit = number[number.length - 1];
      suffix = {
        1: 'st',
        2: 'nd',
        3: 'rd'
      }[lastDigit] || 'th';
    }
    return number + suffix;
  },
  useIntlFormat = (name, options, date) => {
    const formatter = intlFormatterCache[name] || (intlFormatterCache[name] = new Intl.DateTimeFormat(locale, options));
    return formatter.format(date);
  },
  formatTime = (name, options, date, isShort = false) => {
    let strTime = useIntlFormat(name, options, date);
    // remove '0' from time when has AM/PM (from 01:00 PM to 1:00 PM): https://github.com/bryntum/support/issues/1483
    if (/am|pm/i.test(strTime)) {
      // remove first character only if is 0
      strTime = strTime.replace(/^0/, '');
      // if isShort is true, remove minutes if is :00
      if (isShort) {
        strTime = strTime.replace(/:00/, '');
      }
    }
    return strTime;
  },
  getDayDiff = (end, start) => Math.floor((end.getTime() - start.getTime() - (end.getTimezoneOffset() - start.getTimezoneOffset()) * validConversions.minute.millisecond) / validConversions.day.millisecond) + 1,
  normalizeDay = day => day >= 0 ? day : day + 7,
  msRegExp = /([^\w])(S+)/gm,
  msReplacer = (match, g1) => g1 + 'SSS',
  splitRegExp = /[:.\-/\s]/;
// These vars are set when changing locale
let locale = 'en-US',
  ordinalSuffix = enOrdinalSuffix,
  // Used to cache used formats, to not have to parse format string each time
  formatCache = {},
  formatRedirects = {},
  intlFormatterCache = {},
  parserCache = {};
const redirectFormat = format => {
  const intlConfig = intlFormatConfigs[format];
  if (!intlConfig) {
    throw new Error('Only international formats should be used here');
  }
  if (formatRedirects[format] !== undefined) {
    return formatRedirects[format];
  }
  const intl = new Intl.DateTimeFormat(locale, intlConfig),
    fmt = intl.formatToParts(new Date(2001, 1, 2, 3, 4, 5, 6)).map(part => {
      const type = part.type,
        intlCfg = intlConfig[type];
      if (type === 'literal') {
        // here we cheat again, because our parser can not skip unknown separators
        return part.value.replace(/,/g, '');
      } else if (type === 'day') {
        return intlCfg === 'numeric' ? 'D' : 'DD';
      } else if (type === 'month') {
        return intlCfg === 'short' ? 'MMM' : intlCfg === 'long' ? 'MMMM' : intlCfg === 'numeric' ? 'M' : 'MM';
      } else if (type === 'year') {
        // here we cheat a little, using `YYYY` for numeric year in `ll`
        // this is to simplify the fix for https://github.com/bryntum/support/issues/5179
        // to be fixed if anyone complains
        return intlCfg === 'numeric' ? 'YYYY' : 'YY';
      }
    }).join('');
  return formatRedirects[format] = fmt;
};
const DEFAULT_YEAR = 2020,
  // 2020 is the year that has no issues in Safari, see: https://github.com/bryntum/support/issues/554
  DEFAULT_MONTH = 0,
  DEFAULT_DAY = 1,
  intlFormatConfigs = {
    l: {
      year: 'numeric',
      month: 'numeric',
      day: 'numeric'
    },
    ll: {
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    }
  },
  formats = {
    // 1, 2, ... 11, 12
    M: date => date.getMonth() + 1,
    //date.toLocaleDateString(locale, { month : 'numeric' }),
    // 1st, 2nd, 3rd, 4th, ... 11th, 12th
    Mo: date => ordinalSuffix(formats.M(date).toString()),
    // 01, 02, ...
    MM: date => (date.getMonth() + 1).toString().padStart(2, '0'),
    //date.toLocaleDateString(locale, { month : '2-digit' }),
    // Jan, Feb, ...
    MMM: date => useIntlFormat('MMM', {
      month: 'short'
    }, date),
    // January, February, ...
    MMMM: date => useIntlFormat('MMMM', {
      month: 'long'
    }, date),
    // 1, 2, ...
    Q: date => Math.ceil((date.getMonth() + 1) / 3),
    // 1st, 2nd, ...
    Qo: date => ordinalSuffix(formats.Q(date).toString()),
    // 1, 2, ...
    D: date => date.getDate(),
    //date.toLocaleDateString(locale, { day : 'numeric' }),
    // 1st, 2nd, ...
    Do: date => ordinalSuffix(formats.D(date).toString()),
    // 01, 02, ...
    DD: date => date.getDate().toString().padStart(2, '0'),
    //date.toLocaleDateString(locale, { day : '2-digit' }),
    // 1, 2, ..., 365, 365
    DDD: date => Math.ceil((new Date(date.getFullYear(), date.getMonth(), date.getDate(), 12, 0, 0) - new Date(date.getFullYear(), 0, 0, 12, 0, 0)) / validConversions.day.millisecond),
    // 1st, 2nd, ...
    DDDo: date => ordinalSuffix(formats.DDD(date).toString()),
    // 001, 002, ...
    DDDD: date => formats.DDD(date).toString().padStart(3, '0'),
    // 0, 1, ..., 6
    d: date => date.getDay(),
    // 0th, 1st, ...
    do: date => ordinalSuffix(date.getDay().toString()),
    // S, M, ...
    d1: date => useIntlFormat('d1', {
      weekday: 'narrow'
    }, date).substr(0, 1),
    // Su, Mo, ...
    dd: date => formats.ddd(date).substring(0, 2),
    // Sun, Mon, ...
    ddd: date => useIntlFormat('ddd', {
      weekday: 'short'
    }, date),
    // Sunday, Monday, ...
    dddd: date => useIntlFormat('dddd', {
      weekday: 'long'
    }, date),
    u: date => {
      const formatter = intlFormatterCache.u || (intlFormatterCache.u = new Intl.DateTimeFormat('en-GB', {
          timeZone: 'UTC',
          year: 'numeric',
          month: '2-digit',
          day: '2-digit'
        })),
        parts = formatter.formatToParts(date);
      return `${parts[4].value}${parts[2].value}${parts[0].value}Z`;
    },
    uu: date => {
      const formatter = intlFormatterCache.uu || (intlFormatterCache.uu = new Intl.DateTimeFormat('en-GB', {
          timeZone: 'UTC',
          hour12: false,
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit'
        })),
        parts = formatter.formatToParts(date);
      return `${parts[4].value}${parts[2].value}${parts[0].value}T${parts[6].value}${parts[8].value}${parts[10].value}Z`;
    },
    e: date => date.getDay(),
    E: date => date.getDay() + 1,
    // ISO week, 1, 2, ...
    W: date => DateHelper.getWeekNumber(date)[1],
    Wo: date => ordinalSuffix(formats.W(date).toString()),
    WW: date => formats.W(date).toString().padStart(2, '0'),
    // ISO week, 1, 2, ... with localized 'Week ' prefix
    Wp: date => `${DateHelper.localize('L{Week}')} ${formats.W(date)}`,
    WWp: date => `${DateHelper.localize('L{Week}')} ${formats.WW(date)}`,
    Wp0: date => `${DateHelper.localize('L{Week}')[0]}${formats.W(date)}`,
    WWp0: date => `${DateHelper.localize('L{Week}')[0]}${formats.WW(date)}`,
    // 1979, 2018
    Y: date => date.getFullYear(),
    //date.toLocaleDateString(locale, { year : 'numeric' }),
    // 79, 18
    YY: date => (date.getFullYear() % 100).toString().padStart(2, '0'),
    //date.toLocaleDateString(locale, { year : '2-digit' }),
    // 1979, 2018
    YYYY: date => date.getFullYear(),
    //date.toLocaleDateString(locale, { year : 'numeric' }),
    // AM, PM
    A: date => date.getHours() < 12 ? 'AM' : 'PM',
    a: date => date.getHours() < 12 ? 'am' : 'pm',
    // 0, 1, ... 23
    H: date => date.getHours(),
    // 00, 01, ...
    HH: date => date.getHours().toString().padStart(2, '0'),
    // 1, 2, ... 12
    h: date => date.getHours() % 12 || 12,
    // 01, 02, ...
    hh: date => formats.h(date).toString().padStart(2, '0'),
    // 1, 2, ... 24
    k: date => date.getHours() || 24,
    // 01, 02, ...
    kk: date => formats.k(date).toString().padStart(2, '0'),
    // Locale specific (0 -> 24 or 1 AM -> 12 PM)
    K: date => formatTime('K', {
      hour: 'numeric'
    }, date),
    // Locale specific (00 -> 24 or 1 AM -> 12 PM)
    KK: date => formatTime('KK', {
      hour: '2-digit'
    }, date),
    // 0, 1, ... 59
    m: date => date.getMinutes(),
    //date.toLocaleTimeString(locale, { minute : 'numeric' }),
    // 00, 01, ...
    mm: date => formats.m(date).toString().padStart(2, '0'),
    // 0, 1, ... 59
    s: date => date.getSeconds(),
    //date.toLocaleTimeString(locale, { second : 'numeric' }),
    // 00, 01, ...
    ss: date => formats.s(date).toString().padStart(2, '0'),
    // 0, 1, ... 9 which are 000, 100, 200 ... 900 in milliseconds
    S: date => Math.floor(date.getMilliseconds() / 100).toString(),
    // 00, 01, ... 99 which are 000, 010, 020 ... 990 in milliseconds
    SS: date => Math.floor(date.getMilliseconds() / 10).toString().padStart(2, '0'),
    // 000, 001, ... 999 in milliseconds
    SSS: date => date.getMilliseconds().toString().padStart(3, '0'),
    z: date => useIntlFormat('z', {
      timeZoneName: 'short'
    }, date),
    zz: date => useIntlFormat('zz', {
      timeZoneName: 'long'
    }, date),
    Z: date => DH$1.getGMTOffset(date),
    LT: date => formatTime('LT', {
      hour: '2-digit',
      minute: '2-digit'
    }, date),
    // if minutes is 0, doesn't show it
    LST: date => formatTime('LST', {
      hour: 'numeric',
      minute: '2-digit'
    }, date, true),
    LTS: date => formatTime('LTS', {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    }, date),
    L: date => useIntlFormat('L', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit'
    }, date),
    l: date => useIntlFormat('l', intlFormatConfigs.l, date),
    LL: date => useIntlFormat('LL', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    }, date),
    ll: date => useIntlFormat('ll', intlFormatConfigs.ll, date),
    LLL: date => useIntlFormat('LLL', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: 'numeric',
      minute: '2-digit'
    }, date),
    lll: date => useIntlFormat('lll', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: 'numeric',
      minute: '2-digit'
    }, date),
    LLLL: date => useIntlFormat('LLLL', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: 'numeric',
      minute: '2-digit',
      weekday: 'long'
    }, date),
    llll: date => useIntlFormat('llll', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: 'numeric',
      minute: '2-digit',
      weekday: 'short'
    }, date)
  },
  // Want longest keys first, to not stop match at L of LTS etc.
  formatKeys = Object.keys(formats).sort((a, b) => b.length - a.length),
  formatRegexp = `^(?:${formatKeys.join('|')})`,
  // return empty object, meaning value cannot be processed to a valuable date part
  emptyFn = () => ({}),
  isNumber = str => numberRegex.test(str),
  parseMilliseconds = str => isNumber(str) && {
    milliseconds: parseInt(str.padEnd(3, '0').substring(0, 3))
  },
  parsers = {
    YYYY: str => {
      const year = parseInt(str);
      return {
        year: year >= 1000 && year <= 9999 ? year : NaN
      };
    },
    Y: str => ({
      year: parseInt(str)
    }),
    YY: str => {
      const year = parseInt(str);
      return {
        year: year + (year > 1968 ? 1900 : 2000)
      };
    },
    M: str => ({
      month: parseInt(str) - 1
    }),
    MM: str => ({
      month: parseInt(str) - 1
    }),
    Mo: str => ({
      month: parseInt(str) - 1
    }),
    MMM: str => {
      const month = (str || '').toLowerCase();
      for (const [name, entry] of Object.entries(DateHelper._monthShortNamesIndex)) {
        if (month.startsWith(name)) {
          return {
            month: entry.value
          };
        }
      }
    },
    MMMM: str => {
      const month = (str || '').toLowerCase();
      for (const [name, entry] of Object.entries(DateHelper._monthNamesIndex)) {
        if (month.startsWith(name)) {
          return {
            month: entry.value
          };
        }
      }
    },
    DD: str => ({
      date: parseInt(str)
    }),
    D: str => ({
      date: parseInt(str)
    }),
    Do: str => ({
      date: parseInt(str)
    }),
    DDD: emptyFn,
    DDDo: emptyFn,
    DDDD: emptyFn,
    d: emptyFn,
    do: emptyFn,
    d1: emptyFn,
    dd: emptyFn,
    ddd: emptyFn,
    dddd: emptyFn,
    Q: emptyFn,
    Qo: emptyFn,
    W: emptyFn,
    Wo: emptyFn,
    WW: emptyFn,
    e: emptyFn,
    E: emptyFn,
    HH: str => ({
      hours: parseInt(str)
    }),
    hh: str => ({
      hours: parseInt(str)
    }),
    mm: str => ({
      minutes: parseInt(str)
    }),
    H: str => ({
      hours: parseInt(str)
    }),
    m: str => ({
      minutes: parseInt(str)
    }),
    ss: str => ({
      seconds: parseInt(str)
    }),
    s: str => ({
      seconds: parseInt(str)
    }),
    S: parseMilliseconds,
    SS: parseMilliseconds,
    SSS: parseMilliseconds,
    A: str => ({
      amPm: str.toLowerCase()
    }),
    a: str => ({
      amPm: str.toLowerCase()
    }),
    L: 'MM/DD/YYYY',
    LT: 'HH:mm A',
    LTS: 'HH:mm:ss A',
    l: {
      type: 'dynamic',
      parser: () => redirectFormat('l')
    },
    ll: {
      type: 'dynamic',
      parser: () => redirectFormat('ll')
    },
    // Can either be Z (=UTC, 0) or +-HH:MM
    Z: str => {
      if (!str || !timeZoneRegEx.test(str) && str !== 'Z') {
        return null;
      }
      let timeZone = 0;
      // If string being parsed is more detailed than the format specified we can have more chars left,
      // thus check the last (for example HH:mmZ with input HH:mm:ssZ -> ssZ)
      if (str !== 'Z') {
        const matches = timeZoneRegEx.exec(str);
        // If timezone regexp matches, sting has time zone offset like '+02:00'
        if (matches) {
          const sign = matches[1] === '+' ? 1 : -1,
            hours = parseInt(matches[2]) || 0,
            minutes = parseInt(matches[3]) || 0;
          timeZone = sign * (hours * 60 + minutes);
        }
        // otherwise we just return current time zone, because there's a Z key in the input
        else {
          timeZone = -1 * new Date().getTimezoneOffset();
        }
      }
      return {
        timeZone
      };
    }
  },
  parserKeys = Object.keys(parsers).sort((a, b) => b.length - a.length),
  parserRegexp = new RegExp(`(${parserKeys.join('|')})`),
  // Following regexp includes all formats that should be handled by Date class
  // !!! except `l|ll`, plus made all-string capturing, otherwise the left-most `l` pattern
  // matches all `l*` formats
  // localeStrRegExp            = new RegExp('(l|LL|ll|LLL|lll|LLLL|llll)'),
  localeStrRegExp = new RegExp('^(LL|LLL|lll|LLLL|llll)$'),
  //    ISODateRegExp             = new RegExp('YYYY-MM-DD[T ]HH:mm:ss(.s+)?Z'),
  // Some validConversions are negative to show that it's not an exact conversion, just an estimate.
  validConversions = {
    // The units below assume:
    // 30 days in a month, 91 days for a quarter and 365 for a year
    // 52 weeks per year, 4 per month, 13 per quarter
    // 3652 days per decade (assuming two of the years will be leap with 366 days)
    decade: {
      decade: 1,
      year: 10,
      quarter: 40,
      month: 120,
      week: 520,
      day: 3652,
      hour: 24 * 3652,
      minute: 1440 * 3652,
      second: 86400 * 3652,
      millisecond: 86400000 * 3652
    },
    year: {
      decade: 0.1,
      year: 1,
      quarter: 4,
      month: 12,
      week: 52,
      day: 365,
      hour: 24 * 365,
      minute: 1440 * 365,
      second: 86400 * 365,
      millisecond: 86400000 * 365
    },
    quarter: {
      decade: 1 / 40,
      year: 1 / 4,
      quarter: 1,
      month: 3,
      week: 4,
      day: 91,
      hour: 24 * 91,
      minute: 1440 * 91,
      second: 86400 * 91,
      millisecond: 86400000 * 91
    },
    month: {
      decade: 1 / 120,
      year: 1 / 12,
      quarter: 1 / 3,
      month: 1,
      week: 4,
      day: -30,
      hour: -24 * 30,
      minute: -1440 * 30,
      second: -86400 * 30,
      millisecond: -86400000 * 30
    },
    week: {
      decade: -1 / 520,
      year: -1 / 52,
      quarter: -1 / 13,
      month: -1 / 4,
      day: 7,
      hour: 168,
      minute: 10080,
      second: 604800,
      millisecond: 604800000
    },
    day: {
      decade: -1 / 3652,
      year: -1 / 365,
      quarter: -1 / 91,
      month: -1 / 30,
      week: 1 / 7,
      hour: 24,
      minute: 1440,
      second: 86400,
      millisecond: 86400000
    },
    hour: {
      decade: -1 / (3652 * 24),
      year: -1 / (365 * 24),
      quarter: -1 / (91 * 24),
      month: -1 / (30 * 24),
      week: 1 / 168,
      day: 1 / 24,
      minute: 60,
      second: 3600,
      millisecond: 3600000
    },
    minute: {
      decade: -1 / (3652 * 1440),
      year: -1 / (365 * 1440),
      quarter: -1 / (91 * 1440),
      month: -1 / (30 * 1440),
      week: 1 / 10080,
      day: 1 / 1440,
      hour: 1 / 60,
      second: 60,
      millisecond: 60000
    },
    second: {
      decade: -1 / (3652 * 86400),
      year: -1 / (365 * 86400),
      quarter: -1 / (91 * 86400),
      month: -1 / (30 * 86400),
      week: 1 / 604800,
      day: 1 / 86400,
      hour: 1 / 3600,
      minute: 1 / 60,
      millisecond: 1000
    },
    millisecond: {
      decade: -1 / (3652 * 86400000),
      year: -1 / (365 * 86400000),
      quarter: -1 / (91 * 86400000),
      month: -1 / (30 * 86400000),
      week: 1 / 604800000,
      day: 1 / 86400000,
      hour: 1 / 3600000,
      minute: 1 / 60000,
      second: 1 / 1000
    }
  },
  normalizedUnits = {
    ms: 'millisecond',
    milliseconds: 'millisecond',
    s: 'second',
    seconds: 'second',
    m: 'minute',
    mi: 'minute',
    min: 'minute',
    minutes: 'minute',
    h: 'hour',
    hours: 'hour',
    d: 'day',
    days: 'day',
    w: 'week',
    weeks: 'week',
    M: 'month',
    mo: 'month',
    mon: 'month',
    months: 'month',
    q: 'quarter',
    quarters: 'quarter',
    y: 'year',
    years: 'year',
    dec: 'decade',
    decades: 'decade'
  },
  withDecimalsDurationRegex = /^\s*([-+]?\d+(?:[.,]\d*)?|[-+]?(?:[.,]\d+))\s*([^\s]+)?/i,
  noDecimalsDurationRegex = /^\s*([-+]?\d+)(?![.,])\s*([^\s]+)?/i,
  canonicalUnitNames = ['millisecond', 'second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year', 'decade'],
  canonicalUnitAbbreviations = [['mil'], ['s', 'sec'], ['m', 'min'], ['h', 'hr'], ['d'], ['w', 'wk'], ['mo', 'mon', 'mnt'], ['q', 'quar', 'qrt'], ['y', 'yr'], ['dec']],
  deltaUnits = ['decade', 'year', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'],
  // Used when creating a date from an object, to fill in any blanks
  dateProperties = ['milliseconds', 'seconds', 'minutes', 'hours', 'date', 'month', 'year'],
  parseNumber = n => {
    const result = parseFloat(n);
    return isNaN(result) ? null : result;
  },
  numberRegex = /^[0-9]+$/,
  timeZoneRegEx = /([+-])(\d\d):*(\d\d)*$/,
  unitMagnitudes = {
    millisecond: 0,
    second: 1,
    minute: 2,
    hour: 3,
    day: 4,
    week: 5,
    month: 6,
    quarter: 7,
    year: 8,
    decade: 9
  },
  snapFns = {
    round(number, step = 1) {
      return Math.round(number / step) * step;
    },
    floor(number, step = 1) {
      return Math.floor(number / step) * step;
    },
    ceil(number, step = 1) {
      return Math.ceil(number / step) * step;
    }
  },
  keyCache = {};
/**
 * @module Core/helper/DateHelper
 */
/**
 * A static class offering date manipulation, comparison, parsing and formatting helper methods.
 *
 * ## Parsing strings
 * Use `DateHelper.parse()` to parse strings into dates. It accepts a date string and a format specifier.
 * The format specifier is string built up using the following tokens:
 *
 * | Unit        | Token | Description                       |
 * |-------------|-------|-----------------------------------|
 * | Year        | YYYY  | 4-digits year, like: 2018         |
 * |             | Y     | numeric, any number of digits     |
 * |             | YY    | < 68 -> 2000, > 68 -> 1900        |
 * | Month       | MM    | 01 - 12                           |
 * | Month       | MMM   | Short name of the month           |
 * | Date        | DD    | 01 - 31                           |
 * | Hour        | HH    | 00 - 23 or 1 - 12                 |
 * | Minute      | mm    | 00 - 59                           |
 * | Second      | ss    | 00 - 59                           |
 * | Millisecond | S     | 0 - 9 [000, 100, 200 .. 900 ]     |
 * |             | SS    | 00 - 99 [000, 010, 020 .. 990 ]   |
 * |             | SSS   | 000 - 999 [000, 001, 002 .. 999 ] |
 * | AM/PM       | A     | AM or PM                          |
 * |             | a     | am or pm                          |
 * | TimeZone    | Z     | Z for UTC or +-HH:mm              |
 * | Predefined  | L     | Long date, MM/DD/YYYY             |
 * |             | LT    | Long time, HH:mm A                |
 *
 * Default parse format is: `'YYYY-MM-DDTHH:mm:ss.SSSZ'` see {@link #property-defaultParseFormat-static}
 *
 * For example:
 *
 * ```javascript
 * DateHelper.parse('2018-11-06', 'YYYY-MM-DD');
 * DateHelper.parse('13:14', 'HH:mm');
 * DateHelper.parse('6/11/18', 'DD/MM/YY');
 * ```
 *
 * ## Formatting dates
 * Use `DateHelper.format()` to create a string from a date using a format specifier. The format specifier is similar to
 * that used when parsing strings. It can use the following tokens (input used for output below is
 * `new Date(2018,8,9,18,7,8,145)`):
 *
 * | Unit                  | Token | Description & output                  |
 * |-----------------------|-------|---------------------------------------|
 * | Year                  | YYYY  | 2018                                  |
 * |                       | YY    | 18                                    |
 * |                       | Y     | 2018                                  |
 * | Quarter               | Q     | 3                                     |
 * |                       | Qo    | 3rd                                   |
 * | Month                 | MMMM  | September                             |
 * |                       | MMM   | Sep                                   |
 * |                       | MM    | 09                                    |
 * |                       | Mo    | 9th                                   |
 * |                       | M     | 9                                     |
 * | Week (iso)            | WW    | 37 (2 digit, zero padded)             |
 * |                       | Wo    | 37th                                  |
 * |                       | W     | 37                                    |
 * |                       | WWp   | Week 37 (localized prefix, zero pad)  |
 * |                       | Wp    | Week 37 (localized prefix)            |
 * |                       | WWp0  | W37 (localized prefix)                |
 * |                       | Wp0   | W37 (localized prefix)                |
 * | Date                  | DDDD  | Day of year, 3 digits                 |
 * |                       | DDDo  | Day of year, ordinal                  |
 * |                       | DDD   | Day of year                           |
 * |                       | DD    | 09                                    |
 * |                       | Do    | 9th                                   |
 * |                       | D     | 9                                     |
 * | Weekday               | dddd  | Sunday                                |
 * |                       | ddd   | Sun                                   |
 * |                       | dd    | Su                                    |
 * |                       | d1    | S                                     |
 * |                       | do    | 0th                                   |
 * |                       | d     | 0                                     |
 * | Hour                  | HH    | 18 (00 - 23)                          |
 * |                       | H     | 18 (0 - 23)                           |
 * |                       | hh    | 06 (00 - 12)                          |
 * |                       | h     | 6 (0 - 12)                            |
 * |                       | KK    | 19 (01 - 24)                          |
 * |                       | K     | 19 (1 - 24)                           |
 * |                       | kk    | 06 or 18, locale determines           |
 * |                       | k     | 6 or 18, locale determines            |
 * | Minute                | mm    | 07                                    |
 * |                       | m     | 7                                     |
 * | Second                | ss    | 08                                    |
 * |                       | s     | 8                                     |
 * | Millisecond           | S     | 1 (100ms)                             |
 * |                       | SS    | 14 (140ms)                            |
 * |                       | SSS   | 145 (145ms)                           |
 * | AM/PM                 | A     | AM or PM                              |
 * |                       | a     | am or pm                              |
 * | Predefined            | LT    | H: 2-digit (2d), m: 2d                |
 * | (uses browser locale) | LTS   | H: 2d, m: 2d, s : 2d                  |
 * |                       | LST   | Depends on 12 or 24 hour clock        |
 * |                       |       | 12h, H : 1d, m : 0 or 2d              |
 * |                       |       | 24h, H : 2d, m : 2d                   |
 * |                       | L     | Y: numeric (n), M : 2d, D : 2d        |
 * |                       | l     | Y: n, M : n, D : n                    |
 * |                       | LL    | Y: n, M : long (l), D : n             |
 * |                       | ll    | Y: n, M : short (s), D : n            |
 * |                       | LLL   | Y: n, M : l, D : n, H: n, m: 2d       |
 * |                       | lll   | Y: n, M : s, D : n, H: n, m: 2d       |
 * |                       | LLLL  | Y: n, M : l, D : n, H: n, m: 2d, d: l |
 * |                       | llll  | Y: n, M : s, D : n, H: n, m: 2d, d: s |
 * |                       | u     | YYYYMMDDZ in UTC zone                 |
 * |                       | uu    | YYYYMMDDTHHMMSSZ in UTC zone          |
 *
 * Default format is: `'YYYY-MM-DDTHH:mm:ssZ'` see {@link #property-defaultFormat-static}
 *
 * For example:
 *
 * ```javascript
 * DateHelper.format(new Date(2018,10,6), 'YYYY-MM-DD'); // 2018-11-06
 * DateHelper.format(new Date(2018,10,6), 'M/D/YY'); // 11/6/18
 * ```
 *
 * Arbitrary text can be embedded in the format string by wrapping it with {}:
 *
 * ```javascript
 * DateHelper.format(new Date(2019, 7, 16), '{It is }dddd{, yay!}') -> It is Friday, yay!
 * ```
 *
 * ## Unit names
 * Many DateHelper functions (for example add, as, set) accepts a unit among their params. The following units are
 * available:
 *
 * | Unit        | Aliases                       |
 * |-------------|-------------------------------|
 * | millisecond | millisecond, milliseconds, ms |
 * | second      | second, seconds, s            |
 * | minute      | minute, minutes, m            |
 * | hour        | hour, hours, h                |
 * | day         | day, days, d                  |
 * | week        | week, weeks, w                |
 * | month       | month, months, mon, mo, M     |
 * | quarter     | quarter, quarters, q          |
 * | year        | year, years, y                |
 * | decade      | decade, decades, dec          |
 *
 * For example:
 * ```javascript
 * DateHelper.add(date, 2, 'days');
 * DateHelper.as('hour', 7200, 'seconds');
 * ```
 * @static
 */
class DateHelper extends Localizable() {
  static MS_PER_DAY = MS_PER_HOUR * 24;
  static get $name() {
    return 'DateHelper';
  }
  //region Parse & format
  /**
   * Get/set the default format used by `format()` and `parse()`. Defaults to `'YYYY-MM-DDTHH:mm:ssZ'`
   * (~ISO 8601 Date and time, `'1962-06-17T09:21:34Z'`).
   * @member {String}
   */
  static set defaultFormat(format) {
    DH$1._defaultFormat = format;
  }
  static get defaultFormat() {
    return DH$1._defaultFormat || 'YYYY-MM-DDTHH:mm:ssZ';
  }
  /**
   * Get/set the default format used by `parse()`. Defaults to `'YYYY-MM-DDTHH:mm:ss.SSSZ'` or {@link #property-defaultFormat-static}
   * (~ISO 8601 Date and time, `'1962-06-17T09:21:34.123Z'`).
   * @member {String}
   */
  static set defaultParseFormat(parseFormat) {
    this._defaultParseFormat = parseFormat;
  }
  static get defaultParseFormat() {
    return this._defaultParseFormat || this._defaultFormat || 'YYYY-MM-DDTHH:mm:ss.SSSZ';
  }
  static buildParser(format) {
    // Split input format by regexp, which includes predefined patterns. Normally format would have some
    // splitters, like 'YYYY-MM-DD' or 'D/M YYYY' so output will contain matched patterns as well as splitters
    // which would serve as anchors. E.g. provided format is 'D/M!YYYY' and input is `11/6!2019` algorithm would work like:
    // 1. split format by regexp                // ['', 'D', '/', 'M', '!', 'YYYY', '']
    // 2. find splitters                        // ['/', '!']
    // 3. split input by seps, step by step     // ['11', ['6', ['2019']]]
    // Inputs like 'YYYYY' (5*Y) means 'YYYY' + 'Y', because it matches patterns from longer to shorter,
    // but if few patterns describe same unit the last one is applied, for example
    // DH.parse('20182015', 'YYYYY') equals to new Date(2015, 0, 0)
    const parts = format.split(parserRegexp),
      parser = [];
    // if length of the parts array is 1 - there are no regexps in the input string. thus - no parsers
    // do same if there are patterns matching locale strings (l, ll, LLLL etc.)
    // returning empty array to use new Date() as parser
    if (parts.length === 1 || localeStrRegExp.test(format)) {
      return [];
    } else {
      parts.reduce((prev, curr, index, array) => {
        // ignore first and last empty string
        if (index !== 0 || curr !== '') {
          // if current element matches parser regexp store it as a parser
          if (parserRegexp.test(curr)) {
            const localeParsers = this.localize('L{parsers}') || {},
              fn = localeParsers[curr] || parsers[curr];
            // Z should be last element in the string that matches regexp. Last array element is always either
            // an empty string (if format ends with Z) or splitter (everything that doesn't match regexp after Z)
            // If there is a pattern after Z, then Z index will be lower than length - 2
            if (curr === 'Z' && index < array.length - 2) {
              throw new Error(`Invalid format ${format} TimeZone (Z) must be last token`);
            }
            const parserObj = typeof fn === 'function' || typeof fn === 'string' ? fn : fn.parser();
            // If fn is a string, we found an alias (L, LLL, l etc.).
            // Need to build parsers from mapped format and merge with existing
            if (typeof parserObj === 'string') {
              // we are going to merge nested parsers with current, some cleanup required:
              // 1. last element is no longer last
              // 2. need to pass last parser to the next step
              const nestedParsers = DH$1.buildParser(parserObj),
                lastItem = nestedParsers.pop();
              delete lastItem.last;
              // elevate nested parsers
              parser.push(...nestedParsers);
              prev = lastItem;
            } else {
              prev.pattern = curr;
              prev.fn = parserObj;
            }
          }
          // if it doesn't match - we've found a splitter
          else {
            prev.splitter = curr;
            parser.push(prev);
            prev = {};
          }
        } else if (Object.prototype.hasOwnProperty.call(prev, 'pattern')) {
          parser.push(prev);
        }
        return prev;
      }, {});
    }
    parser[parser.length - 1].last = true;
    return parser;
  }
  /**
   * A utility function to create a sortable string key for the passed date or ms timestamp using the `'YYYY-MM-DD'`
   * format.
   * @param {Number|Date} ms The Date instance or ms timestamp to generate a key for
   * @returns {String} Date/timestamp as a string with `'YYYY-M-D'` format
   * @internal
   */
  static makeKey(ms) {
    // If an ten character string passed, assume it's already a key
    if (ms.length === 10) {
      return ms;
    }
    // Convert Date to ms timestamp
    if (ms.getTime) {
      ms = ms.getTime();
    }
    // Cache holds ms -> YYYY-MM-DD
    const cached = keyCache[Math.trunc(ms / MS_PER_HOUR)];
    if (cached) {
      return cached;
    }
    tempDate.setTime(ms);
    const month = tempDate.getMonth() + 1,
      date = tempDate.getDate();
    // Not using DateHelper.format to save some cycles, hit a lot
    return keyCache[Math.trunc(ms / MS_PER_HOUR)] = `${tempDate.getFullYear()}-${month < 10 ? '0' + month : month}-${date < 10 ? '0' + date : date}`;
  }
  /**
   * A utility function to parse a sortable string to a date using the `'YYYY-MM-DD'` format.
   * @param {String} key The string to return a date for
   * @returns {Date} new Date instance
   * @internal
   */
  static parseKey(key) {
    return DH$1.parse(key, 'YYYY-MM-DD');
  }
  /**
   * Returns a date created from the supplied string using the specified format. Will try to create even if format
   * is left out, by first using the default format (see {@link #property-defaultFormat-static}, by default
   * `YYYY-MM-DDTHH:mm:ssZ`) and then using `new Date(dateString)`.
   * Supported tokens:
   *
   * | Unit        | Token | Description                       |
   * |-------------|-------|-----------------------------------|
   * | Year        | YYYY  | 2018                              |
   * |             | YY    | < 68 -> 2000, > 68 -> 1900        |
   * | Month       | MM    | 01 - 12                           |
   * | Date        | DD    | 01 - 31                           |
   * | Hour        | HH    | 00 - 23 or 1 - 12                 |
   * | Minute      | mm    | 00 - 59                           |
   * | Second      | ss    | 00 - 59                           |
   * | Millisecond | S     | 0 - 9 [000, 100, 200 .. 900 ]     |
   * |             | SS    | 00 - 99 [000, 010, 020 .. 990 ]   |
   * |             | SSS   | 000 - 999 [000, 001, 002 .. 999 ] |
   * | AM/PM       | A     | AM or PM                          |
   * |             | a     | am or pm                          |
   * | TimeZone    | Z     | Z for UTC or +-HH:mm              |
   * | Predefined  | L     | Long date, MM/DD/YYYY             |
   * |             | LT    | Long time, HH:mm A                |
   *
   * Predefined formats and functions used to parse tokens can be localized, see for example the swedish locale SvSE.js
   *
   * NOTE: If no date parameters are provided then `Jan 01 2020` is used as a default date
   *
   * @param {String} dateString Date string
   * @param {String} [format] Date format (or {@link #property-defaultParseFormat-static} if left out)
   * @returns {Date} new Date instance parsed from the string
   * @category Parse & format
   */
  static parse(dateString, format = DH$1.defaultParseFormat, strict = false) {
    if (dateString instanceof Date) {
      return dateString;
    }
    if (typeof dateString !== 'string' || !dateString) {
      return null;
    }
    // // For ISO 8601 native is faster, but not very forgiving
    // if (format === defaultFormat) {
    //     const dt = new Date(dateString);
    //     if (!isNaN(dt)) {
    //         return dt;
    //     }
    // }
    const config = {
      year: null,
      month: null,
      date: null,
      hours: null,
      minutes: null,
      seconds: null,
      milliseconds: null
    };
    // Milliseconds parser is the same for S, SS, SSS
    // We search for a string of 'S' characters *not* preceded by an alpha character.
    // So that the formats such as 'LTS' do not get corrupted
    format = format.replace(msRegExp, msReplacer);
    let parser = parserCache[format],
      result;
    if (!parser) {
      parser = parserCache[format] = DH$1.buildParser(format);
    }
    // Since Unicode 15 standard arrived to browsers (Chrome 110+ and FF 109+) they add unicode "thin" space before AM/PM
    // https://icu.unicode.org/download/72
    // Convert unicode spaces to regular for parser
    if (dateString.includes('\u202f')) {
      dateString = dateString.replace(/\s/g, ' ');
    }
    // Each parser knows its pattern and splitter. It looks for splitter in the
    // input string, takes first substring and tries to process it. Remaining string
    // is passed to the next parser.
    parser.reduce((dateString, parser) => {
      if (parser.last) {
        Object.assign(config, parser.fn(dateString));
      } else {
        let splitAt;
        // ISO 8601 says that T symbol can be replaced with a space
        if (parser.splitter === 'T' && dateString.indexOf('T') === -1) {
          splitAt = dateString.indexOf(' ');
        } else {
          var _parser$pattern;
          const timeZoneIndex = dateString.indexOf('+');
          let {
            splitter
          } = parser;
          // Use more forgiving regexp for parsing if strict mode is off
          if (!strict && splitRegExp.test(splitter)) {
            splitter = splitRegExp;
          }
          // If splitter specified find its position, otherwise try to determine pattern length
          splitAt = parser.splitter !== '' ? dateString.search(typeof splitter === 'string' ? StringHelper.escapeRegExp(splitter) : splitter) : ((_parser$pattern = parser.pattern) === null || _parser$pattern === void 0 ? void 0 : _parser$pattern.length) || -1;
          // Don't split in the time zone part
          if (timeZoneIndex > -1 && splitAt > timeZoneIndex) {
            splitAt = -1;
          }
        }
        let part, rest;
        // If splitter is not found in the current string we may be dealing with
        // 1. partial input - in that case we just feed all string to current parser and move on
        // 2. time zone (ssZ - splitter is empty string) and pattern is not specified, see comment below
        // 3. parse milliseconds before Z
        if (splitAt === -1 || parser.pattern === 'SSS' && dateString.match(/^\d+Z$/)) {
          // NOTE: parentheses are required here as + and - signs hold valuable information
          // with parentheses we get array like ['00','+','01:00'], omitting them we won't get
          // regexp match in result, loosing information
          const chunks = dateString.split(/([Z\-+])/);
          // If splitter is not found in the string, we may be dealing with string that contains info about TZ.
          // For instance, if format contains Z as last arg which is not separated (normally it is not indeed),
          // like 'YYYY-MM-DD HH:mm:ssZ', then second to last parser will have string that it cannot just parse, like
          // '2010-01-01 10:00:00'        -> '00'
          // '2010-01-01 10:00:00Z'       -> '00Z'
          // '2010-01-01 10:00:00-01'     -> '00-01'
          // '2010-01-01 10:00:00+01:30'  -> '00+01:30'
          // this cannot be processed by date parsers, so we need to process that additionally. So we
          // split string by symbols that can be found around timezone info: Z,-,+
          if (chunks.length === 1) {
            part = dateString;
            rest = '';
          } else {
            part = chunks[0];
            rest = `${chunks[1]}${chunks[2]}`;
          }
        } else {
          part = dateString.substring(0, splitAt) || dateString;
          rest = dateString.substring(splitAt + parser.splitter.length);
        }
        if (parser.fn) {
          // Run parser and add result to config on successful parse otherwise continue parsing
          const res = parser.fn(part);
          if (res) {
            Object.assign(config, res);
          } else {
            rest = part + rest;
          }
        }
        return rest;
      }
    }, dateString);
    // If year is specified date has to be greater than 0
    if (config.year && !config.date) {
      config.date = 1;
    }
    if (config.date > 31 || config.month > 12) {
      return null;
    }
    const date = DH$1.create(config, strict);
    if (date) {
      result = date;
    } else if (!strict) {
      // Last resort, try if native passing can do it
      result = new Date(dateString);
    }
    return result;
  }
  /**
   * Creates a date from a date definition object. The object can have the following properties:
   * - year
   * - month
   * - date (day in month)
   * - hours
   * - minutes
   * - seconds
   * - milliseconds
   * - amPm : 'am' or 'pm', implies 12-hour clock
   * - timeZone : offset from UTC in minutes
   * @param {Object} definition
   * @param {Number} definition.year
   * @param {Number} [definition.month]
   * @param {Number} [definition.date]
   * @param {Number} [definition.hours]
   * @param {Number} [definition.minutes]
   * @param {Number} [definition.seconds]
   * @param {Number} [definition.milliseconds]
   * @param {Number} [definition.amPm]
   * @param {Number} [definition.timeZone]
   * @returns {Date} new Date instance
   * @category Parse & format
   */
  static create(definition, strict = false) {
    // Shallow clone to not alter input
    const def = {
      ...definition
    };
    let invalid = isNaN(def.year) || strict && (isNaN(def.month) || isNaN(def.date)),
      useUTC = false;
    // Not much validation yet, only considered invalid if all properties are null
    if (!invalid) {
      let allNull = true;
      dateProperties.forEach(property => {
        if (!(property in def) || isNaN(def[property])) {
          def[property] = 0;
        }
        allNull = allNull && def[property] === null;
      });
      invalid = allNull;
    }
    if (invalid) {
      return null;
    }
    if (def.amPm === 'am') {
      def.hours = def.hours % 12;
    } else if (def.amPm === 'pm') {
      def.hours = def.hours % 12 + 12;
    }
    if ('timeZone' in def) {
      useUTC = true;
      def.minutes -= def.timeZone;
    }
    if (strict && (def.year == null || def.month == null || def.date == null)) {
      return null;
    }
    const args = [defaultValue(def.year, DEFAULT_YEAR), defaultValue(def.month, DEFAULT_MONTH), defaultValue(def.date, DEFAULT_DAY), def.hours, def.minutes, def.seconds, def.milliseconds];
    return useUTC ? new Date(Date.UTC(...args)) : new Date(...args);
  }
  static toUTC(date) {
    return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds()));
  }
  /**
   * Converts a date to string with the specified format. Formats heavily inspired by https://momentjs.com.
   * Available formats (input used for output below is `new Date(2018,8,9,18,7,8,145)`):
   *
   * | Unit                  | Token | Description & output                  |
   * |-----------------------|-------|---------------------------------------|
   * | Year                  | YYYY  | 2018                                  |
   * |                       | YY    | 18                                    |
   * |                       | Y     | 2018                                  |
   * | Quarter               | Q     | 3                                     |
   * |                       | Qo    | 3rd                                   |
   * | Month                 | MMMM  | September                             |
   * |                       | MMM   | Sep                                   |
   * |                       | MM    | 09                                    |
   * |                       | Mo    | 9th                                   |
   * |                       | M     | 9                                     |
   * | Week (iso)            | WW    | 37 (2 digit, zero padded)             |
   * |                       | Wo    | 37th                                  |
   * |                       | W     | 37                                    |
   * |                       | WWp   | Week 37 (localized prefix, zero pad)  |
   * |                       | Wp    | Week 37 (localized prefix)            |
   * |                       | WWp0  | W37 (localized prefix)                |
   * |                       | Wp0   | W37 (localized prefix)                |
   * | Date                  | DDDD  | Day of year, 3 digits                 |
   * |                       | DDDo  | Day of year, ordinal                  |
   * |                       | DDD   | Day of year                           |
   * |                       | DD    | 09                                    |
   * |                       | Do    | 9th                                   |
   * |                       | D     | 9                                     |
   * | Weekday               | dddd  | Sunday                                |
   * |                       | ddd   | Sun                                   |
   * |                       | dd    | Su                                    |
   * |                       | d1    | S                                     |
   * |                       | do    | 0th                                   |
   * |                       | d     | 0                                     |
   * | Hour                  | HH    | 18 (00 - 23)                          |
   * |                       | H     | 18 (0 - 23)                           |
   * |                       | hh    | 06 (00 - 12)                          |
   * |                       | h     | 6 (0 - 12)                            |
   * |                       | KK    | 19 (01 - 24)                          |
   * |                       | K     | 19 (1 - 24)                           |
   * |                       | kk    | 06 or 18, locale determines           |
   * |                       | k     | 6 or 18, locale determines            |
   * | Minute                | mm    | 07                                    |
   * |                       | m     | 7                                     |
   * | Second                | ss    | 08                                    |
   * |                       | s     | 8                                     |
   * | Millisecond           | S     | 1 (100ms)                             |
   * |                       | SS    | 14 (140ms)                            |
   * |                       | SSS   | 145 (145ms)                           |
   * | AM/PM                 | A     | AM or PM                              |
   * |                       | a     | am or pm                              |
   * | Predefined            | LT    | H: 2-digit (2d), m: 2d                |
   * | (uses browser locale) | LTS   | H: 2d, m: 2d, s : 2d                  |
   * |                       | LST   | Depends on 12 or 24 hour clock        |
   * |                       |       | 12h, H : 1d, m : 0 or 2d              |
   * |                       |       | 24h, H : 2d, m : 2d                   |
   * |                       | L     | Y: numeric (n), M : 2d, D : 2d        |
   * |                       | l     | Y: n, M : n, D : n                    |
   * |                       | LL    | Y: n, M : long (l), D : n             |
   * |                       | ll    | Y: n, M : short (s), D : n            |
   * |                       | LLL   | Y: n, M : l, D : n, H: n, m: 2d       |
   * |                       | lll   | Y: n, M : s, D : n, H: n, m: 2d       |
   * |                       | LLLL  | Y: n, M : l, D : n, H: n, m: 2d, d: l |
   * |                       | llll  | Y: n, M : s, D : n, H: n, m: 2d, d: s |
   *
   * Some examples:
   *
   * ```javascript
   * DateHelper.format(new Date(2019, 7, 16), 'dddd') -> Friday
   * DateHelper.format(new Date(2019, 7, 16, 14, 27), 'HH:mm') --> 14:27
   * DateHelper.format(new Date(2019, 7, 16, 14, 27), 'L HH') --> 2019-07-16 14
   * ```
   *
   * Arbitrary text can be embedded in the format string by wrapping it with {}:
   *
   * ```javascript
   * DateHelper.format(new Date(2019, 7, 16), '{It is }dddd{, yay!}') -> It is Friday, yay!
   * ```
   *
   * @param {Date} date Date
   * @param {String} [format] Desired format (uses `defaultFormat` if left out)
   * @returns {String} Formatted string
   * @category Parse & format
   */
  static format(date, format = DH$1.defaultFormat) {
    // Bail out if no date or invalid date
    if (!date || isNaN(date)) {
      return null;
    }
    let formatter = formatCache[format],
      output = '';
    if (!formatter) {
      formatter = formatCache[format] = [];
      // Build formatter array with the steps needed to format the date
      for (let i = 0; i < format.length; i++) {
        // Matches a predefined format?
        const formatMatch = format.slice(i).match(formatRegexp),
          predefined = formatMatch === null || formatMatch === void 0 ? void 0 : formatMatch[0];
        if (predefined) {
          const localeFormats = this.localize('L{formats}') || {},
            fn = localeFormats[predefined] || formats[predefined];
          formatter.push(fn);
          i += predefined.length - 1;
        }
        // Start of text block? Append it
        else if (format[i] === '{') {
          // Find closing brace
          const index = format.indexOf('}', i + 1);
          // No closing brace, grab rest of string
          if (index === -1) {
            formatter.push(format.substr(i + 1));
            i = format.length;
          }
          // Closing brace found
          else {
            formatter.push(format.substring(i + 1, index));
            // Carry on after closing brace
            i = index;
          }
        }
        // Otherwise append to output (for example - / : etc)
        else {
          formatter.push(format[i]);
        }
      }
    }
    formatter.forEach(step => {
      if (typeof step === 'string') {
        output += step;
      } else {
        output += step(date);
      }
    });
    return output;
  }
  /**
   * Formats a range of `dates` using the specified `format`. Because two dates are involved, the `format` specifier
   * uses the tokens `S{}` and `E{}`. The text contained between the `{}` is the {@link #function-format-static format}
   * for the start date or end date, respectively. Text not inside these tokens is retained verbatim.
   *
   * For example:
   *
   * ```javascript
   *  DateHelper.formatRange(dates, 'S{DD MMM YYYY} - E{DD MMM YYYY}');
   * ```
   *
   * The above will format `dates[0]` based on the `S{DD MMM YYYY}` segment and `dates[1] using `E{DD MMM YYYY}`. The
   * `' - '` between these will remain between the two formatted dates.
   *
   * @param {Date[]} dates An array of start date and end date (`[startDate, endDate]`)
   * @param {String} format The format specifier
   * @returns {String}
   */
  static formatRange(dates, format) {
    return format.replace(rangeFormatPartRe, (s, which, fmt) => DateHelper.format(dates[which === 'S' ? 0 : 1], fmt));
  }
  /**
   * Converts the specified amount of desired unit into milliseconds. Can be called by only specifying a unit as the
   * first argument, it then uses `amount = 1`.
   *
   * For example:
   *
   * ```javascript
   * asMilliseconds('hour') == asMilliseconds(1, 'hour')
   * ```
   *
   * @param {Number|String} amount Amount, what of is decided by specifying unit (also takes a unit which implies an amount of 1)
   * @param {String} [unit] Time unit (s, hour, months etc.)
   * @returns {Number}
   * @category Parse & format
   */
  static asMilliseconds(amount, unit = null) {
    if (typeof amount === 'string') {
      unit = amount;
      amount = 1;
    }
    return DH$1.as('millisecond', amount, unit);
  }
  /**
   * Converts the passed Date to an accurate number of months passed since the epoch start.
   * @param {Date} time The Date to find the month value of
   * @returns {Number} The number of months since the system time epoch start. May be a fractional value
   */
  static asMonths(time) {
    const monthLength = DH$1.as('ms', DH$1.daysInMonth(time), 'day'),
      fraction = (time.valueOf() - DH$1.startOf(time, 'month').valueOf()) / monthLength;
    return time.getYear() * 12 + time.getMonth() + fraction;
  }
  static monthsToDate(months) {
    const intMonths = Math.floor(months),
      fraction = months - intMonths,
      result = new Date(0, intMonths),
      msInMonth = DH$1.as('ms', DH$1.daysInMonth(result), 'days');
    result.setTime(result.getTime() + fraction * msInMonth);
    return result;
  }
  /**
   * Converts a millisecond time delta to a human-readable form. For example `1000 * 60 * 60 * 50`
   * milliseconds would be rendered as `'2 days, 2 hours'`.
   * @param {Number} delta The millisecond delta value
   * @param {Object} [options] Formatting options
   * @param {Boolean} [options.abbrev] Pass `true` to use abbreviated unit names, eg `'2d, 2h'` for the above example
   * @param {String} [options.precision] The minimum precision unit
   * @param {String} [options.separator] The separator to use
   * @param {Boolean} [options.asString] Pass `false` to return the result as an array, eg ['2d', '2h'] for the above example
   * @returns {String} Formatted string
   * @category Parse & format
   */
  static formatDelta(delta, options) {
    let abbrev, unitName;
    if (typeof options === 'boolean') {
      abbrev = options;
    } else if (options) {
      abbrev = options.abbrev;
    }
    const deltaObj = this.getDelta(delta, options),
      result = [],
      sep = (options === null || options === void 0 ? void 0 : options.separator) || (abbrev ? '' : ' ');
    for (unitName in deltaObj) {
      result.push(`${deltaObj[unitName]}${sep}${unitName}`);
    }
    return (options === null || options === void 0 ? void 0 : options.asString) === false ? result : result.join(', ');
  }
  /**
   * Converts a millisecond time delta to an object structure. For example `1000 * 60 * 60 * 50`
   * milliseconds the result would be as:
   *
   * ```javascript
   * {
   *     day  : 2,
   *     hour : 2
   * }
   *```
   *
   * @param {Number} delta The millisecond delta value
   * @param {Object} [options] Formatting options
   * @param {Boolean} [options.abbrev] Pass `true` to use abbreviated unit names, eg `{ d: 2, h: 2 }` for the above example
   * @param {String} [options.precision] The minimum precision unit
   * @param {Boolean} [options.ignoreLocale] Pass true to return unlocalized unit name. Requires `abbrev` to be false
   * @param {String} [options.maxUnit] Name of the maximum unit in the output. e.g. if you pass `day` then you'll get
   * `{ h: 25 }` instead of `{ d: 1, h: 1 }`
   * @returns {Object} The object with the values for each unit
   */
  static getDelta(delta, options) {
    let abbrev, d, done, precision, unitName, maxUnit, ignoreLocale;
    if (typeof options === 'boolean') {
      abbrev = options;
    } else if (options) {
      abbrev = options.abbrev;
      precision = DH$1.normalizeUnit(options.precision);
      maxUnit = options.maxUnit;
      ignoreLocale = !abbrev && options.ignoreLocale;
    }
    const result = {},
      getUnit = abbrev ? DH$1.getShortNameOfUnit : DH$1.getLocalizedNameOfUnit;
    const units = maxUnit ? deltaUnits.slice(deltaUnits.indexOf(maxUnit)) : deltaUnits;
    // Loop downwards through the magnitude of units from year -> ms
    for (unitName of units) {
      d = DH$1.as(unitName, delta);
      done = precision === unitName;
      d = Math[done ? 'round' : 'floor'](d);
      // If there's a non-zero integer quantity of this unit, add it to result
      // and subtract from the delta, then go round to next unit down.
      if (d || done && !result.length) {
        result[ignoreLocale ? unitName : getUnit.call(DH$1, unitName, d !== 1)] = d;
        delta -= DH$1.as('ms', d, unitName);
      }
      if (done || !delta) {
        break;
      }
    }
    return result;
  }
  /**
   * Converts the specified amount of one unit (`fromUnit`) into an amount of another unit (`toUnit`).
   * @param {String} toUnit The name of units to convert to, eg: `'ms'`
   * @param {Number|String} amount The time to convert. Either the magnitude number form or a duration string such as '2d'
   * @param {String} [fromUnit='ms'] If the amount was passed as a number, the units to use to convert from
   * @returns {Number}
   * @category Parse & format
   */
  static as(toUnit, amount, fromUnit = 'ms') {
    // Allow DH.as('ms', '2d')
    if (typeof amount === 'string') {
      amount = DH$1.parseDuration(amount);
    }
    // Allow DH.as('ms', myDurationObject)
    if (typeof amount === 'object') {
      fromUnit = amount.unit;
      amount = amount.magnitude;
    }
    if (toUnit === fromUnit) {
      return amount;
    }
    toUnit = DH$1.normalizeUnit(toUnit);
    fromUnit = DH$1.normalizeUnit(fromUnit);
    if (toUnit === fromUnit) {
      return amount;
    }
    // validConversions[][] can be negative to signal that conversion is not exact, ignore sign here
    else if (unitMagnitudes[fromUnit] > unitMagnitudes[toUnit]) {
      return amount * Math.abs(validConversions[fromUnit][toUnit]);
    } else {
      return amount / Math.abs(validConversions[toUnit][fromUnit]);
    }
  }
  static formatContainsHourInfo(format) {
    const stripEscapeRe = /(\\.)/g,
      hourInfoRe = /([HhKkmSsAa]|LT|L{3,}|l{3,})/;
    return hourInfoRe.test(format.replace(stripEscapeRe, ''));
  }
  /**
   * Returns `true` for 24-hour format.
   * @param {String} format Date format
   * @returns {Boolean} `true` for 24-hour format
   * @category Parse & format
   */
  static is24HourFormat(format) {
    return DH$1.format(DH$1.getTime(13, 0, 0), format).includes('13');
  }
  //endregion
  //region Manipulate
  /**
   * Add days, hours etc. to a date. Always clones the date, original will be left unaffected.
   * @param {Date|String} date Original date
   * @param {Number|String|Core.data.Duration|DurationConfig} amount Amount of days, hours etc. or a string representation of a duration
   * as accepted by {@link #function-parseDuration-static} or an object with `{ magnitude, unit }` properties
   * @param {String} [unit='ms'] Unit for amount
   * @privateparam {Boolean} [clone=true] Pass `false` to affect the original
   * @returns {Date} New calculated date
   * @category Manipulate
   */
  static add(date, amount, unit = 'ms', clone = true) {
    let d;
    if (typeof date === 'string') {
      d = DH$1.parse(date);
    } else if (clone) {
      d = new Date(date.getTime());
    } else {
      d = date;
    }
    if (typeof amount === 'string') {
      const duration = DateHelper.parseDuration(amount);
      amount = duration.magnitude;
      unit = duration.unit;
    } else if (amount && typeof amount === 'object') {
      unit = amount.unit;
      amount = amount.magnitude;
    }
    if (!unit || amount === 0) {
      return d;
    }
    unit = DH$1.normalizeUnit(unit);
    switch (unit) {
      case 'millisecond':
        d.setTime(d.getTime() + amount);
        break;
      case 'second':
        d.setTime(d.getTime() + amount * 1000);
        break;
      case 'minute':
        d.setTime(d.getTime() + amount * 60000);
        break;
      case 'hour':
        d.setTime(d.getTime() + amount * 3600000);
        break;
      case 'day':
        // Integer value added, do calendar calculation to correctly handle DST etc.
        if (amount % 1 === 0) {
          d.setDate(d.getDate() + amount);
          // When crossing DST in Brazil, we expect hours to end up the same
          if (d.getHours() === 23 && date.getHours() === 0) {
            d.setHours(d.getHours() + 1);
          }
        }
        // No browsers support fractional values for dates any longer, do time based calculation
        else {
          d.setTime(d.getTime() + amount * 86400000);
        }
        break;
      case 'week':
        d.setDate(d.getDate() + amount * 7);
        break;
      case 'month':
        {
          let day = d.getDate();
          if (day > 28) {
            day = Math.min(day, DH$1.getLastDateOfMonth(DH$1.add(DH$1.getFirstDateOfMonth(d), amount, 'month')).getDate());
          }
          d.setDate(day);
          d.setMonth(d.getMonth() + amount);
          break;
        }
      case 'quarter':
        DH$1.add(d, amount * 3, 'month', false);
        break;
      case 'year':
        d.setFullYear(d.getFullYear() + amount);
        break;
      case 'decade':
        d.setFullYear(d.getFullYear() + amount * 10);
        break;
    }
    return d;
  }
  /**
   * Calculates the difference between two dates, in the specified unit.
   * @param {Date} start First date
   * @param {Date} end Second date
   * @param {String} [unit='ms'] Unit to calculate difference in
   * @param {Boolean} [fractional=true] Specify false to round result
   * @returns {Number} Difference in the specified unit
   * @category Manipulate
   */
  static diff(start, end, unit = 'ms', fractional = true) {
    unit = DH$1.normalizeUnit(unit);
    if (!start || !end) return 0;
    let amount;
    switch (unit) {
      case 'year':
        amount = DH$1.diff(start, end, 'month') / 12;
        break;
      case 'quarter':
        amount = DH$1.diff(start, end, 'month') / 3;
        break;
      case 'month':
        amount = (end.getFullYear() - start.getFullYear()) * 12 + (end.getMonth() - start.getMonth());
        if (amount === 0 && fractional) {
          amount = DH$1.diff(start, end, 'day', fractional) / DH$1.daysInMonth(start);
        }
        break;
      case 'week':
        amount = DH$1.diff(start, end, 'day') / 7;
        break;
      case 'day':
        {
          const dstDiff = start.getTimezoneOffset() - end.getTimezoneOffset();
          amount = (end - start + dstDiff * 60 * 1000) / 86400000;
          break;
        }
      case 'hour':
        amount = (end - start) / 3600000;
        break;
      case 'minute':
        amount = (end - start) / 60000;
        break;
      case 'second':
        amount = (end - start) / 1000;
        break;
      case 'millisecond':
        amount = end - start;
        break;
    }
    return fractional ? amount : Math.round(amount);
  }
  /**
   * Sets the date to the start of the specified unit, by default returning a clone of the date instead of changing it
   * in place.
   * @param {Date} date Original date
   * @param {String} [unit='day'] Start of this unit, `'day'`, `'month'` etc
   * @param {Boolean} [clone=true] Manipulate a copy of the date
   * @param {Number} [weekStartDay] The first day of week, `0-6` (Sunday-Saturday). Defaults to the {@link #property-weekStartDay-static}
   * @returns {Date} Manipulated date
   * @category Manipulate
   */
  static startOf(date, unit = 'day', clone = true, weekStartDay = DH$1.weekStartDay) {
    if (!date) {
      return null;
    }
    unit = DH$1.normalizeUnit(unit);
    if (clone) {
      date = DH$1.clone(date);
    }
    switch (unit) {
      case 'year':
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
        return date;
      case 'quarter':
        date.setMonth((DH$1.get(date, 'quarter') - 1) * 3, 1);
        date.setHours(0, 0, 0, 0);
        return date;
      case 'month':
        date.setDate(1);
        date.setHours(0, 0, 0, 0);
        return date;
      case 'week':
        {
          const delta = date.getDay() - weekStartDay;
          date.setDate(date.getDate() - delta);
          date.setHours(0, 0, 0, 0);
          return date;
        }
      case 'day':
        date.setHours(0, 0, 0, 0);
        return date;
      // Cant use setMinutes(0, 0, 0) etc. for DST transitions
      case 'hour':
        date.getMinutes() > 0 && date.setMinutes(0);
      // eslint-disable-next-line no-fallthrough
      case 'minute':
        date.getSeconds() > 0 && date.setSeconds(0);
      // eslint-disable-next-line no-fallthrough
      case 'second':
        date.getMilliseconds() > 0 && date.setMilliseconds(0);
      // eslint-disable-next-line no-fallthrough
      case 'millisecond':
        return date;
    }
  }
  /**
   * Returns the end point of the passed date, that is 00:00:00 of the day after the passed date.
   * @param {Date} date The date to return the end point of
   * @returns {Date} Manipulated date
   */
  static endOf(date) {
    return new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);
  }
  /**
   * Creates a clone of the specified date
   * @param {Date} date Original date
   * @returns {Date} Cloned date
   * @category Manipulate
   */
  static clone(date) {
    return new Date(date.getTime());
  }
  /**
   * Removes time from a date (same as calling {@link #function-startOf-static startOf(date)}).
   * @param {Date} date Date to remove time from
   * @param {Boolean} [clone=true] Manipulate a copy of the date
   * @returns {Date} Manipulated date
   * @category Manipulate
   */
  static clearTime(date, clone = true) {
    if (!date) {
      return null;
    }
    if (clone) {
      date = new Date(date.getTime());
    }
    date.setHours(0, 0, 0, 0);
    return date;
  }
  static midnight(date, inclusive) {
    let ret = DH$1.clearTime(date);
    if (inclusive && ret < date) {
      ret = DH$1.add(ret, 1, 'd');
    }
    return ret;
  }
  /**
   * Returns the elapsed milliseconds from the start of the specified date.
   * @param {Date} date Date to remove date from
   * @param {String} [unit='ms'] The time unit to return
   * @returns {Number} The elapsed milliseconds from the start of the specified date
   * @category Manipulate
   */
  static getTimeOfDay(date, unit = 'ms') {
    const t = date.getHours() * validConversions.hour.millisecond + date.getMinutes() * validConversions.minute.millisecond + date.getSeconds() * validConversions.second.millisecond + date.getMilliseconds();
    return unit === 'ms' ? t : DH$1.as(unit, t, 'ms');
  }
  /**
   * Sets a part of a date (in place).
   * @param {Date} date Date to manipulate
   * @param {String|Object} unit Part of date to set, for example `'minute'`. Or an object like `{ second: 1, minute: 1 }`
   * @param {Number} amount Value to set
   * @returns {Date} Passed date instance modified according to the arguments
   * @category Manipulate
   */
  static set(date, unit, amount) {
    if (!unit) {
      return date;
    }
    if (typeof unit === 'string') {
      switch (DH$1.normalizeUnit(unit)) {
        case 'millisecond':
          // Setting value to 0 when it is 0 at DST crossing messes it up
          if (amount !== 0 || date.getMilliseconds() > 0) {
            date.setMilliseconds(amount);
          }
          break;
        case 'second':
          // Setting value to 0 when it is 0 at DST crossing messes it up
          if (amount !== 0 || date.getSeconds() > 0) {
            date.setSeconds(amount);
          }
          break;
        case 'minute':
          // Setting value to 0 when it is 0 at DST crossing messes it up
          if (amount !== 0 || date.getMinutes() > 0) {
            date.setMinutes(amount);
          }
          break;
        case 'hour':
          date.setHours(amount);
          break;
        case 'day':
        case 'date':
          date.setDate(amount);
          break;
        case 'week':
          throw new Error('week not implemented');
        case 'month':
          date.setMonth(amount);
          break;
        case 'quarter':
          // Setting quarter = first day of first month of that quarter
          date.setDate(1);
          date.setMonth((amount - 1) * 3);
          break;
        case 'year':
          date.setFullYear(amount);
          break;
      }
    } else {
      Object.entries(unit)
      // Make sure smallest unit goes first, to not change month before changing day
      .sort((a, b) => unitMagnitudes[a[0]] - unitMagnitudes[b[0]]).forEach(([unit, amount]) => {
        DH$1.set(date, unit, amount);
      });
    }
    return date;
  }
  static setDateToMidday(date, clone = true) {
    return DH$1.set(DH$1.clearTime(date, clone), 'hour', 12);
  }
  /**
   * Constrains the date within a min and a max date.
   * @param {Date} date The date to constrain
   * @param {Date} [min] Min date
   * @param {Date} [max] Max date
   * @returns {Date} The constrained date
   * @category Manipulate
   */
  static constrain(date, min, max) {
    if (min != null) {
      date = DH$1.max(date, min);
    }
    return max == null ? date : DH$1.min(date, max);
  }
  /**
   * Returns time with default year, month, and day (Jan 1, 2020).
   * @param {Number|Date} hours Hours value or the full date to extract the time of
   * @param {Number} [minutes=0] Minutes value
   * @param {Number} [seconds=0] Seconds value
   * @param {Number} [ms=0] Milliseconds value
   * @returns {Date} A new default date with the time extracted from the given date or from the time values provided individually
   * @category Manipulate
   */
  static getTime(hours, minutes = 0, seconds = 0, ms = 0) {
    if (hours instanceof Date) {
      ms = hours.getMilliseconds();
      seconds = hours.getSeconds();
      minutes = hours.getMinutes();
      hours = hours.getHours();
    }
    return new Date(DEFAULT_YEAR, DEFAULT_MONTH, DEFAULT_DAY, hours, minutes, seconds, ms);
  }
  /**
   * Copies hours, minutes, seconds, milliseconds from one date to another.
   *
   * @param {Date} targetDate The target date
   * @param {Date} sourceDate The source date
   * @returns {Date} The adjusted target date
   * @category Manipulate
   * @static
   */
  static copyTimeValues(targetDate, sourceDate) {
    targetDate.setHours(sourceDate.getHours());
    targetDate.setMinutes(sourceDate.getMinutes());
    targetDate.setSeconds(sourceDate.getSeconds());
    targetDate.setMilliseconds(sourceDate.getMilliseconds());
    return targetDate;
  }
  //endregion
  //region Comparison
  static get isDSTEnabled() {
    const year = new Date().getFullYear(),
      jan = new Date(year, 0, 1),
      jul = new Date(year, 6, 1);
    return jan.getTimezoneOffset() !== jul.getTimezoneOffset();
  }
  static isDST(date) {
    const year = date.getFullYear(),
      jan = new Date(year, 0, 1),
      jul = new Date(year, 6, 1);
    return date.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
  }
  /**
   * Determines if a date precedes another.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @returns {Boolean} `true` if first precedes second, otherwise false
   * @category Comparison
   */
  static isBefore(first, second) {
    return first < second;
  }
  /**
   * Determines if a date succeeds another.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @returns {Boolean} `true` if first succeeds second, otherwise false
   * @category Comparison
   */
  static isAfter(first, second) {
    return first > second;
  }
  /**
   * Checks if two dates are equal.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @param {String} [unit] Unit to calculate difference in. If not given, the comparison will be done up to a millisecond
   * @returns {Boolean} `true` if the dates are equal
   * @category Comparison
   */
  static isEqual(first, second, unit = null) {
    if (unit === null) {
      // https://jsbench.me/3jk2bom2r3/1
      // https://jsbench.me/ltkb3vk0ji/1 (more flavors) - getTime is >2x faster vs valueOf/Number/op+
      return first && second && first.getTime() === second.getTime();
    }
    return DH$1.startOf(first, unit) - DH$1.startOf(second, unit) === 0;
  }
  /**
   * Compares two dates using the specified precision.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @param {String} [unit] Unit to calculate difference in. If not given, the comparison will be done up to a millisecond
   * @returns {Number} `0` = equal, `-1` = first before second, `1` = first after second
   * @category Comparison
   */
  static compare(first, second, unit = null) {
    // Unit specified, cut the rest out
    if (unit) {
      first = DH$1.startOf(first, unit);
      second = DH$1.startOf(second, unit);
    }
    // Comparison on ms level
    if (first < second) return -1;
    if (first > second) return 1;
    return 0;
  }
  /**
   * Coerces the passed Date between the passed minimum and maximum values.
   * @param {Date} date The date to clamp between the `min` and `max`
   * @param {Date} min The minimum Date
   * @param {Date} max The maximum Date
   * @returns {Date} If the passed `date` is valid, a *new* Date object which is clamped between the `min` and `max`
   */
  static clamp(date, min, max) {
    if (!isNaN(date)) {
      if (min != null) {
        date = Math.max(date, min);
      }
      if (max != null) {
        date = Math.min(date, max);
      }
      return new Date(date);
    }
  }
  static isSameDate(first, second) {
    return DH$1.compare(first, second, 'd') === 0;
  }
  static isSameTime(first, second) {
    return first.getHours() === second.getHours() && first.getMinutes() === second.getMinutes() && first.getSeconds() === second.getSeconds() && first.getMilliseconds() === second.getMilliseconds();
  }
  /**
   * Checks if date is the start of specified unit.
   * @param {Date} date Date
   * @param {String} unit Time unit
   * @returns {Boolean} `true` if date is the start of specified unit
   * @category Comparison
   */
  static isStartOf(date, unit) {
    return DH$1.isEqual(date, DH$1.startOf(date, unit));
  }
  /**
   * Checks if this date is `>= start` and `< end`.
   * @param {Date} date The source date
   * @param {Date} start Start date
   * @param {Date} end End date
   * @returns {Boolean} `true` if this date falls on or between the given start and end dates
   * @category Comparison
   */
  static betweenLesser(date, start, end) {
    //return start <= date && date < end;
    return start.getTime() <= date.getTime() && date.getTime() < end.getTime();
  }
  /**
   * Checks if this date is `>= start` and `<= end`.
   * @param {Date} date The source date
   * @param {Date} start Start date
   * @param {Date} end End date
   * @returns {Boolean} `true` if this date falls on or between the given start and end dates
   * @category Comparison
   */
  static betweenLesserEqual(date, start, end) {
    return start.getTime() <= date.getTime() && date.getTime() <= end.getTime();
  }
  /**
   * Returns `true` if dates intersect.
   * @param {Date} date1Start Start date of first span
   * @param {Date} date1End End date of first span
   * @param {Date} date2Start Start date of second span
   * @param {Date} date2End End date of second span
   * @returns {Boolean} Returns `true` if dates intersect
   * @category Comparison
   */
  static intersectSpans(date1Start, date1End, date2Start, date2End) {
    return DH$1.betweenLesser(date1Start, date2Start, date2End) || DH$1.betweenLesser(date2Start, date1Start, date1End);
  }
  /**
   * Compare two units. Returns `1` if first param is a greater unit than second param, `-1` if the opposite is true or `0` if they're equal.
   * @param {String} unit1 The 1st unit
   * @param {String} unit2 The 2nd unit
   * @returns {Number} Returns `1` if first param is a greater unit than second param, `-1` if the opposite is true or `0` if they're equal
   * @category Comparison
   */
  static compareUnits(unit1, unit2) {
    return Math.sign(unitMagnitudes[DH$1.normalizeUnit(unit1)] - unitMagnitudes[DH$1.normalizeUnit(unit2)]);
  }
  /**
   * Returns `true` if the first time span completely 'covers' the second time span.
   *
   * @example
   * DateHelper.timeSpanContains(
   *     new Date(2010, 1, 2),
   *     new Date(2010, 1, 5),
   *     new Date(2010, 1, 3),
   *     new Date(2010, 1, 4)
   * ) ==> true
   * DateHelper.timeSpanContains(
   *   new Date(2010, 1, 2),
   *   new Date(2010, 1, 5),
   *   new Date(2010, 1, 3),
   *   new Date(2010, 1, 6)
   * ) ==> false
   *
   * @param {Date} spanStart The start date for initial time span
   * @param {Date} spanEnd The end date for initial time span
   * @param {Date} otherSpanStart The start date for the 2nd time span
   * @param {Date} otherSpanEnd The end date for the 2nd time span
   * @returns {Boolean} `true` if the first time span completely 'covers' the second time span
   * @category Comparison
   */
  static timeSpanContains(spanStart, spanEnd, otherSpanStart, otherSpanEnd) {
    return otherSpanStart - spanStart >= 0 && spanEnd - otherSpanEnd >= 0;
  }
  //endregion
  //region Query
  /**
   * Get the first day of week, 0-6 (Sunday-Saturday).
   * This is determined by the current locale's `DateHelper.weekStartDay` parameter.
   * @property {Number}
   * @readonly
   */
  static get weekStartDay() {
    // Cache is reset in applyLocale
    if (DH$1._weekStartDay == null) {
      // Defaults to 0, should not need to happen in real world scenarios when a locale is always loaded
      DH$1._weekStartDay = this.localize('L{weekStartDay}') || 0;
    }
    return DH$1._weekStartDay;
  }
  /**
   * Get non-working days as an object where keys are day indices, 0-6 (Sunday-Saturday), and the value is `true`.
   * This is determined by the current locale's `DateHelper.nonWorkingDays` parameter.
   *
   * For example:
   * ```javascript
   * {
   *     0 : true, // Sunday
   *     6 : true  // Saturday
   * }
   * ```
   *
   * @property {Object<Number,Boolean>}
   * @readonly
   */
  static get nonWorkingDays() {
    return {
      ...this.localize('L{nonWorkingDays}')
    };
  }
  /**
   * Get non-working days as an array of day indices, 0-6 (Sunday-Saturday).
   * This is determined by the current locale's `DateHelper.nonWorkingDays` parameter.
   *
   * For example:
   *
   * ```javascript
   * [ 0, 6 ] // Sunday & Saturday
   * ```
   *
   * @property {Number[]}
   * @readonly
   * @internal
   */
  static get nonWorkingDaysAsArray() {
    // transform string keys to integers
    return Object.keys(this.nonWorkingDays).map(Number);
  }
  /**
   * Get weekend days as an object where keys are day indices, 0-6 (Sunday-Saturday), and the value is `true`.
   * Weekends are days which are declared as weekend days by the selected country and defined by the current locale's
   * `DateHelper.weekends` parameter.
   * To get non-working days see {@link #property-nonWorkingDays-static}.
   *
   * For example:
   * ```javascript
   * {
   *     0 : true, // Sunday
   *     6 : true  // Saturday
   * }
   * ```
   * @property {Object<Number,Boolean>}
   * @readonly
   * @internal
   */
  static get weekends() {
    return {
      ...this.localize('L{weekends}')
    };
  }
  /**
   * Get the specified part of a date.
   * @param {Date} date
   * @param {String} unit Part of date, hour, minute etc.
   * @returns {Number} The requested part of the specified date
   * @category Query
   */
  static get(date, unit) {
    switch (DH$1.normalizeUnit(unit)) {
      case 'millisecond':
        return date.getMilliseconds();
      case 'second':
        return date.getSeconds();
      case 'minute':
        return date.getMinutes();
      case 'hour':
        return date.getHours();
      case 'date':
      case 'day':
        // Scheduler has a lot of calculations expecting this to work
        return date.getDate();
      case 'week':
        return formats.W(date);
      case 'month':
        return date.getMonth();
      case 'quarter':
        return Math.floor(date.getMonth() / 3) + 1;
      case 'year':
        return date.getFullYear();
    }
    return null;
  }
  /**
   * Get number of days in the current year for the supplied date.
   * @param {Date} date Date to check
   * @returns {Number} Days in year
   * @category Query
   * @internal
   */
  static daysInYear(date) {
    const fullYear = date.getFullYear(),
      duration = new Date(fullYear + 1, 0, 1) - new Date(fullYear, 0, 1);
    return this.as('day', duration);
  }
  /**
   * Get number of days in the current month for the supplied date.
   * @param {Date} date Date which month should be checked
   * @returns {Number} Days in month
   * @category Query
   */
  static daysInMonth(date) {
    return 32 - new Date(date.getFullYear(), date.getMonth(), 32).getDate();
  }
  /**
   * Get number of hours in the current day for the supplied date.
   * @param {Date} date Date to check
   * @returns {Number} Hours in day
   * @category Query
   * @internal
   */
  static hoursInDay(date) {
    const fullYear = date.getFullYear(),
      month = date.getMonth(),
      day = date.getDate(),
      duration = new Date(fullYear, month, day + 1) - new Date(fullYear, month, day);
    return this.as('hour', duration);
  }
  /**
   * Converts unit related to the date to actual amount of milliseconds in it. Takes into account leap years and
   * different duration of months.
   * @param {Date} date Date
   * @param {String} unit Time unit
   * @returns {Number} Returns amount of milliseconds
   * @internal
   */
  static getNormalizedUnitDuration(date, unit) {
    let result;
    switch (unit) {
      case 'month':
        result = DH$1.asMilliseconds(DH$1.daysInMonth(date), 'day');
        break;
      case 'year':
        result = DH$1.asMilliseconds(DH$1.daysInYear(date), 'day');
        break;
      case 'day':
        result = DH$1.asMilliseconds(DH$1.hoursInDay(date), 'hour');
        break;
      default:
        result = DH$1.asMilliseconds(unit);
    }
    return result;
  }
  /**
   * Get the first date of the month for the supplied date.
   * @param {Date} date Date
   * @returns {Date} New Date instance
   * @category Query
   */
  static getFirstDateOfMonth(date) {
    return new Date(date.getFullYear(), date.getMonth(), 1);
  }
  /**
   * Get the last date of the month for the supplied date.
   * @param {Date} date Date
   * @returns {Date} New Date instance
   * @category Query
   */
  static getLastDateOfMonth(date) {
    return new Date(date.getFullYear(), date.getMonth() + 1, 0);
  }
  /**
   * Get the earliest of two dates.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @returns {Date} Earliest date
   * @category Query
   */
  static min(first, second) {
    return first.getTime() < second.getTime() ? first : second;
  }
  /**
   * Get the latest of two dates.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @returns {Date} Latest date
   * @category Query
   */
  static max(first, second) {
    return first.getTime() > second.getTime() ? first : second;
  }
  /**
   * Get an incremented date. Incrementation based on specified unit and optional amount.
   * @param {Date} date Date
   * @param {String} unit Time unit
   * @param {Number} [increment=1] Increment amount
   * @param {Number} [weekStartDay] Will default to what is set in locale
   * @returns {Date} New Date instance
   * @category Query
   */
  static getNext(date, unit, increment = 1, weekStartDay = DH$1.weekStartDay) {
    if (unit === 'week') {
      const dt = DH$1.clone(date),
        day = dt.getDay();
      DH$1.startOf(dt, 'day', false);
      DH$1.add(dt, weekStartDay - day + 7 * (increment - (weekStartDay <= day ? 0 : 1)), 'day', false);
      // For south american timezones, midnight does not exist on DST transitions, adjust...
      if (dt.getDay() !== weekStartDay) {
        DH$1.add(dt, 1, 'hour');
      }
      return dt;
    }
    return DH$1.startOf(DH$1.add(date, increment, unit), unit, false);
  }
  /**
   * Checks if date object is valid.
   *
   * For example:
   *
   * ```javascript
   * date = new Date('foo')
   * date instanceof Date // true
   * date.toString() // Invalid Date
   * isNaN(date) // true
   * DateHelper.isValidDate(date) // false
   *
   * date = new Date()
   * date instanceof Date // true
   * date.toString() // Mon Jan 13 2020 18:27:38 GMT+0300 (GMT+03:00)
   * isNaN(date) // false
   * DateHelper.isValidDate(date) // true
   * ```
   *
   * @param {Date} date Date
   * @returns {Boolean} `true` if date object is valid
   */
  static isValidDate(date) {
    return DH$1.isDate(date) && !isNaN(date);
  }
  /**
   * Checks if value is a date object. Allows to recognize date object even from another context,
   * like the top frame when used in an iframe.
   *
   * @param {*} value Value to check
   * @returns {Boolean} `true` if value is a date object
   */
  static isDate(value) {
    // see https://jsbench.me/s7kb49w83j/1 (cannot use instanceof cross-frame):
    return value && toString$1.call(value) === DATE_TYPE;
  }
  /**
   * Get the start of the next day.
   * @param {Date} date Date
   * @param {Boolean} [clone=false] Clone date
   * @param {Boolean} [noNeedToClearTime=false] Flag to not clear time from the result
   * @returns {Date} Passed Date or new Date instance, depending on the `clone` flag
   * @category Query
   */
  static getStartOfNextDay(date, clone = false, noNeedToClearTime = false) {
    let nextDay = DH$1.add(noNeedToClearTime ? date : DH$1.clearTime(date, clone), 1, 'day');
    // DST case
    if (nextDay.getDate() === date.getDate()) {
      const offsetNextDay = DH$1.add(DH$1.clearTime(date, clone), 2, 'day').getTimezoneOffset(),
        offsetDate = date.getTimezoneOffset();
      nextDay = DH$1.add(nextDay, offsetDate - offsetNextDay, 'minute');
    }
    return nextDay;
  }
  /**
   * Get the end of previous day.
   * @param {Date} date Date
   * @param {Boolean} [noNeedToClearTime=false] Flag to not clear time from the result
   * @returns {Date} New Date instance
   * @category Query
   */
  static getEndOfPreviousDay(date, noNeedToClearTime = false) {
    const dateOnly = noNeedToClearTime ? date : DH$1.clearTime(date, true);
    // dates are different
    if (dateOnly - date) {
      return dateOnly;
    } else {
      return DH$1.add(dateOnly, -1, 'day');
    }
  }
  /**
   * Returns a string describing the specified week. For example, `'39, September 2020'` or `'40, Sep - Oct 2020'`.
   * @param {Date} startDate Start date
   * @param {Date} [endDate] End date
   * @returns {String} String describing the specified week
   * @internal
   */
  static getWeekDescription(startDate, endDate = startDate) {
    const monthDesc = startDate.getMonth() === endDate.getMonth() ? DateHelper.format(startDate, 'MMMM') : `${DateHelper.format(startDate, 'MMM')} - ${DateHelper.format(endDate, 'MMM')}`,
      week = DateHelper.getWeekNumber(startDate);
    return `${week[1]}, ${monthDesc} ${week[0]}`;
  }
  /**
   * Get week number for the date.
   * @param {Date} date The date
   * @param {Number} [weekStartDay] The first day of week, 0-6 (Sunday-Saturday). Defaults to the {@link #property-weekStartDay-static}
   * @returns {Number[]} year and week number
   * @category Query
   */
  static getWeekNumber(date, weekStartDay = DateHelper.weekStartDay) {
    const jan01 = new Date(date.getFullYear(), 0, 1),
      dec31 = new Date(date.getFullYear(), 11, 31),
      firstDay = normalizeDay(jan01.getDay() - weekStartDay),
      lastDay = normalizeDay(dec31.getDay() - weekStartDay),
      dayNumber = getDayDiff(date, jan01);
    let weekNumber;
    // Check if the year starts before the middle of a week
    if (firstDay < 4) {
      weekNumber = Math.floor((dayNumber + firstDay - 1) / 7) + 1;
    } else {
      weekNumber = Math.floor((dayNumber + firstDay - 1) / 7);
    }
    if (weekNumber) {
      let year = date.getFullYear();
      // Might be week 1 of next year if the year ends before day 3 (0 based)
      if (weekNumber === 53 && lastDay < 3) {
        year++;
        weekNumber = 1;
      }
      return [year, weekNumber];
    }
    // We're in week zero which is the last week of the previous year, so ask what
    // week encapsulates 31 Dec in the previous year.
    const lastWeekOfLastYear = DateHelper.getWeekNumber(new Date(date.getFullYear() - 1, 11, 31))[1];
    return [date.getFullYear() - 1, lastWeekOfLastYear];
  }
  //endregion
  //region Unit helpers
  /**
   * Turns `(10, 'day')` into `'10 days'` etc.
   * @param {Number} count Amount of unit
   * @param {String} unit Unit, will be normalized (days, d -> day etc.)
   * @returns {String} Amount formatted to string
   * @category Unit helpers
   */
  static formatCount(count, unit) {
    unit = DH$1.normalizeUnit(unit);
    if (count !== 1) unit += 's';
    return count + ' ' + unit;
  }
  /**
   * Get the ratio between two units ( year, month -> 1/12 ).
   * @param {String} baseUnit Base time unit
   * @param {String} unit Time unit
   * @param {Boolean} [acceptEstimate=false] If `true`, process negative values of validConversions
   * @returns {Number} Ratio
   * @category Unit helpers
   */
  static getUnitToBaseUnitRatio(baseUnit, unit, acceptEstimate = false) {
    baseUnit = DH$1.normalizeUnit(baseUnit);
    unit = DH$1.normalizeUnit(unit);
    if (baseUnit === unit) return 1;
    // Some validConversions have negative sign to signal that it is not an exact conversion.
    // Ignore those here unless acceptEstimate is provided.
    if (validConversions[baseUnit] && validConversions[baseUnit][unit] && (acceptEstimate || validConversions[baseUnit][unit] > 0)) {
      return 1 / DH$1.as(unit, 1, baseUnit);
    }
    if (validConversions[unit] && validConversions[unit][baseUnit] && (acceptEstimate || validConversions[unit][baseUnit] > 0)) {
      return DH$1.as(baseUnit, 1, unit);
    }
    return -1;
  }
  /**
   * Returns a localized abbreviated form of the name of the duration unit.
   * For example in the `EN` locale, for `'qrt'` it will return `'q'`.
   * @param {String} unit Duration unit
   * @returns {String} Localized abbreviated form of the name of the duration unit
   * @category Unit helpers
   */
  static getShortNameOfUnit(unit) {
    // Convert abbreviations to the canonical name.
    // See locale file and the applyLocale method below.
    unit = DH$1.parseTimeUnit(unit);
    // unitLookup is keyed by eg 'DAY', 'day', 'MILLISECOND', 'millisecond' etc
    return DH$1.unitLookup[unit].abbrev;
  }
  /**
   * Returns a localized full name of the duration unit.
   *
   * For example in the `EN` locale, for `'d'` it will return either
   * `'day'` or `'days'`, depending on the `plural` argument
   *
   * Preserves casing of first letter.
   *
   * @static
   * @param {String} unit Time unit
   * @param {Boolean} [plural=false] Whether to return a plural name or singular
   * @returns {String} Localized full name of the duration unit
   * @category Unit helpers
   */
  static getLocalizedNameOfUnit(unit, plural = false) {
    const capitalize = unit.charAt(0) === unit.charAt(0).toUpperCase();
    // Normalize to not have to have translations for each variation used in code
    unit = DH$1.normalizeUnit(unit);
    // Convert abbreviations to the canonical name.
    // See locale file and the applyLocale method below.
    unit = DH$1.parseTimeUnit(unit);
    // Translate
    // unitLookup is keyed by eg 'DAY', 'day', 'MILLISECOND', 'millisecond' etc
    unit = DH$1.unitLookup[unit][plural ? 'plural' : 'single'];
    // Preserve casing of first letter
    if (capitalize) {
      unit = StringHelper.capitalize(unit);
    }
    return unit;
  }
  /**
   * Normalizes a unit for easier usage in conditionals. For example `'year'`, `'years'`, `'y'` -> `'year'`.
   * @param {String} unit Time unit
   * @returns {String} Normalized unit name
   * @category Unit helpers
   */
  static normalizeUnit(unit) {
    if (!unit) {
      return null;
    }
    const unitLower = unit.toLowerCase();
    if (unitLower === 'date') {
      return unitLower;
    }
    return canonicalUnitNames.includes(unitLower)
    // Already valid
    ? unitLower
    // Trying specified case first, since we have both 'M' for month and 'm' for minute
    : normalizedUnits[unit] || normalizedUnits[unitLower];
  }
  static getUnitByName(name) {
    // Allow either a canonical name to be passed, or, if that fails, parse it as a localized name or abbreviation.
    return DH$1.normalizeUnit(name) || DH$1.normalizeUnit(DH$1.parseTimeUnit(name));
  }
  /**
   * Returns a duration of the timeframe in the given unit.
   * @param {Date} start The start date of the timeframe
   * @param {Date} end The end date of the timeframe
   * @param {String} unit Duration unit
   * @privateparam {Boolean} [doNotRound]
   * @returns {Number} The duration in the units
   * @category Unit helpers
   * @ignore
   */
  static getDurationInUnit(start, end, unit, doNotRound) {
    return DH$1.diff(start, end, unit, doNotRound);
  }
  /**
   * Checks if two date units align.
   * @private
   * @param {String} majorUnit Major time unit
   * @param {String} minorUnit Minor time unit
   * @returns {Boolean} `true` if two date units align
   * @category Unit helpers
   */
  static doesUnitsAlign(majorUnit, minorUnit) {
    return !(majorUnit !== minorUnit && minorUnit === 'week');
  }
  static getSmallerUnit(unit) {
    return canonicalUnitNames[unitMagnitudes[DH$1.normalizeUnit(unit)] - 1] || null;
  }
  static getLargerUnit(unit) {
    return canonicalUnitNames[unitMagnitudes[DH$1.normalizeUnit(unit)] + 1] || null;
  }
  /**
   *
   * Rounds the passed Date value to the nearest `increment` value.
   *
   * Optionally may round relative to a certain base time point.
   *
   * For example `DH.round(new Date('2020-01-01T09:35'), '30 min', new Date('2020-01-01T09:15'))`
   * would round to 9:45 because that's the nearest integer number of 30 minute increments
   * from the base.
   *
   * Note that `base` is ignored when rounding to weeks. The configured {@link #property-weekStartDay-static}
   * dictates what the base of a week is.
   *
   * @param {Date} time The time to round
   * @param {String|Number} increment A millisecond value by which to round the time
   * May be specified in string form eg: `'15 minutes'`
   * @param {Date} [base] The start from which to apply the rounding
   * @param {Number} [weekStartDay] Will default to what is set in locale
   * @returns {Date} New Date instance
   */
  static round(time, increment, base, weekStartDay) {
    return DH$1.snap('round', time, increment, base, weekStartDay);
  }
  /**
   *
   * Floor the passed Date value to the nearest `increment` value.
   *
   * Optionally may floor relative to a certain base time point.
   *
   * For example `DH.floor(new Date('2020-01-01T09:35'), '30 min', new Date('2020-01-01T09:15'))`
   * would floor to 9:15 because that's the closest lower integer number of 30 minute increments
   * from the base.
   *
   * Note that `base` is ignored when flooring to weeks. The configured {@link #property-weekStartDay-static}
   * dictates what the base of a week is.
   *
   * @param {Date} time The time to floor
   * @param {String|Number|DurationConfig|Object} increment A numeric millisecond value by which to floor the time.
   * or a duration in string form eg `'30 min'` or object form : `{unit: 'minute', magnitude: 30}`
   * or `{unit: 'minute', increment: 30}`
   * @param {Date} [base] The start from which to apply the flooring
   * @param {Number} [weekStartDay] Will default to what is set in locale
   * @returns {Date} New Date instance
   */
  static floor(time, increment, base, weekStartDay) {
    return DH$1.snap('floor', time, increment, base, weekStartDay);
  }
  /**
   *
   * Ceils the passed Date value to the nearest `increment` value.
   *
   * Optionally may ceil relative to a certain base time point.
   *
   * For example `DH.ceil(new Date('2020-01-01T09:35'), '30 min', new Date('2020-01-01T09:15'))`
   * would ceil to 9:45 because that's the closest higher integer number of 30 minute increments
   * from the base.
   *
   * Note that `base` is ignored when ceiling to weeks. Use weekStartDay argument which default to the configured
   * {@link #property-weekStartDay-static} dictates what the base of a week is
   *
   * @param {Date} time The time to ceil
   * @param {String|Number|DurationConfig|Object} increment A numeric millisecond value by which to ceil the time
   * or a duration in string form eg `'30 min'` or object form : `{unit: 'minute', magnitude: 30}`
   * or `{unit: 'minute', increment: 30}`
   * @param {Date} [base] The start from which to apply the ceiling
   * @param {Number} [weekStartDay] Will default to what is set in locale
   * @returns {Date} New Date instance
   */
  static ceil(time, increment, base, weekStartDay) {
    return DH$1.snap('ceil', time, increment, base, weekStartDay);
  }
  /**
   * Implementation for round, floor and ceil.
   * @internal
   */
  static snap(operation, time, increment, base, weekStartDay = DH$1.weekStartDay) {
    const snapFn = snapFns[operation];
    if (typeof increment === 'string') {
      increment = DH$1.parseDuration(increment);
    }
    if (Objects.isObject(increment)) {
      // Allow {unit: 'minute', increment: 30} or {unit: 'minute', magnitude: 30}
      // parseDuration produces 'magnitude'. The Scheduler's TimeAxis uses 'increment'
      // in its resolution object, so we allow that too.
      const magnitude = increment.magnitude || increment.increment;
      // increment is in weeks, months, quarters or years, then it can't be handled
      // using millisecond arithmetic.
      switch (increment.unit) {
        case 'week':
          {
            const weekDay = time.getDay();
            // weekStartDay gives our base
            // Our base is the start of the week
            base = DH$1.add(DH$1.clearTime(time), weekDay >= weekStartDay ? weekStartDay - weekDay : -(weekDay - weekStartDay + 7), 'day');
            return DH$1[operation](time, `${magnitude * 7} days`, base);
          }
        case 'month':
          {
            // Express the time as a number of months from epoch start.
            // May be a fraction, eg the 15th will be 0.5 through a month.
            time = DH$1.asMonths(time);
            let resultMonths;
            // Snap the month count in the way requested
            if (base) {
              base = DH$1.asMonths(base);
              resultMonths = time + snapFn(time - base, magnitude);
            } else {
              resultMonths = snapFn(time, magnitude);
            }
            // Convert resulting month value back to a date
            return DH$1.monthsToDate(resultMonths);
          }
        case 'quarter':
          return DH$1[operation](time, `${magnitude * 3} months`, base);
        case 'year':
          return DH$1[operation](time, `${magnitude * 12} months`, base);
        case 'decade':
          // We assume that decades begin with a year divisible by 10
          return DH$1[operation](time, `${magnitude * 10} years`, base);
      }
      // Convert to a millisecond value
      increment = DH$1.as('ms', magnitude, increment.unit);
    }
    // It's a simple round to milliseconds
    if (base) {
      const tzChange = DH$1.as('ms', base.getTimezoneOffset() - time.getTimezoneOffset(), 'ms');
      return new Date(base.valueOf() + snapFn(DH$1.diff(base, time, 'ms') + tzChange, increment));
    } else {
      const offset = time.getTimezoneOffset() * 60 * 1000;
      // Assuming current TZ is GMT+3
      // new Date(2000, 0, 1) / 86400000      -> 10956.875
      // new Date(2000, 0, 1, 3) / 86400000   -> 10957
      // Before calculation we need to align time value of the current timezone to GMT+0
      // And after calculate we need to adjust time back
      return new Date(snapFn(time.valueOf() - offset, increment) + offset);
    }
  }
  //endregion
  //region Date picker format
  /**
   * Parses a typed duration value according to locale rules.
   *
   * The value is taken to be a string consisting of the numeric magnitude and the units:
   * - The numeric magnitude can be either an integer or a float value. Both `','` and `'.'` are valid decimal separators.
   * - The units may be a recognised unit abbreviation of this locale or the full local unit name.
   *
   * For example:
   * `'2d'`, `'2 d'`, `'2 day'`, `'2 days'` will be turned into `{ magnitude : 2, unit : 'day' }`
   * `'2.5d'`, `'2,5 d'`, `'2.5 day'`, `'2,5 days'` will be turned into `{ magnitude : 2.5, unit : 'day' }`
   *
   * **NOTE:** Doesn't work with complex values like `'2 days, 2 hours'`
   *
   * @param {String} value The value to parse
   * @param {Boolean} [allowDecimals=true] Decimals are allowed in the magnitude
   * @param {String} [defaultUnit] Default unit to use if only magnitude passed
   * @returns {DurationConfig} If successfully parsed, the result contains two properties, `magnitude` being a number, and
   * `unit` being the canonical unit name, *NOT* a localized name. If parsing was unsuccessful, `null` is returned
   * @category Parse & format
   */
  static parseDuration(value, allowDecimals = true, defaultUnit) {
    var _match$;
    const durationRegEx = allowDecimals ? withDecimalsDurationRegex : noDecimalsDurationRegex,
      match = durationRegEx.exec(value);
    if (value == null || !match) {
      return null;
    }
    const magnitude = parseNumber((_match$ = match[1]) === null || _match$ === void 0 ? void 0 : _match$.replace(',', '.')),
      unit = DH$1.parseTimeUnit(match[2]) || defaultUnit;
    if (!unit) {
      return null;
    }
    return {
      magnitude,
      unit
    };
  }
  /**
   * Parses a typed unit name, for example `'ms'` or `'hr'` or `'yr'` into the
   * canonical form of the unit name which may be passed to {@link #function-add-static}
   * or {@link #function-diff-static}.
   * @param {*} unitName Time unit name
   * @category Parse & format
   */
  static parseTimeUnit(unitName) {
    // NOTE: In case you get a crash here when running tests, it is caused by missing locale. Build locales
    // using `scripts/build.js locales` to resolve.
    const unitMatch = unitName == null ? null : DH$1.durationRegEx.exec(unitName.toLowerCase());
    if (!unitMatch) {
      return null;
    }
    // See which group in the unitAbbrRegEx matched match[2]
    for (let unitOrdinal = 0; unitOrdinal < canonicalUnitNames.length; unitOrdinal++) {
      if (unitMatch[unitOrdinal + 1]) {
        return canonicalUnitNames[unitOrdinal];
      }
    }
  }
  //endregion
  //region Internal
  static getGMTOffset(date = new Date()) {
    if (!date) {
      return;
    }
    const offsetInMinutes = date.getTimezoneOffset();
    // return 'Z' for UTC
    if (!offsetInMinutes) return 'Z';
    return (offsetInMinutes > 0 ? '-' : '+') + Math.abs(Math.trunc(offsetInMinutes / 60)).toString().padStart(2, '0') + ':' + Math.abs(offsetInMinutes % 60).toString().padStart(2, '0');
  }
  static fillDayNames() {
    const tempDate = new Date('2000-01-01T12:00:00'),
      dayNames = DH$1._dayNames || [],
      dayShortNames = DH$1._dayShortNames || [];
    dayNames.length = 0;
    dayShortNames.length = 0;
    for (let day = 2; day < 9; day++) {
      tempDate.setDate(day);
      dayNames.push(DH$1.format(tempDate, 'dddd'));
      dayShortNames.push(DH$1.format(tempDate, 'ddd'));
    }
    DH$1._dayNames = dayNames;
    DH$1._dayShortNames = dayShortNames;
  }
  static getDayNames() {
    return DH$1._dayNames;
  }
  static getDayName(day) {
    return DH$1._dayNames[day];
  }
  static getDayShortNames() {
    return DH$1._dayShortNames;
  }
  static getDayShortName(day) {
    return DH$1._dayShortNames[day];
  }
  static fillMonthNames() {
    const tempDate = new Date('2000-01-15T12:00:00'),
      monthNames = DH$1._monthNames || [],
      monthShortNames = DH$1._monthShortNames || [],
      monthNamesIndex = {},
      monthShortNamesIndex = {};
    monthNames.length = 0;
    monthShortNames.length = 0;
    for (let month = 0; month < 12; month++) {
      tempDate.setMonth(month);
      const monthName = DH$1.format(tempDate, 'MMMM');
      monthNames.push(monthName);
      const monthShortName = DH$1.format(tempDate, 'MMM');
      monthShortNames.push(monthShortName);
      monthNamesIndex[monthName.toLowerCase()] = {
        name: monthName,
        value: month
      };
      monthShortNamesIndex[monthShortName.toLowerCase()] = {
        name: monthShortName,
        value: month
      };
    }
    DH$1._monthNames = monthNames;
    DH$1._monthShortNames = monthShortNames;
    DH$1._monthNamesIndex = monthNamesIndex;
    DH$1._monthShortNamesIndex = monthShortNamesIndex;
  }
  static getMonthShortNames() {
    return DH$1._monthShortNames;
  }
  static getMonthShortName(month) {
    return DH$1._monthShortNames[month];
  }
  static getMonthNames() {
    return DH$1._monthNames;
  }
  static getMonthName(month) {
    return DH$1._monthNames[month];
  }
  static set locale(name) {
    locale = name;
    intlFormatterCache = {};
    formatCache = {};
    formatRedirects = {};
  }
  static get locale() {
    return locale;
  }
  static setupDurationRegEx(unitNames = [], unitAbbreviations = []) {
    const me = this,
      unitLookup = {};
    let unitAbbrRegEx = '';
    for (let i = 0; i < unitAbbreviations.length; i++) {
      const
        // for example ['s', 'sec']
        abbreviations = unitAbbreviations[i],
        // for example { single : 'second', plural : 'seconds', abbrev : 's' }
        unitNamesCfg = unitNames[i];
      unitNamesCfg.canonicalUnitName = canonicalUnitNames[i];
      // Create a unitLookup object keyed by unit full names
      // both lower and upper case to be able to look up plurals or abbreviations
      // also always include english names, since those are used in sources
      unitLookup[unitNamesCfg.single] = unitLookup[unitNamesCfg.single.toUpperCase()] = unitLookup[unitNamesCfg.canonicalUnitName] = unitLookup[unitNamesCfg.canonicalUnitName.toUpperCase()] = unitNamesCfg;
      unitAbbrRegEx += `${i ? '|' : ''}(`;
      for (let j = 0; j < abbreviations.length; j++) {
        unitAbbrRegEx += `${abbreviations[j]}|`;
      }
      locale = me.localize('L{locale}') || 'en-US';
      if (locale !== 'en-US') {
        // Add canonical values to be able to parse durations specified in configs
        const canonicalAbbreviations = canonicalUnitAbbreviations[i];
        for (let j = 0; j < canonicalAbbreviations.length; j++) {
          unitAbbrRegEx += `${canonicalAbbreviations[j]}|`;
        }
      }
      unitAbbrRegEx += `${unitNamesCfg.single}|${unitNamesCfg.plural}|${unitNamesCfg.canonicalUnitName}|${unitNamesCfg.canonicalUnitName}s)`;
    }
    me.unitLookup = unitLookup;
    me.durationRegEx = new RegExp(`^(?:${unitAbbrRegEx})$`);
  }
  static applyLocale() {
    const me = this,
      unitAbbreviations = me.localize('L{unitAbbreviations}') || [],
      unitNames = me.unitNames = me.localize('L{unitNames}');
    // This happens when applying an incomplete locale, as done in Localizable.t.js.
    // Invalid usecase, but return to prevent a crash in that test.
    if (unitNames === 'unitNames') {
      return;
    }
    locale = me.localize('L{locale}') || 'en-US';
    if (locale === 'en-US') {
      ordinalSuffix = enOrdinalSuffix;
    } else {
      ordinalSuffix = me.localize('L{ordinalSuffix}') || ordinalSuffix;
    }
    formatCache = {};
    formatRedirects = {};
    parserCache = {};
    intlFormatterCache = {};
    DH$1._weekStartDay = null;
    DH$1.setupDurationRegEx(unitNames, unitAbbreviations);
    // rebuild day/month names cache
    DH$1.fillDayNames();
    DH$1.fillMonthNames();
  }
  //endregion
}

const DH$1 = DateHelper;
DH$1.useIntlFormat = useIntlFormat; // to use on tests
// Update when changing locale
LocaleManagerSingleton.ion({
  locale: 'applyLocale',
  prio: 1000,
  thisObj: DH$1
});
// Apply default locale
if (LocaleManagerSingleton.locale) {
  DH$1.applyLocale();
}
DateHelper._$name = 'DateHelper';

/**
 * @module Core/helper/ObjectHelper
 */
// Detect if browser has bad implementation of toFixed()
const {
    hasOwn: hasOwn$2
  } = Objects,
  toFixedFix = 1.005.toFixed(2) === '1.01' ? null : function (number, fractionDigits) {
    const split = number.toString().split('.'),
      newNumber = +(!split[1] ? split[0] : split.join('.') + '1');
    return number.toFixed.call(newNumber, fractionDigits);
  };
/**
 * Helper for Object manipulation.
 */
class ObjectHelper extends Objects {
  // These methods are inherited from Objects (an internal class) but need to be documented here for public use.
  // This is primarily because static methods, while inherited by JavaScript classes, are not displayed in derived
  // classes in the docs.
  /**
   * Copies all enumerable properties from the supplied source objects to `dest`. Unlike `Object.assign`, this copy
   * also includes inherited properties.
   * @param {Object} dest The destination object.
   * @param {...Object} sources The source objects.
   * @returns {Object} The `dest` object.
   * @method assign
   * @static
   */
  /**
   * Copies all enumerable properties from the supplied source objects to `dest`, only including properties that does
   * not already exist on `dest`. Unlike `Object.assign`, this copy also includes inherited properties.
   * @param {Object} dest The destination object.
   * @param {...Object} sources The source objects.
   * @returns {Object} The `dest` object.
   * @method assignIf
   * @static
   */
  /**
   * Creates a deep copy of the `value`. Simple objects ({@link #function-isObject-static}, arrays and `Date` objects
   * are cloned. The enumerable properties of simple objects and the elements of arrays are cloned recursively.
   * @param {*} value The value to clone.
   * @param {Function} [handler] An optional function to call for values of types other than simple object, array or
   * `Date`. This function should return the clone of the `value` passed to it. It is only called for truthy values
   * whose `typeof` equals `'object'`.
   * @param {*} handler.value The value to clone.
   * @returns {*} The cloned value.
   * @method clone
   * @static
   */
  /**
   * Converts a list of names (either a space separated string or an array), into an object with those properties
   * assigned truthy values. The converse of {@link #function-getTruthyKeys-static}.
   * @param {String|String[]} source The list of names to convert to object form.
   * @method createTruthyKeys
   * @static
   */
  /**
   * Gathers the names of properties which have truthy values into an array.
   *
   * This is useful when gathering CSS class names for complex element production.
   * Instead of appending to an array or string which may already contain the
   * name, and instead of contending with space separation and concatenation
   * and conditional execution, just set the properties of an object:
   *
   *     cls = {
   *         [this.selectedCls] : this.isSelected(thing),
   *         [this.dirtyCls] : this.isDirty(thing)
   *     };
   *
   * @param {Object} source Source of keys to gather into an array.
   * @returns {String[]} The keys which had a truthy value.
   * @method getTruthyKeys
   * @static
   */
  /**
   * Gathers the values of properties which are truthy into an array.
   * @param {Object} source Source of values to gather into an array.
   * @returns {String[]} The truthy values from the passed object.
   * @method getTruthyValues
   * @static
   */
  /**
   * Tests whether a passed object has any enumerable properties.
   * @param {Object} object
   * @returns {Boolean} `true` if the passed object has no enumerable properties.
   * @method isEmpty
   * @static
   */
  /**
   * Returns `true` if the `value` is a simple `Object`.
   * @param {Object} value
   * @returns {Boolean} `true` if the `value` is a simple `Object`.
   * @method isObject
   * @static
   */
  /**
   * Copies all enumerable properties from the supplied source objects to `dest`, recursing when the properties of
   * both the source and `dest` are objects.
   * ```
   *  const o = {
   *      a : 1,
   *      b : {
   *          c : 2
   *      }
   *  };
   *  const o2 = {
   *      b : {
   *          d : 3
   *      }
   *  }
   *
   *  console.log(merge(o, o2));
   *
   *  > { a : 1, b : { c : 2, d : 3 } }
   * ```
   * @param {Object} dest The destination object.
   * @param {...Object} sources The source objects.
   * @returns {Object} The `dest` object.
   * @method merge
   * @static
   */
  /**
   * Returns the specific type of the given `value`. Unlike the `typeof` operator, this function returns the text
   * from the `Object.prototype.toString` result allowing `Date`, `Array`, `RegExp`, and others to be differentiated.
   * ```
   *  console.log(typeOf(null));
   *  > null
   *
   *  console.log(typeOf({}));
   *  > object
   *
   *  console.log(typeOf([]));
   *  > array
   *
   *  console.log(typeOf(new Date()));
   *  > date
   *
   *  console.log(typeOf(NaN));
   *  > nan
   *
   *  console.log(typeOf(/a/));
   *  > regexp
   * ```
   * @param {*} value
   * @returns {String}
   * @method typeOf
   * @static
   */
  /**
   * Returns value for a given path in the object
   * @param {Object} object Object to check path on
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @returns {*} Value associated with passed key
   * @method getPath
   * @static
   */
  /**
   * Sets value for a given path in the object
   * @param {Object} object Target object
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @param {*} value Value for a given path
   * @returns {Object} Returns passed object
   * @method setPath
   * @static
   */
  /**
   * Creates a new object where key is a property in array item (`ref` by default) or index in the array and value is array item.
   *
   * From:
   * ```
   * [
   *     {
   *          text : 'foo',
   *          ref : 'fooItem'
   *     },
   *     {
   *          text : 'bar'
   *     }
   * ]
   * ```
   *
   * To:
   * ```
   * {
   *     fooItem : {
   *         text : 'foo',
   *         ref  : 'fooItem'
   *     },
   *     1 : {
   *         text : 'bar'
   *     }
   * }
   * ```
   *
   * @param {Object[]} arrayOfItems Array to transform.
   * @param {String} [prop] Property to read the key from. `ref` by default.
   * @returns {Object} namedItems
   */
  static transformArrayToNamedObject(arrayOfItems, prop = 'ref') {
    const namedItems = {};
    arrayOfItems.forEach((item, index) => {
      const
      // 0 is valid value, but empty string in not valid
      key = item[prop] != null && item[prop].toString().length ? item[prop] : index;
      namedItems[key] = item;
    });
    return namedItems;
  }
  /**
   * Creates a new array from object values and saves key in a property (`ref` by default) of each item.
   *
   * From:
   * ```
   * {
   *     fooItem : {
   *         text : 'foo'
   *     },
   *     1 : {
   *         text : 'bar'
   *     },
   *     barItem : false // will be ignored
   * }
   * ```
   *
   * To:
   * ```
   * [
   *     {
   *          text : 'foo',
   *          ref : 'fooItem'
   *     },
   *     {
   *          text : 'bar',
   *          ref : 1
   *     }
   * ]
   * ```
   *
   * @param {Object} namedItems Object to transform.
   * @param {String} [prop] Property to save the key to. `ref` by default.
   * @returns {Object[]} arrayOfItems
   */
  static transformNamedObjectToArray(namedItems, prop = 'ref') {
    return Object.keys(namedItems).filter(key => namedItems[key]).map(key => {
      const item = namedItems[key];
      item[prop] = key;
      return item;
    });
  }
  /**
   * Checks if two values are equal. Basically === but special handling of dates.
   * @param {*} a First value
   * @param {*} b Second value
   * @returns {*} true if values are equal, otherwise false
   */
  static isEqual(a, b, useIsDeeply = false) {
    // Eliminate null vs undefined mismatch
    if (a === null && b !== null || a === undefined && b !== undefined || b === null && a !== null || b === undefined && a !== undefined) {
      return false;
    }
    // Covers undefined === undefined and null === null, since mismatches are eliminated above
    if (a == null && b == null) {
      return true;
    }
    // The same instance should equal itself.
    if (a === b) {
      return true;
    }
    const typeA = typeof a,
      typeB = typeof b;
    if (typeA === typeB) {
      switch (typeA) {
        case 'number':
        case 'string':
        case 'boolean':
          return a === b;
      }
      switch (true) {
        case a instanceof Date && b instanceof Date:
          // faster than calling DateHelper.isEqual
          // https://jsbench.me/3jk2bom2r3/1
          return a.getTime() === b.getTime();
        case Array.isArray(a) && Array.isArray(b):
          return a.length === b.length ? a.every((v, idx) => OH.isEqual(v, b[idx], useIsDeeply)) : false;
        case typeA === 'object' && a.constructor.prototype === b.constructor.prototype:
          return useIsDeeply ? OH.isDeeplyEqual(a, b, useIsDeeply) : StringHelper.safeJsonStringify(a) === StringHelper.safeJsonStringify(b);
      }
    }
    return String(a) === String(b);
  }
  /**
   * Checks if two objects are deeply equal
   * @param {Object} a
   * @param {Object} b
   * @param {Object} [options] Additional comparison options
   * @param {Object} [options.ignore] Map of property names to ignore when comparing
   * @param {Function} [options.shouldEvaluate] Function used to evaluate if a property should be compared or not.
   * Return false to prevent comparison
   * @param {Function} [options.evaluate] Function used to evaluate equality. Return `true`/`false` as evaluation
   * result or anything else to let `isEqual` handle the comparison
   * @returns {Boolean}
   */
  static isDeeplyEqual(a, b, options = {}) {
    // Same object, equal :)
    if (a === b) {
      return true;
    }
    // Nothing to compare, not equal
    if (!a || !b) {
      return false;
    }
    // Property names excluding ignored
    const aKeys = OH.keys(a, options.ignore),
      bKeys = OH.keys(b, options.ignore);
    // Property count differs, not equal
    if (aKeys.length !== bKeys.length) {
      return false;
    }
    for (let i = 0; i < aKeys.length; i++) {
      const aKey = aKeys[i],
        bKey = bKeys[i];
      // Property name differs, not equal
      if (aKey !== bKey) {
        return false;
      }
      const aVal = a[aKey],
        bVal = b[bKey];
      // Allow caller to determine if property values should be evaluated or not
      if (options.shouldEvaluate) {
        if (options.shouldEvaluate(aKey, {
          value: aVal,
          object: a
        }, {
          value: bVal,
          object: b
        }) === false) {
          continue;
        }
      }
      // Allow caller to determine equality of properties
      if (options.evaluate) {
        const result = options.evaluate(aKey, {
          value: aVal,
          object: a
        }, {
          value: bVal,
          object: b
        });
        // Not equal
        if (result === false) {
          return false;
        }
        // Equal, skip isEqual call below
        if (result === true) {
          continue;
        }
      }
      // Values differ, not equal (also digs deeper)
      if (!OH.isEqual(aVal, bVal, options)) {
        return false;
      }
    }
    // Found to be equal
    return true;
  }
  /**
   * Checks if value B is partially equal to value A.
   * @param {*} a First value
   * @param {*} b Second value
   * @returns {Boolean} true if values are partially equal, false otherwise
   */
  static isPartial(a, b) {
    a = String(a).toLowerCase();
    b = String(b).toLowerCase();
    return a.indexOf(b) !== -1;
  }
  /**
   * Checks if value a is smaller than value b.
   * @param {*} a First value
   * @param {*} b Second value
   * @returns {Boolean} true if a < b
   */
  static isLessThan(a, b) {
    if (a instanceof Date && b instanceof Date) {
      return DateHelper.isBefore(a, b);
    }
    return a < b;
  }
  /**
   * Checks if value a is bigger than value b.
   * @param {*} a First value
   * @param {*} b Second value
   * @returns {Boolean} true if a > b
   */
  static isMoreThan(a, b) {
    if (a instanceof Date && b instanceof Date) {
      return DateHelper.isAfter(a, b);
    }
    return a > b;
  }
  /**
   * Used by the Base class to make deep copies of defaultConfig blocks
   * @private
   */
  static fork(obj) {
    let ret, key, value;
    if (obj && obj.constructor === Object) {
      ret = Object.setPrototypeOf({}, obj);
      for (key in obj) {
        value = obj[key];
        if (value) {
          if (value.constructor === Object) {
            ret[key] = OH.fork(value);
          } else if (value instanceof Array) {
            ret[key] = value.slice();
          }
        }
      }
    } else {
      ret = obj;
    }
    return ret;
  }
  /**
   * Copies the named properties from the `source` parameter into the `dest` parameter.
   * @param {Object} dest The destination into which properties are copied.
   * @param {Object} source The source from which properties are copied.
   * @param {String[]} props The list of property names.
   * @returns {Object} The `dest` object.
   */
  static copyProperties(dest, source, props) {
    let prop, i;
    for (i = 0; i < props.length; i++) {
      prop = props[i];
      if (prop in source) {
        dest[prop] = source[prop];
      }
    }
    return dest;
  }
  /**
   * Copies the named properties from the `source` parameter into the `dest` parameter
   * unless the property already exists in the `dest`.
   * @param {Object} dest The destination into which properties are copied.
   * @param {Object} source The source from which properties are copied.
   * @param {String[]} props The list of property names.
   * @returns {Object} The `dest` object.
   */
  static copyPropertiesIf(dest, source, props) {
    if (source) {
      for (const prop of props) {
        if (!(prop in dest) && prop in source) {
          dest[prop] = source[prop];
        }
      }
    }
    return dest;
  }
  /**
   * Returns an array containing the keys and values of all enumerable properties from every prototype level for the
   * object. If `object` is `null`, this method returns an empty array.
   * @param {Object} object Object from which to retrieve entries.
   * @param {Object|Function} [ignore] Optional object of names to ignore or a function accepting the name and value
   * which returns `true` to ignore the item.
   * @returns {Array}
   * @internal
   */
  static entries(object, ignore) {
    const result = [],
      call = typeof ignore === 'function';
    if (object) {
      for (const p in object) {
        if (call ? !ignore(p, object[p]) : !(ignore !== null && ignore !== void 0 && ignore[p])) {
          result.push([p, object[p]]);
        }
      }
    }
    return result;
  }
  /**
   * Populates an `object` with the provided `entries`.
   * @param {Array} entries The key/value pairs (2-element arrays).
   * @param {Object} [object={}] The object onto which to add `entries`.
   * @returns {Object} The passed `object` (by default, a newly created object).
   * @internal
   */
  static fromEntries(entries, object) {
    object = object || {};
    if (entries) {
      for (let i = 0; i < entries.length; ++i) {
        object[entries[i][0]] = entries[i][1];
      }
    }
    return object;
  }
  /**
   * Returns an array containing all enumerable property names from every prototype level for the object. If `object`
   * is `null`, this method returns an empty array.
   * @param {Object} object Object from which to retrieve property names.
   * @param {Object|Function} [ignore] Optional object of names to ignore or a function accepting the name and value
   * which returns `true` to ignore the item.
   * @param {Function} [mapper] Optional function to call for each non-ignored item. If provided, the result of this
   * function is stored in the returned array. It is called with the array element as the first parameter, and the
   * index in the result array as the second argument (0 for the first, non-ignored element, 1 for the second and so
   * on).
   * @returns {String[]}
   */
  static keys(object, ignore, mapper) {
    const result = [],
      call = typeof ignore === 'function';
    if (object) {
      let index = 0;
      for (const p in object) {
        if (call ? !ignore(p, object[p]) : !(ignore !== null && ignore !== void 0 && ignore[p])) {
          result.push(mapper ? mapper(p, index) : p);
          ++index;
        }
      }
    }
    return result;
  }
  /**
   * Returns an array containing the values of all enumerable properties from every prototype level for the object.
   * If `object` is `null`, this method returns an empty array.
   * @param {Object} object Object from which to retrieve values.
   * @param {Object|Function} [ignore] Optional object of names to ignore or a function accepting the name and value
   * which returns `true` to ignore the item.
   * @param {Function} [mapper] Optional function to call for each non-ignored item. If provided, the result of this
   * function is stored in the returned array. It is called with the array element as the first parameter, and the
   * index in the result array as the second argument (0 for the first, non-ignored element, 1 for the second and so
   * on).
   * @returns {Array}
   * @internal
   */
  static values(object, ignore, mapper) {
    const result = [],
      call = typeof ignore === 'function';
    if (object) {
      let index = 0;
      for (const p in object) {
        if (call ? !ignore(p, object[p]) : !(ignore !== null && ignore !== void 0 && ignore[p])) {
          result.push(mapper ? mapper(object[p], index) : object[p]);
          ++index;
        }
      }
    }
    return result;
  }
  //region Path
  /**
   * Checks if a given path exists in an object
   * @param {Object} object Object to check path on
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @returns {Boolean} Returns `true` if path exists or `false` if it does not
   */
  static pathExists(object, path) {
    const properties = path.split('.');
    return properties.every(property => {
      if (!object || !(property in object)) {
        return false;
      }
      object = object[property];
      return true;
    });
  }
  /**
   * Creates a simple single level key-value object from complex deep object.
   * @param {Object} object Object to extract path and values from
   * @returns {Object} Key-value object where key is a path to the corresponding value
   * @internal
   *
   * ```javascript
   * // converts deep object
   * {
   *     foo : {
   *         bar : {
   *             test : 1
   *         }
   *     }
   * }
   * // into a single level object
   * {
   *     'foo.bar.test' : 1
   * }
   * ```
   */
  static pathifyKeys(object, fieldDataSourceMap) {
    const result = {};
    for (const key in object) {
      if (hasOwn$2(object, key)) {
        const field = fieldDataSourceMap === null || fieldDataSourceMap === void 0 ? void 0 : fieldDataSourceMap[key];
        // do not use path keys if `fieldDataSourceMap` is provided (for top level keys)
        const usesPathKeys = (field === null || field === void 0 ? void 0 : field.type) === 'object' || (field === null || field === void 0 ? void 0 : field.complexMapping) || !Boolean(fieldDataSourceMap);
        if (usesPathKeys && Array.isArray(object[key])) {
          result[key] = object[key].slice();
        } else if (usesPathKeys && object[key] instanceof Object) {
          const paths = this.pathifyKeys(object[key]);
          for (const path in paths) {
            result[`${key}.${path}`] = paths[path];
          }
        } else {
          result[key] = object[key];
        }
      }
    }
    return result;
  }
  /**
   * Removes value for a given path in the object. Doesn't cleanup empty objects.
   * @param {Object} object
   * @param {String} path Dot-separated path, e.g. `obj.child.someKey`
   * @internal
   */
  static deletePath(object, path) {
    path.split('.').reduce((result, key, index, array) => {
      if (result == null) {
        return null;
      }
      if (hasOwn$2(result, key)) {
        if (index === array.length - 1) {
          delete result[key];
        } else {
          return result[key];
        }
      }
    }, object);
  }
  //endregion
  static coerce(from, to) {
    const fromType = Objects.typeOf(from),
      toType = Objects.typeOf(to),
      isString = typeof from === 'string';
    if (fromType !== toType) {
      switch (toType) {
        case 'string':
          return String(from);
        case 'number':
          return Number(from);
        case 'boolean':
          // See http://ecma262-5.com/ELS5_HTML.htm#Section_11.9.3 as to why '0'.
          // TL;DR => ('0' == 0), so if given string '0', we must return boolean false.
          return isString && (!from || from === 'false' || from === '0') ? false : Boolean(from);
        case 'null':
          return isString && (!from || from === 'null') ? null : false;
        case 'undefined':
          return isString && (!from || from === 'undefined') ? undefined : false;
        case 'date':
          return isString && isNaN(from) ? DateHelper.parse(from) : Date(Number(from));
      }
    }
    return from;
  }
  static wrapProperty(object, propertyName, newGetter, newSetter, deep = true) {
    const newProperty = {};
    let proto = Object.getPrototypeOf(object),
      existingProperty = Object.getOwnPropertyDescriptor(proto, propertyName);
    while (!existingProperty && proto && deep) {
      proto = Object.getPrototypeOf(proto);
      if (proto) {
        existingProperty = Object.getOwnPropertyDescriptor(proto, propertyName);
      }
    }
    if (existingProperty) {
      if (existingProperty.set) {
        newProperty.set = v => {
          existingProperty.set.call(object, v);
          // Must invoke the getter in case "v" has been transformed.
          newSetter && newSetter.call(object, existingProperty.get.call(object));
        };
      } else {
        newProperty.set = newSetter;
      }
      if (existingProperty.get) {
        newProperty.get = () => {
          let result = existingProperty.get.call(object);
          if (newGetter) {
            result = newGetter.call(object, result);
          }
          return result;
        };
      } else {
        newProperty.get = newGetter;
      }
    } else {
      newProperty.set = v => {
        object[`_${propertyName}`] = v;
        newSetter && newSetter.call(object, v);
      };
      newProperty.get = () => {
        let result = object[`_${propertyName}`];
        if (newGetter) {
          result = newGetter.call(object, result);
        }
        return result;
      };
    }
    Object.defineProperty(object, propertyName, newProperty);
  }
  /**
   * Intercepts access to a `property` of a given `object`.
   *
   * ```javascript
   *      ObjectHelper.hookProperty(object, 'prop', class {
   *          get value() {
   *              return super.value;
   *          }
   *          set value(v) {
   *              super.value = v;
   *          }
   *      });
   * ```
   * The use of `super` allows the hook's getter and setter to invoke the object's existing get/set.
   *
   * @param {Object} object
   * @param {String} property
   * @param {Function} hook A `class` defining a `value` property getter and/or setter.
   * @returns {Function} A function that removes the hook when called.
   * @internal
   */
  static hookProperty(object, property, hook) {
    const desc = ObjectHelper.getPropertyDescriptor(hook.prototype, 'value'),
      existingDesc = ObjectHelper.getPropertyDescriptor(object, property),
      fieldName = `_${property}`,
      base = class {
        get value() {
          return existingDesc ? existingDesc.get.call(this) : this[fieldName];
        }
        set value(v) {
          if (existingDesc) {
            existingDesc.set.call(this, v);
          } else {
            this[fieldName] = v;
          }
        }
      },
      baseDesc = ObjectHelper.getPropertyDescriptor(base.prototype, 'value');
    Object.setPrototypeOf(hook.prototype, base.prototype); // direct super calls to our "base" implementation
    Object.defineProperty(object, property, {
      configurable: true,
      get: desc.get || baseDesc.get,
      set: desc.set || baseDesc.set
    });
    return () => delete object[property];
  }
  /**
   * Finds a property descriptor for the passed object from all inheritance levels.
   * @param {Object} object The Object whose property to find.
   * @param {String} propertyName The name of the property to find.
   * @returns {Object} An ECMA property descriptor is the property was found, otherwise `null`
   */
  static getPropertyDescriptor(object, propertyName) {
    let result = null;
    for (let o = object; o && !result && !hasOwn$2(o, 'isBase'); o = Object.getPrototypeOf(o)) {
      result = Object.getOwnPropertyDescriptor(o, propertyName);
    }
    return result;
  }
  /**
   * Changes the passed object and removes all null and undefined properties from it
   * @param {Object} object Target object
   * @param {Boolean} [keepNull] Pass true to only remove undefined properties
   * @returns {Object} Passed object
   */
  static cleanupProperties(object, keepNull = false) {
    Object.entries(object).forEach(([key, value]) => {
      if (keepNull) {
        value === undefined && delete object[key];
      } else {
        value == null && delete object[key];
      }
    });
    return object;
  }
  /**
   * Changes the passed object and removes all properties from it.
   * Used while mutating when need to keep reference to the object but replace its properties.
   * @param {Object} object Target object
   * @returns {Object} Passed object
   */
  static removeAllProperties(obj) {
    Object.keys(obj).forEach(key => delete obj[key]);
    return obj;
  }
  //region Assert type
  /**
   * Checks that the supplied value is of the specified type.Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} type Expected type
   * @param {String} name Name of the value, used in error message
   * @param {Boolean} [allowNull] Accept `null` without throwing
   */
  static assertType(value, type, name) {
    const valueType = Objects.typeOf(value);
    if (value != null && valueType !== type) {
      throw new Error(`Incorrect type "${valueType}" for ${name}, expected "${type}"`);
    }
  }
  /**
   * Checks that the supplied value is a plain object. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertObject(value, name) {
    OH.assertType(value, 'object', name);
  }
  /**
   * Checks that the supplied value is an instance of a Bryntum class. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertInstance(value, name) {
    OH.assertType(value, 'instance', name);
  }
  /**
   * Checks that the supplied value is a Bryntum class. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertClass(value, name) {
    OH.assertType(value, 'class', name);
  }
  /**
   * Checks that the supplied value is a function. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertFunction(value, name) {
    if (typeof value !== 'function' || value.isBase || value.$$name) {
      throw new Error(`Incorrect type for ${name}, got "${value}" (expected a function)`);
    }
  }
  /**
   * Checks that the supplied value is a number. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertNumber(value, name) {
    const asNumber = Number(value);
    if (typeof value !== 'number' || isNaN(asNumber)) {
      throw new Error(`Incorrect type for ${name}, got "${value}" (expected a Number)`);
    }
  }
  /**
   * Checks that the supplied value is a boolean. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertBoolean(value, name) {
    OH.assertType(value, 'boolean', name);
  }
  /**
   * Checks that the supplied value is a string. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertString(value, name) {
    OH.assertType(value, 'string', name);
  }
  /**
   * Checks that the supplied value is an array. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertArray(value, name) {
    OH.assertType(value, 'array', name);
  }
  //endregion
  /**
   * Number.toFixed(), with polyfill for browsers that needs it
   * @param {Number} number
   * @param {Number} digits
   * @returns {String} A fixed point string representation of the passed number.
   */
  static toFixed(number, digits) {
    if (toFixedFix) {
      return toFixedFix(number, digits);
    }
    return number.toFixed(digits);
  }
  /**
   * Round the passed number to closest passed step value.
   * @param {Number} number The number to round.
   * @param {Number} [step] The step value to round to.
   * @returns {Number} The number rounded to the closest step.
   */
  static roundTo(number, step = 1) {
    return Math.round(number / step) * step;
  }
  /**
   * Round the passed number to the passed number of decimals.
   * @param {Number} number The number to round.
   * @param {Number} digits The number of decimal places to round to.
   * @returns {Number} The number rounded to the passed number of decimal places.
   */
  static round(number, digits) {
    // Undefined or null means do not round. NOT round to no decimals.
    if (digits == null) {
      return number;
    }
    const factor = 10 ** digits;
    return Math.round(number * factor) / factor;
  }
  /**
   * Returns a non-null entry from a Map for a given key path. This enables a specified defaultValue to be added "just
   * in time" which is returned if the key is not already present.
   * @param {Map} map The Map to find the key in (and potentially add to).
   * @param {String|Number|String[]|Number[]} path Dot-separated path, e.g. 'firstChild.childObject.someKey',
   * or the key path as an array, e.g. ['firstChild', 'childObject', 'someKey'].
   * @param {Object} [defaultValue] Optionally the value to insert if the key is not found.
   */
  static getMapPath(map, path, defaultValue) {
    const keyPath = Array.isArray(path) ? path : typeof path === 'string' ? path.split('.') : [path],
      simpleKey = keyPath.length === 1,
      topKey = keyPath[0],
      topValue = map.has(topKey) ? map.get(topKey) : map.set(topKey, simpleKey ? defaultValue : {}).get(topKey);
    // If it was a simple key, we are done.
    if (simpleKey) {
      return topValue;
    }
    // Go down the property path on the top Object, filling entries in until the leaf.
    return OH.getPathDefault(topValue, keyPath.slice(1), defaultValue);
  }
}
const OH = ObjectHelper;
ObjectHelper._$name = 'ObjectHelper';

/**
 * @module Core/helper/util/Rectangle
 */
const allBorders = ['border-top-width', 'border-right-width', 'border-bottom-width', 'border-left-width'],
  allMargins = ['margin-top', 'margin-right', 'margin-bottom', 'margin-left'],
  allPaddings = ['padding-top', 'padding-right', 'padding-bottom', 'padding-left'],
  borderNames = {
    t: 'border-top-width',
    r: 'border-right-width',
    b: 'border-bottom-width',
    l: 'border-left-width'
  },
  paddingNames = {
    t: 'padding-top',
    r: 'padding-right',
    b: 'padding-bottom',
    l: 'padding-left'
  },
  zeroBased = Object.freeze({
    x: 0,
    y: 0
  }),
  alignSpecRe$1 = /^([trblc])(\d*)-([trblc])(\d*)$/i,
  alignPointRe = /^([trblc])(\d*)$/i,
  edgeNames = ['top', 'right', 'bottom', 'left'],
  edgeIndices = {
    t: 0,
    r: 1,
    b: 2,
    l: 3
  },
  defaultAlignments = ['b-t', 'l-r', 't-b', 'r-l'],
  edgeAligments = {
    bt: 1,
    tb: 1,
    lr: 2,
    rl: 2
  },
  zeroOffsets = Object.freeze([0, 0]),
  matchDimensions = ['width', 'height'],
  parseEdges = (top, right = top, bottom = top, left = right) => {
    return Array.isArray(top) ? parseEdges.apply(null, top) : [top, right, bottom, left];
  };
// Parse a l0-r0 (That's how Menus align to their owning MenuItem) align spec.
// If we are in an RTL env, then reverse the percentage values if we are
// aligning horizontal edges.
function parseAlign(alignSpec, rtl) {
  const parts = alignSpecRe$1.exec(alignSpec),
    myEdge = parts[1],
    targetEdge = parts[3],
    mO = parseInt(parts[2] || 50),
    tO = parseInt(parts[4] || 50),
    myOffset = rtl && !(edgeIndices[myEdge] & 1) ? 100 - mO : mO,
    targetOffset = rtl && !(edgeIndices[targetEdge] & 1) ? 100 - tO : tO,
    edgeAligned = edgeAligments[myEdge + targetEdge];
  // Comments assume the Menu's alignSpec of l0-r0 is used.
  return {
    myAlignmentPoint: myEdge + myOffset,
    // l0
    myEdge,
    // l
    myOffset,
    // 0
    targetAlignmentPoint: targetEdge + targetOffset,
    // r0
    targetEdge,
    // r
    targetOffset,
    // 0
    startZone: edgeIndices[targetEdge],
    // 1 - start trying zone 1 in TRBL order
    edgeAligned // Edge-to-edge align requested
  };
}
// Takes a result from the above function and flips edges for the axisLock config
function flipAlign(align) {
  return `${edgeNames[(edgeIndices[align.myEdge] + 2) % 4][0]}${align.myOffset}-${edgeNames[(edgeIndices[align.targetEdge] + 2) % 4][0]}${align.targetOffset}`;
}
function createOffsets(offset) {
  if (offset == null) {
    return zeroOffsets;
  } else if (typeof offset === 'number') {
    return [offset, offset];
  }
  return offset;
}
/**
 * Encapsulates rectangular areas for comparison, intersection etc.
 *
 * Note that the `right` and `bottom` properties are *exclusive*.
 *
 */
class Rectangle {
  // Class does not extend Base, so we need to define this
  get isRectangle() {
    return true;
  }
  /**
   * Returns the Rectangle in document based coordinates of the passed element.
   *
   * *Note:* If the element passed is the `document` or `window` the `window`'s
   * rectangle is returned which is always at `[0, 0]` and encompasses the
   * browser's entire document viewport.
   * @param {HTMLElement|Core.widget.Widget|Core.widget.Mask} element The element to calculate the Rectangle for.
   * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
   * @param {Boolean} [ignorePageScroll=false] Use browser viewport based coordinates.
   * @returns {Core.helper.util.Rectangle} The Rectangle in document based (or, optionally viewport based) coordinates. Relative to the _relativeTo_ parameter if passed.
   */
  static from(element, relativeTo, ignorePageScroll) {
    var _element, _relativeTo;
    // Convenient in tests
    if (typeof element === 'string') {
      element = document.querySelector(element);
    }
    // If a shadowRoot or other type of document fragment passed, get closest Element
    else if (((_element = element) === null || _element === void 0 ? void 0 : _element.nodeType) === Node.DOCUMENT_FRAGMENT_NODE) {
      element = element.host || element.ownerDocument;
    }
    if (typeof relativeTo === 'string') {
      relativeTo = document.querySelector(relativeTo);
    }
    if (element == null || element.isRectangle) {
      return element;
    }
    element = element.element || element; // works for Widget and Mask
    if (ignorePageScroll === undefined && typeof relativeTo === 'boolean') {
      ignorePageScroll = relativeTo;
      relativeTo = null;
    }
    if (!((_relativeTo = relativeTo) !== null && _relativeTo !== void 0 && _relativeTo.isRectangle)) {
      if (relativeTo) {
        let {
          scrollLeft,
          scrollTop
        } = relativeTo;
        if (BrowserHelper.isSafari && relativeTo === document.body) {
          scrollLeft = scrollTop = 0;
        }
        relativeTo = Rectangle.from(relativeTo).translate(-scrollLeft, -scrollTop);
      } else {
        relativeTo = zeroBased;
      }
    }
    // Viewport is denoted by requesting window or document.
    // document.body may overflow the viewport, so this must not be evaluated as the viewport.
    const
      // If body is 0 height we should treat this case as a viewport
      isViewport = element === document || element === globalThis,
      isSFViewport = element === document.body && document.body.offsetHeight === 0,
      sfElRect = isSFViewport && element.getBoundingClientRect(),
      viewRect = isSFViewport
      // In Salesforce body and html have 0 height so to get correct viewport vertical size we have to use
      // scrollHeight on html element.
      ? new Rectangle(sfElRect.left, sfElRect.top, sfElRect.width, document.body.parentElement.scrollHeight) : isViewport ? new Rectangle(0, 0, globalThis.innerWidth, globalThis.innerHeight) : element.getBoundingClientRect(),
      scrollOffset = ignorePageScroll || isViewport ? [0, 0] : [globalThis.pageXOffset, globalThis.pageYOffset];
    return new Rectangle(viewRect.left + scrollOffset[0] - relativeTo.x, viewRect.top + scrollOffset[1] - relativeTo.y, viewRect.width, viewRect.height);
  }
  /**
   * Returns the Rectangle in viewport coordinates of the passed element.
   *
   * *Note:* If the element passed is the `document` or `window` the `window`'s rectangle is returned which is always
   * at `[0, 0]` and encompasses the browser's entire document viewport.
   * @param {HTMLElement} element The element to calculate the Rectangle for.
   * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
   * @returns {Core.helper.util.Rectangle} The Rectangle in viewport based coordinates. Relative to the _relativeTo_
   * parameter if provided.
   */
  static fromScreen(element, relativeTo) {
    return Rectangle.from(element, relativeTo, /* ignorePageScroll = */true);
  }
  /**
   * Returns the inner Rectangle (within border) in document based coordinates of the passed element.
   * @param {HTMLElement} element The element to calculate the Rectangle for.
   * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
   * @param {Boolean} [ignorePageScroll] Use browser viewport based coordinates.
   * @returns {Core.helper.util.Rectangle} The Rectangle in document based (or, optionally viewport based) coordinates. Relative to the _relativeTo_ parameter if passed.
   */
  static inner(element, relativeTo, ignorePageScroll = false) {
    const result = this.from(element, relativeTo, ignorePageScroll);
    // Can only ask for the following styles if element is in the document.
    if (document.body.contains(element)) {
      const borders = DomHelper.getStyleValue(element, allBorders);
      result.x += parseFloat(borders[borderNames.l]);
      result.y += parseFloat(borders[borderNames.t]);
      result.right -= parseFloat(borders[borderNames.r]);
      result.bottom -= parseFloat(borders[borderNames.b]);
    }
    return result;
  }
  /**
   * Returns the content Rectangle (within border and padding) in document based coordinates of the passed element.
   * @param {HTMLElement} element The element to calculate the Rectangle for.
   * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
   * @param {Boolean} [ignorePageScroll] Use browser viewport based coordinates.
   * @returns {Core.helper.util.Rectangle} The Rectangle in document based (or, optionally viewport based) coordinates. Relative to the _relativeTo_ parameter if passed.
   */
  static content(element, relativeTo, ignorePageScroll = false) {
    const result = this.from(element, relativeTo, ignorePageScroll);
    // Can only ask for the following styles if element is in the document.
    if (document.body.contains(element)) {
      const borders = DomHelper.getStyleValue(element, allBorders),
        padding = DomHelper.getStyleValue(element, allPaddings);
      result.x += parseFloat(borders[borderNames.l]) + parseFloat(padding[paddingNames.l]);
      result.y += parseFloat(borders[borderNames.t]) + parseFloat(padding[paddingNames.t]);
      result.right -= parseFloat(borders[borderNames.r]) + parseFloat(padding[paddingNames.r]);
      result.bottom -= parseFloat(borders[borderNames.b]) + parseFloat(padding[paddingNames.b]);
    }
    return result;
  }
  /**
   * Returns the client Rectangle (within border and padding and scrollbars) in document based coordinates of the
   * passed element.
   * @param {HTMLElement} element The element to calculate the Rectangle for.
   * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
   * @param {Boolean} [ignorePageScroll] Use browser viewport based coordinates.
   * @returns {Core.helper.util.Rectangle} The Rectangle in document based (or, optionally viewport based) coordinates. Relative to the _relativeTo_ parameter if passed.
   */
  static client(element, relativeTo, ignorePageScroll = false) {
    const result = this.content(element, relativeTo, ignorePageScroll),
      scrollbarWidth = DomHelper.scrollBarWidth;
    let padding;
    if (scrollbarWidth) {
      // Capture width taken by any vertical scrollbar.
      // If there is a vertical scrollbar, shrink the box.
      if (element.scrollHeight > element.clientHeight && DomHelper.getStyleValue(element, 'overflow-y') !== 'hidden') {
        padding = parseFloat(DomHelper.getStyleValue(element, 'padding-right'));
        result.right += padding - Math.max(padding, scrollbarWidth);
      }
      // Capture height taken by any horizontal scrollbar.
      // If there is a horizontal scrollbar, shrink the box.
      if (element.scrollWidth > element.clientWidth && DomHelper.getStyleValue(element, 'overflow-x') !== 'hidden') {
        padding = parseFloat(DomHelper.getStyleValue(element, 'padding-bottom'));
        result.bottom += padding - Math.max(padding, scrollbarWidth);
      }
    }
    // The client region excluding any scrollbars.
    return result;
  }
  /**
   * Returns the outer Rectangle (including margin) in document based coordinates of the passed element.
   * @param {HTMLElement} element The element to calculate the Rectangle for.
   * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
   * @param {Boolean} [ignorePageScroll] Use browser viewport based coordinates.
   * @returns {Core.helper.util.Rectangle} The Rectangle in document based (or, optionally viewport based) coordinates.
   * Relative to the _relativeTo_ parameter if passed.
   * @internal
   */
  static outer(element, relativeTo, ignorePageScroll = false) {
    const result = this.from(element, relativeTo, ignorePageScroll);
    // Can only ask for the following styles if element is in the document.
    if (document.body.contains(element)) {
      const margin = DomHelper.getStyleValue(element, allMargins);
      result.x -= parseFloat(margin['margin-left']);
      result.y -= parseFloat(margin['margin-top']);
      result.right += parseFloat(margin['margin-right']);
      result.bottom += parseFloat(margin['margin-bottom']);
    }
    return result;
  }
  /**
   * Returns a new rectangle created as the union of all supplied rectangles.
   * @param {Core.helper.util.Rectangle[]} rectangles
   * @returns {Core.helper.util.Rectangle}
   */
  static union(...rectangles) {
    let {
        x,
        y,
        right,
        bottom
      } = rectangles[0],
      current;
    if (rectangles.length > 1) {
      for (let i = 1; i < rectangles.length; i++) {
        current = rectangles[i];
        if (current.x < x) {
          x = current.x;
        }
        if (current.y < y) {
          y = current.y;
        }
        if (current.right > right) {
          right = current.right;
        }
        if (current.bottom > bottom) {
          bottom = current.bottom;
        }
      }
    }
    return new Rectangle(x, y, right - x, bottom - y);
  }
  /**
   * Rounds this Rectangle to the pixel resolution of the current display or to the nearest
   * passed unit which defaults to the current display's [`devicePixelRatio`](https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio).
   * @param {Number} [devicePixelRatio] device pixel ratio which defaults to `window.devicePixelRatio`
   */
  roundPx(devicePixelRatio = globalThis.devicePixelRatio || 1) {
    const me = this;
    me._x = DomHelper.roundPx(me._x, devicePixelRatio);
    me._y = DomHelper.roundPx(me._y, devicePixelRatio);
    me._width = DomHelper.roundPx(me._width, devicePixelRatio);
    me._height = DomHelper.roundPx(me._height, devicePixelRatio);
    return me;
  }
  // This class doesn't extend Base and extending doesn't seem to be
  // the way to go. Instead we duplicate smallest piece of logic here
  static get $$name() {
    return hasOwnProperty.call(this, '$name') && this.$name ||
    // _$name is filled by webpack for every class (cls._$name = '...')
    hasOwnProperty.call(this, '_$name') && this._$name || this.name;
  }
  get $$name() {
    return this.constructor.$$name;
  }
  /**
   * Constructs a Rectangle
   * @param {Number} x The X coordinate
   * @param {Number} y The Y coordinate
   * @param {Number} width The width
   * @param {Number} height The height
   */
  constructor(x, y, width, height) {
    ObjectHelper.assertNumber(x, 'Rectangle.x');
    ObjectHelper.assertNumber(y, 'Rectangle.y');
    ObjectHelper.assertNumber(width, 'Rectangle.width');
    ObjectHelper.assertNumber(height, 'Rectangle.height');
    const me = this;
    // Normalize rectangle definitions with -ve offsets from their origin
    if (width < 0) {
      x += width;
      width = -width;
    }
    if (height < 0) {
      y += height;
      height = -height;
    }
    me._x = x;
    me._y = y;
    me._width = width;
    me._height = height;
  }
  /**
   * Creates a copy of this Rectangle.
   */
  clone() {
    const me = this,
      result = new Rectangle(me.x, me.y, me.width, me.height);
    result.isAlignRectangle = me.isAlignRectangle;
    result.minHeight = me.minHeight;
    result.minWidth = me.minWidth;
    return result;
  }
  /**
   * Returns `true` if this Rectangle wholly contains the passed rectangle.
   *
   * Note that a {@link Core.helper.util.Point} may be passed.
   * @param {Core.helper.util.Rectangle} other The Rectangle to test for containment within this Rectangle
   * @returns {Boolean} `true` if the other Rectangle is wholly contained within this Rectangle
   */
  contains(other) {
    const me = this;
    if (other.isRectangle) {
      return other._x >= me._x && other._y >= me._y && other.right <= me.right && other.bottom <= me.bottom;
    } else {
      return false;
    }
  }
  /**
   * Checks if this Rectangle intersects the passed Rectangle
   * @param {Core.helper.util.Rectangle} other The Rectangle to intersect with this.
   * @param {Boolean} [useBoolean] Specify `true` to return a boolean value instead of constructing a new Rectangle
   * @param {Boolean} [allowZeroDimensions] `true` to consider zero-width or zero-hight rectangles as intersecting if coordinates indicate the intersection
   * @returns {Core.helper.util.Rectangle|Boolean} Returns the intersection Rectangle or `false` if there is no intersection.
   */
  intersect(other, useBoolean = false, allowZeroDimensions = false) {
    const me = this,
      y = Math.max(me.y, other.y),
      r = Math.min(me.right, other.right),
      b = Math.min(me.bottom, other.bottom),
      x = Math.max(me.x, other.x),
      intersect = allowZeroDimensions ? b >= y && r >= x : b > y && r > x;
    if (intersect) {
      return useBoolean ? true : new Rectangle(x, y, r - x, b - y);
    } else {
      return false;
    }
  }
  equals(other, round = false) {
    const processor = round ? x => Math.round(x) : x => x;
    return other.isRectangle && processor(other.x) === processor(this.x) && processor(other.y) === processor(this.y) && processor(other.width) === processor(this.width) && processor(other.height) === processor(this.height);
  }
  /**
   * Translates this Rectangle by the passed vector. Size is maintained.
   * @param {Number} x The X translation vector.
   * @param {Number} y The Y translation vector.
   * @returns {Core.helper.util.Rectangle} This Rectangle;
   */
  translate(x, y) {
    this._x += x || 0;
    this._y += y || 0;
    return this;
  }
  /**
   * Moves this Rectangle to the passed `x`, `y` position. Size is maintained.
   * @param {Number} x The new X position.
   * @param {Number} y The new Y position.
   * @returns {Core.helper.util.Rectangle}  This Rectangle;
   */
  moveTo(x, y) {
    if (x != null) {
      this._x = x;
    }
    if (y != null) {
      this._y = y;
    }
    return this;
  }
  /**
   * Returns the vector which would translate this Rectangle (or Point) to the same position as the other Rectangle (or point)
   * @param {Core.helper.util.Rectangle|Core.helper.util.Point} other The Rectangle or Point to calculate the delta to.
   * @returns {Array} Returns a vector using format `[deltaX, deltaY]`
   * @internal
   */
  getDelta(other) {
    return [other.x - this.x, other.y - this.y];
  }
  /**
   * The center point of this rectangle.
   * @property {Core.helper.util.Point}
   */
  get center() {
    return new Rectangle.Point(this.x + this.width / 2, this.y + this.height / 2);
  }
  /**
   * Get/sets the X coordinate of the Rectangle. Note that this does *not* translate the
   * Rectangle. The requested {@link #property-width} will change.
   * @property {Number}
   */
  set x(x) {
    const xDelta = x - this._x;
    this._x = x;
    this._width -= xDelta;
  }
  get x() {
    return this._x;
  }
  get start() {
    return this.left;
  }
  /**
   * Alias for x. To match DOMRect.
   * @property {Number}
   */
  set left(x) {
    this.x = x;
  }
  get left() {
    return this.x;
  }
  /**
   * Alias for y. To match DOMRect.
   * @property {Number}
   */
  set top(y) {
    this.y = y;
  }
  get top() {
    return this.y;
  }
  /**
   * Get/sets the Y coordinate of the Rectangle. Note that this does *not* translate the
   * Rectangle. The requested {@link #property-height} will change.
   * @property {Number}
   */
  set y(y) {
    const yDelta = y - this._y;
    this._y = y;
    this._height -= yDelta;
  }
  get y() {
    return this._y;
  }
  /**
   * Get/sets the width of the Rectangle. Note that the requested {@link #property-right} will change.
   * @property {Number}
   */
  set width(width) {
    this._width = width;
  }
  get width() {
    return this._width;
  }
  /**
   * Get/sets the height of the Rectangle. Note that the requested {@link #property-bottom} will change.
   * @property {Number}
   */
  set height(height) {
    this._height = height;
  }
  get height() {
    return this._height;
  }
  /**
   * Get/sets the right edge of the Rectangle. Note that the requested {@link #property-width} will change.
   *
   * The right edge value is exclusive of the calculated rectangle width. So x=0 and right=10
   * means a width of 10.
   * @property {Number}
   */
  set right(right) {
    this._width = right - this._x;
  }
  get right() {
    return this._x + this._width;
  }
  get end() {
    return this.right;
  }
  /**
   * Get/sets the bottom edge of the Rectangle. Note that the requested {@link #property-height} will change.
   *
   * The bottom edge value is exclusive of the calculated rectangle height. So y=0 and bottom=10
   * means a height of 10.
   * @property {Number}
   */
  set bottom(bottom) {
    this._height = bottom - this._y;
  }
  get bottom() {
    return this._y + this._height;
  }
  getStart(rtl, horizontal = true) {
    if (horizontal) {
      return rtl ? this.right : this.left;
    }
    return this.top;
  }
  getEnd(rtl, horizontal = true) {
    if (horizontal) {
      return rtl ? this.left : this.right;
    }
    return this.bottom;
  }
  get area() {
    return this.width * this.height;
  }
  set minWidth(minWidth) {
    const me = this;
    if (isNaN(minWidth)) {
      me._minWidth = null;
    } else {
      me._minWidth = Number(minWidth);
      // If this is being used as an alignment calculation rectangle, minWidth has a different meaning.
      // It does not mean that the width has to be at least this value. It means that under constraint,
      // it is willing to shrink down to that value before falling back to another align position.
      if (!me.isAlignRectangle) {
        me.width = Math.max(me.width, me._minWidth);
      }
    }
  }
  get minWidth() {
    return this._minWidth;
  }
  set minHeight(minHeight) {
    const me = this;
    if (isNaN(minHeight)) {
      me._minHeight = null;
    } else {
      me._minHeight = Number(minHeight);
      // If this is being used as an alignment calculation rectangle, minHeight has a different meaning.
      // It does not mean that the height has to be at least this value. It means that under constraint,
      // it is willing to shrink down to that value before falling back to another align position.
      if (!me.isAlignRectangle) {
        me.height = Math.max(me.height, me._minHeight);
      }
    }
  }
  get minHeight() {
    return this._minHeight;
  }
  /**
   * Modifies the bounds of this Rectangle by the specified deltas.
   * @param {Number} x How much to *add* to the x position.
   * @param {Number} y  How much to *add* to the y position.
   * @param {Number} width  How much to add to the width.
   * @param {Number} height  How much to add to the height.
   * @returns {Core.helper.util.Rectangle} This Rectangle
   */
  adjust(x, y, width, height) {
    const me = this;
    me.x += x;
    me.y += y;
    me.width += width;
    me.height += height;
    return me;
  }
  /**
   * Modifies the bounds of this rectangle by expanding them by the specified amount in all directions.
   * The parameters are read the same way as CSS margin values.
   *
   * - If one value is passed, all edges are inflated by that value.
   * - If two values are passed they are top/bottom inflation and left/right inflation.
   * - If four values are passed, that's top, right, bottom, left.
   * @param {Number} amount How much to inflate, or the top value if more than one values passed.
   * @param {Number} right How much to inflate the right side, or both left and right is only two values passed.
   * @param {Number} bottom How much to inflate the bottom side.
   * @param {Number} left How much to inflate the left side.
   * @returns {Core.helper.util.Rectangle} This Rectangle
   * @internal
   */
  inflate(top, right = top, bottom = top, left = right) {
    if (Array.isArray(top)) {
      [top, right, bottom, left] = parseEdges(top);
    }
    return this.adjust(-left, -top, right, bottom);
  }
  /**
   * Modifies the bounds of this rectangle by reducing them by the specified amount in all directions.
   * The parameters are read the same way as CSS margin values.
   *
   * - If one value is passed, all edges are deflated by that value.
   * - If two values are passed they are top/bottom deflation and left/right deflation.
   * - If four values are passed, that's top, right, bottom, left.
   * @param {Number} amount How much to deflate, or the top value if more than one values passed.
   * @param {Number} right How much to deflate the right side, or both left and right is only two values passed.
   * @param {Number} bottom How much to deflate the bottom side.
   * @param {Number} left How much to deflate the left side.
   * @returns {Core.helper.util.Rectangle} This Rectangle
   * @internal
   */
  deflate(top, right = top, bottom = top, left = right) {
    if (Array.isArray(top)) {
      [top, right, bottom, left] = parseEdges(top);
    }
    return this.adjust(left, top, -right, -bottom);
  }
  /**
   * Attempts constrain this Rectangle into the passed Rectangle. If the `strict` parameter is `true`
   * then this method will return `false` if constraint could not be achieved.
   *
   * If this Rectangle has a `minHeight` or `minWidth` property, size will be adjusted while attempting to constrain.
   *
   * Right and bottom are adjusted first leaving the top and bottom sides to "win" in the case that this Rectangle overflows
   * the constrainTo Rectangle.
   * @param {Core.helper.util.Rectangle} constrainTo The Rectangle to constrain this Rectangle into if possible.
   * @param {Boolean} strict Pass `true` to return false, and leave this Rectangle unchanged if constraint
   * could not be achieved.
   * @returns {Core.helper.util.Rectangle|Boolean} This Rectangle. If `strict` is true, and constraining was not successful, `false`.
   */
  constrainTo(constrainTo, strict) {
    const me = this,
      originalHeight = me.height,
      originalY = me.y,
      minWidth = me.minWidth || me.width,
      minHeight = me.minHeight || me.height;
    if (me.height >= constrainTo.height) {
      // If we're strict, fail if we could *never* fit into available height.
      if (strict && minHeight > constrainTo.height) {
        return false;
      }
      // If we are >= constrain height, we will have to be at top edge of constrainTo
      me._y = constrainTo.y;
      me.height = constrainTo.height;
    }
    if (me.width >= constrainTo.width) {
      // If we're strict, fail if we could *never* fit into available width.
      if (strict && minWidth > constrainTo.width) {
        // Could not be constrained; undo any previous attempt with height
        me.y = originalY;
        me.height = originalHeight;
        return false;
      }
      // If we are >= constrain width, we will have to be at left edge of constrainTo
      me._x = constrainTo.x;
      me.width = constrainTo.width;
    }
    // Overflowing the bottom or right sides, translate upwards or leftwards.
    me.translate.apply(me, me.constrainVector = [Math.min(constrainTo.right - me.right, 0), Math.min(constrainTo.bottom - me.bottom, 0)]);
    // Now, after possible translation upwards or left,
    // if we overflow the top or left, translate downwards or right.
    me.translate(Math.max(constrainTo.x - me.x, 0), Math.max(constrainTo.y - me.y, 0));
    return me;
  }
  /**
   * Returns a cloned version of this Rectangle aligned to a target Rectangle, or element or {@link Core.widget.Widget}.
   * @param {Object} spec Alignment specification.
   * @param {HTMLElement|Core.widget.Widget|Core.helper.util.Rectangle} spec.target The Widget or element or Rectangle to align to.
   * @param {Number[]} [spec.anchorSize] The `[width, height]` of the anchor pointer when in `top` position. The
   * width is the baseline length, and the height is the height of the arrow. If passed, the anchor position
   * will be calculated to be at the centre of the overlap of the two aligned edges and returned in the `anchor`
   * property of the resulting Rectangle:
   *
   *     {
   *         edge: 'top',         // or 'right' or 'bottom' or 'left'
   *         x/y: offset          // dimension to translate and value to translate by.
   *     }
   *
   * @param {Object} [spec.anchorPosition] an `{ x: n, y: n }` anchor translation to be used *if the requested alignment
   * succeeds without violating constraints*. If a fallback alignment is used, the anchor will be centered in the
   * overlap of the aligned edges as usual.
   * @param {Boolean} [spec.overlap] True to allow this to overlap the target.
   * @param {String} spec.align The edge alignment specification string, specifying two points to bring together.
   *
   * Each point is described by an edge initial (`t` for top edge, `b` for bottom edge etc) followed
   * by a percentage along that edge.
   *
   * So the form would be `[trblc][n]-[trblc][n].` The `n` is the percentage offset along that edge
   * which defines the alignment point. This is not valid for alignment point `c` which means the center point.
   *
   * For example `t0-b0' would align this Rectangle's top left corner with the bottom left corner of the `target`.
   * @param {HTMLElement|Core.widget.Widget|Core.helper.util.Rectangle} [spec.constrainTo] The Widget or Element or Rectangle to constrain to.
   * If the requested alignment cannot be constrained (it will first shrink the resulting Rectangle according
   * to the `minWidth` and `minHeight` properties of this rectangle), then it will try aligning at other edges
   * (honouring the `axisLock` option), and pick the fallback alignment which results in the shortest translation.
   * @param {Boolean} [spec.axisLock] Specify as a truthy value to fall back to aligning against the opposite
   * edge first if the requested alignment cannot be constrained into the `constrainTo` option. If specified
   * as `'flexible'`, then fallback will continue searching for solutions on the remaining two sides.
   * @param {Boolean} [spec.matchSize] When aligning edge-to-edge, match the length of the aligned-to
   * edge of the target. This is only honored when `axisLock` is enabled and alignment succeeds on the requested axis.
   * If __not__ aligning edge-to-edge, `matchSize` matches both dimensions of the target.
   * @param {Number|Number[]} [spec.offset] The 'x' and 'y' offset values to create an extra margin round the target
   * to offset the aligned widget further from the target. May be configured as -ve to move the aligned widget
   * towards the target - for example producing the effect of the anchor pointer piercing the target.
   * @param {Number|Number[]} [spec.constrainPadding] The amount of pixels to pad from the `constrainTo` target,
   * either a single value, or an array of values in CSS edge order.
   * @param {Boolean} [spec.rtl] Pass as true if this is being used in an RTL environment, and aligning 0% to
   * 100% along a horizontal edge must proceed from right to left.
   * @returns {Core.helper.util.Rectangle} A new Rectangle aligned as requested if possible, but if the requested position violates
   * the `constrainTo` Rectangle, the shortest translation from the requested position which obeys constraints will be used.
   */
  alignTo(spec) {
    // The target and constrainTo may be passed as HtmlElements or Widgets.
    // If so, extract the Rectangles without mutating the incoming spec.
    let result = this.clone(),
      {
        target,
        constrainTo,
        constrainPadding
      } = spec,
      calculatedAnchorPosition,
      zone,
      resultZone,
      constrainingToViewport;
    if (target && !target.isRectangle) {
      target = Rectangle.from(target.element ? target.element : target);
    }
    if (constrainTo) {
      if (!constrainTo.isRectangle) {
        // Viewport is denoted by requesting window or document.
        // document.body may overflow the viewport, so this must not be evaluated as the viewport.
        constrainingToViewport = constrainTo === globalThis || constrainTo === document;
        // When rectangle is constrained to some element on the page other than window/document, page scroll
        // should not be taken into account
        const ignorePageScroll = 'ignorePageScroll' in spec ? spec.ignorePageScroll : !constrainingToViewport;
        constrainTo = Rectangle.from(constrainTo.element ? constrainTo.element : constrainTo, null, ignorePageScroll);
      }
      // Shrink the constrainTo Rectangle to account for the constrainPadding
      if (constrainPadding) {
        // An array may be used to specify sides in the CSS standard order.
        // One value means all sides reduce by the same amount.
        constrainPadding = parseEdges(constrainPadding);
        // If we are aligning to an element which is closer to an edge than the
        // constrainPadding value for that edge, override the constrainPadding so that
        // the visual alignment is maintained.
        constrainPadding[0] = Math.min(constrainPadding[0], target.top);
        constrainPadding[1] = Math.min(constrainPadding[1], constrainTo.right - target.right);
        constrainPadding[2] = Math.min(constrainPadding[0], constrainTo.bottom - target.bottom);
        constrainPadding[3] = Math.min(constrainPadding[0], target.left);
        // Must clone a passed Rectangle so as not to mutate objects passed in.
        constrainTo = constrainTo.deflate.apply(constrainTo.clone(), constrainPadding);
      }
    }
    const me = this,
      targetOffsets = createOffsets(spec.offset),
      {
        align,
        axisLock,
        anchorSize,
        anchorPosition,
        matchSize,
        position,
        rtl
      } = spec,
      alignSpec = parseAlign(align, rtl),
      targetConstrainRect = constrainTo && constrainTo.clone(),
      constraintZones = [],
      zoneOrder = [{
        zone: zone = alignSpec.startZone,
        align
      }],
      matchDimension = matchSize && matchDimensions[alignSpec.startZone & 1],
      originalSize = me[matchDimension];
    // Match the size of the edge we are aligning against
    if (matchDimension && axisLock) {
      result[matchDimension] = target[matchDimension];
    }
    // If we are not aligning to an edge, match both diensions.
    else if (!alignSpec.edgeAligned && matchSize) {
      result.width = target.width;
      result.height = target.height;
    }
    // Ensure we will fit before trying
    if (constrainTo) {
      result.constrainTo(constrainTo);
    }
    // If we are aligning edge-to-edge, then plan our fallback strategy when we are constrained.
    if (constrainTo && alignSpec.startZone != null) {
      // Create the list of zone numbers and alignments to try in the preferred order.
      //
      // In the case of axisLock, go through the zones by each axis.
      // So if they asked for t-b, which is zone 2,
      // the array will be [2, 0, 3, 1] (t-b, b-t, r-l, l-r)
      if (axisLock) {
        // First axis flip has to maintain the offset along that axis.
        // so align: l0-r0 has to flip to align: r0-l0. See submenu flipping when
        // constrained to the edge. It flips sides but maintains vertical position.
        zoneOrder.push({
          zone: zone = (zone + 2) % 4,
          align: flipAlign(alignSpec)
        });
        // Only try the other axis is axisLock is 'flexible'
        if (axisLock === 'flexible') {
          zoneOrder.push({
            zone: zone = (alignSpec.startZone + 1) % 4,
            align: defaultAlignments[zone]
          });
          zoneOrder.push({
            zone: zone = (zone + 2) % 4,
            align: defaultAlignments[zone]
          });
        }
      }
      // Go through the zones in order from the requested start.
      // So if they asked for t-b, which is zone 2,
      // the array will be [2, 3, 0, 1] (t-b, r-l, b-t, l-r)
      else {
        for (let i = 1; i < 4; i++) {
          zoneOrder.push({
            zone: zone = (zone + 1) % 4,
            align: defaultAlignments[zone]
          });
        }
      }
    }
    // Allow them to pass anchorPosition: {x: 10} to indicate that after a fully successful,
    // unconstrained align, the anchor should be 10px from the start.
    if (anchorPosition) {
      const pos = alignSpec.startZone & 1 ? 'y' : 'x';
      calculatedAnchorPosition = {
        [pos]: anchorPosition[pos],
        edge: edgeNames[(alignSpec.startZone + 2) % 4]
      };
    }
    // Keep the target within reach. If it's way outside, pull it back so that it's only just outside);
    if (targetConstrainRect && target) {
      targetConstrainRect.adjust(-target.width, -target.height, target.width, target.height);
      target.constrainTo(targetConstrainRect);
    }
    // As part of fallback process when fitting within constraints, result may shrink to our minima
    result.minWidth = me.minWidth;
    result.minHeight = me.minHeight;
    // We're being commanded to try to align at a position
    if (position) {
      result.moveTo(position.x, position.y);
      if (constrainTo) {
        result.constrainTo(constrainTo);
      }
    }
    // We're aligning to a Target Rectangle within a ConstrainTo Rectangle, taking into account
    // a possible anchor pointer, or x/y offsets. Here's the situation:
    //
    //                             <-- ConstrainTo Rectangle -->
    //  +-----------------------------------+--------------------+-------------------------+
    //  |                                   |                    |                         |
    //  |                                   |                    |                         |
    //  |                                   |                    |                         |
    //  |-----------------------------------+--------------------+-------------------------+
    //  |                                   |                   |                         |
    //  |                                   | +----------------+ |                         |
    //  |                                   | |                | |                         |
    //  |                                   | |                | |                         |
    //  |                                   ||     Target     ||                         |
    //  |                                   | |                | |                         |
    //  |                                   | |                | |                         |
    //  |                                   | +----------------+ |                         |
    //  |                                   |                   |                         |
    //  +-----------------------------------+--------------------+-------------------------|
    //  |                                   |                    |                         |
    //  |                                   |                    |                         |
    //  |                                   |                    |                         |
    //  +-----------------------------------+--------------------+-------------------------+
    //
    // Which results in the four possible constraint zones above, which we index in standard CSS order.
    //
    // Top    = 0
    // Right  = 1
    // Bottom = 2
    // Left   = 3
    //
    // If the initially requested alignment is not within the constrainTo rectangle
    // then, calculate these four, and then loop through them, beginning at the requested one,
    // quitting when we find a position which does not violate constraints. This includes
    // shrinking the aligning Rectangle towards its minima to attempt a fit.
    //
    // The final fallback, if there is no position which does not violate constraints
    // is to position in whichever of the four rectangles has the largest area shrinking overflowing
    // dimensions down to minima if specified.
    //
    else {
      // Offsets: If we are using an anchor to move away from the target, use anchor height in both dimensions.
      // It's rotated so that "height" always has the same meaning. It's the height of the arrow.
      const centerAligned = alignSpec.myEdge === 'c' || alignSpec.targetEdge === 'c',
        offsets = anchorSize && !centerAligned ? [anchorSize[1] + targetOffsets[0], anchorSize[1] + targetOffsets[1]] : targetOffsets,
        targetPoint = target.getAlignmentPoint(alignSpec.targetAlignmentPoint, offsets),
        myPoint = result.getAlignmentPoint(alignSpec.myAlignmentPoint);
      result.translate(targetPoint[0] - myPoint[0], targetPoint[1] - myPoint[1]);
      // If an overlapping position was requested, then we are *not* trying out those four zones.
      // We just respect constraint, and that's it.
      let overlap = result.intersect(target, true);
      // If we are aligned over our target, we just obey that within any constraint.
      // No complex edge alignment attempts to fall back to.
      if (overlap) {
        if (constrainTo) {
          result.constrainTo(constrainTo);
        }
        resultZone = alignSpec.startZone;
        result.translate(...offsets);
      }
      // Aligned to outside of our target, and we need to be constrained
      else if (constrainTo && !constrainTo.contains(result)) {
        const requestedResult = result.clone(),
          solutions = [];
        let zone, largestZone;
        // Any configured anchorPosition becomes invalid now that we're having to move the resulting zone
        // to some unpredictable new place where it fits. It will have to be calculated based upon where
        // we end up aligning.
        calculatedAnchorPosition = null;
        // Calculate the four constraint zones illustrated above.
        // Top
        constraintZones[0] = zone = constrainTo.clone();
        zone.bottom = target.y - offsets[1];
        // Right
        constraintZones[1] = zone = constrainTo.clone();
        zone.x = target.right + offsets[0];
        // Bottom
        constraintZones[2] = zone = constrainTo.clone();
        zone.y = target.bottom + offsets[1];
        // Left
        constraintZones[3] = zone = constrainTo.clone();
        zone.right = target.x - offsets[0];
        // Start from the preferred edge and see if we are able to constrain to within each rectangle
        for (let i = 0; i < zoneOrder.length; i++) {
          // Revert to incoming dimension for fallback out of axisLock
          if (matchDimension && i == 2) {
            result[matchDimension] = originalSize;
          }
          zone = constraintZones[resultZone = zoneOrder[i].zone];
          // Perform unconstrained alignment at the calculated alignment for the zone
          result = result.alignTo({
            target,
            offsets,
            align: zoneOrder[i].align
          });
          // If we are able to strictly constrain into this area, then it's one of the possible solutions.
          // We choose the solution which result in the shortest translation from the initial position.
          if (result.constrainTo(zone, true)) {
            solutions.push({
              result,
              zone: resultZone
            });
            // If this successful constraint is at the requested alignment, or at a fallback
            // alignment which has used min size constraints, then that's the correct solution.
            // If there's no size compromising, we have to pick the shortest translation.
            if (!largestZone || result.width < me.width || result.height < me.height) {
              result.align = zoneOrder[i].align;
              break;
            }
          }
          // Cache the largest zone we find in case we need the final fallback.
          if (!largestZone || zone.area > largestZone.area) {
            const r = result.clone();
            // And just move the result clone into the edge zone
            switch (resultZone) {
              // Top
              case 0:
                r.moveTo(null, zone.bottom - r.height);
                break;
              // Right
              case 1:
                r.moveTo(zone.left);
                break;
              // Bottom
              case 2:
                r.moveTo(null, zone.top);
                break;
              // Left
              case 3:
                r.moveTo(zone.right - r.width);
                break;
            }
            largestZone = {
              area: zone.area,
              result: r,
              zone: resultZone
            };
          }
        }
        // The loop found at least one solution
        if (solutions.length) {
          // Multiple fallbacks with no axisLock.
          // Use the solution which resulted in the shortest translation distance from the requested alignment.
          if (solutions.length > 1 && !axisLock) {
            solutions.sort((s1, s2) => {
              const s1TranslationDistance = Math.sqrt((requestedResult.x - s1.result.x) ** 2 + (requestedResult.y - s1.result.y) ** 2),
                s2TranslationDistance = Math.sqrt((requestedResult.x - s2.result.x) ** 2 + (requestedResult.y - s2.result.y) ** 2);
              return s1TranslationDistance - s2TranslationDistance;
            });
          }
          // Initial success, or axisLock. Use first successful solution.
          result = solutions[0].result;
          resultZone = solutions[0].zone;
        }
        // No solutions found - use the largest rectangle.
        else {
          result = largestZone.result;
          resultZone = largestZone.zone;
          // When we are constraining to the viewport, we must still must be constrained,
          // even after we've given up making it align *and* constrain.
          if (constrainingToViewport) {
            result.constrainTo(constrainTo);
          }
        }
      } else {
        resultZone = alignSpec.startZone;
      }
      result.zone = resultZone;
      result.overlap = overlap = result.intersect(target, true);
      // If they included an anchor, calculate its position along its edge.
      if (anchorSize && !overlap) {
        // If we were passed an anchorPosition, and it has remained valid (meaning the requested
        // alignment succeeded with no constraint), then anchorPosition will be set. If not,
        // we have to calculate it based upon the aligned edge.
        if (!calculatedAnchorPosition) {
          const isLeftOrRight = resultZone & 1,
            start = isLeftOrRight ? 'y' : 'x',
            end = isLeftOrRight ? 'bottom' : 'right',
            startValue = Math.max(target[start], result[start]),
            endValue = Math.min(target[end], result[end]);
          let anchorStart = startValue + (endValue - startValue) / 2 - anchorSize[0] / 2;
          const anchorEnd = anchorStart + anchorSize[0];
          if (anchorEnd > result[end]) {
            anchorStart -= anchorEnd - result[end];
          }
          if (anchorStart < result[start]) {
            anchorStart += result[start] - anchorStart;
          }
          // Return an anchor property which will have an x or y property and an edge name onto which the
          // arrow should be aligned.
          calculatedAnchorPosition = {
            [start]: anchorStart - result[start],
            edge: edgeNames[(resultZone + 2) % 4]
          };
        }
        result.anchor = calculatedAnchorPosition;
      }
    }
    return result;
  }
  /**
   * Returns the `[x, y]` position of the specified anchor point of this Rectangle in <edge><offset> format.
   * for example passing "t50" will return the centre point of the top edge, passing "r0" will return the start
   * position of the right edge (the top right corner).
   *
   * Note that the offset defaults to 50, so "t" means the centre of the top edge.
   * @param {String} alignmentPoint The alignment point to calculate. Must match the RegExp `[trbl]\d*`
   * @param {Number[]} margins The `[x, y]` margins to add from the left/right, top/bottom edge.
   * @internal
   */
  getAlignmentPoint(alignmentPoint, margins = zeroOffsets) {
    const me = this,
      parts = alignPointRe.exec(alignmentPoint),
      edge = parts[1].toLowerCase(),
      edgeOffset = Math.min(Math.max(parseInt(parts[2] || 50), 0), 100) / 100;
    switch (edge) {
      case 't':
        return [me.x + me.width * edgeOffset, me.y - margins[1]];
      case 'r':
        return [me.right + margins[0], me.y + me.height * edgeOffset];
      case 'b':
        return [me.x + me.width * edgeOffset, me.bottom + margins[1]];
      case 'l':
        return [me.x - margins[0], me.y + me.height * edgeOffset];
      case 'c':
        {
          return [me.x + me.width / 2, me.y + me.height / 2];
        }
    }
  }
  /**
   * Highlights this Rectangle using the highlighting effect of {@link Core.helper.DomHelper}
   * on a transient element which encapsulates the region's area.
   */
  highlight() {
    const me = this,
      highlightElement = DomHelper.createElement({
        parent: document.body,
        style: `position:absolute;z-index:9999999;pointer-events:none;
                            left:${me.x}px;top:${me.y}px;width:${me.width}px;height:${me.height}px`
      });
    return DomHelper.highlight(highlightElement).then(() => highlightElement.remove());
  }
  /**
   * Visualizes this Rectangle by adding a DOM element which encapsulates the region's area into the provided parent element.
   * @param {DomConfig} config Element config object
   * @returns {Element} The highlight element
   * @internal
   */
  visualize(config, asDomConfig) {
    const me = this,
      domConfig = ObjectHelper.merge({
        style: {
          left: `${me.x}px`,
          top: `${me.y}px`,
          width: `${me.width}px`,
          height: `${me.height}px`,
          pointerEvents: 'none',
          // If this visualization is provided a CSS class, let outside handle position + z-index
          ...(config.class ? {} : {
            position: 'absolute',
            'z-index': 9999999
          })
        }
      }, config);
    return asDomConfig ? domConfig : DomHelper.createElement(domConfig);
  }
  toString(delimiter = ',') {
    return [`${this.top}px`, `${this.right}px`, `${this.bottom}px`, `${this.left}px`].join(delimiter);
  }
}
Rectangle._$name = 'Rectangle';

/**
 * @module Core/helper/util/DomClassList
 */
const valueSymbol = Symbol('value'),
  lengthSymbol = Symbol('length');
/**
 * This class encapsulates a list of CSS classes which can be set as the `className`
 * on an `HTMLElement`.
 *
 * Properties names set on this class equate to *adding* a class if the property's value
 * is _truthy_, or removing a class if the value is _falsy_.
 *
 * ```javascript
 * const myClassList = new DomClassList('b-test-button');
 *
 * myClassList.add('test-class');
 * myClassList.important = 1;
 *
 * myHtmlElement.className = myClassList; // Sets it to "b-test-button test-class important"
 * ```
 */
class DomClassList {
  static change(cls, add, remove, as = 'string') {
    remove = DomClassList.normalize(remove, 'object');
    const after = DomClassList.normalize(cls, 'array').filter(c => !remove[c]);
    if (add) {
      add = DomClassList.normalize(add, 'array');
      for (let i = 0; i < add.length; ++i) {
        if (!after.includes(add[i])) {
          after.push(add[i]);
        }
      }
    }
    return DomClassList.normalize(after, as);
  }
  static from(classes, returnEmpty) {
    if (classes) {
      if (classes.isDomClassList) {
        returnEmpty = returnEmpty ?? true;
      } else {
        returnEmpty = returnEmpty ?? (Objects.isObject(classes) && !Objects.isEmpty(classes));
        classes = new DomClassList(classes);
      }
      if (!classes.value && !returnEmpty) {
        classes = null;
      }
    }
    return classes || (returnEmpty ? new DomClassList() : null);
  }
  /**
   * Converts a class name of any understood type to a desired form.
   * @param {String|String[]|Object|Set|Map|HTMLElement} cls
   * @param {String} as Pass `'object'` to return an object with the class names as its keys (all keys will have a
   * value of `true`), or pass `'array'` to return an array of class names, or pass `'string'` (the default) to
   * return a space-separated string of class names.
   * @returns {String|String[]|Object}
   * @internal
   */
  static normalize(cls, as = 'string') {
    cls = cls || ''; // promote null to '' to avoid typeof snag
    const type = typeof cls,
      asArray = as === 'array',
      asObject = as === 'object',
      asString = !asArray && !asObject;
    let isString = type === 'string',
      c,
      i,
      ret;
    if (type === 'object') {
      var _cls;
      if (cls.nodeType === Element.ELEMENT_NODE && typeof cls.getAttribute === 'function') {
        cls = cls.getAttribute('class') || ''; // cannot use className for SVG el's
        isString = true;
      } else if ((_cls = cls) !== null && _cls !== void 0 && _cls.isDomClassList) {
        cls = cls.values;
      } else if (cls instanceof DOMTokenList) {
        cls = Array.from(cls);
      } else if (cls instanceof Map) {
        cls = Array.from(cls.keys()).filter(k => cls.get(k));
      } else if (cls instanceof Set) {
        cls = Array.from(cls);
      } else if (!Array.isArray(cls)) {
        cls = Objects.getTruthyKeys(cls);
      }
    }
    if (isString) {
      // Pass through Set to ensure only unique class names
      cls = [...new Set(StringHelper.split(cls))];
    }
    // cls is now an array
    for /* empty */
    (i = cls.length; i-- > 0;) {
      c = cls[i];
      if (!c.length) {
        cls.splice(i, 1);
      } else if (c.includes(' ')) {
        cls.splice(i, 1, ...StringHelper.split(c));
      }
    }
    if (asArray) {
      ret = cls;
    } else if (asString) {
      ret = cls.join(' ');
    } else {
      ret = Object.create(null);
      for (i = 0; i < cls.length; ++i) {
        ret[cls[i]] = true;
      }
    }
    return ret;
  }
  /**
   * Initializes a new DomClassList.
   * @param {...String|Object} classes The CSS classes as strings or objects.
   * @function constructor
   */
  constructor(...classes) {
    this.process(1, classes);
  }
  /**
   * Clears all class names from this DomClassList instance.
   * @returns {Core.helper.util.DomClassList} this DomClassList.
   */
  clear() {
    // Keep internal class same shape. Do not delete members.
    for (const key in this) {
      this[key] = false;
    }
    return this;
  }
  /**
   * Sets this DomClassList instance to represent the classes passed as either strings or objects.
   * @returns {Core.helper.util.DomClassList} this DomClassList.
   */
  set(...classes) {
    return this.clear().process(1, classes);
  }
  // To gain some speed in DomHelper.sync(), faster than instanceof etc
  get isDomClassList() {
    return true;
  }
  /**
   * Returns a clone of this DomClassList with all the same keys set.
   * @returns {Core.helper.util.DomClassList} A clone of this DomClassList.
   */
  clone() {
    return new DomClassList(this);
  }
  /**
   * Returns a Boolean value, indicating whether this ClassList has the specified CSS class name.
   * @param {String} className CSS class name to check
   * @returns {Boolean} true if this ClassList contains the passed CSS class name, false otherwise
   */
  contains(className) {
    if (typeof className === 'string' && className) {
      return Boolean(this[className]);
    }
    return false;
  }
  // An instance of this class may be assigned directly to an element's className
  // it will be coerced to a string value using this method.
  toString() {
    // Adding space at the end if there is content to make concatenation code simpler in renderers.
    return this.length ? `${this.value} ` : '';
  }
  toJSON() {
    return this.toString();
  }
  /**
   * Analogous to string.trim, returns the string value of this `DomClassList` with no trailing space.
   * @returns {String} A concatenated string value of all the class names in this `DomClassList`
   * separated by spaces.
   */
  trim() {
    return this.value;
  }
  /**
   * Compares this DomClassList to another DomClassList (or class name string of space separated classes).
   * If the same class names (regardless of order) are present, the two are considered equal.
   *
   * So `new DomClassList('foo bar bletch').isEqual('bletch bar foo')` would return `true`
   * @param {Core.helper.util.DomClassList|String} other The `DomClassList` or string of classes to compare to.
   * @returns {Boolean} `true` if the two contain the same class names.
   */
  isEqual(other) {
    const otherClasses = DomClassList.normalize(other, 'array'),
      len = otherClasses.length;
    if (this.length === len) {
      for (let i = 0; i < len; i++) {
        if (!this[otherClasses[i]]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  /**
   * Get/set string value.
   * Class names separated with space.
   * @property {String}
   */
  get value() {
    let value = this[valueSymbol],
      keys;
    if (value == null) {
      keys = Objects.getTruthyKeys(this);
      this[lengthSymbol] = keys.length;
      this[valueSymbol] = value = keys.join(' ');
    }
    return value;
  }
  set value(value) {
    const me = this,
      keys = Object.keys(me),
      len = keys.length;
    for (let i = 0; i < len; i++) {
      delete me[keys[i]];
    }
    if (value) {
      me.process(1, [value]);
    } else {
      // String value needs recalculating
      delete me[valueSymbol];
    }
  }
  /**
   * Returns string values as an array.
   * @readonly
   * @property {String[]}
   */
  get values() {
    return Objects.getTruthyKeys(this);
  }
  get length() {
    // Maintainer: We MUST access the value getter to force
    // the value to be calculated if it's currently dirty.
    return this.value ? this[lengthSymbol] : 0;
  }
  process(value, classes) {
    for (let cls, k, i = 0; i < classes.length; i++) {
      if (classes[i]) {
        cls = classes[i];
        if (cls.isDomClassList || Objects.isObject(cls)) {
          // preserve all keys, even falsy ones
          for (k in cls) {
            this[k] = value ? cls[k] : !cls[k];
          }
        } else {
          cls = DomClassList.normalize(classes[i], 'array');
          for (k = 0; k < cls.length; ++k) {
            this[cls[k]] = value;
          }
        }
      }
    }
    // String value needs recalculating
    delete this[valueSymbol];
    return this;
  }
  /**
   * Adds/removes class names according to the passed object's properties.
   *
   * Properties with truthy values are added.
   * Properties with falsy values are removed.
   * @param {Object} classList Object containing properties to set/clear
   */
  assign(classList) {
    for (const cls in classList) {
      if (!this[cls] !== !classList[cls]) {
        this[cls] = classList[cls];
        // String value needs recalculating
        delete this[valueSymbol];
      }
    }
    return this;
  }
  /**
   * Adds/removes this objects classes to the passed `classList` or element.
   *
   * Properties with truthy values are added.
   * Properties with falsy values are removed.
   * @param {HTMLElement|DOMTokenList} element The element or the element's `classList` to be updated.
   */
  assignTo(element) {
    const classList = element.nodeType === Element.ELEMENT_NODE ? element.classList : element,
      temp = DomClassList.from(classList);
    temp.add(this);
    classList.value = temp.value;
  }
  /**
   * Add CSS class(es)
   * ```
   * myClassList.add('bold', 'small');
   * ```javascript
   * @param {String|String[]|Object} classes CSS classes to add
   */
  add(...classes) {
    return this.process(1, classes);
  }
  /**
   * Remove CSS class(es)
   * ```javascript
   * myClassList.remove('bold', 'small');
   * ```
   * @param {String} classes CSS classes to remove
   */
  remove(...classes) {
    return this.process(0, classes);
  }
  /**
   * Toggles the passed CSS class name.
   *
   * If the `force` parameter is passed, `true` means add the class name, `false` means remove it.
   *
   * ```javascript
   * myClassList.toggle('bold', isImportant);
   * ```
   * @param {String} className CSS class to toggle
   * @param {Boolean} [force] `true` to add the class, `false` to remove it.
   * @returns {Boolean} `true` if the operation changed the value.
   */
  toggle(className, flag = Boolean(!this[className])) {
    flag = Boolean(flag);
    // Only disturb the set classwes if we need to.
    if (Boolean(this[className]) !== flag) {
      this[className] = flag;
      // String value needs recalculating
      delete this[valueSymbol];
      return true;
    }
  }
  /**
   * Analogous to the `String#split` method, but with no delimiter
   * parameter. This method returns an array containing the individual
   * CSS class names set.
   * @returns {String[]} The individual class names in this `DomClassList`
   */
  split() {
    return Objects.getTruthyKeys(this);
  }
  forEach(fn) {
    return Objects.getTruthyKeys(this).forEach(fn);
  }
}
// We put this on the prototype and delete it from instances to mark dirty state. This maintains the same shape for
// the instance to help the JIT
DomClassList.prototype[valueSymbol] = null;
DomClassList._$name = 'DomClassList';

/**
 * @module Core/helper/util/Point
 */
/**
 * Encapsulates an X,Y coordinate point.
 * @extends Core/helper/util/Rectangle
 */
class Point extends Rectangle {
  /**
   * Creates a new Point encapsulating the event's page position.
   * @param {Event} event
   * @returns {Core.helper.util.Point}
   * @typings ignore
   */
  static from(event) {
    const touchPoints = event.changedTouches;
    return new Point(touchPoints ? touchPoints[0].screenX : event.screenX, touchPoints ? touchPoints[0].screenY : event.pageY);
  }
  /**
   * Constructs a Point
   * @param x The X coordinate
   * @param y The Y coordinate
   */
  constructor(x, y) {
    super(x, y, 0, 0);
  }
  /**
   * Coerces this Point to be within the passed Rectangle. Translates it into the bounds.
   * @param {Core.helper.util.Rectangle} into The Rectangle into which to coerce this Point.
   */
  constrain(into) {
    this.x = Math.min(Math.max(this.x, into.x), into.right - 1);
    this.y = Math.min(Math.max(this.y, into.y), into.bottom - 1);
    return this;
  }
  toArray() {
    return [this.x, this.y];
  }
}
// The Rectangle class uses the Point class, but cannot import it.
Object.getPrototypeOf(Point).Point = Point;
Point._$name = 'Point';

/* eslint-disable bryntum/no-on-in-lib */
/**
 * @module Core/helper/EventHelper
 */
/**
 * @typedef {Object.<String,Function|Boolean|Object|Object[]|Number|String>} ElementListenerConfig
 * @property {HTMLElement} options.element The element to add the listener to.
 * @property {Object} options.thisObj The default `this` reference for all handlers added in this call.
 * @property {Boolean} [options.autoDetach=true] The listeners are automatically removed when the `thisObj` is destroyed.
 * @property {String} [options.delegate] A CSS selector string which only fires the handler when the event takes place in a matching element.
 * @property {Boolean} [options.once] Specify as `true` to have the listener(s) removed upon first invocation.
 * @property {Number} [options.delay] The number of milliseconds to delay the handler call after the event fires:
 * @property {Number|Object} [options.expires] The listener only waits for a specified time before
 * being removed. The value may be a number or an object containing an expiry handler.
 * @property {Number} [options.expires.delay] How long to wait for the event for.
 * @property {String|Function} [options.expires.alt] The function to call when the listener expires
 * **without having been triggered**.
 */
const touchProperties = ['clientX', 'clientY', 'pageX', 'pageY', 'screenX', 'screenY'],
  isOption = {
    element: 1,
    thisObj: 1,
    once: 1,
    delegate: 1,
    delay: 1,
    capture: 1,
    passive: 1,
    throttled: 1,
    autoDetach: 1,
    expires: 1,
    block: 1
  },
  configurable = true,
  returnTrueProp = {
    configurable,
    value: true
  },
  normalizedKeyNames = {
    Spacebar: 'Space',
    Del: 'Delete',
    Esc: 'Escape',
    Left: 'ArrowLeft',
    Up: 'ArrowUp',
    Right: 'ArrowRight',
    Down: 'ArrowDown'
  },
  // Required to identify a keyup event for special key
  specialKeys = {
    Control: 'ctrl',
    Alt: 'alt',
    Shift: 'shift'
  },
  specialKeyRe = /^(ctrl|shift|alt|meta)$/,
  eventProps = ['altKey', 'bubbles', 'button', 'buttons', 'cancelBubble', 'cancelable', 'clientX', 'clientY', 'ctrlKey', 'layerX', 'layerY', 'metaKey', 'pageX', 'pageY', 'returnValue', 'screenX', 'screenY', 'shiftKey'];
/**
 * Utility methods for dealing with Events, normalizing Touch/Pointer/Mouse events.
 */
class EventHelper {
  /**
   * DOM event to trigger name mapping.
   * @internal
   */
  static eventNameMap = {
    mousedown: 'MouseDown',
    mouseup: 'MouseUp',
    click: 'Click',
    dblclick: 'DblClick',
    contextmenu: 'ContextMenu',
    mouseenter: 'MouseEnter',
    mouseleave: 'MouseLeave',
    mousemove: 'MouseMove',
    mouseover: 'MouseOver',
    mouseout: 'MouseOut',
    keyup: 'KeyUp',
    keydown: 'KeyDown',
    keypress: 'KeyPress'
  };
  static normalizeEvent(event) {
    return ObjectHelper.copyPropertiesIf(event, event.changedTouches[0] || event.touches[0], touchProperties);
  }
  /**
   * For use when synthesizing events from native DOM events. Copies valid properties from the passed
   * event into the destination object;
   * @param {Object} dest Destination object
   * @param {Event} event The event whose properties to copy
   * @returns {Object} An event construction object.
   * @internal
   */
  static copyEvent(dest, event) {
    return ObjectHelper.copyProperties(dest, event, eventProps);
  }
  /**
   * Returns the `[x, y]` coordinates of the event in the viewport coordinate system.
   * @param {Event} event The event
   * @returns {Number[]} The coordinate.
   */
  static getXY(event) {
    if (event.touches) {
      event = event.touches[0];
    }
    return [event.clientX, event.clientY];
  }
  /**
   * Returns the pixel distance between two mouse/touch/pointer events.
   * @param {Event} event1 The first event.
   * @param {Event} event2 The second event.
   * @returns {Number} The distance in pixels between the two events.
   */
  static getDistanceBetween(event1, event2) {
    const xy1 = EH.getXY(event1),
      xy2 = EH.getXY(event2);
    // No point in moving this to Point. We are dealing only with number values here.
    return Math.sqrt(Math.pow(xy1[0] - xy2[0], 2) + Math.pow(xy1[1] - xy2[1], 2));
  }
  /**
   * Returns a {@link Core.helper.util.Point} which encapsulates the `pageX/Y` position of the event.
   * May be used in {@link Core.helper.util.Rectangle} events.
   * @param {Event} event A browser mouse/touch/pointer event.
   * @returns {Core.helper.util.Point} The page point.
   */
  static getPagePoint(event) {
    return new Rectangle.Point(event.pageX, event.pageY);
  }
  /**
   * Returns a {@link Core.helper.util.Point} which encapsulates the `clientX/Y` position of the event.
   * May be used in {@link Core.helper.util.Rectangle} events.
   * @param {Event} event A browser mouse/touch/pointer event.
   * @returns {Core.helper.util.Point} The page point.
   */
  static getClientPoint(event) {
    return new Rectangle.Point(event.clientX, event.clientY);
  }
  /**
   * Add a listener or listeners to an element
   * The `options` parameter allows supplying options for the listener(s), for available options see {@link #typedef-ElementListenerConfig}.
   *
   * @param {HTMLElement} element The element to add a listener/listeners to.
   * @param {String|Object} eventName Either a string, being the name of the event to listen for,
   * or an options object containing event names and options as keys. See the options parameter
   * for details, or the {@link #function-on-static} method for details.
   * @param {Function} [handler] If the second parameter is a string event name, this is the handler function.
   * @param {ElementListenerConfig} [options] If the second parameter is a string event name, this is the options.
   * @returns {Function} A detacher function which removes all the listeners when called.
   */
  static addListener(element, eventName, handler, options) {
    if (element.nodeType) {
      // All separate params, element, eventName and handler
      if (typeof eventName === 'string') {
        options = Object.assign({
          element,
          [eventName]: handler
        }, options);
      }
      // element, options
      else {
        options = Object.assign({
          element
        }, eventName);
      }
    }
    // Just an options object passed
    else {
      options = element;
    }
    return EH.on(options);
  }
  /**
   * Adds a listener or listeners to an element.
   * all property names other than the options listed below are taken to be event names,
   * and the values as handler specs.
   *
   * A handler spec is usually a function reference or the name of a function in the `thisObj`
   * option.
   *
   * But a handler spec may also be an options object containing a `handler` property which is
   * the function or function name, and local options, including `element` and `thisObj`
   * which override the top level options.
   *
   * The `options` parameter allows supplying options for the listener(s), for available options see {@link #typedef-ElementListenerConfig}.
   *
   *  Usage example
   *
   * ```javascript
   * construct(config) {
   *     super.construct(config);
   *
   *     // Add auto detaching event handlers to this Widget's reference elements
   *     EventHelper.on({
   *         element : this.iconElement,
   *         click   : '_handleIconClick',
   *         thisObj : this,
   *         contextmenu : {
   *             element : document,
   *             handler : '_handleDocumentContextMenu'
   *         }
   *     });
   * }
   *```
   *
   * The `click` handler on the `iconElement` calls `this._handleIconClick`.
   *
   * The `contextmenu` handler is added to the `document` element, but the `thisObj`
   * is defaulted in from the top `options` and calls `this._handleDocumentContextMenu`.
   *
   * Note that on touch devices, `dblclick` and `contextmenu` events are synthesized.
   * Synthesized events contain a `browserEvent` property containing the final triggering
   * event of the gesture. For example a synthesized `dblclick` event would contain a
   * `browserEvent` property which is the last `touchend` event. A synthetic `contextmenu`
   * event will contain a `browserEvent` property which the longstanding `touchstart` event.
   *
   * @param {ElementListenerConfig} options The full listener specification.
   * @returns {Function} A detacher function which removes all the listeners when called.
   */
  static on(options) {
    const element = options.element,
      thisObj = options.thisObj,
      handlerDetails = [];
    for (const eventName in options) {
      // Only treat it as an event name if it's not a supported option
      if (!isOption[eventName]) {
        let handlerSpec = options[eventName];
        if (typeof handlerSpec !== 'object') {
          handlerSpec = {
            handler: handlerSpec
          };
        }
        const targetElement = handlerSpec.element || element;
        // Keep track of the real handlers added.
        // addElementLister returns [ element, eventName, addedFunction, capture ]
        handlerDetails.push(EH.addElementListener(targetElement, eventName, handlerSpec, options));
      }
    }
    const detacher = () => {
      for (let handlerSpec, i = 0; i < handlerDetails.length; i++) {
        handlerSpec = handlerDetails[i];
        EH.removeEventListener(handlerSpec[0], handlerSpec[1], handlerSpec[2]);
      }
      handlerDetails.length = 0;
    };
    // { autoDetach : true, thisObj : scheduler } means remove all listeners when the scheduler dies.
    if (thisObj && options.autoDetach !== false) {
      thisObj.doDestroy = FunctionHelper.createInterceptor(thisObj.doDestroy, detacher, thisObj);
    }
    return detacher;
  }
  /**
   * Used internally to add a single event handler to an element.
   * @param {HTMLElement} element The element to add the handler to.
   * @param {String} eventName The name of the event to add a handler for.
   * @param {Function|String|Object} handlerSpec Either a function to call, or
   * the name of a function to call in the `thisObj`, or an object containing
   * the handler local options.
   * @param {Function|String} [handlerSpec.handler] Either a function to call, or
   * the name of a function to call in the `thisObj`.
   * @param {HTMLElement} [handlerSpec.element] Optionally a local element for the listener.
   * @param {Object} [handlerSpec.thisObj] A local `this` specification for the handler.
   * @param {Object} defaults The `options` parameter from the {@link #function-addListener-static} call.
   * @private
   */
  static addElementListener(element, eventName, handlerSpec, defaults) {
    const handler = EH.createHandler(element, eventName, handlerSpec, defaults),
      {
        spec
      } = handler,
      expires = handlerSpec.expires || defaults.expires,
      options = spec.capture != null || spec.passive != null ? {
        capture: spec.capture,
        passive: spec.passive
      } : undefined;
    element.addEventListener(eventName, handler, options);
    if (expires) {
      // Extract expires : { delay : 100, alt : 'onExpireFn' }
      const thisObj = handlerSpec.thisObj || defaults.thisObj,
        delayable = thisObj !== null && thisObj !== void 0 && thisObj.isDelayable ? thisObj : globalThis,
        {
          alt
        } = expires,
        delay = alt ? expires.delay : expires,
        {
          spec
        } = handler;
      // expires is not applied with other options in createHandler(), store it here
      spec.expires = expires;
      spec.timerId = delayable[typeof delay === 'number' ? 'setTimeout' : 'requestAnimationFrame'](() => {
        spec.timerId = null;
        EH.removeEventListener(element, eventName, handler);
        // If we make it here and the handler has not been called, invoke the alt handler
        if (alt && !handler.called) {
          (typeof alt === 'string' ? thisObj[alt] : alt).call(thisObj);
        }
      }, delay, `listener-timer-${performance.now()}`);
    }
    return [element, eventName, handler, options];
  }
  // composedPath throws in salesforce
  // https://github.com/bryntum/support/issues/4432
  static getComposedPathTarget(event) {
    return event.composedPath()[0] || event.path[0];
  }
  static fixEvent(event) {
    var _target$getRootNode, _target$getRootNode$c, _event$relatedTarget;
    if (event.fixed) {
      return event;
    }
    const {
      type,
      target
    } = event;
    // When we listen to event on document and get event which bubbled from shadow dom, reading its target would
    // return shadow root element, or null if accessed in an async timeframe.
    // We need actual element which started the event
    if ((target !== null && target !== void 0 && target.shadowRoot || target !== null && target !== void 0 && (_target$getRootNode = target.getRootNode) !== null && _target$getRootNode !== void 0 && (_target$getRootNode$c = _target$getRootNode.call(target)) !== null && _target$getRootNode$c !== void 0 && _target$getRootNode$c.host) && event.composedPath) {
      const targetElement = this.getComposedPathTarget(event),
        originalTarget = target;
      // Can there be an event which actually originated from custom element, not its shadow dom?
      Object.defineProperty(event, 'target', {
        value: targetElement,
        configurable
      });
      // Save original target just in case
      Object.defineProperty(event, 'originalTarget', {
        value: originalTarget,
        configurable
      });
    }
    // Flag that we have fixed this event
    Object.defineProperty(event, 'fixed', returnTrueProp);
    // Normalize key names
    if (type.startsWith('key')) {
      const normalizedKeyName = normalizedKeyNames[event.key];
      if (normalizedKeyName) {
        Object.defineProperty(event, 'key', {
          value: normalizedKeyName,
          configurable
        });
      }
      // Polyfill the code property for SPACE because it is not set for synthetic events.
      if (event.key === ' ' && !event.code) {
        Object.defineProperty(event, 'code', {
          value: 'Space',
          configurable
        });
      }
    }
    // Sync OSX's meta key with the ctrl key. This will only happen on Mac platform.
    // It's read-only, so define a local property to return true for ctrlKey.
    if (event.metaKey && !event.ctrlKey) {
      Object.defineProperty(event, 'ctrlKey', returnTrueProp);
    }
    // if (isRTL && (type.startsWith('mouse') || type.startsWith('pointer') || type === 'click')) {
    //     event.nativePageX = event.pageX;
    //
    //     if (!Object.getOwnPropertyDescriptor(event, 'pageX')) {
    //         Object.defineProperties(event, {
    //             pageX : {
    //                 get : () => {
    //                     return document.body.offsetWidth - event.nativePageX;
    //                 }
    //             }
    //         });
    //     }
    // }
    // offsetX/Y are within padding box. Border is outside padding box, so -ve values are possible
    // which are not useful for calculating intra-element positions.
    // We add borderOffsetX and borderOffsetY properties which are offsets within the border box.
    // Tested in EventHelper.js
    if (target && 'offsetX' in event) {
      // Wrap calculating `borderOffsetX/Y` until this property is actually accessed in the code to avoid forced reflow.
      if (!Object.getOwnPropertyDescriptor(event, 'borderOffsetX')) {
        Object.defineProperty(event, 'borderOffsetX', {
          get: () => {
            return event.offsetX + (BrowserHelper.isSafari ? 0 : parseInt(target.ownerDocument.defaultView.getComputedStyle(target).getPropertyValue('border-left-width')));
          }
        });
      }
      if (!Object.getOwnPropertyDescriptor(event, 'borderOffsetY')) {
        Object.defineProperty(event, 'borderOffsetY', {
          get: () => {
            return event.offsetY + (BrowserHelper.isSafari ? 0 : parseInt(target.ownerDocument.defaultView.getComputedStyle(target).getPropertyValue('border-top-width')));
          }
        });
      }
    }
    // Firefox has a bug where it can report that the target is the #document when mouse is over a pseudo element
    if ((target === null || target === void 0 ? void 0 : target.nodeType) === Element.DOCUMENT_NODE && 'clientX' in event) {
      const targetElement = DomHelper.elementFromPoint(event.clientX, event.clientY);
      Object.defineProperty(event, 'target', {
        value: targetElement,
        configurable
      });
    }
    // Firefox has a bug where it can report a textNode as an event target/relatedTarget.
    // We standardize this to report the parentElement.
    if ((target === null || target === void 0 ? void 0 : target.nodeType) === Element.TEXT_NODE) {
      const targetElement = event.target.parentElement;
      Object.defineProperty(event, 'target', {
        value: targetElement,
        configurable
      });
    }
    if (((_event$relatedTarget = event.relatedTarget) === null || _event$relatedTarget === void 0 ? void 0 : _event$relatedTarget.nodeType) === Element.TEXT_NODE) {
      const relatedTargetElement = event.target.parentElement;
      Object.defineProperty(event, 'relatedTarget', {
        value: relatedTargetElement,
        configurable
      });
    }
    // If it's a touch event, move the positional details
    // of touches[0] up to the event.
    if (type.startsWith('touch') && event.touches.length) {
      this.normalizeEvent(event);
    }
    return event;
  }
  static createHandler(element, eventName, handlerSpec, defaults) {
    const delay = handlerSpec.delay || defaults.delay,
      throttled = handlerSpec.throttled || defaults.throttled,
      block = handlerSpec.block || defaults.block,
      once = 'once' in handlerSpec ? handlerSpec.once : defaults.once,
      capture = 'capture' in handlerSpec ? handlerSpec.capture : defaults.capture,
      passive = 'passive' in handlerSpec ? handlerSpec.passive : defaults.passive,
      delegate = 'delegate' in handlerSpec ? handlerSpec.delegate : defaults.delegate,
      wrappedFn = handlerSpec.handler,
      expires = handlerSpec.expires,
      thisObj = handlerSpec.thisObj || defaults.thisObj,
      {
        rtlSource = thisObj
      } = thisObj || {};
    //Capture initial conditions in case of destruction of thisObj.
    // Destruction completely wipes the object.
    // Innermost level of wrapping which calls the user's handler.
    // Normalize the event cross-browser, and attempt to normalize touch events.
    let handler = (event, ...args) => {
      // When playing a demo using DemoBot, only handle synthetic events
      if (EH.playingDemo && event.isTrusted) {
        return;
      }
      // If the thisObj is already destroyed, we cannot call the function.
      // If in dev mode, warn the developer with a JS error.
      if (thisObj !== null && thisObj !== void 0 && thisObj.isDestroyed) {
        return;
      }
      // Fix up events to handle various browser inconsistencies
      event = EH.fixEvent(event, rtlSource === null || rtlSource === void 0 ? void 0 : rtlSource.rtl);
      // Flag for the expiry timer
      handler.called = true;
      (typeof wrappedFn === 'string' ? thisObj[wrappedFn] : wrappedFn).call(thisObj, event, ...args);
      // Remove properties that our fixEvent method added.
      // Other applications to which this may bubble need the pure browser event.
      delete event.target;
      delete event.relatedTarget;
      delete event.originalarget;
      delete event.key;
      delete event.code;
      delete event.ctrlKey;
      delete event.fixed;
    };
    // Allow events to be blocked for a certain time
    if (block) {
      const wrappedFn = handler;
      let lastCallTime, lastTarget;
      handler = (e, ...args) => {
        const now = performance.now();
        if (!lastCallTime || e.target !== lastTarget || now - lastCallTime > block) {
          lastTarget = e.target;
          lastCallTime = now;
          wrappedFn(e, ...args);
        }
      };
    }
    // Go through options, each creates a new handler by wrapping the previous handler to implement the options.
    // Right now, we have delay. Note that it may be zero, so test != null
    if (delay != null) {
      const wrappedFn = handler,
        delayable = thisObj !== null && thisObj !== void 0 && thisObj.setTimeout ? thisObj : globalThis;
      handler = (...args) => {
        delayable.setTimeout(() => {
          wrappedFn(...args);
        }, delay);
      };
    }
    // If they specified the throttled option, wrap the handler in a createdThrottled
    // version. Allow the called to specify an alt function to call when the event
    // fires before the buffer time has expired.
    if (throttled != null) {
      let alt,
        buffer = throttled;
      if (throttled.buffer) {
        alt = e => {
          return throttled.alt.call(EH, EH.fixEvent(e, rtlSource === null || rtlSource === void 0 ? void 0 : rtlSource.rtl));
        };
        buffer = throttled.buffer;
      }
      if (thisObj !== null && thisObj !== void 0 && thisObj.isDelayable) {
        handler = thisObj.throttle(handler, {
          delay: buffer,
          throttled: alt
        });
      } else {
        handler = FunctionHelper.createThrottled(handler, buffer, thisObj, null, alt);
      }
    }
    // This must always be added late to be processed before delay so that the handler is removed immediately.
    // Note that we cant use native once because of our support for `delegate`, it would remove the listener even
    // when delegate does not match
    if (once) {
      const wrappedFn = handler;
      handler = (...args) => {
        EH.removeEventListener(element, eventName, handler);
        wrappedFn(...args);
      };
    }
    // This must be added last to be called first, once and delay should not act on wrong targets when configured
    // with a delegate
    if (delegate) {
      const wrappedFn = handler;
      handler = (event, ...args) => {
        var _event$target$closest;
        event = EH.fixEvent(event, rtlSource === null || rtlSource === void 0 ? void 0 : rtlSource.rtl);
        // delegate: '.b-field-trigger' only fires when click is in a matching el.
        // currentTarget becomes the delegate.
        // Maintainer: In Edge event.target can be an empty object for transitionend events
        const delegatedTarget = ((_event$target$closest = event.target.closest) === null || _event$target$closest === void 0 ? void 0 : _event$target$closest.call) && event.target.closest(delegate);
        if (!delegatedTarget) {
          return;
        }
        // Allow this to be redefined as it bubbles through listeners up the parentNode axis
        // which might have their own delegate settings.
        Object.defineProperty(event, 'currentTarget', {
          get: () => delegatedTarget,
          configurable: true
        });
        wrappedFn(event, ...args);
      };
    }
    // Only autoDetach here if there's a local thisObj is in the handlerSpec for this one listener.
    // If it's in the defaults, then the "on" method will handle it.
    if (handlerSpec.thisObj && handlerSpec.autoDetach !== false) {
      thisObj.doDestroy = FunctionHelper.createInterceptor(thisObj.doDestroy, () => EH.removeEventListener(element, eventName, handler), thisObj);
    }
    handler.spec = {
      delay,
      throttled,
      block,
      once,
      thisObj,
      capture,
      expires,
      passive,
      delegate
    };
    return handler;
  }
  static removeEventListener(element, eventName, handler) {
    const {
      expires,
      timerId,
      thisObj,
      capture
    } = handler.spec;
    // Cancel outstanding expires.alt() call when removing the listener
    if (expires !== null && expires !== void 0 && expires.alt && timerId) {
      const delayable = thisObj !== null && thisObj !== void 0 && thisObj.isDelayable ? thisObj : globalThis;
      delayable[typeof expires.delay === 'number' ? 'clearTimeout' : 'cancelAnimationFrame'](timerId);
    }
    element.removeEventListener(eventName, handler, capture);
  }
  /**
   * Calls a callback when the described animation completes.
   *
   * @param {Object} detail
   * @param {HTMLElement} detail.element The element which is being animated.
   * @param {String|RegExp} [detail.animationName] The name of the animation to wait for.
   * @param {String} [detail.property] If no `animationName` specified, the CSS property
   * which is being animated.
   * @param {Function} detail.handler The function to call on animation end.
   * @param {Number} [detail.duration] Optional fallback time to wait until calling the callback.
   * @param {Object} [detail.thisObj] The `this` reference to call the callback with.
   * @param {Array} [detail.args] Optional arguments to call the callback with.
   * @param {Core.mixin.Delayable} [detail.timerSource] A Delayable to provide the fallback timeout.
   * @param {Boolean} [detail.runOnDestroy] If `timerSource` is a {@link Core.mixin.Delayable},
   * `true` to invoke the callback if it is destroyed during the animation.
   * @returns {Function} a function which detaches the animation end listener.
   */
  static onTransitionEnd({
    element,
    animationName,
    property,
    handler,
    mode = animationName ? 'animation' : 'transition',
    duration = DomHelper[`get${mode === 'transition' ? 'Property' : ''}${StringHelper.capitalize(mode)}Duration`](element, property),
    thisObj = globalThis,
    args = [],
    timerSource,
    runOnDestroy
  }) {
    let timerId;
    timerSource = timerSource || (thisObj.isDelayable ? thisObj : globalThis);
    const callbackArgs = [element, property, ...args],
      doCallback = () => {
        detacher();
        if (!thisObj.isDestroyed) {
          if (thisObj.callback) {
            thisObj.callback(handler, thisObj, callbackArgs);
          } else {
            handler.apply(thisObj, callbackArgs);
          }
        }
      },
      detacher = EH.on({
        element,
        [`${mode}end`]({
          animationName: endedAnimation,
          propertyName,
          target
        }) {
          if (target === element) {
            if (propertyName === property || endedAnimation !== null && endedAnimation !== void 0 && endedAnimation.match(animationName)) {
              if (timerId) {
                var _timerSource$clearTim, _timerSource;
                (_timerSource$clearTim = (_timerSource = timerSource).clearTimeout) === null || _timerSource$clearTim === void 0 ? void 0 : _timerSource$clearTim.call(_timerSource, timerId);
                timerId = null;
              }
              doCallback();
            }
          }
        }
      });
    // If the transition has not signalled its end within duration + 50 milliseconds
    // then give up on it. Remove the listener and call the handler.
    if (duration != null) {
      timerId = timerSource.setTimeout(doCallback, duration + 50, 'onTransitionEnd', runOnDestroy);
    }
    return detacher;
  }
  /**
   * Waits for the described animation completes.
   *
   * @param {Object} config
   * @param {HTMLElement} config.element The element which is being animated.
   * @param {String|RegExp} [config.animationName] The name of the animation to wait for.
   * @param {String} [config.property] If no `animationName` specified, the CSS property
   * which is being animated.
   * @param {Number} [config.duration] Optional fallback time to wait until calling the callback.
   * @param {Core.mixin.Delayable} [config.timerSource] A Delayable to provide the fallback timeout.
   * @param {Boolean} [config.runOnDestroy] If `timerSource` is a {@link Core.mixin.Delayable},
   * `true` to invoke the callback if it is destroyed during the animation.
   * @async
   */
  static async waitForTransitionEnd(config) {
    return new Promise(resolve => {
      config.handler = resolve;
      EventHelper.onTransitionEnd(config);
    });
  }
  /**
   * Private function to wrap the passed function. The returned wrapper function to be used as
   * a `touchend` handler which will call the passed function passing a fabricated `dblclick`
   * event if there is a `click` within 300ms.
   * @param {Element} element element
   * @param {String|Function} handler The handler to call.
   * @param {Object} thisObj The owner of the function.
   * @private
   */
  static createDblClickWrapper(element, handler, thisObj) {
    let startId, secondListenerDetacher, tapholdTimer;
    return () => {
      if (!secondListenerDetacher) {
        secondListenerDetacher = EH.on({
          element,
          // We only get here if a touchstart arrives within 300ms of a click
          touchstart: secondStart => {
            startId = secondStart.changedTouches[0].identifier;
            // Prevent zoom
            secondStart.preventDefault();
          },
          touchend: secondClick => {
            if (secondClick.changedTouches[0].identifier === startId) {
              secondClick.preventDefault();
              clearTimeout(tapholdTimer);
              startId = secondListenerDetacher = null;
              const targetRect = Rectangle.from(secondClick.changedTouches[0].target, null, true),
                offsetX = secondClick.changedTouches[0].pageX - targetRect.x,
                offsetY = secondClick.changedTouches[0].pageY - targetRect.y,
                dblclickEventConfig = Object.assign({
                  browserEvent: secondClick
                }, secondClick),
                dblclickEvent = new MouseEvent('dblclick', dblclickEventConfig);
              Object.defineProperties(dblclickEvent, {
                target: {
                  value: secondClick.target
                },
                offsetX: {
                  value: offsetX
                },
                offsetY: {
                  value: offsetY
                }
              });
              if (typeof handler === 'string') {
                handler = thisObj[handler];
              }
              // Call the wrapped handler passing the fabricated dblclick event
              handler.call(thisObj, dblclickEvent);
            }
          },
          once: true
        });
        // Cancel the second listener is there's no second click within <dblClickTime> milliseconds.
        tapholdTimer = setTimeout(() => {
          secondListenerDetacher();
          startId = secondListenerDetacher = null;
        }, EH.dblClickTime);
      }
    };
  }
  /**
   * Handles various inputs to figure out the name of the special key of the event.
   *
   * ```javascript
   * EventHelper.toSpecialKey('ctrl') // 'ctrlKey'
   * EventHelper.toSpecialKey(true)   // 'ctrlKey', default for PC (Cmd for Mac)
   * EventHelper.toSpecialKey(false)  // false
   * EventHelper.toSpecialKey('foo')  // false
   * ```
   *
   * @param {*} value User input value to process.
   * @param {String} defaultValue Default value to fall back to if `true` value is passed.
   * @returns {Boolean|String} Returns `false` if provided value cannot be converted to special key and special key
   * name otherwise.
   * @internal
   */
  static toSpecialKey(value, defaultValue = BrowserHelper.isMac ? 'metaKey' : 'ctrlKey') {
    let result = false;
    if (value === true) {
      result = defaultValue;
    } else if (typeof value === 'string') {
      value = value.toLowerCase();
      if (value.match(specialKeyRe)) {
        result = `${value}Key`;
      }
    }
    return result;
  }
  /**
   * If keyup event is triggered when special key is pressed, we don't get special key value from properties like
   * `ctrlKey`. Instead we need to read `event.key`. That property uses full name and we use abbreviations, so we
   * need to convert the key.
   * @param {String} code
   * @returns {String}
   * @internal
   */
  static specialKeyFromEventKey(code) {
    return specialKeys[code] || 'no-special-key';
  }
}
const EH = EventHelper;
/**
 * The time in milliseconds for a `taphold` gesture to trigger a `contextmenu` event.
 * @member {Number} [longPressTime=700]
 * @readonly
 * @static
 */
EH.longPressTime = 700;
/**
 * The time in milliseconds within which a second touch tap event triggers a `dblclick` event.
 * @member {Number} [dblClickTime=300]
 * @readonly
 * @static
 */
EH.dblClickTime = 300;
// When dragging on a touch device, we need to prevent scrolling from happening.
// Dragging only starts on a touchmove event, by which time it's too late to preventDefault
// on the touchstart event which started it.
// To do this we need a capturing, non-passive touchmove listener at the document level so we can preventDefault.
// This is in lieu of a functioning touch-action style on iOS Safari. When that's fixed, this will not be needed.
if (BrowserHelper.isTouchDevice) {
  EH.on({
    element: document,
    touchmove: event => {
      // If we're touching a b-dragging event, then stop any panning by preventing default.
      if (event.target.closest('.b-dragging')) {
        event.preventDefault();
      }
    },
    passive: false,
    capture: true
  });
}
EventHelper._$name = 'EventHelper';

const DEFAULT_FONT_SIZE = 14,
  t0t0 = {
    align: 't0-t0'
  },
  ELEMENT_NODE = Node.ELEMENT_NODE,
  TEXT_NODE = Node.TEXT_NODE,
  {
    isObject: isObject$1
  } = ObjectHelper,
  // Transform matrix parse Regex. CSS transform computed style looks like this:
  // matrix(scaleX(), skewY(), skewX(), scaleY(), translateX(), translateY())
  // or
  // matrix3d(scaleX(), skewY(), 0, 0, skewX(), scaleY(), 0, 0, 0, 0, 1, 0, translateX(), translateY())
  // This is more reliable than using the style literal which may include
  // relative styles such as "translateX(-20em)", or not include the translation at all if it's from a CSS rule.
  // Use a const so as to only compile RexExp once
  // Extract repeating number regexp to simplify next expressions. Available values are: https://developer.mozilla.org/en-US/docs/Web/CSS/number
  numberRe = /[+-]?\d*\.?\d+[eE]?-?\d*/g,
  // -2.4492935982947064e-16 should be supported
  numberReSrc = numberRe.source,
  translateMatrix2dRe = new RegExp(`matrix\\((?:${numberReSrc}),\\s?(?:${numberReSrc}),\\s?(?:${numberReSrc}),\\s?(?:${numberReSrc}),\\s?(${numberReSrc}),\\s?(${numberReSrc})`),
  translateMatrix3dRe = new RegExp(`matrix3d\\((?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(-?\\d*),\\s?(-?\\d*)`),
  translateMatrixRe = new RegExp(`(?:${translateMatrix2dRe.source})|(?:${translateMatrix3dRe.source})`),
  pxTtranslateXRe = new RegExp(`translate(3d|X)?\\((${numberReSrc})px(?:,\\s?(${numberReSrc})px)?`),
  pxTtranslateYRe = new RegExp(`translate(3d|Y)?\\((${numberReSrc})px(?:,\\s?(${numberReSrc})px)?`),
  whiteSpaceRe = /\s+/,
  semicolonRe = /\s*;\s*/,
  colonRe = /\s*:\s*/,
  digitsRe = /^-?((\d+(\.\d*)?)|(\.?\d+))$/,
  elementPropKey = '$bryntum',
  // A blank value means the expando name is the same as the key in this object, otherwise the key in this object is
  // the name of the domConfig property and the value is the name of the DOM element expando property.
  elementCreateExpandos = {
    elementData: '',
    for: 'htmlFor',
    retainElement: ''
  },
  // DomHelper#createElement properties which require special processing.
  // All other configs such as id and type are applied directly to the element.
  elementCreateProperties = {
    // these two are handled by being in elementCreateExpands:
    // elementData  : 1,
    // for          : 1,
    tag: 1,
    html: 1,
    text: 1,
    children: 1,
    tooltip: 1,
    style: 1,
    dataset: 1,
    parent: 1,
    nextSibling: 1,
    ns: 1,
    reference: 1,
    class: 1,
    className: 1,
    unmatched: 1,
    // Used by syncId approach
    onlyChildren: 1,
    // Used by sync to not touch the target element itself,
    listeners: 1,
    // eslint-disable-line bryntum/no-listeners-in-lib
    compareHtml: 1,
    // Sync
    syncOptions: 1,
    // Sync
    keepChildren: 1 // Sync
  },
  styleIgnoreProperties = {
    length: 1,
    parentRule: 1,
    style: 1
  },
  nativeEditableTags = {
    INPUT: 1,
    TEXTAREA: 1
  },
  nativeFocusableTags = {
    BUTTON: 1,
    IFRAME: 1,
    EMBED: 1,
    INPUT: 1,
    OBJECT: 1,
    SELECT: 1,
    TEXTAREA: 1,
    BODY: 1
  },
  win = globalThis,
  doc = document,
  emptyObject$5 = Object.freeze({}),
  arraySlice$1 = Array.prototype.slice,
  immediatePromise$3 = Promise.resolve(),
  fontProps = ['font-size', 'font-size-adjust', 'font-style', 'font-weight', 'font-family', 'font-kerning', 'font-stretch', 'line-height', 'text-transform', 'text-decoration', 'letter-spacing', 'word-break'],
  isHiddenWidget = e => e._hidden,
  parentNode = el => el.parentNode || el.host,
  mergeChildren = (dest, src, options) => {
    if (options.key === 'children') {
      // Normally "children" is an array (for which we won't be here, due to isObject check in caller). To
      // maintain declarative order of children as an object, we need some special sauce:
      return ObjectHelper.mergeItems(dest, src, options);
    }
    return ObjectHelper.blend(dest, src, options);
  },
  isVisible = e => {
    const style = e.ownerDocument.defaultView.getComputedStyle(e);
    return style.getPropertyValue('display') !== 'none' && style.getPropertyValue('visibility') !== 'hidden';
  },
  // Nodes such as SVG which do not expose such a property must have an ancestor which has an offsetParent.
  // If position:fixed, there's no offsetParent, so continue to interrogate parentNode.
  // If the el has appeared through a timer from a destroyed frame, the defaultView will be null.
  hasLayout = el => el && (el === doc.body || Boolean(el.offsetParent) || (el.ownerDocument.defaultView && 'offsetParent' in el && DomHelper.getStyleValue(el, 'position') !== 'fixed' ? el.offsetParent : hasLayout(el.parentNode))),
  elementOrConfigToElement = elementOrConfig => {
    if (elementOrConfig instanceof Node) {
      return elementOrConfig;
    }
    if (typeof elementOrConfig === 'string') {
      return DH.createElementFromTemplate(elementOrConfig);
    }
    return DH.createElement(elementOrConfig);
  },
  canonicalStyles = Object.create(null),
  canonicalizeStyle = (name, hasUnit) => {
    const entry = canonicalStyles[name] || [StringHelper.hyphenate(name), hasUnit];
    if (!canonicalStyles[name]) {
      canonicalStyles[entry[0]] = canonicalStyles[name] = entry;
    }
    return entry;
  },
  getOffsetParent = node => node.ownerSVGElement ? node.ownerSVGElement.parentNode : node.offsetParent,
  slideInAnimationName = /b-slide-in-from-\w+/;
// Push the styles that have units into the map:
['top', 'right', 'bottom', 'left', 'width', 'height', 'maxWidth', 'maxHeight', 'minWidth', 'minHeight', 'borderSpacing', 'borderWidth', 'borderTopWidth', 'borderRightWidth', 'borderBottomWidth', 'borderLeftWidth', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft', 'fontSize', 'letterSpacing', 'lineHeight', 'outlineWidth', 'textIndent', 'wordSpacing'].forEach(name => canonicalizeStyle(name, true));
// We only do the measurement once, if the value is null
let scrollBarWidth = null,
  idCounter = 0,
  themeInfo = null,
  templateElement,
  htmlParser,
  scrollBarMeasureElement;
/**
 * @module Core/helper/DomHelper
 */
/**
 * An object that describes a DOM element. Used for example by {@link #function-createElement-static createElement()}
 * and by {@link Core.helper.DomSync#function-sync-static DomSync.sync()}.
 *
 * ```javascript
 * DomHelper.createElement({
 *    class : {
 *        big   : true,
 *        small : false
 *    },
 *    children : [
 *        { tag : 'img', src : 'img.png' },
 *        { html : '<b style="color: red">Red text</b>' }
 *    ]
 * });
 * ```
 *
 * @typedef {Object} DomConfig
 * @property {String} [tag='div'] Tag name, for example 'span'
 * @property {HTMLElement} [parent] Parent element
 * @property {HTMLElement} [nextSibling] Element's next sibling in the parent element
 * @property {String|Object} [class] CSS classes, as a string or an object (truthy keys will be applied)
 * @property {String|Object} [className] Alias for `class`
 * @property {String|Object} [style] Style, as a string or an object (keys will be hyphenated)
 * @property {Object} [elementData] Data object stored as an expando on the resulting element
 * @property {Object} [dataset] Dataset applied to the resulting element
 * @property {DomConfig[]|Object<String,DomConfig>|String[]|HTMLElement[]} [children] Child elements, as an array that can include
 * DomConfigs that will be turned into elements, plain strings that will be used as text nodes or existing elements that
 * will be moved. Also accepts an object map of DomConfigs, but please note that it cannot be used with
 * `DomHelper.createElement()`
 * @property {String} [html] Html string, used as the resulting elements `innerHTML`. Mutually exclusive with the `children` property
 * @property {TooltipConfig|String} [tooltip] Tooltip config applied to the resulting element
 * @property {String} [text] Text content, XSS safe when you want to display text in the element. Mutually exclusive with the `children` property
 * @property {String} [id] Element's `id`
 * @property {String} [href] Element's `href`
 * @property {String} [ns] Element's namespace
 * @property {String} [src] Element's `src`
 */
/**
 * Helps with dom querying and manipulation.
 *
 * ```javascript
 * DomHelper.createElement({
 *   tag: 'div',
 *   className: 'parent',
 *   style: 'background: red',
 *   children: [
 *      { tag: 'div', className: 'child' },
 *      { tag: 'div', className: 'child' }
 *   ]
 * });
 * ```
 */
class DomHelper {
  /**
   * Animates the specified element to slide it into view within the visible viewport
   * of its parentElement from the direction of movement.
   *
   * So in a left-to-right Widget, `direction` 1 means it slides in from the right
   * and `direction` -1 means it slides in from the left. RTL reverses the movement.
   *
   * See the forward/backward navigations in {@link Core.widget.DatePicker} for an example
   * of this in action.
   *
   * If "next" should arrive from below and "previous" should arrive from above, add the
   * class `b-slide-vertical` to the element.
   * @param {HTMLElement} element The element to slide in.
   * @param {Number} direction
   * * `1` to slide in from the "next" direction.
   * * `-1` to slide in from the "previous" direction.
   *
   * If the element is inside an RTL widget the directions are reversed.
   * @async
   */
  static async slideIn(element, direction = 1) {
    const cls = `b-slide-in-${direction > 0 ? 'next' : 'previous'}`,
      {
        classList
      } = element,
      {
        style
      } = element.parentNode,
      {
        overflow,
        overflowX,
        overflowY
      } = style;
    style.overflow = 'hidden';
    classList.add(cls);
    await EventHelper.waitForTransitionEnd({
      element,
      animationName: slideInAnimationName
    });
    style.overflow = overflow;
    style.overflowX = overflowX;
    style.overflowY = overflowY;
    classList.remove(cls);
  }
  /**
   * Returns `true` if the passed element is focusable either programmatically or through pointer gestures.
   * @param {HTMLElement} element The element to test.
   * @returns {Boolean} Returns `true` if the passed element is focusable
   */
  static isFocusable(element, skipAccessibilityCheck = false) {
    if (!skipAccessibilityCheck) {
      // If element is hidden or in a hidden Widget, it's not focusable.
      if (!DH.isVisible(element) || DH.Widget.fromElement(element, isHiddenWidget)) {
        return false;
      }
    }
    const nodeName = element.nodeName;
    /*
     * An element is focusable if:
     *   - It is natively focusable, or
     *   - It is an anchor or link with href attribute, or
     *   - It has a tabIndex, or
     *   - It is an editing host (contenteditable="true")
     */
    return nativeFocusableTags[nodeName] || (nodeName === 'A' || nodeName === 'LINK') && !!element.href || element.getAttribute('tabIndex') != null || element.contentEditable === 'true';
  }
  /**
   * Returns `true` if the passed element accepts keystrokes to edit its contents.
   * @returns {Boolean} Returns `true` if the passed element is editable.
   */
  static isEditable(element) {
    return element.isContentEditable || nativeEditableTags[element.nodeName];
  }
  /**
   * Returns the rectangle of the element which is currently visible in the browser viewport, i.e. user can find it on
   * screen, or `false` if it is scrolled out of view.
   * @param {HTMLElement} target The element to test.
   * @param {Boolean} [whole=false] Whether to check that whole element is visible, not just part of it.
   * If this is passed as true, the result will be a boolean, `true` or `false`.
   * @privateparam {Core.widget.Widget} [caller] the Widget aligning to the target.
   * @returns {Core.helper.util.Rectangle|Boolean} Returns the rectangle of the element which is currently visible in
   * the browser viewport, or `false` if it is out of view.
   */
  static isInView(target, whole = false, caller) {
    // If the target cannot yield a Rectangle, shortcut all processing.
    if (!hasLayout(target)) {
      return false;
    }
    const positioned = (caller === null || caller === void 0 ? void 0 : caller.positioned) && DomHelper.getStyleValue(caller.element, 'position') !== 'fixed',
      docRect = Rectangle.from(globalThis),
      method = whole ? 'contains' : 'intersect',
      cOp = positioned && caller.element.offsetParent,
      cOpR = positioned && Rectangle.from(cOp);
    // If we get to the top, the visible rectangle is the entire document.
    docRect.height = doc.scrollingElement.scrollHeight;
    // If they asked to test the body, it's always in view
    if (target === doc.body) {
      return docRect;
    }
    const result = this.getViewportIntersection(target, docRect, method);
    // We must use the *viewport* coordinate system to ascertain viewability
    if (result && positioned) {
      result.translate(doc.scrollingElement.scrollLeft, doc.scrollingElement.scrollTop);
    }
    // Return any rectangle to its positioned coordinate system
    return positioned && result ? result.translate(-cOpR.x + cOp.scrollLeft, -cOpR.y + cOp.scrollTop) : result;
  }
  /**
   * This method goes up the DOM tree checking that all ancestors are visible in the viewport
   * @param {HTMLElement} target Starting html element
   * @param {Core.helper.util.Rectangle} docRect Window rectangle
   * @param {String} method 'contains' or 'intersect'
   * @returns {Core.helper.util.Rectangle}
   */
  static getViewportIntersection(target, docRect, method) {
    const {
        parentNode
      } = target,
      {
        parentElement
      } = parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? target.getRootNode().host : target,
      peStyle = parentElement.ownerDocument.defaultView.getComputedStyle(parentElement),
      parentScroll = peStyle.overflowX !== 'visible' || peStyle.overflowY !== 'visible',
      offsetParent = getOffsetParent(target);
    let result = Rectangle.from(target, null, true);
    for (let viewport = parentScroll ? target.parentNode : offsetParent; result && viewport !== doc.documentElement; viewport = viewport.parentNode) {
      // Skip shadow root node.
      if (viewport.nodeType === Node.DOCUMENT_FRAGMENT_NODE && viewport.host) {
        viewport = viewport.host.parentNode;
      }
      const isTop = viewport === doc.body,
        style = viewport.ownerDocument.defaultView.getComputedStyle(viewport),
        viewportRect = isTop ? docRect : Rectangle.inner(viewport, null, true);
      // If this level allows overflow to show, don't clip. Obv, <body> can't show overflowing els.
      if (isTop || style.overflow !== 'visible') {
        result = viewportRect[method](result, false, true);
      }
    }
    return result;
  }
  /**
   * Returns `true` if the passed element is deeply visible. Meaning it is not hidden using `display`
   * or `visibility` and no ancestor node is hidden.
   * @param {HTMLElement} element The element to test.
   * @returns {Boolean} `true` if deeply visible.
   */
  static isVisible(element) {
    const document = element.ownerDocument;
    // Use the parentNode function so that we can traverse upwards through shadow DOM
    // to correctly ascertain visibility of nodes in web components.
    for (; element; element = parentNode(element)) {
      // Visible if we've reached top of the owning document without finding a hidden Element.
      if (element === document) {
        return true;
      }
      // Must not evaluate a shadow DOM's root fragment.
      if (element.nodeType === element.ELEMENT_NODE && !isVisible(element)) {
        return false;
      }
    }
    // We get here if the node is detached.
    return false;
  }
  /**
   * Returns true if DOM Event instance is passed. It is handy to override to support Locker Service.
   * @param event
   * @internal
   * @returns {Boolean}
   */
  static isDOMEvent(event) {
    return event instanceof Event;
  }
  /**
   * Merges specified source DOM config objects into a `dest` object.
   * @param {DomConfig} dest The destination DOM config object.
   * @param {...DomConfig} sources The DOM config objects to merge into `dest`.
   * @returns {DomConfig} The `dest` object.
   * @internal
   */
  static merge(dest, ...sources) {
    return ObjectHelper.blend(dest, sources, {
      merge: mergeChildren
    });
  }
  /**
   * Updates in-place a DOM config object whose `children` property may be an object instead of the typical array.
   * The keys of such objects become the `reference` property upon conversion.
   *
   * @param {DomConfig} domConfig
   * @param {Function} [namedChildren] A function to call for each named child element.
   * @privateparam {Boolean} [ignoreRefs] Not meant to be manually set, used when recursing.
   * @returns {DomConfig} Returns the altered DOM config
   * @internal
   */
  static normalizeChildren(domConfig, namedChildren, ignoreRefs) {
    var _domConfig$syncOption;
    let children = domConfig === null || domConfig === void 0 ? void 0 : domConfig.children,
      child,
      i,
      name,
      kids,
      ref;
    // Allow redirecting/opting out of ref ownership in a hierarchy
    if (domConfig !== null && domConfig !== void 0 && (_domConfig$syncOption = domConfig.syncOptions) !== null && _domConfig$syncOption !== void 0 && _domConfig$syncOption.ignoreRefs) {
      ignoreRefs = true;
    }
    if (children && !(domConfig instanceof Node)) {
      if (Array.isArray(children)) {
        for (i = 0; i < children.length; ++i) {
          DH.normalizeChildren(children[i], namedChildren, ignoreRefs);
        }
      } else {
        kids = children;
        domConfig.children = children = [];
        for (name in kids) {
          var _child;
          child = kids[name];
          if ((_child = child) !== null && _child !== void 0 && _child.isWidget) {
            child = child.element;
          }
          // $ prefix indicates element is not a reference:
          ref = !name.startsWith('$') && !DH.isElement(child);
          ref && (namedChildren === null || namedChildren === void 0 ? void 0 : namedChildren(name, /* hoist = */!ignoreRefs));
          if (child) {
            if (!(child instanceof Node)) {
              if (child.reference === false) {
                delete child.reference;
              } else if (ref && typeof child !== 'string') {
                child.reference = name;
              }
              DH.normalizeChildren(child, namedChildren, ignoreRefs);
            }
            children.push(child);
          }
        }
      }
    }
    return domConfig;
  }
  static roundPx(px, devicePixelRatio = globalThis.devicePixelRatio || 1) {
    const multiplier = 1 / devicePixelRatio;
    return Math.round(px / multiplier) * multiplier;
  }
  // For use when we are dividing a DOM element into even parts. The resulting value
  // must be floored to prevent overflow. But only floored to the device's resolution,
  // so raw Math.floor will not work - it would leave empty space in hi resolution screens.
  static floorPx(px, devicePixelRatio = globalThis.devicePixelRatio || 1) {
    const multiplier = 1 / devicePixelRatio;
    return Math.floor(px * multiplier) / multiplier;
  }
  /**
   * Returns true if element has opened shadow root
   * @param {HTMLElement} element Element to check
   * @returns {Boolean}
   */
  static isCustomElement(element) {
    return Boolean(element === null || element === void 0 ? void 0 : element.shadowRoot);
  }
  /**
   * Resolves element from point, checking shadow DOM if required
   * @param {Number} x
   * @param {Number} y
   * @returns {HTMLElement}
   */
  static elementFromPoint(x, y) {
    let el = document.elementFromPoint(x, y);
    // Try to check shadow dom if it exists
    if (DH.isCustomElement(el)) {
      el = el.shadowRoot.elementFromPoint(x, y) || el;
    }
    return el;
  }
  /**
   * Resolves child element from point __in the passed element's coordinate space__.
   * @param {HTMLElement} parent The element to find the occupying element in.
   * @param {Number|Core.helper.util.Point} x Either the `X` part of a point, or the point to find.
   * @param {Number} [y] The `Y` part of the point.
   * @returns {HTMLElement}
   * @internal
   */
  static childFromPoint(el, x, y, /* internal */parent = el) {
    const p = y == null ? x : new Rectangle(x, y, 0, 0);
    let result = null;
    Array.from(el.children).reverse().some(el => {
      if (Rectangle.from(el, parent).contains(p)) {
        // All rectangles must be relative to the topmost el, so that must be
        // passed down as the "parent" of all Rectangles.
        result = el.children.length && DH.childFromPoint(el, p, null, parent) || el;
        return true;
      }
    });
    return result;
  }
  /**
   * Converts a name/value pair of a style name and its value into the canonical (hyphenated) name of the style
   * property and a value with the `defaultUnit` suffix appended if no unit is already present in the `value`.
   *
   * For example:
   * ```javascript
   *  const [property, value] = DomHelper.unitize('marginLeft', 50);
   *  console.log(property, value);
   * ```
   *
   * ```
   *  > margin-left 50px
   * ```
   * @param {String} name
   * @param {String|Number} value
   * @param {String} [defaultUnit]
   * @returns {String[]}
   * @internal
   */
  static unitize(name, value, defaultUnit = 'px') {
    const [trueName, hasUnits] = canonicalizeStyle(name);
    if (value != null) {
      value = String(value);
      value = hasUnits && digitsRe.test(value) ? value + defaultUnit : value;
    }
    return [trueName, value];
  }
  /**
   * Returns active element checking shadow dom too
   * @readonly
   * @property {HTMLElement}
   */
  static get activeElement() {
    let el = document.activeElement;
    while (el.shadowRoot) {
      el = el.shadowRoot.activeElement;
    }
    return el;
  }
  // returns active element for DOM tree / shadow DOM tree to which element belongs
  static getActiveElement(element) {
    var _element, _element2;
    if ((_element = element) !== null && _element !== void 0 && _element.isWidget) {
      element = element.element;
    }
    // If no element passed, fallback to document
    let el = (((_element2 = element) === null || _element2 === void 0 ? void 0 : _element2.getRootNode()) || document).activeElement;
    while ((_el = el) !== null && _el !== void 0 && _el.shadowRoot) {
      var _el;
      el = el.shadowRoot.activeElement;
    }
    return el;
  }
  // Returns the visible root (either document.body or a web component shadow root)
  static getRootElement(element) {
    var _element$getRootNode;
    const root = (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element),
      {
        nodeType
      } = root;
    // If the root is a document, return its body.
    // If it is a document fragment, then it us a shadow root, so return that.
    // fall back to using the passed element's owning document body.
    return nodeType === Node.DOCUMENT_NODE ? root.body : nodeType === Node.DOCUMENT_FRAGMENT_NODE ? root : element.ownerDocument.contains(element) ? element.ownerDocument.body : null;
  }
  // Returns the topmost HTMLElement inside the current context (either document.body or a direct child of a web component shadow root)
  static getOutermostElement(element) {
    var _element$getRootNode2, _element3;
    const root = (_element$getRootNode2 = (_element3 = element).getRootNode) === null || _element$getRootNode2 === void 0 ? void 0 : _element$getRootNode2.call(_element3);
    if (root !== null && root !== void 0 && root.body) {
      return root === null || root === void 0 ? void 0 : root.body;
    }
    // we are in a shadow root
    // parentNode might be null in salesforce
    while (element.parentNode !== root && element.parentNode) {
      element = element.parentNode;
    }
    return element;
  }
  static isValidFloatRootParent(target) {
    return target === document.body || target.constructor.name === 'ShadowRoot';
  }
  /**
   * Returns the `id` of the passed element. Generates a unique `id` if the element does not have one.
   * @param {HTMLElement} element The element to return the `id` of.
   */
  static getId(element) {
    return element.id || (element.id = 'b-element-' + ++idCounter);
  }
  /**
   * Returns common widget/node ancestor for from/to arguments
   * @param {Core.widget.Widget|HTMLElement} from
   * @param {Core.widget.Widget|HTMLElement} to
   * @returns {Core.widget.Widget|HTMLElement}
   * @internal
   */
  static getCommonAncestor(from, to) {
    if (from === to) {
      return from;
    }
    while (from && !((_from = (_from2 = from)[from.isWidget ? 'owns' : 'contains']) !== null && _from !== void 0 && _from.call(_from2, to) || from === to)) {
      var _from, _from2;
      from = from.owner || from.parentNode;
    }
    return from;
  }
  //region Internal
  /**
   * Internal convenience fn to allow specifying either an element or a CSS selector to retrieve one
   * @private
   * @param {String|HTMLElement} elementOrSelector element or selector to lookup in DOM
   * @returns {HTMLElement}
   */
  static getElement(elementOrSelector) {
    // also used for SVG elements, so need to use more basic class, that is also returned by querySelector
    if (elementOrSelector instanceof Element) {
      return elementOrSelector;
    }
    return doc.querySelector(elementOrSelector);
  }
  /**
   * Sets attributes passed as object to given element
   * @param {String|Element} elementOrSelector
   * @param {Object} attributes
   * @internal
   */
  static setAttributes(elementOrSelector, attributes) {
    const element = DH.getElement(elementOrSelector);
    if (element && attributes) {
      for (const key in attributes) {
        if (attributes[key] == null) {
          element.removeAttribute(key);
        } else {
          element.setAttribute(key, attributes[key]);
        }
      }
    }
  }
  /**
   * Sets a CSS [length](https://developer.mozilla.org/en-US/docs/Web/CSS/length) style value.
   * @param {String|HTMLElement} element The element to set the style in, or, if just the result is required,
   * the style magnitude to return with units added. If a nullish value is passed, an empty string
   * is returned.
   * @param {String} [style] The name of a style property which specifies a [length](https://developer.mozilla.org/en-US/docs/Web/CSS/length)
   * @param {Number|String} [value] The magnitude. If a number is used, the value will be set in `px` units.
   * @returns {String} The style value string.
   */
  static setLength(element, style, value) {
    if (arguments.length === 1) {
      value = typeof element === 'number' ? `${element}px` : element ?? '';
    } else {
      element = DH.getElement(element);
      value = element.style[style] = typeof value === 'number' ? `${value}px` : value ?? '';
    }
    return value;
  }
  /**
   * Returns string percentified and rounded value for setting element's height, width etc.
   * @param {String|Number} value percent value
   * @param {Number} digits number of decimal digits for rounding
   * @returns {string} percentified value or empty string if value can not be parsed
   * @internal
   */
  static percentify(value, digits = 2) {
    const mult = Math.pow(10, digits);
    return value == null || value === '' || isNaN(value) ? '' : `${Math.round(value * mult) / mult}%`;
  }
  //endregion
  //region Children, going down...
  /**
   * Gets the first direct child of `element` that matches `selector`.
   * @param {HTMLElement} element Parent element
   * @param {String} selector CSS selector
   * @returns {HTMLElement}
   * @category Query children
   */
  static getChild(element, selector) {
    return element.querySelector(':scope>' + selector);
  }
  /**
   * Checks if `element` has any child that matches `selector`.
   * @param {HTMLElement} element Parent element
   * @param {String} selector CSS selector
   * @returns {Boolean} true if any child matches selector
   * @category Query children
   */
  static hasChild(element, selector) {
    return DH.getChild(element, selector) != null;
  }
  /**
   * Returns all child elements (not necessarily direct children) that matches `selector`.
   *
   * If `selector` starts with `'>'` or `'# '`, then all components of the `selector` must match inside of `element`.
   * The scope selector, `:scope` is prepended to the selector (and if `#` was used, it is removed).
   *
   * These are equivalent:
   *
   *      DomHelper.children(el, '# .foo .bar');
   *
   *      el.querySelectorAll(':scope .foo .bar');
   *
   * These are also equivalent:
   *
   *      DomHelper.children(el, '> .foo .bar');
   *
   *      el.querySelectorAll(':scope > .foo .bar');
   *
   * @param {HTMLElement} element The parent element
   * @param {String} selector The CSS selector
   * @returns {HTMLElement[]} Matched elements, somewhere below `element`
   * @category Query children
   */
  static children(element, selector) {
    // a '#' could be '#id' but '# ' (hash and space) is not a valid selector...
    if (selector[0] === '>' || selector.startsWith('# ')) {
      if (selector[0] === '#') {
        selector = selector.substr(2);
      }
      selector = ':scope ' + selector;
    }
    return Array.from(element.querySelectorAll(selector));
  }
  // Salesforce doesn't yet support childElementCount. So we relace all native usages with this wrapper and
  // override it for salesforce environment.
  // https://github.com/bryntum/support/issues/3008
  static getChildElementCount(element) {
    return element.childElementCount;
  }
  /**
   * Looks at the specified `element` and all of its children for the one that first matches `selector.
   * @param {HTMLElement} element Parent element
   * @param {String} selector CSS selector
   * @returns {HTMLElement} Matched element, either element or an element below it
   * @category Query children
   */
  static down(element, selector) {
    if (!element) {
      return null;
    }
    if (element.matches && element.matches(selector)) {
      return element;
    }
    selector = ':scope ' + selector;
    return element.querySelector(selector);
  }
  /**
   * Checks if childElement is a descendant of parentElement (contained in it or a sub element)
   * @param {HTMLElement} parentElement Parent element
   * @param {HTMLElement} childElement Child element, at any level below parent (includes nested shadow roots)
   * @returns {Boolean}
   * @category Query children
   */
  static isDescendant(parentElement, childElement) {
    const parentRoot = DH.getRootElement(parentElement),
      childRoot = DH.getRootElement(childElement);
    if (childRoot && parentRoot !== childRoot && childRoot.host) {
      return DH.isDescendant(parentRoot, childRoot.host);
    }
    return parentElement.contains(childElement);
  }
  /**
   * Returns the specified element of the given `event`. If the `event` is an `Element`, it is returned. Otherwise,
   * the `eventName` argument is used to retrieve the desired element property from `event` (this defaults to the
   * `'target'` property).
   * @param {Event|Element} event
   * @param {String} [elementName]
   * @returns {Element}
   */
  static getEventElement(event, elementName = 'target') {
    return !event || DH.isElement(event) ? event : event[elementName];
  }
  /**
   * Returns `true` if the provided value is _likely_ a DOM element. If the element can be assured to be from the
   * same document, `instanceof Element` is more reliable.
   * @param {*} value
   * @returns {Boolean}
   */
  static isElement(value) {
    return (value === null || value === void 0 ? void 0 : value.nodeType) === document.ELEMENT_NODE && DH.isNode(value);
  }
  /**
   * Returns `true` if the provided element is an instance of React Element.
   * All React elements require an additional $$typeof: Symbol.for('react.element') field declared on the object for security reasons.
   * The object which React.createElement() return has $$typeof property equals to Symbol.for('react.element')
   *
   * Sources:
   * https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html
   * https://github.com/facebook/react/pull/4832
   *
   * @param {*} element
   * @returns {Boolean}
   * @internal
   */
  static isReactElement(element) {
    return (element === null || element === void 0 ? void 0 : element.$$typeof) === Symbol.for('react.element');
  }
  /**
   * Returns `true` if the provided value is _likely_ a DOM node. If the node can be assured to be from the same
   * document, `instanceof Node` is more reliable.
   * @param {*} value
   * @returns {Boolean}
   */
  static isNode(value) {
    // cannot use instanceof across frames. Using it here won't help since we'd need the same logic if it were
    // false... meaning we'd have the same chances of a false-positive.
    return Boolean(value) && typeof value.nodeType === 'number' && !isObject$1(value);
  }
  /**
   * Iterates over each result returned from `element.querySelectorAll(selector)`. First turns it into an array to
   * work in IE. Can also be called with only two arguments, in which case the first argument is used as selector and
   * document is used as the element.
   * @param {HTMLElement} element Parent element
   * @param {String} selector CSS selector
   * @param {Function} fn Function called for each found element
   * @category Query children
   */
  static forEachSelector(element, selector, fn) {
    if (typeof element === 'string') {
      // Legacy internal API, no longer valid
      throw new Error('DomHelper.forEachSelector must provide a root element context (for shadow root scenario)');
    }
    DH.children(element, selector).forEach(fn);
  }
  /**
   * Iterates over the direct child elements of the specified element. First turns it into an array to
   * work in IE.
   * @param {HTMLElement} element Parent element
   * @param {Function} fn Function called for each child element
   * @category Query children
   */
  static forEachChild(element, fn) {
    Array.from(element.children).forEach(fn);
  }
  /**
   * Removes each element returned from `element.querySelectorAll(selector)`.
   * @param {HTMLElement} element
   * @param {String} selector
   * @category Query children
   */
  static removeEachSelector(element, selector) {
    DH.forEachSelector(element, selector, child => child.remove());
  }
  static removeClsGlobally(element, ...classes) {
    classes.forEach(cls => DH.forEachSelector(element, '.' + cls, child => child.classList.remove(cls)));
  }
  //endregion
  //region Parents, going up...
  /**
   * Looks at the specified element and all of its parents for the one that first matches selector.
   * @deprecated Since 5.3.9, use native `element.closest()` instead
   * @param {HTMLElement} element Element
   * @param {String} selector CSS selector
   * @returns {HTMLElement} Matched element, either the passed in element or an element above it
   * @category Query parents
   */
  static up(element, selector) {
    VersionHelper.deprecate('Core', '6.0.0', 'DomHelper.up() deprecated, use native `element.closest()` instead');
    return element.closest(selector);
  }
  static getAncestor(element, possibleAncestorParents, outerElement = null) {
    let found = false,
      ancestor,
      parent = element;
    possibleAncestorParents = ArrayHelper.asArray(possibleAncestorParents);
    while (parent = parent.parentElement) {
      if (possibleAncestorParents.includes(parent)) {
        found = true;
        break;
      }
      if (outerElement && parent === outerElement) break;
      ancestor = parent;
    }
    if (!found) return null;
    return ancestor || element;
  }
  /**
   * Retrieves all parents to the specified element.
   * @param {HTMLElement} element Element
   * @returns {HTMLElement[]} All parent elements, bottom up
   * @category Query parents
   */
  static getParents(element) {
    const parents = [];
    while (element.parentElement) {
      parents.push(element.parentElement);
      element = element.parentElement;
    }
    return parents;
  }
  //endregion
  //region Creation
  /**
   * Converts the passed id to an id valid for usage as id on a DOM element.
   * @param {String} id
   * @returns {String}
   */
  static makeValidId(id, replaceValue = '') {
    return StringHelper.makeValidDomId(id, replaceValue);
  }
  /**
   * Creates an Element, accepts a {@link #typedef-DomConfig} object. Example usage:
   *
   * ```javascript
   * DomHelper.createElement({
   *   tag         : 'table', // defaults to 'div'
   *   className   : 'nacho',
   *   html        : 'I am a nacho',
   *   children    : [ { tag: 'tr', ... }, myDomElement ],
   *   parent      : myExistingElement // Or its id
   *   style       : 'font-weight: bold;color: red',
   *   dataset     : { index: 0, size: 10 },
   *   tooltip     : 'Yay!',
   *   ns          : 'http://www.w3.org/1999/xhtml'
   * });
   * ```
   *
   * @param {DomConfig} config Element config object
   * @param {Object} [options] An object specifying creation options. If this is a boolean value, it is
   * understood to be the `returnAll` option.
   * @param {Boolean} [options.ignoreRefs] Pass `true` to ignore element references.
   * @param {Boolean} [options.returnAll] Specify true to return all elements & child elements
   * created as an array.
   * @returns {HTMLElement|HTMLElement[]|Object<String,HTMLElement>} Single element or array of elements `returnAll` was set to true.
   * If any elements had a `reference` property, this will be an object containing a reference to
   * all those elements, keyed by the reference name.
   * @category Creation
   */
  static createElement(config = {}, options) {
    var _options, _options$callback, _config$dataset;
    let returnAll = options,
      element,
      i,
      ignoreChildRefs,
      ignoreRefOption,
      ignoreRefs,
      key,
      name,
      value,
      refOwner,
      refs,
      syncIdField;
    if (typeof returnAll === 'boolean') {
      throw new Error('Clean up');
    } else if (options) {
      ignoreRefs = options.ignoreRefs;
      refOwner = options.refOwner;
      refs = options.refs;
      returnAll = options.returnAll;
      syncIdField = options.syncIdField;
      if (ignoreRefs) {
        ignoreChildRefs = true;
        ignoreRefs = ignoreRefs !== 'children';
      }
    }
    if (typeof config.parent === 'string') {
      config.parent = document.getElementById(config.parent);
    }
    // nextSibling implies a parent
    const parent = config.parent || config.nextSibling && config.nextSibling.parentNode,
      {
        dataset,
        html,
        reference,
        syncOptions,
        text
      } = config;
    if (syncOptions) {
      syncIdField = syncOptions.syncIdField || syncIdField;
      ignoreRefOption = syncOptions.ignoreRefs;
      if (ignoreRefOption) {
        ignoreChildRefs = true;
        ignoreRefs = ignoreRefOption !== 'children';
        options = {
          ...options,
          ignoreRefs: true
        };
      }
    }
    if (ignoreRefs) {
      refOwner = null;
    }
    if (config.ns) {
      element = doc.createElementNS(config.ns, config.tag || 'svg');
    } else {
      element = doc.createElement(config.tag || 'div');
    }
    if (text != null) {
      DH.setInnerText(element, text);
    } else if (html != null) {
      if (html instanceof DocumentFragment) {
        element.appendChild(html);
      } else {
        element.innerHTML = html;
      }
    }
    if (config.tooltip) {
      DH.Widget.attachTooltip(element, config.tooltip);
    }
    if (config.style) {
      DH.applyStyle(element, config.style);
    }
    if (dataset) {
      for (name in dataset) {
        value = dataset[name];
        if (value != null) {
          element.dataset[name] = value;
        }
      }
    }
    if (parent) {
      this.addChild(parent, element, config.nextSibling);
    }
    if (refOwner) {
      // Tag each element created by the refOwner's id to enable DomSync
      element.$refOwnerId = refOwner.id;
    }
    if (reference && !ignoreRefs) {
      // SalesForce platform does not allow custom attributes, but existing code
      // uses querySelector('[reference]'), so bypass it when we can:
      if (refOwner) {
        element.$reference = reference;
        refOwner.attachRef(reference, element, config);
      } else {
        if (!refs) {
          options = Object.assign({}, options);
          options.refs = refs = {};
        }
        refs[reference] = element;
        element.setAttribute('data-reference', reference);
      }
    }
    const className = config.className || config.class,
      // matches DomSync
      keys = Object.keys(config);
    if (className) {
      element.setAttribute('class', DomClassList.normalize(className));
    }
    for (i = 0; i < keys.length; ++i) {
      name = keys[i];
      value = config[name];
      // We have to use setAttribute() for custom attributes to work and this is inline with how DomSync
      // handles attributes. For "expando" properties, however, we have to simply assign them.
      if ((key = elementCreateExpandos[name]) != null) {
        element[key || name] = value;
      } else if (!elementCreateProperties[name] && name && value != null) {
        // if (config.ns) {
        //     element.setAttributeNS(config.ns, name, value);
        // }
        // else {
        //     element.setAttribute(name, value);
        // }
        element.setAttribute(name, value);
      }
    }
    // ARIA. In the absence of a defined role or the element being hidden from ARIA,
    // omit unfocusable elements from the accessibility tree.
    if (!config['aria-hidden'] && !config.role && !config.tabIndex && !DomHelper.isFocusable(element, true) && !element.htmlFor) {
      element.setAttribute('role', 'presentation');
    }
    // Mimic the way DomSync issues callbacks as elements are created (needed by TaskBoard to trigger custom
    // taskRenderer calls as elements get produced).
    (_options = options) === null || _options === void 0 ? void 0 : (_options$callback = _options.callback) === null || _options$callback === void 0 ? void 0 : _options$callback.call(_options, {
      action: 'newElement',
      domConfig: config,
      targetElement: element,
      syncId: refOwner ? reference : options.syncIdField && ((_config$dataset = config.dataset) === null || _config$dataset === void 0 ? void 0 : _config$dataset[options.syncIdField])
    });
    // if returnAll is true, use array
    if (returnAll === true) {
      options.returnAll = returnAll = [element];
    }
    // if it already is an array, add to it (we are probably a child)
    else if (Array.isArray(returnAll)) {
      returnAll.push(element);
    }
    if (config.children) {
      if (syncIdField) {
        // Map syncId -> child element to avoid querying dom later on
        element.syncIdMap = {};
      }
      config.children.forEach(child => {
        // Skip null children, convenient to allow those for usage with Array.map()
        if (child) {
          // Append string children as text nodes
          if (typeof child === 'string') {
            const textNode = document.createTextNode(child);
            if (refOwner) {
              textNode.$refOwnerId = refOwner.id;
            }
            element.appendChild(textNode);
          }
          // Just append Elements directly.
          else if (isNaN(child.nodeType)) {
            var _config$syncOptions, _child$dataset;
            child.parent = element;
            if (!child.ns && config.ns) {
              child.ns = config.ns;
            }
            const childElement = DH.createElement(child, {
                ...options,
                ignoreRefs: ((_config$syncOptions = config.syncOptions) === null || _config$syncOptions === void 0 ? void 0 : _config$syncOptions.ignoreRef) ?? ignoreChildRefs
              }),
              syncId = (_child$dataset = child.dataset) === null || _child$dataset === void 0 ? void 0 : _child$dataset[syncIdField];
            // syncId is used with DomHelper.sync to match elements. Populate a map here to make finding them faster
            if (syncId != null) {
              element.syncIdMap[syncId] = childElement;
            }
            // Do not want to alter the initial config
            delete child.parent;
          } else {
            element.appendChild(child);
          }
        }
      });
    }
    // Store used config, to be able to compare on sync to determine if changed without hitting dom
    element.lastDomConfig = config;
    // If references were used, return them in an object
    // If returnAll was specified, return the array
    // By default, return the root element
    return refs || returnAll || element;
  }
  /**
   * Create element(s) from a template (html string). Note that
   * `textNode`s are discarded unless the `raw` option is passed
   * as `true`.
   *
   * If the template has a single root element, then the single element will be returned
   * unless the `array` option is passed as `true`.
   *
   * If there are multiple elements, then an Array will be returned.
   *
   * @param {String} template The HTML string from which to create DOM content
   * @param {Object} [options] An object containing properties to modify how the DOM is created and returned.
   * @param {Boolean} [options.array] `true` to return an array even if there's only one resulting element.
   * @param {Boolean} [options.raw] Return all child nodes, including text nodes.
   * @param {Boolean} [options.fragment] Return a DocumentFragment.
   * @private
   */
  static createElementFromTemplate(template, options = emptyObject$5) {
    const {
      array,
      raw,
      fragment
    } = options;
    let result;
    // Use template by preference if it exists. It's faster on most supported platforms
    // https://jsperf.com/domparser-vs-template/
    if (DH.supportsTemplate) {
      (templateElement || (templateElement = doc.createElement('template'))).innerHTML = template;
      result = templateElement.content;
      if (fragment) {
        // The template is reused, so therefore is its fragment.
        // If we release the fragment to a caller, it must be a clone.
        return result.cloneNode(true);
      }
    } else {
      result = (htmlParser || (htmlParser = new DOMParser())).parseFromString(template, 'text/html').body;
      // We must return a DocumentFragment.
      // myElement.append(fragment) inserts the contents of the fragment, not the fragment itself.
      if (fragment) {
        const nodes = result.childNodes;
        result = document.createDocumentFragment();
        while (nodes.length) {
          result.appendChild(nodes[0]);
        }
        return result;
      }
    }
    // Raw means all child nodes are returned
    if (raw) {
      result = result.childNodes;
    }
    // Otherwise, only element nodes
    else {
      result = result.children;
    }
    return result.length === 1 && !array ? result[0] : arraySlice$1.call(result);
  }
  /**
   * Dispatches a MouseEvent of the passed type to the element at the visible centre of the passed element.
   * @param {HTMLElement} targetElement The element whose center receives the mouse event.
   * @param {String} [type=contextmenu] The mouse event type to dispatch.
   * @internal
   */
  static triggerMouseEvent(targetElement, type = 'contextmenu') {
    const isInView = this.isInView(targetElement),
      targetRect = isInView || Rectangle.from(targetElement),
      targetPoint = targetRect.center,
      contextmenuEvent = new MouseEvent(type, {
        clientX: targetPoint.x,
        clientY: targetPoint.y,
        bubbles: true
      });
    targetElement.dispatchEvent(contextmenuEvent);
  }
  /**
   * Inserts an `element` at first position in `into`.
   * @param {HTMLElement} into Parent element
   * @param {HTMLElement} element Element to insert, or an element config passed on to createElement()
   * @returns {HTMLElement}
   * @category Creation
   */
  static insertFirst(into, element) {
    if (element && element.nodeType !== ELEMENT_NODE && element.tag) {
      element = DH.createElement(element);
    }
    return into.insertBefore(element, into.firstElementChild);
  }
  /**
   * Inserts a `element` before `beforeElement` in `into`.
   * @param {HTMLElement} into Parent element
   * @param {HTMLElement} element Element to insert, or an element config passed on to createElement()
   * @param {HTMLElement} beforeElement Element before which passed element should be inserted
   * @returns {HTMLElement}
   * @category Creation
   */
  static insertBefore(into, element, beforeElement) {
    if (element && element.nodeType !== ELEMENT_NODE && element.tag) {
      element = DH.createElement(element);
    }
    return beforeElement ? into.insertBefore(element, beforeElement) : DH.insertFirst(into, element);
  }
  static insertAt(parentElement, newElement, index) {
    const siblings = Array.from(parentElement.children);
    if (index >= siblings.length) {
      return DH.append(parentElement, newElement);
    }
    const beforeElement = siblings[index];
    return DH.insertBefore(parentElement, newElement, beforeElement);
  }
  /**
   * Appends element to parentElement.
   * @param {HTMLElement} parentElement Parent element
   * @param {HTMLElement|DomConfig|String} elementOrConfig Element to insert, or an element config passed on to
   * `createElement()`, or an html string passed to `createElementFromTemplate()`
   * @returns {HTMLElement}
   * @category Creation
   */
  static append(parentElement, elementOrConfig) {
    if (elementOrConfig.forEach) {
      // Ensure all elements of an Array are HTMLElements.
      // The other implementor of forEach is a NodeList which needs no conversion.
      if (Array.isArray(elementOrConfig)) {
        elementOrConfig = elementOrConfig.map(elementOrConfig => elementOrConfigToElement(elementOrConfig));
      }
      if (parentElement.append) {
        parentElement.append(...elementOrConfig);
      } else {
        const docFrag = document.createDocumentFragment();
        elementOrConfig.forEach(function (child) {
          docFrag.appendChild(child);
        });
        parentElement.appendChild(docFrag);
      }
      return elementOrConfig;
    } else {
      return parentElement.appendChild(elementOrConfigToElement(elementOrConfig));
    }
  }
  //endregion
  //region Get position
  /**
   * Returns the element's `transform translateX` value in pixels.
   * @param {HTMLElement} element
   * @returns {Number} X transform
   * @category Position, get
   */
  static getTranslateX(element) {
    const transformStyle = element.style.transform;
    let matches = pxTtranslateXRe.exec(transformStyle);
    // Use inline transform style if it contains "translate(npx, npx" or "translate3d(npx, npx" or "translateX(npx"
    if (matches) {
      return parseFloat(matches[2]);
    } else {
      // If the inline style is the matrix() form, then use that, otherwise, use computedStyle
      matches = translateMatrixRe.exec(transformStyle) || translateMatrixRe.exec(DH.getStyleValue(element, 'transform'));
      return matches ? parseFloat(matches[1] || matches[3]) : 0;
    }
  }
  /**
   * Returns the element's `transform translateY` value in pixels.
   * @param {HTMLElement} element
   * @returns {Number} Y coordinate
   * @category Position, get
   */
  static getTranslateY(element) {
    const transformStyle = element.style.transform;
    let matches = pxTtranslateYRe.exec(transformStyle);
    // Use inline transform style if it contains "translate(npx, npx" or "translate3d(npx, npx" or "translateY(npx"
    if (matches) {
      // If it was translateY(npx), use first item in the parens.
      const y = parseFloat(matches[matches[1] === 'Y' ? 2 : 3]);
      // FF will strip `translate(x, 0)` -> `translate(x)`, so need to check for isNaN also
      return isNaN(y) ? 0 : y;
    } else {
      // If the inline style is the matrix() form, then use that, otherwise, use computedStyle
      matches = translateMatrixRe.exec(transformStyle) || translateMatrixRe.exec(DH.getStyleValue(element, 'transform'));
      return matches ? parseFloat(matches[2] || matches[4]) : 0;
    }
  }
  /**
   * Gets both X and Y coordinates as an array [x, y]
   * @param {HTMLElement} element
   * @returns {Number[]} [x, y]
   * @category Position, get
   */
  static getTranslateXY(element) {
    return [DH.getTranslateX(element), DH.getTranslateY(element)];
  }
  /**
   * Get elements X offset within a containing element
   * @param {HTMLElement} element
   * @param {HTMLElement} container
   * @returns {Number} X offset
   * @category Position, get
   */
  static getOffsetX(element, container = null) {
    return container ? element.getBoundingClientRect().left - container.getBoundingClientRect().left : element.offsetLeft;
  }
  /**
   * Get elements Y offset within a containing element
   * @param {HTMLElement} element
   * @param {HTMLElement} container
   * @returns {Number} Y offset
   * @category Position, get
   */
  static getOffsetY(element, container = null) {
    return container ? element.getBoundingClientRect().top - container.getBoundingClientRect().top : element.offsetTop;
  }
  /**
   * Gets elements X and Y offset within containing element as an array [x, y]
   * @param {HTMLElement} element
   * @param {HTMLElement} container
   * @returns {Number[]} [x, y]
   * @category Position, get
   */
  static getOffsetXY(element, container = null) {
    return [DH.getOffsetX(element, container), DH.getOffsetY(element, container)];
  }
  /**
   * Focus element without scrolling the element into view.
   * @param {HTMLElement} element
   */
  static focusWithoutScrolling(element) {
    function resetScroll(scrollHierarchy) {
      scrollHierarchy.forEach(({
        element,
        scrollLeft,
        scrollTop
      }) => {
        // Check first to avoid triggering unnecessary `scroll` events
        if (element.scrollLeft !== scrollLeft) {
          element.scrollLeft = scrollLeft;
        }
        if (element.scrollTop !== scrollTop) {
          element.scrollTop = scrollTop;
        }
      });
    }
    // Check browsers which do support focusOptions. Currently only Safari lags.
    // https://caniuse.com/mdn-api_htmlelement_focus_preventscroll_option
    const preventScrollSupported = !BrowserHelper.isSafari;
    if (preventScrollSupported) {
      element.focus({
        preventScroll: true
      });
    } else {
      // Examine every parentNode of the target and cache the scrollLeft and scrollTop,
      // and restore all values after the focus has taken place
      const parents = DH.getParents(element),
        scrollHierarchy = parents.map(parent => ({
          element: parent,
          scrollLeft: parent.scrollLeft,
          scrollTop: parent.scrollTop
        }));
      element.focus();
      // Reset in async.
      setTimeout(() => resetScroll(scrollHierarchy), 0);
    }
  }
  /**
   * Get elements X position on page
   * @param {HTMLElement} element
   * @returns {Number}
   * @category Position, get
   */
  static getPageX(element) {
    return element.getBoundingClientRect().left + win.pageXOffset;
  }
  /**
   * Get elements Y position on page
   * @param {HTMLElement} element
   * @returns {Number}
   * @category Position, get
   */
  static getPageY(element) {
    return element.getBoundingClientRect().top + win.pageYOffset;
  }
  /**
   * Returns extremal (min/max) size (height/width) of the element in pixels
   * @param {HTMLElement} element
   * @param {String} style minWidth/minHeight/maxWidth/maxHeight
   * @returns {Number}
   * @internal
   */
  static getExtremalSizePX(element, style) {
    const prop = StringHelper.hyphenate(style),
      measure = prop.split('-')[1];
    let value = DH.getStyleValue(element, prop);
    if (/%/.test(value)) {
      // Element might be detached from DOM
      if (element.parentElement) {
        value = parseInt(DH.getStyleValue(element.parentElement, measure), 10);
      } else {
        value = NaN;
      }
    } else {
      value = parseInt(value, 10);
    }
    return value;
  }
  //endregion
  //region Set position
  /**
   * Set element's `scale`.
   * @param {HTMLElement} element
   * @param {Number} scaleX The value by which the element should be scaled in the X axis (0 to 1)
   * @param {Number} [scaleY] The value by which the element should be scaled in the Y axis (0 to 1).
   * Defaults to `scaleX`
   * @category Position, set
   * @internal
   */
  static setScale(element, scaleX, scaleY = scaleX) {
    const t = DH.getStyleValue(element, 'transform').split(/,\s*/);
    if (t.length > 1) {
      if (t[0].startsWith('matrix3d')) {
        t[0] = `matrix3d(${scaleX}`;
        t[5] = scaleY;
      } else {
        t[0] = `matrix(${scaleX}`;
        t[3] = scaleY;
      }
      element.style.transform = t.join(',');
    } else {
      element.style.transform = `scale(${scaleX}, ${scaleY})`;
    }
  }
  /**
   * Set element's `X` translation in pixels.
   * @param {HTMLElement} element
   * @param {Number} x The value by which the element should be translated from its default position.
   * @category Position, set
   */
  static setTranslateX(element, x) {
    const t = DH.getStyleValue(element, 'transform').split(/,\s*/);
    // Avoid blurry text on non-retina displays
    x = DH.roundPx(x);
    if (t.length > 1) {
      t[t[0].startsWith('matrix3d') ? 12 : 4] = x;
      element.style.transform = t.join(',');
    } else {
      element.style.transform = `translateX(${x}px)`;
    }
  }
  /**
   * Set element's `Y` translation in pixels.
   * @param {HTMLElement} element
   * @param {Number} y  The value by which the element should be translated from its default position.
   * @category Position, set
   */
  static setTranslateY(element, y) {
    const t = DH.getStyleValue(element, 'transform').split(/,\s*/);
    // Avoid blurry text on non-retina displays
    y = DH.roundPx(y);
    if (t.length > 1) {
      t[t[0].startsWith('matrix3d') ? 13 : 5] = y;
      element.style.transform = t.join(',') + ')';
    } else {
      element.style.transform = `translateY(${y}px)`;
    }
  }
  /**
   * Set element's style `top`.
   * @param {HTMLElement} element
   * @param {Number|String} y The top position. If numeric, `'px'` is used as the unit.
   * @category Position, set
   */
  static setTop(element, y) {
    DH.setLength(element, 'top', y);
  }
  /**
   * Set element's style `left`.
   * @param {HTMLElement} element
   * @param {Number|String} x The top position. If numeric, `'px'` is used as the unit.
   * @category Position, set
   */
  static setLeft(element, x) {
    DH.setLength(element, 'left', x);
  }
  static setTopLeft(element, y, x) {
    DH.setLength(element, 'top', y);
    DH.setLength(element, 'left', x);
  }
  static setRect(element, {
    x,
    y,
    width,
    height
  }) {
    DH.setTopLeft(element, y, x);
    DH.setLength(element, 'width', width);
    DH.setLength(element, 'height', height);
  }
  /**
   * Set elements `X` and `Y` translation in pixels.
   * @param {HTMLElement} element
   * @param {Number} [x] The `X translation.
   * @param {Number} [y] The `Y translation.
   * @category Position, set
   */
  static setTranslateXY(element, x, y) {
    if (x == null) {
      return DH.setTranslateY(element, y);
    }
    if (y == null) {
      return DH.setTranslateX(element, x);
    }
    // Avoid blurry text on non-retina displays
    x = DH.roundPx(x);
    y = DH.roundPx(y);
    const t = DH.getStyleValue(element, 'transform').split(/,\s*/),
      is3d = t[0].startsWith('matrix3d');
    if (t.length > 1) {
      t[is3d ? 12 : 4] = x;
      t[is3d ? 13 : 5] = y;
      element.style.transform = t.join(',') + ')';
    } else {
      element.style.transform = `translate(${x}px, ${y}px)`;
    }
  }
  /**
   * Increase `X` translation
   * @param {HTMLElement} element
   * @param {Number} x The number of pixels by which to increase the element's `X` translation.
   * @category Position, set
   */
  static addTranslateX(element, x) {
    DH.setTranslateX(element, DH.getTranslateX(element) + x);
  }
  /**
   * Increase `Y` position
   * @param {HTMLElement} element
   * @param {Number} y The number of pixels by which to increase the element's `Y` translation.
   * @category Position, set
   */
  static addTranslateY(element, y) {
    DH.setTranslateY(element, DH.getTranslateY(element) + y);
  }
  /**
   * Increase X position
   * @param {HTMLElement} element
   * @param {Number} x
   * @category Position, set
   */
  static addLeft(element, x) {
    DH.setLeft(element, DH.getOffsetX(element) + x);
  }
  /**
   * Increase Y position
   * @param {HTMLElement} element
   * @param {Number} y
   * @category Position, set
   */
  static addTop(element, y) {
    DH.setTop(element, DH.getOffsetY(element) + y);
  }
  /**
   * Align the passed element with the passed target according to the align spec.
   * @param {HTMLElement} element The element to align.
   * @param {HTMLElement|Core.helper.util.Rectangle} target The target element or rectangle to align to
   * @param {Object} [alignSpec] See {@link Core.helper.util.Rectangle#function-alignTo} Defaults to `{ align : 't0-t0' }`
   * @param {Boolean} [round] Round the calculated Rectangles (for example if dealing with scrolling which
   * is integer based).
   */
  static alignTo(element, target, alignSpec = t0t0, round) {
    target = target instanceof Rectangle ? target : Rectangle.from(target, true);
    const elXY = DH.getTranslateXY(element),
      elRect = Rectangle.from(element, true);
    if (round) {
      elRect.roundPx();
      target.roundPx();
    }
    const targetRect = elRect.alignTo(Object.assign(alignSpec, {
      target
    }));
    DH.setTranslateXY(element, elXY[0] + targetRect.x - elRect.x, elXY[1] + targetRect.y - elRect.y);
  }
  //endregion
  //region Styles & CSS
  /**
   * Returns a style value or values for the passed element.
   * @param {HTMLElement} element The element to read styles from
   * @param {String|String[]} propName The property or properties to read
   * @param {Boolean} [inline=false] Pass as `true` to read the element's inline style.
   * Note that this could return inaccurate results if CSS rules apply to this element.
   * @returns {String|Object} The value or an object containing the values keyed by the requested property name.
   * @category CSS
   */
  static getStyleValue(element, propName, inline, pseudo) {
    const styles = inline ? element.style : element.ownerDocument.defaultView.getComputedStyle(element, pseudo);
    if (Array.isArray(propName)) {
      const result = {};
      for (const prop of propName) {
        result[prop] = styles.getPropertyValue(StringHelper.hyphenate(prop));
      }
      return result;
    }
    // Use the elements owning view to get the computed style.
    // Ensure the property name asked for is hyphenated.
    // getPropertyValue doesn't work with camelCase
    return styles.getPropertyValue(StringHelper.hyphenate(propName));
  }
  /**
   * Returns an object with the parse style values for the top, right, bottom, and left
   * components of the given edge style.
   *
   * The return value is an object with `top`, `right`, `bottom`, and `left` properties
   * for the respective components of the edge style, as well as `width` (the sum of
   * `left` and `right`) and `height` (the sum of `top` and `bottom`).
   *
   * @param {HTMLElement} element
   * @param {String} edgeStyle The element's desired edge style such as 'padding', 'margin',
   * or 'border'.
   * @param {String} [edges='trbl'] A string with one character codes for each edge. Only
   * those edges will be populated in the returned object. By default, all edges will be
   * populated.
   * @returns {Object}
   */
  static getEdgeSize(element, edgeStyle, edges) {
    const suffix = edgeStyle === 'border' ? '-width' : '',
      ret = {
        raw: {}
      };
    for (const edge of ['top', 'right', 'bottom', 'left']) {
      if (!edges || edges.includes(edge[0])) {
        // This produces px units even if the provided style is em or other (i.e.,
        // getComputedStyle normalizes this):
        ret[edge] = parseFloat(ret.raw[edge] = DH.getStyleValue(element, `${edgeStyle}-${edge}${suffix}`));
      }
    }
    // These may not even be requested (based on "edges") but conditional code here
    // would be wasted since the caller would still need to know not to use them...
    // Replace NaN with 0 to keep calculations correct if they only asked for one side.
    ret.width = (ret.left || 0) + (ret.right || 0);
    ret.height = (ret.top || 0) + (ret.bottom || 0);
    return ret;
  }
  /**
   * Splits a style string up into object form. For example `'font-weight:bold;font-size:150%'`
   * would convert to
   *
   * ```javascript
   * {
   *     font-weight : 'bold',
   *     font-size : '150%'
   * }
   * ```
   * @param {String} style A DOM style string
   * @returns {Object} the style declaration in object form.
   */
  static parseStyle(style) {
    if (typeof style === 'string') {
      const styles = style.split(semicolonRe);
      style = {};
      for (let i = 0, {
          length
        } = styles; i < length; i++) {
        const propVal = styles[i].split(colonRe);
        style[propVal[0]] = propVal[1];
      }
    }
    return style || {};
  }
  /**
   * Applies specified style to the passed element. Style can be an object or a string.
   * @param {HTMLElement} element Target element
   * @param {String|Object} style Style to apply, 'border: 1px solid black' or { border: '1px solid black' }
   * @param {Boolean} [overwrite] Specify `true` to replace style instead of applying changes
   * @category CSS
   */
  static applyStyle(element, style, overwrite = false) {
    if (typeof style === 'string') {
      if (overwrite) {
        // Only assign if either end has any styles, do not want to add empty `style` tag on element
        if (style.length || element.style.cssText.length) {
          element.style.cssText = style;
        }
      } else {
        // Add style so as not to delete configs in style such as width, height, flex etc.
        // If a style is already there, the newest, appended one will take precedence.
        element.style.cssText += style;
      }
    } else if (style) {
      if (overwrite) {
        element.style.cssText = '';
        //element.removeAttribute('style');
      }
      // Has a sub-style block in object form? Use it to override style block
      if (style.style && typeof style.style !== 'string') {
        style = ObjectHelper.assign({}, style, style.style);
      }
      let key, value;
      // Prototype chained objects may be passed, so use direct loop.
      for (key in style) {
        // Ignore readonly properties of the CSSStyleDeclaration object:
        // https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration
        // Also ignores sub-style blocks, which are applied above
        if (!styleIgnoreProperties[key]) {
          [key, value] = DH.unitize(key, style[key]);
          // Cannot use element.style[key], won't work with CSS vars
          if (value == null) {
            element.style.removeProperty(key);
          } else {
            element.style.setProperty(key, value);
          }
        }
      }
      // Has sub-styles as string? Add to cssText after applying style block, to override it
      if (typeof style.style === 'string') {
        element.style.cssText += style.style;
      }
    }
  }
  static getCSSText(style) {
    if (typeof style === 'string') {
      return style;
    }
    let cssText = '';
    for (const key in style) {
      // Ignore readonly properties of the CSSStyleDeclaration object:
      // https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration
      if (!styleIgnoreProperties[key]) {
        cssText += `${StringHelper.hyphenate(key)}:${style[key]};`;
      }
    }
    return cssText;
  }
  /**
   * Add multiple classes to elements classList.
   * @param {HTMLElement} element
   * @param {String[]} classes
   * @deprecated Since 5.0. Use {@link https://developer.mozilla.org/en-US/docs/Web/API/DOMTokenList/add add} method
   * for {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/classList Element.classlist}
   * @category CSS
   */
  static addClasses(element, classes) {
    VersionHelper.deprecate('Core', '6.0.0', 'DomHelper.addClasses should be replaced by native classList.add');
    element.classList.add(...classes);
  }
  /**
   * Remove multiple classes from elements classList.
   * @param {HTMLElement} element
   * @param {String[]} classes
   * @deprecated Since 5.0. Use {@link https://developer.mozilla.org/en-US/docs/Web/API/DOMTokenList/remove remove} method
   * for {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/classList Element.classlist}
   * @category CSS
   */
  static removeClasses(element, classes) {
    VersionHelper.deprecate('Core', '6.0.0', 'DomHelper.removeClasses should be replaced by native classList.remove');
    element.classList.remove(...classes);
  }
  /**
   * Toggle multiple classes in elements classList. Helper for toggling multiple classes at once.
   * @param {HTMLElement} element
   * @param {String[]} classes
   * @param {Boolean} [force] Specify true to add classes, false to remove. Leave blank to toggle
   * @category CSS
   */
  static toggleClasses(element, classes, force = null) {
    classes = ArrayHelper.asArray(classes);
    if (force === true) {
      element.classList.add(...classes);
    } else if (force === false) {
      element.classList.remove(...classes);
    } else {
      classes.forEach(cls => element.classList.toggle(cls));
    }
  }
  /**
   * Adds a CSS class to an element during the specified duration
   * @param {HTMLElement} element Target element
   * @param {String} cls CSS class to add temporarily
   * @param {Number} duration Duration in ms, 0 means cls will not be applied
   * @param {Core.mixin.Delayable} delayable The delayable to tie the setTimeout call to
   * @typings delayable -> {typeof Delayable}
   * @category CSS
   */
  static addTemporaryClass(element, cls, duration, delayable = globalThis) {
    if (duration > 0) {
      element.classList.add(cls);
      delayable.setTimeout({
        fn: cls => element.classList.remove(cls),
        delay: duration,
        name: cls,
        args: [cls],
        cancelOutstanding: true
      });
    }
  }
  /**
   * Reads computed style from the element and returns transition duration for a given property in milliseconds
   * @param {HTMLElement} element Target DOM element
   * @param {String} property Animated property name
   * @returns {Number} Duration in ms
   * @internal
   */
  static getPropertyTransitionDuration(element, property) {
    const style = globalThis.getComputedStyle(element),
      properties = style.transitionProperty.split(', '),
      durations = style.transitionDuration.split(', '),
      index = properties.indexOf(StringHelper.hyphenate(property));
    let result;
    if (index !== -1) {
      // get floating value of transition duration in seconds and convert into milliseconds
      result = parseFloat(durations[index]) * 1000;
    }
    return result;
  }
  /**
   * Reads computed style from the element and returns the animation duration for any
   * attached animation in milliseconds
   * @param {HTMLElement} element Target DOM element
   * @returns {Number} Duration in ms
   * @internal
   */
  static getAnimationDuration(element) {
    return parseFloat(DH.getStyleValue(element, 'animation-duration')) * 1000;
  }
  //endregion
  //region Effects
  /**
   * Highlights the passed element or Rectangle according to the theme's highlighting rules.
   * Usually an animated framing effect.
   *
   * The framing effect is achieved by adding the CSS class `b-fx-highlight` which references
   * a `keyframes` animation named `b-fx-highlight-animation`. You may override the animation
   * name referenced, or the animation itself in your own CSS.
   *
   * @param {HTMLElement|Core.helper.util.Rectangle} element The element or Rectangle to highlight.
   */
  static highlight(element, delayable = globalThis) {
    if (element instanceof Rectangle) {
      return element.highlight();
    }
    return new Promise(resolve => {
      delayable.setTimeout(() => {
        element.classList.add('b-fx-highlight');
        delayable.setTimeout(() => {
          element.classList.remove('b-fx-highlight');
          resolve();
        }, 1000);
      }, 0);
    });
  }
  //endregion
  //region Measuring / Scrollbar
  /**
   * Measures the scrollbar width using a hidden div. Caches result
   * @property {Number}
   * @readonly
   */
  static get scrollBarWidth() {
    // Ensure the measurement is only done once, when the value is null.
    // Leave measure element in place. It needs to be remeasured when the zoom level is changed
    // which is detected using a window resize listener, so *may* be called frequently.
    if (scrollBarWidth === null) {
      const element = scrollBarMeasureElement || (scrollBarMeasureElement = DH.createElement({
        parent: doc.documentElement,
        style: 'position:absolute;top:-9999em;height:100px;overflow-y:scroll'
      }));
      if (element.parentNode !== doc.documentElement) {
        doc.documentElement.appendChild(element);
      }
      scrollBarWidth = element.offsetWidth;
    }
    return scrollBarWidth;
  }
  static get scrollBarPadElement() {
    return {
      className: 'b-yscroll-pad',
      children: [{
        className: 'b-yscroll-pad-sizer'
      }]
    };
  }
  /**
   * Resets DomHelper.scrollBarWidth cache, triggering a new measurement next time it is read
   */
  static resetScrollBarWidth() {
    scrollBarWidth = null;
  }
  /**
   * Measures the text width using a hidden div
   * @param {String} text
   * @param {HTMLElement} sourceElement
   * @returns {Number} width
   * @category Measure
   */
  static measureText(text, sourceElement, useHTML = false, parentElement = undefined) {
    const offScreenDiv = DH.getMeasureElement(sourceElement, parentElement);
    offScreenDiv[useHTML ? 'innerHTML' : 'innerText'] = text;
    const result = offScreenDiv.clientWidth;
    offScreenDiv.className = '';
    return result;
  }
  /**
   * Measures a relative size, such as a size specified in `em` units for the passed element.
   * @param {String} size The CSS size value to measure.
   * @param {HTMLElement} sourceElement
   * @param {Boolean} [round] Pass true to return exact width, not rounded value
   * @returns {Number} size The size in pixels of the passed relative measurement.
   * @category Measure
   */
  static measureSize(size, sourceElement, round = true) {
    if (!size) {
      return 0;
    }
    if (typeof size === 'number') {
      return size;
    }
    if (!size.length) {
      return 0;
    }
    if (/^\d+(px)?$/.test(size)) {
      return parseInt(size);
    }
    if (sourceElement) {
      const offScreenDiv = DH.getMeasureElement(sourceElement);
      offScreenDiv.innerHTML = '';
      offScreenDiv.style.width = DH.setLength(size);
      const result = round ? offScreenDiv.offsetWidth : offScreenDiv.getBoundingClientRect().width;
      offScreenDiv.style.width = offScreenDiv.className = '';
      return result;
    }
    if (/^\d+em$/.test(size)) {
      return parseInt(size) * DEFAULT_FONT_SIZE;
    }
    return isNaN(size) ? 0 : parseInt(size);
  }
  // parentElement allows measurement to happen inside a specific element, allowing scoped css rules to match
  static getMeasureElement(sourceElement, parentElement = doc.body) {
    const sourceElementStyle = win.getComputedStyle(sourceElement),
      offScreenDiv = parentElement.offScreenDiv = parentElement.offScreenDiv || DH.createElement({
        parent: parentElement,
        style: 'position:fixed;top:-10000px;left:-10000px;visibility:hidden;contain:strict',
        className: 'b-measure-element',
        children: [{
          style: 'white-space:nowrap;display:inline-block;will-change:contents;width:auto;contain:none'
        }]
      }, {
        returnAll: true
      })[1];
    fontProps.forEach(prop => {
      if (offScreenDiv.style[prop] !== sourceElementStyle[prop]) {
        offScreenDiv.style[prop] = sourceElementStyle[prop];
      }
    });
    offScreenDiv.className = sourceElement.className;
    // In case the measure element was moved/removed, re-add it
    if (offScreenDiv.parentElement.parentElement !== parentElement) {
      parentElement.appendChild(offScreenDiv.parentElement);
    }
    return offScreenDiv;
  }
  /**
   * Strips the tags from a html string, returning text content.
   *
   * ```javascript
   * DomHelper.stripTags('<div class="custom"><b>Bold</b><i>Italic</i></div>'); // -> BoldItalic
   * ```
   *
   * @internal
   * @param {String} htmlString HTML string
   * @returns {String} Text content
   */
  static stripTags(htmlString) {
    const
      // we need to avoid any kind of evaluation of embedded XSS scripts or "web bugs" (img tags that issue
      // GET requests)
      parser = DH.$domParser || (DH.$domParser = new DOMParser()),
      doc = parser.parseFromString(htmlString, 'text/html');
    return doc.body.textContent;
  }
  //endregion
  //region Sync
  /**
   * Sync one source element attributes, children etc. to a target element. Source element can be specified as a html
   * string or an actual HTMLElement.
   *
   * NOTE: This function is superseded by {@link Core/helper/DomSync#function-sync-static DomSync.sync()}, which works
   * with DOM configs. For most usecases, use it instead.
   *
   * @param {String|HTMLElement} sourceElement Source "element" to copy from
   * @param {HTMLElement} targetElement Target element to apply to, can also be specified as part of the config object
   * @returns {HTMLElement} Returns the updated targetElement (which is also updated in place)
   */
  static sync(sourceElement, targetElement) {
    if (typeof sourceElement === 'string') {
      if (sourceElement === '') {
        targetElement.innerHTML = '';
        return;
      } else {
        sourceElement = DH.createElementFromTemplate(sourceElement);
      }
    }
    DH.performSync(sourceElement, targetElement);
    return targetElement;
  }
  // Internal helper used for recursive syncing
  static performSync(sourceElement, targetElement) {
    // Syncing identical elements is a no-op
    if (sourceElement.outerHTML !== targetElement.outerHTML) {
      DH.syncAttributes(sourceElement, targetElement);
      DH.syncContent(sourceElement, targetElement);
      DH.syncChildren(sourceElement, targetElement);
      return true;
    }
    return false;
  }
  // Attributes as map { attr : value, ... }, either from an html element or from a config
  static getSyncAttributes(element) {
    const attributes = {},
      // Attribute names, simplifies comparisons and calls to set/removeAttribute
      names = [];
    // Extract from element
    for (let i = 0; i < element.attributes.length; i++) {
      const attr = element.attributes[i];
      if (attr.specified) {
        const name = attr.name.toLowerCase();
        attributes[name] = attr.value;
        names.push(name);
      }
    }
    return {
      attributes,
      names
    };
  }
  /**
   * Syncs attributes from sourceElement to targetElement.
   * @private
   * @param {HTMLElement} sourceElement
   * @param {HTMLElement} targetElement
   */
  static syncAttributes(sourceElement, targetElement) {
    const
      // Extract attributes from elements (sourceElement might be a config)
      {
        attributes: sourceAttributes,
        names: sourceNames
      } = DH.getSyncAttributes(sourceElement),
      {
        attributes: targetAttributes,
        names: targetNames
      } = DH.getSyncAttributes(targetElement),
      // Used to ignore data-xx attributes when we will be setting entire dataset
      hasDataset = sourceNames.includes('dataset'),
      // Intersect arrays to determine what needs adding, removing and syncing
      toAdd = sourceNames.filter(attr => !targetNames.includes(attr)),
      toRemove = targetNames.filter(attr => !sourceNames.includes(attr) && (!hasDataset || !attr.startsWith('data-'))),
      toSync = sourceNames.filter(attr => targetNames.includes(attr));
    if (toAdd.length > 0) {
      for (let i = 0; i < toAdd.length; i++) {
        const attr = toAdd[i];
        // Style requires special handling
        if (attr === 'style') {
          DH.applyStyle(targetElement, sourceAttributes.style, true);
        }
        // So does dataset
        else if (attr === 'dataset') {
          Object.assign(targetElement.dataset, sourceAttributes.dataset);
        }
        // Other attributes are set using setAttribute (since it calls toString() DomClassList works fine)
        else {
          targetElement.setAttribute(attr, sourceAttributes[attr]);
        }
      }
    }
    if (toRemove.length > 0) {
      for (let i = 0; i < toRemove.length; i++) {
        targetElement.removeAttribute(toRemove[i]);
      }
    }
    if (toSync.length > 0) {
      for (let i = 0; i < toSync.length; i++) {
        const attr = toSync[i];
        // Set all attributes that has changed, with special handling for style
        if (attr === 'style') {
          DH.applyStyle(targetElement, sourceAttributes.style, true);
        }
        // And dataset
        else if (attr === 'dataset') {
          Object.assign(targetElement.dataset, sourceAttributes.dataset);
        }
        // And class, which might be a DomClassList or an config for a DomClassList
        else if (attr === 'class' && (sourceAttributes.class.isDomClassList || typeof sourceAttributes.class === 'object')) {
          let classList;
          if (sourceAttributes.class.isDomClassList) {
            classList = sourceAttributes.class;
          } else {
            classList = new DomClassList(sourceAttributes.class);
          }
          if (!classList.isEqual(targetAttributes.class)) {
            targetElement.setAttribute('class', classList);
          }
        } else if (targetAttributes[attr] !== sourceAttributes[attr]) {
          targetElement.setAttribute(attr, sourceAttributes[attr]);
        }
      }
    }
  }
  /**
   * Sync content (innerText) from sourceElement to targetElement
   * @private
   * @param {HTMLElement} sourceElement
   * @param {HTMLElement} targetElement
   */
  static syncContent(sourceElement, targetElement) {
    if (DH.getChildElementCount(sourceElement) === 0) {
      targetElement.innerText = sourceElement.innerText;
    }
  }
  static setInnerText(targetElement, text) {
    // setting firstChild.data is faster than innerText (and innerHTML),
    // but in some cases the inner node is lost and needs to be recreated
    const {
      firstChild
    } = targetElement;
    if ((firstChild === null || firstChild === void 0 ? void 0 : firstChild.nodeType) === Element.TEXT_NODE) {
      firstChild.data = text;
    } else {
      // textContent is supposed to be faster than innerText, since it does not trigger layout
      targetElement.textContent = text;
    }
  }
  /**
   * Sync traversing children
   * @private
   * @param {HTMLElement} sourceElement Source element
   * @param {HTMLElement} targetElement Target element
   */
  static syncChildren(sourceElement, targetElement) {
    const me = this,
      sourceNodes = arraySlice$1.call(sourceElement.childNodes),
      targetNodes = arraySlice$1.call(targetElement.childNodes);
    while (sourceNodes.length) {
      const sourceNode = sourceNodes.shift(),
        targetNode = targetNodes.shift();
      // only textNodes and elements allowed (no comments)
      if (sourceNode && sourceNode.nodeType !== TEXT_NODE && sourceNode.nodeType !== ELEMENT_NODE) {
        throw new Error(`Source node type ${sourceNode.nodeType} not supported by DomHelper.sync()`);
      }
      if (targetNode && targetNode.nodeType !== TEXT_NODE && targetNode.nodeType !== ELEMENT_NODE) {
        throw new Error(`Target node type ${targetNode.nodeType} not supported by DomHelper.sync()`);
      }
      if (!targetNode) {
        // out of target nodes, add to target
        targetElement.appendChild(sourceNode);
      } else {
        // match node
        if (sourceNode.nodeType === targetNode.nodeType) {
          // same type of node, take action depending on which type
          if (sourceNode.nodeType === TEXT_NODE) {
            // text
            targetNode.data = sourceNode.data;
          } else {
            if (sourceNode.tagName === targetNode.tagName) {
              me.performSync(sourceNode, targetNode);
            } else {
              // new tag, remove targetNode and insert new element
              targetElement.insertBefore(sourceNode, targetNode);
              targetNode.remove();
            }
          }
        }
        // Trying to set text node as element, use it as innerText
        // (we get this in FF with store mutations and List)
        else if (sourceNode.nodeType === TEXT_NODE && targetNode.nodeType === ELEMENT_NODE) {
          targetElement.innerText = sourceNode.data.trim();
        } else {
          const logElement = sourceNode.parentElement || sourceNode;
          throw new Error(`Currently no support for transforming nodeType.\n${logElement.outerHTML}`);
        }
      }
    }
    // Out of source nodes, remove remaining target nodes
    targetNodes.forEach(targetNode => {
      targetNode.remove();
    });
  }
  /**
   * Replaces the passed element's `className` with the class names
   * passed in either Array or String format or Object.
   *
   * This method compares the existing class set with the incoming class set and
   * avoids mutating the element's class name set if possible.
   *
   * This can avoid browser style invalidations.
   * @param {HTMLElement} element The element whose class list to synchronize.
   * @param {String[]|String|Object} newClasses The incoming class names to set on the element.
   * @returns {Boolean} `true` if the DOM class list was changed.
   * @category CSS
   */
  static syncClassList(element, newClasses) {
    const {
        classList
      } = element,
      isString = typeof newClasses === 'string',
      newClsArray = isString ? newClasses.split(whiteSpaceRe) : DomClassList.normalize(newClasses, 'array'),
      classCount = newClsArray.length;
    let changed = classList.length !== classCount,
      i;
    // If the incoming and existing class lists are the same length
    // then check that each contains the same names. As soon as
    // we find a non-matching name, we know we have to update the
    // className.
    for (i = 0; !changed && i < classCount; i++) {
      changed = !classList.contains(newClsArray[i]);
    }
    if (changed) {
      element.className = isString ? newClasses : newClsArray.join(' ');
    }
    return changed;
  }
  /**
   * Applies the key state of the passed object or DomClassList to the passed element.
   *
   * Properties with a falsy value mean that property name is *removed* as a class name.
   *
   * Properties with a truthy value mean that property name is *added* as a class name.
   *
   * This is different from {@link #function-syncClassList-static}. That sets the `className` of the element to the
   * sum of all its truthy keys, regardless of what the pre-existing value of the `className` was, and ignoring falsy
   * keys.
   *
   * This _selectively_ updates the classes in the `className`. If there is a truthy key, the name is added. If there
   * is a falsy key, the name is removed.
   * @param {HTMLElement} element The element to apply the class list to .
   * @param {Object|Core.helper.util.DomClassList} classes The classes to add or remove.
   * @returns {Boolean} `true` if the DOM class list was changed.
   * @category CSS
   */
  static updateClassList(element, classes) {
    const {
      classList
    } = element;
    let cls,
      add,
      changed = false;
    for (cls in classes) {
      add = Boolean(classes[cls]);
      if (classList.contains(cls) !== add) {
        classList[add ? 'add' : 'remove'](cls);
        changed = true;
      }
    }
    return changed;
  }
  /**
   * Changes the theme to the passed theme name if possible.
   *
   * Theme names are case insensitive. The `href` used is all lower case.
   *
   * To use this method, the `<link rel="stylesheet">` _must_ use the default,
   * Bryntum-supplied CSS files where the `href` end with `<themeName>.css`, so that
   * it can be found in the document, and switched out for a new link with
   * the a modified `href`. The new `href` will use the same path, just
   * with the `themeName` portion substituted for the new name.
   *
   * If no `<link>` with that name pattern can be found, an error will be thrown.
   *
   * If you use this method, you  must ensure that the theme files are
   * all accessible on your server.
   *
   * Because this is an asynchronous operation, a `Promise` is returned.
   * The theme change event is passed to the success function. If the
   * theme was not changed, because the theme name passed is the current theme,
   * nothing is passed to the success function.
   *
   * The theme change event contains two properties:
   *
   *  - `prev` The previous Theme name.
   *  - `theme` The new Theme name.
   *
   * @param {String} newThemeName the name of the theme that should be applied
   * @privateparam {String} [defaultTheme] Optional, the name of the theme that should be used in case of fail
   * @returns {Promise} A promise who's success callback receives the theme change
   * event if the theme in fact changed. If the theme `href` could not be loaded,
   * the failure callback is called, passing the error event caught.
   * @async
   */
  static setTheme(newThemeName, defaultTheme) {
    newThemeName = newThemeName.toLowerCase();
    const {
        head
      } = document,
      oldThemeName = DH.getThemeInfo(defaultTheme).name.toLowerCase();
    let oldThemeLinks = head.querySelectorAll('[data-bryntum-theme]:not([data-loading])'),
      loaded = 0;
    if (oldThemeName === newThemeName) {
      return immediatePromise$3;
    }
    // Remove any links currently loading
    DH.removeEachSelector(head, '#bryntum-theme[data-loading],link[data-bryntum-theme][data-loading]');
    const themeEvent = {
      theme: newThemeName,
      prev: oldThemeName
    };
    function replaceTheme(oldThemeLink, resolve, reject) {
      const newThemeLink = DomHelper.createElement({
        tag: 'link',
        rel: 'stylesheet',
        dataset: {
          loading: true,
          bryntumTheme: true
        },
        href: oldThemeLink.href.replace(oldThemeName, newThemeName),
        nextSibling: oldThemeLink
      });
      newThemeLink.addEventListener('load', () => {
        delete newThemeLink.dataset.loading;
        themeInfo = null;
        // Flip all products to the new theme at the same time
        if (++loaded === oldThemeLinks.length) {
          oldThemeLinks.forEach(link => link.remove());
          GlobalEvents.trigger('theme', themeEvent);
          resolve(themeEvent);
        }
      });
      newThemeLink.addEventListener('error', e => {
        delete newThemeLink.dataset.loading;
        reject(e);
      });
    }
    if (oldThemeLinks.length) {
      return new Promise((resolve, reject) => {
        oldThemeLinks.forEach((oldThemeLink, i) => {
          replaceTheme(oldThemeLink, resolve, reject, i === oldThemeLinks.length - 1);
        });
      });
    } else {
      const oldThemeLink = head.querySelector('#bryntum-theme:not([data-loading])') || head.querySelector(`[href*="${oldThemeName}.css"]:not([data-loading])`);
      // Theme link href ends with <themeName>.css also there could be a query - css?11111...
      if (!(oldThemeLink !== null && oldThemeLink !== void 0 && oldThemeLink.href.includes(`${oldThemeName}.css`))) {
        throw new Error(`Theme link for ${oldThemeName} not found`);
      }
      oldThemeLinks = [oldThemeLink];
      return new Promise((resolve, reject) => replaceTheme(oldThemeLink, resolve, reject));
    }
  }
  /**
   * A theme information object about the current theme.
   *
   * Currently, this has only one property:
   *
   *   - `name` The current theme name.
   * @property {Object}
   * @readonly
   */
  static get themeInfo() {
    return DomHelper.getThemeInfo();
  }
  /**
   * A theme information object about the current theme.
   *
   * Currently this has only one property:
   *
   *   - `name` The current theme name.
   * @param {String} defaultTheme the name of the theme used as backup value in case of fail
   * @param {HTMLElement} contextElement The element for which to find the theme. If using a
   * web component, the theme will be encapsulated in the web component's encapsulated style
   * so a context element is required. If no web components are in use, this may be omitted and
   * `document.body` will be used.
   * @returns {Object} info, currently it contains only one property - 'name'.
   * @private
   */
  static getThemeInfo(defaultTheme) {
    if (!themeInfo) {
      const
        // The content it creates for 'b-theme-info' is described in corresponding theme in Core/resources/sass/themes
        // for example in Core/resources/sass/themes/material.scss
        // ```
        // .b-theme-info:before {
        //     content : '{"name":"Material"}';
        // }
        // ```
        testDiv = DH.createElement({
          parent: document.body,
          className: 'b-theme-info'
        }),
        // Theme desc object is in the :before pseudo element.
        themeData = DH.getStyleValue(testDiv, 'content', false, ':before');
      if (themeData) {
        // themeData could be invalid JSON string in case there is no content rule
        try {
          themeInfo = JSON.parse(themeData.replace(/^["']|["']$|\\/g, ''));
        } catch (e) {
          themeInfo = null;
        }
      }
      // CSS file has to be loaded to make the themeInfo available, so fallback to the default theme name
      themeInfo = themeInfo || (defaultTheme ? {
        name: defaultTheme
      } : null);
      testDiv.remove();
    }
    return themeInfo;
  }
  //endregion
  //region Transition
  static async transition({
    element: outerElement,
    selector = '[data-dom-transition]',
    duration,
    action,
    thisObj = this,
    addTransition = {},
    removeTransition = {}
  }) {
    const scrollers = new Set(),
      beforeElements = Array.from(outerElement.querySelectorAll(selector)),
      beforeMap = new Map(beforeElements.map(element => {
        let depth = 0,
          parent = element.parentElement;
        while (parent && parent !== outerElement) {
          depth++;
          parent = parent.parentElement;
        }
        element.$depth = depth;
        // Store scrolling elements and their current scroll pos, for restoring later
        if (element.scrollHeight > element.offsetHeight && getComputedStyle(element).overflow === 'auto') {
          element.$scrollTop = element.scrollTop;
          scrollers.add(element);
        }
        // Intersect our bounds with parents, to trim away overflow
        const {
            parentElement
          } = element,
          globalBounds = Rectangle.from(element, outerElement),
          localBounds = Rectangle.from(element, parentElement),
          style = getComputedStyle(parentElement),
          borderLeftWidth = parseFloat(style.borderLeftWidth);
        if (borderLeftWidth) {
          globalBounds.left -= borderLeftWidth;
          localBounds.left -= borderLeftWidth;
        }
        return [element.id, {
          element,
          globalBounds,
          localBounds,
          depth,
          parentElement
        }];
      }));
    action.call(thisObj);
    const afterElements = Array.from(outerElement.querySelectorAll(selector)),
      afterMap = new Map(afterElements.map(element => {
        const globalBounds = Rectangle.from(element, outerElement),
          localBounds = Rectangle.from(element, element.parentElement),
          style = globalThis.getComputedStyle(element.parentElement),
          borderLeftWidth = parseFloat(style.borderLeftWidth);
        if (borderLeftWidth) {
          globalBounds.left -= borderLeftWidth;
          localBounds.left -= borderLeftWidth;
        }
        return [element.id, {
          element,
          globalBounds,
          localBounds
        }];
      })),
      styleProps = ['position', 'top', 'left', 'width', 'height', 'padding', 'margin', 'zIndex', 'minWidth', 'minHeight', 'opacity', 'overflow'];
    // Convert to absolute layout, iterating elements remaining after action
    for (const [id, before] of beforeMap) {
      // We match before vs after on id and not actual element, allowing adding a new element with the same id to
      // transition from the old (which was removed or released). To match what will happen when DomSyncing with
      // multiple containing elements (columns in TaskBoard)
      const after = afterMap.get(id);
      if (after) {
        const {
            element
          } = after,
          {
            style,
            parentElement
          } = element,
          // Need to keep explicit zIndex to keep above other stuff
          zIndex = parseInt(DH.getStyleValue(element, 'zIndex')),
          {
            globalBounds,
            localBounds,
            depth,
            parentElement: beforeParent
          } = before,
          parentChanged = beforeParent !== parentElement;
        // Store initial state, in case element has a style prop we need to restore later
        ObjectHelper.copyProperties(element.$initial = {
          parentElement
        }, style, styleProps);
        // Prevent transition during the process, forced further down instead
        // element.remove();
        let bounds;
        // Action moved element to another parent, move it to the outer element to allow transitioning to the
        // new parent. Also use coordinates relative to that element
        if (parentChanged) {
          after.bounds = after.globalBounds;
          bounds = globalBounds;
          outerElement.appendChild(element);
        }
        // Keep element in current parent if it was not moved during the action call above.
        // Need to use coords relative to the parent
        else {
          after.bounds = after.localBounds;
          bounds = localBounds;
          beforeParent.appendChild(element);
        }
        let overflow = 'hidden'; // Looks weird with content sticking out if height is transitioned
        if (scrollers.has(element)) {
          element.$scrollPlaceholder = DH.createElement({
            parent: element,
            style: {
              height: element.scrollHeight
            }
          });
          overflow = 'auto';
        }
        const targetStyle = {
          position: 'absolute',
          top: `${bounds.top}px`,
          left: `${bounds.left}px`,
          width: `${bounds.width}px`,
          height: `${bounds.height}px`,
          minWidth: 0,
          minHeight: 0,
          margin: 0,
          zIndex: depth + (zIndex || 0),
          overflow
        };
        if (element.dataset.domTransition !== 'preserve-padding') {
          targetStyle.padding = 0;
        }
        // Move element back to where it started
        Object.assign(style, targetStyle);
        after.processed = true;
      }
      // Existed before but not after = removed
      else {
        const {
          element,
          localBounds: bounds,
          depth,
          parentElement
        } = before;
        element.$initial = {
          removed: true
        };
        Object.assign(element.style, {
          position: 'absolute',
          top: `${bounds.top}px`,
          left: `${bounds.left}px`,
          width: `${bounds.width}px`,
          height: `${bounds.height}px`,
          minWidth: 0,
          minHeight: 0,
          padding: 0,
          margin: 0,
          zIndex: depth,
          overflow: 'hidden' // Looks weird with content sticking out if height is transitioned
        });

        parentElement.appendChild(element);
        // Inject among non-removed elements to have it transition away
        afterMap.set(id, {
          element,
          bounds,
          removed: true,
          processed: true
        });
        afterElements.push(element);
      }
    }
    // Handle new elements
    for (const [, after] of afterMap) {
      if (!after.processed) {
        const {
            element
          } = after,
          {
            style,
            parentElement
          } = element,
          bounds = after.bounds = after.localBounds;
        element.classList.add('b-dom-transition-adding');
        ObjectHelper.copyProperties(element.$initial = {
          parentElement
        }, style, styleProps);
        // Props in `addTransition` will be transitioned
        Object.assign(style, {
          position: 'absolute',
          top: addTransition.top ? 0 : `${bounds.top}px`,
          left: addTransition.left ? 0 : `${bounds.left}px`,
          width: addTransition.width ? 0 : `${bounds.width}px`,
          height: addTransition.height ? 0 : `${bounds.height}px`,
          opacity: addTransition.opacity ? 0 : null,
          zIndex: parentElement.$depth + 1,
          overflow: 'hidden' // Looks weird with content sticking out if height is transitioned
        });
      }
    }
    // Restore scroll after modifying layout
    for (const element of scrollers) {
      element.scrollTop = element.$scrollTop;
    }
    // Enable transitions
    outerElement.classList.add('b-dom-transition');
    // Trigger layout, to be able to transition below
    outerElement.firstElementChild.offsetWidth;
    // Transition to new layout
    for (const [, {
      element,
      bounds: afterBounds,
      removed
    }] of afterMap) {
      if (removed) {
        Object.assign(element.style, {
          top: removeTransition.top ? 0 : `${afterBounds.top}px`,
          left: removeTransition.left ? 0 : `${afterBounds.left}px`,
          width: removeTransition.width ? 0 : `${afterBounds.width}px`,
          height: removeTransition.height ? 0 : `${afterBounds.height}px`,
          opacity: removeTransition.opacity ? 0 : element.$initial.opacity
        });
      } else {
        Object.assign(element.style, {
          top: `${afterBounds.top}px`,
          left: `${afterBounds.left}px`,
          width: `${afterBounds.width}px`,
          height: `${afterBounds.height}px`,
          opacity: element.$initial.opacity
        });
      }
    }
    // Wait for transition to finish
    await AsyncHelper.sleep(duration);
    outerElement.classList.remove('b-dom-transition');
    // Restore layout after transition
    for (const element of afterElements) {
      if (element.$initial) {
        if (element.$initial.removed) {
          element.remove();
        } else {
          ObjectHelper.copyProperties(element.style, element.$initial, styleProps);
          if (element.$scrollPlaceholder) {
            element.$scrollPlaceholder.remove();
            delete element.$scrollPlaceholder;
          }
          element.classList.remove('b-dom-transition-adding');
          element.$initial.parentElement.appendChild(element);
        }
      }
    }
    // Restore scroll positions last when all layout is restored
    for (const element of scrollers) {
      element.scrollTop = element.$scrollTop;
      delete element.$scrollTop;
    }
  }
  //endregion
  static async loadScript(url) {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = url;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }
  static isNamedColor(color) {
    return color && !/^(#|hsl|rgb|hwb)/.test(color);
  }
  //#region Salesforce hooks
  // Wrap NodeFilter to support salesforce
  static get NodeFilter() {
    return NodeFilter;
  }
  static addChild(parent, child, sibling) {
    parent.insertBefore(child, sibling);
  }
  static cloneStylesIntoShadowRoot(shadowRoot, removeExisting) {
    return new Promise((resolve, reject) => {
      if (removeExisting) {
        // Removes all style-tags or stylesheet link tags from shadowRoot
        shadowRoot.querySelectorAll('style, link[rel="stylesheet"]').forEach(el => el.remove());
      }
      // Clones all stylesheet link tags from document into shadowRoot and waits for them to load
      const links = document.querySelectorAll('link[rel="stylesheet"]');
      let loadCount = 0;
      links.forEach(node => {
        const clone = node.cloneNode();
        clone.addEventListener('load', () => {
          loadCount += 1;
          if (loadCount === links.length) {
            resolve();
          }
        });
        clone.addEventListener('error', e => {
          reject(clone.href);
        });
        shadowRoot.appendChild(clone);
      });
      // Clones all style tags from document into shadowRoot
      document.querySelectorAll('style').forEach(node => {
        shadowRoot.appendChild(node.cloneNode());
      });
    });
  }
  //#endregion
}

const DH = DomHelper;
let clearTouchTimer;
const clearTouchEvent = () => DH.isTouchEvent = false,
  setTouchEvent = () => {
    DH.isTouchEvent = true;
    // Jump round the click delay
    clearTimeout(clearTouchTimer);
    clearTouchTimer = setTimeout(clearTouchEvent, 400);
  };
// Set event type flags so that mousedown and click handlers can know whether a touch gesture was used.
// This is used. This must stay until we have a unified DOM event system which handles both touch and mouse events.
doc.addEventListener('touchstart', setTouchEvent, true);
doc.addEventListener('touchend', setTouchEvent, true);
DH.canonicalStyles = canonicalStyles;
DH.supportsTemplate = 'content' in doc.createElement('template');
DH.elementPropKey = elementPropKey;
DH.numberRe = numberRe;
//region Polyfills
if (!('children' in Node.prototype)) {
  const elementFilter = node => node.nodeType === node.ELEMENT_NODE;
  Object.defineProperty(Node.prototype, 'children', {
    get: function () {
      return Array.prototype.filter.call(this.childNodes, elementFilter);
    }
  });
}
if (!Element.prototype.matches) {
  Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function (s) {
    const matches = (this.document || this.ownerDocument).querySelectorAll(s);
    let i = matches.length;
    while (--i >= 0 && matches.item(i) !== this) {/* empty */}
    return i > -1;
  };
}
if (win.Element && !Element.prototype.closest) {
  Node.prototype.closest = Element.prototype.closest = function (s) {
    let el = this;
    if (!doc.documentElement.contains(el)) return null;
    do {
      if (el.matches(s)) return el;
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === el.ELEMENT_NODE);
    return null;
  };
} else {
  // It's crazy that closest is not already on the Node interface!
  // Note that some Node types (eg DocumentFragment) do not have a parentNode.
  Node.prototype.closest = function (selector) {
    var _this$parentNode;
    return (_this$parentNode = this.parentNode) === null || _this$parentNode === void 0 ? void 0 : _this$parentNode.closest(selector);
  };
}
// from MDN (public domain): https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/remove
(function (arr) {
  arr.forEach(function (item) {
    if (Object.prototype.hasOwnProperty.call(item, 'remove')) {
      return;
    }
    Object.defineProperty(item, 'remove', {
      configurable: true,
      enumerable: true,
      writable: true,
      value: function remove() {
        this.parentNode && this.parentNode.removeChild(this);
      }
    });
  });
})([Element.prototype, CharacterData.prototype, DocumentType.prototype]);
//endregion
// CTRL/+ and  CTRL/- zoom gestures must invalidate the scrollbar width.
// Window resize is triggered by this operation on Blink (Chrome & Edge), Firefox and Safari.
globalThis.addEventListener('resize', () => scrollBarWidth = null);
DomHelper._$name = 'DomHelper';

/**
 * @module Core/GlobalEvents
 */
const // Allow an unsteady finger to jiggle by this much
  longpressMoveThreshold = 5,
  isFloatingWidget = w => w.floating,
  longPressCancelEvents = {
    touchend: 1,
    pointerup: 1
  },
  ignoreModifierKeys = {
    Meta: 1,
    Control: 1,
    Alt: 1
  },
  GlobalEvents = new class GlobalEventsHandler extends Base.mixin(Events) {
    suspendFocusEvents() {
      focusEventsSuspended = true;
    }
    resumeFocusEvents() {
      focusEventsSuspended = false;
    }
    setupFocusListenersOnce(rootElement, EventHelper) {
      if (rootElement && !GlobalEvents.observedElements.has(rootElement)) {
        GlobalEvents.setupFocusListeners(rootElement, EventHelper);
        GlobalEvents.observedElements.add(rootElement);
      }
    }
    // This is imported by EventHelper and that makes the call to set up the listeners
    // `detach` argument is required to not setup more listeners than we need to. In case of salesforce we include floatroot
    // inside the webcomponent element and thus don't need default listeners on document. In regular webcomponents demo we
    // don't need to do it, because with multiple components on one page that would force us to make more complex lookups.
    setupFocusListeners(element = document, EventHelper, detach = false) {
      var _detacher;
      const listeners = {
        element,
        touchstart(touchstart) {
          if (!globaltouchStart && touchstart.changedTouches.length === 1) {
            globaltouchStart = touchstart.changedTouches[0];
            if (!BrowserHelper.isAndroid) {
              // On single touch start, set up a timer so that a longpress results in a
              // synthesized contextmenu event being injected into the target element.
              const
                // This is what gets called if the user moves their touchpoint,
                // or releases the touch before <longPressTime>ms is up
                onMoveOrPointerUp = ({
                  clientX,
                  clientY,
                  type
                }) => {
                  if (longPressCancelEvents[type] || Math.max(Math.abs(clientX - globaltouchStart.clientX), Math.abs(clientY - globaltouchStart.clientY)) > longpressMoveThreshold) {
                    contextMenuTouchId = null;
                    touchMoveRemover();
                    clearTimeout(tapholdTimer);
                  }
                },
                // Touchmove or touchend before that timer fires cancels the timer and removes these listeners.
                touchMoveRemover = EventHelper.on({
                  element: document,
                  touchmove: onMoveOrPointerUp,
                  touchend: onMoveOrPointerUp,
                  pointermove: onMoveOrPointerUp,
                  pointerup: onMoveOrPointerUp,
                  capture: true
                }),
                tapholdTimer = setTimeout(() => {
                  // The global touchend listener prevents a touchend from proceeding
                  // to a click if it was used to trigger contextmenu
                  contextMenuTouchId = globaltouchStart.identifier;
                  // Remove the gesture cancelling listeners
                  touchMoveRemover();
                  touchstart.target.dispatchEvent(new MouseEvent('contextmenu', EventHelper.copyEvent({}, touchstart)));
                }, EventHelper.longPressTime);
            }
          } else {
            globaltouchStart = null;
          }
        },
        // Just this one has to be passive: false so that we are allowed to preventDefault
        // if we are part of a contextmenu longpress emulation. Otherwise the gesture will
        // proceed to cause a mousedown event.
        touchend: {
          handler: event => {
            if (globaltouchStart) {
              // If the touchstart was used to synthesize a contextmenu event
              // stop the touch gesture processing right now.
              // Also prevent the conversion of the touch into click.
              if (event.changedTouches[0].identifier === contextMenuTouchId) {
                event.stopImmediatePropagation();
                if (event.cancelable !== false) {
                  event.preventDefault();
                }
              } else if (event.changedTouches.length === 1 && event.changedTouches[0].identifier === globaltouchStart.identifier) {
                GlobalEvents.trigger('globaltap', {
                  event
                });
              }
              globaltouchStart = null;
            }
          },
          passive: false
        },
        mousedown: {
          handler: event => {
            lastInteractionType = 'mouse';
            if (!globaltouchStart) {
              GlobalEvents.trigger('globaltap', {
                event
              });
            }
            currentMouseDown = event;
            // If no keydown is catched, and the mouse down has modifier key. Add a fake key event.
            const hasModifierKey = event.ctrlKey || event.altKey || event.shiftKey || event.metaKey;
            if (!currentKeyDown && hasModifierKey) {
              currentKeyDown = new KeyboardEvent('keydown', {
                key: event.ctrlKey ? 'Control' : event.shiftKey ? 'Shift' : event.altKey ? 'Alt' : 'Meta',
                ctrlKey: event.ctrlKey,
                altKey: event.altKey,
                shiftKey: event.shiftKey,
                metaKey: event.metaKey
              });
            } else if (currentKeyDown && !hasModifierKey) {
              currentKeyDown = null;
            }
          },
          passive: false
        },
        mouseup() {
          currentMouseDown = null;
        },
        pointerdown: {
          passive: false,
          handler: event => {
            var _element$classList;
            currentPointerDown = event;
            // Remove keyboard flag if last user action used pointer
            // Moved this from EventHelper, need to be once per root to support nested widgets
            DomHelper.usingKeyboard = false;
            (_element$classList = element.classList) === null || _element$classList === void 0 ? void 0 : _element$classList.remove('b-using-keyboard');
            // if shadow root, remove from children (shadow root itself lacks a classList :( )
            if (element.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
              DomHelper.removeClsGlobally(element, 'b-using-keyboard');
            }
          }
        },
        pointerup: {
          passive: false,
          handler: event => {
            var _currentPointerDown;
            if (((_currentPointerDown = currentPointerDown) === null || _currentPointerDown === void 0 ? void 0 : _currentPointerDown.pointerId) === event.pointerId) {
              currentPointerDown = null;
            }
          }
        },
        keydown(ev) {
          lastInteractionType = 'key';
          currentKeyDown = ev;
          // Flag root if last user action used keyboard, used for focus styling etc.
          // Moved this from EventHelper, need to be once per root to support nested widgets
          if (!ignoreModifierKeys[ev.key]) {
            DomHelper.usingKeyboard = true;
            // if shadow root, add to outer children (shadow root itself lacks a classList :( )
            if (element.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
              for (const node of element.children) {
                if (node.matches('.b-outer')) {
                  node.classList.add('b-using-keyboard');
                }
              }
            } else {
              element.classList.add('b-using-keyboard');
            }
          }
        },
        keypress() {
          lastInteractionType = 'key';
        },
        keyup() {
          currentKeyDown = null;
        },
        focusin(focusin) {
          var _focusin$target, _focusin$target2;
          const {
            Widget
          } = GlobalEvents;
          // Ignore if focus is going into a shadow root
          if ((_focusin$target = focusin.target) !== null && _focusin$target !== void 0 && _focusin$target.shadowRoot || (_focusin$target2 = focusin.target) !== null && _focusin$target2 !== void 0 && _focusin$target2._shadowRoot) {
            return;
          }
          Widget.resetFloatRootScroll();
          if (focusEventsSuspended) {
            return;
          }
          const fromElement = !focusin.relatedTarget ? null : focusin.relatedTarget instanceof HTMLElement ? focusin.relatedTarget : document.body,
            toElement = focusin.target || document.body,
            fromWidget = Widget.fromElement(fromElement),
            toWidget = Widget.fromElement(toElement),
            commonAncestor = DomHelper.getCommonAncestor(fromWidget, toWidget),
            // Flag if the fromElement is DOCUMENT_POSITION_FOLLOWING toElement
            backwards = !!(fromElement && toElement.compareDocumentPosition(fromElement) & 4),
            topVisibleModal = Widget.query(isTopVisibleModal);
          let currentFocus = null;
          if (toElement && toElement !== document.body) {
            currentFocus = DomHelper.getActiveElement(toElement);
          } else {
            currentFocus = DomHelper.getActiveElement(document);
          }
          // If there is a topmost modal that is not actively reverting focus, and the focus is moving to
          // somewhere *not* a descendant of that modal, and that somewhere is not in a floater that us
          // *above* that modal (the compareDocumentPosition call), then we enforce modality and sweep focus
          // back into the modal.
          // By default, the Container class will yield the first focusable descendant widget's focusEl as its
          // focusEl, so that will be out of the box behaviour for Popups.
          if (topVisibleModal && !topVisibleModal._isRevertingFocus) {
            if (!toWidget || !topVisibleModal.owns(toWidget) && !(topVisibleModal.element.compareDocumentPosition(toWidget.element) & 4 && toWidget.up(isFloatingWidget))) {
              return topVisibleModal.focus();
            }
          }
          let event = createWidgetEvent('focusout', fromElement, focusin.target, fromWidget, toWidget, backwards);
          // Bubble focusout event up the "from" side of the tree
          for (let target = fromWidget, owner; target && target !== commonAncestor; target = owner) {
            // Capture before any focus out handling is done. It may be manipulated.
            owner = target.owner;
            if (!target.isDestroying && target.onFocusOut) {
              target.onFocusOut(event);
              // It is possible for focusout handlers to refocus themselves (editor's invalidAction='block'), so
              // check if the focus is still where it was when we started unless we are in a document
              // loss of focus situation (no target)
              if (focusin.target && currentFocus !== DomHelper.getActiveElement(focusin.target)) {
                // If the focus has moved, that movement would have kicked off a nested sequence of focusin/out
                // notifications, so everyone has already been notified... no more to do here.
                return;
              }
            }
          }
          // Focus is moving upwards to the ancestor widget.
          // Its focus method might delegate focus to a focusable descendant.
          if (commonAncestor && focusin.target === commonAncestor.element) {
            // If one of the handlers above has not moved focus onwards
            // and the common ancestor is a container which delegates
            // focus inwards to a descendant, then give it the opportunity to do that.
            if (!commonAncestor.isDestroying && DomHelper.getActiveElement(commonAncestor) === toElement && commonAncestor.focusElement && commonAncestor.focusElement !== commonAncestor.element) {
              // If focus is not inside, move focus inside
              if (!commonAncestor.element.contains(currentFocus) || commonAncestor.focusDescendant) {
                // Wait until out of the focusin handler to move focus on.
                commonAncestor.setTimeout(() => {
                  var _commonAncestor$focus;
                  return (_commonAncestor$focus = commonAncestor.focus) === null || _commonAncestor$focus === void 0 ? void 0 : _commonAncestor$focus.call(commonAncestor);
                }, 0);
              }
            }
          }
          // Focus is moving between two branches of a subtree.
          // Bubble focusin event up the "to" side of the tree
          else {
            event = createWidgetEvent('focusin', toElement, fromElement, fromWidget, toWidget, backwards);
            for (let target = toWidget; target && target !== commonAncestor; target = target.owner) {
              if (!target.isDestroying) {
                var _target$onFocusIn, _target;
                (_target$onFocusIn = (_target = target).onFocusIn) === null || _target$onFocusIn === void 0 ? void 0 : _target$onFocusIn.call(_target, event);
              }
            }
          }
          // Fire element focusmove event. Grid navigation will use  this when cells are focusable.
          const commonAncestorEl = DomHelper.getCommonAncestor((fromElement === null || fromElement === void 0 ? void 0 : fromElement.nodeType) === Element.ELEMENT_NODE ? fromElement : null, toElement) || toElement.parentNode;
          // Common ancestor may be null is salesforce
          // https://github.com/bryntum/support/issues/4865
          if (commonAncestorEl) {
            event = createWidgetEvent('focusmove', toElement, fromElement, fromWidget, toWidget, backwards, {
              bubbles: true
            });
            commonAncestorEl.dispatchEvent(event);
          }
        },
        focusout(focusout) {
          if (focusEventsSuspended) {
            return;
          }
          if (!focusout.relatedTarget || !GlobalEvents.Widget.fromElement(focusout.relatedTarget)) {
            // When switching between tabs in Salesforce app `relatedTarget` of the focusout event might be not an instance of
            // HTMLElement.
            const target = focusout.relatedTarget && focusout.relatedTarget instanceof HTMLElement ? focusout.relatedTarget : null;
            listeners.focusin({
              target,
              relatedTarget: focusout.target
            });
            currentKeyDown = currentMouseDown = null;
          }
        },
        // This will clear keydown and mousedown status on window blur
        blur: {
          element: globalThis,
          handler(event) {
            if (event.target === globalThis) {
              currentKeyDown = null;
              currentMouseDown = null;
            }
          }
        },
        capture: true,
        passive: true
      };
      // detach previous listeners
      detach && ((_detacher = detacher) === null || _detacher === void 0 ? void 0 : _detacher());
      detacher = this.detachEvents = EventHelper.on(listeners);
    }
    get lastInteractionType() {
      return lastInteractionType;
    }
    get shiftKeyDown() {
      var _currentKeyDown;
      return (_currentKeyDown = currentKeyDown) === null || _currentKeyDown === void 0 ? void 0 : _currentKeyDown.shiftKey;
    }
    get ctrlKeyDown() {
      var _currentKeyDown2, _currentKeyDown3;
      return ((_currentKeyDown2 = currentKeyDown) === null || _currentKeyDown2 === void 0 ? void 0 : _currentKeyDown2.ctrlKey) || ((_currentKeyDown3 = currentKeyDown) === null || _currentKeyDown3 === void 0 ? void 0 : _currentKeyDown3.metaKey);
    }
    get altKeyDown() {
      var _currentKeyDown4;
      return (_currentKeyDown4 = currentKeyDown) === null || _currentKeyDown4 === void 0 ? void 0 : _currentKeyDown4.altKey;
    }
    isKeyDown(key) {
      var _currentKeyDown5;
      return !key ? Boolean(currentKeyDown) : ((_currentKeyDown5 = currentKeyDown) === null || _currentKeyDown5 === void 0 ? void 0 : _currentKeyDown5.key) === key || currentKeyDown[(key === null || key === void 0 ? void 0 : key.toLowerCase()) + 'Key'] === true;
    }
    isMouseDown(button = 0) {
      var _currentMouseDown;
      return ((_currentMouseDown = currentMouseDown) === null || _currentMouseDown === void 0 ? void 0 : _currentMouseDown.button) === button;
    }
    get currentMouseDown() {
      return currentMouseDown;
    }
    get currentPointerDown() {
      return currentPointerDown;
    }
    get currentTouch() {
      return globaltouchStart;
    }
    get currentKeyDown() {
      return currentKeyDown;
    }
  }(),
  isTopVisibleModal = w => w.isVisible && w.isTopModal;
GlobalEvents.observedElements = new Set();
/**
 * Fired after the theme is changed
 * @event theme
 * @param {Core.GlobalEvents} source
 * @param {String} theme The new theme name
 */
let globaltouchStart,
  contextMenuTouchId,
  focusEventsSuspended = false,
  lastInteractionType,
  currentKeyDown,
  currentMouseDown,
  currentPointerDown,
  detacher;
function createWidgetEvent(eventName, target, relatedTarget, fromWidget, toWidget, backwards, options) {
  const result = new CustomEvent(eventName, options);
  // Workaround for Salesforce. They use strict mode and define non-configurable property `target`. We use this
  // CustomEvent as a synthetic one, feels fine to use non-standard handle for target.
  Object.defineProperty(result, '_target', {
    get() {
      return target;
    }
  });
  Object.defineProperty(result, 'relatedTarget', {
    get() {
      return relatedTarget;
    }
  });
  result.fromWidget = fromWidget;
  result.toWidget = toWidget;
  result.backwards = backwards;
  return result;
}

/**
 * @module Core/mixin/InstancePlugin
 */
function getDescriptor(me, fnName) {
  const property = ObjectHelper.getPropertyDescriptor(me, fnName); //Object.getOwnPropertyDescriptor(Object.getPrototypeOf(me), fnName);
  return property && (property.get || property.set) ? property : null;
}
/**
 * Base class for plugins. Published functions will be available from the other class. `this` in published functions is
 * referenced to the plugin, access the other class using `this.client`.
 *
 * Observe that plugin doesn't apply itself on class level but instead on instance level. Plugin is its own instance
 * that can have own functions and data that is not exposed to target class.
 *
 * Functions can be published in four ways:
 *
 * * `assign` (when function is not already available on target)
 * * `before` (when function is already available on target, will be called before original function)
 * * `after` (when function is already available on target, will be called after original function)
 * * `override` (replaces function on target, but old function can be reached)
 *
 * To configure which functions get published and in what way, specify `pluginConfig` getter on plugin:
 *
 * ```javascript
 * class Sort extends InstancePlugin {
 *   static get pluginConfig {
 *      return {
 *          before   : ['init'],
 *          after    : ['destroy', 'onElementClick'],
 *          override : ['render']
 *      };
 *   }
 * }
 * ```
 *
 * @extends Core/Base
 * @mixes Core/localization/Localizable
 * @mixes Core/mixin/Events
 * @plugin
 */
class InstancePlugin extends Base.mixin(Events, Localizable) {
  static $name = 'InstancePlugin';
  //region Config
  static get configurable() {
    return {
      clientListeners: null,
      /**
       * The plugin/feature `disabled` state.
       *
       * For a feature that is **off** by default that you want to enable later during runtime,
       * configure it with `disabled : true`.
       * ```javascript
       * const grid = new Grid({
       *      features : {
       *          featureName : {
       *              disabled : true // on and disabled, can be enabled later
       *          }
       *      }
       * });
       *
       * // enable the feature
       * grid.features.featureName.disabled = false;
       * ```
       *
       * If the feature is **off** by default, and you want to include and enable the feature, configure it as `true`:
       * ```javascript
       * const grid = new Grid({
       *      features : {
       *          featureName : true // on and enabled, can be disabled later
       *      }
       * });
       *
       * // disable the feature
       * grid.features.featureName.disabled = true;
       * ```
       *
       * If the feature is **on** by default, but you want to turn it **off**, configure it as `false`:
       * ```javascript
       * const grid = new Grid({
       *      features : {
       *          featureName : false // turned off, not included at all
       *      }
       * });
       * ```
       *
       * If the feature is **enabled** by default and you have no need of reconfiguring it,
       * you can omit the feature configuration.
       *
       * @prp {Boolean}
       * @default
       * @category Common
       */
      disabled: false,
      /**
       * The Widget which was passed into the constructor,
       * which is the Widget we are providing extra services for.
       * @member {Core.widget.Widget} client
       * @readonly
       * @category Misc
       * @advanced
       */
      /**
       * The widget which this plugin is to attach to.
       * @config {Core.widget.Widget}
       * @category Misc
       * @advanced
       */
      client: null,
      /**
       * @hideconfigs bubbleEvents, callOnFunctions
       */
      /**
       * @hidefunctions downloadTestCase, destroy
       */
      /**
       * @hideproperties isDestroyed
       */
      /**
       * @hideevents destroy, beforeDestroy
       */
      // The plugins can define their own keyMap which will then be merged with their client's keyMap.
      keyMap: null
    };
  }
  //endregion
  updateClient(client) {
    // So that this.callback can reach the owning Widget when resolving function names.
    if (!this.owner) {
      this.owner = client;
    }
  }
  /**
   * This will merge a feature's (subclass of InstancePlugin) keyMap with it's client's keyMap.
   * @private
   */
  updateKeyMap(keyMap) {
    const {
      client
    } = this;
    client.keyMap = client.mergeKeyMaps(client.keyMap, keyMap, StringHelper.uncapitalize(this.constructor.$name));
  }
  //region Init
  /**
   * Call from another instance to add plugins to it.
   * @example
   * InstancePlugin.initPlugins(this, Search, Stripe);
   * @param plugInto Instance to mix into (usually this)
   * @param plugins Classes to plug in
   * @internal
   */
  static initPlugins(plugInto, ...plugins) {
    const property = plugInto.plugins || (plugInto.plugins = {});
    for (const PluginClass of plugins) {
      property[PluginClass.$$name] = new PluginClass(plugInto);
    }
  }
  /**
   * Simple wrapper for {@link #property-disabled} to make optional chaining simple:
   *
   * ```javascript
   * grid.features.myFeature?.enabled // returns true when feature exists and is enabled
   * ```
   * @returns {Boolean}
   * @internal
   */
  get enabled() {
    return !this.disabled;
  }
  // We can act as an owner of a widget, so must be able to participate in focus reversion
  getFocusRevertTarget() {
    var _this$client;
    return (_this$client = this.client) === null || _this$client === void 0 ? void 0 : _this$client.getFocusRevertTarget();
  }
  construct(...args) {
    const me = this;
    let [plugInto, config] = args,
      listeners;
    // When called with one argument (a config object), grab the "client" from the config object.
    if (args.length === 1) {
      if (ObjectHelper.isObject(plugInto)) {
        config = plugInto;
        plugInto = config.client;
      }
    }
    // Two args, so client is the first. Ensure the config doesn't contain a client property.
    else {
      config = ObjectHelper.assign({}, config);
      delete config.client;
    }
    me.client = plugInto;
    super.construct(config);
    me.applyPluginConfig(plugInto);
    listeners = me.clientListeners;
    if (listeners) {
      listeners = ObjectHelper.assign({}, listeners);
      listeners.thisObj = me;
      // NOTE: If clientListeners are ever made public, we need to separate internal clientListeners from app ones
      plugInto.ion(listeners);
    }
  }
  /**
   * Applies config as found in plugInto.pluginConfig, or published all if no config found.
   * @private
   * @param plugInto Target instance to plug into
   */
  applyPluginConfig(plugInto) {
    const me = this,
      config = me.pluginConfig || me.constructor.pluginConfig;
    if (config) {
      const {
        assign,
        chain,
        after,
        before,
        override
      } = config;
      assign && me.applyAssign(plugInto, assign);
      (chain || after) && me.applyChain(plugInto, chain || after);
      before && me.applyChain(plugInto, before, false);
      override && me.applyOverride(plugInto, override);
    }
  }
  /**
   * Applies assigning for specified functions.
   * @private
   * @param plugInto
   * @param fnNames
   */
  applyAssign(plugInto, fnNames) {
    fnNames.forEach(fnName => this.assign(plugInto, fnName));
  }
  /**
   * Applies chaining for specified functions.
   * @private
   * @param plugInto
   * @param functions
   * @param after
   */
  applyChain(plugInto, functions, after = true) {
    if (Array.isArray(functions)) {
      for (const fnName of functions) {
        this.chain(plugInto, fnName, fnName, after);
      }
    } else {
      for (const intoName in functions) {
        this.chain(plugInto, intoName, functions[intoName], after);
      }
    }
  }
  /**
   * Applies override for specified functions.
   * @private
   * @param plugInto
   * @param fnNames
   */
  applyOverride(plugInto, fnNames) {
    const me = this;
    if (!me.overridden) {
      me.overridden = {};
    }
    fnNames.forEach(fnName => {
      if (!me[fnName]) {
        throw new Error(`Trying to chain fn ${plugInto.$$name}#${fnName}, but plugin fn ${me.$$name}#${fnName} does not exist`);
      }
      // override
      if (typeof plugInto[fnName] === 'function') {
        me.overridden[fnName] = plugInto[fnName].bind(plugInto);
      }
      plugInto[fnName] = me[fnName].bind(me);
    });
  }
  /**
   * Assigns specified functions.
   * @private
   * @param plugInto
   * @param fnName
   */
  assign(plugInto, fnName) {
    const me = this,
      property = getDescriptor(me, fnName);
    if (property) {
      // getter/setter, define corresponding property on target
      Object.defineProperty(plugInto, fnName, {
        configurable: true,
        enumerable: true,
        get: property.get && property.get.bind(me),
        set: property.set && property.set.bind(me)
      });
    } else {
      plugInto[fnName] = me[fnName].bind(me);
    }
  }
  //endregion
  //region Chaining
  /**
   * Chains functions. When the function is called on the target class all functions in the chain will be called in
   * the order they where added.
   * @private
   * @param plugInto
   * @param intoName
   * @param hookName
   * @param after
   */
  chain(plugInto, intoName, hookName, after = true) {
    // default hook prio
    let prio = 0;
    if (typeof intoName === 'object') {
      intoName = intoName.fn;
    }
    // if hook is provided as an object
    if (typeof hookName === 'object') {
      // hook prio to order runs
      prio = hookName.prio || 0;
      hookName = hookName.fn;
    }
    const me = this,
      chains = plugInto.pluginFunctionChain || (plugInto.pluginFunctionChain = {}),
      hookFn = me[hookName] && me[hookName].bind(me),
      // Grab the fn so that we won't need our this pointer to call it. This is due
      // to this instance possibly being destroyed by the time a chain call is made.
      functionChainRunner = me.functionChainRunner;
    if (!hookFn) {
      throw new Error(`Trying to chain fn ${plugInto.$$name}#${hookName}, but plugin fn ${me.$$name}#${hookName} does not exist`);
    }
    if (!chains[intoName]) {
      let intoFn = plugInto[intoName];
      if (intoFn) {
        intoFn = intoFn.bind(plugInto);
        intoFn.$this = plugInto;
        // use default prio
        intoFn.$prio = 0;
      }
      chains[intoName] = intoFn ? [intoFn] : [];
      plugInto[intoName] = (...params) => functionChainRunner(chains[intoName], params);
    }
    hookFn.$this = me;
    hookFn.$prio = prio;
    chains[intoName][after ? 'push' : 'unshift'](hookFn);
    chains[intoName].$sorted = false;
  }
  /**
   * Used to run multiple plugged in functions with the same name, see chain above. Returning false from a
   * function will abort chain.
   * @private
   * @param {Array} chain
   * @param {Array} params
   * @returns {*} value returned from last function in chain (or false if any returns false)
   */
  functionChainRunner(chain, params) {
    // NOTE: even though we are an instance method, we must not use our "this" pointer
    // since our instance may be destroyed. We cope with that by receiving parameters
    // for everything we need (so we're just a pure function).
    let fn, i, returnValue;
    // sort hooks by prio before running them
    if (!chain.$sorted) {
      chain.sort((a, b) => b.$prio - a.$prio);
      chain.$sorted = true;
    }
    for (i = 0; i < chain.length; i++) {
      fn = chain[i];
      // Feature hooks remain in place even after GridBase loops and destroys its
      // features, so skip over any destroyed features on the chain. In particular,
      // bindStore hooks will be called when GridBase sets store to null.
      if (!fn.$this.isDestroyed) {
        returnValue = fn(...params);
        if (returnValue === false) {
          break;
        }
      }
    }
    return returnValue;
  }
  //endregion
  /**
   * Called when disabling/enabling the plugin/feature, not intended to be called directly. To enable or disable a
   * plugin/feature, see {@link #property-disabled}.
   *
   * By default removes the cls of the plugin from its client. Override in subclasses to take any other actions necessary.
   * @category Misc
   * @advanced
   */
  doDisable(disable) {
    const me = this,
      {
        constructor
      } = me,
      cls = 'featureClass' in constructor ? constructor.featureClass : `b-${constructor.$$name.toLowerCase()}`,
      key = StringHelper.uncapitalize(constructor.$$name);
    // Some features do not use a cls
    if (cls) {
      var _me$client, _me$client$_element;
      // _element to not flush composable
      (_me$client = me.client) === null || _me$client === void 0 ? void 0 : (_me$client$_element = _me$client._element) === null || _me$client$_element === void 0 ? void 0 : _me$client$_element.classList[disable ? 'remove' : 'add'](cls);
    }
    if (!me.isConfiguring) {
      var _me$client$syncSplits, _me$client2;
      if (disable) {
        /**
         * Fired when the plugin/feature is disabled.
         * @event disable
         * @param {Core.mixin.InstancePlugin} source
         */
        me.trigger('disable');
      } else {
        /**
         * Fired when the plugin/feature is enabled.
         * @event enable
         * @param {Core.mixin.InstancePlugin} source
         */
        me.trigger('enable');
      }
      // Enable/disable in other splits, if any
      (_me$client$syncSplits = (_me$client2 = me.client).syncSplits) === null || _me$client$syncSplits === void 0 ? void 0 : _me$client$syncSplits.call(_me$client2, other => {
        // Might be a plugin that is not a feature (there is no Feature baseclass in Grid)
        const otherFeature = other.features[key];
        if (otherFeature) {
          otherFeature.disabled = disable;
        }
      });
    }
  }
  updateDisabled(disabled) {
    this.doDisable(disabled);
  }
  throwOverrideIsMissing(data) {
    throw new Error(`Trying to override fn ${data.plugIntoName}#${data.fnName}, but plugin fn ${data.pluginName}#${data.fnName} does not exist`);
  }
  // Convenience method to read the rootElement from the owner widget
  get rootElement() {
    return this.client.rootElement;
  }
}
InstancePlugin._$name = 'InstancePlugin';

/**
 * @module Core/mixin/Pluggable
 */
/**
 * Enables using plugins for a class by specifying property plugins as an array of plugin classes. If only a single plugin
 * is used, just give the plugin class instead of an array. This class isn't required for using plugins, just makes it
 * easier. Without mixin you can otherwise use `InstancePlugin.initPlugins(this, PluginClass)`.
 *
 * @example
 * new Store({
 *   plugins: [PluginClass, ...]
 * });
 *
 * @mixin
 */
var Pluggable = (Target => class Pluggable extends (Target || Base) {
  static get $name() {
    return 'Pluggable';
  }
  /**
   * Specify plugins (an array of classes) in config
   * @config {Function[]} plugins
   * @category Misc
   * @advanced
   */
  /**
   * Map of applied plugins
   * @property {Object<String,Core.mixin.InstancePlugin>}
   * @readonly
   * @category Misc
   * @advanced
   */
  get plugins() {
    if (!this._plugins) {
      this._plugins = {};
    }
    return this._plugins;
  }
  set plugins(plugins) {
    if (plugins) {
      if (!Array.isArray(plugins)) plugins = [plugins];
      InstancePlugin.initPlugins(this, ...plugins);
    }
    this.initPlugins();
  }
  /**
   * Template method which may be implemented in subclasses to initialize any plugins.
   * This method is empty in the `Pluggable` base class.
   * @internal
   */
  initPlugins() {}
  /**
   * Adds plugins to an instance.
   * @param {Function[]} plugins The plugins to add
   * @category Misc
   * @advanced
   */
  addPlugins(...plugins) {
    InstancePlugin.initPlugins(this, ...plugins);
  }
  /**
   * Checks if instance has plugin.
   * @param {String|Function} pluginClassOrName Plugin or name to check for
   * @returns {Boolean}
   * @category Misc
   * @advanced
   */
  hasPlugin(pluginClassOrName) {
    return this.getPlugin(pluginClassOrName) != null;
  }
  /**
   * Get a plugin instance.
   * @param {String|Function} pluginClassOrName
   * @returns {Core.mixin.InstancePlugin}
   * @category Misc
   * @advanced
   */
  getPlugin(pluginClassOrName) {
    var _this$plugins;
    if (typeof pluginClassOrName === 'function') {
      pluginClassOrName = pluginClassOrName.$$name;
    }
    return (_this$plugins = this.plugins) === null || _this$plugins === void 0 ? void 0 : _this$plugins[pluginClassOrName];
  }
  // This does not need a className on Widgets.
  // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
  // to the Widget it's mixed in to should implement thus.
  get widgetClass() {}
});

const {
  defineProperty: defineProperty$4
} = Reflect;
let performance$1;
if (BrowserHelper.isBrowserEnv) {
  performance$1 = globalThis.performance;
} else {
  performance$1 = {
    now() {
      return new Date().getTime();
    }
  };
}
/**
 * @module Core/mixin/Delayable
 */
// Global timeout collections for tests
let globalDelays = null;
if (VersionHelper.isTestEnv) {
  const bryntum = globalThis.bryntum || (globalThis.bryntum = {});
  globalDelays = bryntum.globalDelays = {
    timeouts: new Map(),
    intervals: new Map(),
    animationFrames: new Map(),
    idleCallbacks: new Map(),
    isEmpty(includeIntervals = false) {
      return globalDelays.timeouts.size + globalDelays.animationFrames.size + globalDelays.idleCallbacks.size + (includeIntervals ? globalDelays.intervals.size : 0) === 0;
    },
    /**
     * Returns filtered delays array
     * @param {Object} options
     * @param {String[]} [options.ignoreTimeouts] array of delays names to ignore
     * @param {Number} [options.maxDelay] maximum delay in milliseconds. Timeouts with bigger delay will be filtered out
     * @param {Boolean} [options.includeIntervals] include intervals
     * @returns {Object[]} array of filtered delays
     * @internal
     */
    getFiltered({
      ignoreTimeouts = [],
      maxDelay = 5000,
      includeIntervals = false
    }) {
      const result = [],
        scopes = ['timeouts', 'animationFrames', 'idleCallbacks'];
      if (includeIntervals) {
        scopes.push('intervals');
      }
      // Filter delays
      for (const scope of scopes) {
        const map = globalDelays[scope];
        for (const [, entry] of map.entries()) {
          if (!ignoreTimeouts.includes(entry.name) && (!Number.isInteger(entry.delay) || entry.delay < maxDelay)) {
            result.push(entry);
          }
        }
      }
      return result;
    }
  };
}
const
  /**
   * Creates and returns a function that will call the user-supplied `fn`.
   *
   * @param {Core.mixin.Delayable} me
   * @param {Function} fn The user function to call when the timer fires.
   * @param {Function} wrapFn The function the user will call to start the timer.
   * @param {Object} options The invoke options.
   * @param {Array} [options.appendArgs] The argument list to append to those passed to the function.
   * @param {Object} [options.thisObj] The `this` reference for `fn`.
   * @returns {Function}
   * @private
   */
  makeInvoker = (me, fn, wrapFn, options) => {
    const named = typeof fn === 'string',
      appendArgs = (options === null || options === void 0 ? void 0 : options.appendArgs) || [],
      // The invoker fn is intended to be wired directly to native setTimeout/requestAnimationFrame/etc. and so
      // it does not receive any arguments worth passing on to the user's fn. Those come from the original call
      // to the wrapFn.
      invoker = () => {
        wrapFn.timerId = null;
        wrapFn.lastCallTime = performance$1.now();
        // Grab args now and null the stored args out (to avoid leaks):
        const args = wrapFn.args;
        wrapFn.args = null;
        if (named) {
          me[fn](...args, ...appendArgs);
        } else {
          fn.call(me, ...args, ...appendArgs);
        }
        wrapFn.called = true;
        ++wrapFn.calls;
      };
    if (options) {
      me = options.thisObj || me;
    }
    // We put most everything as properties on the wrapFn so that it can all be inspected in the debugger (unlike
    // closure variables) and expected in tests.
    wrapFn.lastCallTime = -9e9; // performance.now() = 0 at start...
    wrapFn.calls = 0;
    wrapFn.invoker = invoker;
    invoker.wrapFn = wrapFn;
    return invoker;
  },
  /**
   * Decorates the supported `wrapFn` with additional methods and an `isPending` readonly
   * property. These decorations are available to user code to help manage the scheduling
   * behavior of the buffered function.
   *
   * @param {Core.mixin.Delayable} me
   * @param {Function} wrapFn The function the user will call to start the timer.
   * @param {String} cancelFn The name of the function that will cancel a timer.
   * @returns {Function} The `wrapFn` is returned.
   * @private
   */
  decorateWrapFn = (me, wrapFn, cancelFn = 'clearTimeout') => {
    wrapFn.cancel = () => {
      if (wrapFn.isPending) {
        me[cancelFn](wrapFn.timerId);
        // avoid leaks and cleanup:
        wrapFn.args = wrapFn.timerId = null;
      }
    };
    wrapFn.flush = () => {
      if (wrapFn.isPending) {
        me[cancelFn](wrapFn.timerId);
        wrapFn.timerId = null;
        // we don't call cancel() since it also sets args=null
        wrapFn.invoker();
      }
    };
    wrapFn.now = (...args) => {
      wrapFn.cancel();
      wrapFn.args = args;
      wrapFn.invoker();
    };
    wrapFn.resume = all => {
      const n = wrapFn.suspended;
      wrapFn.suspended = all || n < 1 ? 0 : n - 1;
    };
    wrapFn.suspend = () => {
      ++wrapFn.suspended;
    };
    wrapFn.immediate = false;
    wrapFn.suspended = 0;
    wrapFn.timerId = null;
    defineProperty$4(wrapFn, 'isPending', {
      get() {
        return wrapFn.timerId !== null;
      }
    });
    return wrapFn;
  };
/**
 * Configuration options available when defining a delayable function.
 *
 * @typedef {Object} DelayableConfig
 * @property {'buffer'|'raf'|'idle'|'throttle'} type Type of delay to use. `raf` is short for `requestAnimationFrame`,
 * 'idle' for `requestIdleCallback` (not supported in Safari)
 * @property {Number} [delay] Number of milliseconds to wait before (buffer) or after (throttle) calling the underlying
 * method. A value of 0 is equivalent to setting `immediate: true`.
 * @property {Boolean} [immediate] Set to `true` to call immediately (effectively disabling the buffer/throttle)
 * @property {Boolean} [cancelOutstanding] Set to `true` to cancel any pending animation frame requests and
 * schedule a new one on each call.
 */
/**
 * Tracks setTimeout, setInterval and requestAnimationFrame calls and clears them on destroy.
 *
 * @example
 * someClass.setTimeout(() => console.log('hi'), 200);
 * someClass.setInterval(() => console.log('annoy'), 100);
 * // can also use named timeouts for easier tracking
 * someClass.setTimeout(() => console.log('named'), 300, 'named');
 * someClass.clearTimeout('named');
 *
 * @mixin
 */
var Delayable = (Target => class Delayable extends (Target || Base) {
  static get $name() {
    return 'Delayable';
  }
  static get declarable() {
    return [
    /**
     * This class property returns an object that specifies methods to wrap with configurable timer behaviors.
     *
     * It is used like so:
     * ```javascript
     *  class Foo extends Base.mixin(Delayable) {
     *      static get delayable() {
     *          return {
     *              expensiveMethod : 500
     *          };
     *      }
     *
     *      expensiveMethod() {
     *          this.things();
     *          this.moreThings();
     *          this.evenMoreThings();
     *      }
     *  }
     * ```
     * With the above in place, consider:
     * ```javascript
     *  let instance = new Foo();
     *
     *  instance.expensiveMethod();
     * ```
     * Instead of the above code immediately calling the `expensiveMethod()`, it will start a timer that will
     * invoke the method 500ms later. Because `expensiveMethod()` is an instance method, each instance of `Foo`
     * will have its own timer.
     *
     * NOTE: Only instance methods are currently supported (i.e., only non-`static` methods).
     *
     * #### Options
     * The value of each key configures how the method will be scheduled. If the value is a number, it is
     * promoted to a config object of `type='buffer'` as in the following:
     * ```javascript
     *  class Foo extends Base.mixin(Delayable) {
     *      static get delayable() {
     *          return {
     *              expensiveMethod : {
     *                  type  : 'buffer',
     *                  delay : 500
     *              }
     *          };
     *      }
     *  }
     * ```
     * The `type` property of the config object must be one of three values. Other options can be provided
     * depending on the `type`:
     *
     *  - `buffer`<br>
     *    Other options:
     *     - `delay` (Number) : The number of milliseconds to wait before calling the underlying method. A
     *       value of 0 is equivalent to setting `immediate: true`.
     *     - `immediate` (Boolean) : Set to `true` to call immediately (effectively disabling the buffer).
     *  - `raf` (short for "request animation frame")<br>
     *  - `idle` (short for "request idle callback") __Not available on Safari__ <br>
     *    Other options:
     *     - `cancelOutstanding` (Boolean) : Set to `true` to cancel any pending animation frame requests and
     *       schedule a new one on each call.
     *     - `immediate` (Boolean) : Set to `true` to call immediately.
     *  - `throttle`<br>
     *    Other options:
     *     - `delay` (Number) : The number of milliseconds to wait after each execution before another
     *       execution takes place. A value of 0 is equivalent to setting `immediate: true`.
     *     - `immediate` (Boolean) : Set to `true` to call immediately (effectively disabling the throttle).
     *
     * While `immediate: true` can be specified at the class level, it is more typical to set it on the
     * instance's method as described below.
     *
     * #### Delayable Method API
     * Delayable methods have a consistent API to manage their scheduling. This API is added to the methods
     * themselves.
     *
     * For example:
     * ```javascript
     *  let instance = new Foo();
     *
     *  instance.expensiveMethod();         // schedule a call in 500ms
     *  instance.expensiveMethod.isPending; // true
     *  instance.expensiveMethod.cancel();
     *  instance.expensiveMethod.flush();
     *  instance.expensiveMethod.now();
     *
     *  instance.expensiveMethod.delay = 10;
     *  instance.expensiveMethod();         // schedule a call in 10ms
     * ```
     *
     * ##### `isPending` (Boolean, readonly)
     * This boolean property will be `true` if a call has been scheduled, and false otherwise.
     *
     * ##### `cancel()`
     * Cancels a pending call if one has been scheduled. Otherwise this method does nothing.
     *
     * ##### `flush()`
     * Cancels the timer and causes the pending call to execute immediately. If there is no pending call, this
     * method does nothing.
     *
     * ##### `now()`
     * Cancels the timer (if one is pending) and executes the method immediately. If there is no pending call,
     * this method will still call the underlying method.
     *
     * @static
     * @member {Object<String,'raf'|Number|DelayableConfig>} delayable
     * @internal
     */
    'delayable'];
  }
  doDestroy() {
    const me = this;
    // Normally one would expect this call at the end of this method... but in this case we need to run cleanup
    // of this stuff after config nullification since those can trigger delayable method calls.
    super.doDestroy();
    if (me.timeoutIds) {
      me.timeoutIds.forEach((fn, id) => {
        var _globalDelays;
        if (typeof fn === 'function') {
          fn();
        }
        clearTimeout(id);
        (_globalDelays = globalDelays) === null || _globalDelays === void 0 ? void 0 : _globalDelays.timeouts.delete(id);
      });
      me.timeoutIds = null;
    }
    if (me.timeoutMap) {
      me.timeoutMap.forEach((name, id) => clearTimeout(id));
      me.timeoutMap = null;
    }
    if (me.intervalIds) {
      me.intervalIds.forEach(id => {
        var _globalDelays2;
        clearInterval(id);
        (_globalDelays2 = globalDelays) === null || _globalDelays2 === void 0 ? void 0 : _globalDelays2.intervals.delete(id);
      });
      me.intervalIds = null;
    }
    if (me.animationFrameIds) {
      me.animationFrameIds.forEach(id => {
        var _globalDelays3;
        cancelAnimationFrame(id);
        (_globalDelays3 = globalDelays) === null || _globalDelays3 === void 0 ? void 0 : _globalDelays3.animationFrames.delete(id);
      });
      me.animationFrameIds = null;
    }
    if (me.idleCallbackIds) {
      me.idleCallbackIds.forEach(id => {
        var _globalDelays4;
        cancelIdleCallback(id);
        (_globalDelays4 = globalDelays) === null || _globalDelays4 === void 0 ? void 0 : _globalDelays4.idleCallbacks.delete(id);
      });
      me.idleCallbackIds = null;
    }
  }
  /**
   * Check if a named timeout is active
   * @param name
   * @internal
   */
  hasTimeout(name) {
    var _this$timeoutMap;
    return Boolean((_this$timeoutMap = this.timeoutMap) === null || _this$timeoutMap === void 0 ? void 0 : _this$timeoutMap.has(name));
  }
  /**
   * Same as native setTimeout, but will be cleared automatically on destroy. If a propertyName is supplied it will
   * be used to store the timeout id.
   * @param {Object} timeoutSpec An object containing the details about that function, and the time delay.
   * @param {Function|String} timeoutSpec.fn The function to call, or name of function in this object to call. Used as the `name` parameter if a string.
   * @param {Number} timeoutSpec.delay The milliseconds to delay the call by.
   * @param {Object[]} timeoutSpec.args The arguments to pass.
   * @param {String} [timeoutSpec.name] The name under which to register the timer. Defaults to `fn.name`.
   * @param {Boolean} [timeoutSpec.runOnDestroy] Pass `true` if this function should be executed if the Delayable instance is destroyed while function is scheduled.
   * @param {Boolean} [timeoutSpec.cancelOutstanding] Pass `true` to cancel any outstanding invocation of the passed function.
   * @returns {Number}
   * @internal
   */
  setTimeout({
    fn,
    delay,
    name,
    runOnDestroy,
    cancelOutstanding,
    args
  }) {
    var _globalDelays6;
    if (arguments.length > 1 || typeof arguments[0] === 'function') {
      [fn, delay, name, runOnDestroy] = arguments;
    }
    if (typeof fn === 'string') {
      name = fn;
    } else if (!name) {
      name = fn.name || fn;
    }
    if (cancelOutstanding) {
      this.clearTimeout(name);
    }
    const me = this,
      timeoutIds = me.timeoutIds || (me.timeoutIds = new Map()),
      timeoutMap = me.timeoutMap || (me.timeoutMap = new Map()),
      timeoutId = setTimeout(() => {
        var _globalDelays5;
        if (typeof fn === 'string') {
          fn = me[name];
        }
        // Cleanup before invocation in case fn throws
        timeoutIds === null || timeoutIds === void 0 ? void 0 : timeoutIds.delete(timeoutId);
        timeoutMap === null || timeoutMap === void 0 ? void 0 : timeoutMap.delete(name);
        (_globalDelays5 = globalDelays) === null || _globalDelays5 === void 0 ? void 0 : _globalDelays5.timeouts.delete(timeoutId);
        fn.apply(me, args);
      }, delay);
    timeoutIds.set(timeoutId, runOnDestroy ? fn : true);
    // Commented out code is helpful when debugging timeouts in tests
    (_globalDelays6 = globalDelays) === null || _globalDelays6 === void 0 ? void 0 : _globalDelays6.timeouts.set(timeoutId, {
      fn,
      delay,
      name /*, stack : new Error().stack*/
    });
    if (name) {
      timeoutMap.set(name, timeoutId);
    }
    return timeoutId;
  }
  /**
   * clearTimeout wrapper, either call with timeout id as normal clearTimeout or with timeout name (if you specified
   * a name to setTimeout())
   * property to null.
   * @param {Number|String} idOrName timeout id or name
   * @internal
   */
  clearTimeout(idOrName) {
    var _this$timeoutIds, _globalDelays7;
    let id = idOrName;
    if (typeof id === 'string') {
      if (this.timeoutMap) {
        id = this.timeoutMap.get(idOrName);
        this.timeoutMap.delete(idOrName);
      } else {
        return;
      }
    }
    clearTimeout(id);
    (_this$timeoutIds = this.timeoutIds) === null || _this$timeoutIds === void 0 ? void 0 : _this$timeoutIds.delete(id);
    (_globalDelays7 = globalDelays) === null || _globalDelays7 === void 0 ? void 0 : _globalDelays7.timeouts.delete(id);
  }
  /**
   * clearInterval wrapper
   * @param {Number} id
   * @internal
   */
  clearInterval(id) {
    var _this$intervalIds, _globalDelays8;
    clearInterval(id);
    (_this$intervalIds = this.intervalIds) === null || _this$intervalIds === void 0 ? void 0 : _this$intervalIds.delete(id);
    (_globalDelays8 = globalDelays) === null || _globalDelays8 === void 0 ? void 0 : _globalDelays8.intervals.delete(id);
  }
  /**
   * Same as native setInterval, but will be cleared automatically on destroy
   * @param {Function} fn callback method
   * @param {Number} delay delay in milliseconds
   * @param {String} name delay name for debugging
   * @returns {Number}
   * @internal
   */
  setInterval(fn, delay, name) {
    var _globalDelays9;
    const intervalId = setInterval(fn, delay);
    (this.intervalIds || (this.intervalIds = new Set())).add(intervalId);
    (_globalDelays9 = globalDelays) === null || _globalDelays9 === void 0 ? void 0 : _globalDelays9.intervals.set(intervalId, {
      fn,
      delay,
      name
    });
    return intervalId;
  }
  /**
   * Relays to native requestAnimationFrame and adds to tracking to have call automatically canceled on destroy.
   * @param {Function} fn
   * @param {Object[]} [extraArgs] The argument list to append to those passed to the function.
   * @param {Object} [thisObj] `this` reference for the function.
   * @returns {Number}
   * @internal
   */
  requestAnimationFrame(fn, extraArgs = [], thisObj = this) {
    var _globalDelays11;
    const animationFrameIds = this.animationFrameIds || (this.animationFrameIds = new Set()),
      frameId = requestAnimationFrame(() => {
        var _globalDelays10;
        (_globalDelays10 = globalDelays) === null || _globalDelays10 === void 0 ? void 0 : _globalDelays10.animationFrames.delete(frameId);
        // [dongriffin 2022-01-19] It was observed that we can still be called even though we issued the
        // cancelAnimationFrame call. Since delete() returns true if our frameId was present and is now
        // removed, we can tell that we haven't been cancelled before we call our fn:
        animationFrameIds.delete(frameId) && fn.apply(thisObj, extraArgs);
      });
    animationFrameIds.add(frameId);
    (_globalDelays11 = globalDelays) === null || _globalDelays11 === void 0 ? void 0 : _globalDelays11.animationFrames.set(frameId, {
      fn,
      extraArgs,
      thisObj
    });
    return frameId;
  }
  /**
   * Relays to native requestIdleCallback and adds to tracking to have call automatically canceled on destroy.
   * @param {Function} fn
   * @param {Object[]} [extraArgs] The argument list to append to those passed to the function.
   * @param {Object} [thisObj] `this` reference for the function.
   * @returns {Number}
   * @internal
   */
  requestIdleCallback(fn, extraArgs = [], thisObj = this) {
    var _globalDelays13;
    const idleCallbackIds = this.idleCallbackIds || (this.idleCallbackIds = new Set()),
      frameId = requestIdleCallback(() => {
        var _globalDelays12;
        (_globalDelays12 = globalDelays) === null || _globalDelays12 === void 0 ? void 0 : _globalDelays12.idleCallbacks.delete(frameId);
        // Since delete() returns true if our frameId was present and is now
        // removed, we can tell that we haven't been cancelled before we call our fn:
        idleCallbackIds.delete(frameId) && fn.apply(thisObj, extraArgs);
      });
    idleCallbackIds.add(frameId);
    (_globalDelays13 = globalDelays) === null || _globalDelays13 === void 0 ? void 0 : _globalDelays13.idleCallbacks.set(frameId, {
      fn,
      extraArgs,
      thisObj
    });
    return frameId;
  }
  /**
   * Creates a function which will execute once, on the next animation frame. However many time it is
   * called in one event run, it will only be scheduled to run once.
   * @param {Function|String} fn The function to call, or name of function in this object to call.
   * @param {Object[]} [args] The argument list to append to those passed to the function.
   * @param {Object} [thisObj] `this` reference for the function.
   * @param {Boolean} [cancelOutstanding] Cancel any outstanding queued invocation upon call.
   * @internal
   */
  createOnFrame(fn, args = [], thisObj = this, cancelOutstanding) {
    let rafId;
    const result = (...callArgs) => {
      // Cancel if outstanding if requested
      if (rafId != null && cancelOutstanding) {
        this.cancelAnimationFrame(rafId);
        rafId = null;
      }
      if (rafId == null) {
        rafId = this.requestAnimationFrame(() => {
          if (typeof fn === 'string') {
            fn = thisObj[fn];
          }
          rafId = null;
          callArgs.push(...args);
          fn.apply(thisObj, callArgs);
        });
      }
    };
    result.cancel = () => this.cancelAnimationFrame(rafId);
    return result;
  }
  /**
   * Relays to native cancelAnimationFrame and removes from tracking.
   * @param {Number} handle
   * @internal
   */
  cancelAnimationFrame(handle) {
    var _this$animationFrameI, _globalDelays14;
    cancelAnimationFrame(handle);
    (_this$animationFrameI = this.animationFrameIds) === null || _this$animationFrameI === void 0 ? void 0 : _this$animationFrameI.delete(handle);
    (_globalDelays14 = globalDelays) === null || _globalDelays14 === void 0 ? void 0 : _globalDelays14.animationFrames.delete(handle);
  }
  /**
   * Relays to native cancelIdleCallback and removes from tracking.
   * @param {Number} handle
   * @internal
   */
  cancelIdleCallback(handle) {
    var _this$idleCallbackIds, _globalDelays15;
    cancelIdleCallback(handle);
    (_this$idleCallbackIds = this.idleCallbackIds) === null || _this$idleCallbackIds === void 0 ? void 0 : _this$idleCallbackIds.delete(handle);
    (_globalDelays15 = globalDelays) === null || _globalDelays15 === void 0 ? void 0 : _globalDelays15.idleCallbacks.delete(handle);
  }
  async nextAnimationFrame() {
    return new Promise(resolve => this.requestAnimationFrame(resolve));
  }
  /**
   * Wraps a function with another function that delays it specified amount of time, repeated calls to the wrapper
   * resets delay.
   * @param {Function|String} fn The function to call. If this is a string, it is looked up as a method on `this`
   * instance (or `options.thisObj` instead, if provided).
   * @param {Object|Number} options The delay in milliseconds or an options object.
   * @param {Number} options.delay The delay in milliseconds.
   * @param {Array} [options.appendArgs] The argument list to append to those passed to the function.
   * @param {Object} [options.thisObj] The `this` reference for the function.
   * @returns {Function} Wrapped function to call.
   * @internal
   */
  buffer(fn, options) {
    let delay = options;
    if (options && typeof options !== 'number') {
      // if (config object)
      delay = options.delay;
    } else {
      options = null;
    }
    const bufferWrapFn = (...params) => {
        if (bufferWrapFn.suspended) {
          return;
        }
        const {
          delay
        } = bufferWrapFn;
        bufferWrapFn.cancel();
        bufferWrapFn.called = false;
        bufferWrapFn.args = params;
        // If delay=0, the buffer has been disabled so always call immediately.
        if (bufferWrapFn.immediate || !delay) {
          invoker();
        } else {
          bufferWrapFn.timerId = this.setTimeout(invoker, delay);
        }
      },
      invoker = makeInvoker(this, fn, bufferWrapFn, options);
    bufferWrapFn.delay = delay;
    return decorateWrapFn(this, bufferWrapFn);
  }
  /**
   * Returns a function that when called will schedule a call to `fn` on the next animation frame.
   *
   * @param {Function|String} fn The function to call. If this is a string, it is looked up as a method on `this`
   * instance (or `options.thisObj` instead, if provided).
   * @param {Boolean|Object} [options] An options object or the `cancelOutstanding` boolean property of it.
   * @param {Boolean} [options.cancelOutstanding] Pass `true` to cancel any pending animation frame requests and
   * schedule a new one on each call to the returned function.
   * @param {Array} [options.appendArgs] The argument list to append to those passed to the function.
   * @param {Object} [options.thisObj] The `this` reference for the function.
   * @returns {Function}
   * @internal
   */
  raf(fn, options) {
    // NOTE: This method is only intended for use with `delayable`. It has a signature that is compatible
    // with `buffer()` and `throttle()`. The name is 'raf' to make the following aesthetically pleasing:
    //
    //  class Foo extends Delayable() {
    //      static get delayable() {
    //          return {
    //              bar : 'raf'
    //          };
    //      }
    //  }
    let cancelOutstanding = options;
    if (options && typeof options !== 'boolean') {
      // if (config object)
      cancelOutstanding = options.cancelOutstanding;
    } else {
      options = null;
    }
    const rafWrapFn = (...params) => {
        if (rafWrapFn.suspended) {
          return;
        }
        // Reschedule the frame on each call if requested
        if (rafWrapFn.cancelOutstanding) {
          rafWrapFn.cancel();
        }
        rafWrapFn.called = false;
        rafWrapFn.args = params;
        if (rafWrapFn.immediate) {
          invoker();
        } else if (!rafWrapFn.isPending) {
          rafWrapFn.timerId = this.requestAnimationFrame(invoker);
        }
      },
      invoker = makeInvoker(this, fn, rafWrapFn, options);
    rafWrapFn.cancelOutstanding = cancelOutstanding;
    return decorateWrapFn(this, rafWrapFn, 'cancelAnimationFrame');
  }
  idle(fn, options) {
    let cancelOutstanding = options;
    if (options && typeof options !== 'boolean') {
      // if (config object)
      cancelOutstanding = options.cancelOutstanding;
    } else {
      options = null;
    }
    const idleWrapFn = (...params) => {
        if (idleWrapFn.suspended) {
          return;
        }
        // Reschedule the frame on each call if requested
        if (idleWrapFn.cancelOutstanding) {
          idleWrapFn.cancel();
        }
        idleWrapFn.called = false;
        idleWrapFn.args = params;
        if (idleWrapFn.immediate) {
          invoker();
        } else if (!idleWrapFn.isPending) {
          idleWrapFn.timerId = this.requestIdleCallback(invoker);
        }
      },
      invoker = makeInvoker(this, fn, idleWrapFn, options);
    idleWrapFn.cancelOutstanding = cancelOutstanding;
    // If the timer is still there in 100ms, then invoke it.
    this.setTimeout(() => this.idleCallbackIds.delete(idleWrapFn.timerId) && idleWrapFn.now(), 100);
    return decorateWrapFn(this, idleWrapFn, 'cancelIdleCallback');
  }
  /**
   * Create a "debounced" function which will call on the "leading edge" of a timer period.
   * When first invoked will call immediately, but invocations after that inside its buffer
   * period will be rejected, and *one* invocation will be made after the buffer period has expired.
   *
   * This is useful for responding immediately to a first mousemove, but from then on, only
   * calling the action function on a regular timer while the mouse continues to move.
   *
   * @param {Function|String} fn The function to call. If this is a string, it is looked up as a method on `this`
   * instance (or `options.thisObj` instead, if provided).
   * @param {Number|Object} options The milliseconds to wait after each execution before another execution takes place
   * or a object containing options.
   * @param {Object} [options.thisObj] `this` reference for the function.
   * @param {Array} [options.appendArgs] The argument list to append to those passed to the function.
   * @param {Function|String} [options.throttled] A function to call when the invocation is delayed due to buffer
   * time not having expired. If this is a string, it is looked up as a method on `this` instance (or `options.thisObj`
   * instead, if provided). When called, the same arguments are passed as would have been passed to `fn`, including
   * any `options.appendArgs`.
   * @internal
   */
  throttle(fn, options) {
    let delay = options,
      throttled;
    if (options && typeof options !== 'number') {
      // if (config object)
      delay = options.delay;
      throttled = options.throttled;
    } else {
      options = null;
    }
    const me = this,
      throttleWrapFn = (...args) => {
        if (throttleWrapFn.suspended) {
          return;
        }
        const {
            delay
          } = throttleWrapFn,
          elapsed = performance$1.now() - throttleWrapFn.lastCallTime;
        throttleWrapFn.args = args;
        // If it's been more then the delay period since we invoked, we can call it now.
        // Setting delay=0 effectively disables the throttle (which is the goal)
        if (throttleWrapFn.immediate || elapsed >= delay) {
          me.clearTimeout(throttleWrapFn.timerId);
          invoker();
        } else {
          // Kick off a timer for the requested period.
          if (!throttleWrapFn.isPending) {
            throttleWrapFn.timerId = me.setTimeout(invoker, delay - elapsed);
            throttleWrapFn.called = false;
          }
          if (throttled) {
            // Args have to be stored on the wrapFn for the invoker to pick them up:
            throttled.wrapFn.args = args;
            throttled();
          }
        }
      },
      invoker = makeInvoker(me, fn, throttleWrapFn, options);
    throttleWrapFn.delay = delay;
    if (throttled) {
      // Make an invoker for this callback to handle thisObj and typeof=string etc (pass a dud wrapFn):
      throttled = makeInvoker(me, throttled, () => {}, options);
    }
    return decorateWrapFn(me, throttleWrapFn);
  }
  static setupDelayable(cls) {
    cls.setupDelayableMethods(cls.delayable);
  }
  /**
   * This method initializes the `delayable` methods on this class.
   * @param {Object} delayable The `delayable` property.
   * @param {Function} [cls] This parameter will be used internally to process static methods.
   * @private
   */
  static setupDelayableMethods(delayable, cls = null) {
    const me = this,
      statics = delayable.static,
      target = cls || me.prototype;
    if (statics) {
      delete delayable.static;
    }
    for (const name in delayable) {
      let options = delayable[name];
      const implName = name + 'Now',
        type = typeof options;
      if (!target[implName]) {
        // Only move foo() -> fooNow() if a base class hasn't done so already
        target[implName] = target[name];
      }
      if (type === 'number') {
        options = {
          type: 'buffer',
          delay: options
        };
      } else if (type === 'string') {
        options = {
          type: options
        };
      }
      // For instance methods, we place a getter on the prototype. When the method is first accessed from the
      // prototype, we create an instance-specific version by calling this.buffer()/throttle() (based on the type
      // desired) and set that as the instance-level property.
      defineProperty$4(target, name, {
        get() {
          const value = this[options.type]((...params) => {
            this[implName](...params);
          }, options);
          defineProperty$4(this, name, {
            value
          });
          return value;
        }
      });
    }
  }
  // This does not need a className on Widgets.
  // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
  // to the Widget it's mixed in to should implement thus.
  get widgetClass() {}
});

/**
 * @module Core/state/StateStorage
 */
/**
 * Base class representing interface used by the {@link Core.state.StateProvider} to actually store the state data.
 * This class is not intended to be used directly.
 *
 * This class has an interface similar to the [Storage API](https://developer.mozilla.org/en-US/docs/Web/API/Storage).
 */
class StateStorage {
  /**
   * Returns an object with all stored keys and their values as its properties
   * @member {Object}
   */
  get data() {
    return Object.create(null);
  }
  /**
   * Returns the stored keys as set by {@link #function-setItem}
   * @member {String[]}
   */
  get keys() {
    return [];
  }
  /**
   * Remove all stored keys
   */
  clear() {}
  /**
   * Returns key value as set by {@link #function-setItem}
   * @param {String} key
   * @returns {*}
   */
  getItem(key) {
    return null;
  }
  /**
   * Removes the specified key
   * @param {String} key
   */
  removeItem(key) {}
  /**
   * Sets the specified key to the given value
   * @param {String} key
   * @param {*} value The item value
   */
  setItem(key, value) {}
}
StateStorage._$name = 'StateStorage';

/**
 * @module Core/state/StateProvider
 */
class Local extends StateStorage {
  constructor(stateProvider) {
    super();
    this.prefix = stateProvider.prefix || '';
  }
  get isLocal() {
    return true;
  }
  get data() {
    const data = empty(),
      keys = this.keys;
    for (const key of keys) {
      data[key] = this.getItem(key);
    }
    return data;
  }
  get keys() {
    return getKeys(this.prefix, this.prefix.length);
  }
  clear() {
    // It's important that we only clear our own StateProvider's keys, not all of localStorage. We get the
    // full keys not the suffixes since we're just going to call removeItem() with them...
    const keys = getKeys(this.prefix);
    for (const key of keys) {
      localStorage.removeItem(key);
    }
  }
  getItem(key) {
    const value = localStorage.getItem(this.prefix + key);
    // We handle the JSON translation at this layer because the Memory storage does not do any such pickling
    // of data but localStorage only handles strings
    return value === null ? value : JSON.parse(value);
  }
  removeItem(key) {
    return localStorage.removeItem(this.prefix + key);
  }
  setItem(key, value) {
    return localStorage.setItem(this.prefix + key, JSON.stringify(value));
  }
}
class Memory extends StateStorage {
  constructor() {
    super();
    this.clear();
  }
  get isMemory() {
    return true;
  }
  get data() {
    return ObjectHelper.clone(this._data);
  }
  get keys() {
    return Object.keys(this._data);
  }
  clear() {
    this._data = empty();
  }
  getItem(key) {
    return key in this._data ? this._data[key] : null;
  }
  removeItem(key) {
    delete this._data[key];
  }
  setItem(key, value) {
    this._data[key] = value;
  }
}
const empty = () => Object.create(null),
  getKeys = (prefix, pos = 0) => {
    const keys = [],
      count = localStorage.length;
    for (let key, i = 0; i < count; ++i) {
      key = localStorage.key(i);
      key.startsWith(prefix) && keys.push(key.slice(pos));
    }
    return keys;
  },
  nullStorage = new StateStorage(),
  storageTypes = {
    local: Local,
    memory: Memory
  };
/**
 * Instances of this class are used to manage data storage for objects that use the {@link Core.mixin.State} mixin, i.e.
 * stateful components. When such components change their {@link Core.mixin.State#config-stateful} properties, they
 * notify the associated {@link Core.mixin.State#config-stateProvider}, which will save the changes after a short
 * delay (to allow multiple changes to coalesce into a single save operation).
 *
 * There are two (2) built-in types of storage supported by `StateProvider`:
 *
 *  - `local` : Stores data in the browser's `localStorage`. Because of this, all `StateProvider` instances share their
 *    state data if they have the same {@link #config-prefix}.
 *  - `memory` : Stores data in the provider's memory. Each instance has its own storage. This is typically used when
 *    the state data is saved to a backend server.
 *
 * ## Using `local` Storage
 *
 * The global `StateProvider` is typically to use `localStorage` for the page or application like so:
 *
 * ```javascript
 *  StateProvider.setup('local');
 * ```
 *
 * With this provider in place, all {@link Core.mixin.State stateful components} will save their
 * {@link Core.mixin.State#property-state} to this provider by default.
 *
 * This is the most typical, and recommended, strategy for proving data to stateful components. This approach allows
 * various widgets on the page to simply declare their {@link Core.mixin.State#config-stateId} to participate in the
 * saving and restoring of application state.
 *
 * Because this storage type uses `localStorage`, the `StateProvider` applies a string prefix to isolate its data from
 * other users of `localStorage`. The default prefix is `'bryntum-state:'`, but this can be configured to a different
 * value. This could be desired, for example, to isolate state data from multiple pages or for version changes.
 *
 * ```javascript
 *  StateProvider.setup({
 *      storage : 'local',
 *      prefix  : 'myApp-v1:'
 *  });
 * ```
 *
 * ## Using `memory` Storage
 *
 * In some applications it may be desirable to save state to a server and restore it on other devices for the user.
 * Because state data is consumed synchronously, and server I/O is asynchronous, the `StateProvider` can be configured
 * to use `'memory'` storage and the actual state data can be loaded/saved by the application.
 *
 * Two factors are important to consider before deciding to save application state on the server (beyond the async
 * adaptation):
 *
 * - State properties are often more of a reflection of the user's device than they are application preferences
 *   and, therefore, may not apply well on other devices.
 * - Potentially undesired application state will not be cleared by clearing local browser user data (a common
 *   troubleshooting strategy) and will follow the user to other browsers (another common troubleshooting technique).
 *
 * The use this type of storage, the global `StateProvider` is configured like so:
 *
 * ```javascript
 * StateProvider.setup('memory');
 * ```
 *
 * In this scenario, application code would download the user's state and use {@link #property-data} to populate
 * the {@link #property-instance-static StateProvider.instance}. In this case, the {@link #event-save} event is used
 * to save the data back to the server when it changes.
 *
 * See [state](https://bryntum.com/products/grid/examples/state/) demo for a usage example.
 * @mixes Core/mixin/Events
 */
class StateProvider extends Base.mixin(Delayable, Events) {
  static get $name() {
    return 'StateProvider';
  }
  static get configurable() {
    return {
      /**
       * The key prefix applied when using the `'local'` {@link #config-storage} type.
       * @config {String}
       * @default
       */
      prefix: 'bryntum-state:',
      /**
       * Storage instance
       * @member {Core.state.StateStorage} storage
       */
      /**
       * One of the following storage types:
       *  - `local` : Stores data in the browser's `localStorage` using the {@link #config-prefix}.
       *  - `memory` : Stores data in the provider's memory.
       *
       * @config {'local'|'memory'|Core.state.StateStorage}
       * @default
       */
      storage: 'local'
    };
  }
  static get delayable() {
    /*
        The StateProvider uses a delayed write to save stateful components in batches. To illustrate, consider the
        "collapsed" config for a Panel that has been marked as "stateful":
            App                         Stateful                      State
            Code                        Component                    Provider
              :                             :                           :
              | .collapsed=true             :                           :
              |---------------------------->|                           :
              |         onConfigChange() +--|                           :
              |                          |  |                           :
              |                          +->|                           :
              |              saveState() +--|                           :
              |                          |  |                           :
              |                          +->| saveStateful()            :
              |                             |-------------------------->|
              |                             |                           | pendingSaves.push()
              |                             |                           |----+ writeStatefuls()
              | .collapsed=true             |<..........................:    :
              |<............................:                           :    :  (maybe other changes)
              :                             :                           :    :
              :                             :                           |<---+ (50 ms later)
              :                             :                           | writeStatefuls()
              :                             :       saveState({         |
              :                             :         immediate:true})  | <---------------+
              :                             |<--------------------------|                  \
              :                             | setValue()                |                   \
              :                             |-------------------------->|                    \
              :                             |                           | .trigger('set')     ) one or more of these
              :                             |<..........................|                    /
              :                             |              saveState()  |                   /
              :                             :..........................>|                  /
              :                             :                           | <---------------+
              :                             :                           |
              :                             :                           | .trigger('save')
              :                             :                           |
              :                             :                           :....> writeStatefuls()
              :                             :                           :
    */
    return {
      writeStatefuls: 50
    };
  }
  /**
   * The default {@link Core.mixin.State#config-stateProvider} for stateful objects.
   * @property {Core.state.StateProvider}
   */
  static get instance() {
    return this._instance;
  }
  static set instance(inst) {
    if (inst == null) {
      inst = nullProvider;
    } else {
      if (typeof inst === 'string' || ObjectHelper.isClass(inst) || inst instanceof StateStorage) {
        inst = {
          storage: inst
        };
      }
      if (ObjectHelper.isObject(inst)) {
        inst = new StateProvider(inst);
      }
    }
    this._instance = inst;
  }
  /**
   * Initializes the default `StateProvider` instance for the page. This method can be passed an instance or one of
   * the following type aliases:
   *
   *  - `'local'` : use `localStorage` to store application state (most common)
   *  - `'memory'` : holds application state in the `StateProvider` instance (used when state is saved to a server)
   *
   * Once the `StateProvider` is initialized, components that use {@link Core.mixin.State} and assign components a
   * {@link Core.mixin.State#config-stateId} will use this default provider to automatically save and restore their
   * state.
   *
   * @param {'local'|'memory'|Core.state.StateProvider} inst The state provider storage type ('local' or 'memory') or
   * the `StateProvider` instance.
   * @returns {Core.state.StateProvider}
   */
  static setup(inst) {
    this.instance = inst; // use smart setter
    return this.instance;
  }
  doDestroy() {
    self.writeStatefuls.flush();
    super.doDestroy();
  }
  /**
   * On read, this property returns all state data stored in the provider. On write, this property _adds_ all the
   * given values to the state provider's data. To replace the data, call {@link #function-clear} before assigning
   * this property. This is used to bulk populate this `StateProvider` with data for stateful components.
   * @member {Object}
   */
  get data() {
    return this.storage.data;
  }
  set data(data) {
    if (!data) {
      this.clear();
    } else {
      for (const key in data) {
        this.setValue(key, data[key]);
      }
    }
  }
  /**
   * Clears all state date
   * @returns {Core.state.StateProvider} this instance
   */
  clear() {
    this.storage.clear();
    return this;
  }
  changeStorage(storage) {
    if (storage == null) {
      storage = nullStorage;
    } else {
      if (typeof storage === 'string') {
        if (!storageTypes[storage]) {
          throw new Error(`Invalid storage type "${storage}" (expected one of: "${Object.keys(storageTypes).join('", "')}")`);
        }
        storage = storageTypes[storage];
      }
      if (ObjectHelper.isClass(storage)) {
        storage = new storage(this);
      }
    }
    return storage;
  }
  /**
   * This method is called to schedule saving the given `stateful` object.
   * @param {Core.mixin.State} stateful The stateful object to save.
   * @param {Object} [options] An object of options that affect the state saving process.
   * @param {String} [options.id] The key for the saved state.
   * @param {Boolean} [options.immediate] Pass `true` to save the data synchronously instead of on a delay.
   * @internal
   */
  saveStateful(stateful, options) {
    (this.pendingSaves || (this.pendingSaves = [])).push([stateful, options]);
    this.writeStatefuls();
  }
  /**
   * A delayable method that flushes pending stateful objects.
   * @private
   */
  writeStatefuls() {
    const me = this,
      {
        pendingSaves
      } = me,
      n = pendingSaves === null || pendingSaves === void 0 ? void 0 : pendingSaves.length,
      stateIds = [],
      saved = [];
    me.pendingSaves = null;
    if (n) {
      for (let options, stateful, stateId, i = 0; i < n; ++i) {
        [stateful, options] = pendingSaves[i];
        if (!stateful.isDestroying && stateful.isSaveStatePending) {
          stateId = stateful.saveState({
            ...options,
            immediate: true
          });
          if (stateId) {
            stateIds.push(stateId);
            saved.push(stateful);
          }
        }
      }
      if (stateIds.length) {
        /**
         * Triggered after one or more stateful objects save their state to the state provider. This event can
         * be used to save state to a backend server.
         *
         * For example, to save the page's state object as a single object on the server:
         *
         * ```javascript
         *  StateProvider.instance.on({
         *      save() {
         *          const data = StateProvider.instance.data;
         *          // Save "data" to server
         *      }
         *  });
         * ```
         *
         * Or, to save individual stateful components to the server:
         *
         * ```javascript
         *  StateProvider.instance.on({
         *      save({ stateIds }) {
         *          for (const stateId of stateIds) {
         *              const data = StateProvider.instance.getValue(stateId);
         *
         *              if (data == null) {
         *                  // Remove "stateId" from the server
         *              }
         *              else {
         *                  // Save new "data" for "stateId" to the server
         *              }
         *          }
         *      }
         *  });
         * ```
         *
         * Multi-page applications should probably include a page identifier in addition to the `stateId` to
         * prevent state from one page affecting other pages. If there are common components across all (or
         * many) pages, the `stateId` values would need to be assigned with all pages in mind.
         *
         * @event save
         * @param {Core.state.StateProvider} source The source of the event
         * @param {String[]} stateIds An array of `stateId` values that were saved to the state provider.
         * @param {Core.mixin.State[]} saved An array of stateful objects saved just saved to state provider
         * storage, in the same order as the `stateIds` array.
         */
        me.trigger('save', {
          stateIds,
          saved
        });
      }
    }
  }
  /**
   * Returns the stored state given its `key`.
   * @param {String} key The identifier of the state to return.
   * @returns {Object}
   */
  getValue(key) {
    this.writeStatefuls.flush();
    return this.storage.getItem(key);
  }
  /**
   * Stores the given state `value` under the specified `key`.
   * @param {String} key The identifier of the state value.
   * @param {Object} value The state value to set.
   * @returns {Core.state.StateProvider} this instance
   */
  setValue(key, value) {
    const me = this,
      {
        storage
      } = me,
      was = me.getValue(key);
    if (value != null) {
      storage.setItem(key, value);
      /**
       * Triggered after an item is stored to the state provider.
       * @event set
       * @param {Core.state.StateProvider} source The source of the event
       * @param {String} key The name of the stored item.
       * @param {*} value The value of the stored item.
       * @param {*} was The previous value of the stored item.
       */
      me.trigger('set', {
        key,
        value,
        was
      });
    } else if (was !== null) {
      storage.removeItem(key);
      /**
       * Triggered after an item is removed from the state provider.
       * @event remove
       * @param {Core.state.StateProvider} source The source of the event
       * @param {String} key The name of the removed item.
       * @param {*} was The value of the removed item.
       */
      me.trigger('remove', {
        key,
        was
      });
    }
    return me;
  }
}
const nullProvider = new StateProvider({
  storage: nullStorage
});
StateProvider._instance = nullProvider;
StateProvider._$name = 'StateProvider';

//import Config from '../Config.js';
/**
 * @module Core/mixin/State
 */
const primitiveRe = /boolean|number|string/;
/**
 * A mixin that handles accessing, saving, and restoring an object's persistent state.
 *
 * ## Using Stateful Components
 *
 * Instances of classes that use this mixin (i.e., "stateful components") have a {@link #property-state} property that
 * provides read/write access to their persistable state in the form of a simple object. These state objects can be
 * saved and restored under application control, e.g., using `localStorage`.
 *
 * This approach can be streamlined using a {@link Core.state.StateProvider} either by setting the
 * {@link Core.state.StateProvider#property-instance-static default state provider} or by using an instance-level
 * {@link #config-stateProvider} config.
 *
 * When using a state provider, stateful components with a {@link #config-stateId} or an
 * {@link Core.widget.Widget#config-id} will automatically save (see {@link #function-saveState}) and restore
 * (see {@link #function-loadState}) their `state`. This use of the `id` as a `stateId` can be disabled by assigning
 * the {@link #config-stateful} config to `false`. When using a `stateId` and a state provider, it is not necessary to
 * call the {@link #function-loadState} and {@link #function-saveState} methods directly.
 *
 * ### Simple vs Complex State
 *
 * Some stateful components (e.g., {@link Core.widget.Panel panels}) have state that can be described purely by their
 * config properties. For these components, the {@link #config-stateful} config can be used to control which config
 * properties to include in their persistent state. For example:
 *
 * ```javascript
 *  const mainPanel = new Panel({
 *      collapsible : true,
 *      stateId     : 'mainPanel',
 *      stateful    : ['collapsed']
 *  });
 * ```
 *
 * Other components have a complex state (e.g., `GridState`), and do not use the `stateful` config in this way. In all
 * other ways, however, these components behave the same as their simple state counterparts.
 *
 * ## Implementing Stateful Components
 *
 * Implementors of stateful components have two main design points to consider:
 *
 *  - Getting and setting their persistent {@link #property-state} object.
 *  - Initiating calls to {@link #function-saveState} when the object's persistent state changes.
 *
 * ### Persistent State
 *
 * For simple cases, the {@link #config-stateful} config can be set to the list of config property names that should be
 * saved:
 *
 * ```javascript
 *  class MyStatefulComponent extends Base.mixin(State) {
 *      static get configurable() {
 *          return {
 *              stateful : ['text', 'size']
 *          };
 *      }
 *  }
 * ```
 *
 * While the `stateful` config supports an object form (where keys with truthy values are the config names), this form
 * is typically reserved for configuring instances.
 *
 * Classes can choose to implement the {@link #function-getState} and {@link #function-applyState} methods to enhance
 * the `state` object with data not easily mapped to config properties. These method can call their `super` methods or
 * fully replace them.
 *
 * ```javascript
 *  class MyStatefulComponent extends Base.mixin(State) {
 *      getState() {
 *          return {
 *              text : this.text,
 *              size : this.size
 *          };
 *      }
 *
 *      applyState(state) {
 *          this.text = state.text;
 *          this.size = state.size;
 *      }
 *  }
 * ```
 *
 * ### Saving Dates
 *
 * A stateful property may be a `Date` property if the `changeDate` method of the class accepts an
 * ISO 8601 formatted date. Dates are saved in state using ISO 8601 format: `YYYY-MM-DDTHH:mm:ssZ`
 *
 * ### Saving State
 *
 * When the persistent state of a stateful component changes, it must call {@link #function-saveState}. This method
 * schedules an update of the component's persistence {@link #property-state} with the appropriate
 * {@link #config-stateProvider}. When a config property named in the {@link #config-stateful} config changes, this
 * call will be made automatically. This means that even if a component replaces {@link #function-getState} and
 * {@link #function-applyState}, it can still be helpful to specify a value for the `stateful` config.
 *
 * ```javascript
 *  class MyStatefulComponent extends Base.mixin(State) {
 *      static get configurable() {
 *          return {
 *              stateful : ['text', 'size']
 *          };
 *      }
 *
 *      getState() { ... }
 *      applyState(state) { ... }
 *  }
 * ```
 *
 * Another way to ensure {@link #function-saveState} is called when necessary is to use {@link #config-statefulEvents}.
 *
 * ```javascript
 *  class MyStatefulComponent extends Base.mixin(State) {
 *      static get configurable() {
 *          return {
 *              statefulEvents : ['change', 'resize']
 *          };
 *      }
 *  }
 * ```
 *
 * @mixin
 */
var State = (Target => class State extends (Target || Base) {
  static $name = 'State';
  static configurable = {
    /**
     * This value can be one of the following:
     *
     * - `false` to not use an explicitly assigned {@link Core.widget.Widget#config-id} as the component's
     * {@link #config-stateId} (this is only necessary when there is a {@link #config-stateProvider}).
     * - An array of strings naming the config properties to save in the component's {@link #property-state}
     * object.
     * - An object whose truthy keys are the config properties to save in the component's {@link #property-state}
     * object.
     *
     * These last two uses of the `stateful` config property do not apply to components that have a complex
     * state, as described in the {@link Core.mixin.State State mixin documentation}.
     *
     * This config property is typically set by derived classes to a value including any config property that
     * the user can affect via the user interface. For example, the {@link Core.widget.Panel#config-collapsed}
     * config property is listed for a {@link Core.widget.Panel} since the user can toggle this config property
     * using the {@link Core.widget.panel.PanelCollapser#config-tool collapse tool}.
     *
     * @config {Boolean|Object|String[]}
     * @category State
     */
    stateful: {
      value: null,
      $config: {
        merge: 'classList'
      }
    },
    /**
     * The events that, when fired by this component, should trigger it to save its state by calling
     * {@link #function-saveState}.
     *
     * ```javascript
     *  class MyStatefulComponent extends Base.mixin(State) {
     *      static get configurable() {
     *          return {
     *              statefulEvents : [ 'change', 'resize' ]
     *          };
     *      }
     *  }
     * ```
     * In the above example, {@link #function-saveState} will be called any time an instance of this class
     * fires the `change` or `resize` event.
     *
     * This config is typically set by derived classes as a way to ensure {@link #function-saveState} is called
     * whenever their persistent state changes.
     *
     * @config {Object|String[]}
     * @category State
     * @default
     */
    statefulEvents: {
      $config: {
        merge: 'classList'
      },
      value: ['stateChange']
    },
    /**
     * The key to use when saving this object's state in the {@link #config-stateProvider}. If this config is
     * not assigned, and {@link #config-stateful} is not set to `false`, the {@link Core.widget.Widget#config-id}
     * (if explicitly specified) will be used as the `stateId`.
     *
     * If neither of these is given, the {@link #function-loadState} and {@link #function-saveState} methods
     * will need to be called directly to make use of the `stateProvider`.
     *
     * For single page applications (SPA's), or multi-page applications (MPA's) that have common, stateful
     * components on multiple pages, the `stateId` should be unique across all stateful components (similar to DOM
     * element id's). MPA's that want each page to be isolated can more easily achieve that isolation using the
     * {@link Core.state.StateProvider#config-prefix}.
     *
     * @config {String}
     * @category State
     */
    stateId: null,
    /**
     * The `StateProvider` to use to save and restore this object's {@link #property-state}. By default, `state`
     * will be saved using the {@link Core.state.StateProvider#property-instance-static default state provider}.
     *
     * This config is useful for multi-page applications that have a set of common components that want to share
     * state across pages, as well as other components that want their state to be isolated. One of these groups
     * of stateful components could be assigned an explicit `stateProvider` while the other group could use the
     * default state provider.
     *
     * @config {Core.state.StateProvider}
     * @category State
     */
    stateProvider: null
  };
  static prototypeProperties = {
    statefulLoaded: false,
    statefulSuspended: 0
  };
  afterConstruct() {
    super.afterConstruct();
    this.loadState();
  }
  finalizeInit() {
    // For widgets, this should happen before rendering which happens in Widget.finalizeInit():
    this.loadState();
    super.finalizeInit();
  }
  /**
   * Returns `true` if this instance implements the {@link Core.mixin.State} interface.
   * @property {Boolean}
   * @readonly
   * @advanced
   */
  get isStateful() {
    return true;
  }
  /**
   * Returns `true` if this instance is ready to participate in state activities.
   * @property {Boolean}
   * @readonly
   * @internal
   */
  get isStatefulActive() {
    // If a widget is rendered via appendTo (for example), this happens inside construct(), before we are called
    // in afterConstruct(). When the Widget uses Responsive mixin, that will trigger its initial responsive update.
    // In short, when isResponsivePending, the Widget is Responsive _and_ has not yet determined its responsiveState.
    // In this case we do NOT want to activate statefulness.
    // Further, if we are updating configs from a responsiveUpdate, we do not want to save to state.
    return !this.statefulSuspended && !this.isResponsivePending && !this.isResponsiveUpdating;
  }
  // state
  /**
   * Gets or sets a component's state
   * @property {Object}
   * @category State
   */
  get state() {
    return this._state = this.getState();
  }
  set state(state) {
    this._state = state;
    if (state) {
      this.applyState(state);
    }
  }
  // statefulEvents
  updateStatefulEvents(events) {
    const me = this,
      listeners = {
        name: 'statefulEvents',
        thisObj: me
      };
    me.detachListeners(listeners.name);
    if (events) {
      if (typeof events === 'string') {
        events = StringHelper.split(events);
      } else if (!Array.isArray(events)) {
        events = ObjectHelper.getTruthyKeys(events);
      }
      if (events.length) {
        var _me$ion;
        for (const event of events) {
          listeners[event] = 'onStatefulEvent';
        }
        (_me$ion = me.ion) === null || _me$ion === void 0 ? void 0 : _me$ion.call(me, listeners);
      }
    }
  }
  // statefulId
  /**
   * Returns the state key to use for this instance. This will be either the {@link #config-stateId} or the
   * {@link Core.widget.Widget#config-id} (if explicitly specified and {@link #config-stateful} is not `false`).
   * @property {String}
   * @category State
   * @internal
   */
  get statefulId() {
    const me = this,
      {
        responsiveState
      } = me;
    let statefulId = me.stateId;
    if (statefulId == null && me.hasGeneratedId === false && me.stateful !== false) {
      statefulId = me.id;
    }
    if (statefulId && responsiveState) {
      statefulId = `${statefulId}[${responsiveState}]`; // ex = 'foo[small]'
    }

    return statefulId;
  }
  // statefulness
  /**
   * Returns an object whose truthy keys are the config properties to include in this object's {@link #property-state}.
   * @property {Object}
   * @category State
   * @readonly
   * @private
   */
  get statefulness() {
    const {
      stateful
    } = this;
    return Array.isArray(stateful) ? ObjectHelper.createTruthyKeys(stateful) : stateful;
  }
  // stateProvider
  get stateProvider() {
    return this._stateProvider || StateProvider.instance;
  }
  //---------------------------------------------------------------------------------------------------------------
  // Methods
  /**
   * Applies the given `state` to this instance.
   *
   * This method is not called directly, but is called when the {@link #property-state} property is assigned a value.
   *
   * This method is implemented by derived classes that have complex state which exceeds the simple list of config
   * properties provided by {@link #config-stateful}. In these cases, the `super` method can be called to handle any
   * config properties that are part of the complex state. The default implementation of this method will only assign
   * those config properties listed in {@link #config-stateful} from the provided `state` object.
   *
   * @param {Object} state The state object to apply to this instance.
   * @category State
   * @advanced
   */
  applyState(state) {
    state = this.pruneState(state);
    if (state) {
      this.setConfig(state);
    }
  }
  /**
   * Returns this object's state information.
   *
   * This method is not called directly, but is called to return the value of the {@link #property-state} property.
   *
   * This method is implemented by derived classes that have complex state which exceeds the simple list of config
   * properties provided by {@link #config-stateful}. In these cases, the `super` method can be called to gather the
   * config properties that are part of the complex state. The default implementation of this method will only copy
   * those config properties listed in {@link #config-stateful} to the returned `state` object.
   *
   * @returns {Object}
   * @category State
   * @advanced
   */
  getState() {
    const me = this,
      {
        initialConfig,
        statefulness,
        isConstructing: defaultState
      } = me,
      {
        configs
      } = me.$meta,
      // If we are reading state at construction time, we are collecting the defaultState, so
      // we should read from the initial config and the defaults.
      source = defaultState ? Object.setPrototypeOf(initialConfig, me.$meta.config) : me;
    let state = null,
      key,
      value;
    if (statefulness) {
      state = {};
      for (key in statefulness) {
        if (statefulness[key]) {
          var _value;
          value = source[key];
          if ((_value = value) !== null && _value !== void 0 && _value.isStateful) {
            value = value.state; // e.g.: stateful : { store : true }
          } else if (!defaultState) {
            // Dates can be saved in state as ISO 8601 Date and time.
            // This class's changer must be able to ingest this format.
            if (ObjectHelper.isDate(value)) {
              value = DateHelper.format(value, 'YYYY-MM-DDTHH:mm:ssZ');
            }
            // If we are reading state to save, ignore configs that have their initial value or aren't primitives
            if (configs[key].equal(value, initialConfig === null || initialConfig === void 0 ? void 0 : initialConfig[key]) || !primitiveRe.test(typeof value)) {
              continue;
            }
          }
          state[key] = value;
        }
      }
    }
    return state;
  }
  /**
   * Loads this object's state from its {@link #config-stateProvider} and applies it to its {@link #property-state}.
   *
   * This method only acts upon its first invocation for a given instance (unless `true` is passed for the `reload`
   * parameter). This allows for flexibility in the timing of that call during the early stages of the instances'
   * lifecycle. To reload the state after this time, manually assign the desired value to the {@link #property-state}
   * property or call this method and pass `reload` as `true`.
   *
   * This method is called automatically during construction when a {@link #config-stateId} or (in some cases) an
   * explicit {@link Core.widget.Widget#config-id} is provided.
   *
   * @param {String} [stateId] An overriding key to use instead of this object's {@link #config-stateId}.
   * @param {Boolean} [reload=false] Pass `true` to load the state even if previously loaded.
   * @category State
   */
  loadState(stateId, reload) {
    if (typeof stateId === 'boolean') {
      reload = stateId;
      stateId = null;
    }
    const me = this,
      {
        statefulLoaded
      } = me;
    if (me.isStatefulActive && (reload || !statefulLoaded)) {
      const state = me.loadStatefulData(stateId || (stateId = me.statefulId));
      if (!statefulLoaded && stateId) {
        // Whether we have state data or not, we attempted to load it, so track the defaults and load attempt.
        // The state as gathered when statefulLoaded not set is gathered from the configuration, *not*
        // the running state.
        me.defaultState = me.state;
        me.statefulLoaded = true;
      }
      if (state) {
        me.state = state;
      }
    }
  }
  loadStatefulData(stateId) {
    var _this$stateProvider;
    stateId = this.isStatefulActive ? stateId || this.statefulId : null;
    return stateId && ((_this$stateProvider = this.stateProvider) === null || _this$stateProvider === void 0 ? void 0 : _this$stateProvider.getValue(stateId));
  }
  resetDefaultState() {
    if (this.defaultState) {
      this.state = this.defaultState;
    }
  }
  resumeStateful(full = false) {
    this.statefulSuspended = full ? 0 : Math.max(this.statefulSuspended - 1, 0);
  }
  /**
   * Saves this object's state to its {@link #config-stateProvider}.
   *
   * When a {@link #config-stateId} or (in some cases) an explicit {@link Core.widget.Widget#config-id} is provided,
   * this method will be called automatically any time a config property listed in {@link #config-stateful} changes or
   * when a {@link #config-statefulEvents stateful event} is fired.
   *
   * Derived classes are responsible for calling this method whenever the persistent {@link #property-state} of the
   * object changes.
   *
   * @param {Object|String} [options] Options that affect the state saving process or, if a string, the state `id`.
   * @param {String} [options.id] The state id for the saved state (overrides {@link #config-stateId}).
   * @param {Boolean} [options.immediate] Pass `true` to save the data synchronously instead of on a delay.
   * @category State
   */
  saveState(options) {
    if (typeof options === 'string') {
      options = {
        id: options
      };
    } else {
      options = options || {};
    }
    const me = this,
      {
        stateProvider
      } = me,
      statefulId = options.id || me.isStatefulActive && me.statefulId;
    if (statefulId && stateProvider) {
      if (options.immediate) {
        me.isSaveStatePending = false;
        stateProvider.setValue(statefulId, me.state);
      } else if (!me.isSaveStatePending) {
        me.isSaveStatePending = true;
        stateProvider.saveStateful(me, options);
      }
      return statefulId;
    }
  }
  suspendStateful() {
    ++this.statefulSuspended;
  }
  //---------------------------------------------------------------------------------------------------------------
  // Private / Internal
  onConfigChange({
    name,
    value,
    was,
    config
  }) {
    super.onConfigChange({
      name,
      value,
      was,
      config
    });
    if (!this.isConstructing && this.isStatefulActive && this.statefulId) {
      const {
        stateful
      } = this;
      if (Array.isArray(stateful) ? stateful.includes(name) : stateful === null || stateful === void 0 ? void 0 : stateful[name]) {
        this.saveState();
      }
    }
  }
  onStatefulEvent() {
    if (!this.isConstructing) {
      this.saveState();
    }
  }
  /**
   * Returns an object that copies the {@link #config-stateful} config properties from the provided `state` object.
   *
   * @param {Object} state A state object from which to copy stateful configs.
   * @returns {Object}
   * @category State
   * @private
   */
  pruneState(state) {
    const {
      statefulness
    } = this;
    if (statefulness) {
      const pruned = {};
      for (const key in state) {
        if (statefulness[key]) {
          pruned[key] = state[key];
        }
      }
      state = pruned;
    }
    return state;
  }
  //---------------------------------------------------------------------------------------------------------------
  // This does not need a className on Widgets.
  // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
  // to the Widget it's mixed in to should implement thus.
  get widgetClass() {}
});

/**
 * @module Core/mixin/Identifiable
 */
const
  // Id generation should be on a per page basis, not per module
  idCounts$1 = ObjectHelper.getPathDefault(globalThis, 'bryntum.idCounts', Object.create(null)),
  idTypes = {
    string: 1,
    number: 1
  };
/**
 * A mixin which provides identifier services such as auto-creation of `id`s and registration and
 * lookup of instances by `id`.
 *
 * @mixin
 * @internal
 */
var Identifiable = (Target => class Identifiable extends (Target || Base) {
  static get $name() {
    return 'Identifiable';
  }
  static get declarable() {
    return ['identifiable'];
  }
  static get configurable() {
    return {
      /**
       * The id of this object.  If not specified one will be generated. Also used for lookups through the
       * static `getById` of the class which mixes this in. An example being {@link Core.widget.Widget}.
       *
       * For a {@link Core.widget.Widget Widget}, this is assigned as the `id` of the DOM
       * {@link Core.widget.Widget#config-element element} and must be unique across all elements
       * in the page's `document`.
       * @config {String}
       * @category Common
       */
      id: ''
    };
  }
  static setupIdentifiable(cls, meta) {
    const {
      identifiable
    } = cls;
    identifiable.idMap = Object.create(null);
    Reflect.defineProperty(cls, 'identifiable', {
      get() {
        return identifiable;
      }
    });
  }
  doDestroy() {
    this.constructor.unregisterInstance(this);
    super.doDestroy();
  }
  changeId(id) {
    return (this.hasGeneratedId /* assignment */ = !id) ? this.generateAutoId() : id;
  }
  updateId(id, oldId) {
    const me = this,
      C = me.constructor;
    oldId && C.unregisterInstance(me, oldId);
    if (!me.hasGeneratedId || C.identifiable.registerGeneratedId !== false) {
      C.registerInstance(me, id);
    }
  }
  /**
   * This method generates an id for this instance.
   * @returns {String}
   * @internal
   */
  generateAutoId() {
    return this.constructor.generateId(`b-${this.$$name.toLowerCase()}-`);
  }
  static get all() {
    // not documented here since type of array is not knowable... documented at mixin target class
    return Object.values(this.identifiable.idMap);
  }
  /**
   * Generate a new id, using an internal counter and a prefix.
   * @param {String} prefix Id prefix
   * @returns {String} Generated id
   */
  static generateId(prefix = 'generatedId') {
    // This produces "b-foo-1, b-foo-2, ..." for each prefix independently of the others. In other words, it makes
    // id's more stable since the counter is on a per-class basis.
    return prefix + (idCounts$1[prefix] = (idCounts$1[prefix] || 0) + 1);
  }
  static registerInstance(instance, instanceId = instance.id) {
    const {
      idMap
    } = this.identifiable;
    // Code editor sets `disableThrow` to not get conflicts when loading the same module again
    if (instanceId in idMap && !this.disableThrow) {
      throw new Error('Id ' + instanceId + ' already in use');
    }
    idMap[instanceId] = instance;
  }
  /**
   * Unregister Identifiable instance, normally done on destruction
   * @param {Object} instance Object to unregister
   * @param {String} id The id of the instance to unregister.
   */
  static unregisterInstance(instance, id = instance.id) {
    const {
      idMap
    } = this.identifiable;
    // ID may be passed, for example if the instance is destroyed and can no longer yield an id.
    if (idTypes[typeof instance]) {
      delete idMap[instance];
    }
    // Have to check for identity in case another instance by the same id has been created.
    // Allow that to be overridden. Stores have always just evicted the previous owner of their IDs
    else if (idMap[id] === instance) {
      delete idMap[id];
    }
  }
  static getById(id) {
    const idMap = this.identifiable.idMap;
    if (idMap) {
      return idMap[id];
    }
  }
  static get registeredInstances() {
    const idMap = this.identifiable.idMap;
    return idMap ? Object.values(idMap) : [];
  }
});

/**
 * @module Core/data/stm/mixin/ModelStm
 */
const STM_PROP$1 = Symbol('STM_PROP'),
  unrecordedFields = {
    // This field's value is a by product of node insertion and must not be recorded here.
    // It's the node insertion operation which is recorded by STM.
    parentIndex: 1
  };
/**
 * Mixin making a model compatible with {@link Core/data/stm/StateTrackingManager}
 *
 * @mixin
 */
var ModelStm = (Target => class ModelStm extends (Target || Base) {
  static get $name() {
    return 'ModelStm';
  }
  static get defaultConfig() {
    return {
      stm: null
    };
  }
  joinStore(store) {
    // No super on purpose, micro optimization of critical perf path
    // super.joinStore && super.joinStore(store);
    if (!this.stm) {
      this.stm = store.stm;
    }
  }
  unjoinStore(store, isReplacing = false) {
    var _super$unjoinStore;
    if (this.stm === store.stm) {
      this.stm = null;
    }
    (_super$unjoinStore = super.unjoinStore) === null || _super$unjoinStore === void 0 ? void 0 : _super$unjoinStore.call(this, store, isReplacing);
  }
  /**
   * Reference to STM manager, if used
   * @member {Core.data.stm.StateTrackingManager}
   * @category Misc
   */
  get stm() {
    return this[STM_PROP$1];
  }
  set stm(stm) {
    this[STM_PROP$1] = stm;
  }
  // Hook for chronograph entity field accessors, for example; task.duration = 123.
  // Triggers before setting the value.
  beforeChronoFieldSet(fieldName, value) {
    var _me$stm;
    const me = this;
    if (!me.inSetting && (_me$stm = me.stm) !== null && _me$stm !== void 0 && _me$stm.enabled && !unrecordedFields[fieldName] && !me.constructor.nonPersistableFields[fieldName]) {
      // Do not record changes of identifiers that are not fields
      if (me.getFieldDefinition(fieldName)) {
        return {
          [fieldName]: {
            value,
            oldValue: me[fieldName]
          }
        };
      }
    }
    return null;
  }
  // Hook for chronograph entity field accessors, for example; task.duration = 123
  // Triggers after setting the value.
  afterChronoFieldSet(fieldName, value, wasSet) {
    wasSet && this.afterSet(fieldName, value, false, false, wasSet, true);
  }
  shouldRecordFieldChange(fieldName, oldValue, newValue) {
    const store = this.firstStore;
    // By default, we do not record:
    // - not persistable field changes
    // - null vs undefined changes
    // - same value changes, compared by reference (by value for dates)
    // - "id" changes
    // - "parentId" changes caused by parent record idChange
    return !(this.constructor.nonPersistableFields[fieldName] || oldValue == null && newValue == null || oldValue === newValue || oldValue instanceof Date && newValue instanceof Date && oldValue.getTime() === newValue.getTime() || fieldName === 'id' || fieldName === '$PhantomId' || fieldName === 'parentId' && store && store.oldIdMap[oldValue] === store.getById(newValue));
  }
  /**
   * Overridden to store initial data of the changed fields and to notify STM
   * manager about the change action if anything has been changed in result.
   *
   * The method is called from within {@link Core/data/Model#function-set} method.
   *
   * @private
   */
  afterSet(field, value, silent, fromRelationUpdate, wasSet, isChronoFieldSet) {
    const {
        stm
      } = this,
      nonPersistableFields = this.constructor.nonPersistableFields;
    if (stm !== null && stm !== void 0 && stm.isBase && stm.enabled && !unrecordedFields[field] && !nonPersistableFields[field]) {
      if (wasSet) {
        let shouldRecord;
        const [newData, oldData] = Object.keys(wasSet).reduce((data, fieldName) => {
          const {
            value,
            oldValue
          } = wasSet[fieldName];
          if (this.shouldRecordFieldChange(fieldName, oldValue, value)) {
            shouldRecord = true;
            data[0][fieldName] = value;
            data[1][fieldName] = oldValue;
          }
          return data;
        }, [{}, {}]);
        if (shouldRecord) {
          stm.onModelUpdate(this, newData, oldData, isChronoFieldSet);
        }
      }
    }
    // No super on purpose, micro optimization of critical perf path
    // super.afterSet?.afterSet(field, value, silent, fromRelationUpdate, wasSet, isChronoFieldSet);
  }
  /**
   * Called from {@link Core/data/mixin/TreeNode#function-insertChild} to obtain inserted
   * records initial parents and parent index, to be able to restore the state back upon undo.
   *
   * @param {Core.data.Model[]} childRecords
   * @returns {Array} Array of results from this call and any of super calls if any.
   *               This result is consumed by {@link #function-afterInsertChild} which pops
   *               from the result array to take only results of this method call and leave
   *               results from super calls untouched.
   *
   * @private
   */
  beforeInsertChild(childRecords) {
    var _super$beforeInsertCh;
    const preResult = ((_super$beforeInsertCh = super.beforeInsertChild) === null || _super$beforeInsertCh === void 0 ? void 0 : _super$beforeInsertCh.call(this, childRecords)) || [],
      {
        stm
      } = this;
    if (stm !== null && stm !== void 0 && stm.enabled) {
      preResult.push(childRecords.reduce((result, childRecord) => {
        // We are interested only in records from the same root node.
        // Removing (which is done before insertion) of the records
        // from another root (and store) should
        // be handled by that store STM instance.
        if (childRecord.root === this.root) {
          result.set(childRecord, {
            parent: childRecord.parent,
            index: childRecord.parent ? childRecord.parentIndex : undefined
          });
        }
        return result;
      }, new Map()));
    }
    return preResult;
  }
  /**
   * Called from {@link Core/data/mixin/TreeNode#function-insertChild} to notify {@link Core/data/stm/StateTrackingManager}
   * about children insertion. Provides it with all necessary context information collected
   * in {@link #function-beforeInsertChild} required to undo/redo the action.
   *
   * @private
   */
  afterInsertChild(index, childRecords, beforeResult, inserted) {
    var _super$afterInsertChi;
    const {
      stm
    } = this;
    if (stm !== null && stm !== void 0 && stm.enabled) {
      const context = beforeResult.pop();
      if (inserted) {
        stm.onModelInsertChild(this, index, inserted, context);
      }
    }
    (_super$afterInsertChi = super.afterInsertChild) === null || _super$afterInsertChi === void 0 ? void 0 : _super$afterInsertChi.call(this, index, childRecords, beforeResult, inserted);
  }
  /**
   * Called from {@link Core/data/mixin/TreeNode#function-removeChild} to obtain removed
   * records initial parent index, to be able to restore the state back upon undo.
   *
   * @param {Core.data.Model[]} childRecords
   * @param {Boolean} isMove
   * @returns {Array} Array of results from this call and any of super calls if any.
   *               This result is consumed by {@link #function-afterRemoveChild} which pops
   *               from the result array to take only results of this method call and leave
   *               results from super calls untouched.
   *
   * @private
   */
  beforeRemoveChild(childRecords, isMove) {
    const preResult = super.beforeRemoveChild ? super.beforeRemoveChild(childRecords, isMove) : [],
      {
        stm
      } = this;
    // If it's move then InsertChildAction will handle this case
    if (stm !== null && stm !== void 0 && stm.enabled && !isMove) {
      // Child records we receive are guaranteed to be direct children
      // of this node, see Core/data/mixin/TreeNode#removeChild method
      // Here we interested in the original index for each child removed,
      // we collect it and store for future use in RemoveChildAction
      preResult.push(childRecords.reduce((result, childRecord) => {
        result.set(childRecord, {
          parentIndex: childRecord.parentIndex,
          orderedParentIndex: childRecord.orderedParentIndex
        });
        return result;
      }, new Map()));
    }
    return preResult;
  }
  /**
   * Called from {@link Core/data/mixin/TreeNode#function-removeChild} to notify {@link Core/data/stm/StateTrackingManager}
   * about children removing. Provides it with all necessary context information collected
   * in {@link #function-beforeRemoveChild} required to undo/redo the action.
   *
   * @private
   */
  afterRemoveChild(childRecords, beforeResult, isMove) {
    var _super$afterRemoveChi;
    const {
      stm
    } = this;
    // If it's move then InsertChildAction will handle this case
    if (stm !== null && stm !== void 0 && stm.enabled && !isMove) {
      const context = beforeResult.pop();
      if (childRecords && childRecords.length) {
        stm.onModelRemoveChild(this, childRecords, context);
      }
    }
    (_super$afterRemoveChi = super.afterRemoveChild) === null || _super$afterRemoveChi === void 0 ? void 0 : _super$afterRemoveChi.call(this, childRecords, beforeResult, isMove);
  }
});

/**
 * @module Core/data/mixin/TreeNode
 */
const defaultTraverseOptions$1 = {
    includeFilteredOutRecords: false
  },
  fixTraverseOptions$1 = options => {
    options = options || false;
    if (typeof options === 'boolean') {
      options = {
        includeFilteredOutRecords: options
      };
    }
    return options || defaultTraverseOptions$1;
  };
/**
 * Mixin for Model with tree node related functionality. This class is mixed into the {@link Core/data/Model} class.
 *
 * ## Adding and removing child nodes
 *
 * ```javascript
 * const parent = store.getById(1),
 *
 * firstBorn = parent.insertChild({
 *     name : 'Child node'
 * }, parent.children[0]); // Insert a child at a specific place in the children array
 *
 * parent.removeChild(parent.children[0]); // Removes a child node
 * parent.appendChild({ name : 'New child node' }); // Appends a child node
 * ```
 *
 * @mixin
 */
var TreeNode = (Target => class TreeNode extends (Target || Base) {
  static get $name() {
    return 'TreeNode';
  }
  /**
   * This static configuration option allows you to control whether an empty parent task should be converted into a
   * leaf. Enable/disable it for a whole class:
   *
   * ```javascript
   * Model.convertEmptyParentToLeaf = false;
   * ```
   *
   * By specifying `true`, all empty parents will be considered leafs. Can also be assigned a configuration object
   * with the following Boolean properties to customize the behaviour:
   *
   * ```javascript
   * Model.convertEmptyParentToLeaf = {
   *     onLoad   : false,
   *     onRemove : true
   * }
   * ```
   *
   * @member {Boolean|{ onLoad : Boolean, onRemove : Boolean }} convertEmptyParentToLeaf
   * @property {Boolean} onLoad Apply the transformation on load to any parents without children (`children : []`)
   * @property {Boolean} onRemove Apply the transformation when all children have been removed from a parent
   * @default false
   * @static
   * @category Parent & children
   * */
  static set convertEmptyParentToLeaf(value) {
    if (value === true) {
      value = {
        onLoad: true,
        onRemove: true
      };
    } else if (value === false) {
      value = {
        onLoad: false,
        onRemove: false
      };
    }
    this._convertEmptyParentToLeaf = value;
  }
  constructor(...args) {
    super(...args);
    if (this.children) {
      this.orderedChildren = this.orderedChildren || [];
    }
  }
  static get convertEmptyParentToLeaf() {
    return this._convertEmptyParentToLeaf || {
      onLoad: false,
      onRemove: false
    };
  }
  /**
   * This is a read-only property providing access to the parent node.
   * @member {Core.data.Model} parent
   * @readonly
   * @category Parent & children
   */
  /**
   * This is a read-only field provided in server synchronization packets to specify
   * which record id is the parent of the record.
   * @readonly
   * @field {String|Number|null} parentId
   * @category Tree
   */
  /**
   * This is a read-only field provided in server synchronization packets to specify
   * which position the node takes in the parent's children array.
   * This index is set on load and gets updated automatically after row reordering, sorting, etc.
   * To save the order, need to persist the field on the server and when data is fetched to be loaded,
   * need to sort by this field.
   * @readonly
   * @field {Number} parentIndex
   * @category Tree
   */
  /**
   * This is a read-only field provided in server synchronization packets to specify
   * which position the node takes in the parent's ordered children array.
   * This index is set on load and gets updated on reordering nodes in tree. Sorting and filtering
   * have no effect on it.
   * @readonly
   * @field {Number} orderedParentIndex
   * @category Tree
   */
  ingestChildren(childRecord, stores = this.stores) {
    const {
        inProcessChildren,
        constructor: MyClass
      } = this,
      store = stores[0];
    if (childRecord === true) {
      if (inProcessChildren) {
        return true;
      }
      return [];
    }
    if (childRecord) {
      childRecord = ArrayHelper.asArray(childRecord);
      const len = childRecord.length,
        result = [];
      for (let i = 0, child; i < len; i++) {
        child = childRecord[i];
        child = child.isModel ? child : store ? store.createRecord(child, false, true) : new MyClass(child, null, null, true);
        child = store ? store.processRecord(child) : child;
        result.push(child);
      }
      if (this.children === true && store) {
        const sorter = store.createSorterFn(store.sorters);
        result.sort(sorter);
      }
      return result;
    }
  }
  /**
   * Child nodes. To allow loading children on demand, specify `children : true` in your data. Omit the field for leaf
   * tasks.
   *
   * Note, if the tree store loads data from a remote origin, make sure {@link Core/data/AjaxStore#config-readUrl}
   * is specified, and optionally {@link Core/data/AjaxStore#config-parentIdParamName} is set, otherwise
   * {@link Core/data/Store#function-loadChildren} has to be implemented.
   *
   * @field {Boolean|Object[]|Core.data.Model[]} children
   * @category Parent & children
   */
  /**
   * Array of sorted tree nodes but without a filter applied
   * @member {Core.data.Model[]|null} unfilteredChildren
   * @category Parent & children
   * @private
   */
  /**
   * Array of children unaffected by sorting and filtering, keeps original tree structure
   * @member {Core.data.Model[]|null} orderedChildren
   * @category Parent & children
   * @private
   */
  /**
   * Called during creation to also turn any children into Models joined to the same stores as this model
   * @internal
   * @category Parent & children
   */
  processChildren(stores = this.stores) {
    const me = this,
      {
        meta
      } = me;
    me.inProcessChildren = true;
    const children = me.ingestChildren(me.data[me.constructor.childrenField], stores);
    if (children) {
      const {
          convertEmptyParentToLeaf
        } = me.constructor,
        shouldConvert = convertEmptyParentToLeaf === true || convertEmptyParentToLeaf.onLoad;
      if (shouldConvert ? children.length : Array.isArray(children)) {
        meta.isLeaf = false;
        // We are processing a remote load
        if (me.children === true) {
          me.children = [];
        } else if (children.length === 0) {
          me.children = children;
          return;
        }
        me.insertChild(children);
      }
      // Flagged for load on demand
      else if (children === true) {
        meta.isLeaf = false;
        me.children = true;
      }
      // Empty child array, flag is leaf if configured to do so
      else if (!me.isRoot) {
        meta.isLeaf = me.constructor.convertEmptyParentToLeaf.onLoad;
      }
    }
    me.inProcessChildren = false;
  }
  /**
   * This method returns `true` if this record has all expanded ancestors and is therefore
   * eligible for inclusion in a UI.
   * @param {Core.data.Store} [store] Optional store, defaults to nodes first store
   * @returns {Boolean}
   * @readonly
   * @category Parent & children
   * @returns {Boolean}
   */
  ancestorsExpanded(store = this.firstStore) {
    const {
      parent
    } = this;
    return !parent || parent.isExpanded(store) && parent.ancestorsExpanded(store);
  }
  /**
   * Used by stores to assess the record's collapsed/expanded state in that store.
   * @param {Core.data.Store} store
   * @category Parent & children
   * @returns {Boolean}
   */
  isExpanded(store = this.firstStore) {
    const mapMeta = this.instanceMeta(store.id);
    // Default initial expanded/collapsed state when in the store
    // to the record's original expanded property.
    if (!Object.prototype.hasOwnProperty.call(mapMeta, 'collapsed')) {
      mapMeta.collapsed = !this.expanded;
    }
    return !mapMeta.collapsed;
  }
  // A read-only property. It provides the initial state upon load
  // The UI's expanded/collapsed state is in the store's meta map.
  get expanded() {
    return this.data.expanded;
  }
  /**
   * Depth in the tree at which this node exists. First visual level of nodes are at level 0, their direct children at
   * level 1 and so on.
   * @property {Number}
   * @readonly
   * @category Parent & children
   */
  get childLevel() {
    let node = this,
      ret = -1;
    while (node && !node.isRoot) {
      ++ret;
      node = node.parent;
    }
    return ret;
  }
  /**
   * Is a leaf node in a tree structure?
   * @property {Boolean}
   * @readonly
   * @category Parent & children
   */
  get isLeaf() {
    return this.meta.isLeaf !== false && !this.isRoot;
  }
  /**
   * Returns `true` if this node is the root of the tree
   * @member {Boolean} isRoot
   * @readonly
   * @category Parent & children
   */
  /**
   * Is a parent node in a tree structure?
   * @property {Boolean}
   * @readonly
   * @category Parent & children
   */
  get isParent() {
    return !this.isLeaf;
  }
  /**
   * Returns true for parent nodes with children loaded (there might still be no children)
   * @property {Boolean}
   * @readonly
   * @category Parent & children
   */
  get isLoaded() {
    return this.isParent && Array.isArray(this.children);
  }
  /**
   * Count all children (including sub-children) for a node (in its `firstStore)
   * @member {Number}
   * @category Parent & children
   */
  get descendantCount() {
    return this.getDescendantCount();
  }
  /**
   * Count visible (expanded) children (including sub-children) for a node (in its `firstStore`)
   * @member {Number}
   * @category Parent & children
   */
  get visibleDescendantCount() {
    return this.getDescendantCount(true);
  }
  /**
   * Count visible (expanded)/all children for this node, optionally specifying for which store.
   * @param {Boolean} [onlyVisible] Specify `true` to only count visible (expanded) children.
   * @param {Core.data.Store} [store] A Store to which this node belongs
   * @returns {Number}
   * @category Parent & children
   */
  getDescendantCount(onlyVisible = false, store = this.firstStore) {
    const {
      children
    } = this;
    if (!children || !Array.isArray(children) || onlyVisible && !this.isExpanded(store)) {
      return 0;
    }
    return children.reduce((count, child) => count + child.getDescendantCount(onlyVisible), children.length);
  }
  /**
   * Retrieve all children, not including filtered out nodes (by traversing sub nodes)
   * @property {Core.data.Model[]}
   * @category Parent & children
   */
  get allChildren() {
    return this.getAllChildren(false);
  }
  /**
   * Retrieve all children, including filtered out nodes (by traversing sub nodes)
   * @property {Core.data.Model[]}
   * @private
   * @category Parent & children
   */
  get allUnfilteredChildren() {
    return this.getAllChildren(true);
  }
  getAllChildren(unfiltered = false) {
    const {
      [unfiltered ? 'unfilteredChildren' : 'children']: children
    } = this;
    if (!children || children === true) {
      return [];
    }
    return children.reduce((all, child) => {
      all.push(child);
      // push.apply is faster than push with array spread:
      // https://jsperf.com/push-apply-vs-push-with-array-spread/1
      all.push.apply(all, unfiltered ? child.allUnfilteredChildren : child.allChildren);
      return all;
    }, []);
  }
  /**
   * Get the first child of this node
   * @property {Core.data.Model}
   * @readonly
   * @category Parent & children
   */
  get firstChild() {
    const {
      children
    } = this;
    return (children === null || children === void 0 ? void 0 : children.length) && children[0] || null;
  }
  /**
   * Get the last child of this node
   * @property {Core.data.Model}
   * @readonly
   * @category Parent & children
   */
  get lastChild() {
    const {
      children
    } = this;
    return (children === null || children === void 0 ? void 0 : children.length) && children[children.length - 1] || null;
  }
  /**
   * Get the previous sibling of this node
   * @member {Core.data.Model} previousSibling
   * @readonly
   * @category Parent & children
   */
  /**
   * Get the next sibling of this node
   * @member {Core.data.Model} nextSibling
   * @readonly
   * @category Parent & children
   */
  /**
   * Returns count of all preceding sibling nodes (including their children).
   * @property {Number}
   * @category Parent & children
   */
  get previousSiblingsTotalCount() {
    let task = this.previousSibling,
      count = this.parentIndex;
    while (task) {
      count += task.descendantCount;
      task = task.previousSibling;
    }
    return count;
  }
  get previousOrderedSibling() {
    var _this$parent;
    return (_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.orderedChildren[this.orderedParentIndex - 1];
  }
  get nextOrderedSibling() {
    var _this$parent2;
    return (_this$parent2 = this.parent) === null || _this$parent2 === void 0 ? void 0 : _this$parent2.orderedChildren[this.orderedParentIndex + 1];
  }
  get root() {
    var _this$parent3;
    return ((_this$parent3 = this.parent) === null || _this$parent3 === void 0 ? void 0 : _this$parent3.root) || this;
  }
  /**
   * Reading this property returns the id of the parent node, if this record is a child of a node.
   *
   * Setting this property appends this record to the record with the passed id **in the same store that this record
   * is already in**.
   *
   * Note that setting this property is **only valid if this record is already part of a tree store**.
   *
   * This is not intended for general use. This is for when a server responds to a record mutation and the server
   * decides to move a record to a new parent. If a `parentId` property is passed in the response data for a record,
   * that record will be moved.
   *
   * @property {Number|String|null}
   * @category Parent & children
   */
  get parentId() {
    return this.parent && !this.parent.isAutoRoot ? this.parent.id : null;
  }
  set parentId(parentId) {
    const me = this,
      {
        parent
      } = me,
      newParent = parentId === null ? me.firstStore.rootNode : me.firstStore.getById(parentId);
    // Handle exact equality of parent.
    // Also handle one being null and the other being undefined meaning no change.
    if (!(newParent === parent || !parent && !newParent)) {
      // If we are batching, we do not trigger a change immediately.
      // endBatch will set the field which will set the property again.
      if (me.isBatchUpdating) {
        me.meta.batchChanges.parentId = parentId;
      } else {
        if (newParent) {
          newParent.appendChild(me);
        } else {
          me.parent.removeChild(me);
        }
      }
    }
  }
  static set parentIdField(parentIdField) {
    // Maintainer: the "this" references in here reference two different contexts.
    // Outside of the property definition, it's the Model Class.
    // In the getter and setter, it's the record instance.
    this._parentIdField = parentIdField;
    Object.defineProperty(this.prototype, parentIdField, {
      set: function (parentId) {
        // no arrow functions here, need `this` to change to instance
        // noinspection JSPotentiallyInvalidUsageOfClassThis
        this.parentId = parentId;
      },
      get: function () {
        // no arrow functions here, need `this` to change to instance
        // noinspection JSPotentiallyInvalidUsageOfClassThis
        return this.parentId;
      }
    });
  }
  static get parentIdField() {
    return this._parentIdField || 'parentId';
  }
  getChildren(options) {
    let result;
    if (options.includeFilteredOutRecords) {
      result = this.unfilteredChildren || this.children;
    } else if (options.useOrderedTree) {
      result = this.orderedChildren;
    } else {
      result = this.children;
    }
    return result;
  }
  /**
   * Traverses all child nodes recursively calling the passed function
   * on a target node **before** iterating the child nodes.
   * @param {Function} fn The function to call
   * @param {Boolean} [skipSelf=false] True to ignore self
   * @param {Object|Boolean} [options] A boolean for includeFilteredOutRecords, or an options object
   * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records
   * @param {Boolean} [options.useOrderedTree] True to traverse unsorted/unfiltered tree
   * @category Parent & children
   */
  traverse(fn, skipSelf, options) {
    options = fixTraverseOptions$1(options);
    const me = this,
      children = me.getChildren(options);
    if (!skipSelf) {
      fn.call(me, me);
    }
    // Simply testing whether there is non-zero children length
    // is 10x faster than using this.isLoaded
    for (let i = 0, l = children === null || children === void 0 ? void 0 : children.length; i < l; i++) {
      children[i].traverse(fn, false, options);
    }
  }
  /**
   * Traverses all child nodes recursively calling the passed function
   * on child nodes of a target **before** calling it on the node.
   * @param {Function} fn The function to call
   * @param {Boolean} [skipSelf=false] True to skip this node in the traversal
   * @param {Object|Boolean} [options] A boolean for includeFilteredOutRecords, or an options object
   * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records
   * @category Parent & children
   */
  traverseBefore(fn, skipSelf, options) {
    options = fixTraverseOptions$1(options);
    const me = this,
      children = me.getChildren(options);
    // Simply testing whether there is non-zero children length
    // is 10x faster than using me.isLoaded
    for (let i = 0, l = children === null || children === void 0 ? void 0 : children.length; i < l; i++) {
      children[i].traverse(fn, false, options);
    }
    if (!skipSelf) {
      fn.call(me, me);
    }
  }
  /**
   * Traverses child nodes recursively while fn returns true
   * @param {Function} fn
   * @param {Boolean} [skipSelf=false] True to skip this node in the traversal
   * @param {Object|Boolean} [options] A boolean for includeFilteredOutRecords, or an options object
   * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records
   * @category Parent & children
   * @returns {Boolean}
   */
  traverseWhile(fn, skipSelf, options) {
    options = fixTraverseOptions$1(options);
    const me = this;
    let goOn = skipSelf || fn.call(me, me) !== false;
    if (goOn) {
      const children = me.getChildren(options);
      // Simply testing whether there is non-zero children length
      // is 10x faster than using me.isLoaded
      if (children !== null && children !== void 0 && children.length) {
        goOn = children.every(child => child.traverseWhile(fn, false, options));
      }
    }
    return goOn;
  }
  /**
   * Bubbles up from this node, calling the specified function with each node.
   *
   * @param {Function} fn The function to call for each node
   * @param {Boolean} [skipSelf] True to skip this node in the traversal
   * @category Parent & children
   */
  bubble(fn, skipSelf = false) {
    let me = this;
    if (!skipSelf) {
      fn.call(me, me);
    }
    while (me.parent) {
      me = me.parent;
      fn.call(me, me);
    }
  }
  /**
   * Bubbles up from this node, calling the specified function with each node,
   * while the function returns true.
   *
   * @param {Function} fn The function to call for each node
   * @param {Boolean} [skipSelf] True to skip this node in the traversal
   * @category Parent & children
   * @returns {Boolean}
   */
  bubbleWhile(fn, skipSelf = false) {
    let me = this,
      goOn = true;
    if (!skipSelf) {
      goOn = fn.call(me, me);
    }
    while (goOn && me.parent) {
      me = me.parent;
      goOn = fn.call(me, me);
    }
    return goOn;
  }
  /**
   * Checks if this model contains another model as one of it's descendants
   *
   * @param {Core.data.Model|String|Number} childOrId child node or id
   * @param {Boolean} [skipSelf=false] True to ignore self in the traversal
   * @category Parent & children
   * @returns {Boolean}
   */
  contains(childOrId, skipSelf = false) {
    if (childOrId && typeof childOrId === 'object') {
      childOrId = childOrId.id;
    }
    return !this.traverseWhile(node => node.id != childOrId, skipSelf);
  }
  getTopParent(all) {
    let result;
    if (all) {
      result = [];
      this.bubbleWhile(t => {
        result.push(t);
        return t.parent && !t.parent.isRoot;
      });
    } else {
      result = null;
      this.bubbleWhile(t => {
        result = t;
        return t.parent && !t.parent.isRoot;
      });
    }
    return result;
  }
  /**
   * Append a child record(s) to any current children.
   * @param {Core.data.Model|Core.data.Model[]|Object|Object[]} childRecord Array of records/data or a single
   * record/data to append
   * @param {Boolean} [silent] Pass `true` to not trigger events during append
   * @returns {Core.data.Model|Core.data.Model[]|null}
   * @category Parent & children
   */
  appendChild(childRecord, silent = false) {
    return this.insertChild(childRecord, null, silent);
  }
  /**
   * Insert a child record(s) before an existing child record.
   * @param {Core.data.Model|Core.data.Model[]|Object|Object[]} childRecord Array of records/data or a single
   * record/data to insert
   * @param {Core.data.Model} [before] Optional record to insert before, leave out to append to the end
   * @param {Boolean} [silent] Pass `true` to not trigger events during append
   * @returns {Core.data.Model|Core.data.Model[]|null}
   * @category Parent & children
   */
  insertChild(childRecord, before = null, silent = false, options = {}) {
    var _before, _me$children2, _me$beforeInsertChild, _me$afterInsertChild;
    const me = this,
      returnArray = Array.isArray(childRecord);
    childRecord = ArrayHelper.asArray(childRecord);
    if (typeof before === 'number') {
      var _me$children;
      before = ((_me$children = me.children) === null || _me$children === void 0 ? void 0 : _me$children[before]) ?? null;
    }
    if (!silent && !me.stores.every(s => s.trigger('beforeAdd', {
      records: childRecord,
      parent: me
    }) !== false)) {
      return null;
    }
    // This call makes child record an array containing Models
    childRecord = me.ingestChildren(childRecord);
    // NOTE: see comment in Model::set() about before/in/after calls approach.
    const index = ((_before = before) === null || _before === void 0 ? void 0 : _before.parentIndex) ?? ((_me$children2 = me.children) === null || _me$children2 === void 0 ? void 0 : _me$children2.length) ?? 0,
      preResult = (_me$beforeInsertChild = me.beforeInsertChild) === null || _me$beforeInsertChild === void 0 ? void 0 : _me$beforeInsertChild.call(me, childRecord),
      inserted = me.internalAppendInsert(childRecord, before, silent, options);
    // Turn into a parent if not already one
    if (inserted.length) {
      me.convertToParent(silent);
    }
    (_me$afterInsertChild = me.afterInsertChild) === null || _me$afterInsertChild === void 0 ? void 0 : _me$afterInsertChild.call(me, index, childRecord, preResult, inserted);
    return returnArray || !inserted ? inserted : inserted[0];
  }
  /**
   * Converts a leaf node to a parent node, assigning an empty array as its children
   * @param {Boolean} [silent] Pass `true` to not trigger any event
   * @category Parent & children
   */
  convertToParent(silent = false) {
    const me = this,
      wasLeaf = me.isLeaf;
    me.meta.isLeaf = false;
    if (!me.children) {
      me.children = [];
    }
    // Signal a change event so that the UI updates, unless it is during load in which case StoreTree#onNodeAddChild
    // will handle it
    if (wasLeaf && !me.root.isLoading && !silent) {
      me.signalNodeChanged({
        isLeaf: {
          value: false,
          oldValue: true
        }
      });
    }
  }
  signalNodeChanged(changes, stores = this.stores) {
    stores.forEach(s => {
      s.trigger('update', {
        record: this,
        records: [this],
        changes
      });
      s.trigger('change', {
        action: 'update',
        record: this,
        records: [this],
        changes
      });
    });
  }
  tryInsertChild() {
    return this.insertChild(...arguments);
  }
  internalAppendInsert(recordsToInsert, beforeRecord, silent, options) {
    const me = this,
      {
        stores,
        root,
        children
      } = me,
      {
        firstStore: rootStore
      } = root,
      {
        parentIdField
      } = me.constructor,
      parentId = me.id;
    let isNoop, start, i, newRecordsCloned, oldParentIndices, isMove;
    if (!root.isLoading && rootStore) {
      // Only collect this info if not loading, to not produce garbage
      isMove = {};
      oldParentIndices = [];
      for (i = 0; i < recordsToInsert.length; i++) {
        const newRecord = recordsToInsert[i];
        // Store added should not be modified for adds
        // caused by moving.
        isMove[newRecord.id] = newRecord.root === root;
        oldParentIndices[i] = newRecord.parentIndex;
      }
    }
    // The reference node must be one of our children. If not, fall back to an append.
    if (beforeRecord && beforeRecord.parent !== me) {
      beforeRecord = null;
    }
    // If the records starting at insertAt or (insertAt - 1), are the same sequence
    // that we are being asked to add, this is a no-op.
    if (children) {
      const insertAt = beforeRecord ? beforeRecord.parentIndex : children.length;
      if (children[start = insertAt] === recordsToInsert[0] || children[start = insertAt - 1] === recordsToInsert[0]) {
        for (isNoop = true, i = 0; isNoop && i < recordsToInsert.length; i++) {
          if (recordsToInsert[i] !== children[start + i]) {
            isNoop = false;
          }
        }
      }
    }
    // Fulfill the contract of appendChild/insertChild even if we did not have to do anything.
    // Callers must be able to correctly postprocess the returned value as an array.
    if (isNoop) {
      return recordsToInsert;
    }
    // Remove incoming child nodes from any current parent.
    for (i = 0; i < recordsToInsert.length; i++) {
      var _isMove;
      const newRecord = recordsToInsert[i],
        oldParent = newRecord.parent;
      // Check if any descendants of the added node are moves.
      if (rootStore && !root.isLoading) {
        newRecord.traverse(r => {
          if (r.root === root) {
            isMove[r.id] = true;
          }
        });
      }
      // If the new record has a parent, remove from that parent.
      // This operation may be vetoed by listeners.
      // If it is vetoed, then remove from the newRecords and do not
      // set the parent property
      if ((oldParent === null || oldParent === void 0 ? void 0 : oldParent.removeChild(newRecord, (_isMove = isMove) === null || _isMove === void 0 ? void 0 : _isMove[newRecord.id], silent, {
        isInserting: true,
        ...options
      })) === false) {
        if (!newRecordsCloned) {
          recordsToInsert = recordsToInsert.slice();
          newRecordsCloned = true;
        }
        recordsToInsert.splice(i--, 1);
      } else {
        newRecord.parent = me;
        // Set parentId directly to data, record.parentId uses a getter to return record.parent.id
        newRecord.data[parentIdField] = parentId;
        const {
          meta
        } = newRecord;
        // it seems we rely on setting the `oldParentId` flag on the "meta" object for managing `parentId` field
        // presence in the `meta.modified` in the code below
        // however, `oldParent` might be missing in case of STM removal restoring for example, but
        // `oldParentId` should still be set
        // covered with `Core/tests/data/stm/TreeRemoval.t.js//Should not include `parentId` to modifications after undo-ing the child removal`
        if (meta.modified[parentIdField] === parentId && !oldParent) {
          meta.oldParentId = parentId;
        }
        if (oldParent) {
          meta.oldParentId = oldParent.id;
        }
      }
    }
    // Still records to insert after beforeRemove listeners may have vetoed some
    if (recordsToInsert.length) {
      if (!Array.isArray(children)) {
        me.children = [];
      }
      if (!Array.isArray(me.orderedChildren)) {
        me.orderedChildren = [];
      }
      // Add to the children
      const insertAt = me.addToChildren(beforeRecord, recordsToInsert, options);
      stores.forEach(store => {
        if (!store.isChained) {
          recordsToInsert.forEach(record => {
            // Initialize context for newly added records
            record.joinStore(store);
          });
          // Add to store (will also add any child records and trigger events)
          store.onNodeAddChild(me, recordsToInsert, insertAt, isMove, silent);
          recordsToInsert.forEach((record, i) => {
            // If we are in the recursive inclusion of children at construction
            // time, or in a store load, that must not be a data modification.
            // Otherwise, we have to signal a change
            if (record.meta.oldParentId != null && !(me.inProcessChildren || me.isLoading)) {
              const toSet = {
                  [parentIdField]: parentId,
                  [me.getDataSource('parentIndex')]: record.parentIndex
                },
                wasSet = {},
                {
                  modified,
                  oldParentId
                } = record.meta,
                oldParentIndex = oldParentIndices[i];
              delete record.meta.oldParentId;
              if (me.id !== oldParentId) {
                wasSet[parentIdField] = {
                  value: parentId,
                  oldValue: oldParentId
                };
              }
              if (record.parentIndex !== oldParentIndex) {
                wasSet.parentIndex = {
                  value: record.parentIndex,
                  oldValue: oldParentIndex
                };
              }
              // Changing back to its original value
              if (modified[parentIdField] === me.id) {
                Reflect.deleteProperty(modified, parentIdField);
              }
              // Cache its original value
              else if (!(parentIdField in modified)) {
                modified[parentIdField] = oldParentId;
              }
              if (isMove[record.id]) {
                const oldParent = store.getById(oldParentId);
                // If old parent transitioned to being a leaf node, signal a change event so that the UI
                // updates. Handled here and not on remove to get the correct order of events on move
                if (oldParent.isLeaf && !silent) {
                  oldParent.signalNodeChanged({
                    isLeaf: {
                      value: true,
                      oldValue: false
                    }
                  }, [store]);
                }
              }
              record.afterChange(toSet, wasSet);
            }
            // should only perform this after all changes to `node.modified` are completed
            record.traverse(node => {
              if (!node.ignoreBag && !node.isLinked) {
                store.updateModifiedBagForRecord(node);
              }
            });
          });
        }
      });
    }
    return recordsToInsert;
  }
  /**
   * Remove a child record. Only direct children of this node can be removed, others are ignored.
   * @param {Core.data.Model|Core.data.Model[]} childRecords The record(s) to remove.
   * @param {Boolean} [isMove] Pass `true` if the record is being moved within the same store.
   * @param {Boolean} [silent] Pass `true` to not trigger events during remove.
   * @privateparam {Object} [options]
   * @privateparam {Object} [options.isInserting] `true` is passed when removal is part of record inserting (acted on by
   * ModelLink)
   * @returns {Core.data.Model[]} All records (including nested children) removed
   * @category Parent & children
   */
  removeChild(childRecords, isMove = false, silent = false, options = {}) {
    var _me$beforeRemoveChild, _me$afterRemoveChild;
    const me = this,
      allRemovedRecords = [],
      wasLeaf = me.isLeaf,
      {
        children,
        stores
      } = me;
    childRecords = ArrayHelper.asArray(childRecords);
    childRecords = childRecords.filter(r => r.parent === me);
    if (!silent) {
      // Allow store listeners to veto the beforeRemove event
      for (const store of stores) {
        if (!store.isChained && store.trigger('beforeRemove', {
          parent: me,
          records: childRecords,
          isMove
        }) === false) {
          return false;
        }
      }
    }
    const preResult = (_me$beforeRemoveChild = me.beforeRemoveChild) === null || _me$beforeRemoveChild === void 0 ? void 0 : _me$beforeRemoveChild.call(me, childRecords, isMove);
    for (const childRecord of childRecords) {
      const {
          parentIdField
        } = childRecord.constructor,
        {
          modified
        } = childRecord.meta,
        oldParentId = childRecord.parent ? childRecord.parent.id : null;
      // Cache its original value (not if it is a link, that would pollute original)
      if (!(parentIdField in modified) && !childRecord.isLinked) {
        modified[parentIdField] = oldParentId;
      }
      const index = me.removeFromChildren(childRecord, options);
      stores.forEach(store => {
        if (!store.isChained) {
          const {
            isRemoving
          } = store;
          // Raise the store isRemoving flag (it's set in Store#remove() but not when we call record#removeChild() directly)
          store.isRemoving = true;
          allRemovedRecords.push(...store.onNodeRemoveChild(me, [childRecord], index, {
            isMove,
            silent
          }));
          // restore the flag initial state
          store.isRemoving = isRemoving;
        }
      });
      // No need to clean up the node parent info and other meta data in case it is "move" operation. The info will be updated after "insert" operation.
      if (!isMove) {
        childRecord.parent = childRecord.parentIndex = childRecord.unfilteredIndex = childRecord.nextSibling = childRecord.previousSibling = null;
        // Reset parentId in data, record.parentId uses a getter to return record.parent.id
        childRecord.data[parentIdField] = null;
      }
    }
    // Convert emptied parent into leaf if configured to do so
    if ((me.unfilteredChildren || children).length === 0 && me.constructor.convertEmptyParentToLeaf.onRemove && !me.isRoot) {
      me.meta.isLeaf = true;
    }
    // If we've transitioned to being a leaf node, signal a change event so that the UI updates
    // (but not if part of move, will be signaled by insert)
    if (me.isLeaf !== wasLeaf && !silent && !isMove) {
      me.signalNodeChanged({
        isLeaf: {
          value: true,
          oldValue: false
        }
      });
    }
    (_me$afterRemoveChild = me.afterRemoveChild) === null || _me$afterRemoveChild === void 0 ? void 0 : _me$afterRemoveChild.call(me, childRecords, preResult, isMove);
    return allRemovedRecords;
  }
  clearParentId() {
    const me = this;
    Reflect.deleteProperty(me.data, me.parentIdField);
    Reflect.deleteProperty(me.originalData, me.parentIdField);
    if (me.meta.modified) {
      Reflect.deleteProperty(me.meta.modified, me.parentIdField);
    }
  }
  /**
   * Replaces all child nodes with the new node set.
   * @param {Core.data.Model|Core.data.Model[]} childRecords The new child record set.
   * @returns {Core.data.Model[]}
   * @category Parent & children
   */
  replaceChildren(newChildren) {
    this.clearChildren();
    this.data[this.constructor.childrenField] = newChildren;
    this.processChildren();
    return this.children;
  }
  /**
   * Removes all child nodes from this node.
   * @param {Boolean} [silent=false] Pass `true` to not fire Store events during the remove.
   * @returns {Core.data.Model[]}
   * @category Parent & children
   */
  clearChildren(silent = false) {
    const me = this,
      {
        stores
      } = me,
      children = me.unfilteredChildren || me.children;
    me.children = [];
    me.orderedChildren = [];
    if (children && children !== true) {
      stores.forEach(store => {
        if (!store.isChained) {
          // unfiltered:true to unregister children on filtered stores
          store.onNodeRemoveChild(me, children, 0, {
            unfiltered: true,
            silent
          });
        }
      });
      // clear unfilteredChildren (must be after the above loop)
      if (me.unfilteredChildren) {
        me.unfilteredChildren = [];
      }
    }
  }
  /**
   * Removes all records from the rootNode
   * @private
   */
  clear() {
    var _me$children3;
    const me = this,
      {
        stores
      } = me,
      children = (_me$children3 = me.children) === null || _me$children3 === void 0 ? void 0 : _me$children3.slice();
    // Only allow for root node and if data is present
    if (!me.isRoot || !children) {
      return;
    }
    for (const store of stores) {
      if (!store.isChained) {
        if (store.trigger('beforeRemove', {
          parent: me,
          records: children,
          isMove: false,
          removingAll: true
        }) === false) {
          return false;
        }
      }
    }
    me.children.length = 0;
    if (me.unfilteredChildren) {
      me.unfilteredChildren.length = 0;
    }
    stores.forEach(store => {
      children.forEach(child => {
        if (child.stores.includes(store)) {
          // this will drill down the child, unregistering whole branch
          child.unjoinStore(store);
        }
        child.parent = child.parentIndex = child.nextSibling = child.previousSibling = null;
      });
      store.storage.suspendEvents();
      store.storage.clear();
      store.storage.resumeEvents();
      store.added.clear();
      store.modified.clear();
      store.trigger('removeAll');
      store.trigger('change', {
        action: 'removeall'
      });
    });
  }
  updateChildrenIndices(children, indexName, silent = false) {
    let previousSibling = null;
    for (let i = 0; i < children.length; i++) {
      const child = children[i],
        oldValue = child[indexName];
      if (indexName === 'parentIndex' || indexName === 'orderedParentIndex') {
        // Record should not be considered modified by initial assignment of parentIndex
        if (oldValue === undefined || silent) {
          child.setData(indexName, i);
        }
        // Check to avoid pointless beforeUpdates from inSet
        else if (oldValue !== i) {
          // Silent set, do not want to trigger events from updated indices
          child.set(indexName, i, true);
        }
      } else {
        child[indexName] = i;
      }
      if (indexName === 'parentIndex') {
        child.previousSibling = previousSibling;
        if (previousSibling) {
          previousSibling.nextSibling = child;
        }
        // Last child never has a nextSibling
        if (i === children.length - 1) {
          child.nextSibling = null;
        }
        previousSibling = child;
      }
    }
  }
  addToChildren(beforeRecord, newRecords, options = {}) {
    // children can be sorted and filtered
    // unfilteredChildren can not be filtered
    // orderedChildren can not be nor filtered nor sorted. it holds true tree hierarchy
    const me = this,
      configs = [[me.children, 'parentIndex', beforeRecord], [me.unfilteredChildren, 'unfilteredIndex', beforeRecord], [me.orderedChildren, 'orderedParentIndex', (options === null || options === void 0 ? void 0 : options.orderedBeforeNode) ?? ((options === null || options === void 0 ? void 0 : options.orderedParentIndex) !== undefined ? me.orderedChildren[options === null || options === void 0 ? void 0 : options.orderedParentIndex] : beforeRecord)]];
    for (const config of configs) {
      const [children, indexName, beforeRecord] = config;
      if (children) {
        var _options$indexName;
        // On undo/redo it might happen that we redo orderedParentIndex change first breaking indexing. Safe
        // way is to always check array for record index. We also cannot filter out orderedParentIndex change
        // because by itself it is valid.
        const index = beforeRecord ? indexName === 'orderedParentIndex' ? children.indexOf(beforeRecord) : beforeRecord[indexName] : children.length;
        config.push(index);
        children.splice(index, 0, ...newRecords);
        if (!(options !== null && options !== void 0 && (_options$indexName = options[indexName]) !== null && _options$indexName !== void 0 && _options$indexName.skip)) {
          me.updateChildrenIndices(children, indexName);
        }
      }
    }
    // always return index of the record in the children array
    return configs[0][3];
  }
  removeFromChildren(childRecord, options) {
    const configs = [[this.children, 'parentIndex'], [this.unfilteredChildren, 'unfilteredIndex'], [this.orderedChildren, 'orderedParentIndex']];
    for (const config of configs) {
      const [children, indexName] = config;
      if (children) {
        // parentIndex/orderedParentIndex might be changed when applying a remote changeset leading to
        // record getting removed from the wrong position in the children array. Therefore, we should
        // not rely on the index value, instead we query array itself
        const index = children.indexOf(childRecord);
        config.push(index);
        if (index > -1) {
          var _options$indexName2;
          children.splice(index, 1);
          if (!(options !== null && options !== void 0 && (_options$indexName2 = options[indexName]) !== null && _options$indexName2 !== void 0 && _options$indexName2.skip)) {
            this.updateChildrenIndices(children, indexName);
          }
        }
      }
    }
    // always return index of the record in the children array
    return configs[0][2];
  }
  /**
   * Iterates orderedChildren array to apply sorting order according to `orderedParentIndex`.
   * Normally sorting is not required because order is maintained on append/insert. But is useful
   * when pasting number of records to restore their original order.
   * @param {Boolean} [deep=true] True to dive into children. False to sort own children.
   * @param {Boolean} [usePreviousOrder=false] Enable to use previous value of `orderedParentIndex`.
   * @returns {Set} Returns Set of moved nodes which require WBS update
   * @private
   */
  sortOrderedChildren(deep = true, usePreviousOrder = false) {
    // Collect moved nodes, we need to recalculate WBS on them.
    const movedNodes = [];
    if (!this.isLeaf) {
      this.orderedChildren.sort((a, b) => {
        if (usePreviousOrder) {
          const aPrevIndex = a.meta.modified.orderedParentIndex ?? a.orderedParentIndex,
            bPrevIndex = b.meta.modified.orderedParentIndex ?? b.orderedParentIndex,
            result = aPrevIndex - bPrevIndex;
          if (result !== 0) {
            movedNodes.push(a);
            movedNodes.push(b);
          }
          return result;
        } else {
          return a.orderedParentIndex - b.orderedParentIndex;
        }
      });
      if (deep) {
        this.orderedChildren.forEach(child => {
          movedNodes.push(...child.sortOrderedChildren(deep, usePreviousOrder));
        });
      }
      this.updateChildrenIndices(this.orderedChildren, 'orderedParentIndex', true);
    }
    return new Set(movedNodes);
  }
  unjoinStore(store, isReplacing = false) {
    var _super$unjoinStore;
    const me = this;
    // clear the filtering when unjoining the record from the store
    if (me.unfilteredChildren) {
      me.children = me.unfilteredChildren.slice();
      me.unfilteredChildren = null;
    }
    (_super$unjoinStore = super.unjoinStore) === null || _super$unjoinStore === void 0 ? void 0 : _super$unjoinStore.call(this, store, isReplacing);
  }
});

/**
 * @module Core/data/mixin/ModelLink
 */
const
  // Properties set on the proxy instead of on the original
  propertyOverrides = {
    id: 1,
    stores: 1,
    parentIndex: 1,
    parent: 1,
    previousSibling: 1,
    nextSibling: 1,
    unfilteredIndex: 1
  },
  proxyConfig = {
    get(target, prop) {
      // Proxy record has some additional meta
      if (prop === 'proxyMeta') {
        return this.proxyMeta;
      }
      // Accessing constructor in functions should lead to original records constructor
      // (for static fns etc.)
      if (prop === 'constructor') {
        return target.constructor;
      }
      // Override setData / set to reroute parentIndex updates
      if (prop === 'setData') {
        return this.setDataOverride;
      }
      if (prop === 'set') {
        return this.setOverride;
      }
      // Special properties not shared with the original record
      if (propertyOverrides[prop]) {
        return this.proxyMeta.data[prop];
      }
      // Everything else is scoped to the proxy record
      return Reflect.get(target, prop, this.proxyRecord);
    },
    set(target, prop, value) {
      // Special properties not shared with the original record
      if (propertyOverrides[prop]) {
        this.proxyMeta.data[prop] = value;
      }
      // Everything else is relayed to the original record
      else {
        target[prop] = value;
      }
      return true;
    },
    // Override setData & set to reroute parentIndex updates
    setDataOverride(toSet, value) {
      if (toSet === 'parentIndex') {
        this.proxyMeta.data.parentIndex = value;
      } else {
        this.proxyMeta.originalRecord.setData(toSet, value);
      }
    },
    setOverride(field, value, ...args) {
      if (field === 'parentIndex') {
        this.proxyMeta.data.parentIndex = value;
      } else {
        this.proxyMeta.originalRecord.set(field, value, ...args);
      }
    }
  };
/**
 * Mixin that allows creating proxy records linked to an original record. See {@link #function-link} for more
 * information.
 *
 * <div class="note">Note that not all UI features support linked records</div>
 *
 * @mixin
 */
var ModelLink = (Target => class ModelLink extends (Target || Base) {
  static $name = 'ModelLink';
  /**
   * Creates a proxy record (using native Proxy) linked to this record (the original). The proxy records shares most
   * data with the original, except for its `id` (which is always generated), and ordering fields such as
   * `parentIndex` and `parentId` etc.
   *
   * Any change to the proxy record will be reflected on the original, and vice versa. A proxy record is not meant to
   * be persisted, only the original record should be persisted. Thus, proxy records are not added to stores change
   * tracking (added, modified and removed records).
   *
   * Removing the original record removes all proxies.
   *
   * Creating a proxy record allows a Store to seemingly contain the record multiple times, something that is
   * otherwise not possible. It also allows a record to be used in both a tree store and in a flat store.
   *
   * <div class="note">Note that not all UI features support linked records</div>
   *
   * @returns {Proxy} Proxy record linked to the original record
   * @category Misc
   */
  link() {
    // Calling link on a link creates another link of the original record
    if (this.isLinked) {
      return this.$original.link();
    }
    const me = this,
      useConfig = {
        ...proxyConfig,
        // Data not shared with the original record
        proxyMeta: {
          originalRecord: me,
          data: {
            id: `${me.id}_link_${StringHelper.generateUUID()}`,
            stores: []
          }
        }
      },
      proxyRecord = new Proxy(me, useConfig);
    useConfig.proxyRecord = proxyRecord;
    // Original record keeps tracks of all proxies
    (me.meta.linkedRecords || (me.meta.linkedRecords = [])).push(proxyRecord);
    return proxyRecord;
  }
  /**
   * Is this record linked to another record?
   * @member {Boolean}
   * @readonly
   * @category Misc
   */
  get isLinked() {
    var _this$proxyMeta;
    return Boolean((_this$proxyMeta = this.proxyMeta) === null || _this$proxyMeta === void 0 ? void 0 : _this$proxyMeta.originalRecord);
  }
  /**
   * Are other records linked to this record?
   * @member {Boolean}
   * @readonly
   * @category Misc
   */
  get hasLinks() {
    return Boolean(!this.proxyMeta && this.$links.length);
  }
  // Logic to remove a link shared between removing in a flat store and a tree store
  removeLink(link, records = null, silent = false) {
    // Removing original, also remove linked records
    if (link.hasLinks) {
      for (const linked of link.$links.slice()) {
        // Flat
        if (records) {
          ArrayHelper.include(records, linked);
        }
        // Tree
        else {
          linked.remove(silent);
        }
      }
    }
    // Removing linked record, remove from originals link tracking
    else if (link.isLinked) {
      ArrayHelper.remove(link.$original.$links, link);
    }
  }
  // Overrides beforeRemove in Model, to remove all linked records when original record is removed.
  beforeRemove(records) {
    this.removeLink(this, records);
  }
  // Overrides removeChild in TreeNode, to remove the original node and all linked nodes when either a linked or
  // original node is removed.
  removeChild(childRecords, isMove, silent, options) {
    if (!(options !== null && options !== void 0 && options.isInserting)) {
      childRecords = ArrayHelper.asArray(childRecords);
      for (const child of childRecords) {
        this.removeLink(child, null, silent);
      }
    }
    return super.removeChild(childRecords, isMove, silent, options);
  }
  // Convenience getter for code keying by id that needs to work with both link and original
  get $originalId() {
    return this.$original.id;
  }
  // Convenience getter to retrieve linked records
  get $links() {
    return this.meta.linkedRecords ?? [];
  }
});

/**
 * @module Core/mixin/Factoryable
 */
const {
    defineProperty: defineProperty$3
  } = Reflect,
  ownerSymbol = Symbol('owner'),
  typeSplitRe = /[\s,]+/;
/**
 * This mixin is applied to base classes of a type that will be dynamically created by type name aliases.
 *
 * ```javascript
 *  class Layout extends Base.mixin(Factoryable) {
 *      static get factoryable() {
 *          return {
 *              defaultType : 'default'
 *          };
 *      }
 *
 *      static get type() {
 *          return 'default';
 *      }
 *  }
 *
 *  class Fit extends Layout {
 *      static get type() {
 *          return 'fit';
 *      }
 *  }
 * ```
 *
 * Once a family of classes has been defined, instances are created using the `create()` method:
 *
 * ```javascript
 *  const layout = Layout.create(config);
 * ```
 *
 * In the above example, `config` can be a type name (such as "fit") or a config object with a `type` property that
 * holds the type name.
 *
 * Factories can also extend other factories. For example, one factory creates objects that are useful across a wide
 * range of consumers, and a second factory creates objects for a more specialized consumer. If that specialized
 * consumer can also consume objects from the first factory, then the second factory can specify this relationship:
 *
 * ```javascript
 *  class General extends Base.mixin(Factoryable) {
 *      ...
 *  }
 *
 *  class Specialized extends Base.mixin(Factoryable) {
 *      static get factoryable() {
 *          return {
 *              extends : General,
 *              ...
 *          };
 *      }
 *  }
 * ```
 *
 * The `extends` factoryable option can be either a class that mixes in `Factoryable` or an array of such classes.
 * @mixin
 * @internal
 */
var Factoryable = (Target => class Factoryable extends (Target || Base) {
  static get $name() {
    return 'Factoryable';
  }
  static get declarable() {
    return [
    /**
     * This property getter returns options that control the factory process. This property getter must be
     * defined by the class that mixes in `Factoryable` in order to initialize the factory properly.
     * ```
     *  static get factoryable() {
     *      return {
     *          defaultType : 'default'
     *      };
     *  }
     * ```
     * If there are no special options to provide, this method can return nothing (`undefined`):
     * ```
     *  static get factoryable() {
     *      // initialize the factory with all default options
     *  }
     * ```
     * @static
     * @member {Object} factoryable
     * @property {Boolean} [factoryable.caseless=true] Specify `false` to use case-sensitive type names. The
     * default is to ignore case.
     * @property {String} [factoryable.defaultType=null] The default type to create when a config object has
     * no `typeKey` property.
     * @property {Function|Function[]} [factoryable.extends] One or more classes that mix in `Factoryable` to
     * use for resolving type names when a type name is not found in this factory.
     * @property {String} [factoryable.typeKey='type'] The name of the property in a config object that holds
     * the type name.
     * @internal
     */
    'factoryable',
    /**
     * One or more additional type name aliases for this class. This can be useful for renaming and maintaining
     * a previous type name.
     * ```
     *  class Fit extends Layout {
     *      static get type() {
     *          return 'fit';
     *      }
     *
     *      static get alias() {
     *          return 'fill';  // deprecated type name (now known as 'fit')
     *      }
     *  }
     * ```
     * @static
     * @member {String|String[]} alias
     * @internal
     */
    'alias',
    /**
     * The (canonical) type name for this class by which instances can be created using the static
     * {@link #function-create-static create()} method.
     * @static
     * @member {String} type
     */
    'type'];
  }
  /**
   * Registers a class (`cls`) associated with the given `type`.
   * @param {String|String[]} type A string, array of strings or a comma-separated string containing the type names
   * for the specified `cls` class.
   * @param {Function} cls The class (constructor function)
   * @param {Boolean} [replace] Pass `true` to overwrite existing registered types. Otherwise, this method will throw
   * an exception if the `type` is already registered with this factory.
   * @internal
   */
  static register(type, cls, replace = globalThis.__BRYNTUM_EXAMPLE) {
    // `replace` default value is set to true while we are run inside a bryntum demo where code editor changes might
    // lead to same widget class being registered over and over.
    const {
        factoryable
      } = this.initClass(),
      {
        caseless,
        registry
      } = factoryable,
      types = StringHelper.split(type, typeSplitRe); // if type is a string[] it will just be returned
    for (let lower, name, i = 0; i < types.length; ++i) {
      name = types[i];
      lower = caseless ? name.toLowerCase() : name;
      if (!replace && lower in registry) {
        throw new Error(`Type "${name}" already registered with ${factoryable.class.name} factory`);
      }
      // Ensure class being registered is initialized. (initClass returns the class)
      registry[name] = registry[lower] = cls.initClass();
    }
  }
  /**
   * Returns `true` if the passed instance is of the passed type or of a derived class.
   * @param {Object} instance The object to test.
   * @param {String} type The type to test against
   */
  static isA(instance, type) {
    return this.isType(instance, type, true);
  }
  /**
   * Returns `true` if the passed instance is of the passed type.
   * @param {Object} instance The object to test.
   * @param {String} type The type to test against
   * @param {Boolean} [deep] Pass `true` to return `true` if the class is a subclass of the passed type.
   */
  static isType(instance, type, deep) {
    const {
        factoryable
      } = this,
      {
        caseless,
        registry
      } = factoryable,
      typeCls = registry[caseless ? type.toLowerCase() : type];
    // If the type to be tested against maps to a class, see if the instance is an instanceof that
    if (typeCls) {
      if (deep) {
        return instance instanceof typeCls;
      }
      return instance.constructor === typeCls;
    }
    return false;
  }
  static setupAlias(cls) {
    cls.register(cls.alias, cls);
  }
  static setupFactoryable(cls, meta) {
    const superClass = meta.super.class;
    let {
      factoryable
    } = cls;
    factoryable = {
      caseless: true,
      defaultType: null,
      extends: superClass.factoryable ? [superClass] : null,
      typeKey: 'type',
      ...factoryable
    };
    factoryable.class = cls;
    factoryable.registry = Object.create(null);
    if (factoryable.extends && !Array.isArray(factoryable.extends)) {
      factoryable.extends = [factoryable.extends];
    }
    // Replace the class/static getter with a new one that returns the complete factoryable object:
    defineProperty$3(cls, 'factoryable', {
      get() {
        return factoryable;
      }
    });
  }
  static setupType(cls, meta) {
    const {
      type
    } = cls;
    cls.register(type, cls, meta.replaceType);
    // Copy the static type property onto the prototype as a readonly property:
    defineProperty$3(cls.prototype, 'type', {
      value: type
    });
  }
  /**
   * Creates an instance from this factory, given the type name or a config object.
   * @param {String|Object} config The type name string or config object.
   * @param {String|Function|Object} [options] Creation options (for details see {@link #function-reconfigure-static}).
   * @returns {Object}
   */
  static create(config, options) {
    return this.reconfigure(null, config, options);
  }
  /**
   * Reconfigures an optional existing instance based on the provided config and returns the correctly configured
   * instance. This will be the `existingInstance` if the `config` does not specify a different type.
   *
   * If `config` is `null` (or simply falsy), this method will destroy the `existingInstance` (if any) and return
   * `null`.
   *
   * If there is no `existingInstance`, the config must specify a type. That is, it must be a string (the type name)
   * or an object containing a `type` property, the `defaultType` must be provided or the factory itself must have
   * a `defaultType` specified (see {@link #property-factoryable-static}).
   *
   * When an `existingInstance` is provided and a type is specified, the instance will be reconfigured via `setConfig`
   * if it is of that type. Otherwise, the `existingInstance` is destroyed (if it is owned by the `options.owner`)
   * and a new instance of the correct type is created.
   *
   * @param {Object} existingInstance The instance to reconfigure. This can be `null`.
   *
   * @param {String|Object} config The type name string or config object.
   *
   * @param {String|Function|Object} [options] Additional options to control the reconfiguration process. If this
   * value is a string or a class constructor, it treated as `options.type`. If this value is a class instance, it
   * is used as the `options.owner`. If this is a function, it is treated as `options.setup`. NOTE: functions declared
   * using the `function` keyword are equivalent to class constructors. Use an arrow function or a class method to
   * avoid this when a `setup` function is intended.
   *
   * @param {String|Function} [options.type] The default type to use if the `config` object does not specify a type.
   *
   * @param {Object} [options.owner] The owner of any created instances. If the `existingInstance` is being replaced,
   * this value determines if the instance will be destroyed.
   *
   * @param {Object} [options.defaults] A config object of default values to use when creating a new instance.
   *
   * @param {Function|String} [options.setup] A function or the name of a method (on the `options.owner`) to call
   * prior to creating a new instance. It is passed the config object that will be used to create the instance. If a
   * truthy value is returned, that value is passed to the constructor instead of the provided config object.
   *
   * @param {Function|String} [options.transform] A function or the name of a method (on the `options.owner`) to call
   * with the raw config object prior to processing and the value it returns replaces the raw value. This function is
   * used to transform strings or arrays (for example) into proper config objects.
   *
   * @param {Function|String} [options.cleanup] A function or the name of a method (on the `options.owner`) to call
   * prior to destroying the `existingInstance`. The `existingInstance` is passed as the sole argument.
   *
   * @returns {Object} The reconfigured instance (either `existingInstance` or a new instance of the desired type)
   */
  static reconfigure(existingInstance, config, options) {
    const me = this,
      {
        factoryable
      } = me,
      {
        typeKey
      } = factoryable;
    let defaultType = options,
      cleanup,
      defaults,
      mergeType,
      owner,
      prepared,
      setup,
      t,
      transform,
      type;
    // Pick apart the options and set the vars accordingly
    if (options && !ObjectHelper.isClass(options)) {
      // if (options is not the defaultType)
      defaultType = null;
      t = typeof options;
      if (t === 'function') {
        setup = options;
      } else if (t === 'string') {
        defaultType = options;
      } else if (ObjectHelper.isObject(options)) {
        cleanup = options.cleanup;
        defaults = options.defaults;
        owner = options.owner;
        setup = options.setup;
        defaultType = options.type;
        transform = options.transform;
      } else {
        owner = options;
      }
    }
    if (transform) {
      config = typeof transform === 'string' ? owner[transform](config) : transform(config);
    }
    type = config;
    // Figure out config... it's either a type (string), a config object or the actual instance.
    if (typeof type === 'string') {
      config = {};
    } else if (config) {
      if (config === true) {
        config = {};
      }
      if (!ObjectHelper.isObject(config)) {
        // If we are being given an instance (not a config object), discard or destroy the existingInstance
        if (owner && config !== existingInstance && (existingInstance === null || existingInstance === void 0 ? void 0 : existingInstance[ownerSymbol]) === owner) {
          var _cleanup;
          typeof cleanup === 'string' ? owner[cleanup](existingInstance) : (_cleanup = cleanup) === null || _cleanup === void 0 ? void 0 : _cleanup(existingInstance);
          existingInstance.destroy();
        }
        return config;
      }
      type = config[typeKey];
    }
    type = type && me.resolveType(type);
    // We've got our orders... make it so...
    if (existingInstance) {
      // We can have a type-less config object when reconfiguring an existing instance, but if we have a type,
      // the existingInstance must be of that type. If !config that means we are nulling out.
      if (config && (!type || existingInstance.constructor === type)) {
        if (typeKey in config) {
          config = ObjectHelper.assign({}, config);
          delete config[typeKey]; // so "type" won't be processed as a config property
        }

        existingInstance.setConfig(config);
        return existingInstance;
      }
      if (owner && existingInstance[ownerSymbol] === owner) {
        var _cleanup2;
        typeof cleanup === 'string' ? owner[cleanup](existingInstance) : (_cleanup2 = cleanup) === null || _cleanup2 === void 0 ? void 0 : _cleanup2(existingInstance);
        existingInstance.destroy();
      }
    }
    if (config) {
      if (defaults) {
        if (!(mergeType = type)) {
          if (!(mergeType = defaults[typeKey] || defaultType || factoryable.defaultType)) {
            throw new Error(`No default mergeType defined for ${factoryable.class.name} factory`);
          }
          mergeType = me.resolveType(mergeType);
        }
        if (mergeType) {
          // Allow the merge fn of each config to perform the task:
          config = mergeType.mergeConfigs(defaults, config);
        }
      }
      if (setup) {
        prepared = typeof setup === 'string' ? owner[setup](config, type, defaults) : setup(config, type, defaults);
        if (prepared === null) {
          return prepared;
        }
        config = prepared || config;
      }
      if (!type) {
        // One more check on config[typeKey] since the setup() function may have added it...
        if (!(type = config[typeKey] || defaultType || factoryable.defaultType)) {
          throw new Error(`No default type defined for ${factoryable.class.name} factory`);
        }
        type = me.resolveType(type);
      }
      if (defaults && !mergeType) {
        config = type.mergeConfigs(defaults, config);
      }
      if (typeKey in config) {
        config = ObjectHelper.assign({}, config);
        delete config[typeKey]; // so "type" won't be processed as a config property
      }

      config = new type(config);
      if (owner) {
        config[ownerSymbol] = owner;
      }
    }
    return config || null;
  }
  /**
   * This method returns the constructor of the class registered for the given type name.
   * @param {String} type The type name to look up.
   * @param {Boolean} [optional] Pass `true` to return `null` if `type` is not found instead of throwing an exception.
   * @returns {Function}
   */
  static resolveType(type, optional) {
    if (typeof type !== 'string') {
      return type;
    }
    const {
        factoryable
      } = this,
      bases = factoryable.extends;
    let result = factoryable.registry[factoryable.caseless ? type.toLowerCase() : type],
      i;
    for (i = 0; !result && bases && i < bases.length; ++i) {
      // Pass optional=true to base factory so the error is our own should the lookup fail:
      result = bases[i].resolveType(type, /* optional = */true);
    }
    if (!result && !optional) {
      throw new Error(`Invalid type name "${type}" passed to ${factoryable.class.name} factory`);
    }
    return result;
  }
});

/**
 * @module Core/data/field/DataField
 */
const {
  getOwnPropertyDescriptor
} = Reflect;
/**
 * This is the base class for Model field classes. A field class defines how to handle the data for a particular type
 * of field. Many of these behaviors can be configured on individual field instances.
 *
 * @extends Core/Base
 * @datafield
 */
class DataField extends Base.mixin(Factoryable) {
  static get $name() {
    return 'DataField';
  }
  static get type() {
    return 'auto';
  }
  static get factoryable() {
    return {
      defaultType: 'auto'
    };
  }
  static get prototypeProperties() {
    return {
      /**
       * The name of the field.
       * @config {String} name
       */
      /**
       * The label text for a form item generated for this field. This is also used to create
       * a column header for a {@link #config-column} for this field.
       * @config {String} label
       */
      /**
       * A column config object for a column to display this field in a grid. For simple, atomic
       * data types, such as `date`, `string`, `boolean`, `number` and `integer`, this is optional
       * and the appropriate column type can be inferred.
       *
       * This also provides default values for column configuration if a configured column definition
       * for a grid lacks a property.
       *
       * For complex fields, such as identifiers which link to other records, a more capable
       * column type may be specified, for example a `type : `number'` field may be configured
       * with
       *
       * ```javascript
       * column : 'percent'
       * ```
       * or
       * ```javascript
       * column : {
       *     type : 'percent',
       *     width : 100
       * }
       * ```
       * if it represents a percentage vaue and needs appropriate rendering and editing.
       * @config {String|Object} column
       */
      /**
       * A config object for a widget to edit this field in a form. For simple, atomic
       * data types, such as `date`, `string`, `boolean`, `number` and `integer`, this is optional
       * and the appropriate input widget type can be inferred.
       *
       * For complex fields, such as identifiers which link to other records, a more capable
       * widget may be specified.
       * @config {String|InputFieldConfig} editor
       * @private
       */
      /**
       * A function that compares two values and returns a value < 0 if the first is less than the second, or 0
       * if the values are equal, or a value > 0 if the first is greater than the second.
       * @config {Function}
       * @default
       */
      compare: null,
      /**
       * A function that compares two objects or records using the `compare` function on the properties of each
       * objects based on the `name` of this field.
       * @config {Function}
       * @default
       * @internal
       */
      compareItems: null,
      /**
       * The property in a record's data object that contains the field's value.
       * Defaults to the field's `name`.
       * @config {String}
       */
      dataSource: null,
      /**
       * The default value to assign to this field in a record if no value is provided.
       * @config {*} defaultValue
       */
      /**
       * Setting to `true` will ensure this field is included in any update/insert request payload
       * when a Store / Project / CrudManager performs a request.
       * @config {Boolean}
       * @default
       */
      alwaysWrite: false,
      /**
       * Setting to `false` indicates that `null` is not a valid value.
       * @config {Boolean}
       * @default
       */
      nullable: true,
      /**
       * The value to return from {@link #function-print} for a `null` or `undefined` value.
       * @config {String}
       * @default
       */
      nullText: null,
      /**
       * The value to replace `null` when the field is not `nullable`.
       * @config {*}
       * @default
       */
      nullValue: undefined,
      /**
       * Set to `false` to exclude this field when saving records to a server.
       * @config {Boolean}
       * @default
       */
      persist: true,
      /**
       * Set to `true` for the field's set accessor to ignore attempts to set this field.
       * @config {Boolean}
       * @default
       */
      readOnly: false,
      /**
       * By default, defined {@link Core.data.Model} fields may be used to create a grid column
       * suitable for diplaying that field in a grid cell. Some fields may not be suitable for
       * features which automatically generate columns for view. These fields are created using
       * `internal : true`. Some examples are the `expanded` and `rowHeight` fields which are used
       * internally.
       * @config {Boolean}
       * @default
       */
      internal: false,
      useProp: null
    };
  }
  /**
   * The class that first defined this field. Derived classes that override a field do not change this property.
   * @member {Core.data.Model} definedBy
   * @private
   * @readonly
   */
  /**
   * The class that most specifically defined this field. Derived classes that override a field set this property to
   * themselves.
   * @member {Core.data.Model} owner
   * @private
   * @readonly
   */
  // NOTE: Since we create lots of instances, they have no life cycle (they are not destroyed) and are readonly after
  // creation, this class does not use configurable.
  construct(config) {
    const me = this;
    if (config) {
      me.name = config.name; // assign name first for diagnostic reasons
      Object.assign(me, config);
    }
    if (me.compare) {
      // We wrap in this way to allow compareItems() to be used as an array sorter fn (which gets no "this"):
      me.compareItems = (itemA, itemB) => me.compare(itemA === null || itemA === void 0 ? void 0 : itemA[me.name], itemB === null || itemB === void 0 ? void 0 : itemB[me.name]);
    }
  }
  /**
   * This method transforms a data value into the desired form for storage in the record's data object.
   *
   * ```javascript
   * export default class Task extends TaskModel {
   *    static get fields() {
   *        return [
   *            {
   *                name    : 'status',
   *                convert : (value, data) => {
   *                    if (value >= 100) {
   *                        return 'done';
   *                    }
   *                    else if (value > 0) {
   *                        return 'started';
   *                    }
   *                }
   *            }
   *        ];
   *    }
   * }
   * ```
   *
   * @method convert
   * @param {*} value The value to convert for storage in a record.
   * @param {Object} data The raw record data object
   * @returns {*} The converted value.
   */
  /**
   * This method transforms a data value into the desired form for transmitting to a server.
   * @method serialize
   * @param {*} value The value to serialize
   * @param {Core.data.Model} record The record that contains the value being serialized.
   * @returns {*} The serialized value.
   */
  /**
   * This optional method is called when setting a data value on a record.
   * @method set
   * @param {*} value The value to set
   * @param {Object} data The records future or current data object to set value to
   * @param {Core.data.Model} record The record that owns or will own the data object
   * @internal
   */
  /**
   * This optional method is called when a record using this field is created.
   * @method init
   * @param {Core.data.Model} record The record being created
   * @internal
   */
  /**
   * Create getter and setter functions for the specified field name under the specified key.
   * @internal
   */
  defineAccessor(target, force) {
    const {
      name,
      dataSource
    } = this;
    // Bail out if trying to override an explicitly defined accessor
    if (!force && name in target && target.$meta.hierarchy.some(current => {
      var _getOwnPropertyDescri;
      return ((_getOwnPropertyDescri = getOwnPropertyDescriptor(current.prototype, name)) === null || _getOwnPropertyDescri === void 0 ? void 0 : _getOwnPropertyDescri.enumerable) === false;
    })) {
      return;
    }
    Reflect.defineProperty(target, name, {
      configurable: true,
      // To allow removing it later
      enumerable: true,
      // no arrow functions here, need `this` to change to instance
      get: this.complexMapping ? function () {
        return this.complexGet(name, dataSource);
      } : function () {
        // Inlined copy of Model#flatGet, to save a fn call since this is hit very often
        // When changes are batched, they get stored by field name, not dataSource
        if (this.batching && name in this.meta.batchChanges) {
          return this.meta.batchChanges[name];
        }
        return dataSource in this.data ? this.data[dataSource] : this.data[name];
      },
      // no arrow functions here, need `this` to change to instance
      set(value) {
        // Since the accessor is defined on a base class, we dip into the fields map for the actual
        // calling class to get the correct field definition
        const field = this.$meta.fields.map[name];
        // Only set if field is read/write. Privately, we use setData to set its value
        if (!(field && field.readOnly)) {
          this.set(name, value);
        }
      }
    });
  }
  /**
   * Compares two values for this field and returns `true` if they are equal, and `false` if not.
   * @param {*} first The first value to compare for equality.
   * @param {*} second The second value to compare for equality.
   * @returns {Boolean} `true` if `first` and `second` are equal.
   */
  isEqual(first, second) {
    return ObjectHelper.isEqual(first, second);
  }
  /**
   * Returns the given field value as a `String`. If `value` is `null` or `undefined`, the value specified by
   * {@link #config-nullText} is returned.
   * @param {*} value The value to convert to a string.
   * @returns {String}
   */
  print(value) {
    return value == null ? this.nullText : this.printValue(value);
  }
  /**
   * Returns the given, non-null field value as a `String`.
   * @param {*} value The value to convert to a string (will not be `null` or `undefined`).
   * @returns {String}
   * @protected
   */
  printValue(value) {
    return String(value);
  }
}
DataField._$name = 'DataField';

/**
 * @module Core/data/field/ArrayDataField
 */
/**
 * This field class handles fields that hold an array.
 *
 * ```javascript
 * class Task extends Model {
 *     static get fields() {
 *         return [
 *             'name',
 *             // Array field
 *             { name : 'todo', type : 'array' }
 *         ];
 *     }
 * }
 * ```
 *
 * A record can be constructed like this:
 *
 * ```javascript
 * const task = new Task({
 *     name : 'Task 1',
 *     todo : [
 *         { text : 'Something', done : false },
 *         { text : 'Some other thing', done : true }
 *     ]
 * };
 * ```
 *
 * Or by populating a store:
 *
 * ```javascript
 * const store = new Store({
 *     modelClass : Task,
 *     data : [
 *         {
 *             name : 'Task 1',
 *             todo : [
 *                 { text : 'Something', done : false },
 *                 { text : 'Some other thing', done : true }
 *             ]
 *         },
 *         ...
 *     ]
 * });
 * ```
 *
 * For the field to count as modified, the whole array has to be replaced:
 *
 * ```javascript
 * // This won't be detected as a modification
 * task.todo[0].done = true;
 * // task.isModified === false
 *
 * // But this will
 * const todo = task.todo.slice(); // Create a new array with same contents
 * todo[0].done = true;
 * task.todo = todo;
 * // task.isModified === true
 * ```
 *
 * @extends Core/data/field/DataField
 * @classtype array
 * @datafield
 */
class ArrayDataField extends DataField {
  static $name = 'ArrayDataField';
  static type = 'array';
  isEqual(a, b) {
    return a === b;
  }
  getAt(record, index) {
    return record.get(this.name)[index];
  }
}
ArrayDataField.initClass();
ArrayDataField._$name = 'ArrayDataField';

/**
 * @module Core/data/field/BooleanDataField
 */
/**
 * This field class handles field of type `Boolean`.
 *
 * ```javascript
 * class Person extends Model {
 *     static get fields() {
 *         return [
 *             'name',
 *             { name : 'active', type : 'boolean' }
 *         ];
 *     }
 * }
 * ```
 *
 * When a field is declared as a `'boolean'`, non-null values are promoted to `Boolean` type. This is seldom required,
 * but can be useful if a field value is received as a number but should be treated as a boolean.
 *
 * @extends Core/data/field/DataField
 * @classtype boolean
 * @datafield
 */
class BooleanDataField extends DataField {
  static get $name() {
    return 'BooleanDataField';
  }
  static get type() {
    return 'boolean';
  }
  static get alias() {
    return 'bool';
  }
  static get prototypeProperties() {
    return {
      /**
       * The value to replace `null` when the field is not `nullable`.
       * @config {Boolean}
       * @default
       */
      nullValue: false
    };
  }
  isEqual(first, second) {
    if (first == null && second == null) {
      return true;
    }
    return super.isEqual(first, second);
  }
  convert(value) {
    var _value$toLowerCase;
    if (value == null) {
      return this.nullable ? value : this.nullValue;
    }
    // string 'false' will convert to false, other strings to true
    if (((_value$toLowerCase = value.toLowerCase) === null || _value$toLowerCase === void 0 ? void 0 : _value$toLowerCase.call(value)) === 'false') {
      return false;
    }
    return Boolean(value);
  }
}
BooleanDataField.initClass();
BooleanDataField._$name = 'BooleanDataField';

/**
 * @module Core/data/field/DateDataField
 */
/**
 * This field class handles field of type `Date`.
 *
 * ```javascript
 * class Person extends Model {
 *     static get fields() {
 *         return [
 *             'name',
 *             { name : 'birthday', type : 'date', format : 'YYYY-MM-DD' },
 *             { name : 'age', readOnly : true }
 *         ];
 *     }
 * }
 * ```
 *
 * When a field is declared as a `'date'`, non-null values are promoted to `Date` type. This is frequently needed due
 * to how date types are serialized to JSON strings.
 *
 * Date fields can have a special `defaultValue` of `'now'` which will convert to the current date/time.
 *
 * @extends Core/data/field/DataField
 * @classtype date
 * @datafield
 */
class DateDataField extends DataField {
  static get $name() {
    return 'DateDataField';
  }
  static get type() {
    return 'date';
  }
  static get prototypeProperties() {
    return {
      /**
       * The format of the date field.
       *
       * See {@link Core.helper.DateHelper DateHelper} for details.
       * @config {String} format
       * @default DateHelper.defaultFormat
       */
      format: null
    };
  }
  convert(value) {
    if (value == null) {
      if (!this.nullable) {
        value = this.nullValue;
      }
    } else if (value === 'now') {
      value = new Date();
    } else if (!(value instanceof Date)) {
      // Use configured format, if null/undefined use DateHelpers default format
      value = DateHelper.parse(value, this.format || DateHelper.defaultParseFormat);
      // if parsing has failed, we would like to return `undefined` to indicate the "absence" of data
      // instead of `null` (presence of "empty" data)
      if (!value || isNaN(value)) {
        value = undefined;
      }
    }
    return value;
  }
  serialize(value) {
    if (value instanceof Date) {
      // Use configured format or DateHelpers default one
      value = DateHelper.format(value, this.format || DateHelper.defaultFormat);
    }
    return value;
  }
  printValue(value) {
    return DateHelper.format(value, this.format || DateHelper.defaultFormat);
  }
}
DateDataField.initClass();
DateDataField._$name = 'DateDataField';

/**
 * @module Core/data/field/StringDataField
 */
/**
 * This field class handles field of type `String`.
 *
 * ```javascript
 * class Person extends Model {
 *     static get fields() {
 *         return [
 *             { name : 'name', type : 'string' }
 *         ];
 *     }
 * }
 * ```
 *
 * When a field is declared as a `'string'`, non-null values are promoted to `String` type. This is seldom required, but
 * can be useful if a field value is received as a number but should be treated as a string.
 *
 * @extends Core/data/field/DataField
 * @classtype string
 * @datafield
 */
class StringDataField extends DataField {
  static get $name() {
    return 'StringDataField';
  }
  static get type() {
    return 'string';
  }
  static get prototypeProperties() {
    return {
      /**
       * The value to replace `null` when the field is not `nullable`.
       * @config {String}
       * @default
       */
      nullValue: ''
    };
  }
  convert(value) {
    return value == null ? this.nullable ? value : this.nullValue : String(value);
  }
}
StringDataField.initClass();
StringDataField._$name = 'StringDataField';

/**
 * @module Core/data/field/DurationUnitDataField
 */
/**
 * This field class handles field of type `durationunit` (string type). See {@link Core.data.Duration} for more information.
 *
 * ```javascript
 * class Event extends Model {
 *     static get fields() {
 *         return [
 *             { name : 'durationUnit', type : 'durationunit' }
 *         ];
 *     }
 * }
 * ```
 *
 * @extends Core/data/field/StringDataField
 * @classtype durationunit
 * @datafield
 */
class DurationUnitDataField extends StringDataField {
  static get $name() {
    return 'DurationUnitDataField';
  }
  static get type() {
    return 'durationunit';
  }
  isEqual(first, second) {
    return DateHelper.compareUnits(first, second) === 0;
  }
}
DurationUnitDataField.initClass();
DurationUnitDataField._$name = 'DurationUnitDataField';

/**
 * @module Core/data/field/IntegerDataField
 */
/**
 * This field class handles field of type `Number` with no decimal digits.
 *
 * ```javascript
 * class Person extends Model {
 *     static get fields() {
 *         return [
 *             'name',
 *             { name : 'age', type : 'int' }
 *         ];
 *     }
 * }
 * ```
 *
 * When a field is declared as a `'int'`, non-null values are promoted to `Number` type and decimals are removed using
 * a specified `rounding`. This field type can be useful if a field value is received as a string but should be stored
 * as a number or has a fractional component that must be rounded or truncated.
 *
 * @extends Core/data/field/DataField
 * @classtype integer
 * @datafield
 */
class IntegerDataField extends DataField {
  static get $name() {
    return 'IntegerDataField';
  }
  static get type() {
    return 'integer';
  }
  static get alias() {
    return 'int';
  }
  static get prototypeProperties() {
    return {
      /**
       * The value to replace `null` when the field is not `nullable`.
       * @config {Number}
       * @default
       */
      nullValue: 0,
      /**
       * The `Math` method to use to ensure fractional component is removed.
       * @config {'round'|'floor'|'ceil'}
       * @default
       */
      rounding: 'round'
    };
  }
  convert(value) {
    return value == null ? this.nullable ? value : this.nullValue : Math[this.rounding](Number(value));
  }
}
IntegerDataField.initClass();
IntegerDataField._$name = 'IntegerDataField';

/**
 * @module Core/data/field/ModelDataField
 */
/**
 * This field class handles fields that hold other records.
 *
 * ```javascript
 * class Person extends Model {
 *     static get fields() {
 *         return [
 *             'name',
 *             { name : 'address', type : 'model' }
 *         ];
 *     }
 * }
 * ```
 *
 * @internal
 * @extends Core/data/field/DataField
 * @classtype model
 * @datafield
 */
class ModelDataField extends DataField {
  static get $name() {
    return 'ModelDataField';
  }
  static get type() {
    return 'model';
  }
  static get prototypeProperties() {
    return {
      complexMapping: true
    };
  }
  isEqual(first, second) {
    // Check for semantic equality. An instance of the same Model class of the same ID is equal.
    return first && second && second instanceof first.constructor && second.id == first.id;
  }
}
ModelDataField.initClass();
ModelDataField._$name = 'ModelDataField';

/**
 * @module Core/data/field/NumberDataField
 */
/**
 * This field class handles field of type `Number`.
 *
 * ```javascript
 * class Person extends Model {
 *     static get fields() {
 *         return [
 *             'name',
 *             { name : 'age', type : 'number' }
 *         ];
 *     }
 * }
 * ```
 *
 * When a field is declared as a `'number'`, non-null values are promoted to `Number` type. This is seldom required, but
 * can be useful if a field value is received as a string but should be treated as a number.
 *
 * @extends Core/data/field/DataField
 * @classtype number
 * @datafield
 */
class NumberDataField extends DataField {
  static get $name() {
    return 'NumberDataField';
  }
  static get type() {
    return 'number';
  }
  static get alias() {
    return 'float';
  }
  static get prototypeProperties() {
    return {
      /**
       * The value to replace `null` when the field is not `nullable`.
       * @config {Number}
       * @default
       */
      nullValue: 0,
      /**
       * The numeric precision of this field. Values are rounded to the specified number of digits. If `null`,
       * the default, no rounding is performed.
       * @config {Number}
       * @default
       */
      precision: null
    };
  }
  isEqual(first, second) {
    // NaN !== NaN in JS which results having a number field w/ such value always dirty
    // Not sure having two NaN-s not equal each other makes any sense here to us ..so handle it
    return isNaN(Number(first)) && isNaN(Number(second)) || super.isEqual(first, second);
  }
  convert(value) {
    if (value == null) {
      return this.nullable ? value : this.nullValue;
    }
    value = Number(value);
    // Returning undefined to let set know that this is a invalid value
    if (isNaN(value)) {
      return;
    }
    let scale = this.precision;
    if (scale) {
      scale = 10 ** scale;
      value = Math.round(value * scale) / scale;
    } else if (scale === 0) {
      value = Math.round(value);
    }
    return value;
  }
}
NumberDataField.initClass();
NumberDataField._$name = 'NumberDataField';

/**
 * @module Core/data/field/ObjectDataField
 */
/**
 * This field class handles fields that hold an object.
 *
 * ```javascript
 * class Person extends Model {
 *     static fields = [
 *         'name',
 *         { name : 'address', type : 'object' }
 *     ];
 * }
 * ```
 *
 * For the field to count as modified, the whole object has to be replaced:
 *
 * ```javascript
 * person.address = { ...address };
 * ```
 *
 * Or, sub properties of the object has to be modified using calls to `set()`:
 *
 * ```javascript
 * person.set('address.street', 'Main Street');
 * ```
 *
 * Note that if any property of the nested object requires conversion after load, you have to define that property as
 * a field:
 *
 * ```javascript
 * class Order extends Model {
 *     static fields = [
 *         'title',
 *         { name : 'details', type : 'object' },
 *         { name : 'details.date', type : 'date' }
 *     ];
 * }
 *
 * const order = new Order({
 *    title   : 'Order 1',
 *    details : {
 *      customer : 'Bill',
 *      // Definition above required for this to be converted to a date
 *      date     : '2020-01-01'
 *    }
 * });
 * ```
 *
 * @extends Core/data/field/DataField
 * @classtype object
 * @datafield
 */
class ObjectDataField extends DataField {
  static get $name() {
    return 'ObjectDataField';
  }
  static get type() {
    return 'object';
  }
  static get prototypeProperties() {
    return {
      complexMapping: true
    };
  }
}
ObjectDataField.initClass();
ObjectDataField._$name = 'ObjectDataField';

/**
 * @module Core/data/field/StoreDataField
 */
/**
 * This field class handles fields that accepts an array that is then converted to a store.
 *
 * ```javascript
 * class Task extends Model {
 *     static fields = [
 *         'name',
 *         // Store field
 *         { name : 'subTasks', type : 'store', storeClass : Store }
 *     ];
 * }
 * ```
 *
 * A record can be constructed like this:
 *
 * ```javascript
 * const task = new Task({
 *     name : 'Task 1',
 *     subTasks : [
 *         { text : 'Something', done : false },
 *         { text : 'Some other thing', done : true }
 *     ]
 * };
 * ```
 *
 * Or by populating a store:
 *
 * ```javascript
 * const store = new Store({
 *     modelClass : Task,
 *     data : [
 *         {
 *             name : 'Task 1',
 *             subTasks : [
 *                 { text : 'Something', done : false },
 *                 { text : 'Some other thing', done : true }
 *             ]
 *         },
 *         ...
 *     ]
 * });
 * ```
 *
 * Whenever the store or its records are manipulated, the field will be marked as modified:
 *
 * ```javascript
 * // These will all be detected as modifications
 * task.subTasks.first.done = true;
 * task.subTasks.last.remove();
 * task.subTasks.add({ text : 'New task', done : false });
 * ```
 *
 * <div class="note">Note that the underlying store by default will be configured with <code>syncDataOnLoad</code> set
 * to <code>true</code></div>
 *
 * @extends Core/data/field/DataField
 * @classtype store
 * @datafield
 */
class StoreDataField extends DataField {
  static $name = 'StoreDataField';
  static type = 'store';
  /**
   * Store class to use when creating the store.
   *
   * ```javascript
   * class TodoStore extends Store {
   *     ...
   * }
   *
   * const task = new Store({
   *     static fields = [
   *         { type : 'store', name: 'todoItems', storeClass : TodoStore }
   *     ]
   * });
   * ```
   *
   * @config {Class} storeClass
   * @typings {typeof Store}
   */
  /**
   * Model class to use for the store (can also be configured as usual on the store class, this config is for
   * convenience).
   *
   * ```javascript
   * class TodoItem extends Model {
   *   ...
   * }
   *
   * const task = new Store({
   *     static fields = [
   *         { type : 'store', name: 'todoItems', storeClass : Store, modelClass : TodoItem }
   *     ]
   * });
   * ```
   *
   * @config {Class} modelClass
   * @typings {typeof Model}
   */
  /**
   * Optional store configuration object to apply when creating the store.
   *
   * ```javascript
   * const task = new Store({
   *     static fields = [
   *         {
   *             type       : 'store',
   *             name       : 'todoItems',
   *             storeClass : Store
   *             store      : {
   *                  syncDataOnLoad : false
   *             }
   *         }
   *     ]
   * });
   * ```
   *
   * @config {StoreConfig} store
   */
  // Initializer, called when creating a record. Sets up the store and populates it with any initial data
  init(data, record) {
    var _record;
    const me = this,
      storeName = `${me.name}Store`,
      config = {
        skipStack: true,
        syncDataOnLoad: true
      }; // Optimization when used from sources, don't create a stack in Base
    if (me.store) {
      ObjectHelper.assign(config, me.store);
    }
    // Optionally apply modelClass, for convenient configuration
    if (me.modelClass) {
      config.modelClass = me.modelClass;
    }
    // Call optional initializer (initSubTasksStore for subTasks field) on the record, letting it manipulate the
    // config before creating a store
    (_record = record[`init${StringHelper.capitalize(storeName)}`]) === null || _record === void 0 ? void 0 : _record.call(record, config);
    if (!config.storeClass && !me.storeClass) {
      throw new Error(`Field '${me.name}' with type 'store' must have a storeClass configured`);
    }
    // Store has to be assigned on the record, field is shared
    const store = record.meta[storeName] = new (config.storeClass || me.storeClass)(config);
    if (me.complexMapping) {
      ObjectHelper.setPath(data, me.dataSource, store);
    } else {
      data[me.dataSource] = store;
    }
    // Don't warn about generated ids, responsibility lies elsewhere
    store.verifyNoGeneratedIds = false;
    // Keep track of if id should be included when serializing or not
    store.usesId = !store.count || !store.every(record => record.hasGeneratedId);
    // Cache value
    store.$currentValue = me.getValue(store);
    // Track changes to the store, applying them to the record and caching current value to be used when
    // serializing and in comparisons (required, otherwise we would be comparing to already updated store
    store.ion({
      change: ({
        action
      }) => {
        const value = me.getValue(store);
        if (!store.$isSettingStoreFieldData) {
          const oldPreserveCurrentDataset = store.$preserveCurrentDataset;
          store.$preserveCurrentDataset = me.subStore && (action === 'update' || action === 'remove' || action === 'add');
          me.$isUpdatingRecord = true;
          record.set(me.name, value);
          me.$isUpdatingRecord = false;
          store.$preserveCurrentDataset = oldPreserveCurrentDataset;
        }
        // cache the field current value
        store.$currentValue = value;
      }
    });
  }
  // Called when setting a new value to the field on a record
  set(value, data, record) {
    var _record2;
    const me = this,
      storeName = `${me.name}Store`,
      {
        [storeName]: store
      } = record.meta;
    // Lazy store might not be created yet, gets created on first access. Returning false keeps the value for later
    // if called during init
    if (!store) {
      // Missing store suggests value was not yet initialized and future value resides
      // in a special meta property. In which case we need to update it there
      record.meta.initableValues.set(me, value);
      return false;
    }
    // Prevent changes from leading to recursive calls
    if (store.$isSettingStoreFieldData) {
      return;
    }
    store.$isSettingStoreFieldData = true;
    // Call optional processing fn (processSubTasksStoreData for subTasks field) on the record, letting it
    // manipulate the data before creating records
    value = ((_record2 = record[`process${StringHelper.capitalize(storeName)}Data`]) === null || _record2 === void 0 ? void 0 : _record2.call(record, value, record)) ?? value;
    // Apply incoming array to store
    if (!store.$preserveCurrentDataset) {
      store.data = value;
    }
    store.$isSettingStoreFieldData = false;
    // Keep track of if id should be included when serializing or not
    store.usesId = !store.count || !store.every(record => record.hasGeneratedId);
  }
  serialize(value, record) {
    const store = record.meta[`${this.name}Store`];
    return this.$isUpdatingRecord ? this.getValue(store) : store.$currentValue;
  }
  // Extract persistable values, optionally including id depending on if ids are used
  getValue(store) {
    return store.allRecords.map(r => {
      const data = r.persistableData;
      if (!store.usesId) {
        delete data.id;
      }
      return data;
    });
  }
  isEqual(a, b) {
    var _a, _b;
    if ((_a = a) !== null && _a !== void 0 && _a.isStore) {
      a = a.$currentValue;
    }
    if ((_b = b) !== null && _b !== void 0 && _b.isStore) {
      b = b.$currentValue;
    }
    return ObjectHelper.isDeeplyEqual(a, b);
  }
  // Cloned value to be able to restore it later using STM
  getOldValue(record) {
    const store = record.meta[`${this.name}Store`];
    return store ? ObjectHelper.clone(store.$currentValue) : null;
  }
  getAt(record, index) {
    const store = record.meta[`${this.name}Store`];
    return store === null || store === void 0 ? void 0 : store.getAt(index);
  }
}
StoreDataField.initClass();
StoreDataField._$name = 'StoreDataField';

/**
 * @module Core/data/Model
 */
const nestedRe = new RegExp(/^(.*?)\.(.*)/),
  arrayRe = /(.*)\[(.*)]\.?(.*)/;
/**
 * Defines the properties of a relation between two stores.
 *
 * Used as the values of a Model's {@link Core.data.Model#property-relations-static} definition.
 *
 * This snippet will define a relation called `team`, allowing access to the foreign record via `player.team`. It will
 * point to a record in the `teamStore` (must be available as `record.firstStore.teamStore)` with an id matching the
 * players `teamId` field. The team record in turn, will have a field called `players` which is a collection of all
 * players in the team.
 *
 * ```javascript
 * class Player extends Model {
 *     static relations = {
 *         team : {
 *             foreignKey            : 'teamId',
 *             foreignStore          : 'teamStore',
 *             relatedCollectionName : 'players'
 *         }
 *     }
 * }
 * ```
 *
 * See {@link Core.data.Model#property-relations-static} for a more extensive example.
 *
 * @typedef {Object} RelationConfig
 * @property {String} foreignKey Name of a field on this model which holds the foreign key value.
 * @property {String|Core.data.Store} foreignStore Name of a property on the model's first store, which holds the
 * foreign store. Or the actual store instance
 * @property {String} [relatedCollectionName] Optionally, name of a property that will be added to the records of the
 * foreign store, which will hold all records from the model's store related to it.
 */
const {
    defineProperty: defineProperty$2
  } = Reflect,
  {
    hasOwn: hasOwn$1
  } = ObjectHelper,
  _undefined = undefined,
  internalProps = {
    children: 1,
    data: 1,
    meta: 1
  },
  abbreviationFields = ['name', 'title', 'text', 'label', 'description'],
  fieldDataTypes = {
    boolean: 1,
    number: 1,
    date: 1,
    object: 1
  },
  fieldsOrder = {
    parentId: 1,
    $PhantomId: 2,
    id: 3
  };
/**
 * A Model is the definition of a record which can be added to (or loaded into) a {@link Core.data.Store}. It defines
 * which fields the data contains and exposes an interface to access and manipulate that data. The Model data is
 * populated through simple a JSON object.
 *
 * By default, a Model stores a shallow copy of its raw json, but for records in stores configured with
 * `useRawData: true` it stores the supplied json object as is.
 *
 * ## Defining fields
 *
 * A Model can either define its fields explicitly (see {@link #property-fields-static}) or have them created from its
 * data (see {@link #property-autoExposeFields-static}). This snippet shows a model with 4 fields defined explicitly:
 *
 * ```javascript
 * class Person extends Model {
 *     static fields = [
 *         'name',
 *         { name : 'birthday', type : 'date', format : 'YYYY-MM-DD' },
 *         { name : 'shoeSize', type : 'number', defaultValue : 11 },
 *         { name : 'age', readOnly : true }
 *     ]
 * }
 * ```
 *
 * The first field (name) has an unspecified type, which means the field's value is held as received with no conversion
 * applied. The second field (birthday) is defined to be a date, which will make the model parse any supplied value into
 * an actual date. The parsing is handled by {@link Core/helper/DateHelper#function-parse-static DateHelper.parse()}
 * using the specified `format`, or if no format is specified using
 * {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat}.
 *
 * The set of standard field types is as follows:
 *
 *  - {@link Core.data.field.ArrayDataField `array`}
 *  - {@link Core.data.field.BooleanDataField `boolean`}
 *  - {@link Core.data.field.DateDataField `date`}
 *  - {@link Core.data.field.IntegerDataField `integer`}
 *  - {@link Core.data.field.ObjectDataField `object`}
 *  - {@link Core.data.field.NumberDataField `number`}
 *  - {@link Core.data.field.StoreDataField `store`}
 *  - {@link Core.data.field.StringDataField `string`}
 *
 * You can also set a `defaultValue` that will be used if the data does not contain a value for the field:
 *
 * ```javascript
 * { name : 'shoeSize', type : 'number', defaultValue : 11 }
 * ```
 *
 * To create a record from a Model, supply data to its constructor:
 *
 * ```javascript
 * let guy = new Person({
 *     id       : 1,
 *     name     : 'Dude',
 *     birthday : '2014-09-01'
 * });
 * ```
 *
 * If no id is specified, a temporary id based on a UUID will be generated. This id is not meant to be serialized, it
 * should instead be replaced by the backend with a proper id from the underlying database (or similar).
 *
 * Please avoid using reserved names for your fields (such as `parent`, `children` and others that are used as Model
 * properties) to avoid possible data collisions and bugs.
 *
 * ## Nested fields
 *
 * Model supports mapping fields to nested data structures using dot `.` separated paths as the `dataSource`. For
 * example given this JSON object:
 *
 * ```json
 * {
 *     name : 'Borje Salming',
 *     team : {
 *         name   : 'Toronto Maple Leafs',
 *         league : 'NHL'
 *     }
 * }
 * ```
 *
 * A field can be mapped to the nested team name by using `dataSource : 'team.name'`:
 *
 * ```javascript
 * class Player extends Model {
 *     static fields = [
 *         'name',
 *         // Field mapped to a property on a nested object
 *         { name : 'teamName', dataSource : 'team.name' }
 *     ];
 * }
 * ```
 *
 * Usage:
 *
 * ```javascript
 * const player = new Player(json);
 *
 * console.log(player.teamName); // > Toronto Maple Leafs
 * player.teamName = 'Minnesota Wild'; // Updates name property of the team object
 * ```
 *
 * Alternatively, you can define the top level of the nested object as a field of type `object`:
 *
 * ```javascript
 * class Person extends Model {
 *     static fields = [
 *         'name',
 *         // Nested object
 *         { name : 'address', type : 'object' }
 *     ];
 * }
 * ```
 *
 * You can then access properties of the nested object using dot notation with the {@link #function-get} function:
 *
 * ```javascript
 * const person = new Person({
 *    name    : 'Borje Salming',
 *    address : {
 *        city : 'Toronto'
 *    }
 * });
 *
 * person.get('address.city'); // > Toronto
 * ```
 *
 * ### Updating a nested object
 *
 * Note that directly altering a property of the nested object won't register as an update of the record, record does
 * not track changes deeply. If nested fields (as described above) is not enough for your usecase you can map a field
 * directly to the nested object and then assign a shallow copy of it to the record on changes:
 *
 * ```javascript
 * class Player extends Model {
 *     static get fields() {
 *         return [
 *             ...,
 *             // Field mapped directly to the nested object
 *             { name : 'team', type : 'object' }
 *         ]
 *     }
 * }
 *
 * // "External object" to nest
 * const team = {
 *     name   : 'Brynas',
 *     league : 'SHL'
 * }
 *
 * const player = new Player({
 *     name : 'Borje Salming',
 *     team
 * });
 *
 * // This will not flag player as dirty
 * team.league = 'CHL';
 *
 * // Instead you have to reassign the mapped field
 * player.team = { ...player.team };
 * ```
 *
 * You can also use the {@link #function-set} function to update a property of the nested object:
 *
 * ```javascript
 * // This will flag player as dirty
 * player.set('team.name', 'BIF');
 * ```
 *
 * ## Arrays of atomic types
 *
 * When a field holds an array of atomic types (strings, numbers etc.) we recommend using the
 * {@link Core/data/field/ArrayDataField `array`} type for the field:
 *
 * ```javascript
 * class GroceryList extends Model {
 *     static get fields() {
 *         return [
 *             'name',
 *             { name : 'items', type : 'array' }
 *         ];
 *     }
 * }
 *
 * const list = new GroceryList({
 *    name  : 'My list',
 *    items : ['Milk', 'Bread', 'Eggs']
 * });
 * ```
 *
 * {@note}Modifying items in the array will not flag the field as updated, since the array itself does not
 * change. For it to register a change, you must assign it a new array (could be a copy of the old one). For more info,
 * see {@link Core/data/field/ArrayDataField}{/@note}
 *
 * ## Arrays of objects
 *
 * When a field holds an array of objects, we recommend using the {@link Core/data/field/StoreDataField `store`} type
 * for the field:
 *
 * ```javascript
 * class GroceryList extends Model {
 *     static fields = [
 *         'name',
 *         { name : 'items', type : 'store', storeClass : Store }
 *     ]
 * }
 *
 * const list = new GroceryList({
 *    name  : 'My list',
 *    items : [
 *        { name : 'Milk', quantity : 1 },
 *        { name : 'Bread', quantity : 2 },
 *        { name : 'Eggs', quantity : 12 }
 *    ]
 * });
 * ```
 *
 * The `items` field on the `list` above will be a {@link Core.data.Store} instance (because we passed that as
 * `storeClass`), which can be used to manipulate the items in the list. Doing so will flag the `list` as modified. For
 * more info, see {@link Core.data.field.StoreDataField}.
 *
 * ## Persisting fields
 *
 * By default, all fields are persisted. If you don't want particular field to get saved to the server, configure it
 * with `persist: false`. In this case field will not be among changes which are sent by
 * {@link Core/data/AjaxStore#function-commit store.commit()}, otherwise its behavior doesn't change.
 *
 * ```javascript
 * class Person extends Model {
 *     static get fields() {
 *         return [
 *             'name',
 *             { name : 'age', persist : false }
 *         ];
 *     }
 * }
 * ```
 *
 * ## The `id` field
 * By default Model expects its id field to be stored in a data source named "id". The data source for the id field can
 * be customized by setting {@link Core/data/field/DataField#config-dataSource} on the id field object configuration.
 *
 * ```javascript
 * class Person extends Model {
 *     static fields = [
 *         { name : 'id', dataSource: 'personId'},
 *         'name',
 *         { name : 'age', persist : false },
 *         { name : 'birthday', type : 'date' }
 *      ];
 * }
 *
 * let girl = new Person({
 *     personId : 2,
 *     name     : 'Lady',
 *     birthday : '2011-11-05'
 * });
 * ```
 *
 * Also, it is possible to change the id field data source by setting {@link #property-idField-static}:
 *
 * ```javascript
 * class Person extends Model {
 *     // Id drawn from 'id' property by default; use custom field here
 *     static idField = 'personId';
 *
 *     static fields = [
 *         'name',
 *         { name : 'age', persist : false },
 *         { name : 'birthday', type : 'date' }
 *     ];
 * }
 * ```
 *
 * ## Getting and setting values
 *
 * Fields are used to generate getters and setters on the records. Use them to access or modify values (they are
 * reactive):
 *
 * ```javascript
 * console.log(guy.name);
 * girl.birthday = new Date(2011,10,6);
 * ```
 *
 * NOTE: In an application with multiple different models you should subclass Model, since the prototype is decorated
 * with getters and setters. Otherwise, you might get unforeseen collisions.
 *
 * ## Field data mapping
 *
 * By default, fields are mapped to data using their name. If you for example have a "name" field it expects data to be
 * `{ name: 'Some name' }`. If you need to map it to some other property, specify `dataSource` in your field definition:
 *
 * ```javascript
 * class Person extends Model {
 *     static get fields {
 *         return [
 *             { name : 'name', dataSource : 'TheName' }
 *         ];
 *     }
 * }
 *
 * // This is now OK:
 * let dude = new Person({ TheName : 'Manfred' });
 * console.log(dude.name); // --> Manfred
 * ```
 *
 * ## Field inheritance
 *
 * Fields declared in a derived model class are added to those from its superclass. If a field declared by a derived
 * class has also been declared by its super class, the field properties of the super class are merged with those of
 * the derived class.
 *
 * For example:
 * ```javascript
 *  class Person extends Model {
 *      static get fields() {
 *          return [
 *              'name',
 *              { name : 'birthday', type : 'date', format : 'YYYY-MM-DD' }
 *          ];
 *      }
 *  }
 *
 *  class User extends Person {
 *      static get fields() {
 *          return [
 *              { name : 'birthday', dataSource : 'dob' },
 *              { name : 'lastLogin', type : 'date' }
 *          ];
 *      }
 *  }
 * ```
 *
 * In the above, the `Person` model declares the `birthday` field as a `date` with a specified `format`. The `User`
 * model extends `Person` and also declares the `birthday` field. This redeclared field only specifies `dataSource`, so
 * all the other fields are preserved from `Person`. The `User` model also adds a `lastLogin` field.
 *
 * The `User` from above could have been declared like so to achieve the same `fields`:
 *
 * ```javascript
 *  class User extends Model {
 *      static get fields() {
 *          return [
 *              'name',
 *              { name : 'birthday', type : 'date', format : 'YYYY-MM-DD', dataSource : 'dob' },
 *              { name : 'lastLogin', type : 'date' }
 *          ];
 *      }
 *  }
 * ```
 *
 * ## Override default values
 *
 * In case you need to define default value for a specific field, or override an existing default value, you can
 * define a new or re-define an existing field definition in {@link #property-fields-static} static getter:
 *
 * ```javascript
 * class Person extends Model {
 *     static get fields() {
 *         return [
 *             { name : 'username', defaultValue : 'New person' },
 *             { name : 'birthdate', type : 'date' }
 *         ];
 *     }
 * }
 *
 * class Bot extends Person {
 *     static get fields() {
 *         return [
 *             { name : 'username', defaultValue : 'Bot' } // default value of 'username' field is overridden
 *         ];
 *     }
 * }
 * ```
 *
 * ## Read-only records
 *
 * Model has a default field called {@link #field-readOnly}, which is used to make the record read-only in the UI while
 * still allowing programmatic changes to it. Setting it to `true` will prevent it from being edited by the built-in
 * editing features (cell editing in Grid, event draging in Scheduler, task editor in Gantt etc.). Please note that it
 * is not made read-only on the data level, the record can still be manipulated by application code.
 *
 * ```javascript
 * // Prevent record from being manipulated by the user
 * record.readOnly = true;
 *
 * // Programmatic manipulation is still allowed
 * record.remove();
 * ```
 *
 * ## Tree API
 *
 * This class mixes in the {@link Core/data/mixin/TreeNode TreeNode} mixin which provides an API for tree related
 * functionality (only relevant if your store is configured to be a {@link Core/data/Store#config-tree tree}).
 *
 * @mixes Core/data/mixin/ModelLink
 * @mixes Core/data/mixin/TreeNode
 * @mixes Core/data/stm/mixin/ModelStm
 */
class Model extends Base.mixin(ModelStm, TreeNode, ModelLink) {
  static get $name() {
    return 'Model';
  }
  static get declarable() {
    return [
    /**
     * Array of defined fields for this model class. Subclasses add new fields by implementing this static
     * getter:
     *
     * ```javascript
     * // Model defining two fields
     * class Person extends Model {
     *     static get fields() {
     *         return [
     *             { name : 'username', defaultValue : 'New person' },
     *             { name : 'birthdate', type : 'date' }
     *         ];
     *     }
     * }
     *
     * // Subclass overriding one of the fields
     * class Bot extends Person {
     *     static get fields() {
     *         return [
     *             // Default value of 'username' field is overridden, any other setting from the parents
     *             // definition is preserved
     *             { name : 'username', defaultValue : 'Bot' }
     *         ];
     *     }
     * }
     * ```
     *
     * Fields in a subclass are merged with those from the parent class, making it easy to override mappings,
     * formats etc.
     *
     * @member {Array<String|ModelFieldConfig|Core.data.field.DataField>} fields
     * @readonly
     * @static
     * @category Fields
     */
    'fields'];
  }
  static get fields() {
    return [
    // The index of this item in its parent (respects filtering)
    {
      name: 'parentIndex',
      type: 'number',
      persist: false,
      internal: true
    },
    // The index of this item in its parent ghost (non-sortable) children array
    {
      name: 'orderedParentIndex',
      type: 'number',
      persist: false,
      internal: true
    },
    /**
     * Flag the record as read-only on the UI level, preventing the end user from manipulating it using editing
     * features such as cell editing and event dragging.
     *
     * Does not prevent altering the record programmatically, it can still be manipulated by application code.
     *
     * For more info, see the "Read-only records" section above.
     *
     * @field {Boolean} readOnly
     * @category Common
     */
    {
      name: 'readOnly',
      type: 'boolean'
    },
    /**
     * Start expanded or not (only valid for tree data)
     * @readonly
     * @field {Boolean} expanded
     * @category Tree
     */
    {
      name: 'expanded',
      internal: true
    }];
  }
  /**
   * Override in a subclass of Model to define relations to records in other stores.
   *
   * Always defined on the "one" side, not the "many" side.
   *
   * Expects an object where keys are relation names and values are {@link #typedef-RelationConfig relation configs}.
   *
   * This snippet will define a relation called `team`, allowing access to the foreign record via `player.team`. It
   * will point to a record in the `teamStore` (must be available as `record.firstStore.teamStore)` with an id
   * matching the players `teamId` field. The team record in turn, will have a field called `players` which is a
   * collection of all players in the team.
   *
   * ```javascript
   * class Player extends Model {
   *     static relations = {
   *         // Define a relation between a player and a team
   *         team : {
   *             foreignKey            : 'teamId',
   *             foreignStore          : 'teamStore',
   *             relatedCollectionName : 'players'
   *         }
   *     }
   * }
   *
   * const teamStore = new Store({
   *     data : [
   *         { id : 1, name : 'Brynas' },
   *         { id : 2, name : 'Leksand' }
   *     ]
   * });
   *
   * const playerStore = new Store({
   *     modelClass : Player,
   *     // Matches foreignStore, allowing records of playerStore to find the related store
   *     teamStore,
   *     data       : [
   *         // teamId is specified as foreignKey, will be used to match the team
   *         { id : 1, name : 'Nicklas Backstrom', teamId : 1  },
   *         { id : 2, name : 'Elias Lindholm',   teamId : 1  },
   *         { id : 3, name : 'Filip Forsberg',  teamId : 2  }
   *     ],
   * }
   *
   * playerStore.first.team.name // > Brynas
   * playerStore.last.team.name // > Leksand
   * teamStore.first.players // > [nick, elias]
   * teamStore.last.players // > [filip]
   * ```
   *
   * To access the related record from the many side, use dot notation for the field name. For example in a Grid
   * column:
   *
   * ```javascript
   * const grid = new Grid({
   *    store : playerStore,
   *    columns : [
   *        { field : 'name', text : 'Name' },
   *        { field : 'team.name', text : 'Team' }
   *    ]
   * });
   * ```
   *
   * @member {Object<String,RelationConfig>} relations
   * @static
   */
  static relations = null;
  /**
   * Template static getter which is supposed to be overridden to define default field values for the Model class.
   * Overrides `defaultValue` config specified by the {@link #property-fields-static} getter.
   * Returns a named object where key is a field name and value is a default value for the field.
   *
   * NOTE: This is a legacy way of defining default values, we recommend using {@link #property-fields-static} moving
   * forward.
   *
   * ```javascript
   * class Person extends Model {
   *     static get fields() {
   *         return [
   *             { name : 'username', defaultValue : 'New person' }
   *         ];
   *     }
   * }
   *
   * class Bot extends Person {
   *     static get defaults() {
   *         return {
   *             username : 'Bot' // default value of 'username' field is overridden
   *         };
   *     }
   * }
   * ```
   *
   * @member {Object} defaults
   * @static
   * @category Fields
   */
  /**
   * The data source for the id field which provides the ID of instances of this Model.
   * @property {String}
   * @category Fields
   */
  static set idField(idField) {
    this._assignedIdField = true;
    this._idField = idField;
  }
  static get idField() {
    return this._idField;
  }
  /**
   * The name of the data field which holds children of this Model when used in a tree structure
   * ```javascript
   * MyModel.childrenField = 'kids';
   * const parent = new MyModel({
   *     name : 'Dad',
   *     kids : [
   *         { name : 'Daughter' },
   *         { name : 'Son' }
   *     ]
   * });
   * ```
   * @property {String}
   * @category Fields
   */
  static set childrenField(childrenField) {
    this._childrenField = childrenField;
  }
  static get childrenField() {
    if (!this._childrenField) {
      const dataField = this.fieldMap.children;
      this._childrenField = (dataField === null || dataField === void 0 ? void 0 : dataField.dataSource) || 'children';
    }
    return this._childrenField;
  }
  /**
   * Returns index path to this node. This is the index of each node in the node path
   * starting from the topmost parent. (only relevant when its part of a tree store).
   * @returns {Number[]} The index of each node in the path from the topmost parent to this node.
   * @category Parent & children
   * @private
   */
  get indexPath() {
    const indices = [];
    let node = this,
      depth = node.childLevel;
    for (node = this; node && !node.isRoot; node = node.parent) {
      indices[depth--] = node.parentIndex + 1;
    }
    return indices;
  }
  /**
   * Unique identifier for the record. Might be mapped to another dataSource using idField, but always exposed as
   * record.id. Will get a generated value if none is specified in records data.
   *
   * {@note}Note that generated ids are meant to be temporary (phantom ids), they should not be serialized
   * but instead replaced by the backend on commit{/@note}
   *
   * @field {String|Number} id
   * @category Common
   */
  //region Init
  /**
   * Constructs a new record from the supplied data config.
   * @param {Object} [config] Raw model config
   * @param {Core.data.Store} [store] Data store
   * @param {Object} [meta] Meta data
   * @privateparam {Boolean} [skipExpose] Skip exposing properties from data
   * @privateparam {Boolean} [forceUseRaw] Force using raw data, used by copy to not clone data twice
   * @function constructor
   * @category Lifecycle
   */
  construct(config = {}, store = null, meta = null, skipExpose = false, forceUseRaw = false, rawData = false) {
    var _me$meta$initableValu;
    const me = this,
      stores = ArrayHelper.asArray(store) ?? [],
      {
        constructor,
        fieldMap
      } = me;
    // null passed to Base construct inhibits config processing.
    let configs = null;
    store = stores[0];
    me.meta = {
      modified: {},
      ...constructor.metaConfig,
      ...meta
    };
    // Should apply configs?
    if (constructor.applyConfigs) {
      // Extract from data and combine with defaultConfigs
      for (const key in me.getDefaultConfiguration()) {
        if (!configs) {
          // if (first config)
          configs = {};
          if (!me.useRawData || !me.useRawData.enabled) {
            // Shallow copy of data to not mutate incoming object
            config = {
              ...config
            };
          }
        }
        // Loop through configs excluding fields
        if (key in config) {
          // Let defaults override any config supplied with an `undefined` value
          if (config[key] !== undefined) {
            // Use as config
            configs[key] = config[key];
          }
          // Always remove config from data
          delete config[key];
        }
      }
    }
    super.construct(configs);
    // make getters/setters for fields, needs to be done before processing data to make sure defaults are available
    if (!skipExpose) {
      constructor.exposeProperties(config, rawData);
    }
    // It's only valid to do this once, on construction of the first instance
    if (!hasOwn$1(constructor, 'idFieldProcessed')) {
      // idField can be overridden from meta, or from the store if we have not had an idField set programmatically
      // and if we have not had an id field defined above the base Model class level.
      let overriddenIdField = me.meta.idField;
      if (!overriddenIdField) {
        // Might have been set to Model after construction but before load
        if (constructor._assignedIdField) {
          overriddenIdField = constructor.idField;
        } else if (store) {
          overriddenIdField = store.idField;
        }
      }
      // If it's overridden to something different than we already have, replace the 'id' field in the fieldMap
      if (overriddenIdField && overriddenIdField !== fieldMap.id.dataSource) {
        constructor.addField({
          name: 'id',
          dataSource: overriddenIdField,
          internal: true
        });
      }
      // Model.idField should always reflect the idField mapping
      constructor._idField = fieldMap.id.dataSource;
      constructor.idFieldProcessed = true;
    }
    // assign internalId, unique among all records
    me._internalId = Model._internalIdCounter++;
    // relation code expects store to be available for relation lookup, but actual join done below
    me.stores = [];
    me.unjoinedStores = [];
    // Superclass constructors may set this in their own way before this is called.
    if (!me.originalData) {
      me.originalData = config;
    }
    me.data = constructor.processData(config, false, store, me, forceUseRaw);
    // Assign any intiable value last, so that it can reference this record if needed
    ((_me$meta$initableValu = me.meta.initableValues) === null || _me$meta$initableValu === void 0 ? void 0 : _me$meta$initableValu.size) && me.assignInitables();
    // Consider undefined and null as missing id and generate one
    if (me.id == null) {
      // Assign a generated id silently, record should not be considered modified
      me.setData('id', me.generateId(store));
    }
    if (me.data[constructor.childrenField]) {
      me.processChildren(stores);
    }
    me.generation = 0;
  }
  /**
   * Set this property to `true` when adding a record on a conditional basis, that is, it is yet
   * to be confirmed as an addition.
   *
   * When this is set, the {@link #property-isPersistable} value of the record is **false**, and upon being
   * added to a Store it will *not* be eligible to be synced with the server as an added record.
   *
   * Subsequently, *clearing* this property means this record will become persistable and eligible
   * for syncing as an added record.
   * @property {Boolean}
   * @category Editing
   */
  set isCreating(isCreating) {
    const me = this;
    // A no-change must not have any effect.
    if (Boolean(me.meta.isCreating) !== isCreating) {
      // This flag contributes to the evaluation of isPersistable.
      // A record is not persistable if it isCreating.
      me.meta.isCreating = isCreating;
      // Owning Stores may have things to do at this lifecycle point
      me.stores.forEach(s => {
        s.onIsCreatingToggle(me, isCreating);
      });
    }
  }
  get isCreating() {
    return Boolean(this.meta.isCreating);
  }
  /**
   * Compares this Model instance to the passed instance. If they are of the same type, and all fields
   * (except, obviously, `id`) are equal, this returns `true`.
   * @param {Core.data.Model} other The record to compare this record with.
   * @returns {Boolean} `true` if the other is of the same class and has all fields equal.
   * @category Misc
   */
  equals(other) {
    if (other instanceof this.constructor) {
      for (let fields = this.$meta.fields.defs, i = 0, {
          length
        } = fields; i < length; i++) {
        const field = fields[i],
          {
            name
          } = field;
        if (name !== 'id' && !field.isEqual(this.getValue(name), other.getValue(name))) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  get subclass() {
    return new this.constructor(Object.setPrototypeOf({
      id: _undefined
    }, this.data), this.stores[0], null, true);
  }
  /**
   * Processes raw data, converting values and setting defaults.
   * @private
   * @param {Object} data Raw data
   * @param {Boolean} [ignoreDefaults] Ignore setting default values, used when updating
   * @returns {Object} Processed data
   * @category Fields
   */
  static processData(data, ignoreDefaults = false, store, record, forceUseRaw) {
    const {
        fieldMap,
        defaultValues
      } = this,
      {
        useRawData = {
          enabled: false
        }
      } = store || {},
      // Store configured with useRawData uses the supplied data object, polluting it. When not configured with
      // useRawData it instead makes a copy (intentionally deep, in case data has a prototype chain or contains
      // arrays or objects)
      processed = forceUseRaw || useRawData.enabled ? data : ObjectHelper.clone(data);
    let fieldName;
    ignoreDefaults = ignoreDefaults || useRawData.disableDefaultValue || forceUseRaw;
    if (!ignoreDefaults) {
      for (fieldName in defaultValues) {
        if (processed[fieldName] === _undefined) {
          let defaultValue = defaultValues[fieldName];
          // Avoid sharing arrays across instances
          if (Array.isArray(defaultValue)) {
            defaultValue = defaultValue.slice();
          }
          processed[fieldName] = defaultValue;
        }
      }
    }
    if (!useRawData.disableTypeConversion && !forceUseRaw) {
      // Convert field types which need converting
      for (fieldName in fieldMap) {
        const field = fieldMap[fieldName],
          {
            name,
            dataSource
          } = field,
          // Value might have been supplied either using mapped dataSource (when loading JSON etc. for example
          // event.myStartDate) or as field name (from internal code, for example event.startDate). If [name]
          // exists but not [dataSource], use it.
          hasSource = dataSource !== name,
          complex = field.complexMapping,
          sourceExists = hasSource && (complex ? ObjectHelper.pathExists(data, dataSource) : dataSource in data),
          useNameForValue = name in data && (!hasSource || !sourceExists),
          convert = !useRawData.disableTypeConversion && field.convert;
        // Only action field definitions which have a convert function or remap data
        if (useNameForValue || convert) {
          // When ignoringDefaults, do not convert unspecified values
          if (!ignoreDefaults || useNameForValue || sourceExists) {
            const value = useNameForValue ? processed[name] : complex ? ObjectHelper.getPath(processed, dataSource) : processed[dataSource],
              converted = convert ? field.convert(value, data, record) : value;
            if (complex) {
              ObjectHelper.setPath(processed, dataSource, converted);
            } else {
              processed[dataSource] = converted;
            }
            // Remove [startDate] from internal data holder, only keeping [myStartDate]
            if (hasSource) {
              delete processed[name];
            }
          }
        }
      }
    }
    // Fields that needs initializing
    this.$meta.fields.initable.length && this.initInitables(record, processed);
    return processed;
  }
  static setupClass(meta) {
    super.setupClass(meta);
    if (!meta.fields) {
      // Normally setupFields will only run when a Model defines a fields getter, but we want to always run it:
      this.setupFields(this, meta);
    }
  }
  static setupFields(cls, meta) {
    const classFields = hasOwn$1(cls, 'fields') && cls.fields,
      base = meta.super.fields,
      fieldsInfo = meta.fields = {
        defs: (base === null || base === void 0 ? void 0 : base.defs.slice()) ?? [],
        // Set to true when an instance's data object is run through exposeProperties
        exposedData: false,
        // These objects are all keyed by field name:
        defaults: base ? {
          ...base.defaults
        } : {},
        // value=field.defaultValue
        exposed: Object.create((base === null || base === void 0 ? void 0 : base.exposed) ?? null),
        // value=true if we've done defineProperty
        ordinals: Object.create((base === null || base === void 0 ? void 0 : base.ordinals) ?? null),
        // value=index in the defs array
        map: Object.create((base === null || base === void 0 ? void 0 : base.map) ?? null),
        // value=definition object
        sources: Object.create((base === null || base === void 0 ? void 0 : base.sources) ?? null) // value=source definition object
      };
    // We use Object.create(null) as the base for these maps because some models declare "constructor" as a field
    // NOTE: instead of chaining the defaults, we copy them so the defaults object can be used with Object.assign
    // in other contexts (since it does not copy inherited properties from the prototype chain)
    // Clone the superclass's defaults, and override that with our own defaults.
    // As we find fields with a defaultValue, more defaults may be added
    if (hasOwn$1(cls, 'defaults')) {
      Object.assign(fieldsInfo.defaults, cls.defaults);
    }
    // Hook up our field maps with the class hierarchy's fieldMaps.
    // We need to be able to look up field definitions by the name, or by the dataSource property name
    // If the idField is overridden at this level, create a new field
    if (hasOwn$1(cls, 'idField')) {
      cls.addField({
        name: 'id',
        dataSource: cls.idField,
        internal: true
      });
      fieldsInfo.exposed[cls.idField] = true;
    }
    // Process fields defined in the class definition
    if (classFields !== null && classFields !== void 0 && classFields.length) {
      classFields.map(cls.addField, cls);
    }
    // Collect fields that need to be initialized (StoreDataField for example)
    fieldsInfo.initable = fieldsInfo.defs.filter(field => field.init);
    cls.exposeRelations();
  }
  static get defaultValues() {
    return this.$meta.fields.defaults;
  }
  /**
   * An array containing all the _defined_ fields for this Model class. This will include all superclass's
   * defined fields.
   * @property {Core.data.field.DataField[]}
   * @static
   * @readonly
   * @category Fields
   */
  static get allFields() {
    return this.$meta.fields.defs;
  }
  /**
   * Same as {@link #property-allFields-static}.
   * @property {Core.data.field.DataField[]}
   * @readonly
   * @category Fields
   */
  get allFields() {
    return this.$meta.fields.defs;
  }
  /**
   * An object containing all the _defined_ fields for this Model class. This will include all superclass's
   * defined fields through its prototype chain. So be aware that `Object.keys` and `Object.entries` will only
   * access this class's defined fields.
   * @property {Object<String,Core.data.field.DataField>}
   * @static
   * @readonly
   * @category Fields
   */
  static get fieldMap() {
    return this.$meta.fields.map;
  }
  /**
   * Same as {@link #property-fieldMap-static}.
   * @property {Object<String,Core.data.field.DataField>}
   * @readonly
   * @category Fields
   */
  get fieldMap() {
    return this.$meta.fields.map;
  }
  static get fieldDataSourceMap() {
    return this.$meta.fields.sources;
  }
  /**
   * Makes getters and setters for fields (from definitions and data). Called once when class is defined and once when
   * data is loaded first time.
   * @internal
   * @param {Object} [data] Raw data
   * @param {Boolean} [raw=true] True if data is raw (contains data sources), False if data contains field names
   * @category Fields
   */
  static exposeProperties(data, raw = true) {
    const me = this,
      fieldsInfo = me.$meta.fields,
      // exposeProperties method is called from two different places: from the model constructor which receives
      // field names, and from store loadData method, which handles raw data. When loading data to store we need
      // to use names as specified in the dataSource. And when calling a model constructor we need to use field
      // names
      fieldMapProperty = raw ? 'exposed' : 'map';
    // Process the raw data properties and expose them as fields unless the property name
    // has already been used by the "dataSource" of a defined field.
    if (data && me.autoExposeFields && !fieldsInfo.exposedData) {
      let dataProperty, fieldDef, type;
      for (dataProperty in data) {
        // We need to skip children field because it can be `true` and that would create boolean field.
        // See https://github.com/bryntum/support/issues/2705
        if (!fieldsInfo[fieldMapProperty][dataProperty] && dataProperty !== me.childrenField) {
          type = ObjectHelper.typeOf(data[dataProperty]);
          // Create a field definition in our fieldMap with the flag that it's from data
          fieldDef = {
            name: dataProperty,
            dataSource: dataProperty,
            fromData: true
          };
          if (fieldDataTypes[type]) {
            fieldDef.type = type;
          }
          me.addField(fieldDef);
        }
      }
      fieldsInfo.exposedData = true;
    }
    me.exposeRelations();
  }
  /**
   * Add a field definition in addition to those predefined in `fields`.
   * @param {String|ModelFieldConfig} fieldDef A field name or definition
   * @category Fields
   */
  static addField(fieldDef) {
    if (fieldDef == null) {
      return;
    }
    if (typeof fieldDef === 'string') {
      fieldDef = {
        name: fieldDef
      };
    }
    const me = this.initClass(),
      fieldsInfo = me.$meta.fields,
      {
        ordinals
      } = fieldsInfo,
      propertiesExposed = fieldsInfo.exposed,
      {
        name
      } = fieldDef,
      existing = fieldsInfo.map[name],
      dataSource = fieldDef.dataSource || (fieldDef.dataSource = name);
    let field, key;
    if (!existing || fieldDef.type && fieldDef.type !== existing.type) {
      field = DataField.create(fieldDef);
      field.definedBy = existing ? existing.definedBy : me;
      field.ordinal = existing ? existing.ordinal : ordinals[name] = fieldsInfo.defs.length;
    } else {
      field = Object.create(existing);
      for (key in fieldDef) {
        if (key !== 'type') {
          field[key] = fieldDef[key];
        }
      }
    }
    field.owner = me;
    fieldsInfo.defs[field.ordinal] = field;
    fieldsInfo.map[name] = field;
    if (!fieldsInfo.sources[dataSource]) {
      fieldsInfo.sources[dataSource] = field;
    }
    // With complex mapping avoid exposing object as model field
    if (dataSource.includes('.')) {
      field.complexMapping = true;
    }
    if (field.complexMapping) {
      // model fields have this set on their prototype...
      propertiesExposed[dataSource.split('.')[0]] = true;
    } else {
      // When iterating through the raw data, if autoExposeFields is set
      // We do not need to create properties for raw property names we've processed here
      propertiesExposed[dataSource] = true;
    }
    // Maintain an object of defaultValues for fields.
    if ('defaultValue' in field) {
      fieldsInfo.defaults[dataSource] = field.defaultValue;
    }
    // Create a property on this Model's prototype, named for the defined field name
    // which reads the correct property out of the raw data object.
    if (!internalProps[name]) {
      // Either creates a new accessor or redefines an existing
      field.defineAccessor(me.prototype);
    }
    me._nonPersistableFields = null;
    me._alwaysWriteFields = null;
    return field;
  }
  /**
   * Remove a field definition by name.
   * @param {String} fieldName Field name
   * @category Fields
   */
  static removeField(fieldName) {
    const me = this.initClass(),
      fieldsInfo = me.$meta.fields,
      definition = fieldsInfo.map[fieldName],
      {
        ordinals
      } = fieldsInfo,
      index = ordinals[fieldName];
    if (definition) {
      fieldsInfo.defs.splice(index, 1);
      delete ordinals[fieldName];
      delete fieldsInfo.defaults[fieldName];
      delete fieldsInfo.exposed[fieldName];
      delete fieldsInfo.map[fieldName];
      delete fieldsInfo.sources[definition.dataSource];
      for (const name in ordinals) {
        if (ordinals[name] > index) {
          --ordinals[name];
        }
      }
      // Note: if field was exposed by superclass, this won't do anything...
      delete me.prototype[fieldName];
    }
  }
  /**
   * Makes getters and setters for related records. Populates a Model#relation array with the relations, to allow it
   * to be modified later when assigning stores.
   * @internal
   * @category Relations
   */
  static exposeRelations() {
    const me = this;
    if (hasOwn$1(me, 'exposedRelations')) {
      return;
    }
    if (me.relations) {
      me.exposedRelations = [];
      for (const relationName in me.relations) {
        const relation = me.relations[relationName];
        relation.relationName = relationName;
        me.exposedRelations.push(relation);
        // getter and setter for related object
        if (!Reflect.ownKeys(me.prototype).includes(relationName)) {
          defineProperty$2(me.prototype, relationName, {
            enumerable: true,
            get: function () {
              // noinspection JSPotentiallyInvalidUsageOfClassThis
              return this.getForeign(relationName);
            },
            set: function (value) {
              // noinspection JSPotentiallyInvalidUsageOfClassThis
              this.setForeign(relationName, value, relation);
            }
          });
        }
      }
    }
  }
  //endregion
  //region Initable fields
  // Initializes any fields using a data type that has an init method, and caches the value to assign to that field to
  // be able to assign it after all others. That allows the initter to reference the records other data if needed
  // (baselines use that to reference the task to get default values)
  static initInitables(record, processedData) {
    const laterValues = record.meta.initableValues = new Map();
    // Initialize any initializable fields (only StoreDataField currently)
    for (const field of this.$meta.fields.initable) {
      // Set data (if any) later, in case it needs to reference this record
      const value = ObjectHelper.getPath(processedData, field.dataSource);
      value !== undefined && laterValues.set(field, value);
      // Init field if not lazy, if lazy app is responsible for doing it
      !field.lazy && field.init(processedData, record);
    }
  }
  // Assigns values to the fields that were initialized earlier (see initInitables above)
  assignInitables() {
    const {
      initableValues
    } = this.meta;
    for (const [field, value] of initableValues) {
      if (field.set(value, this.data, this) !== false) {
        initableValues.delete(field);
      }
    }
  }
  //endregion
  //region Fields
  /**
   * Flag checked from Store when loading data that determines if fields found in first records should be exposed in
   * same way as predefined fields.
   *
   * {@note}Note that we for all but the most basic use cases recommend explicitly defining the fields.
   * Having them auto exposed can lead to unexpected behavior, if the first record is not complete (fields missing,
   * null etc).
   * {/@note}
   *
   * @property {Boolean}
   * @category Fields
   */
  static get autoExposeFields() {
    return true;
  }
  /**
   * This function forces correct field order. Correct order is parentId before id. If we process id field before
   * parentId, idMap won't be updated and changing parent node will lead to duplicated records in storage
   * @param {String} a
   * @param {String} b
   * @returns {number}
   * @private
   */
  static fieldSorter(a, b) {
    return (fieldsOrder[a] || 100) - (fieldsOrder[b] || 100);
  }
  /**
   * Convenience getter to get field definitions from class.
   * @property {Core.data.field.DataField[]}
   * @readonly
   * @category Fields
   */
  get fields() {
    return this.$meta.fields.defs;
  }
  /**
   * Convenience function to get the definition for a field from class.
   * @param {String} fieldName Field name
   * @returns {Core.data.field.DataField}
   * @category Fields
   */
  getFieldDefinition(fieldName) {
    return this.$meta.fields.map[fieldName];
  }
  getFieldDefinitionFromDataSource(dataSource) {
    return this.$meta.fields.sources[dataSource];
  }
  /**
   * Get the names of all fields in data.
   * @property {String[]}
   * @readonly
   * @category Fields
   */
  get fieldNames() {
    return Object.keys(this.data);
  }
  /**
   * Get the definition for a field by name. Caches results.
   * @param {String} fieldName Field name
   * @returns {Core.data.field.DataField} Field definition or null if none found
   * @category Fields
   */
  static getFieldDefinition(fieldName) {
    return this.$meta.fields.map[fieldName];
  }
  /**
   * Returns dataSource configuration for a given field name
   * @param {String} fieldName
   * @returns {String} Field `dataSource` mapping
   * @internal
   */
  static getFieldDataSource(fieldName) {
    var _this$getFieldDefinit;
    return ((_this$getFieldDefinit = this.getFieldDefinition(fieldName)) === null || _this$getFieldDefinit === void 0 ? void 0 : _this$getFieldDefinit.dataSource) || fieldName;
  }
  /**
   * Get the data source used by specified field. Returns the fieldName if no data source specified.
   * @param {String} fieldName Field name
   * @returns {String}
   * @category Fields
   */
  getDataSource(fieldName) {
    const def = this.constructor.getFieldDefinition(fieldName);
    return (def === null || def === void 0 ? void 0 : def.dataSource) || (def === null || def === void 0 ? void 0 : def.name);
  }
  /**
   * Processes input to a field, converting to expected type.
   * @param {String} fieldName Field name
   * @param {*} value Value to process
   * @returns {*} Converted value
   * @category Fields
   */
  static processField(fieldName, value, record) {
    const field = this.fieldMap[fieldName];
    return field !== null && field !== void 0 && field.convert ? field.convert(value, this.data, record) : value;
  }
  //endregion
  //region Relations
  /**
   * Initializes model relations. Called from store when adding a record.
   * @private
   * @category Relations
   */
  initRelations() {
    const me = this,
      relations = me.constructor.exposedRelations;
    if (!relations) {
      return;
    }
    me.stores.forEach(store => {
      var _store$modelRelations;
      if (!store.modelRelations) {
        store.initRelations();
      }
      const relatedRecords = [];
      (_store$modelRelations = store.modelRelations) === null || _store$modelRelations === void 0 ? void 0 : _store$modelRelations.forEach(config => {
        relatedRecords.push({
          related: me.initRelation(config),
          config
        });
      });
      store.updateRecordRelationCache(me, relatedRecords);
    });
  }
  /**
   * Initializes/updates a single relation.
   * @param config Relation config
   * @returns {Core.data.Model} Related record
   * @private
   * @category Relations
   */
  initRelation(config) {
    const me = this,
      foreignId = me.get(config.foreignKey),
      foreign = foreignId !== _undefined && typeof config.foreignStore !== 'string' && config.foreignStore.getById(foreignId),
      relationCache = me.meta.relationCache || (me.meta.relationCache = {});
    // apparently scheduler tests expect cache to work without matched related record, thus the placeholder
    relationCache[config.relationName] = foreign || (foreignId != null ? {
      id: foreignId,
      placeHolder: true
    } : null);
    return foreign;
  }
  removeRelation(config) {
    const {
      relationName,
      foreignKey,
      nullFieldOnRemove
    } = config;
    // (have to check for existence before deleting to work in Safari)
    if (this.meta.relationCache[relationName]) {
      delete this.meta.relationCache[relationName];
      if (nullFieldOnRemove) {
        // Setting to null silently, to not trigger additional relation behaviour
        this.setData(foreignKey, null);
      }
    }
  }
  getForeign(name) {
    var _this$meta$relationCa;
    return (_this$meta$relationCa = this.meta.relationCache) === null || _this$meta$relationCa === void 0 ? void 0 : _this$meta$relationCa[name];
  }
  setForeign(name, value, config) {
    const id = Model.asId(value);
    return this.set(config.foreignKey, id);
  }
  /**
   * Get a relation config by name, from the first store.
   * @param {String} name
   * @returns {Object}
   * @private
   * @category Relations
   */
  getRelationConfig(name) {
    var _this$firstStore, _this$firstStore$mode;
    //?
    // Using first store for relations, might have to revise later...
    return (_this$firstStore = this.firstStore) === null || _this$firstStore === void 0 ? void 0 : (_this$firstStore$mode = _this$firstStore.modelRelations) === null || _this$firstStore$mode === void 0 ? void 0 : _this$firstStore$mode.find(r => r.foreignKey === name);
  }
  //endregion
  //region Get/set values, data handling
  flatGet(fieldName, dataSource) {
    // NOTE: There is an inlined copy of this fn in DataField, when changing here make sure it is updated too
    // When changes are batched, they get stored by field name, not dataSource
    if (this.batching && fieldName in this.meta.batchChanges) {
      return this.meta.batchChanges[fieldName];
    }
    return dataSource in this.data ? this.data[dataSource] : this.data[fieldName];
  }
  complexGet(fieldName, dataSource) {
    // When changes are batched, they get stored by field name, not dataSource
    if (this.batching && fieldName in this.meta.batchChanges) {
      return this.meta.batchChanges[fieldName];
    }
    return ObjectHelper.getPath(this.data, dataSource);
  }
  /**
   * Get value for specified field name. You can also use the generated getters if loading through a Store.
   * If model is currently in batch operation this will return updated batch values which are not applied to Model
   * until endBatch() is called.
   * @param {String} fieldName Field name to get value from
   * @returns {*} Fields value
   * @category Fields
   */
  get(fieldName) {
    if (!fieldName) {
      return;
    }
    const me = this,
      field = me.fieldMap[fieldName];
    if (!field) {
      // team.players[0], team.players[0].name
      if (fieldName.includes('[')) {
        const [, arrayFieldName, index, path] = fieldName.match(arrayRe);
        // team
        const arrayField = me.fieldMap[arrayFieldName];
        if (arrayField !== null && arrayField !== void 0 && arrayField.getAt) {
          // Access the field to make sure it is initialized if lazy
          me._thisIsAUsedExpression(me[arrayFieldName]);
          // 0
          const subRecord = arrayField.getAt(me, index);
          // name
          if (subRecord && path) {
            if (subRecord.isModel) {
              return subRecord.getValue(path);
            }
            return subRecord[path];
          }
          return subRecord;
        }
        return null;
      }
      if (fieldName.includes('.')) {
        // Related record?
        if (!ObjectHelper.hasPath(me.data, fieldName)) {
          return ObjectHelper.getPath(me, fieldName);
        }
        // Nested data object
        return me.complexGet(fieldName, fieldName);
      }
    }
    if (field !== null && field !== void 0 && field.complexMapping) {
      return me.complexGet(fieldName, field.dataSource);
    }
    return me.flatGet(fieldName, (field === null || field === void 0 ? void 0 : field.dataSource) || fieldName);
  }
  // Used to get field values, replaces `record[fieldName]` in internal code to allow relations etc.
  getValue(fieldName) {
    if (!fieldName) {
      return;
    }
    // Try matching "user defined" getters
    if (fieldName in this) {
      return this[fieldName];
    }
    // Fall back to normal get
    return this.get(fieldName);
  }
  // Used to set field values, replacing `record[fieldName] = value` to handle dot notation
  setValue(fieldName, value) {
    if (fieldName in this) {
      this[fieldName] = value;
    } else {
      this.set(fieldName, value);
    }
  }
  /**
   * Internal function used to update a records underlying data block (record.data) while still respecting field
   * mappings. Needed in cases where a field needs setting without triggering any associated behaviour and it has a
   * dataSource with a different name.
   *
   * For example:
   * ```javascript
   * // startDate mapped to data.beginDate
   * { name : 'startDate', dataSource : 'beginDate' }
   *
   * // Some parts of our code needs to update the data block without triggering any of the behaviour associated with
   * // calling set. This would then not update "beginDate":
   * record.data.startDate = xx;
   *
   * // But this would
   * record.setData('startDate', xx);
   * ```
   * @internal
   * @category Editing
   */
  setData(toSet, value) {
    const {
      data,
      fieldMap
    } = this;
    // Two separate paths for performance reasons
    // setData('name', 'Quicksilver');
    if (typeof toSet === 'string') {
      const field = fieldMap[toSet],
        dataSource = (field === null || field === void 0 ? void 0 : field.dataSource) ?? toSet;
      if (field !== null && field !== void 0 && field.set) {
        field.set(value, this.data, this);
      } else if (field !== null && field !== void 0 && field.complexMapping) {
        ObjectHelper.setPath(data, dataSource, value);
      } else {
        data[dataSource] = value;
      }
    }
    // setData({ name : 'Magneto', power : 'Magnetism' });
    else {
      const keys = Object.keys(toSet);
      for (let i = 0; i < keys.length; i++) {
        const fieldName = keys[i],
          field = fieldMap[fieldName],
          dataSource = (field === null || field === void 0 ? void 0 : field.dataSource) ?? fieldName;
        if (field !== null && field !== void 0 && field.set) {
          field.set(value, this.data, this);
        } else if (dataSource) {
          if (field !== null && field !== void 0 && field.complexMapping) {
            ObjectHelper.setPath(data, dataSource, toSet[fieldName]);
          } else {
            data[dataSource] = toSet[fieldName];
          }
        }
      }
    }
  }
  /**
   * Returns raw data from the encapsulated data object for the passed field name
   * @param {String} fieldName The field to get data for.
   * @returns {*} The raw data value for the field.
   * @category Editing
   */
  getData(fieldName) {
    const field = this.fieldMap[fieldName],
      dataSource = (field === null || field === void 0 ? void 0 : field.dataSource) ?? fieldName;
    if (dataSource) {
      if (field !== null && field !== void 0 && field.complexMapping) {
        return ObjectHelper.getPath(this.data, dataSource);
      }
      return this.data[dataSource];
    }
  }
  /**
   * Silently updates record's id with no flagging the property as modified.
   * Triggers onModelChange event for changed id.
   * @param {String|Number} value id value
   * @private
   */
  syncId(value) {
    const oldValue = this.id;
    if (oldValue !== value) {
      this.setData('id', value);
      const data = {
        id: {
          value,
          oldValue
        }
      };
      this.afterChange(data, data);
    }
  }
  /**
   * Set value for the specified field. You can also use the generated setters if loading through a Store.
   *
   * Setting a single field, supplying name and value:
   *
   * ```javascript
   * record.set('name', 'Clark');
   * ```
   *
   * Setting multiple fields, supplying an object:
   *
   * ```javascript
   * record.set({
   *     name : 'Clark',
   *     city : 'Metropolis'
   * });
   * ```
   *
   * @param {String|Object} field The field to set value for, or an object with multiple values to set in one call
   * @param {*} [value] Value to set
   * @param {Boolean} [silent] Set to true to not trigger events. If event is recurring, occurrences won't be updated automatically.
   * @privateparam {Boolean} [validOnly] If set to `true` it will ignore setting a `undefined` value, allowing conversion functions to invalidate a data input
   * @privateparam {Boolean} [triggerBeforeUpdate]
   * @fires Store#idChange
   * @fires Store#update
   * @fires Store#change
   * @category Editing
   */
  set(field, value, silent = false, fromRelationUpdate = false, skipAccessors = false, validOnly = false, triggerBeforeUpdate = true) {
    const me = this;
    if (me.isBatchUpdating) {
      me.inBatchSet(field, value, silent || me.$silenceBatch);
      return null;
    } else {
      var _me$afterSet;
      // We use inSet/afterSet approach here because mixin interested in overriding set() method like STM, for
      // example, might be mixed before Model class or after. In general, we have no control over this.
      // STM mixed before, so the only option to wrap set() method body is actually to call afterSet().
      const wasSet = me.inSet(field, value, silent, fromRelationUpdate, skipAccessors, validOnly, triggerBeforeUpdate);
      (_me$afterSet = me.afterSet) === null || _me$afterSet === void 0 ? void 0 : _me$afterSet.call(me, field, value, silent, fromRelationUpdate, wasSet);
      return wasSet;
    }
  }
  fieldToKeys(field, value) {
    if (typeof field !== 'string') {
      // will get in trouble when setting same field on multiple models without this
      return ObjectHelper.assign({}, field);
    }
    return {
      [field]: value
    };
  }
  inBatchSet(field, value, silent) {
    const me = this,
      {
        meta,
        constructor,
        fieldMap
      } = me,
      wasSet = {};
    let cmp,
      changed = false;
    if (typeof field !== 'string') {
      Object.keys(me.fieldToKeys(field, value)).forEach(key => {
        cmp = fieldMap[key] || ObjectHelper;
        value = constructor.processField(key, field[key], me);
        // Store batch changes
        if (!cmp.isEqual(meta.batchChanges[key], value)) {
          wasSet[key] = {
            value,
            oldValue: me.get(key)
          };
          meta.batchChanges[key] = value;
          changed = true;
        }
      });
    } else {
      cmp = fieldMap[field] || ObjectHelper;
      // Minor optimization for engine writing back a lot of changes
      if (!cmp.isEqual(meta.batchChanges[field], value)) {
        wasSet[field] = {
          value,
          oldValue: me.get(field)
        };
        meta.batchChanges[field] = value;
        changed = true;
      }
    }
    // Callers need to be able to detect changes
    if (changed) {
      me.generation++;
      if (!silent) {
        // Fire batched events for UIs which need to update themselves during batched updates.
        // An example is evenResize feature which batches the changes to the endDate
        // or startDate, but the UI must update during the drag.
        const event = {
          action: 'update',
          record: me,
          records: [me],
          changes: wasSet
        };
        me.stores.forEach(store => {
          store.trigger('batchedUpdate', {
            ...event
          });
        });
        // Propagate to linked records
        me.forEachLinked((store, record) => store.trigger('batchedUpdate', {
          ...event,
          record,
          records: [record]
        }));
      }
    }
  }
  inSet(fieldNameOrObject, value, silent, fromRelationUpdate, skipAccessors = false, validOnly = false, triggerBeforeUpdate = true) {
    const me = this,
      {
        data,
        meta,
        fieldMap,
        constructor
      } = me,
      {
        prototype: myProto,
        childrenField,
        relations
      } = constructor,
      wasSet = {},
      toSet = me.fieldToKeys(fieldNameOrObject, value),
      // Sort fields to make sure parentId is processed before id
      // https://github.com/bryntum/support/issues/6851
      keys = Object.keys(toSet).sort(constructor.fieldSorter);
    let changed = false;
    // Give a chance to cancel action before records are updated.
    if (!silent && !me.triggerBeforeUpdate(toSet)) {
      return null;
    }
    me.inSetting = true;
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      // Currently not allowed to set children in a TreeNode this way, will be ignored
      if (key === childrenField) {
        continue;
      }
      // Setting a field on a record in a store data field (players[0].name = 'foo')
      if (key.includes('[')) {
        const [, arrayFieldName, index, path] = key.match(arrayRe),
          field = me.fieldMap[arrayFieldName];
        if (field !== null && field !== void 0 && field.getAt) {
          const subRecord = field.getAt(me, index);
          if (subRecord.isModel) {
            subRecord.set(path, toSet[key]);
          } else {
            ObjectHelper.setPath(subRecord, path, toSet[key]);
          }
          continue;
        }
      }
      const complexKey = key.includes('.');
      // Handle updating related record
      if (relations && complexKey) {
        const [, relationName, prop] = key.match(nestedRe);
        if (relations[relationName]) {
          me[relationName].set(prop, toSet[key]);
          continue;
        }
      }
      const field = fieldMap[key],
        cmp = field || ObjectHelper,
        readOnly = field === null || field === void 0 ? void 0 : field.readOnly,
        mapping = (field === null || field === void 0 ? void 0 : field.dataSource) ?? key,
        useProp = !skipAccessors && !field && key in myProto || (field === null || field === void 0 ? void 0 : field.useProp),
        oldValue = useProp ? me[mapping] : field !== null && field !== void 0 && field.complexMapping || complexKey ? ObjectHelper.getPath(data, mapping) : data[mapping],
        value = constructor.processField(key, toSet[key], me),
        val = toSet[key] = {
          value
        },
        relation = me.getRelationConfig(key);
      if (!readOnly && !cmp.isEqual(oldValue, value) && (!validOnly || value !== undefined)) {
        var _field$getOldValue;
        // Indicate to observers that data has changed.
        me.generation++;
        // Give fields a shot at affecting the old value (used by StoreDataField)
        val.oldValue = (field === null || field === void 0 ? void 0 : (_field$getOldValue = field.getOldValue) === null || _field$getOldValue === void 0 ? void 0 : _field$getOldValue.call(field, me)) ?? oldValue;
        changed = true;
        // Update `modified` state which is used in sync request
        if (key in meta.modified && cmp.isEqual(meta.modified[key], value)) {
          // Remove changes if values are the same
          Reflect.deleteProperty(meta.modified, key);
          // Hack for when reverting record changes when using engine. If data is not made up to date here,
          // the write-back from engine coming later will detect the revert as a change. And round we go
          if (me.isReverting) {
            me.data[mapping] = value;
          }
        } else if (!me.ignoreBag) {
          // Private flag in engine, speeds initial commit up by not recording changes
          // Cache its original value
          if (!(key in meta.modified)) {
            me.storeFieldChange(key, oldValue);
          }
          if (val.oldValue === _undefined) {
            Reflect.deleteProperty(val, 'oldValue');
          }
        }
        // The wasSet object keys must be the field *name*, not its dataSource.
        wasSet[key] = val;
        me.applyValue(useProp, mapping, value, skipAccessors, field);
        // changing foreign key
        if (relation && !fromRelationUpdate) {
          me.initRelation(relation);
          me.stores.forEach(store => store.cacheRelatedRecord(me, value, relation.relationName, val.oldValue));
        }
      }
    }
    if (changed) {
      me.afterChange(toSet, wasSet, silent, fromRelationUpdate, skipAccessors);
    }
    me.inSetting = false;
    return changed ? wasSet : null;
  }
  // Provided as a hook for Engine to do what needs to be done which ever way a field value is changed
  applyValue(useProp, key, value, skipAccessors, field) {
    var _field, _field3;
    const me = this;
    // Setting parentId moves the node, always route through setter
    if ((((_field = field) === null || _field === void 0 ? void 0 : _field.name) || key) === me.constructor.parentIdField) {
      var _me$parent;
      // do nothing if `value=null/undefined` (or unresolvable id) - supposed to move the node
      // to the children of root _and_ node is already a child of root
      if (!((_me$parent = me.parent) !== null && _me$parent !== void 0 && _me$parent.isRoot && (value == null || !me.firstStore.getById(value)))) {
        // key is the dataSource, if we use property we need to use field name
        (me.firstStore.getById(value) || me.firstStore.rootNode).insertChild(me, null, false, {
          orderedParentIndex: {
            skip: true
          }
        });
      }
    }
    // If we don't have a field, but we have a property define eg, the fullDuration property defined in TaskModel,
    // then use the property.
    else if (useProp) {
      var _field2;
      // key is the dataSource, if we use property we need to use field name
      me[((_field2 = field) === null || _field2 === void 0 ? void 0 : _field2.name) || key] = value;
    } else if ((_field3 = field) !== null && _field3 !== void 0 && _field3.set) {
      field.set(value, me.data, me);
    } else {
      var _field4;
      let complexMapping = (_field4 = field) === null || _field4 === void 0 ? void 0 : _field4.complexMapping;
      // Might be setting value of nested object
      if (!field && key.includes('.')) {
        var _field5, _field6;
        const nestedName = key.split('.')[0];
        field = me.constructor.fieldMap[nestedName];
        // We use complex mapping if the field's dataSource was defined as such,
        // OR if we are being asked to set using dot notation and field is of Object type.
        complexMapping = ((_field5 = field) === null || _field5 === void 0 ? void 0 : _field5.complexMapping) || ((_field6 = field) === null || _field6 === void 0 ? void 0 : _field6.type) === 'object';
      }
      // Use complex mapping?
      if (complexMapping) {
        ObjectHelper.setPath(me.data, key, value);
      }
      // Otherwise, push the value through into the data.
      else {
        me.data[key] = value;
      }
    }
  }
  // skipAccessors argument is used in the engine override
  afterChange(toSet, wasSet, silent, fromRelationUpdate, skipAccessors) {
    for (const store of this.stores) {
      store.onModelChange(this, toSet, wasSet, silent, fromRelationUpdate, skipAccessors);
    }
    // Propagate to linked records
    this.forEachLinked((store, record) => store.onModelChange(record, toSet, wasSet, silent, fromRelationUpdate, skipAccessors));
  }
  // Run fn for each store on each linked record
  forEachLinked(fn) {
    for (const linked of this.$links) {
      for (const store of linked.stores) {
        fn(store, linked);
      }
    }
  }
  /**
   * This yields `true` if this record is eligible for syncing with the server.
   * It can yield `false` if the record is in the middle of a {@link #property-isBatchUpdating batched update},
   * or if it is a {@link #property-isCreating tentative record} yet to be confirmed as a new addition.
   * @property {Boolean}
   * @readonly
   */
  get isPersistable() {
    // Record is not persistable if the owning app is in the middle of a batch update
    // and the record is not flagged as being in the middle of a creation sequence.
    // This means that a "new" record can be added on a conditional basis with its
    // isCreating property set which means it is examplt from being synced until
    // the isCreating flag is cleared.
    return !this.isBatchUpdating && !this.isCreating;
  }
  /**
   * True if this model has any uncommitted changes.
   * @property {Boolean}
   * @readonly
   * @category Editing
   */
  get isModified() {
    return Boolean(this.meta.modified && Object.keys(this.meta.modified).length > 0);
  }
  get hasPersistableChanges() {
    return this.isPersistable && !ObjectHelper.isEmpty(this.rawModificationData);
  }
  /**
   * Returns true if this model has uncommitted changes for the provided field.
   * @param {String} fieldName Field name
   * @returns {Boolean} True if the field is changed
   * @category Editing
   */
  isFieldModified(fieldName) {
    return this.isModified && fieldName in this.meta.modified;
  }
  /**
   * Returns field value that should be persisted, or `undefined` if field is configured with `persist: false`.
   * @param {String|Core.data.field.DataField} nameOrField Name of the field to get value for, or its field definition
   * @private
   * @category Fields
   */
  getFieldPersistentValue(nameOrField) {
    const field = typeof nameOrField === 'string' ? this.getFieldDefinition(nameOrField) : nameOrField,
      name = (field === null || field === void 0 ? void 0 : field.name) || nameOrField;
    let result;
    if (!field || field.persist) {
      result = this.getValue(name);
      // if serialize function is provided we use it to prepare the persistent value
      if (field !== null && field !== void 0 && field.serialize) {
        result = field.serialize(result, this);
      }
    }
    return result;
  }
  /**
   * Get a map of the modified fields in form of an object. The field *names* are used as the property names
   * in the returned object.
   * @property {Object}
   * @readonly
   * @category Editing
   */
  get modifications() {
    const data = this.rawModifications;
    if (data && Object.keys(data).length) {
      data[this.constructor.idField] = this.id;
    }
    return data;
  }
  get rawModifications() {
    const me = this,
      data = {};
    if (!me.isModified) {
      return null;
    }
    let keySet = false;
    Object.keys(me.meta.modified).forEach(key => {
      const value = me.getFieldPersistentValue(key);
      if (value !== _undefined) {
        data[key] = value;
        keySet = true;
      }
    });
    return keySet ? data : null;
  }
  /**
   * Get a map of the modified fields in form of an object. The fields {@link Core.data.field.DataField#config-dataSource}
   * is used as the property name in the returned object. The records id is always included.
   * @property {Object}
   * @readonly
   * @category Editing
   */
  get modificationData() {
    const data = this.rawModificationData;
    // If there are some persistable field changes, append record id
    if (data && Object.keys(data).length) {
      ObjectHelper.setPath(data, this.constructor.idField, this.id);
    }
    return data;
  }
  /**
   * Returns a map of the modified persistable fields
   * @internal
   * @property {Object}
   * @category Editing
   */
  get rawModificationData() {
    const me = this,
      {
        fieldMap
      } = me.constructor,
      data = {};
    if (!me.isModified) {
      return null;
    }
    let keySet = false;
    Object.keys(me.meta.modified).forEach(fieldName => {
      var _field7, _field8;
      let field = fieldMap[fieldName],
        dataSource = (_field7 = field) === null || _field7 === void 0 ? void 0 : _field7.dataSource;
      // Nested field, get top level field definition, but set the dataSource to the full path
      if (fieldName.includes('.')) {
        const topLevelFieldName = fieldName.match(nestedRe)[1];
        field = fieldMap[topLevelFieldName];
        dataSource = fieldName;
      }
      // No field definition means there's no original dataSource to update
      if ((_field8 = field) !== null && _field8 !== void 0 && _field8.persist) {
        const value = me.getFieldPersistentValue(fieldName);
        if (value !== _undefined) {
          ObjectHelper.setPath(data, dataSource, value);
          keySet = true;
        }
      }
    });
    return keySet ? data : null;
  }
  /**
   * Get a map of the modified data fields along with any {@link Core/data/field/DataField#config-alwaysWrite} fields,
   * in form of an object. The fields *dataSource* is used as the property name in the returned object.
   * Used internally by AjaxStore / CrudManager when sending updates.
   * @property {Object}
   * @readonly
   * @category Editing
   */
  get modificationDataToWrite() {
    const alwaysWriteFields = this.constructor.alwaysWriteFields,
      recordData = this.modificationData;
    alwaysWriteFields.forEach(fieldName => {
      recordData[this.getFieldDefinition(fieldName).dataSource] = this.getFieldPersistentValue(fieldName);
    });
    return recordData;
  }
  /**
   * Returns data for **all** {@link Core.data.field.DataField#config-persist persistable} fields in form of an
   * object, using dataSource if present.
   * @property {Object}
   * @internal
   * @readonly
   * @category Editing
   */
  get persistableData() {
    const me = this,
      data = {};
    me.fields.forEach(field => {
      const value = me.getFieldPersistentValue(field);
      if (value !== _undefined) {
        if (field !== null && field !== void 0 && field.complexMapping) {
          ObjectHelper.setPath(data, field.dataSource, value);
        } else {
          data[field.dataSource] = value;
        }
      }
    });
    return data;
  }
  get dataByFieldName() {
    const {
      data
    } = this;
    return this.fields.reduce((result, field) => {
      if (ObjectHelper.hasPath(data, field.dataSource)) {
        result[field.name] = data[field.dataSource];
      }
      return result;
    }, {});
  }
  /**
   * True if this models changes are currently being committed.
   * @property {Boolean}
   * @category Editing
   */
  get isCommitting() {
    return Boolean(this.meta.committing);
  }
  /**
   * Clear stored changes, used on commit. Does not revert changes.
   * @param {Boolean} [includeDescendants] Supply `false` to not clear node descendants
   * @privateparam {Boolean} [removeFromStoreChanges] Update related stores modified collection or not
   * @privateparam {Object|null} [changes] Set of changes to clear on the record
   * @category Editing
   */
  clearChanges(includeDescendants = true, removeFromStoreChanges = true, changes = null) {
    const me = this,
      {
        meta
      } = me;
    // If we've received an object with changes, we only need to clean that one up
    if (changes) {
      for (const key in changes) {
        delete meta.modified[key];
      }
    } else {
      meta.modified = {};
    }
    // We can only remove record from changes if we no modified fields in meta
    const noChanges = ObjectHelper.isEmpty(meta.modified);
    meta.committing = false;
    if (removeFromStoreChanges) {
      me.stores.forEach(store => {
        noChanges && store.modified.remove(me);
        store.added.remove(me);
        if (includeDescendants) {
          const descendants = store.collectDescendants(me).all;
          store.added.remove(descendants);
          noChanges && store.modified.remove(descendants);
        }
      });
    }
  }
  storeFieldChange(key, oldValue) {
    this.meta.modified[key] = oldValue;
  }
  /**
   * Reverts changes in this back to their original values.
   * @privateparam {Boolean} [silent] Specify `true` to not trigger events.
   * @category Editing
   */
  revertChanges(silent = false) {
    // Flag checked by engine to not set startDate constraint on revert
    this.isReverting = true;
    this.set(this.meta.modified, _undefined, silent);
    this.isReverting = false;
  }
  applyChangeset(rawChanges, phantomIdField = '$PhantomId', remote = true) {
    const me = this,
      modelClass = me.constructor,
      {
        idField,
        fieldDataSourceMap
      } = modelClass,
      rawChangesSimplePaths = ObjectHelper.pathifyKeys(rawChanges, fieldDataSourceMap),
      ownChangesSimplePaths = ObjectHelper.pathifyKeys(me.modificationData),
      changes = {},
      // Value of id field cannot be changed, it can only be set. In which case phantom id field will be in the
      // rawChanges objects
      idChanged = (phantomIdField in rawChanges);
    // Collect the changes into a change set for field names.
    for (const dataSource in rawChangesSimplePaths) {
      const field = fieldDataSourceMap[dataSource],
        propName = (field === null || field === void 0 ? void 0 : field.name) ?? dataSource;
      // Only apply change to the model:
      // 1. if changes is remote
      // 2. or local change is not outdated
      // 3. we are setting id (in which case phantom id would be in raw changes). id value cannot be changed here,
      // only assigned if record is phantom - because we use id from the raw data to resolve this record in the
      // first place
      if (remote || ((field === null || field === void 0 ? void 0 : field.name) === idField ? idChanged : rawChangesSimplePaths[dataSource] === ownChangesSimplePaths[dataSource])) {
        changes[propName] = rawChangesSimplePaths[dataSource];
      }
    }
    // Apply all changes in one go, making sure record is considered unmodified after
    const wasSet = me.set(changes);
    me.clearChanges(false, true, remote ? null : changes);
    // wasSet has format { field : { oldValue, value }}, convert to { field : value }
    return wasSet ? Object.entries(wasSet).reduce((result, [field, change]) => {
      result[field] = change.value;
      return result;
    }, {}) : {};
  }
  //endregion
  //region Id
  /**
   * Gets the records internalId. It is assigned during creation, guaranteed to be globally unique among models.
   * @property {Number}
   * @category Identification
   */
  get internalId() {
    return this._internalId;
  }
  /**
   * Returns true if the record is new and has not been persisted (and received a proper id).
   * @property {Boolean}
   * @readonly
   * @category Identification
   */
  get isPhantom() {
    return this.id === '' || this.id == null || this.hasGeneratedId;
  }
  get isModel() {
    return true;
  }
  /**
   * Checks if record has a generated id.
   *
   * New records are assigned a generated id based on a UUID (starting with `_generated`), which is intended to be
   * temporary and should be replaced by the backend on commit.
   *
   * @property {Boolean}
   * @category Identification
   */
  get hasGeneratedId() {
    return typeof this.id === 'string' && this.id.startsWith('_generated');
  }
  static generateId(text = this.$$name) {
    return `_generated${text}_${StringHelper.generateUUID()}`;
  }
  /**
   * Generates an id for a new record (a phantom id), based on a UUID (starting with `_generated`).
   *
   * Generated ids are intended to be temporary and should be replaced by the backend on commit.
   *
   * @category Identification
   * @returns {String}
   */
  generateId() {
    return this.constructor.generateId();
  }
  /**
   * Gets the id of specified model or model data object, or the value if passed string/number.
   * @param {Core.data.Model|String|Number} model
   * @returns {String|Number} id
   * @category Identification
   */
  static asId(model) {
    return model !== null && model !== void 0 && model.isModel ? model.id : ObjectHelper.isObject(model) ? model[this.fieldMap.id.dataSource] : model;
  }
  //endregion
  //region JSON
  /**
   * Get the records data as a json string.
   *
   * ```javascript
   * const record = new Model({
   *     title    : 'Hello',
   *     children : [
   *         ...
   *     ]
   * });
   *
   * const jsonString = record.json;
   *
   * //jsonString:
   * '{"title":"Hello","children":[...]}'
   * ```
   *
   * @member {String}
   * @category JSON
   */
  get json() {
    return StringHelper.safeJsonStringify(this); // calls our toJSON() method
  }
  /**
   * Used by `JSON.stringify()` to correctly convert this record to json.
   *
   * In most cases no point in calling it directly.
   *
   * ```
   * // This will call `toJSON()`
   * const json = JSON.stringify(record);
   * ```
   *
   * If called manually, the resulting object is a clone of `record.data` + the data of any children:
   *
   * ```
   * const record = new Model({
   *     title    : 'Hello',
   *     children : [
   *         ...
   *     ]
   * });
   *
   * const jsonObject = record.toJSON();
   *
   * // jsonObject:
   * {
   *     title : 'Hello',
   *     children : [
   *         ...
   *     ]
   * }
   * ```
   *
   * @returns {Object}
   * @category JSON
   */
  toJSON() {
    const {
        children,
        unfilteredChildren
      } = this,
      jsonData = this.persistableData;
    if (unfilteredChildren || children) {
      jsonData[this.constructor.childrenField] = (unfilteredChildren || children).map(c => c.toJSON());
    }
    return jsonData;
  }
  /**
   * Represent the record as a string, by default as a JSON string. Tries to use an abbreviated version of the
   * object's data, using id + name/title/text/label/description. If no such field exists, the full data is used.
   *
   * ```javascript
   * const record = new Model({ id : 1, name : 'Steve Rogers', alias : 'Captain America' });
   * console.log(record.toString()); // logs { "id" : 1, "name" : "Steve Rogers" }
   * ```
   *
   * @returns {String}
   * @category JSON
   */
  toString() {
    const me = this,
      nameField = abbreviationFields.find(field => field in me.constructor.fieldMap),
      data = nameField ? {
        [me.constructor.idField]: me.id,
        [nameField]: me[nameField]
      } : me.data;
    return StringHelper.safeJsonStringify(data);
  }
  //endregion
  //region Batch
  /**
   * True if this Model is currently batching its changes.
   * @property {Boolean}
   * @readonly
   * @category Editing
   */
  get isBatchUpdating() {
    return Boolean(this.batching);
  }
  /**
   * Returns `true` if this Model currently has outstanding batched changes for the specified field name.
   * @param {String} fieldName The field name to check for batched updates on.
   * @returns {Boolean}
   * @category Editing
   */
  hasBatchedChange(fieldName) {
    var _this$meta, _this$meta$batchChang;
    return (_this$meta = this.meta) === null || _this$meta === void 0 ? void 0 : (_this$meta$batchChang = _this$meta.batchChanges) === null || _this$meta$batchChang === void 0 ? void 0 : _this$meta$batchChang[fieldName];
  }
  /**
   * Begin a batch, which stores changes and commits them when the batch ends.
   * Prevents events from being fired during batch.
   *
   * ```javascript
   * record.beginBatch();
   * record.name = 'Mr Smith';
   * record.team = 'Golden Knights';
   * record.endBatch();
   * ```
   *
   * Please note that you can also set multiple fields in a single call using {@link #function-set}, which in many
   * cases can replace using a batch:
   *
   * ```javascript
   * record.set({
   *   name : 'Mr Smith',
   *   team : 'Golden Knights'
   * });
   * ```
   * @category Editing
   * @privateparam {Boolean} silentUpdates Suppress firing the `batchUpdatedEvent`
   */
  beginBatch(silentUpdates = false) {
    const me = this;
    if (!me.batching) {
      me.batching = 0;
      me.meta.batchChanges = {};
    }
    if (silentUpdates) {
      me.$silenceBatch = (me.$silenceBatch || 0) + 1;
    }
    me.batching++;
  }
  /**
   * End a batch, triggering events if data has changed.
   * @param {Boolean} [silent] Specify `true` to not trigger events. If event is recurring, occurrences won't be updated automatically.
   * @privateparam {Boolean} [silent=false] Specify `true` to not trigger events. If event is recurring, occurrences won't be updated automatically.
   * @privateparam {Boolean} [triggerBeforeUpdate=true]
   * @category Editing
  */
  endBatch(silent = false, skipAccessors = false, triggerBeforeUpdate = true) {
    const me = this,
      {
        parentIdField
      } = me.constructor;
    if (!me.batching) {
      return;
    }
    me.batching--;
    // Ideally we should track which batch was silenced, but that will complicate code more than what avoiding a few
    // triggered events is worth (this is private and we do not start batches while batches are ongoing in the
    // critical code path in engine)
    me.$silenceBatch && me.$silenceBatch--;
    if (me.batching > 0) {
      return;
    }
    // Set pending batch changes
    if (!ObjectHelper.isEmpty(me.meta.batchChanges)) {
      let {
        batchChanges
      } = me.meta;
      me.meta.batchChanges = null;
      // Move to its new parent before applying the other changes.
      if (batchChanges[parentIdField]) {
        batchChanges = {
          ...batchChanges
        };
        me.parentId = batchChanges[parentIdField];
        delete batchChanges[parentIdField];
      }
      me.set(batchChanges, _undefined, silent, false, skipAccessors, undefined, triggerBeforeUpdate);
    }
  }
  /**
   * Cancels current batch operation. Any changes during the batch are discarded.
   * @category Editing
   */
  cancelBatch() {
    if (this.batching) {
      const me = this,
        {
          batchChanges
        } = me.meta,
        wasSet = {};
      me.batching = null;
      me.meta.batchChanges = null;
      me.generation++;
      if (!me.$silenceBatch) {
        // Create a wasSet describing the revert back from the batched values to the real values.
        Object.entries(batchChanges).forEach(([key, oldValue]) => {
          wasSet[key] = {
            oldValue,
            value: me[key]
          };
        });
        // Fire batched events for UIs which need to update themselves during batched updates.
        // An example is evenResize feature which batches the changes to the endDate
        // or startDate, but the UI must update during the drag.
        const event = {
          action: 'update',
          record: me,
          records: [me],
          changes: wasSet
        };
        me.stores.forEach(store => {
          // Cant use event directly, it will get polluted with `source` and then have that incorrect for
          // following calls
          store.trigger('batchedUpdate', {
            ...event
          });
        });
        // Propagate to linked records
        me.forEachLinked((store, record) => {
          store.trigger('batchedUpdate', {
            ...event,
            record,
            records: [record]
          });
        });
      }
      me.$silenceBatch && me.$silenceBatch--;
    }
  }
  //endregion
  //region Events
  /**
   * Triggers beforeUpdate event for each store and checks if changes can be made from event return value.
   * @param {Object} changes Data changes
   * @returns {Boolean} returns true if data changes are accepted
   * @private
   */
  triggerBeforeUpdate(changes) {
    var _this$stores;
    return !((_this$stores = this.stores) !== null && _this$stores !== void 0 && _this$stores.some(s => s.trigger('beforeUpdate', {
      record: this,
      changes
    }) === false));
  }
  //endregion
  //region Additional functionality
  /**
   * Makes a copy of this model, assigning the specified id or a generated id and also allowing you to pass field values to
   * the created copy.
   *
   * ```
   * const record = new Model({ name : 'Super model', hairColor : 'Brown' });
   * const clone = record.copy({ name : 'Super model clone' });
   * ```
   * @param {Number|String|Object} [newId] The id for the copied instance, or any field values to apply
   * (overriding the values from the source record). If no id provided, one will be auto-generated
   * @param {Boolean} [deep] True to also clone children
   * @returns {Core.data.Model} Copy of this model
   * @category Editing
   */
  copy(newId = null, deep) {
    const me = this,
      data = ObjectHelper.clone(me.data),
      idField = me.constructor.idField,
      // Chrono model is adding more logic to copy and that logic should be manageable from arguments. So there is
      // option to pass object as a last argument to switch method behavior. Used internally only, shouldn't be public.
      useDeep = ObjectHelper.isObject(deep) ? deep.deep : deep;
    let id;
    if (newId && typeof newId === 'object') {
      id = newId[idField];
      Object.assign(data, newId);
    } else {
      id = newId;
    }
    // Iterate over instance children, because data may not reflect actual children state.
    // Copy's initial expanded state will be from the "expanded" property of the data object
    // which is cloned from the source.
    if (useDeep && me.children) {
      data.children = me.children.map(child => child.copy(undefined, deep));
    } else {
      delete data.children;
      delete data.expanded;
    }
    if (me.$meta.fields.initable.length > 0) {
      const json = me.toJSON();
      for (const field of me.$meta.fields.initable) {
        data[field.name] = json[field.name];
      }
    }
    if (newId !== false) {
      // We can use the value from the 'id' property, but as a fallback, generate the id.
      data[idField] = id || me.generateId(me.firstStore);
    }
    // Force using raw data when creating a copy, since data was cloned above anyway
    const copy = new me.constructor(data, null, null, false, true);
    // Store original record internal id to lookup from copy later
    copy.originalInternalId = me.internalId;
    return copy;
  }
  // Copies data using the real field names to trigger setters
  copyData(fromRecord, raw, silent) {
    const propertiesAndValues = {};
    fromRecord.allFields.forEach(({
      name: fieldName
    }) => {
      if (fieldName !== fromRecord.constructor.idField) {
        propertiesAndValues[fieldName] = raw ? fromRecord.get(fieldName) : fromRecord.getValue(fieldName);
      }
    });
    this.set(propertiesAndValues, null, silent);
  }
  /**
   * Removes this record from all stores (and in a tree structure, also from its parent if it has one).
   * @param {Boolean} [silent] Specify `true` to not trigger events. If event is recurring, occurrences won't be updated automatically.
   * @category Editing
   */
  remove(silent = false) {
    const me = this,
      {
        parent
      } = this;
    // Remove from parent if we're in a tree structure.
    // This informs the owning store(s)
    if (parent) {
      parent.removeChild(me);
    }
    // Store handles remove
    // Not sure what should happen if you try to remove a special row (group row for example), bailing out
    else if (me.stores.length && !me.isSpecialRow) {
      me.stores.forEach(s => s.remove(me, silent, false, true));
    }
  }
  // Called by stores before removing the record from the store. Returning false prevents the removal (overridden in
  // ModelLink.js)
  beforeRemove(stores, records) {
    return super.beforeRemove(stores, records);
  }
  //endregion
  //region Validation
  /**
   * Check if record has valid data. Default implementation returns true, override in your model to do actual validation.
   * @property {Boolean}
   * @category Editing
   */
  get isValid() {
    return true;
  }
  //endregion
  //region Store
  /**
   * Get the first store that this model is assigned to.
   * @property {Core.data.Store}
   * @readonly
   * @category Misc
   */
  get firstStore() {
    return this.stores.length > 0 && this.stores[0];
  }
  /**
   * Joins this record and any children to specified store, if not already joined.
   * @internal
   * @param {Core.data.Store} store Store to join
   * @category Misc
   */
  joinStore(store) {
    const me = this,
      {
        stores
      } = me;
    if (!stores.includes(store)) {
      var _store$stm;
      const {
        unjoinedStores
      } = me;
      super.joinStore(store);
      store.register(me);
      stores.push(store);
      if (unjoinedStores.includes(store)) {
        unjoinedStores.splice(unjoinedStores.indexOf(store), 1);
      }
      me.isLoaded && me.children.forEach(child => child.joinStore(store));
      me.initRelations();
      // do not change the collapsed state during stm restoring
      if (store.tree && !me.isRoot && !((_store$stm = store.stm) !== null && _store$stm !== void 0 && _store$stm.isRestoring)) {
        me.instanceMeta(store.id).collapsed = !me.expanded;
      }
    }
  }
  /**
   * Unjoins this record and any children from specified store, if already joined.
   * @internal
   * @param {Core.data.Store} store Store to join
   * @param {Boolean} [isReplacing] `true` if this record is being replaced
   * @category Misc
   */
  unjoinStore(store, isReplacing = false) {
    const me = this,
      {
        stores,
        unjoinedStores
      } = me;
    if (stores.includes(store)) {
      var _ref, _ref$forEach, _super$unjoinStore;
      if (!store.isDestroying) {
        store.unregister(me);
        unjoinedStores.push(store);
      }
      // me.children may === true...
      // If filtered, *all* children must be unjoined when we are.
      (_ref = me.unfilteredChildren || me.children) === null || _ref === void 0 ? void 0 : (_ref$forEach = _ref.forEach) === null || _ref$forEach === void 0 ? void 0 : _ref$forEach.call(_ref, child => child.unjoinStore(store, isReplacing));
      stores.splice(stores.indexOf(store), 1);
      // keep the cord to allow removed records to reach the store when needed
      (_super$unjoinStore = super.unjoinStore) === null || _super$unjoinStore === void 0 ? void 0 : _super$unjoinStore.call(this, store, isReplacing);
      // remove from relation cache
      store.uncacheRelatedRecord(me);
    }
  }
  /**
   * Returns true if this record is contained in the specified store, or in any store if store param is omitted.
   * @internal
   * @param {Core.data.Store} store Store to join
   * @returns {Boolean}
   * @category Misc
   */
  isPartOfStore(store) {
    if (store) {
      return store.includes(this);
    }
    return this.stores.length > 0;
  }
  /**
   * Returns true if this record is not part of any store.
   * @property {Boolean}
   * @readonly
   * @internal
   */
  get isRemoved() {
    return !this.isPartOfStore();
  }
  //endregion
  //region Per instance meta
  /**
   * Used to set per external instance meta data. For example useful when using a record in multiple grids to store some state
   * per grid.
   * @param {String|Object} instanceOrId External instance id or the instance itself, if it has id property
   * @private
   * @category Misc
   */
  instanceMeta(instanceOrId) {
    const {
        meta
      } = this,
      id = instanceOrId.id || instanceOrId;
    if (!meta.map) {
      meta.map = {};
    }
    return meta.map[id] || (meta.map[id] = {});
  }
  /**
   * When called on a group header row returns list of records in that group. Returns `undefined` otherwise.
   * @member {Core.data.Model[]|undefined} groupChildren
   * @category Grouping
   * @readonly
   */
  /**
   * Returns true for a group header record
   * @member {Boolean}
   * @category Grouping
   * @readonly
   */
  get isGroupHeader() {
    return 'groupRowFor' in this.meta;
  }
  get isGroupFooter() {
    return 'groupFooterFor' in this.meta;
  }
  get isSpecialRow() {
    var _this$meta2;
    return Boolean((_this$meta2 = this.meta) === null || _this$meta2 === void 0 ? void 0 : _this$meta2.specialRow);
  }
  get $original() {
    return this.isLinked ? this.proxyMeta.originalRecord : this;
  }
  //endregion
  static get nonPersistableFields() {
    const me = this;
    if (!me._nonPersistableFields) {
      me._nonPersistableFields = {};
      me.allFields.forEach(field => {
        if (!field.persist || field.calculated) {
          me._nonPersistableFields[field.name] = 1;
        }
      });
    }
    return me._nonPersistableFields;
  }
  static get alwaysWriteFields() {
    const me = this;
    if (!me._alwaysWriteFields) {
      me._alwaysWriteFields = [];
      me.allFields.forEach(field => {
        if (field.alwaysWrite) {
          me._alwaysWriteFields.push(field.name);
        }
      });
    }
    return me._alwaysWriteFields;
  }
  // Id with spaces and dots replaced by -, for safe usage as an id in DOM
  get domId() {
    return typeof this.id === 'string' ? this.id.replace(/[ .]/g, '-') : this.id;
  }
  //region Extract config
  // These functions are not meant to be called by any code other than Base#getCurrentConfig()
  // Convert custom modelClass to string, keeping custom fields
  static toJavaScriptValue(options) {
    // Get name, skipping the automatically extended name that goes last (MyModel, not MyModelEx)
    const {
        names
      } = this.$meta,
      className = names[names.length - 2],
      superName = names[names.length - 3];
    return `class ${className} extends ${superName} { static fields = ${StringHelper.toJavaScriptValue(this.fields, options)}; }`;
  }
  // Get fields current values
  getCurrentConfig(options) {
    const {
        data,
        children
      } = this,
      {
        defaultValues,
        applyConfigs
      } = this.constructor,
      result = applyConfigs ? super.getCurrentConfig(options) : {};
    if (result) {
      for (const field of this.fields) {
        if (field.persist) {
          const value = ObjectHelper.getPath(data, field.dataSource);
          if (!field.isEqual(value, defaultValues[field.name])) {
            ObjectHelper.setPath(result, field.dataSource, Base.processConfigValue(value, options));
          }
        }
      }
      // Always include children
      if (children) {
        // Inline available children
        if (Array.isArray(children)) {
          result.children = [];
          for (const child of children) {
            result.children.push(child.getCurrentConfig(options));
          }
        }
        // Load on demand
        else {
          result.children = children;
        }
      }
      if (this.hasGeneratedId) {
        delete result.id;
      }
      delete result.parentId;
      delete result.parentIndex;
    }
    return result;
  }
  //endregion
}

Model._idField = 'id';
Model._internalIdCounter = 1;
Model._assignedIdField = false;
Model.exposeProperties();
Model._$name = 'Model';

/**
 * @module Core/data/Duration
 */
/**
 * Object describing a duration.
 * @typedef {Object} DurationConfig
 * @property {Number} magnitude The magnitude of the duration
 * @property {String} unit The unit of the duration
 */
/**
 * Class which represents a duration object. A duration consists of a `magnitude` and a `unit`.
 *
 * ```javascript
 * {
 *    unit      : String,
 *    magnitude : Number
 * }
 * ```
 *
 * Valid values are:
 * - "millisecond" - Milliseconds
 * - "second" - Seconds
 * - "minute" - Minutes
 * - "hour" - Hours
 * - "day" - Days
 * - "week" - Weeks
 * - "month" - Months
 * - "quarter" - Quarters
 * - "year"- Years
 */
class Duration {
  /**
   * Duration constructor.
   * @param {Number|String} magnitude Duration magnitude value or a duration + magnitude string ('2h', '4d')
   * @param {String} [unit] Duration unit value
   */
  constructor(magnitude, unit) {
    // we treat `magnitude === null` specially, it indicates the user intention
    // to unschedule the task
    if (typeof magnitude === 'number' || magnitude === null) {
      this._magnitude = magnitude;
      this._unit = unit;
    } else {
      if (typeof magnitude === 'string') {
        Object.assign(this, DateHelper.parseDuration(magnitude));
      }
      if (typeof magnitude === 'object') {
        Object.assign(this, magnitude);
      }
    }
  }
  /**
   * Get/Set numeric magnitude `value`.
   * @property {Number}
   */
  get magnitude() {
    return this._magnitude;
  }
  set magnitude(value) {
    this._magnitude = typeof value === 'number' && value;
  }
  /**
   * Get/Set duration unit to use with the current magnitude value.
   * Valid values are:
   * - "millisecond" - Milliseconds
   * - "second" - Seconds
   * - "minute" - Minutes
   * - "hour" - Hours
   * - "day" - Days
   * - "week" - Weeks
   * - "month" - Months
   * - "quarter" - Quarters
   * - "year"- Years
   *
   * @member {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'}
   */
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = DateHelper.parseTimeUnit(value);
  }
  get isValid() {
    return this._magnitude != null && Boolean(DateHelper.normalizeUnit(this._unit));
  }
  /**
   * The `milliseconds` property is a read only property which returns the number of milliseconds in this Duration
   * @property {Number}
   * @readonly
   */
  get milliseconds() {
    // There's no smaller time unit in the Date class than milliseconds, so round any divided values
    return this.isValid ? Math.round(DateHelper.asMilliseconds(this._magnitude, this._unit)) : 0;
  }
  /**
   * Returns truthy value if this Duration equals the passed value.
   * @param {Core.data.Duration} value
   * @returns {Boolean}
   */
  isEqual(value) {
    return Boolean(value) && this._magnitude != null && value._magnitude != null && this.milliseconds === value.milliseconds;
  }
  toString(useAbbreviation) {
    const me = this,
      abbreviationFn = useAbbreviation ? 'getShortNameOfUnit' : 'getLocalizedNameOfUnit';
    return me.isValid ? `${me._magnitude} ${DateHelper[abbreviationFn](me._unit, me._magnitude !== 1)}` : '';
  }
  toJSON() {
    return this.toString();
  }
  valueOf() {
    return this.milliseconds;
  }
  diff(otherDuration) {
    return new Duration({
      unit: this.unit,
      magnitude: DateHelper.as(this.unit, this.milliseconds - otherDuration.milliseconds)
    });
  }
}
Duration._$name = 'Duration';

/**
 * @module Core/util/CollectionFilter
 */
const nestedValueReducer = (object, path) => object === null || object === void 0 ? void 0 : object[path],
  relativeDateUnitRegExp = /^is(this|next|last)(week|month|year)$/i,
  relativeDateOperators = ['isToday', 'isTomorrow', 'isYesterday', 'isThisWeek', 'isNextWeek', 'isLastWeek', 'isThisMonth', 'isNextMonth', 'isLastMonth', 'isThisYear', 'isNextYear', 'isLastYear', 'isYearToDate'];
/**
 * A class which encapsulates a single filter operation which may be applied to any object to decide whether to
 * include or exclude it from a set.
 *
 * A CollectionFilter generally has at least three main properties:
 *
 * * `property` - The name of a property in candidate objects from which to extract the value to test
 * * `value` - The value which  this filter uses to test against.
 * * `operator` - The comparison operator, eg: `'='` or `'>'` etc.
 *
 * Given these three essential values, further configurations may affect how the filter is applied:
 *
 * * `caseSensitive` - If configured as `false`, string comparisons are case insensitive.
 * * `convert` - A function which, when passed the extracted value from the candidate object, returns the value to test.
 *
 * A filter may also be configured with a single `filterBy` property. This function is just passed the raw
 * candidate object and must return `true` or `false`.
 *
 * A CollectionFilter may be configured to encapsulate a single filtering function by passing that function as the sole
 * parameter to the constructor:
 *
 *     new CollectionFilter(candidate => candidate.title.contains('search string'));
 *
 */
class CollectionFilter extends Base.mixin(Identifiable) {
  static $name = 'CollectionFilter';
  static get defaultConfig() {
    return {
      /**
       * The value against which to compare the {@link #config-property} of candidate objects.
       * @config {*}
       */
      value: null,
      /**
       * The operator to use when comparing a candidate object's {@link #config-property} with this CollectionFilter's {@link #config-value}.
       * May be:
       * `'='`, `'!='`, `'>'`, `'>='`, `'<'`, `'<='`, `'*'`,
       * `'startsWith'`, `'endsWith'`, `'isIncludedIn'`, `'includes'`, `'doesNotInclude'`,
       * `'empty'`, `'notEmpty'`, `'between'`, `'notBetween'`, `'sameDay'`,
       * `'isToday'`, `'isTomorrow'`, `'isYesterday'`, `'isThisWeek'`, `'isLastWeek'`, `'isNextWeek'`, `'isThisMonth'`,
       * `'isLastMonth'`, `'isNextMonth'`, `'isThisYear'`, `'isLastYear'`, `'isNextYear'`, `'isYearToDate`',
       * `'isTrue'`, `'isFalse'`
       * @config {'='|'!='|'>'|'>='|'<'|'<='|'*'|'startsWith'|'endsWith'|'isIncludedIn'|'isNotIncludedIn'|'includes'|'doesNotInclude'|'empty'|'notEmpty'|'between'|'notBetween'|'sameDay'|'isToday'|'isTomorrow'|'isYesterday'|'isThisWeek'|'isLastWeek'|'isNextWeek'|'isThisMonth'|'isLastMonth'|'isNextMonth'|'isThisYear'|'isLastYear'|'isNextYear'|'isYearToDate'|'isTrue'|'isFalse'}
       */
      operator: null,
      /**
       * May be used in place of the {@link #config-property}, {@link #config-value} and {@link #config-property} configs. A function which
       * accepts a candidate object and returns `true` or `false`
       * @config {Function}
       */
      filterBy: null,
      /**
       * A function which accepts a value extracted from a candidate object using the {@link #config-property} name, and
       * returns the value which the filter should use to compare against its {@link #config-value}.
       * @config {Function}
       */
      convert: null,
      /**
       * Configure as `false` to have string comparisons case insensitive.
       * @config {Boolean}
       * @default
       */
      caseSensitive: true,
      /**
       * The `id` of this Filter for when used by a {@link Core.util.Collection} Collection.
       * By default the `id` is the {@link #config-property} value.
       * @config {String}
       */
      id: null,
      // Type is required to process the Date value in State API. Store doesn't always know about field type to
      // process filter value, when it applies it from the state, e.g. when you don't declare model field as `date`
      // type but provide a Date instance there. When DateColumn is used to shows this field, it could add date
      // filters to the store. When store is applying state it cannot just infer type, because model doesn't
      // declare it. Only column knows. So to properly process the Date instance for the filter State API would
      // have to process the field additionally, checking model field type and column type. So it is simpler to
      // make Filter to put this information. That way when filter is instantiated by the store, it can gracefully
      // handle value processing, converting date string to the Date instance.
      // Date is the only known value type so far which requires this processing.
      type: null,
      /**
       * Setting the `internal` config on a filter means that it is a fixed part of your store's operation.
       *
       * {@link Core.data.Store#function-clearFilters} does not remove `internal` filters. If you add an
       * `internal` filter, you must explicitly remove it if it is no longer required.
       *
       * Grid features which offer column-based filtering do *not* ingest existing store filters on
       * their data field if the filter is `internal`
       * @config {Boolean}
       * @default false
       */
      internal: null,
      /**
       * When `true`, the filter will not be applied.
       * @config {Boolean}
       * @default
       */
      disabled: false
    };
  }
  static get configurable() {
    return {
      /**
       * The name of a property of candidate objects which yields the value to compare against this CollectionFilter's {@link #config-value}.
       * @member {String} property
       */
      /**
       * The name of a property of candidate objects which yields the value to compare against this CollectionFilter's {@link #config-value}.
       * @config {String}
       */
      property: null
    };
  }
  construct(config) {
    if (typeof config === 'function') {
      config = {
        filterBy: config
      };
    }
    // If Filter is created without a type (yet everything except applying state) create one
    if (!config.type) {
      if (DateHelper.isDate(config.value) || Array.isArray(config.value) && config.value.every(DateHelper.isDate)) {
        config.type = 'date';
      } else if (config.value instanceof Duration) {
        config.type = 'duration';
      }
    }
    // If type already exist, it means we are applying state and should process value
    else {
      if (config.type === 'date' && config.value != null && !Array.isArray(config.value)) {
        config.value = new Date(config.value);
      } else if (config.type === 'duration' && config.value != null && !Array.isArray(config.value)) {
        config.value = new Duration(config.value);
      }
    }
    super.construct(config);
  }
  /**
   * When in a Collection (A Collection holds its Filters in a Collection), we need an id.
   * @property {String}
   * @private
   */
  get id() {
    if (!this._id) {
      // Internal filters get a special, unique property so that they cannot collide
      // with default filters for a field.
      if (this.internal) {
        this._id = CollectionFilter.generateId(`b-internal-${this.property}-filter-`);
      } else {
        this._id = this.property || CollectionFilter.generateId('b-filter-');
      }
    }
    return this._id;
  }
  set id(id) {
    this._id = id;
  }
  onChange(propertyChanged) {
    var _me$owner;
    const me = this;
    // Inform any owner (eg a Store), that it has to reassess its CollectionFilters
    if (!me.isConfiguring && (_me$owner = me.owner) !== null && _me$owner !== void 0 && _me$owner.onFilterChanged && !me.owner.isConfiguring) {
      me.owner.onFilterChanged(me, propertyChanged);
    }
  }
  get filterBy() {
    return this._filterBy || this.defaultFilterBy;
  }
  /**
   * May be used in place of the {@link #config-property}, {@link #config-value} and {@link #config-property} configs. A function which
   * accepts a candidate object and returns `true` or `false`
   * @type {Function}
   */
  set filterBy(filterBy) {
    this._filterBy = filterBy;
  }
  defaultFilterBy(candidate) {
    const me = this;
    let candidateValue;
    // Let records handle retrieving their own values
    if (candidate.isModel) {
      candidateValue = candidate.getValue(me.property);
    }
    // check if is nested property
    else if (me._propertyItems.length > 1) {
      // support nested props (https://github.com/bryntum/support/issues/1861)
      candidateValue = me._propertyItems.reduce(nestedValueReducer, candidate);
    } else {
      candidateValue = candidate[me.property];
    }
    return me[me.operator](me.convert(candidateValue));
  }
  updateProperty(property) {
    this._propertyItems = property.split('.');
    // Signal to owner about filter change
    this.onChange('property');
  }
  /**
   * The value against which to compare the {@link #config-property} of candidate objects.
   * @type {*}
   */
  set value(value) {
    const me = this;
    me._value = value;
    // Filter value is a processed value to be used by the comparators. Useful when value is object, like Duration field
    if (Array.isArray(value) && ({
      date: 1,
      duration: 1
    }[me.type] || value.length > 0 && typeof value[0] === 'string')) {
      me._filterValue = value.map(v => me.convert(v));
    } else if (!me.caseSensitive && Array.isArray(value) && value.length > 0 && typeof value[0] === 'string') {
      me._filterValue = value.map(s => s === null || s === void 0 ? void 0 : s.toLowerCase());
    } else if (!me.caseSensitive && typeof value === 'string') {
      me._filterValue = value.toLowerCase();
    } else {
      me._filterValue = me.convert(value);
    }
    // Signal to owner about filter change
    me.onChange('value');
  }
  get value() {
    return this._value;
  }
  get filterValue() {
    return this._filterValue;
  }
  /**
   * The operator to use when comparing a candidate object's {@link #config-property} with this CollectionFilter's {@link #config-value}.
   * May be:
   * `'='`, `'!='`, `'>'`, `'>='`, `'<'`, `'<='`, `'*'`,
   * `'startsWith'`, `'endsWith'`, `'isIncludedIn'`, `'includes'`, `'doesNotInclude'`,
   * `'empty'`, `'notEmpty'`, `'between'`, `'notBetween'`,
   * `'isToday'`, `'isTomorrow'`, `'isYesterday'`, `'isThisWeek'`, `'isLastWeek'`, `'isNextWeek'`, `'isThisMonth'`,
   * `'isLastMonth'`, `'isNextMonth'`, `'isThisYear'`, `'isLastYear'`, `'isNextYear'`, `'isYearToDate`',
   * `'isTrue'`, `'isFalse'`
   * @type {'='|'!='|'>'|'>='|'<'|'<='|'*'|'startsWith'|'endsWith'|'isIncludedIn'|'isNotIncludedIn'|'includes'|'doesNotInclude'|'empty'|'notEmpty'|'between'|'notBetween'|'isToday'|'isTomorrow'|'isYesterday'|'isThisWeek'|'isLastWeek'|'isNextWeek'|'isThisMonth'|'isLastMonth'|'isNextMonth'|'isThisYear'|'isLastYear'|'isNextYear'|'isYearToDate'|'isTrue'|'isFalse'}
   */
  set operator(operator) {
    this._operator = operator;
    // Signal to owner about filter change
    this.onChange('operator');
  }
  get operator() {
    const me = this;
    if (me._operator) {
      return me._operator;
    }
    if (Array.isArray(me.filterValue)) {
      return 'isIncludedIn';
    }
    return typeof me.filterValue === 'string' ? '*' : '=';
  }
  convert(value) {
    // This is a workaround for filterbar feature: it always converts input value to string. When date is typed,
    // it is converted into string, and Date.valueOf() would return number. So if we are matching date against string
    // type, we should not convert it.
    if (this.operator !== 'sameTime' && !(typeof this.filterValue === 'string' && value instanceof Date)) {
      var _value;
      if (this.operator === 'sameDay') {
        value = DateHelper.clearTime(value);
      }
      // if value is a complex type, try to access `value` property to get primitive value
      value = ((_value = value) === null || _value === void 0 ? void 0 : _value.valueOf()) ?? value;
    }
    value = !this.caseSensitive && typeof value === 'string' ? value.toLowerCase() : value;
    return value;
  }
  filter(candidate) {
    return this.filterBy(candidate);
  }
  startsWith(v) {
    return String(v).startsWith(this.filterValue);
  }
  endsWith(v) {
    return String(v).endsWith(this.filterValue);
  }
  isIncludedIn(v) {
    return this.filterValue.length === 0 || this.filterValue.includes(v);
  }
  isNotIncludedIn(v) {
    return !this.isIncludedIn(v);
  }
  includes(v) {
    return this.filterValue.length === 0 || String(v).includes(this.filterValue);
  }
  doesNotInclude(v) {
    return !this.includes(v);
  }
  sameTime(v) {
    return DateHelper.isSameTime(v, this.filterValue);
  }
  sameDay(v) {
    return v === this.filterValue;
  }
  '='(v) {
    return ObjectHelper.isEqual(v, this.filterValue);
  }
  '!='(v) {
    return !ObjectHelper.isEqual(v, this.filterValue);
  }
  '>'(v) {
    return ObjectHelper.isMoreThan(v, this.filterValue);
  }
  '>='(v) {
    return ObjectHelper.isMoreThan(v, this.filterValue) || ObjectHelper.isEqual(v, this.filterValue);
  }
  '<'(v) {
    return ObjectHelper.isLessThan(v, this.filterValue);
  }
  '<='(v) {
    return ObjectHelper.isLessThan(v, this.filterValue) || ObjectHelper.isEqual(v, this.filterValue);
  }
  '*'(v) {
    return ObjectHelper.isPartial(v, this.filterValue);
  }
  between(v) {
    const [start, end] = this._filterValue;
    return (ObjectHelper.isMoreThan(v, start) || ObjectHelper.isEqual(v, start)) && (ObjectHelper.isLessThan(v, end) || ObjectHelper.isEqual(v, end));
  }
  notBetween(v) {
    return !this.between(v);
  }
  empty(v) {
    return v === undefined || v === null || String(v).length === 0;
  }
  notEmpty(v) {
    return !this.empty(v);
  }
  isToday(v) {
    // Values have already been converted to fixed date range
    return this.between(v);
  }
  isTomorrow(v) {
    return this.between(v);
  }
  isYesterday(v) {
    return this.between(v);
  }
  isThisWeek(v) {
    return this.between(v);
  }
  isNextWeek(v) {
    return this.between(v);
  }
  isLastWeek(v) {
    return this.between(v);
  }
  isThisMonth(v) {
    return this.between(v);
  }
  isNextMonth(v) {
    return this.between(v);
  }
  isLastMonth(v) {
    return this.between(v);
  }
  isThisYear(v) {
    return this.between(v);
  }
  isNextYear(v) {
    return this.between(v);
  }
  isLastYear(v) {
    return this.between(v);
  }
  isYearToDate(v) {
    return this.between(v);
  }
  isTrue(v) {
    return v === true;
  }
  isFalse(v) {
    return v === false;
  }
  // Fill in actual dates relative to now
  setRelativeDateValues() {
    this._filterValue = CollectionFilter.getRelativeDateRange(this._operator).map(date => date.valueOf());
  }
  static getRelativeDateRange(relativeExpr, now = new Date()) {
    let todayStart, tomorrowStart, parts, oneTimeUnit, unitStart, which, timeUnit;
    switch (relativeExpr) {
      case 'isYearToDate':
        return [DateHelper.floor(now, '1 year'), now];
      case 'isToday':
        todayStart = DateHelper.floor(now, '1 day');
        return [todayStart, DateHelper.add(todayStart, 1, 'day')];
      case 'isYesterday':
        todayStart = DateHelper.floor(now, '1 day');
        return [DateHelper.add(todayStart, -1, 'day'), todayStart];
      case 'isTomorrow':
        tomorrowStart = DateHelper.getStartOfNextDay(now);
        return [tomorrowStart, DateHelper.add(tomorrowStart, 1, 'day')];
      case 'isThisWeek':
      case 'isNextWeek':
      case 'isLastWeek':
      case 'isThisMonth':
      case 'isNextMonth':
      case 'isLastMonth':
      case 'isThisYear':
      case 'isNextYear':
      case 'isLastYear':
        parts = relativeExpr.toLowerCase().match(relativeDateUnitRegExp);
        if (!parts) {
          throw new Error(`Unrecognized relative date expression: ${relativeExpr}`);
        }
        [, which, timeUnit] = parts;
        oneTimeUnit = `1 ${timeUnit}`;
        unitStart = DateHelper.floor(now, oneTimeUnit);
        if (which === 'next') {
          unitStart = DateHelper.add(unitStart, 1, timeUnit);
        } else if (which === 'last') {
          unitStart = DateHelper.add(unitStart, -1, timeUnit);
        }
        return [unitStart, DateHelper.add(unitStart, 1, timeUnit)];
    }
  }
  // Accepts an array or a Collection
  static generateFiltersFunction(filters) {
    if (!filters || !filters.length && !filters.count) {
      return FunctionHelper.returnTrue;
    }
    for (const filter of filters) {
      if (filter.type === 'date' && relativeDateOperators.includes(filter._operator)) {
        filter.setRelativeDateValues();
      }
    }
    return function (candidate) {
      let match = true;
      for (const filter of filters) {
        // Skip disabled filters
        if (!filter.disabled) {
          match = filter.filter(candidate);
        }
        if (!match) {
          break;
        }
      }
      return match;
    };
  }
}
CollectionFilter._$name = 'CollectionFilter';

/**
 * @module Core/helper/IdHelper
 */
// Id generation should be on a per page basis, not per module
const idCounts = ObjectHelper.getPathDefault(globalThis, 'bryntum.idCounts', Object.create(null));
/**
 * IdHelper provides unique ID generation.
 *
 * This class is not intended for application use, it is used internally by the Bryntum infrastructure.
 * @internal
 */
class IdHelper {
  /**
   * Generate a new id, using IdHelpers internal counter and a prefix
   * @param {String} prefix Id prefix
   * @returns {String} Generated id
   */
  static generateId(prefix = 'generatedId') {
    // This produces "b-foo-1, b-foo-2, ..." for each prefix independently of the others. In other words, it makes
    // id's more stable since the counter is on a per-class basis.
    return prefix + (idCounts[prefix] = (idCounts[prefix] || 0) + 1);
  }
}
IdHelper._$name = 'IdHelper';

/**
 * @module Core/util/CollectionSorter
 */
/**
 * A class which encapsulates a single sorter operation which may be applied to a {@link Core.util.Collection} to
 * order its elements in a specific way.
 *
 * A CollectionSorter generally has two properties:
 *
 * * `property` - The name of a property in collection objects by which to sort
 * * `direction` - The sort direction, `'ASC'` or `'DESC'`.
 *
 * It may also be configured with just a {@link #config-sortFn} function which returns the desired comparison
 * result when passed two objects to compare. Note that this does *not* require or use the
 * {@link #config-property} config. Two collection items are passed for comparison.
 *
 * Further configurations may affect how the sorter is applied:
 *
 * * `convert` - A function which, when passed the {@link #config-property} value from
 * a collection object, returns the value to sort by.
 *
 * A CollectionSorter may be configured to encapsulate a {@link #config-sortFn} by passing that function as the sole
 * parameter to the constructor:
 *
 *     new CollectionSorter((lhs, rhs) => {
 *         lhs = lhs.customerDetails.companyName.toLowerCase();
 *         rhs = rhs.customerDetails.companyName.toLowerCase();
 *
 *         if (lhs < rhs) {
 *             return -1;
 *         }
 *         else if (lhs > rhs) {
 *             return 1;
 *         }
 *         else {
 *             return 0;
 *         }
 *     });
 *
 */
class CollectionSorter extends Base {
  static get defaultConfig() {
    return {
      /**
       * The name of a property of collection objects which yields the value to sort by.
       * @config {String}
       */
      property: null,
      /**
       * The direction to sort in, `'ASC'` or `'DESC'`
       * @config {'ASC'|'DESC'}
       * @default
       */
      direction: 'ASC',
      /**
       * A function which takes the place of using {@link #config-property} and {@link #config-direction}.
       * The function is passed two objects from the collection to compare and must return the comparison result.
       * @config {Function}
       */
      sortFn: null,
      /**
       * When using {@link #config-property}, this may be specified as a function which takes the raw
       * property value and returns the value to actually sort by.
       * @config {Function}
       */
      convert: null,
      /**
       * The `id` of this Sorter for when used by a {@link Core.util.Collection} Collection.
       * By default the `id` is the {@link #config-property} value.
       * @config {String}
       */
      id: null,
      /**
       * Use `localeCompare()` when sorting, which lets the browser sort in a locale specific order. Set to `true`,
       * a locale string or a locale config to enable.
       *
       * Enabling this has big negative impact on sorting performance. For more info on `localeCompare()`, see
       * [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare).
       *
       * ```javascript
       * collection.addSorter({ field: 'name', useLocaleSort : 'sv-SE' });
       * ```
       *
       * @config {Boolean|String|Object}
       * @default false
       */
      useLocaleSort: null
    };
  }
  construct(config) {
    if (typeof config === 'function') {
      config = {
        sortFn: config
      };
    }
    super.construct(config);
  }
  /**
   * When in a Collection (A Collection holds its Sorters in a Collection), we need an id.
   * @property {String}
   * @private
   */
  get id() {
    return this._id || (this._id = this.property || IdHelper.generateId('b-sorter'));
  }
  set id(id) {
    this._id = id;
  }
  set sortFn(sortFn) {
    this._sortFn = sortFn;
  }
  get sortFn() {
    if (this._sortFn) {
      return this._sortFn;
    }
    return this.defaultSortFn;
  }
  /**
   * Default sortFn used when no sortFn specified. Uses the {@link #config-property},
   * {@link #config-direction}, and {@link #config-convert}.
   * @private
  */
  defaultSortFn(lhs, rhs) {
    const me = this,
      {
        convert,
        property,
        useLocaleSort
      } = me,
      multiplier = me.direction.toLowerCase() === 'desc' ? -1 : 1;
    lhs = lhs[property];
    rhs = rhs[property];
    if (convert) {
      lhs = convert(lhs);
      rhs = convert(rhs);
    }
    if (useLocaleSort && lhs != null && rhs != null && typeof lhs === 'string') {
      // Use systems locale
      if (useLocaleSort === true) {
        return String(lhs).localeCompare(rhs);
      }
      // Use specified locale
      if (typeof useLocaleSort === 'string') {
        return String(lhs).localeCompare(rhs, useLocaleSort);
      }
      // Use locale config
      if (typeof useLocaleSort === 'object') {
        return String(lhs).localeCompare(rhs, useLocaleSort.locale, useLocaleSort);
      }
    }
    return (lhs > rhs ? 1 : lhs < rhs ? -1 : 0) * multiplier;
  }
  static generateSortFunction(sorters, tieBreaker) {
    const items = sorters.isCollection ? sorters.values : sorters,
      n = items.length;
    return (lhs, rhs) => {
      let comp, i;
      for (i = 0; i < n; ++i) {
        comp = items[i].sortFn(lhs, rhs);
        if (comp) {
          return comp;
        }
      }
      return tieBreaker ? tieBreaker(lhs, rhs) : 0;
    };
  }
}
CollectionSorter._$name = 'CollectionSorter';

/**
 * @module Core/util/Collection
 */
const return0 = () => 0,
  reverseNumericSortFn = (a, b) => b - a,
  filteredIndicesProperty = Symbol('filteredIndicesProperty'),
  emptyArray$5 = Object.freeze([]),
  sortEvent = Object.freeze({
    action: 'sort',
    added: emptyArray$5,
    removed: emptyArray$5,
    replaced: emptyArray$5
  }),
  filterEvent = Object.freeze({
    action: 'filter',
    added: emptyArray$5,
    removed: emptyArray$5,
    replaced: emptyArray$5
  }),
  keyTypes = {
    string: 1,
    number: 1
  };
// Adds a single item to a single index using the specified key
function addItemToIndex(item, index, key) {
  // Unique holds a single entry
  if (index.unique !== false) {
    index.set(key, item);
  }
  // Non-unique index holds a Set
  else {
    let set = index.get(key);
    // Add a set if this is the first entry
    if (!set) {
      set = new Set();
      index.set(key, set);
    }
    // Add entry to the set
    set.add(item);
  }
}
// Removes a single item from a single index using the specified key
function removeItemFromIndex(item, index, key) {
  // Unique holds single entry, remove it
  if (index.unique !== false) {
    index.delete(key);
  } else if (index.has(key)) {
    // Remove from set
    index.get(key).delete(item);
    // Remove turned empty set
    if (!index.get(key).size) {
      index.delete(key);
    }
  }
}
// Used to fully build the indices, normal and filtered (if used). Better to do full builds for performance reasons
// when assigning new datasets. For other CRUD operations, indices are kept up to date elsewhere
function doRebuildIndices(values, indices, keyProps, indexCount) {
  for (let i = 0; i < values.length; i++) {
    const item = values[i];
    for (let j = 0; j < indexCount; j++) {
      const keyProp = keyProps[j],
        key = item[keyProp],
        index = indices[keyProp];
      addItemToIndex(item, index, key);
    }
  }
}
/**
 * A class which encapsulates a {@link #function-get keyed},
 * {@link #function-addFilter filterable}, {@link #function-addSorter sortable}
 * collection of objects. Entries may not be atomic data types such as `string` or `number`.
 *
 * The entries are keyed by their `id` which is determined by interrogating the {@link #config-idProperty}.
 *
 * To filter a Collection, add a {@link Core.util.CollectionFilter CollectionFilter}
 * using the {@link #function-addFilter} method. A Filter config object may be specified here
 * which will be promoted to a CollectionFilter instance.
 *
 * To sort a Collection, add a {@link Core.util.CollectionSorter CollectionSorter}
 * using the {@link #function-addSorter} method. A Sorter config object may be specified here
 * which will be promoted to a CollectionSorter instance.
 */
class Collection extends Base.mixin(Events) {
  _sortFunction = null;
  _addedValues = null;
  //region Config
  static get configurable() {
    return {
      /**
       * Specify the name of the property of added objects which provides the lookup key
       * @config {String}
       * @default
       */
      idProperty: 'id',
      /**
       * Specify the names or index configs of properties which are to be indexed for fast lookup.
       *
       * Index configs use the format `{ property : string, unique : boolean }`. Unique indices stores one index
       * per entry, non-unique stores a `Set`. If left out, `unique` defaults to `true`
       *
       * @config {String[]|Object[]}
       * @property {String} property Property to index by
       * @property {Boolean} [unique=true] `true` for unique keys (~primary keys), `false` for non-unique keys
       * (~foreign keys)
       */
      extraKeys: null,
      /**
       * Automatically apply filters on item add.
       * @config {Boolean}
       * @default
       */
      autoFilter: true,
      /**
       * Automatically apply sorters on item add.
       * @config {Boolean}
       * @default
       */
      autoSort: true,
      /**
       * A {@link Core.util.CollectionSorter Sorter}, or Sorter config object, or
       * an array of these, to use to sort this Collection.
       * @config {CollectionSorterConfig[]}
       * @default
       */
      sorters: {
        $config: ['lazy'],
        value: []
      }
    };
  }
  get isCollection() {
    return true;
  }
  //endregion
  //region Init & destroy
  construct(config) {
    /**
     * A counter which is incremented whenever the Collection is mutated in a meaningful way.
     *
     * If a {@link #function-splice} call results in no net replacement, removal or addition,
     * then the `generation` will not be incremented.
     * @property {Number}
     * @readonly
     */
    this.generation = 0;
    this._values = [];
    super.construct(config);
  }
  doDestroy() {
    var _me$_sorters;
    super.doDestroy();
    const me = this;
    me._values.length = 0;
    if (me.isFiltered) {
      me._filteredValues.length = 0;
      me.filters.destroy();
    }
    (_me$_sorters = me._sorters) === null || _me$_sorters === void 0 ? void 0 : _me$_sorters.destroy();
  }
  //endregion
  //region "CRUD"
  /**
   * Clears this collection.
   */
  clear() {
    const me = this,
      removed = me._values.slice();
    if (me.totalCount) {
      me._values.length = 0;
      if (me._filteredValues) {
        me._filteredValues.length = 0;
      }
      me._indicesInvalid = true;
      // Indicate to observers that data has changed.
      me.generation++;
      me.trigger('change', {
        action: 'clear',
        removed
      });
    }
  }
  /**
   * Compares the content of this Collection with the content of the passed Collection or
   * with the passed array. Order insensitive. This returns `true` if the two objects passed
   * contain the same set of items.
   * @param {Core.util.Collection|Array} other The Collection or array to compare with.
   * @param {Function} [map] Optionally a function to convert the items into a comparable object
   * to compare. For example `item => item.id` could be used to compare the ids of the
   * constituent items.
   * @returns {Boolean} `true` if the two objects passed have the same content.
   */
  equals(other, map) {
    if (other.isCollection) {
      other = other.values;
    }
    if (other.length === this.count) {
      let {
        values
      } = this;
      if (map) {
        other = other.map(map);
        values = values.map(map);
      }
      return ArrayHelper.delta(other, values).inBoth.length === this.count;
    }
    return false;
  }
  /**
   * Replaces the internal `values` array with the passed `values`, or `filteredValues` array with the passed `filteredValues`.
   * If `filteredValues` are not passed explicitly, but storage is filtered, decides internally `values` or `filteredValues` should
   * be replaced by passed `values`.
   *
   * Note that this takes ownership of the array, and the array must not be mutated by outside code.
   *
   * This is an internal utility method, not designed for use by application code.
   *
   * @param {Object} params Values and parameters to replace
   * @param {Object[]} params.values The new `values` array
   * @param {Object[]} [params.filteredValues] The new `filteredValues` array. Applicable only when storage is filtered.
   * @param {Boolean} [params.silent=false] If true, `change` event will not be fired
   * @param {Boolean} [params.isNewDataset=false] If true, `values` is a new dataset
   * @fires change
   * @internal
   */
  replaceValues({
    values,
    filteredValues,
    silent = false,
    isNewDataset = false
  }) {
    const me = this;
    let replacedValues, replacedFilteredValues;
    // The isNewDataset flag is passed by store#loadData to indicate that it's
    // a new data load, and that local filters can be applied.
    // Other use cases are for purely local updates of an existing dataset such as
    // refreshing the visible data with a values array containing group headers.
    if (me.isFiltered && !isNewDataset) {
      const filteredPassed = Boolean(filteredValues);
      // If `filteredValues` are missing, take `values` as a source of filtered values
      if (!filteredPassed) {
        filteredValues = values.slice();
        values = null;
      }
      // otherwise check if non-filtered values are passed together with filtered, and replace them too
      else if (values) {
        replacedValues = me._values;
        me._values = values.slice();
      }
      replacedFilteredValues = me._filteredValues;
      me._filteredValues = filteredValues.slice();
    } else {
      replacedValues = me._values;
      me._values = values.slice();
      filteredValues = null;
      if (me.isFiltered && isNewDataset && me.autoFilter) {
        me._filterFunction = null;
        me._filteredValues = me._values.filter(me.filterFunction);
      } else if (me._filteredValues) {
        me._filteredValues.length = 0;
      }
    }
    me._indicesInvalid = true;
    me._addedValues = undefined;
    // Indicate to observers that data has changed.
    me.generation++;
    if (!silent) {
      me.trigger('change', {
        action: 'replaceValues',
        replacedValues,
        replacedFilteredValues,
        values,
        filteredValues
      });
    }
  }
  set values(values) {
    // Want a full rebuild for new dataset, less costly than doing it per item
    this.invalidateIndices();
    this.splice(0, this._values.length, values);
  }
  /**
   * The set of values of this Collection. If this Collection {@link #property-isFiltered},
   * this yields the filtered data set.
   *
   * Setting this property replaces the data set.
   * @property {Object[]}
   */
  get values() {
    return this.isFiltered ? this._filteredValues : this._values;
  }
  /**
   * The set of filtered values of this Collection (those matching the current filters).
   * @property {Object[]}
   * @private
   */
  get filteredValues() {
    return this._filteredValues;
  }
  /**
   * Iterator that allows you to do `for (const item of collection)`
   */
  [Symbol.iterator]() {
    return this.values[Symbol.iterator]();
  }
  /**
   * Executes the passed function for each item in this Collection, passing in the item,
   * ths index, and the full item array.
   * @param {Function} fn The function to execute.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to include all items, bypassing filters.
   */
  forEach(fn, ignoreFilters = false) {
    (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).forEach(fn);
  }
  /**
   * Extracts ths content of this Collection into an array based upon the passed
   * value extraction function.
   * @param {Function} fn A function, which, when passed an item, returns a value to place into the resulting array.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to process an item even if it is filtered out.
   * @returns {Object[]} An array of values extracted from this Collection.
   */
  map(fn, ignoreFilters = false) {
    return (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).map(fn);
  }
  /**
   * Returns the first item in this Collection which elicits a *truthy* return value from the passed function.
   * @param {Function} fn A function, which, when passed an item, returns `true` to select it as the item to return.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to include filtered out items.
   * @returns {Object} The matched item, or `undefined`.
   */
  find(fn, ignoreFilters = false) {
    return (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).find(fn);
  }
  get first() {
    return this.values[0];
  }
  get last() {
    return this.values[this.count - 1];
  }
  /**
   * The set of all values of this Collection regardless of filters applied.
   * @readonly
   * @property {Object[]}
   */
  get allValues() {
    return this._values;
  }
  /**
   * The set of values added to this Collection since the last sort or replaceValues operation.
   * @private
   * @readonly
   * @property {Object[]}
   */
  get addedValues() {
    return this._addedValues;
  }
  /**
   * This method ensures that every item in this Collection is replaced by the matched by
   * `id` item in the other Collection.
   *
   * By default, any items in this Collection which are __not__ in the other Collection are removed.
   *
   * If the second parameter is passed as `false`, then items which are not in the other
   * Collection are not removed.
   *
   * This can be used for example when updating a selected record Collection when a new
   * Store or new store dataset arrives. The selected Collection must reference the latest
   * versions of the selected record `id`s
   * @param {Core.util.Collection} other The Collection whose items to match.
   */
  match(other, allowRemove = true) {
    const me = this,
      {
        _values
      } = me,
      toRemove = [];
    // Update selected records collection
    me.forEach(item => {
      const newInstance = other.get(item.id, true);
      // If item exists in other Collection, update this with a reference to the other version.
      // This must happen silently, so splice the _values array
      if (newInstance) {
        const index = me.indexOf(item, true),
          oldInstance = _values[index];
        // Replace the instance directly into our values
        _values[index] = newInstance;
        // Ensure the indexes match
        me.removeFromIndices(oldInstance);
        me.addToIndices(newInstance);
      } else if (allowRemove) {
        toRemove.push(item);
      }
    });
    if (toRemove.length) {
      me.remove(toRemove);
    }
    // The filtered set must match the new reality.
    if (me.isFiltered) {
      me._filteredValues = me._values.filter(me.filterFunction);
    }
    return toRemove;
  }
  /**
   * Adds items to this Collection. Multiple new items may be passed.
   *
   * By default, new items are appended to the existing values.
   *
   * Any {@link #property-sorters} {@link #property-sorters} present are re-run.
   *
   * Any {@link #property-filters} {@link #property-filters} present are re-run.
   *
   * *Note that if application functionality requires add and remove, the
   * {@link #function-splice} operation is preferred as it performs both
   * operations in an atomic manner*
   * @param  {...Object} items The item(s) to add.
   */
  add(...items) {
    if (items.length === 1) {
      this.splice(this._values.length, null, ...items);
    } else {
      this.splice(this._values.length, null, items);
    }
  }
  /**
   * Removes items from this Collection. Multiple items may be passed.
   *
   * Any {@link #property-sorters} {@link #property-sorters} present are re-run.
   *
   * Any {@link #property-filters} {@link #property-filters} present are re-run.
   *
   * *Note that if application functionality requires add and remove, the
   * {@link #function-splice} operation is preferred as it performs both
   * operations in an atomic manner*
   * @param  {...Object} items The item(s) to remove.
   */
  remove(...items) {
    if (items.length === 1) {
      this.splice(0, ...items);
    } else {
      this.splice(0, items);
    }
  }
  /**
   * Moves an individual item, or a block of items to another location.
   * @param {Object|Object[]} items The item/items to move.
   * @param {Object} [beforeItem] the item to insert the first item before. If omitted, the `item`
   * is moved to the end of the Collection.
   * @returns {Number} The new index of the `item`.
   */
  move(items, beforeItem) {
    items = ArrayHelper.asArray(items);
    // Handle the case of move(myItem, myItem). It's a no-op
    while (items.length && items[0] === beforeItem) {
      items.shift();
    }
    if (!items.length) {
      return;
    }
    const me = this,
      {
        _values
      } = me,
      itemIndex = me.indexOf(items[0], true);
    // move(record, followingrecord) is a no-op
    if (items.length === 1 && _values[itemIndex + 1] === beforeItem) {
      return;
    }
    // Silently remove the items that are to be inserted before the "beforeItem".
    me.suspendEvents();
    me.remove(items);
    me.resumeEvents();
    const beforeIndex = beforeItem ? me.indexOf(beforeItem, true) : _values.length;
    if (beforeIndex === -1) {
      throw new Error('Collection move beforeItem parameter must be present in Collection');
    }
    _values.splice(beforeIndex, 0, ...items);
    me._indicesInvalid = 1;
    me.trigger('change', {
      action: 'move',
      items,
      from: itemIndex,
      to: beforeIndex
    });
    return beforeIndex;
  }
  /**
   * The core data set mutation method. Removes and adds at the same time. Analogous
   * to the `Array` `splice` method.
   *
   * Note that if items that are specified for removal are also in the `toAdd` array,
   * then those items are *not* removed then appended. They remain in the same position
   * relative to all remaining items.
   *
   * @param {Number} index Index at which to remove a block of items. Only valid if the
   * second, `toRemove` argument is a number.
   * @param {Object[]|Number} [toRemove] Either the number of items to remove starting
   * at the passed `index`, or an array of items to remove (If an array is passed, the `index` is ignored).
   * @param  {Object[]|Object} [toAdd] An item, or an array of items to add.
   */
  splice(index = 0, toRemove, ...toAdd) {
    const me = this,
      idProperty = me.idProperty,
      values = me._values,
      newIds = {},
      removed = [],
      replaced = [],
      oldCount = me.totalCount;
    let added, mutated;
    // Create an "newIds" map of the new items so remove ops know if it's really a replace
    // {
    //     1234 : true
    // }
    // And an "added" array of the items that need adding (there was not already an entry for the id)
    //
    if (me.trigger('beforeSplice', {
      index,
      toRemove,
      toAdd
    }) === false) {
      return;
    }
    if (toAdd) {
      if (toAdd.length === 1 && Array.isArray(toAdd[0])) {
        toAdd = toAdd[0];
      }
      // Check for replacements if we contain any data
      if (oldCount && toAdd.length) {
        // Only risk rebuilding the indices if we are adding
        const idIndex = me.indices[idProperty];
        added = [];
        for (let i = 0; i < toAdd.length; i++) {
          const newItem = toAdd[i],
            id = newItem[idProperty],
            existingItem = idIndex.get(id),
            existingIndex = existingItem ? values.indexOf(existingItem) : -1;
          // Register incoming id so that removal leaves it be
          newIds[id] = true;
          // Incoming id is already present.
          // Replace it in place.
          if (existingIndex !== -1) {
            // If incoming is the same object, it's a no-op
            if (values[existingIndex] !== newItem) {
              replaced.push([values[existingIndex], newItem]);
              values[existingIndex] = newItem;
            }
          } else {
            added.push(newItem);
          }
        }
      }
      // Empty Collection, we simply add what we're passed
      else {
        added = toAdd;
      }
    }
    if (toRemove) {
      // We're removing a chunk starting at index
      if (typeof toRemove === 'number') {
        // Ensure we don't walk off the end if the toRemove count exceeds what we contain
        toRemove = Math.min(toRemove, values.length - index);
        for (let removeIndex = index; toRemove; --toRemove) {
          const id = values[removeIndex][idProperty];
          // If the entry here is being replaced, skip the insertion index past it
          if (newIds[id]) {
            index++;
            removeIndex++;
          }
          // If the id is not among incoming items, remove it
          else {
            removed.push(values[removeIndex]);
            values.splice(removeIndex, 1);
            mutated = true;
          }
        }
      }
      // We are removing an item/items
      else {
        let contiguous = added.length === 0,
          lastIdx;
        toRemove = ArrayHelper.asArray(toRemove);
        // Create array of index points to remove.
        // They must be in reverse order so that removal leaves following remove indices stable
        const removeIndices = toRemove.reduce((result, item) => {
          const isNumeric = typeof item === 'number',
            idx = isNumeric ? item : me.indexOf(item, true);
          // Drop out of contiguous mode if we find a non-contiguous record, or a remove *index*
          if (contiguous && (lastIdx != null && idx !== lastIdx + 1 || isNumeric)) {
            contiguous = false;
          }
          // Do not include indices out of range in our removeIndices
          if (idx >= 0 && idx < oldCount) {
            result.push(idx);
          }
          lastIdx = idx;
          return result;
        }, []).sort(reverseNumericSortFn);
        // If it's a pure remove of contiguous items with no adds, fast track it.
        if (contiguous) {
          // If reduced to zero by being asked to remove items we do not contain
          // then this is a no-op
          if (removeIndices.length) {
            removed.push.apply(removed, toRemove);
            values.splice(removeIndices[removeIndices.length - 1], removeIndices.length);
            mutated = true;
          }
        } else {
          // Loop through removeIndices splicing each index out of the values
          // unless there's an incoming identical id.
          for (let i = 0; i < removeIndices.length; i++) {
            const removeIndex = removeIndices[i];
            if (removeIndex !== -1) {
              const id = values[removeIndex][idProperty];
              // If the id is not among incoming items, remove it
              if (!newIds[id]) {
                removed.unshift(values[removeIndex]);
                values.splice(removeIndex, 1);
                mutated = true;
              }
            }
          }
        }
      }
      // Update indices only if they have been used
      if (removed.length && !me._indicesInvalid) {
        removed.forEach(me.removeFromIndices, me);
      }
    }
    // If we collected genuinely new entries, insert them at the splice index
    if (added.length) {
      values.splice(Math.min(index, values.length), 0, ...added);
      mutated = true;
      // Update indices only if they have been used
      if (!me._indicesInvalid) {
        added.forEach(me.addToIndices, me);
      }
      if (!me._addedValues) {
        me._addedValues = new Set();
      }
      for (const value of added) {
        me._addedValues.add(value);
      }
    }
    if (removed.length && me._addedValues) {
      for (const value of removed) {
        me._addedValues.delete(value);
      }
    }
    // Update indices only if they have been used
    if (replaced.length && !me._indicesInvalid) {
      replaced.forEach(rep => {
        me.removeFromIndices(rep[0]);
        me.addToIndices(rep[1]);
      });
    }
    // If we either added or removed items, or we did an in-place replace operation
    // then inform all interested parties.
    if (mutated || replaced.length) {
      // Ensure order of values matches the sorters
      if (me.isSorted) {
        me.onSortersChanged();
      }
      // The sort will also recreate the filteredValues so that it can be in correct sort order
      else if (me.isFiltered) {
        if (me.autoFilter) {
          me.onFiltersChanged({
            action: 'splice',
            oldCount: 1
          });
        } else {
          me._filteredValues.splice(Math.min(index, me._filteredValues.length), 0, ...added);
        }
      }
      // Indicate to observers that data has changed.
      me.generation++;
      /**
       * Fired when items are added, replace or removed
       * @event change
       * @param {'splice'|'clear'|'replaceValues'|'move'|'sort'|'filter'} action The underlying operation
       * which caused data change. May be `'splice'` (meaning an atomic add/remove operation, `'sort'` or
       * `'filter'`), `'clear'`, `'replaceValues'`, `'move'`, `'sort'` or `'filter'`.
       * @param {Core.util.Collection} source This Collection.
       * @param {Object[]} removed An array of removed items. If the `action` is `'filter'`, the
       * removed property represents the records which were filtered out by the action.
       * @param {Object[]} added An array of added items. If the `action` is `'filter'`, the
       * added property represents the records which were filtered in by the action.
       * @param {Object[]} replaced An array of replacements, each entry of which contains `[oldValue, newValue]`.
       * @param {Number} oldCount The number of items in the full, unfiltered collection prior to the splice operation.
       */
      me.trigger('change', {
        action: 'splice',
        removed,
        added,
        replaced,
        oldCount
      });
    } else {
      /**
       * Fired when a {@link #function-splice} operation is requested but the operation
       * is a no-op and has caused no change to this Collection's dataset. The splice
       * method's parameters are passed for reference.
       * @event noChange
       * @param {Number} index Index at which to remove a block of items.
       * @param {Object[]|Number} [toRemove] Either the number of items to remove starting
       * at the passed `index`, or an array of items to remove (If an array is passed, the `index` is ignored).
       * @param  {Object[]|Object} [toAdd] An item, or an array of items to add.
       */
      me.trigger('noChange', {
        index,
        toRemove,
        toAdd
      });
    }
  }
  /**
   * Change the id of an existing member by mutating its {@link #config-idProperty}.
   * @param {String|Number|Object} item The item or id of the item to change.
   * @param {String|Number} newId The id to set in the existing member.
   */
  changeId(item, newId) {
    const me = this,
      {
        idProperty
      } = me,
      oldId = keyTypes[typeof item] ? item : item[idProperty],
      member = me.get(oldId);
    if (member) {
      const existingMember = me.get(newId);
      if (existingMember && member !== existingMember) {
        throw new Error(`Attempt to set item ${oldId} to already existing member's id ${newId}`);
      }
      me.removeIndexEntry(item, idProperty, oldId);
      me.addIndexEntry(item, idProperty, newId);
      // Last on purpose, onItemMutation would fail to find the item if its id was changed prior to the call
      member[idProperty] = newId;
    }
  }
  /**
   * Returns the item with the passed `id`. By default, filtered are honoured, and
   * if the item with the requested `id` is filtered out, nothing will be returned.
   *
   * To return the item even if it has been filtered out, pass the second parameter as `true`.
   * @param {*} id The `id` to find.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to return an item even if it is filtered out.
   * @returns {Object} The found item, or `undefined`.
   */
  get(id, ignoreFilters = false) {
    return this.getBy(this.idProperty, id, ignoreFilters);
  }
  getAt(index, ignoreFilters = false) {
    if (this.isFiltered && !ignoreFilters) {
      return this._filteredValues[index];
    } else {
      return this._values[index];
    }
  }
  /**
   * Returns the item with passed property name equal to the passed value. By default,
   * filtered are honoured, and if the item with the requested `id` is filtered out,
   * nothing will be returned.
   *
   * To return the item even if it has been filtered out, pass the third parameter as `true`.
   * @param {String} propertyName The property to test.
   * @param {*} value The value to find.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to return an item even if it is filtered out.
   * @returns {Object} The found item, or `undefined`.
   */
  getBy(propertyName, value, ignoreFilters = false) {
    return this.findItem(propertyName, value, this.isFiltered && ignoreFilters);
  }
  /**
   * The number of items in this collection. Note that this honours filtering.
   * See {@link #property-totalCount};
   * @property {Number}
   * @readonly
   */
  get count() {
    return this.values.length;
  }
  /**
   * The number of items in this collection regardless of filtering.
   * @property {Number}
   * @readonly
   */
  get totalCount() {
    return this._values.length;
  }
  /**
   * The property name used to extract item `id`s from added objects.
   * @member {String} idProperty
   */
  updateIdProperty(idProperty) {
    this.addIndex({
      property: idProperty,
      unique: true
    });
  }
  //endregion
  //region Sorting
  /**
   * The Collection of {@link Core.util.CollectionSorter Sorters} for this Collection.
   * @member {Core.util.Collection} sorters
   */
  changeSorters(sorters) {
    return new Collection({
      values: ArrayHelper.asArray(sorters),
      internalListeners: {
        change: 'onSortersChanged',
        thisObj: this
      }
    });
  }
  /**
   * Adds a Sorter to the Collection of Sorters which are operating on this Collection.
   *
   * A Sorter may be specified as an instantiated {@link Core.util.CollectionSorter}, or a config object for a
   * CollectionSorter of the form
   *
   *     {
   *         property  : 'age',
   *         direction : 'desc'
   *     }
   *
   * Note that by default, a Sorter *replaces* a Sorter with the same `property` to make
   * it easy to change existing Sorters. A Sorter's `id` is its `property` by default. You
   * can avoid this and add multiple Sorters for one property by configuring Sorters with `id`s.
   *
   * A Sorter may also be specified as a function which compares two objects eg:
   *
   *     (lhs, rhs) => lhs.customerDetails.age - rhs.customerDetails.age
   *
   * @param {CollectionSorterConfig} sorter A Sorter configuration object to add to the Collection
   * of Sorters operating on this Collection.
   * @returns {Core.util.CollectionSorter} The resulting Sorter to make it easy to remove Sorters.
   */
  addSorter(sorter) {
    const result = sorter instanceof CollectionSorter ? sorter : new CollectionSorter(sorter);
    this.sorters.add(result);
    return result;
  }
  /**
   * A flag which is `true` if this Collection has active {@link #property-sorters}.
   * @property {Boolean}
   * @readonly
   */
  get isSorted() {
    var _this$_sorters;
    return Boolean((_this$_sorters = this._sorters) === null || _this$_sorters === void 0 ? void 0 : _this$_sorters.count);
  }
  onSortersChanged() {
    const me = this;
    me._sortFunction = null;
    me._addedValues = null;
    me._values.sort(me.sortFunction);
    me.trigger('change', sortEvent);
  }
  /**
   * A sorter function which encapsulates the {@link Core.util.CollectionSorter Sorters}
   * for this Collection.
   * @property {Function}
   * @readonly
   */
  get sortFunction() {
    if (!this._sortFunction) {
      if (this.isSorted) {
        this._sortFunction = CollectionSorter.generateSortFunction(this.sorters.values);
      } else {
        this._sortFunction = return0;
      }
    }
    return this._sortFunction;
  }
  //endregion
  //region Filtering
  /**
   * The Collection of {@link Core.util.CollectionFilter Filters} for this Collection.
   * @property {Core.util.Collection}
   * @readonly
   */
  get filters() {
    if (!this._filters) {
      this._filters = new Collection({
        internalListeners: {
          change: 'onFiltersChanged',
          thisObj: this
        }
      });
    }
    return this._filters;
  }
  /**
   * Adds a Filter to the Collection of Filters which are operating on this Collection.
   *
   * A Filter may be an specified as an instantiated {@link Core.util.CollectionFilter
   * CollectionFilter}, or a config object for a CollectionFilter of the form
   *
   *     {
   *         property : 'age',
   *         operator : '>=',
   *         value    : 21
   *     }
   *
   * Note that by default, a Filter *replaces* a Filter with the same `property` to make
   * it easy to change existing Filters. A Filter's `id` is its `property` by default. You
   * can avoid this and add multiple Filters for one property by configuring Filters with `id`s.
   *
   * A Filter may also be specified as a function which filters candidate objects eg:
   *
   *     candidate => candidate.customerDetails.age >= 21
   *
   * @param {CollectionFilterConfig|Core.util.CollectionFilter} filter A Filter or Filter configuration object to add
   * to the Collection of Filters operating on this Collection.
   * @returns {Core.util.CollectionFilter} The resulting Filter to make it easy to remove Filters.
   */
  addFilter(filter) {
    const result = filter instanceof CollectionFilter ? filter : new CollectionFilter(filter);
    this.filters.add(result);
    return result;
  }
  removeFilter(filter) {
    const {
      filters
    } = this;
    if (!filter.isCollectionFilter) {
      filter = filters.get(filter);
    }
    filters.remove(filter);
  }
  clearFilters() {
    this.filters.clear();
  }
  /**
   * A flag which is `true` if this Collection has active {@link #property-filters}.
   * @property {Boolean}
   * @readonly
   */
  get isFiltered() {
    return Boolean(this._filters && this._filters.count);
  }
  onFiltersChanged({
    action,
    removed: gone,
    oldCount
  }) {
    const me = this,
      oldDataset = oldCount || action === 'clear' && gone.length ? me._filteredValues : me._values;
    me._filterFunction = null;
    me._filteredValues = me._values.filter(me.filterFunction);
    me._indicesInvalid = true;
    const {
      toAdd: added,
      toRemove: removed
    } = ArrayHelper.delta(me._filteredValues, oldDataset, true);
    me.trigger('change', {
      ...filterEvent,
      added,
      removed
    });
  }
  /**
   * A filter function which encapsulates the {@link Core.util.CollectionFilter Filters}
   * for this Collection.
   * @property {Function}
   * @readonly
   */
  get filterFunction() {
    if (!this._filterFunction) {
      if (this.isFiltered) {
        this._filterFunction = CollectionFilter.generateFiltersFunction(this.filters.values);
      } else {
        this._filterFunction = FunctionHelper.returnTrue;
      }
    }
    return this._filterFunction;
  }
  //endregion
  //region Indexing
  changeExtraKeys(extraKeys) {
    const keys = ArrayHelper.asArray(extraKeys);
    // Normalize to always be an array of index configs
    return keys.map(config => {
      if (typeof config === 'string') {
        return {
          property: config,
          unique: true
        };
      }
      return config;
    });
  }
  updateExtraKeys(extraKeys) {
    for (let i = 0; i < extraKeys.length; i++) {
      this.addIndex(extraKeys[i]);
    }
  }
  /**
   * Adds a lookup index for the passed property name or index config. The index is built lazily when an index is
   * searched
   * @internal
   * @param {Object} indexConfig An index config
   * @param {String} indexConfig.property The property name to add an index for
   * @param {Boolean} [indexConfig.unique] Specify `false` to allow multiple entries of the same index, turning
   *   entries into sets
   * @param {Object} [indexConfig.dependentOn] The properties that make the key
   */
  addIndex(indexConfig) {
    const me = this;
    // Combo without valueField used in some tests -> addIndex(undefined). Safeguarding here
    if (indexConfig) {
      (me._indices || (me._indices = {}))[indexConfig.property] = new Map();
      // Piggyback the index config
      Object.assign(me._indices[indexConfig.property], indexConfig);
      // Indices need a rebuild now.
      me.invalidateIndices();
      if (indexConfig.dependentOn) {
        me.hasCompositeIndex = true;
      }
      /**
       * this.indices is keyed by the property name, and contains the keys linked to an item in the _values array.
       * So collection.add({id : foo, name : 'Nige'}, {id : 'bar', name : 'Faye'}) where collection has had an index
       * added for the "name" property would result in:
       *
       * {
       *     id : Map({
       *         foo : nige,
       *         bar : faye
       *     }),
       *     name : Map({
       *         Nige : nige,
       *         Faye : faye
       *     })
       * }
       */
    }
  }
  /**
   * Return the index of the item with the specified key having the specified value.
   *
   * By default, filtering is taken into account and this returns the index in the filtered dataset if present. To
   * bypass this, pass the third parameter as `true`.
   *
   * Only useful for indices configured with `unique: true`.
   *
   * @param {String} propertyName The name of the property to test.
   * @param {*} value The value to test for.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to return the index in
   * the original data set if the item is filtered out.
   * @returns {Number} The index of the item or `-1` if not found for unique indices
   */
  findIndex(propertyName, value, ignoreFilters = false) {
    const item = this.findItem(propertyName, value, ignoreFilters);
    if (!item) {
      return -1;
    }
    const values = this.isFiltered && !ignoreFilters ? this._filteredValues : this._values;
    return values.indexOf(item);
  }
  /**
   * Return the item with the specified key having the specified value.
   *
   * By default, filtering is taken into account. To bypass this, pass the third parameter as `true`.
   *
   * For indices configured with `unique: false`, a Set of items will be returned.
   *
   * @param {String} propertyName The name of the property to test.
   * @param {*} value The value to test for.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to return the index in
   * the original data set if the item is filtered out.
   * @returns {Object|Set} The found item or Set of items or null
   */
  findItem(propertyName, value, ignoreFilters = false) {
    const me = this,
      {
        isFiltered
      } = me,
      index = isFiltered && !ignoreFilters ? me.indices[filteredIndicesProperty][propertyName] : me.indices[propertyName];
    if (index) {
      // If the key is a numeric string, cast it to a number and find.
      // Store's idRegister is an object which treats numeric keys as strings
      // but Maps are more picky, so we have to work round that.
      const item = index.get(value) ?? (typeof value === 'string' && value.length && !isNaN(value) && index.get(Number(value)) || null);
      if (item != null) {
        return item;
      }
    } else {
      // Search the filtered values if we are filtered and not ignoring filters
      const values = isFiltered && !ignoreFilters ? me._filteredValues : me._values,
        count = values.length;
      for (let i = 0; i < count; i++) {
        const item = values[i];
        if (item[propertyName] == value) {
          return item;
        }
      }
    }
    return null;
  }
  removeIndex(propertyName) {
    delete this._indices[propertyName];
    this.hasCompositeIndex = Object.values(this.indices).some(index => index.dependentOn);
  }
  /**
   * Returns the index of the item with the same `id` as the passed item.
   *
   * By default, filtering is honoured, so if the item in question has been added, but is currently filtered out of
   * visibility, `-1` will be returned.
   *
   * To find the index in the master, unfiltered dataset, pass the second parameter as `true`;
   * @param {Object|String|Number} item The item to find, or an `id` to find.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to find the index in the master, unfiltered data set.
   * @returns {Number} The index of the item, or `-1` if not found.
   */
  indexOf(item, ignoreFilters = false) {
    return this.findIndex(this.idProperty, keyTypes[typeof item] ? item : item[this.idProperty], ignoreFilters);
  }
  /**
   * Returns `true` if this Collection includes an item with the same `id` as the passed item.
   *
   * By default, filtering is honoured, so if the item in question has been added,
   * but is currently filtered out of visibility, `false` will be returned.
   *
   * To query inclusion in the master, unfiltered dataset, pass the second parameter as `true`;
   * @param {Object|String|Number} item The item to find, or an `id` to find.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to find the index in the master, unfiltered data set.
   * @returns {Boolean} True if the passed item is found.
   */
  includes(item, ignoreFilters = false) {
    if (Array.isArray(item)) {
      return item.some(item => this.includes(item));
    }
    return Boolean(this.findItem(this.idProperty, keyTypes[typeof item] ? item : item[this.idProperty], ignoreFilters));
  }
  get indices() {
    if (this._indicesInvalid) {
      this.rebuildIndices();
    }
    return this._indices;
  }
  invalidateIndices() {
    this._indicesInvalid = true;
  }
  /**
   * Called when the Collection is mutated and the indices have been flagged as invalid.
   *
   * Rebuilds the indices object to allow lookup by keys.
   * @internal
   */
  rebuildIndices() {
    const me = this,
      isFiltered = me.isFiltered,
      indices = me._indices || (me._indices = {}),
      keyProps = Object.keys(indices),
      indexCount = keyProps.length,
      values = me._values;
    let filteredIndices;
    if (isFiltered) {
      filteredIndices = indices[filteredIndicesProperty] = {};
    }
    // First, clear indices.
    for (let i = 0; i < indexCount; i++) {
      const index = indices[keyProps[i]];
      index.clear();
      if (isFiltered) {
        let filteredIndex = filteredIndices[keyProps[i]];
        if (filteredIndex) {
          filteredIndex.clear();
        } else {
          filteredIndex = filteredIndices[keyProps[i]] = new Map();
          // Piggyback config
          filteredIndex.unique = index.unique;
        }
      }
    }
    doRebuildIndices(values, indices, keyProps, indexCount);
    // Create a parallel lookup structure into the _filteredValues
    if (isFiltered) {
      doRebuildIndices(me._filteredValues, filteredIndices, keyProps, indexCount);
    }
    me._indicesInvalid = false;
  }
  // Returns an array with [indices] or [indices, filteredIndices] if filtering is used
  getIndices(propertyName) {
    const indices = [this.indices[propertyName]];
    if (this.isFiltered) {
      indices.push(this.indices[filteredIndicesProperty][propertyName]);
    }
    return indices;
  }
  /**
   * Add an item to all indices
   * @param {*} item Item already available in the Collection
   * @private
   */
  addToIndices(item) {
    Object.keys(this.indices).forEach(propertyName => {
      this.addIndexEntry(item, propertyName, item[propertyName]);
    });
  }
  /**
   * Remove an item from all indices
   * @param {*} item Item already available in the Collection
   * @private
   */
  removeFromIndices(item) {
    Object.keys(this.indices).forEach(propertyName => {
      this.removeIndexEntry(item, propertyName, item[propertyName]);
    });
  }
  /**
   * Remove an entry from an index, and if filtering is used also from the filtered index.
   * @param {*} item Item already available in the Collection
   * @param {String} propertyName Property of the item, will be matched with configured indices
   * @param {*} oldValue Value to remove
   * @private
   */
  removeIndexEntry(item, propertyName, oldValue) {
    this.getIndices(propertyName).forEach(index => removeItemFromIndex(item, index, oldValue));
  }
  /**
   * Add a new entry to an index, and if filtering is used also to the filtered index.
   * @param {*} item Item already available in the Collection
   * @param {String} propertyName Property of the item, will be matched with configured indices
   * @param {*} value Value to store
   * @private
   */
  addIndexEntry(item, propertyName, value) {
    this.getIndices(propertyName).forEach(index => addItemToIndex(item, index, value));
  }
  /**
   * Call externally to update indices on item mutation (from Store)
   * @param {*} item Item already available in the Collection
   * @param {Object} wasSet Uses the `wasSet` format from Store, `{ field : { oldValue, newValue } }`
   * @internal
   */
  onItemMutation(item, wasSet) {
    const me = this;
    // Iterate over changes if we have extra indices defined, keeping those indices up to date
    if (!me._indicesInvalid && Object.keys(me.indices).length > 1) {
      Object.keys(wasSet).forEach(propertyName => {
        const indexConfig = me.indices[propertyName];
        if (indexConfig) {
          const {
            value,
            oldValue
          } = wasSet[propertyName];
          me.removeIndexEntry(item, propertyName, oldValue);
          me.addIndexEntry(item, propertyName, value);
        }
        // Might have both index and composite index
        if (me.hasCompositeIndex) {
          // Now check if any composite index depends on the property that was changed
          const dependentIndex = Object.values(me.indices).find(index => {
            var _index$dependentOn;
            return (_index$dependentOn = index.dependentOn) === null || _index$dependentOn === void 0 ? void 0 : _index$dependentOn[propertyName];
          });
          if (dependentIndex) {
            const keysAndOldValues = {};
            for (const o in dependentIndex.dependentOn) {
              var _wasSet$o;
              keysAndOldValues[o] = ((_wasSet$o = wasSet[o]) === null || _wasSet$o === void 0 ? void 0 : _wasSet$o.oldValue) || item[o];
            }
            const oldIndex = item.buildIndexKey(keysAndOldValues);
            me.removeIndexEntry(item, dependentIndex.property, oldIndex);
            me.addIndexEntry(item, dependentIndex.property, item[dependentIndex.property]);
          }
        }
      });
    }
  }
  //endregion
}
Collection._$name = 'Collection';

const nonPrimitives = new WeakMap(),
  safeIndexKey = value => {
    if (value && typeof value === 'object') {
      let substitute = nonPrimitives.get(value);
      if (substitute === undefined) {
        substitute = Symbol('bscik'); // Bryntum safe collection index key
        nonPrimitives.set(value, substitute);
      }
      value = substitute;
    }
    return value;
  };
/**
 * @module Core/util/Bag
 */
/**
 * A simple collection class to contain unique, keyed items.
 * @internal
 */
class Bag {
  constructor(config) {
    const me = this;
    me.generation = 0;
    me.items = new Set();
    me.idMap = {};
    me.idProperty = 'id';
    if (config) {
      if (config.idProperty) {
        me.idProperty = config.idProperty;
      }
      if (config.values) {
        me.values = config.values;
      }
    }
  }
  /**
   * Returns the item with the passed `id`.
   *
   * @param {*} id The `id` to find.
   * @returns {Object} The found item, or `undefined`.
   */
  get(key) {
    return this.idMap[safeIndexKey(key)];
  }
  /**
   * The number of items in this Bag.
   * @property {Number}
   * @readonly
   */
  get count() {
    return this.items.size;
  }
  /**
   * Adds the passed item(s) to this Bag. Existing items with the same ID
   * will be replaced.
   * @param {Object|Object[]} toAdd Item(s) to add.
   */
  add(...toAdd) {
    if (toAdd.length === 1 && Array.isArray(toAdd[0])) {
      toAdd = toAdd[0];
    }
    const me = this,
      {
        items,
        idMap,
        idProperty
      } = me,
      len = toAdd.length;
    for (let i = 0; i < len; i++) {
      const item = toAdd[i],
        key = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]),
        existingItem = idMap[key];
      // Not already present
      if (existingItem == null) {
        idMap[key] = item;
        items.add(item);
        me.generation++;
      }
      // Already present, replace it if different. No generational change.
      // IDs rule.
      else if (existingItem !== item) {
        idMap[key] = item;
        items.delete(existingItem);
        items.add(item);
      }
    }
  }
  /**
   * Returns `nth` item in this Bag.
   * @param {Number} nth The index of the matching item. Negative numbers index for the last item. For example, -1
   * returns the last item, -2 the 2nd to last item etc.
   * @returns {Object} The matched item, or `undefined`.
   */
  at(nth) {
    let item, ret;
    if (nth < 0) {
      nth += this.count; // ex: count=10 ... -1 -> 9, -2 -> 8, -3 -> 7, ... -9 -> 1, -10 -> 0
    }

    for (item of this.items) {
      if (!nth--) {
        ret = item;
        break;
      }
    }
    return ret;
  }
  /**
   * Removes the passed item(s) from this Bag.
   * @param {Object|Object[]} toRemove Item(s) to remove.
   */
  remove(toRemove) {
    toRemove = ArrayHelper.asArray(toRemove);
    const {
        items,
        idMap,
        idProperty
      } = this,
      len = toRemove.length;
    for (let i = 0; i < len; i++) {
      const item = toRemove[i],
        key = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]),
        existingItem = idMap[key];
      // Found match, so delete it
      if (existingItem != null) {
        items.delete(existingItem);
        delete idMap[key];
        this.generation++;
      }
    }
  }
  clear() {
    this.items.clear();
    this.idMap = {};
    this.generation++;
  }
  /**
   * Returns the number of items in this Bag which elicits a truthy return value from the passed function.
   * @param {Function} fn A function, which, when passed an item, returns `true` to select it as the item to return.
   * @returns {Number} The number of matched items.
   */
  countOf(fn) {
    let ret = 0,
      item;
    for (item of this.items) {
      if (fn(item)) {
        ++ret;
      }
    }
    return ret;
  }
  /**
   * Change the id of an existing member by mutating its idProperty.
   * @param {String|Number|Object} item The item or id of the item to change.
   * @param {String|Number} newId The id to set in the existing member.
   */
  changeId(item, newId) {
    const me = this,
      {
        idMap,
        idProperty
      } = me,
      oldId = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]),
      member = me.get(oldId);
    if (member) {
      const existingMember = me.get(newId);
      if (existingMember && member !== existingMember) {
        throw new Error(`Attempt to set item ${oldId} to already existing member's id ${newId}`);
      }
      member[idProperty] = newId;
      delete idMap[oldId];
      idMap[newId] = member;
    }
  }
  /**
   * Extracts the matching items from this Bag into an array based upon the passed value filter function.
   * @param {Function} fn A function, which, when passed an item, returns a `true` to place into the resulting array.
   * @param {Object} [thisObj] The `this` reference when the function is called.
   * @returns {Object[]} An array of values extracted from this Bag.
   */
  filter(fn, thisObj) {
    const {
        items
      } = this,
      result = [];
    let i = 0;
    items.forEach(item => {
      if (fn.call(thisObj, item, i++, items)) {
        result.push(item);
      }
    });
    return result;
  }
  /**
   * Returns `true` if this Collection includes an item with the same `id` as the passed item.
   *
   * @param {Object|String|Number} item The item to find, or an `id` to find.
   * @returns {Boolean} True if the passed item is found.
   */
  includes(item) {
    const key = keyTypes[typeof item] ? item : safeIndexKey(item[this.idProperty]);
    return Boolean(this.idMap[key]);
  }
  /**
   * Extracts the content of this Bag into an array based upon the passed
   * value extraction function.
   * @param {Function} fn A function, which, when passed an item, returns a value to place into the resulting array.
   * @param {Object} [thisObj] The `this` reference when the function is called.
   * @returns {Object[]} An array of values extracted from this Bag.
   */
  map(fn, thisObj) {
    const {
        items
      } = this,
      result = new Array(items.size);
    // Set has no map
    let i = 0;
    items.forEach(item => {
      result[i] = fn.call(thisObj, item, i++, items);
    });
    return result;
  }
  /**
   * Executes the passed function for each item in this Bag, passing in the item.
   * @param {Function} fn The function to execute.
   * @param {Object} [thisObj] The `this` reference when the function is called.
   */
  forEach(fn, thisObj) {
    return this.items.forEach(fn, thisObj);
  }
  /**
   * Returns `nth` item in this Bag which elicits a truthy return value from the provided matcher function `fn`.
   * @param {Function} fn A function which, when passed an item, returns `true` to select the item as a match.
   * @param {Number} [nth=0] The index of the matching item. By default, 0 returns the first item that matches
   * according to `fn`. Negative numbers index for the last item. For example, -1 returns the last matching item,
   * -2 the 2nd to last matching item etc..
   * @returns {Object} The matched item, or `undefined`.
   */
  find(fn, nth = 0) {
    let item, ret;
    if (nth < 0) {
      nth += this.countOf(fn); // ex: count=10 ... -1 -> 9, -2 -> 8, -3 -> 7, ... -9 -> 1, -10 -> 0
    }

    for (item of this.items) {
      if (fn(item) && !nth--) {
        ret = item;
        break;
      }
    }
    return ret;
  }
  /**
   * Iterator that allows you to do for (let item of bag)
   */
  [Symbol.iterator]() {
    return this.items[Symbol.iterator]();
  }
  indexOf(item, matchFn) {
    let index = -1,
      it;
    for (it of this.items) {
      if (!matchFn || matchFn(it)) {
        ++index;
        if (it === item) {
          return index;
        }
      }
    }
    return -1;
  }
  /**
   * The set of values of this Bag.
   *
   * Setting this property replaces the data set.
   * @property {Object[]}
   */
  get values() {
    return [...this.items];
  }
  set values(values) {
    values = ArrayHelper.asArray(values);
    this.clear();
    this.add.apply(this, values);
    this.generation++;
  }
  /**
   * Sort the values of this Bag using the passed comparison function.
   *
   * Setting this property replaces the data set.
   * @param {Function} fn Comparison function which returns -ve, 0, or +ve
   */
  sort(fn) {
    this.values = this.values.sort(fn);
  }
  some(fn, thisObj) {
    return this.values.some(fn, thisObj);
  }
}
Bag._$name = 'Bag';

/**
 * @module Core/data/StoreBag
 */
class StoreBag extends Bag {
  add(...toAdd) {
    if (toAdd.length === 1 && Array.isArray(toAdd[0])) {
      toAdd = toAdd[0];
    }
    // ignore unpersistable records
    return super.add(...toAdd.filter(record => record.isPersistable));
  }
}
StoreBag._$name = 'StoreBag';

/**
 * @module Core/data/mixin/StoreCRUD
 */
/**
 * Mixin for Store that handles modifying records (add, remove etc).
 *
 * @example
 * // add new record to store
 * store.add({ id: 1, team: 'FC Krasnodar' });
 *
 * // remove a record from store, using id
 * store.remove(1);
 *
 * @mixin
 */
var StoreCRUD = (Target => class StoreCRUD extends (Target || Base) {
  static get $name() {
    return 'StoreCRUD';
  }
  //region Config
  static get defaultConfig() {
    return {
      /**
       * Commit changes automatically
       * @config {Boolean}
       * @default
       * @category Common
       */
      autoCommit: false
    };
  }
  static get properties() {
    return {
      isRemoving: false,
      suspendCount: 0
    };
  }
  //endregion
  //region Events
  /**
   * Fired after removing all records
   * @event removeAll
   * @param {Core.data.Store} source This Store
   */
  /**
   * Fired before committing changes. Return false from handler to abort commit
   * @event beforeCommit
   * @param {Core.data.Store} source This Store
   * @param {Object} changes Modification data
   */
  /**
   * Fired after committing changes
   * @event commit
   * @param {Core.data.Store} source This Store
   * @param {Object} changes Modification data
   */
  /**
   * Fired before records are removed from this store by the {@link #function-remove} or {@link #function-removeAll}.
   * Also fired when removing a child record in a tree store using {@link Core.data.mixin.TreeNode#function-removeChild}.
   * The remove may be vetoed by returning `false` from a handler.
   * @event beforeRemove
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model[]} records The records which are to be removed.
   * @param {Core.data.Model} parent The record from which children are being removed when using a tree store. Only
   * provided when removing a single node.
   * @param {Boolean} isMove This flag is `true` if the child node is being removed by
   * {@link Core.data.mixin.TreeNode#function-appendChild appendChild} to be moved
   * _within the same tree_.
   * @param {Boolean} removingAll This flag is `true` if the operation is removing the store's entire data set.
   * @preventable
   */
  /**
   * Fired before records are added to this store by the {@link #function-add} or {@link #function-insert}. In a tree
   * store, also fired by {@link Core.data.mixin.TreeNode#function-appendChild} and
   * {@link Core.data.mixin.TreeNode#function-insertChild}. The add or insert may be vetoed by returning `false`
   * from a handler.
   * @event beforeAdd
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model[]} records The records which are to be added
   * @param {Core.data.Model} parent The parent node when using a tree store
   * @preventable
   */
  /**
   * Fired after adding/inserting record(s). If the record was added to a parent, the `isChild` flag is set on the
   * event. If it was inserted, event contains `index`
   * @event add
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model[]} records Added records. In case of tree store, if branch is added, only branch root
   * is returned
   * @param {Core.data.Model[]} [allRecords] Flat list of all added records. In case of tree store, if branch is
   * added, all new records are returned, not only branch root
   * @param {Core.data.Model} [parent] If due to an {@link Core/data/mixin/TreeNode#function-appendChild}
   * call, this is the parent node added to.
   * @param {Number} [index] Insertion point in the store's {@link Core.data.Store#config-storage Collection}.
   * @param {Number} [oldIndex] Not used for tree stores. The index of the first record moved.
   * @param {Boolean} [isChild] Flag which is set to true if the records are added to a parent record
   * @param {Boolean} [isExpand] Flag which is set to true if records are added to the store by expanding parent
   * @param {Object} [isMove] An object keyed by the ids of the records which were moved from another
   * position in the store, or from another parent node in the store. The ids of moved records will be
   * property names with a value `true`.
   */
  /**
   * Fired when one or more records are removed
   * @event remove
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model[]} records Array of removed records. In case of tree store, if branch is removed, only branch root
   * is returned
   * @param {Core.data.Model[]} [allRecords] Flat array of all removed records. In case of tree store, if branch is
   * removed, all removed records are returned, not only branch root
   * @param {Core.data.Model} [parent] If due to a {@link Core.data.mixin.TreeNode#function-removeChild removeChild}
   * call, this is the parent node removed from. Only applicable when removing a single tree node.
   * @param {Number} [index] Visible index at which record was removed. In case the record was removed from a collapsed
   * branch, -1 is returned. For tree store, this is only provided when removing a single node.
   * @param {Boolean} [isChild] Flag which is set to true if the record was removed from a parent record
   * @param {Boolean} [isCollapse] Flag which is set to true if records were removed from the store by collapsing parent
   * @param {Boolean} [isMove] Passed as `true` if the remove was part of a move operation within this Store.
   */
  //endregion
  //region Add, insert & remove
  /**
   * Removes a record from this store. Fires a single {@link #event-remove} event passing the removed records.
   * @param {String|String[]|Number|Number[]|Core.data.Model|Core.data.Model[]} records Record/array of records (or record ids) to remove
   * @param {Boolean} [silent] Specify `true` to suppress events/autoCommit
   * @returns {Core.data.Model[]} Removed records
   * @fires beforeRemove
   * @fires remove
   * @fires change
   * @category CRUD
   */
  remove(records, silent = false) {
    const me = this,
      {
        storage
      } = me;
    // Ensure we have an array of records in case we are passed IDs
    records = ArrayHelper.asArray(records).reduce((result, r) => {
      r = me.getById(r);
      if (r) {
        result.push(r);
      }
      return result;
    }, []);
    if (records.length === 0) {
      return records;
    }
    // Give chance to veto or take action before records disappear.
    if (!me.tree && !silent && me.trigger('beforeRemove', {
      records
    }) === false) {
      return [];
    }
    // Flag that can be checked in linked store to determine if removal is ongoing
    me.isRemoving = true;
    // Ensure that records in collapsed groups are removed and events fired.
    if (me.isGrouped) {
      const oldCount = storage.count,
        recordsInCollapsedGroups = [],
        changedGroupParents = new Set();
      // Collect any records which are in collapsed groups which will not be in the storage
      // Collection, and so will not cause a store change.
      // If we find some, we must fire the event which the store will react to and update itself.
      for (const rec of records) {
        const {
          groupParent
        } = rec.instanceMeta(me);
        if (groupParent.meta.collapsed) {
          recordsInCollapsedGroups.push(rec);
        }
        // Collect group header records which change so they can announce this to cause UI updates.
        ArrayHelper.remove(groupParent.groupChildren, rec);
        ArrayHelper.remove(groupParent.unfilteredGroupChildren, rec);
        groupParent.meta.childCount--;
        changedGroupParents.add(groupParent);
      }
      // The changed group parents must announce their changes, otherwise the group headers
      // in a UI will not refresh to reflect the change.
      for (const groupParent of changedGroupParents) {
        if (groupParent.groupChildren.length > 0) {
          me.onModelChange(groupParent, {}, {});
        }
      }
      // The store must react as if these records in collapsed groups have been removed from storage
      if (recordsInCollapsedGroups.length) {
        storage.trigger('change', {
          action: 'splice',
          removed: recordsInCollapsedGroups,
          added: [],
          replaced: [],
          oldCount
        });
      }
    } else if (me.tree) {
      const allRemovedRecords = [],
        removingMultiple = records.length > 1,
        firstRemoved = records[0],
        // index is only relevant when removing single node
        index = removingMultiple ? undefined : storage.indexOf(firstRemoved),
        // Group all tree nodes by their parent since they might be out of order
        removeChildArgs = records.reduce((result, child) => {
          const {
            parent
          } = child;
          if (parent) {
            if (!result[parent.id]) {
              result[parent.id] = [parent, []];
            }
            result[parent.id][1].push(child);
          }
          return result;
        }, {}),
        removals = Array.from(Object.values(removeChildArgs));
      if (!silent && me.trigger('beforeRemove', {
        records,
        isMove: false,
        parent: removingMultiple ? undefined : firstRemoved.parent
      }) === false) {
        me.isRemoving = false;
        return [];
      }
      // need to process the removals starting from deep-most ones, otherwise if we start with removal
      // from higher-level parent, then all its children are removed from the store as well
      // when the order comes to remove from the child node, it is not in the store and does not have
      // stm instance, so removal happens outside the stm context
      // https://github.com/bryntum/support/issues/5436
      removals.sort((a, b) => b[0].childLevel - a[0].childLevel);
      // Remove the records each from their correct parent
      for (const [parent, children] of removals) {
        allRemovedRecords.push(...parent.removeChild(children, false, true));
      }
      if (!silent) {
        me.trigger('remove', {
          // parent is only relevant when removing single node
          parent: removingMultiple ? undefined : firstRemoved.parent,
          index,
          isChild: true,
          allRecords: allRemovedRecords,
          isMove: false,
          records
        });
        me.trigger('change', {
          action: 'remove',
          records
        });
      }
      me.isRemoving = false;
      return records;
    }
    if (records.length === 0) {
      me.isRemoving = false;
      return records;
    }
    // Call model hook to allow taking action before removal (used by ModelLink to remove linked records)
    for (const record of records) {
      record.beforeRemove(records);
    }
    if (silent) {
      me.suspendEvents();
    }
    storage.remove(records);
    if (silent) {
      me.resumeEvents();
    }
    if (me.autoCommit) {
      me.doAutoCommit();
    }
    me.isRemoving = false;
    return records;
  }
  /**
   * Clears store data. Used by removeAll, separate function for using with chained stores.
   * @private
   * @category CRUD
   */
  clear(isLoading = false) {
    var _me$rootNode, _me$rootNode$unfilter;
    const me = this,
      {
        storage
      } = me;
    // For tree store, we have to check unfilteredChildren to see if store has contents
    if (me.storage.totalCount || (_me$rootNode = me.rootNode) !== null && _me$rootNode !== void 0 && (_me$rootNode$unfilter = _me$rootNode.unfilteredChildren) !== null && _me$rootNode$unfilter !== void 0 && _me$rootNode$unfilter.length) {
      // Give chance to veto or take action before records disappear.
      if (!isLoading && me.trigger('beforeRemove', {
        records: storage.allValues,
        removingAll: true
      }) === false) {
        return null;
      }
      // For tree scenario, clean up root node too
      if (me.rootNode) {
        // A chained tree store shares root node with its master store
        if (!me.isChained) {
          me.rootNode.clearChildren(isLoading);
        }
      } else if (isLoading) {
        // If we are loading, we suspend events, and Store#onDataChange won't get to
        // do all this stuff.
        const allRecords = me.registeredRecords;
        for (let i = allRecords.length - 1, rec; i >= 0; i--) {
          rec = allRecords[i];
          if (rec && !rec.isDestroyed) {
            rec.unjoinStore(me);
          }
        }
      }
      if (isLoading) {
        me.removed.clear();
        storage.suspendEvents();
      }
      // Clearing the storage will trigger 'removeAll' and 'change' if `removing`
      storage.clear();
      if (isLoading) {
        storage.resumeEvents();
      }
      me.added.clear();
      me.modified.clear();
    }
  }
  /**
   * Removes all records from the store.
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Boolean} `true` unless the action was prevented, in which case it returns `false`
   * @fires beforeRemove
   * @fires removeAll
   * @fires change
   * @category CRUD
   */
  removeAll(silent = false) {
    const me = this,
      storage = me.storage;
    let result;
    me.isRemoving = true;
    // No reaction to the storage Collection's change event.
    if (silent) {
      storage.suspendEvents();
      // If silent, the storage Collection won't fire the event we react to
      // to unjoin, and we allow the removing flag in remove() to be true,
      // so *it* will not do the unJoin, so if silent, so do it here.
      const allRecords = me.registeredRecords;
      for (let i = allRecords.length - 1, rec; i >= 0; i--) {
        rec = allRecords[i];
        if (rec && !rec.isDestroyed && !rec.isRoot) {
          rec.unjoinStore(me);
        }
      }
    }
    if (me.tree) {
      result = me.rootNode.clear() !== false;
    } else {
      result = me.clear() !== null;
    }
    if (silent) {
      storage.resumeEvents();
    }
    me.isRemoving = false;
    return result;
  }
  /**
   * Add records to store.
   * @param {Core.data.Model|Core.data.Model[]|Object|Object[]} records Array of records/data or a single record/data to add to store
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Core.data.Model[]} Added records
   * @fires add
   * @fires change
   * @category CRUD
   */
  add(records, silent = false, options = {}) {
    var _records2;
    const me = this,
      {
        storage
      } = me;
    records = ArrayHelper.asArray(records);
    if (!((_records2 = records) !== null && _records2 !== void 0 && _records2.length)) {
      // Adding zero records, bail out
      return;
    }
    me.tree = me.tree || Boolean(me.autoTree && records[0].children);
    if (me.tree) {
      const
        // Map and not Object to allow keys to keep their type
        parentIdMap = new Map(),
        parentIndexField = me.modelClass.getFieldDataSource('parentIndex'),
        {
          parentIdField
        } = me.modelClass,
        added = [];
      records.forEach(node => {
        const parentId = node[parentIdField];
        if (!parentIdMap.has(parentId)) {
          parentIdMap.set(parentId, {
            append: [],
            insert: []
          });
        }
        const entry = parentIdMap.get(parentId);
        // Allow inserting raw data at specific index when passing a parentIndex, used by
        // ProjectChangeHandlerMixin
        if (!node.isModel && parentIndexField in node) {
          entry.insert.push(node);
        } else {
          entry.append.push(node);
        }
      });
      parentIdMap.forEach(({
        append,
        insert
      }, parentId) => {
        const parentNode = parentId == null ? me.rootNode : me.getById(parentId);
        if (!parentNode) {
          throw new Error(`Parent node with id ${parentId} not found, cannot add children.`);
        }
        // Append all that needs appending in one go
        if (append.length) {
          added.push(...parentNode.appendChild(append, silent));
        }
        // Insertions has to happen one at the time
        if (insert.length) {
          for (const toInsert of insert) {
            added.push(parentNode.insertChild(toInsert, toInsert[parentIndexField], silent, options));
          }
        }
      });
      if (me.isFiltered && me.reapplyFilterOnAdd) {
        me.filter({
          silent: true
        });
      }
      // Sort if configured to do so on add, but not if syncing data on load since that will sort anyway
      if (me.reapplySortersOnAdd && !me.isSyncingDataOnLoad) {
        me.sort();
      }
      return added;
    }
    // Give chance to cancel action before records added.
    if (!silent && me.trigger('beforeAdd', {
      records
    }) === false) {
      return null;
    }
    me.tree = me.tree || Boolean(me.autoTree && records[0].children);
    if (me.tree) {
      return me.rootNode.appendChild(records);
    }
    const added = me.processRecords(records);
    if (silent) {
      me.suspendEvents();
    }
    storage.add(added);
    if (silent) {
      me.resumeEvents();
    }
    if (me.autoCommit) {
      me.doAutoCommit();
    }
    return added;
  }
  processRecords(records, onRecordCreated) {
    return records.map(data => {
      const record = this.processRecord(data.isModel ? data : this.createRecord(data));
      onRecordCreated === null || onRecordCreated === void 0 ? void 0 : onRecordCreated.call(this, record);
      return record;
    });
  }
  /**
   * Insert records into the store.
   * @param {Number} index Index to insert at
   * @param {Core.data.Model|Core.data.Model[]|Object|Object[]} records Array of records/data or a single record/data to insert to store
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Core.data.Model[]} Inserted records
   * @fires add
   * @fires change
   * @category CRUD
   */
  insert(index, records, silent = false) {
    const me = this,
      storage = me.storage,
      insertBefore = me.getAt(index),
      _records = storage.values,
      removeIndices = [];
    records = ArrayHelper.asArray(records);
    if (me.tree) {
      var _root$children;
      const root = me.rootNode;
      return root.insertChild(records, (_root$children = root.children) === null || _root$children === void 0 ? void 0 : _root$children[index], silent);
    }
    // Give chance to cancel action before records added.
    if (!silent && me.trigger('beforeAdd', {
      records
    }) === false) {
      return null;
    }
    let isNoop, start, i;
    // If the records starting at index or (index - 1), are the same sequence
    // that we are being asked to add, this is a no-op.
    if (_records[start = index] === records[0] || _records[start = index - 1] === records[0]) {
      for (isNoop = true, i = 0; isNoop && i < records.length; i++) {
        if (records[i] !== _records[start + i]) {
          isNoop = false;
        }
      }
    }
    if (isNoop) {
      return null;
    }
    const added = me.processRecords(records, record => {
      const removedAtIndex = storage.indexOf(record);
      if (record.children && record.children.length && me.autoTree) {
        me.tree = true;
      }
      // already in store, do some cleanup
      if (removedAtIndex > -1) {
        if (removedAtIndex < index && insertBefore) index--;
        removeIndices.push(removedAtIndex);
      }
      // Store previous index to be able to determine that it is a move, since Collection does not handle that
      record.meta.previousIndex = removedAtIndex;
    });
    // Silently remove them, so that they will be inserted into place.
    // Collection is stable by default, and inserting an existing item
    // is a no-op.
    me.suspendEvents();
    me.storage.remove(removeIndices);
    me.resumeEvents();
    if (silent) {
      me.suspendEvents();
    }
    storage.splice(index, 0, ...added);
    if (silent) {
      me.resumeEvents();
    }
    if (me.autoCommit) {
      me.doAutoCommit();
    }
    return added;
  }
  /**
   * Moves a record, or block of records to another location.
   * @param {Core.data.Model|Core.data.Model[]} records The record(s) to move.
   * @param {Core.data.Model} beforeRecord the record to insert the first record(s) before.
   * @fires change
   * @category CRUD
   */
  move(records, beforeRecord) {
    if (this.isTree) {
      beforeRecord.parent.insertChild(records, beforeRecord);
    } else {
      this.storage.move(records, beforeRecord);
    }
  }
  //endregion
  //region Update multiple
  setMultiple(filterFn, field, value) {
    const me = this,
      records = [],
      changes = [];
    me.forEach(r => {
      if (filterFn(r)) {
        changes.push(r.set(field, value, true));
        records.push(r);
      }
    });
    me.trigger('updateMultiple', {
      records,
      all: me.records.length === records.length
    });
    me.trigger('change', {
      action: 'updatemultiple',
      records,
      all: me.records.length === records.length
    });
    if (me.reapplyFilterOnUpdate && me.isFiltered) me.filter();
  }
  setAll(field, value) {
    const me = this,
      changes = [];
    me.forEach(r => {
      changes.push(r.set(field, value, true));
    });
    me.trigger('updateMultiple', {
      records: me.records,
      all: true
    });
    me.trigger('change', {
      action: 'updatemultiple',
      records: me.records,
      all: true
    });
    if (me.reapplyFilterOnUpdate && me.isFiltered) me.filter();
  }
  //endregion
  //region Commit
  /**
   * Accepts all changes, resets the modification tracking:
   * * Clears change tracking for all records
   * * Clears added
   * * Clears modified
   * * Clears removed
   * Leaves the store in an "unmodified" state.
   * @internal
   */
  acceptChanges() {
    const me = this;
    // Clear record change tracking
    me.added.forEach(r => r.clearChanges(true, false));
    me.modified.forEach(r => r.clearChanges(true, false));
    // Clear store change tracking
    me.added.clear();
    me.modified.clear();
    me.removed.clear();
  }
  /**
   * Commits changes, per default only returns changes and resets tracking.
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Object} Changes, see {@link #property-changes}
   * @fires beforeCommit
   * @fires commit
   * @category CRUD
   */
  commit(silent = false) {
    // resets stores tracking of changed records, doesn't store changes, only returns them
    const {
      changes
    } = this;
    if (!silent && this.trigger('beforeCommit', {
      changes
    }) === false) {
      return false;
    }
    this.acceptChanges();
    if (!silent) {
      this.trigger('commit', {
        changes
      });
    }
    return changes;
  }
  /**
   * Reverts all changes in the store (adds removed records back, and removes newly added records).
   * @fires change
   * @fires refresh
   * @category CRUD
   */
  revertChanges() {
    const me = this,
      {
        changes
      } = me;
    if (changes) {
      const event = {
        action: 'clearchanges',
        changes
      };
      me.add(me.removed.values, true);
      me.remove(me.added.values, true);
      me.modified.forEach(r => r.revertChanges(true));
      me.added.clear();
      me.modified.clear();
      me.removed.clear();
      me.trigger('change', event);
      me.trigger('refresh', event);
    }
  }
  /**
   * Get uncommitted changes as an object of added/modified/removed arrays of records.
   *
   * ```javascript
   * // Format:
   * {
   *      added: [], // array of Core.data.Model
   *      modified: [], // array of Core.data.Model
   *      removed: [] // array of Core.data.Model
   * }
   * ```
   *
   * @member {Object} changes
   * @property {Core.data.Model[]} changes.added Records that have been added
   * @property {Core.data.Model[]} changes.modified Records that have changes to persistable fields
   * @property {Core.data.Model[]} changes.removed Records that have been removed
   * @readonly
   * @category Records
   */
  get changes() {
    const me = this,
      // Only include modified records that have persistable changes
      modified = me.modified.values.filter(r => r.rawModifications);
    return me.added.count || modified.length || me.removed.count ? {
      // Slicing to have changes intact when triggering commit
      added: me.added.values.slice(),
      modified,
      removed: me.removed.values.slice()
    } : null;
  }
  /**
   * Setting autoCommit to true automatically commits changes to records.
   * @property {Boolean}
   * @category Records
   */
  get autoCommit() {
    return this._autoCommit;
  }
  set autoCommit(auto) {
    this._autoCommit = auto;
    if (auto && this.changes) {
      this.commit();
    }
  }
  /**
   * Suspends automatic commits upon store changes. Can be called multiple times (it uses an internal counter).
   * @category Records
   */
  suspendAutoCommit() {
    this.suspendCount++;
  }
  /**
   * Resumes automatic commits upon store changes. Will trigger commit if the internal counter is 0.
   * @category Records
   */
  resumeAutoCommit(doCommit = true) {
    this.suspendCount--;
    if (this.autoCommit && doCommit) {
      this.doAutoCommit();
    }
  }
  doAutoCommit() {
    if (this.suspendCount <= 0) {
      this.commit();
    }
  }
  //endregion
});

/**
 * @module Core/data/mixin/StoreChanges
 */
/**
 * Mixin for Store that handles applying changes (presumable from a backend)
 *
 * @mixin
 */
var StoreChanges = (Target => class StoreChanges extends (Target || Base) {
  static get $name() {
    return 'StoreChanges';
  }
  static get configurable() {
    return {
      /**
       * Specifies target to filter and sort after applying changeset:
       * * `'changes'` - apply sort and filter to changeset only (see more below)
       * * `'none'` - do not apply sort and filter
       *
       * ### `changes` behavior
       * If the store has filters in effect when the changeset is applied, the following rules will determine how the
       * filtered values are affected:
       * - Among added records, only those that match the filter will be included in the filtered set
       * - Among updated records, those that did not previously match the filter but now do will be added to the filtered set,
       *   and those that did match but no longer do will also remain in the filtered set. This means that new records may
       *   appear in the filtered set as a result of `applyChanges`, but records will not disappear until filters are
       *   re-applied.
       *
       * @default
       * @prp {'changes'|'none'}
       * @category Advanced
       */
      applyChangesetFilterSortTarget: 'changes'
    };
  }
  /**
   * Applies changes from another store to this store. Useful if cloning records in one store to display in a
   * grid in a popup etc. to reflect back changes.
   * @param {Core.data.Store} otherStore
   * @category CRUD
   */
  applyChangesFromStore(otherStore) {
    const me = this,
      {
        changes
      } = otherStore;
    if (!changes) {
      return;
    }
    if (changes.added) {
      me.add(changes.added);
    }
    if (changes.removed) {
      // Remove using id, otherwise indexOf in remove fn won't yield correct result
      me.remove(changes.removed.map(r => r.id));
    }
    if (changes.modified) {
      changes.modified.forEach(record => {
        const localRecord = me.getById(record.id);
        localRecord === null || localRecord === void 0 ? void 0 : localRecord.set(record.modifications);
      });
    }
  }
  /**
   * Applies a set of changes (presumable from a backend) expressed as an object matching the format outputted by the
   * {@link Core/data/Store#property-changes} property: `{ added : [], modified/updated : [], removed : [] }`
   *
   * `added` is expected to be an array of raw data objects consumable by the stores model class for records to add to
   * the store (see example snippet below).
   *
   * `modified` (or `updated` for compatibility with Schedulers CrudManager) is expected to have the same format as
   * `added`, but should always include the `id` of the record to update.
   *
   * Records that have been created locally and gets assigned a proper id by the backend are expected to also pass a
   * `phantomId` field (name of the field is configurable using the `phantomIdField` arg, more info on phantom ids
   * below), to match it with the current id of a local record (`id` will contain the new id).
   *
   * Note that it is also possible to pass this `phantomId` -> `id` mapping in the `added` array. When encountering a
   * record in that array that already exists in the local store, it will be treated the same was as a record in the
   * `modified` array.
   *
   * `removed` is expected to be an array of objects with the `{ id : xx }` shape. Any matches on an id in the store
   * will be removed, those and any non matches will also be cleared from the change tracking of the store.
   *
   * If the store has filters in effect when the changeset is applied, the following rules will determine how the
   * filtered values are affected:
   * - Among added records, only those that match the filter will be included in the filtered set
   * - Among updated records, those that did not previously match the filter but now do will be added to the filtered set,
   *   and those that did match but no longer do will also remain in the filtered set. This means that new records may
   *   appear in the filtered set as a result of `applyChanges`, but records will not disappear until filters are
   *   re-applied.
   *
   * As an example, consider a store with the following initial state and some operations performed on it:
   *
   * ```javascript
   * // Load some data into the store
   * store.data = [
   *     { id : 1, name : 'Minerva' },
   *     { id : 2, name : 'Mars' },
   *     { id : 3, name : 'Jupiter' }
   * ];
   * // Add a new record. It gets assigned a generated id,
   * // for example 'generated56'
   * store.add({ name : 'Artemis' });
   * // Remove Jupiter
   * store.remove(3);
   * ```
   *
   * After syncing those operations to a custom backend (however you chose to solve it in your application) we might
   * get the following response (see "Transforming a response to the correct format" below if your backend responds
   * in another format):
   *
   * ```javascript
   * const serverResponse = {
   *     added : [
   *         // Added by the backend, will be added locally
   *         { id : 5, name : 'Demeter' }
   *     ],
   *
   *     updated : [
   *         // Will change the name of Minerva -> Athena
   *         { id : 1, name : 'Athena' },
   *         // Will set proper id 4 for Artemis
   *         { $PhantomId : 'generated56', id : 4 }
   *     ],
   *
   *     removed : [
   *         // Confirmed remove of Jupiter
   *         { id : 3 },
   *         // Removed by the backend, Mars will be removed locally
   *         { id : 2 }
   *     ]
   * };
   * ```
   *
   * If that response is then passed to this function:
   *
   * ```javascript
   * store.applyChangeSet(serverResponse);
   * ```
   *
   * The end result will be the following data in the store:
   *
   * ```javascript
   * [
   *     { id : 1, name : 'Athena' }, // Changed name
   *     { id : 4, name : 'Artemis' }, // Got a proper id
   *     { id : 5, name : 'Demeter' } // Added by the backend
   * ]
   * ```
   *
   * ### Phantom ids
   *
   * When a record is created locally, it is always assigned a generated id. That id is called a phantom id (note that
   * it is assigned to the normal id field). When passing the new record to the backend, the id is sent with it. When
   * the backend inserts the record into the database, it (normally) gets a proper id assigned. That id then needs to
   * be passed back in the response, to update the local record with the correct id. Making sure that future updates
   * match the correct row in the database.
   *
   * For example a newly created record should be passed similar to this to the backend (pseudo format, up to the
   * application/backend to decide):
   *
   * ```json
   * {
   *     "added" : {
   *         "id" : "generated79",
   *         "name" : "Hercules",
   *         ...
   *     }
   * }
   * ```
   *
   * For the backend response to be applicable for this function, it should then respond with:
   *
   * ```json
   * {
   *     "updated" : {
   *         {
   *             "$PhantomId" : "generated79",
   *             "id" : 465
   *         }
   *     }
   * }
   * ```
   *
   * (Or, as stated above, it can also be passed in the "added" array. Which ever suits your backend best).
   *
   * This function will then change the id of the local record using the phantom id `generated79` to `465`.
   *
   * ### Transforming a response to the correct format
   *
   * This function optionally accepts a `transformFn`, a function that will be called with the `changes`. It is
   * expected to return a changeset in the format described above (`{ added : [], updated : [], removed : [] }`),
   * which then will be used to apply the changes.
   *
   * Consider the following "non standard" (made up) changeset:
   *
   * ```javascript
   * const changes = {
   *     // Database ids for records previously added locally
   *     assignedIds : {
   *         'phantom1' : 10,
   *         'phantom2' : 15
   *     },
   *     // Ids records removed by the backend
   *     removed : [11, 27],
   *     // Modified records, keyed by id
   *     altered : {
   *         12 : { name : 'Changed' }
   *     },
   *     // New records, keyed by id
   *     inserted : {
   *         20  : { name : 'New' }
   *     }
   * }
   * ```
   *
   * Since it does not match the expected format it has to be transformed:
   *
   * ```javascript
   * store.applyChangeset(changes, ({ assignedIds, inserted, altered, removed }) => ({
   *    // Convert inserted to [{ id : 20, name : 'New' }]
   *    added : Object.entries(inserted).map(([id, data] => ({ id, ...data }),
   *    updated : [
   *        // Convert assignedIds to [{ $PhantomId : 'phantom1', id : 10 }, ...]
   *       ...Object.entries(assignedIds).map(([phantomId, id])) => ({ $PhantomId : phantomId, id }),
   *       // Convert altered to [{ id : 12, name : 'Changed' }]
   *       ...Object.entries(modified).map(([id, data] => ({ id, ...data })
   *    ],
   *    // Convert removed to [{ id : 11 }, ...]
   *    removed : removed.map(id => ({ id }))
   * }));
   * ```
   *
   * The transform function above would output:
   *
   * ```javascript
   * {
   *     added : [
   *         {  id : 20, name : 'New' }
   *     ],
   *     updated : [
   *         { $PhantomId : 'phantom1', id : 10 },
   *         { $PhantomId : 'phantom2', id : 15 },
   *         {  id : 12, name : 'Changed' }
   *     ],
   *     removed : [
   *        { id : 11 },
   *        { id : 12 }
   *     ]
   * }
   * ```
   *
   * And that format can then be applied.
   *
   * @param {Object} changes Changeset to apply to the store, see specification above
   * @param {Function} [transformFn] Optional function used to preprocess a changeset in a different format,
   * should return an object with the format expected by this function (see above)
   * @param {String} [phantomIdField] Field used by the backend when communicating a record being assigned a proper id
   * instead of a phantom id (see above)
   * @privateparam {Boolean} [remote] Set to true to indicate changes are from the remote source. Remote changes have
   * precedence over local.
   * @privateparam {Boolean} [logChanges] Used by CrudManager to be able to revert specific changes later
   * @category CRUD
   */
  applyChangeset(changes, transformFn = null, phantomIdField = '$PhantomId', remote = true, logChanges = false) {
    const me = this,
      {
        added,
        updated,
        modified,
        removed
      } = (transformFn === null || transformFn === void 0 ? void 0 : transformFn(changes, me)) ?? changes,
      // To support both updated & modified (store uses modified, CM updated)
      altered = updated ?? modified ?? [],
      idDataSource = me.modelClass.getFieldDataSource('id'),
      log = logChanges ? new Map() : null,
      allAdded = [],
      allAltered = [];
    let rootUpdated = false,
      modifiedParents = [];
    // Store currently visible records to keep records which no longer match filter in view
    me._groupVisibleRecordIds = [];
    // We only need this for grouped store which cannot be a tree store
    me.isGrouped && me.forEach(record => {
      me._groupVisibleRecordIds.push(record.id);
    });
    // Process added records
    if ((added === null || added === void 0 ? void 0 : added.length) > 0) {
      const toUpdate = [],
        toAdd = [];
      // Separate actually new records from added records that get a proper id set up, to match more backends
      for (const data of added) {
        if (me.getById(data[phantomIdField] ?? ObjectHelper.getPath(data, idDataSource))) {
          // we need to keep order of the added records
          // https://github.com/bryntum/support/issues/5189
          toUpdate.push(data);
        } else {
          toAdd.push(data);
        }
      }
      altered.unshift.apply(altered, toUpdate);
      // Create new records in the store, and clear them out of the added bag
      // When applying remote changes we do not want to update ordered tree index until all
      // add/update/remove action are finalized. After that we can sort it correctly.
      const addedRecords = me.add(toAdd, false, {
        orderedParentIndex: {
          skip: true
        }
      }) ?? [];
      allAdded.push(...addedRecords);
      if (me.tree) {
        // Go over added records and find all parents which children are modified in case
        // we need to restore ordered tree
        for (const record of addedRecords) {
          const {
            parent
          } = record;
          // If root WBS should be updated
          if (parent.isRoot) {
            rootUpdated = true;
            modifiedParents = [parent];
            break;
          }
          if (!parent.isRoot && modifiedParents.every(r => !r.contains(parent))) {
            modifiedParents.push(parent);
          }
        }
      }
      for (const record of addedRecords) {
        log === null || log === void 0 ? void 0 : log.set(record.id, record.data);
        record.clearChanges();
      }
    }
    // Process modified records
    if ((altered === null || altered === void 0 ? void 0 : altered.length) > 0) {
      for (const data of altered) {
        const phantomId = data[phantomIdField],
          id = ObjectHelper.getPath(data, idDataSource),
          record = me.getById(phantomId ?? id);
        // Matching an existing record -> update it
        if (record) {
          const changes = record.applyChangeset(data, phantomIdField, remote);
          // If current record is not part of tree already scheduled to ordering, add it
          if (me.tree && !rootUpdated && modifiedParents.every(r => !r.contains(record))) {
            if (record.parent.isRoot) {
              rootUpdated = true;
              modifiedParents = [record.parent];
            } else {
              modifiedParents.push(record.parent);
            }
          }
          log === null || log === void 0 ? void 0 : log.set(id, changes);
          allAltered.push(record);
        }
      }
    }
    // Process removed records
    if ((removed === null || removed === void 0 ? void 0 : removed.length) > 0) {
      me.applyRemovals(removed);
    }
    if (me.applyChangesetFilterSortTarget === 'changes') {
      const parentsModifiedByFilter = me.filterChangeset(allAdded, allAltered);
      modifiedParents.push(...parentsModifiedByFilter);
    }
    me.afterChangesetApplied(modifiedParents);
    me._groupVisibleRecordIds = null;
    return log;
  }
  afterChangesetApplied(modifiedParents) {
    // Can we always safely use ordered tree?
    modifiedParents.forEach(parent => {
      parent.traverse(record => {
        record.sortOrderedChildren(false, false);
        // Parent index from the remote source might have been applied, in which case
        // we need to update local index because we do not want any movements in the tree
        if (record.children) {
          record.updateChildrenIndices(record.children, 'parentIndex', true);
        }
        if (record.unfilteredChildren) {
          record.updateChildrenIndices(record.unfilteredChildren, 'unfilteredIndex', true);
        }
      });
    });
  }
  // Apply removals, removing records and updating the `removed` bag to match.
  //
  // Accepts an array of objects containing an `id` property. Records in the store matching an entry in the array
  // will be removed from the store and the `removed` bag. Unmatched entries will be removed from the `removed` bag.
  applyRemovals(removals) {
    const me = this,
      {
        removed: removedStash
      } = me,
      idDataSource = me.modelClass.idField,
      toRemove = [];
    for (const removedEntry of removals) {
      const id = ObjectHelper.getPath(removedEntry, idDataSource);
      // Removed locally and confirmed by server, just remove the record from the removed stash
      if (removedStash.includes(id)) {
        removedStash.remove(id);
      }
      // Server driven removal (most likely), collect for removal locally too
      else {
        toRemove.push(id);
      }
    }
    // Remove collected records in one go
    me.remove(toRemove);
    // Leave no trace of them at all
    for (const record of toRemove) {
      removedStash.remove(record);
    }
  }
  /**
   * Filters records that have been added/updated as part of a changeset. The `added` and `updated` parameters
   * are arrays of values that have already been added/updated in the Collection's values. This method brings
   * the Collection's `_filteredValues` in sync without performing a full sort or filter, using the following rules:
   *
   * - Added records that do not match the filter are removed from _filteredValues
   *
   * - Updated records that now match the filter are inserted at the correct position in _filteredValues
   *   if they were not formerly included
   *
   * - Updated records that formerly matched the filter, but now do not, are NOT removed from _filteredValues
   *
   * If the collection is sorted, either on its own or via a sort applied at the store level, that sort order is
   * respected when adding items to _filteredValues. If not, items are inserted in the same order they occur in
   * _values.
   *
   * @param {Object[]} added An array of unique values that were added as part of the changeset.
   * @param {Object[]} updated An array of unique values that were updated as part of the changeset.
   * @returns {Object[]} Any records that were added or removed from view, or whose children were modified.
   * @private
   */
  filterChangeset(added, updated) {
    const me = this,
      {
        isFiltered,
        tree,
        isGrouped,
        filtersFunction
      } = me,
      storeSortFunction = me.isSorted ? me.createSorterFn(me.sorters) : undefined,
      {
        allValues,
        addedValues,
        isSorted
      } = me.storage,
      sorter = storeSortFunction != null || isSorted ? storeSortFunction ?? me.storage.sortFunction : null,
      modifiedParents = new Set();
    if (!isFiltered) {
      return [];
    }
    let trigger = false,
      groupers;
    // When groups are involved we always rebuild them entirely. We need to store groupers, remove them to get flat
    // store, apply flat store logic regarding filtering changes, and then re-group store again
    // https://github.com/bryntum/support/issues/6134
    if (isGrouped) {
      groupers = me.groupers;
      me.clearGroupers(true);
    }
    if (tree) {
      const nodesToInclude = new Set(updated.filter(filtersFunction));
      // Tree store does not automatically include new filter-matching nested descendants inside
      // collapsed branches; we must make sure they and their ancestors are all included in the filtered set
      for (const matchingAdd of added.filter(filtersFunction)) {
        nodesToInclude.add(matchingAdd);
      }
      // Expand to include all ancestors of included rows
      nodesToInclude.forEach(node => node.bubble(ancestor => nodesToInclude.add(ancestor)));
      nodesToInclude.delete(me.rootNode);
      const nodesToIncludeByParent = ArrayHelper.groupBy(Array.from(nodesToInclude), 'parentId');
      for (const siblingsToInclude of Object.values(nodesToIncludeByParent)) {
        const {
          parent
        } = siblingsToInclude[0];
        // If `unfilteredChildren` is null, we assume `children` already contains all available children
        if (parent.unfilteredChildren) {
          // Ignore ordering here and just append non-duplicates to `children`
          parent.children.push(...siblingsToInclude.filter(child => !parent.children.includes(child)));
          modifiedParents.add(parent); // Remember that we modified this, to re-sort later
        }
      }
    }
    // If store is grouped, sorter will be applied anyway
    else if (sorter && !isGrouped) {
      // Non-tree, sorted store
      // Current approach is to divide the filtered list into a "sorted" head and an unsorted tail (items added
      // since last sort). Insert the newly-matching items into the sorted part, re-sort that, then re-append
      // the unsorted tail
      const
        // Must wait to read filteredValues after clearGroupers
        {
          filteredValues
        } = me.storage,
        sortedLength = addedValues ? filteredValues.findLastIndex(value => !addedValues.has(value)) + 1 : filteredValues.length,
        sorted = filteredValues.slice(0, sortedLength),
        updatedMatches = new Set(updated.filter(filtersFunction));
      for (const value of filteredValues) {
        if (updatedMatches.has(value)) {
          updatedMatches.delete(value);
        }
      }
      for (const newMatch of updatedMatches) {
        sorted.push(newMatch);
      }
      sorted.sort(sorter);
      filteredValues.splice(0, sortedLength, ...sorted);
      trigger = true;
    } else {
      // Non-tree, non-sorted store
      // Move through filtered and unfiltered lists in order, inserting raw value into filtered list whenever one
      // is encountered that's in the set of matching, updated values
      const updatedMatches = updated.filter(item => filtersFunction(item) && !me.storage.includes(item));
      if (updatedMatches.length > 0) {
        me.includeInSubset(allValues, me.storage.filteredValues, updatedMatches);
        trigger = true;
      }
    }
    // Un-show non-matching added records
    const nonMatchingAdds = new Set(added.filter(value => !filtersFunction(value)));
    if (nonMatchingAdds.size > 0) {
      if (tree) {
        for (const addedChild of nonMatchingAdds) {
          ArrayHelper.remove(addedChild.parent.children, addedChild);
          modifiedParents.add(addedChild.parent);
        }
      } else {
        ArrayHelper.remove(me.storage.filteredValues, nonMatchingAdds);
      }
      trigger = true;
    }
    if (groupers) {
      me.group(groupers[0], null, false, true, true);
      trigger = true;
    }
    if (tree && modifiedParents.size > 0) {
      me.storage.replaceValues({
        values: me.collectDescendants(me.rootNode).visible,
        silent: true
      });
    } else if (trigger) {
      // Storage content has changed, clear idMap to rebuild it
      me._idMap = null;
      me.trigger('refresh');
    }
    return [...modifiedParents];
  }
  /**
   * Given an array `all`, an array `subset` that is a subset of `all` in the same order, and another array
   * `toInclude` that is a different subset of `all` disjoint with `subset`, add each item from `toInclude`
   * to `subset`, in an order matching the order in `all`. The order of `subset` must match the order of `all`.
   * The order of `toInclude` is unimportant.
   *
   * Modifies `subset` in-place.
   *
   * @param {Array} all An array of unique items (e.g. records)
   * @param {Array} subset An array containing a subset of the items in `all` (same order as `all`)
   * @param {Array} toInclude An array or items from `all` that should be included in `subset` (unordered)
   * @returns {Array} The subset modified in-place.
   * @private
   */
  includeInSubset(all, subset, toInclude) {
    const toIncludeSet = new Set(toInclude);
    let subsetIndex = 0,
      allIndex = 0,
      done = toIncludeSet.size === 0;
    while (allIndex < all.length && !done) {
      const subsetItem = subset[subsetIndex];
      let allItem = all[allIndex];
      // Move ahead in raw list until we find the matching item, inserting new items along the way
      while (subsetItem !== allItem) {
        if (toIncludeSet.has(allItem)) {
          subset.splice(subsetIndex, 0, allItem);
          subsetIndex++;
          toIncludeSet.delete(allItem);
          done = toIncludeSet.size === 0;
        }
        allItem = all[++allIndex];
      }
      // Ignore "to include" items that are already in the subset (prevents duplicates)
      if (toIncludeSet.has(subsetItem)) {
        toIncludeSet.delete(subsetItem);
      }
      // Keep going in filtered list
      if (subsetIndex < subset.length) {
        subsetIndex++;
      }
    }
    return subset;
  }
});

/**
 * @module Core/data/mixin/StoreFilter
 */
/**
 * Mixin for Store that handles filtering.
 * Filters are instances of {@link Core/util/CollectionFilter} class.
 *
 * - Adding a filter for the same property will replace the current one (unless a unique {@link Core.util.CollectionFilter#config-id} is specified),
 * but will not clear any other filters.
 * - Adding a filter through the {@link #function-filterBy} function is ultimate.
 * It will clear all the property based filters and replace the current filterBy function if present.
 * - Removing records from the store does not remove filters!
 * The filters will be reapplied if {@link #config-reapplyFilterOnAdd}/{@link #config-reapplyFilterOnUpdate} are true and you add new records or update current.
 *
 * ```javascript
 * // Add a filter
 * store.filter({
 *     property : 'score',
 *     value    : 10,
 *     operator : '>'
 * });
 *
 * // Add filter as a function
 * store.filter(record => record.score > 10);
 *
 * // Add named filter as a function
 * store.filter({
 *     id : 'my filter',
 *     filterBy : record => record.score > 10
 * });
 *
 * // Replace any filter set with new filters
 * store.filter({
 *     filters : {
 *         property : 'score',
 *         value    : 10,
 *         operator : '>'
 *     },
 *     replace : true
 * });
 *
 * // Remove this one specific filter, leaving any possible others in place.
 * // A filter's id defaults to the property name that it's filtering on.
 * store.removeFilter('score');
 *
 * // Reapply filters without firing an event.
 * // Use if making multiple data mutations with the
 * // intention of updating UIs when all finished.
 * store.filter({
 *     silent : true
 * });
 * ```
 *
 * @mixin
 */
var StoreFilter = (Target => class StoreFilter extends (Target || Base) {
  static get $name() {
    return 'StoreFilter';
  }
  //region Config
  static get defaultConfig() {
    return {
      /**
       * Specify one or more {@link Core/util/CollectionFilter} config objects to apply initially.
       *
       * For example:
       *
       * ```javascript
       *  // Configure the store to filter in clients over the age of 30
       *  new Store({
       *      ...,
       *      filters : [{
       *          property : 'age',
       *          value    : 30,
       *          operator : '>'
       *      }],
       *      ...
       *  })
       * ```
       *
       * or:
       *
       * ```javascript
       *  // Configure the store to filter based on a complex operation
       *  new Store({
       *      ...,
       *      filters : [{
       *          filterBy(record) {
       *              // Return true or false for filtering in or out
       *              return shouldClientBeVisible(record);
       *          }
       *      }],
       *      ...
       *  })
       * ```
       *
       * @config {CollectionFilterConfig|CollectionFilterConfig[]}
       * @category Filtering
       */
      filters: null,
      /**
       * Specify true to reapply filters when a record is added to the store.
       * @config {Boolean}
       * @default
       * @category Filtering
       */
      reapplyFilterOnAdd: false,
      /**
       * Specify true to reapply filters when a record is updated in the store.
       * @config {Boolean}
       * @default
       * @category Filtering
       */
      reapplyFilterOnUpdate: false
    };
  }
  //endregion
  //region Events
  /**
   * Fired after applying filters to the store
   * @event filter
   * @param {Core.data.Store} source This Store
   * @param {Core.util.Collection} filters Filters used by this Store
   * @param {Core.data.Model[]} removed The records which were filtered out by the action.
   * @param {Core.data.Model[]} added The records which were filtered back in by the action.
   * @param {Core.data.Model[]} records Filtered records
   */
  //endregion
  //region Properties
  set reapplyFilterOnAdd(enable) {
    this.storage.autoFilter = enable;
  }
  get reapplyFilterOnAdd() {
    return this.storage.autoFilter;
  }
  /**
   * Currently applied filters. A collection of {@link Core.util.CollectionFilter} instances.
   * @type {Core.util.Collection}
   * @readonly
   * @category Sort, group & filter
   */
  set filters(filters) {
    const me = this,
      collection = me.filters;
    collection.clear();
    // Invalidate the filtersFunction so that it has to be recalculated upon next access
    me._filtersFunction = null;
    // If we are being asked to filter, parse the filters.
    if (filters) {
      if (filters.constructor.name === 'Object') {
        for (const f of Object.entries(filters)) {
          // Entry keys are either a field name with its value being the filter value
          // or, there may be one filterBy property which specifies a filtering function.
          if (f[0] === 'filterBy' && typeof f[1] === 'function') {
            collection.add(new CollectionFilter({
              filterBy: f[1]
            }));
          } else {
            collection.add(new CollectionFilter(f[1].constructor.name === 'Object' ? Object.assign({
              property: f[0]
            }, f[1]) : {
              property: f[0],
              value: f[1]
            }));
          }
        }
      } else if (Array.isArray(filters)) {
        // Make sure we are adding CollectionFilters
        collection.add(...filters.map(filterConfig => {
          if (filterConfig instanceof CollectionFilter) {
            return filterConfig;
          }
          return new CollectionFilter(filterConfig);
        }));
      } else if (filters.isCollection) {
        // Use supplied collection? Opting to use items from it currently
        collection.add(...filters.values);
      } else {
        collection.add(new CollectionFilter({
          filterBy: filters
        }));
      }
      collection.forEach(item => item.owner = me);
    }
  }
  get filters() {
    return this._filters || (this._filters = new Collection({
      extraKeys: ['property']
    }));
  }
  set filtersFunction(filtersFunction) {
    this._filtersFunction = filtersFunction;
  }
  get filtersFunction() {
    const me = this,
      {
        filters,
        isGrouped
      } = me;
    if (!me._filtersFunction) {
      if (filters.count) {
        const generatedFilterFunction = CollectionFilter.generateFiltersFunction(filters);
        me._filtersFunction = candidate => {
          // A group record is filtered in if it has passing groupChildren.
          if (isGrouped && candidate.isSpecialRow) {
            return candidate.groupChildren.some(generatedFilterFunction);
          }
          return generatedFilterFunction(candidate);
        };
      } else {
        me._filtersFunction = FunctionHelper.returnTrue;
      }
    }
    return me._filtersFunction;
  }
  /**
   * Check if store is filtered
   * @property {Boolean}
   * @readonly
   * @category Sort, group & filter
   */
  get isFiltered() {
    return this.filters.values.some(filter => !filter.disabled);
  }
  //endregion
  traverseFilter(record) {
    const me = this,
      hitsCurrent = !record.isRoot && me.filtersFunction(record),
      children = record.unfilteredChildren || record.children;
    // leaf, bail out
    if (!children || !children.length) {
      return hitsCurrent;
    }
    if (!record.unfilteredChildren) {
      record.unfilteredChildren = record.children.slice();
    }
    record.children = record.unfilteredChildren.filter(r => {
      return me.traverseFilter(r);
    });
    // unfilteredIndex must be set for child elements
    record.updateChildrenIndices(record.unfilteredChildren, 'unfilteredIndex', true);
    // parentIndex must be set for visible child elements
    record.updateChildrenIndices(record.children, 'parentIndex', true);
    return hitsCurrent || Boolean(record.children.length);
  }
  traverseClearFilter(record) {
    const me = this;
    if (record.unfilteredChildren) {
      // the code might seem a bit weird here, but yes - we want to copy from `orderedChildren`
      // and clear `unfilteredChildren`
      record.children = record.orderedChildren.slice();
      record.unfilteredChildren = null;
    }
    if (record.children) {
      record.children.forEach(r => me.traverseClearFilter(r));
      record.updateChildrenIndices(record.children, 'parentIndex', true);
    }
  }
  get latestFilterField() {
    return this.filters.last ? this.filters.last.property : null;
  }
  /**
   * Adds a single filter to the {@link #config-filters} collection. By default, filters are reevaluated
   * and a Store change event fired.
   *
   * If the `silent` parameter is passed as `true`, multiple filters can be added without causing data changes.
   *
   * When the filters are as required, call {@link #function-filter} with no parameters
   * to apply the filters to the store.
   *
   * @param {CollectionFilterConfig|Function} newFilter A {@link Core.util.CollectionFilter filter} config,
   * or a function to use for filtering.
   * @param {Boolean} [silent] Pass `true` to *not* refilter the store immediately. Such as when
   * adding multiple filters.
   * @returns {Core.util.CollectionFilter} The Filter instance that was added.
   * @returns {Promise|Core.util.CollectionFilter} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method
   * returns Collection filter inside a `Promise` which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  addFilter(filter, silent = false) {
    const me = this;
    filter = filter instanceof CollectionFilter ? filter : new CollectionFilter(filter);
    // We want notification upon change of field, value or operator
    filter.owner = me;
    // Collection will replace any already existing filter on the field, unless it has id specified
    me.filters.add(filter);
    if (!silent) {
      if (me.remoteFilter) {
        return me.filter().then(() => filter);
      } else {
        me.filter();
      }
    }
    return filter;
  }
  /**
   * Filters the store by **adding** the specified filter(s) to the existing filters collection applied to this Store.
   * If a filter has an {@link Core.util.CollectionFilter#config-id id} specified,
   * or a {@link Core.util.CollectionFilter#config-property property} specified,
   * it will search for corresponding filter(s) in the existing filters first and replace it with a new filter.
   * **It will not remove other filters applied to the store!**
   *
   * To **add** a new filter:
   * ```
   * // Filter using simple object
   * store.filter({
   *     property : 'age',
   *     operator : '>',
   *     value    : 90
   * });
   *
   * // Filter using function
   * store.filter(r => r.age < 90);
   *
   * // Filter using a named filter as a function
   * store.filter({
   *     id : 'my-filter',
   *     filterBy : record => record.score > 10
   * });
   * ```
   *
   * To **remove** a specific filter, but keep other filters applied
   * ```
   * // Remove by filter `id` or `property`. Filter `id` defaults to the `property` name.
   * store.removeFilter('age');
   * store.removeFilter('my-filter');
   * ```
   *
   * To **replace** all existing filters with a new filter
   * ```
   * // Remove all filters and filter using simple object
   * store.filter({
   *     filters : {
   *         property : 'age',
   *         operator : '<',
   *         value    : 90
   *     },
   *     replace : true
   * });
   *
   * // Remove all filters and filter using function
   * store.filter({
   *     filters : r => r.age > 90,
   *     replace : true
   * });
   *
   * // Remove all filters and filter using a named filter as a function
   * store.filter({
   *     filters : {
   *         id : 'my-filter',
   *         filterBy : record => record.score > 10
   *     },
   *     replace : true
   * });
   * ```
   *
   * Basically filters replacing is an equivalent of having two sequenced calls:
   * {@link #function-clearFilters clearFilters} and {@link #function-filter filter}.
   *
   * Call without arguments to reapply filters.
   * ```
   * // Re-filter the store
   * store.filter();
   * ```
   *
   * @param {Object|CollectionFilterConfig|CollectionFilterConfig[]|Function} newFilters
   *        A {@link Core.util.CollectionFilter filter} config,
   *        or an array of {@link Core.util.CollectionFilter filter} configs,
   *        or a function to use for filtering,
   *        or a special object like: ```{ replace : true, filters : newFilters }```
   * @param {Boolean} [newFilters.replace]
   *        A flag, indicating whether or not the previous filters should be removed.
   * @param {Boolean} [newFilters.silent]
   *        Set as true to not fire events. UI will not be informed about the changes.
   * @param {CollectionFilterConfig|CollectionFilterConfig[]|Function} [newFilters.filters]
   *        If `newFilters` is an object and `replace` property is defined in the `newFilters`,
   *        it means that special object is used and real filter configuration must be nested down to this `filters` property.
   *        It can be:
   *        A {@link Core.util.CollectionFilter filter} config,
   *        or an array of {@link Core.util.CollectionFilter filter} configs,
   *        or a function to use for filtering.
   * @fires filter
   * @fires change
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method returns Promise
   * which is resolved after data is loaded from remote server, otherwise it returns null value
   * @async
   * @category Sort, group & filter
   */
  filter(newFilters) {
    const me = this;
    let silent = false,
      internal;
    if (newFilters) {
      let fieldType = typeof newFilters;
      if (fieldType === 'object') {
        if ('silent' in newFilters || 'replace' in newFilters || newFilters.filters) {
          silent = newFilters.silent;
          if (newFilters.replace) {
            // If replacing with empty filters (i.e. clearing filters), clearFilters should trigger a re-filter
            me.clearFilters(newFilters.filters.length === 0);
          }
          internal = newFilters.internal;
          newFilters = newFilters.filters;
          fieldType = typeof newFilters;
        }
      }
      // If it was just a config object containing no filters, this will be null
      if (newFilters) {
        const wasFiltered = me.isFiltered;
        // We will not be informed about Filter mutations while configuring.
        me.isConfiguring = true;
        // If we provide array of objects looking like :
        //  {
        //      property  : 'fieldName',
        //      value     : 'someValue',
        //      [operator : '>']
        //  }
        //  or ...
        //  {
        //      property : 'fieldName',
        //      filterBy : function (value, record) {
        //          return value > 50;
        //      }
        //  }
        if (Array.isArray(newFilters)) {
          newFilters.forEach(f => me.addFilter(f, true), me);
        } else if (fieldType === 'function') {
          const filter = new CollectionFilter(newFilters);
          filter.internal = internal;
          me.addFilter(filter, true);
        }
        // Old signature of field name, value with implicit equality test.
        // Not documented, but still tested.
        else if (fieldType === 'string') {
          me.addFilter({
            property: newFilters,
            value: arguments[1]
          }, true);
        }
        // An object-based filter definition
        else {
          me.addFilter(newFilters, true);
        }
        // Open up to receiving Filter mutation notifications again
        me.isConfiguring = false;
        // We added a disabled filter to either no filters, or all disabled filters, so no change.
        if (!me.isFiltered && !wasFiltered) {
          return null;
        }
      }
    }
    // Invalidate the filtersFunction so that it has to be recalculated upon next access
    me.filtersFunction = null;
    // Implemented here for local filtering.
    // AjaxStore implements for remote and returns a Promise, so MUST return the call value.
    const result = me.performFilter(silent);
    // Force rebuild of idMap
    me._idMap = null;
    return result;
  }
  /**
   * Perform filtering according to the {@link #property-filters} Collection.
   * This is the internal implementation which is overridden in {@link Core.data.AjaxStore} and
   * must not be overridden.
   * @private
   */
  performFilter(silent) {
    const me = this,
      {
        storage,
        filters,
        rootNode
      } = me,
      oldCount = me.count;
    // Private event, did not need it documented or preventable right now
    me.trigger('beforeFilter', {
      filters
    });
    let added, removed;
    if (me.tree) {
      const oldDataset = storage.values;
      if (me.isFiltered) {
        me.traverseFilter(rootNode);
      } else {
        me.traverseClearFilter(rootNode);
      }
      const newDataset = me.collectDescendants(rootNode).visible;
      storage.replaceValues({
        values: newDataset,
        silent: true
      });
      const delta = ArrayHelper.delta(newDataset, oldDataset, true);
      added = delta.toAdd;
      removed = delta.toRemove;
    } else {
      // Collect the added and removed deltas from the filter operation
      storage.ion({
        change({
          removed: r,
          added: a
        }) {
          removed = r;
          added = a;
        },
        once: true
      });
      if (me.isFiltered) {
        // Bring collapsed away records in, to be considered in filtering
        me.isGrouped && me.includeCollapsed();
        storage.addFilter({
          id: 'primary-filter',
          filterBy: me.filtersFunction
        });
        // Take them back out again after filtering
        me.isGrouped && me.excludeCollapsed();
      } else {
        storage.filters.clear();
      }
    }
    me.afterPerformFilter(silent || me.isRemoteDataLoading ? null : {
      action: 'filter',
      filters,
      oldCount,
      added,
      removed,
      records: me.storage.values
    });
  }
  afterPerformFilter(event) {
    this.resetRelationCache();
    if (event) {
      this.triggerFilterEvent(event);
    }
  }
  // Used from filter() and StoreCRUD when reapplying filters
  triggerFilterEvent(event) {
    this.trigger('filter', event);
    // Only fire these events if it's a local filter.
    // If we are configured with filterParamName, the loadData will fire them.
    if (!this.remoteFilter) {
      this.trigger('refresh', event);
      this.trigger('change', event);
    }
  }
  /**
   * *Adds* a function used to filter the store. Alias for calling `filter(fn)`. Return `true` from the function to
   * include record in filtered set
   *
   * ```javascript
   * store.filterBy(record => record.age > 25 && record.name.startsWith('A'));
   * ```
   *
   * @param {Function} fn Function used to test records
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  filterBy(fn) {
    return this.filter(fn);
  }
  /**
   * Removes the passed filter, or the filter by the passed ID from the {@link #config-filters} collection.
   * By default, filters are reevaluated and a Store change event fired.
   *
   * If the `silent` parameter is passed as `true`, multiple filters can be removed without causing data changes.
   *
   * When the filters are as required, call {@link #function-filter} with no parameters
   * to apply the filters to the store.
   *
   * ```javascript
   * // Only view top priority events
   * myEventStore.filter({
   *     id       : 'priorityFilter',
   *     property : 'priority',
   *     value    : 1,
   *     operator : '='
   * });
   *
   * // That individual filter can be removed like this
   * myEventStore.removeFilter('priorityFilter');
   *
   * // Add named filter as a function
   * store.filter({
   *     id : 'my filter',
   *     filterBy : record => record.score > 10
   * });
   *
   * // Remove named filter function
   * store.removeFilter('my filter');
   * ```
   *
   * @param {String|Core.util.CollectionFilter} idOrInstance Filter to remove, or ID of the filter to remove. By default,
   * filters are reevaluated and a change event fired.
   * @param {Boolean} [silent] Pass `true` to *not* refilter the store immediately. Such as when
   * removing multiple filters.
   * @returns {Promise|Core.util.CollectionFilter} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method
   * returns Collection filter inside a `Promise` which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  removeFilter(idOrInstance, silent = false) {
    const me = this,
      filter = idOrInstance instanceof CollectionFilter ? idOrInstance : me.filters.get(idOrInstance);
    // If we have such a filter, remove it.
    if (filter) {
      me.filters.remove(filter);
      // Invalidate the filtersFunction so that it has to be recalculated upon next access
      me._filtersFunction = null;
      if (!silent) {
        if (me.remoteFilter) {
          return me.filter().then(() => filter);
        } else {
          me.filter();
        }
      }
      return filter;
    }
  }
  /**
   * Removes all filters from the store.
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  clearFilters(apply = true) {
    // Remove all non-internal filters (those have to be explicitly removed)
    this.filters.remove(this.filters.values.filter(f => !f.internal));
    if (apply) {
      return this.filter();
    }
  }
  convertFilterToString(field) {
    const filter = this.filters.getBy('property', field);
    return filter && !filter.filterBy ? String(filter) : '';
  }
  doDestroy() {
    var _this$_filters;
    (_this$_filters = this._filters) === null || _this$_filters === void 0 ? void 0 : _this$_filters.destroy();
    super.doDestroy();
  }
});

/**
 * @module Core/data/mixin/StoreGroup
 */
const resortActions = {
  add: 1,
  replace: 1
};
/**
 * An immutable object representing a store grouper.
 *
 * @typedef {Object} Grouper
 * @property {String} field Field name
 * @property {Boolean} [ascending=true] `true` to group ascending, `false` to group descending
 */
/**
 * Mixin for Store that handles grouping.
 *
 * ```javascript
 * // simple grouper
 * store.group('city');
 *
 * // grouper as object, descending order
 * store.group({ field : 'city', ascending : false });
 *
 * // using custom sorting function
 * store.group({
 *     field : 'city',
 *     fn : (recordA, recordB) => {
 *         // apply custom logic, for example:
 *         return recordA.city.length < recordB.city.length ? -1 : 1;
 *     }
 * });
 * ```
 *
 * Currently grouping is not supported when using pagination, the underlying store cannot group data that is split into pages.
 *
 * @mixin
 */
var StoreGroup = (Target => class StoreGroup extends (Target || Base) {
  static $name = 'StoreGroup';
  //region Config
  static configurable = {
    /**
     * Currently used groupers.
     * To set groupers when remote sorting is enabled by {@link Core/data/AjaxStore#config-sortParamName} you should
     * use {@link #function-setGroupers} instead to be able to wait for the operation to finish.
     * @member {Grouper[]} groupers
     * @category Sort, group & filter
     */
    /**
     * Initial groupers, specify to have store grouped automatically after initially setting data
     * @config {Grouper[]}
     * @category Common
     */
    groupers: null,
    useGroupFooters: false,
    /**
     * To have all groups __initially loaded__ start collapsed, configure this as `true`.
     *
     * Note that this only affects the initial load of the store. Subsequent reloads maintain
     * current group state where possible.
     * @config {Boolean}
     * @default false
     * @category Advanced
     */
    startGroupsCollapsed: null
  };
  static get properties() {
    return {
      collapsedGroups: new Set()
    };
  }
  //endregion
  //region Init
  construct(config) {
    super.construct(config);
    // For handling record mutation, *not* add/remove of records.
    // Sorts dataset if necessary.
    this.ion({
      change: 'onDataChanged',
      thisObj: this
    });
  }
  updateGroupers(groupers) {
    this.setGroupers(groupers);
  }
  /**
   * Set groupers.
   * @param {Grouper[]} groupers Array of groupers to apply to store
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns
   * `Promise` which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  setGroupers(groupers, options = null) {
    const me = this,
      {
        storage
      } = me;
    let result;
    if (groupers !== null && groupers !== void 0 && groupers.length) {
      me._groupers = groupers;
    } else if (me.groupers) {
      delete me._groupers;
      me.includeCollapsed();
      storage.replaceValues({
        values: me.removeHeadersAndFooters(storage._values),
        filteredValues: storage.isFiltered ? me.removeHeadersAndFooters(storage._filteredValues) : null,
        silent: true
      });
      result = me.group(null, null, null, false, options === null || options === void 0 ? void 0 : options.silent);
    }
    // Need to clear the id map so it gets rebuilt next time its accessed
    me._idMap = null;
    return result;
  }
  // Collects group headers/footers on the fly. Not used in any performance sensitive code, but if that need arises
  // it should be cached and invalidated on record remove, add, update, grouping changes, filter and sorting...
  get groupRecords() {
    const groupRecords = [];
    if (this.isGrouped) {
      for (const record of this) {
        if (record.isSpecialRow) {
          groupRecords.push(record);
        }
      }
    }
    return groupRecords;
  }
  get unfilteredGroupRecords() {
    const me = this;
    if (me.isGrouped) {
      var _me$_unfilteredGroupR;
      const {
        generation
      } = me.storage;
      if (((_me$_unfilteredGroupR = me._unfilteredGroupRecords) === null || _me$_unfilteredGroupR === void 0 ? void 0 : _me$_unfilteredGroupR.generation) !== generation) {
        me._unfilteredGroupRecords = me.storage.allValues.filter(r => r.isSpecialRow);
        me._unfilteredGroupRecords.generation = generation;
      }
    }
    return me._unfilteredGroupRecords || [];
  }
  /**
   * Returns group header record for the passed record or last group header in the store
   * @param {Core.data.Model} [targetRecord]
   * @param {Boolean} [ignoreFilter] Pass true to search in the complete collection
   * @returns {Core.data.Model}
   * @internal
   */
  getGroupHeaderForRecord(targetRecord, ignoreFilter = false) {
    if (this.isGrouped) {
      let result;
      const collection = ignoreFilter ? this.storage._values : this.storage.values;
      for (const record of collection) {
        if (record.isGroupHeader) {
          if (!targetRecord) {
            result = record;
          } else if (record === targetRecord || record.unfilteredGroupChildren.includes(targetRecord)) {
            result = record;
            break;
          }
        }
      }
      return result;
    }
  }
  // Temporarily include records from collapsed groups, for example prior to filtering
  includeCollapsed() {
    for (const groupId of this.collapsedGroups) {
      this.expand(this.getById(groupId), false);
    }
  }
  // Exclude records in collapsed groups, intended to be used after a call to includeCollapsed()
  excludeCollapsed() {
    for (const groupId of this.collapsedGroups) {
      this.collapse(this.getById(groupId));
    }
  }
  onDataChange({
    source: storage,
    action,
    removed
  }) {
    var _super$onDataChange;
    const me = this,
      {
        groupers
      } = me;
    // Only do grouping transformations if we have groupers to apply.
    // In stores which never use grouping, this code is superfluous and will reduce performance.
    // The else side will simply replace the ungrouped data with itself.
    if (groupers) {
      // When records are added or removed, re-evaluate the group records
      // so that when the events are fired by the super call, the group
      // records are in place.
      if (groupers.length) {
        if (action === 'splice' && removed !== null && removed !== void 0 && removed.length || action === 'move') {
          storage.replaceValues({
            ...me.prepareGroupRecords(),
            silent: true
          });
        }
      }
      // Remove all group headers and footers
      else {
        storage.replaceValues({
          values: me.removeHeadersAndFooters(storage._values),
          filteredValues: storage.isFiltered ? me.removeHeadersAndFooters(storage._filteredValues) : null,
          silent: true
        });
      }
    }
    (_super$onDataChange = super.onDataChange) === null || _super$onDataChange === void 0 ? void 0 : _super$onDataChange.call(this, ...arguments);
  }
  move(records, beforeRecord) {
    const me = this;
    if (me.isGrouped && !me.tree) {
      var _beforeRecord, _beforeRecord2;
      let prevRecord = beforeRecord;
      if ((_beforeRecord = beforeRecord) !== null && _beforeRecord !== void 0 && _beforeRecord.isSpecialRow) {
        prevRecord = me.getPrev(beforeRecord, false, false);
        if (!prevRecord) {
          // Trying to move above first group header, no-op
          return;
        }
      }
      // Target group header always exists
      const targetGroupHeader = me.getGroupHeaderForRecord(prevRecord),
        groupField = me.groupers[0].field,
        newGroupValue = targetGroupHeader.meta.groupRowFor,
        {
          reapplyFilterOnUpdate
        } = me;
      // Disable reapply filter on update because it will rebuild groups faster than we need. Groups will be
      // updated in super.move call anyway
      me.reapplyFilterOnUpdate = false;
      me.beginBatch();
      records.forEach(record => record.setValue(groupField, newGroupValue));
      me.endBatch();
      me.reapplyFilterOnUpdate = reapplyFilterOnUpdate;
      // If store is filtered, we might have hidden groups between target group header and `beforeRecord`. To
      // make move safe we need to find new target group (visible) and find next group in the unfiltered
      // collection. But only if `beforeRecord is a group header
      if (me.isFiltered && (_beforeRecord2 = beforeRecord) !== null && _beforeRecord2 !== void 0 && _beforeRecord2.isSpecialRow) {
        const {
            unfilteredGroupRecords
          } = me,
          // Find index of the group header we're moving record into
          index = unfilteredGroupRecords.indexOf(targetGroupHeader);
        // If `beforeRecord` exists, index cannot point to the last group in the store, meaning we can
        // safely access element at index + 1
        beforeRecord = unfilteredGroupRecords[index + 1];
      }
    }
    super.move(records, beforeRecord);
  }
  // private function that collapses on the data level
  collapse(groupRecord) {
    if (groupRecord && !groupRecord.meta.collapsed) {
      this.excludeGroupRecords(groupRecord);
      groupRecord.meta.collapsed = true;
      // Track which groups are collapsed
      this.collapsedGroups.add(groupRecord.id);
      this.trigger('toggleGroup', {
        groupRecord,
        collapse: true
      });
      return true;
    }
    return false;
  }
  // private function that expands on the data level
  expand(groupRecord, updateMap = true) {
    if (groupRecord !== null && groupRecord !== void 0 && groupRecord.meta.collapsed) {
      this.includeGroupRecords(groupRecord);
      groupRecord.meta.collapsed = false;
      // Optionally track which groups are collapsed (not done when expanding temporarily prior to filtering etc)
      updateMap && this.collapsedGroups.delete(groupRecord.id);
      updateMap && this.trigger('toggleGroup', {
        groupRecord,
        collapse: false
      });
      return true;
    }
    return false;
  }
  removeHeadersAndFooters(records) {
    return records.filter(r => {
      if (r.isSpecialRow) {
        this.unregister(r);
        return false;
      } else {
        return true;
      }
    });
  }
  prepareGroupRecords(sorter) {
    const me = this,
      {
        isFiltered,
        reapplyFilterOnUpdate,
        startGroupsCollapsed
      } = me,
      toCollapse = me.collapsedGroups,
      {
        allValues
      } = me.storage,
      toExpand = [],
      // this property is set by StoreChanges mixin to keep in view records which were visible prior to
      // `applyChangeset` call but after update no longer match the filter
      visibleRecordsIds = me._groupVisibleRecordIds || [],
      isVisible = record => {
        const matchesFilter = !isFiltered || me.filtersFunction(record);
        return reapplyFilterOnUpdate ? matchesFilter : matchesFilter || visibleRecordsIds.includes(record.id);
      };
    for (const record of allValues) {
      if (record.isGroupHeader && (record.meta.collapsed || toCollapse.has(record.id))) {
        toCollapse.add(record.id);
        toExpand.push(record);
      }
    }
    for (const record of toExpand) {
      me.includeGroupRecords(record);
    }
    const records = me.removeHeadersAndFooters(me.storage._values);
    if (sorter) {
      records.sort(sorter);
    }
    // Update filters function
    if (isFiltered) {
      me.filtersFunction = null;
    }
    const groupedRecords = [],
      field = me.groupers[0].field;
    let curGroup = null,
      curGroupRecord = null,
      childCount = 0;
    function addFooter() {
      const val = curGroupRecord.meta.groupRowFor,
        id = `group-footer-${typeof val === 'number' ? val : StringHelper.createId(val)}`,
        footer = me.getById(id) || new me.modelClass({
          id
        }, me, {
          specialRow: true,
          groupFooterFor: val,
          groupRecord: curGroupRecord
        });
      // Used by indexOf to determine if part of store
      footer.stores = [me];
      me.register(footer);
      footer.groupChildren = curGroupRecord.groupChildren;
      if (!curGroupRecord.meta.collapsed) {
        groupedRecords.push(footer);
      }
      me.allRecords.push(footer);
      curGroupRecord.groupChildren.push(footer);
      curGroupRecord.unfilteredGroupChildren.push(footer);
      childCount++;
      return footer;
    }
    records.forEach(record => {
      var _record$unfilteredGro;
      const fieldValue = record.getValue(field),
        val = fieldValue == undefined ? '__novalue__' : fieldValue,
        id = `group-header-${typeof val === 'number' ? val : StringHelper.createId(val)}`;
      // A group header or footer record of an empty group.
      // Remove from the data
      if (((_record$unfilteredGro = record.unfilteredGroupChildren) === null || _record$unfilteredGro === void 0 ? void 0 : _record$unfilteredGro.length) === 0) {
        me.unregister(record);
        return;
      }
      if (!ObjectHelper.isEqual(val, curGroup)) {
        if (curGroupRecord) {
          // also add group footer? used by GroupSummary feature
          if (me.useGroupFooters) {
            addFooter();
          }
          curGroupRecord.meta.childCount = childCount;
        }
        curGroupRecord = me.getById(id);
        if (!curGroupRecord) {
          curGroupRecord = new me.modelClass({
            id
          }, me, {
            specialRow: true,
            groupRowFor: val,
            groupField: field
          });
          // New groups start life collapsed
          if (startGroupsCollapsed) {
            toCollapse.add(id);
            // It only works the first time groups are created.
            me.startGroupsCollapsed = false;
          }
        }
        curGroupRecord.meta.collapsed = toCollapse.has(id);
        // Used by indexOf to determine if part of store
        curGroupRecord.stores = [me];
        me.register(curGroupRecord);
        curGroupRecord.groupChildren = [];
        curGroupRecord.unfilteredGroupChildren = [];
        groupedRecords.push(curGroupRecord);
        me.allRecords.push(curGroupRecord);
        curGroup = val;
        childCount = 0;
      }
      record.instanceMeta(me.id).groupParent = curGroupRecord;
      // Collapse groups that was collapsed earlier
      if (!toCollapse.has(id)) {
        groupedRecords.push(record);
      }
      if (isVisible(record)) {
        curGroupRecord.groupChildren.push(record);
        childCount++;
      }
      curGroupRecord.unfilteredGroupChildren.push(record);
    });
    // misses for last group without this
    if (curGroupRecord) {
      // footer for last group
      if (me.useGroupFooters) {
        addFooter();
      }
      curGroupRecord.meta.childCount = childCount;
    }
    me._idMap = null;
    const result = {
      values: groupedRecords
    };
    if (isFiltered) {
      result.filteredValues = groupedRecords.filter(isVisible);
    }
    return result;
  }
  //endregion
  //region Group and ungroup
  /**
   * Is store currently grouped?
   * @property {Boolean}
   * @readonly
   * @category Sort, group & filter
   */
  get isGrouped() {
    var _this$groupers;
    return Boolean((_this$groupers = this.groupers) === null || _this$groupers === void 0 ? void 0 : _this$groupers.length);
  }
  /**
   * Group records, either by replacing current sorters or by adding to them.
   * A grouper can specify a **_custom sorting function_** which will be called with arguments (recordA, recordB).
   * Works in the same way as a standard array sorter, except that returning `null` triggers the stores
   * normal sorting routine. Grouped store **must** always be sorted by the same field.
   *
   * ```javascript
   * // simple grouper
   * store.group('city');
   *
   * // grouper as object, descending order
   * store.group({ field : 'city', ascending : false });
   *
   * // using custom sorting function
   * store.group({
   *     field : 'city',
   *     fn : (recordA, recordB) => {
   *         // apply custom logic, for example:
   *         return recordA.city.length < recordB.city.length ? -1 : 1;
   *     }
   * });
   * ```
   *
   * @param {String|Object} field Field to group by.
   * Can also be a config containing a field to group by and a custom sorting function called `fn`.
   * @param {Boolean} [ascending] Sort order of the group titles
   * @param {Boolean} [add] Add a grouper (true) or use only this grouper (false)
   * @param {Boolean} [performSort] Trigger sort directly, which does the actual grouping
   * @param {Boolean} [silent] Set as true to not fire events
   * @category Sort, group & filter
   * @fires group
   * @fires refresh
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   */
  group(field, ascending, add = false, performSort = true, silent = false) {
    const me = this;
    let newGrouper, fn;
    if (field && typeof field === 'object') {
      ascending = field.ascending;
      fn = field.fn;
      field = field.field;
    }
    if (add) {
      me.groupers.push(newGrouper = {
        field,
        ascending,
        complexMapping: field.includes('.')
      });
    } else if (field) {
      if (ascending == null) {
        var _me$groupInfo, _me$groupInfo2;
        ascending = ((_me$groupInfo = me.groupInfo) === null || _me$groupInfo === void 0 ? void 0 : _me$groupInfo.field) === field && ((_me$groupInfo2 = me.groupInfo) === null || _me$groupInfo2 === void 0 ? void 0 : _me$groupInfo2.fn) === fn ? !me.groupInfo.ascending : true;
      }
      me.groupInfo = newGrouper = {
        field,
        ascending,
        fn,
        complexMapping: field.includes('.')
      };
      me.groupers = [me.groupInfo];
    }
    if (newGrouper) {
      const {
        prototype
      } = me.modelClass;
      // Create a getter for complex field names like "get resource.city"
      if (newGrouper.complexMapping && !Object.prototype.hasOwnProperty.call(prototype, field)) {
        Object.defineProperty(prototype, field, {
          get() {
            return ObjectHelper.getPath(this, field);
          }
        });
      }
    }
    // as far as the store is concerned, grouping is just more sorting. so trigger sort
    if (performSort !== false) {
      if (me.remoteSort && !me.isRemoteDataLoading) {
        return me.sort(null, null, false, true).then(() => me.onAfterGrouping(silent));
      } else {
        me.sort(null, null, false, true);
      }
    }
    me.onAfterGrouping(silent);
  }
  onAfterGrouping(silent) {
    if (silent) {
      return;
    }
    const me = this,
      groupers = me.groupers || [];
    /**
     * Fired when grouping changes
     * @event group
     * @param {Core.data.Store} source This Store
     * @param {Grouper[]} groupers Applied groupers
     * @param {Core.data.Model[]} records Grouped records
     */
    me.trigger('group', {
      isGrouped: me.isGrouped,
      groupers,
      records: me.storage.values
    });
    me.trigger('refresh', {
      action: 'group',
      isGrouped: me.isGrouped,
      groupers,
      records: me.storage.values
    });
  }
  // Internal since UI does not support multi grouping yet
  /**
   * Add a grouping level (a grouper).
   * @param {String} field Field to group by
   * @param {Boolean} ascending Group direction
   * @category Sort, group & filter
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @internal
   */
  addGrouper(field, ascending = true) {
    return this.group(field, ascending, true);
  }
  // Internal since UI does not support multi grouping yet
  /**
   * Removes a grouping level (a grouper)
   * @param {String} field Grouper to remove
   * @category Sort, group & filter
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @internal
   */
  removeGrouper(field) {
    const me = this,
      {
        groupers
      } = me;
    if (!groupers) {
      return;
    }
    const index = groupers.findIndex(grouper => grouper.field === field);
    if (index > -1) {
      groupers.splice(index, 1);
      if (!groupers.length) {
        return me.clearGroupers();
      } else {
        return me.group();
      }
    }
  }
  /**
   * Removes all groupers, turning store grouping off.
   * @privateparam {Boolean} [silent=false] Pass true to suppress events.
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  clearGroupers(silent = false) {
    return this.setGroupers(null, {
      silent
    });
  }
  //endregion
  //region Get and check
  /**
   * Check if a record belongs to a certain group (only for the first grouping level)
   * @param {Core.data.Model} record The Record
   * @param {*} groupValue The group value
   * @returns {Boolean} True if the record belongs to the group, otherwise false
   * @category Sort, group & filter
   */
  isRecordInGroup(record, groupValue) {
    var _this$groupers$;
    if (!this.isGrouped) {
      return null;
    }
    const groupField = (_this$groupers$ = this.groupers[0]) === null || _this$groupers$ === void 0 ? void 0 : _this$groupers$.field;
    return record.getValue(groupField) === groupValue && !record.isSpecialRow;
  }
  isInCollapsedGroup(record) {
    const parentGroupRec = record.instanceMeta(this).groupParent;
    return parentGroupRec === null || parentGroupRec === void 0 ? void 0 : parentGroupRec.meta.collapsed;
  }
  /**
   * Returns all records in the group with specified groupValue.
   * @param {*} groupValue
   * @returns {Core.data.Model[]} Records in specified group or null if store not grouped
   * @category Sort, group & filter
   */
  getGroupRecords(groupValue) {
    if (!this.isGrouped) {
      return null;
    }
    return this.storage.values.filter(record => this.isRecordInGroup(record, groupValue));
  }
  /**
   * Get all group titles.
   * @returns {String[]} Group titles
   * @category Sort, group & filter
   */
  getGroupTitles() {
    if (!this.isGrouped) {
      return null;
    }
    return this.getDistinctValues(this.groupers[0].field);
  }
  //endregion
  onDataChanged({
    changes,
    action
  }) {
    if (this.isGrouped && (
    // If an action flagged as requiring resort is performed...
    !changes && resortActions[action] ||
    // ...or if the group field has changes...
    changes && this.groupers.some(grouper => grouper.field in changes))) {
      // ...then re-sort
      this.sort();
    }
  }
  /**
   * Adds or removes records in a group from storage. Used when expanding/collapsing groups.
   * @private
   * @param {Core.data.Model} groupRecord Group which records should be added or removed
   * @param {Boolean} include Include (true) or exclude (false) records
   * @category Grouping
   */
  internalIncludeExcludeGroupRecords(groupRecord, include) {
    const me = this,
      index = me.indexOf(groupRecord),
      allIndex = me.allIndexOf(groupRecord),
      {
        id: mapId,
        storage
      } = me,
      {
        _filteredValues,
        _values
      } = storage,
      {
        meta,
        groupChildren,
        unfilteredGroupChildren
      } = groupRecord;
    // Skip if group record is not found, otherwise it removes records from wrong position.
    // Also prevent removing from already collapsed and vice versa
    if (allIndex === -1 || meta.collapsed && !include || !meta.collapsed && include) {
      return;
    }
    unfilteredGroupChildren.forEach(child => child.instanceMeta(mapId).hiddenByCollapse = !include);
    if (include) {
      // Avoid adding record duplicates which may already have been reinserted by clearing filters
      if (_filteredValues) {
        _filteredValues.splice(index + 1, 0, ...groupChildren.filter(r => !me.isAvailable(r)));
      }
      storage._values.splice(allIndex + 1, 0, ...unfilteredGroupChildren.filter(r => !me.isAvailable(r)));
    } else {
      if (_filteredValues) {
        _filteredValues.splice(index + 1, groupChildren.length);
      }
      _values.splice(allIndex + 1, unfilteredGroupChildren.length);
    }
    storage._indicesInvalid = true;
    me._idMap = null;
  }
  /**
   * Removes records in a group from storage. Used when collapsing a group.
   * @private
   * @param groupRecord Group which records should be removed
   * @category Grouping
   */
  excludeGroupRecords(groupRecord) {
    this.internalIncludeExcludeGroupRecords(groupRecord, false);
  }
  /**
   * Adds records in a group to storage. Used when expanding a group.
   * @private
   * @param groupRecord Group which records should be added
   * @category Grouping
   */
  includeGroupRecords(groupRecord) {
    this.internalIncludeExcludeGroupRecords(groupRecord, true);
  }
  /**
   * Collects all group headers + children, whether expanded or not
   * @private
   * @param {Boolean} allRecords True to include filtered out records
   * @param {Boolean} includeHeaders True to also include group headers
   * @returns {Core.data.Model[]}
   */
  collectGroupRecords(allRecords, includeHeaders = true) {
    const records = allRecords ? this.storage.allValues : this.storage.values;
    return records.reduce((records, record) => {
      if (record.isSpecialRow) {
        if (includeHeaders && !record.isGroupFooter) {
          records.push(record);
        }
        if (record.isGroupHeader) {
          records.push.apply(records, record.groupChildren);
        }
      }
      return records;
    }, []);
  }
});

/**
 * @module Core/data/mixin/StoreProxy
 */
/**
 * Object-like interaction with a Store by using a Proxy. To enable, configure the store with `objectify : true`.
 *
 * ```javascript
 * const store = new Store({
 *    objectify : true,
 *    data      : [
 *        { id : 'batman', name : 'Bruce' }
 *    ]
 * });
 * ```
 *
 * Access records using their ids as Store properties:
 * ```javascript
 * console.log(store.batman.name); // logs Bruce
 * ```
 *
 * Add records by assigning properties to the Store:
 * ```javascript
 * store.superman = { name : 'Clark' }; // Id will be 'superman'
 * ```
 *
 * Remove records by removing their property:
 * ```javascript
 * delete store.batman;
 * ```
 *
 * Check if a certain id existing in the store by using `in`:
 * ```javascript
 * console.log('superman' in store): // logs true
 * ```
 *
 * Please note that this approach:
 * * Will affect performance slightly, not recommended for larger datasets.
 * * Uses native Proxy.
 * * Preserves predefined Store properties, records cannot use ids that match those.
 * * Might have other limitations preventing the use of it in some scenarios where a normal Store can be used.
 *
 * @mixin
 */
var StoreProxy = (Target => class StoreProxy extends (Target || Base) {
  static get configurable() {
    return {
      /**
       * Allow object like interaction with the Store. For example:
       *
       * ```javascript
       * const store = new Store({
       *    objectify : true,
       *    data      : [
       *        { id : 'batman', name : 'Bruce' }
       *    ]
       * });
       *
       * // retrieve using id as property
       * const record = store.batman;
       *
       * // add as property
       * store.superman = { name : 'Clark' };
       *
       * // delete to remove
       * delete store.batman;
       * ``
       *
       * @config {Boolean}
       * @default false
       */
      objectify: null
    };
  }
  initProxy() {
    if (!globalThis.Proxy) {
      throw new Error('Proxy not supported');
    }
    const proxy = new Proxy(this, {
      // Support getting records using `store[id/index]
      get(target, property) {
        // Stores own properties take precedence
        if (property in target) {
          return target[property];
        }
        // To allow accessing the underlying store
        if (property === '$store') {
          return target;
        }
        // Then ids
        let record = target.getById(property);
        // And finally index
        if (!record && !isNaN(parseInt(property))) {
          record = target.getAt(parseInt(property));
        }
        return record;
      },
      // Support adding/replacing records using `store.id = { ...data }`
      set(target, property, value) {
        // Pass through when using names of existing properties or when destroyed/ing
        if (property in target || target.isDestroying) {
          target[property] = value;
        }
        // Otherwise add/replace a record
        else {
          target.add({
            [target.modelClass.idField]: property,
            ...value
          });
        }
        return true;
      },
      // Support deleting records using `delete store.id`
      deleteProperty(target, property) {
        // Properties are deleted on destroy
        if (target.isDestroying) {
          delete target[property];
          return true;
        }
        return Boolean(target.remove(property).length);
      },
      // Support `id in store`
      has(target, property) {
        // Actual property
        if (property in target) {
          return true;
        }
        // Threat { ... } as JSON representation of a record (likely from toString())
        if (property.startsWith('{') && property.endsWith('}')) {
          const data = StringHelper.safeJsonParse(property);
          property = data === null || data === void 0 ? void 0 : data.id;
        }
        return target.includes(property);
      }
    });
    return proxy;
  }
});

/**
 * @module Core/data/mixin/StoreRelation
 */
/**
 * Mixin for Store that handles relations with other stores.
 *
 * The relation is defined in a Model subclass, see Model's {@link Core/data/Model#property-relations-static} property
 * for more information.
 *
 * @mixin
 */
var StoreRelation = (Target => class StoreRelation extends (Target || Base) {
  static $name = 'StoreRelation';
  //region Init
  /**
   * Initialized relations, called from constructor
   * @private
   */
  initRelations(reset) {
    const me = this,
      relations = me.modelClass.exposedRelations;
    if (reset && me.modelRelations) {
      // reset will reinit all relations, stop listening for store events on existing ones
      me.modelRelations.forEach(relation => {
        var _relation$storeDetach;
        return (_relation$storeDetach = relation.storeDetacher) === null || _relation$storeDetach === void 0 ? void 0 : _relation$storeDetach.call(relation);
      });
    }
    if ((!me.modelRelations || me.modelRelations.length === 0 || reset) && relations) {
      me.modelRelations = [];
      // foreignKeys is filled when model exposes its properties
      relations === null || relations === void 0 ? void 0 : relations.forEach(modelRelationConfig => {
        const config = {
            ...modelRelationConfig
          },
          {
            foreignStore,
            relationName,
            relatedCollectionName
          } = config,
          relatedStore = typeof foreignStore === 'string' ? me[foreignStore] : foreignStore;
        config.dependentStore = me;
        me.modelRelations.push(config);
        if (relatedStore) {
          config.foreignStoreProperty = config.foreignStore;
          config.foreignStore = relatedStore; // repeated from initRelationStores, needed if stored is assigned late
          const dependentStoreConfigs = relatedStore.dependentStoreConfigs;
          // Add link to dependent store
          if (dependentStoreConfigs.has(me)) {
            const dependentConfigs = dependentStoreConfigs.get(me);
            // Remove existing config on reset
            if (reset) {
              const existingConfig = dependentConfigs.find(c => c.relationName === relationName);
              if (existingConfig) {
                ArrayHelper.remove(dependentConfigs, existingConfig);
              }
            }
            dependentConfigs.push(config);
          } else {
            dependentStoreConfigs.set(me, [config]);
          }
          // if foreign key specifies relatedCollectionName the related store should also be configured
          if (relatedCollectionName) {
            relatedStore.initRelationCollection(config, me);
          }
          if (relatedStore.count > 0) {
            relatedStore.updateDependentStores('dataset', relatedStore.records);
          }
        }
      });
    }
  }
  /**
   * Called from other end of an relation when this store should hold a collection of related records.
   * @private
   * @param config
   * @param collectionStore
   */
  initRelationCollection(config, collectionStore) {
    const me = this,
      name = config.relatedCollectionName,
      collectionStores = me.collectionStores || (me.collectionStores = {});
    collectionStores[name] = {
      store: collectionStore,
      config
    };
    if (!me[name + 'Store']) {
      me[name + 'Store'] = collectionStore;
    }
    if (me.count > 0) {
      me.initModelRelationCollection(name, me.records);
    }
  }
  initModelRelationCollection(name, records) {
    const me = this;
    // add collection getter to each model
    records.forEach(record => {
      // Needs to work in trees also, if not a tree traverse just calls fn on self
      record.traverse(node => {
        // Add/replace $relatedAssignments (or similar) if assignments already exists on target
        const useName = name in node ? `$related${StringHelper.capitalize(name)}` : name;
        Object.defineProperty(node, useName, {
          enumerable: true,
          configurable: true,
          get: function () {
            return me.getCollection(this, name);
          },
          set: function (value) {
            return me.setCollection(this, name, value);
          }
        });
      });
    });
  }
  /**
   * Updates relationCache for all records.
   * @private
   */
  resetRelationCache() {
    this.relationCache = {};
    this.forEach(record => record.initRelations());
  }
  /**
   * Caches related records from related store on the local store.
   * @private
   * @param record Local record
   * @param relations Relations to related store
   */
  updateRecordRelationCache(record, relations) {
    relations === null || relations === void 0 ? void 0 : relations.forEach(relation => {
      const {
          config
        } = relation,
        // use related records id, or if called before "binding" is complete use foreign key
        foreignId = relation.related ? relation.related.id : record.getValue(config.foreignKey);
      // cache on that id, removing previously cached value if any
      foreignId !== undefined && this.cacheRelatedRecord(record, foreignId, config.relationName, foreignId);
    });
  }
  //endregion
  //region Getters
  /**
   * Returns records the relation cache. Same result as if retrieving the collection on the dependent store, but
   * without the need of accessing that store.
   * @internal
   * @param {String} name
   * @param {Core.data.Model|String|Number} recordOrId
   * @returns {Array}
   */
  getRelationCollection(name, recordOrId) {
    var _this$relationCache$n;
    const id = Model.asId(recordOrId);
    return ((_this$relationCache$n = this.relationCache[name]) === null || _this$relationCache$n === void 0 ? void 0 : _this$relationCache$n[id]) || [];
  }
  /**
   * Returns records from a collection of related records. Not to be called directly, called from Model getter.
   * @private
   * @param {Core.data.Model} record
   * @param {String} name
   * @returns {Array}
   */
  getCollection(record, name) {
    var _store$relationCache$;
    const {
      config,
      store
    } = this.collectionStores[name];
    return ((_store$relationCache$ = store.relationCache[config.relationName]) === null || _store$relationCache$ === void 0 ? void 0 : _store$relationCache$[record.id]) || [];
  }
  /**
   * Sets a collection of related records. Will updated the related store and trigger events from it. Not to be called
   * directly, called from Model setter.
   * @private
   */
  setCollection(model, name, records) {
    const {
        config,
        store
      } = this.collectionStores[name],
      relationCache = store.relationCache[config.relationName] || (store.relationCache[config.relationName] = {}),
      old = (relationCache[model.id] || []).slice(),
      added = [],
      removed = [];
    store.suspendEvents();
    // Remove any related records not in the new collection
    old.forEach(record => {
      if (!records.includes(record)) {
        record[config.foreignKey] = null;
        store.remove(record);
        removed.push(record);
      }
    });
    // Add records from the new collection not already in store
    records.forEach(record => {
      if (record.isModel instanceof Model) {
        if (!record.stores.includes(store)) {
          store.add(record);
          added.push(record);
        }
      } else {
        [record] = store.add(record);
        added.push(record);
      }
      // Init relation
      record[config.foreignKey] = model.id;
    });
    store.resumeEvents();
    if (removed.length) {
      store.trigger('remove', {
        records: removed
      });
      store.trigger('change', {
        action: 'remove',
        records: removed
      });
    }
    if (added.length) {
      store.trigger('add', {
        records: added
      });
      store.trigger('change', {
        action: 'add',
        records: added
      });
    }
  }
  //endregion
  //region Caching
  /**
   * Adds a record to relation cache, optionally removing it if already there.
   * @private
   * @param record
   * @param id
   * @param name
   * @param uncacheId
   */
  cacheRelatedRecord(record, id, name, uncacheId = null) {
    const me = this,
      cache = me.relationCache[name] || (me.relationCache[name] = {});
    if (uncacheId !== null) {
      me.uncacheRelatedRecord(record, name, uncacheId);
    }
    if (id != null) {
      // Only include of not already in relation cache, which might happen when removing and re-adding the same instance
      ArrayHelper.include(cache[id] || (cache[id] = []), record);
    }
  }
  /**
   * Removes a record from relation cache, for a specific relation (specify relation name and id) or for all relations
   * @private
   * @param record Record to remove from cache
   * @param name Optional, relation name
   * @param id Optional, id
   */
  uncacheRelatedRecord(record, name = null, id = null) {
    const me = this;
    function remove(relationName, relatedId) {
      const cache = me.relationCache[relationName],
        oldCache = cache === null || cache === void 0 ? void 0 : cache[relatedId];
      // When unjoining a record from a filtered store the relationCache will also be filtered
      // and might give us nothing, in which case we have nothing to clean up and bail out
      if (oldCache) {
        const uncacheIndex = oldCache.indexOf(record);
        uncacheIndex >= 0 && oldCache.splice(uncacheIndex, 1);
        if (oldCache.length === 0) {
          delete cache[relatedId];
        }
      }
    }
    if (id != null) {
      remove(name, id);
    } else {
      if (record.meta.relationCache) {
        Object.entries(record.meta.relationCache).forEach(([relationName, relatedRecord]) => remove(relationName, relatedRecord === null || relatedRecord === void 0 ? void 0 : relatedRecord.id));
      }
    }
  }
  /**
   * Updates related stores when store is cleared, a record is removed or added.
   * @private
   * @param {String} action
   * @param {Core.data.Model[]} records
   */
  updateDependentStores(action, records) {
    this.dependentStoreConfigs.forEach(configs => {
      configs.forEach(config => {
        const {
            dependentStore,
            relatedCollectionName,
            relationName,
            foreignKey
          } = config,
          cache = dependentStore.relationCache[relationName];
        if (action === 'dataset') {
          relatedCollectionName && this.initModelRelationCollection(relatedCollectionName, records);
          dependentStore.forEach(record => {
            const foreign = record.initRelation(config);
            foreign && dependentStore.cacheRelatedRecord(record, foreign.id, relationName, foreign.id);
          });
          return;
        }
        if (action === 'removeall') {
          dependentStore.forEach(record => record.removeRelation(config));
          delete dependentStore.relationCache[relationName];
          return;
        }
        if (action === 'add') {
          relatedCollectionName && this.initModelRelationCollection(relatedCollectionName, records);
        }
        if (action === 'add' || action === 'remove') {
          records.forEach(record => {
            const dependentRecords = cache === null || cache === void 0 ? void 0 : cache[record.id];
            switch (action) {
              case 'remove':
                // removing related record removes from cache on model and store
                if (dependentRecords) {
                  dependentRecords.forEach(dependentRecord => dependentRecord.removeRelation(config));
                  // Altered to not delete on self, simplifies taking actions on related records after remove if relation still lives
                  //delete cache[relatedRecord.id];
                }

                break;
              case 'add':
                // adding a new record in related store checks if any foreign keys match the new id,
                // and if so it sets up the relation
                dependentStore.forEach(dependentRecord => {
                  if (dependentRecord.getValue(foreignKey) == record.id) {
                    dependentRecord.initRelation(config);
                    dependentStore.cacheRelatedRecord(dependentRecord, record.id, relationName);
                  }
                });
                break;
            }
          });
        }
      });
    });
  }
  /**
   * Updates relation cache and foreign key value when a related objects id is changed.
   * @private
   */
  updateDependentRecordIds(oldValue, value) {
    var _this$dependentStoreC;
    (_this$dependentStoreC = this.dependentStoreConfigs) === null || _this$dependentStoreC === void 0 ? void 0 : _this$dependentStoreC.forEach(configs => {
      configs.forEach(config => {
        var _cache$oldValue;
        const {
            dependentStore,
            relationName,
            foreignKey
          } = config,
          cache = dependentStore.relationCache[relationName],
          localRecords = cache === null || cache === void 0 ? void 0 : (_cache$oldValue = cache[oldValue]) === null || _cache$oldValue === void 0 ? void 0 : _cache$oldValue.slice();
        localRecords === null || localRecords === void 0 ? void 0 : localRecords.forEach(localRecord => {
          // First update cache
          dependentStore.cacheRelatedRecord(localRecord, value, relationName, oldValue);
          // Then update & announce, otherwise relations won't be up-to-date in listeners
          localRecord.set(foreignKey, value, false, true);
        });
      });
    });
  }
  //endregion
});

/**
 * @module Core/data/mixin/StoreSum
 */
/**
 * Mixin for Store that handles summaries.
 *
 * @mixin
 */
var StoreSum = (Target => class StoreSum extends (Target || Base) {
  static get $name() {
    return 'StoreSum';
  }
  /**
   * Returns sum calculated by adding value of specified field for specified records. Defaults to using all records
   * in store
   * @param {String} field Field to summarize by
   * @param {Core.data.Model[]} records Records to summarize, uses all records if unspecified.
   * @returns {Number}
   * @category Sum
   */
  sum(field, records = this.storage.values) {
    if (!records) {
      return 0;
    }
    return records.reduce((sum, record) => {
      if (record.isSpecialRow) {
        return sum;
      }
      const v = Number(record.getValue(field));
      return isNaN(v) ? sum : sum + v;
    }, 0);
  }
  /**
   * Returns min value for the specified field, can be used with Date or Number values. Defaults to look through all records in store
   * @param {String} field Field to find min value for
   * @param {Core.data.Model[]} records Records to process, uses all records if unspecified
   * @returns {Number|Date}
   * @category Sum
   */
  min(field, records = this.storage.values) {
    if (!(records !== null && records !== void 0 && records.length)) {
      return 0;
    }
    return records.reduce((min, record) => {
      const fieldValue = record.getValue(field),
        type = typeof (fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.valueOf());
      if (type === 'number' && fieldValue < min) {
        min = fieldValue;
      }
      return min;
    }, records[0].getValue(field));
  }
  /**
   * Returns max value for the specified field, can be used with Date or Number values. Defaults to look through all records in store
   * @param {String} field Field to find max value for
   * @param {Core.data.Model[]} records Records to process, uses all records if unspecified
   * @returns {Number|Date}
   * @category Sum
   */
  max(field, records = this.storage.values) {
    if (!(records !== null && records !== void 0 && records.length)) {
      return 0;
    }
    return records.reduce((max, record) => {
      const fieldValue = record.getValue(field),
        type = typeof (fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.valueOf());
      if (type === 'number' && fieldValue > max) {
        max = fieldValue;
      }
      return max;
    }, records[0].getValue(field));
  }
  /**
   * Returns the average value for the specified field. Defaults to look through all records in store
   * @param {String} field Field to calculate average value for
   * @param {Core.data.Model[]} records Records to process, uses all records if unspecified
   * @returns {Number}
   * @category Sum
   */
  average(field, records = this.storage.values) {
    if (!(records !== null && records !== void 0 && records.length)) {
      return 0;
    }
    let count = 0;
    const sum = records.reduce((sum, record) => {
      if (record.isSpecialRow) {
        return sum;
      }
      const v = parseFloat(record.getValue(field));
      if (!isNaN(v)) {
        count++;
        return sum + v;
      } else {
        return sum;
      }
    }, 0);
    return count > 0 ? sum / count : 0;
  }
  /**
   * Returns sum by adding value of specified field for records in the group with the specified groupValue.
   * @param {*} groupValue The group to summarize
   * @param {String} field Field to summarize by
   * @returns {Number} Sum or null if store not grouped
   * @category Sum
   */
  groupSum(groupValue, field) {
    return this.sum(field, this.getGroupRecords(groupValue));
  }
});

/**
 * @module Core/data/mixin/StoreSearch
 */
const findInString = (value, text) => String(value).toLowerCase().includes(text),
  matchFns = {
    string: findInString,
    number: findInString,
    boolean: findInString,
    date: (value, text) => {
      if (value instanceof Date && text instanceof Date) {
        return value - text === 0;
      }
      return String(value.getMonth() + 1).includes(text) || String(value.getDate()).includes(text) || String(value.getFullYear()).includes(text);
    },
    object: (value, text) => value === text,
    // typeof null === object
    undefined: (value, text) => value === text
  };
/**
 * Format returned by Store#findByField().
 * @typedef {Object} StoreSearchResult
 * @property {Number} index Index of the record in the store
 * @property {Core.data.Model} data The record
 */
/**
 * Mixin for Store that handles searching (multiple records) and finding (single record).
 *
 * @example
 * // find all records that has a field containing the string john
 * let hits = store.search('john');
 *
 * @mixin
 */
var StoreSearch = (Target => class StoreSearch extends (Target || Base) {
  static get $name() {
    return 'StoreSearch';
  }
  //region Search (multiple hits)
  /**
   * Find all hits matching the specified input
   * @param {String} text Value to search for
   * @param {String[]} fields Fields to search value in
   * @param {Function[]} [formatters] An array of field formatting functions to format the found value
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {StoreSearchResult[]} Array of hits, in the format { index: x, data: record }
   * @category Search
   */
  search(text, fields = null, formatters, searchAllRecords) {
    const records = this.isTree && !searchAllRecords ? this.rootNode.allChildren : this.getAllDataRecords(searchAllRecords),
      len = records.length,
      found = [];
    if (text == null) {
      return [];
    }
    if (typeof text === 'string') {
      text = text.toLowerCase();
    }
    let i, j, record, value, valueType, comparison;
    for (i = 0; i < len; i++) {
      record = records[i];
      j = 0;
      for (const key of fields || record.fieldNames) {
        var _comparison;
        value = record.getValue(key);
        valueType = value instanceof Date ? 'date' : typeof value;
        const formatter = formatters === null || formatters === void 0 ? void 0 : formatters[j];
        if (formatter) {
          value = formatter(value);
          valueType = 'string';
        }
        comparison = matchFns[valueType];
        if (value && (_comparison = comparison) !== null && _comparison !== void 0 && _comparison(value, text)) {
          found.push({
            index: i,
            data: record,
            field: key,
            id: record.id
          });
        }
        j++;
      }
    }
    return found;
  }
  /**
   * Find occurrences of the specified `value` in the specified `field` on all records in the store
   * @param {String} field The record field to search in
   * @param {*} value Value to search for
   * @param {Boolean} distinct True to only return distinct matches, no duplicates
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {StoreSearchResult[]} Array of hits, in the format { index: x, data: record }
   * @category Search
   */
  findByField(field, value, distinct = false, searchAllRecords = false) {
    const records = this.getAllDataRecords(searchAllRecords),
      len = records.length,
      usedValues = new Set(),
      found = [];
    let i, record, fieldValue;
    if (value != null) {
      value = String(value).toLowerCase();
    }
    for (i = 0; i < len; i++) {
      record = records[i];
      fieldValue = record.getValue(field);
      if (!distinct || !usedValues.has(fieldValue)) {
        const type = fieldValue instanceof Date ? 'date' : typeof fieldValue,
          matchFn = matchFns[type];
        if (value == null && fieldValue === value || value && matchFn(fieldValue, value)) {
          found.push({
            id: record.id,
            index: i,
            data: record
          });
          if (distinct) {
            usedValues.add(fieldValue);
          }
        }
      }
    }
    return found;
  }
  //endregion
  //region Find (single hit)
  /**
   * Finds the first record for which the specified function returns true
   * @param {Function} fn Comparison function, called with record as parameter
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {Core.data.Model} Record or undefined if none found
   *
   * @example
   * store.find(record => record.color === 'blue');
   * @category Search
   */
  find(fn, searchAllRecords = false) {
    return this.getAllDataRecords(searchAllRecords).find(fn);
  }
  /**
   * Finds the first record for which the specified field has the specified value
   * @param {String} fieldName Field name
   * @param {*} value Value to find
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {Core.data.Model} Record or undefined if none found
   * @category Search
   */
  findRecord(fieldName, value, searchAllRecords = false) {
    const matchFn = r => ObjectHelper.isEqual(r[fieldName], value);
    if (this.isTree) {
      return this.query(matchFn, searchAllRecords)[0];
    }
    return this.getAllDataRecords(searchAllRecords).find(matchFn);
  }
  /**
   * Searches the Store records using the passed function.
   * @param {Function} fn A function that is called for each record. Return true to indicate a match
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {Core.data.Model[]} An array of the matching Records
   * @category Search
   */
  query(fn, searchAllRecords = false) {
    if (this.isTree) {
      const matches = [];
      this.traverse(node => {
        if (fn(node)) {
          matches.push(node);
        }
      }, undefined, undefined, searchAllRecords);
      return matches;
    }
    return this.getAllDataRecords(searchAllRecords).filter(fn);
  }
  //endregion
  //region Others
  /**
   * Returns true if the supplied function returns true for any record in the store
   * @param {Function} fn A function that should return true to indicate a match
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {Boolean}
   *
   * @example
   * store.some(record => record.age > 95); // true if any record has age > 95
   * @category Search
   */
  some(fn, searchAllRecords = false) {
    return this.getAllDataRecords(searchAllRecords).some(fn);
  }
  //endregion
});

/**
 * @module Core/data/mixin/StoreSort
 */
/**
 * An immutable object representing a store sorter.
 *
 * @typedef {Object} Sorter
 * @property {String} field Field name
 * @property {Function} [fn] A custom sorting function
 * @property {Boolean} [ascending=true] `true` to sort ascending, `false` to sort descending
 */
/**
 * Mixin for Store that handles simple sorting as well as multi-level sorting.
 *
 * ```javascript
 * // single sorter
 * store.sort('age');
 *
 * // single sorter as object, descending order
 * store.sort({ field : 'age', ascending : false });
 *
 * // multiple sorters
 * store.sort(['age', 'name']);
 *
 * // using custom sorting function
 * store.sort({
 *     fn : (recordA, recordB) => {
 *         // apply custom logic, for example:
 *         return recordA.name.length < recordB.name.length ? -1 : 1;
 *     }
 * });
 *
 * // using locale specific sort (slow)
 * store.sort({ field : 'name', useLocaleSort : 'sv-SE' });
 * ```
 *
 * @mixin
 */
var StoreSort = (Target => class StoreSort extends (Target || Base) {
  static get $name() {
    return 'StoreSort';
  }
  //region Config
  static get defaultConfig() {
    return {
      /**
       * Use `localeCompare()` when sorting, which lets the browser sort in a locale specific order. Set to `true`,
       * a locale string or a locale config to enable.
       *
       * Enabling this has big negative impact on sorting
       * performance. For more info on `localeCompare()`, see [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare).
       *
       * Examples:
       *
       * ```javascript
       * const store = new Store({
       *     // Swedish sorting
       *     useLocaleSort : 'sv-SE'
       * });
       *
       * const store = new Store({
       *     // Swedish sorting with custom casing order
       *     useLocaleSort : {
       *         locale    : 'sv-SE',
       *         caseFirst : 'upper'
       *     }
       * });
       * ```
       *
       * Can also be configured on a per-sorter basis:
       *
       * ```javascript
       * store.sort({ field: 'name', useLocaleSort : 'sv-SE' });
       * ```
       *
       * @config {Boolean|String|Object}
       * @default false
       * @category Advanced
       */
      useLocaleSort: null
    };
  }
  static get configurable() {
    return {
      /**
       * Initial sorters, format is [{ field: 'name', ascending: false }, ...]
       * @config {Sorter[]|String[]}
       * @category Common
       */
      sorters: [],
      /**
       * Specify true to sort this store after records are added.
       * @config {Boolean}
       * @default
       * @category Sorting
       */
      reapplySortersOnAdd: false
    };
  }
  //endregion
  //region Events
  /**
   * Fired before sorting
   * @event beforeSort
   * @param {Core.data.Store} source This Store
   * @param {Sorter[]} sorters Sorter configs
   * @param {Core.data.Model[]} records Records to sort
   */
  /**
   * Fired after sorting
   * @event sort
   * @param {Core.data.Store} source This Store
   * @param {Sorter[]} sorters Sorter configs
   * @param {Core.data.Model[]} records Sorted records
   */
  //endregion
  //region Properties
  /**
   * Currently applied sorters
   * @member {Sorter[]} sorters
   * @readonly
   * @category Sort, group & filter
   */
  /**
   * Is store sorted?
   * @property {Boolean}
   * @readonly
   * @category Sort, group & filter
   */
  get isSorted() {
    return Boolean(this.sorters.length) || this.isGrouped;
  }
  changeSorters(sorters) {
    return sorters.map(sorter => this.normalizeSorterConfig(sorter, true));
  }
  updateReapplySortersOnAdd(enable) {
    this.storage.autoSort = enable;
  }
  //endregion
  //region Add & remove sorters
  /**
   * Sort records, either by replacing current sorters or by adding to them.
   * A sorter can specify a **_custom sorting function_** which will be called with arguments (recordA, recordB).
   * Works in the same way as a standard array sorter, except that returning `null` triggers the stores
   * normal sorting routine.
   *
   * ```javascript
   * // single sorter
   * store.sort('age');
   *
   * // single sorter as object, descending order
   * store.sort({ field : 'age', ascending : false });
   *
   * // multiple sorters
   * store.sort(['age', 'name']);
   *
   * // using custom sorting function
   * store.sort((recordA, recordB) => {
   *     // apply custom logic, for example:
   *     return recordA.name.length < recordB.name.length ? -1 : 1;
   * });
   *
   * // using locale specific sort (slow)
   * store.sort({ field : 'name', useLocaleSort : 'sv-SE' });
   * ```
   *
   * @param {String|Sorter[]|Sorter|Function} field Field to sort by.
   * Can also be an array of {@link Core.util.CollectionSorter sorter} config objects, or a sorting function, or a
   * {@link Core.util.CollectionSorter sorter} config.
   * @param {Boolean} [ascending] Sort order.
   * Applicable when the `field` is a string (if not specified and already sorted by the field, reverts direction),
   * or an object and `ascending` property is not specified for the object. `true` by default.
   * Not applicable when `field` is a function. `ascending` is always `true` in this case.
   * @param {Boolean} [add] If `true`, adds a sorter to the sorters collection.
   * Not applicable when `field` is an array. In this case always replaces active sorters.
   * @param {Boolean} [silent] Set as true to not fire events. UI will not be informed about the changes.
   * @category Sort, group & filter
   * @fires beforeSort
   * @fires sort
   * @fires refresh
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   */
  sort(field, ascending, add = false, silent = false) {
    const me = this,
      records = me.allRecords,
      currentSorters = me.sorters ? me.sorters.slice() : [];
    let currentDir = null,
      curSort;
    if (field) {
      if (Array.isArray(field)) {
        // array of strings make fields always be sorted ascending
        me.sorters = field.map(sorter => me.normalizeSorterConfig(sorter, typeof sorter === 'string' ? true : ascending));
      } else {
        const sorter = me.normalizeSorterConfig(field, ascending);
        if (add) {
          curSort = me.getCurrentSorterByField(sorter.field);
          // Field already among sorters? change sort direction instead of adding new sorter
          if (curSort) {
            currentDir = curSort.ascending;
            curSort.ascending = sorter.ascending;
          } else {
            me.sorters.push(sorter);
          }
        } else {
          me.sorters = [sorter];
        }
      }
    }
    if (!silent && me.trigger('beforeSort', {
      sorters: me.sorters,
      records,
      currentSorters
    }) === false) {
      // Restore sorters
      me.sorters = currentSorters;
      // Restore sorting direction if toggled
      if (currentDir !== null) {
        curSort.ascending = currentDir;
      }
      return null;
    }
    return me.performSort(silent);
  }
  normalizeSorterConfig(field, ascending) {
    const me = this,
      sorter = {
        ascending
      };
    if (typeof field === 'object') {
      ObjectHelper.assign(sorter, field);
      if (field.fn) {
        delete sorter.fn;
        sorter.sortFn = field.fn;
      }
      sorter.ascending = field.ascending ?? ascending;
    } else if (typeof field === 'function') {
      sorter.sortFn = field;
    } else {
      sorter.field = field;
    }
    // sort in opposite direction if not specified and already sorted, default to sorting ascending
    if (sorter.ascending == null) {
      const curSort = me.getCurrentSorterByField(sorter.field);
      sorter.ascending = curSort ? !curSort.ascending : true;
    }
    if (sorter.sortFn == null) {
      var _me$modelClass, _me$modelClass$$meta$;
      const compareItems = (_me$modelClass = me.modelClass) === null || _me$modelClass === void 0 ? void 0 : (_me$modelClass$$meta$ = _me$modelClass.$meta.fields.map[sorter.field]) === null || _me$modelClass$$meta$ === void 0 ? void 0 : _me$modelClass$$meta$.compareItems;
      if (compareItems) {
        // These sorters will be ignored by AjaxStore when remoting...
        sorter.sortFn = compareItems;
      }
    }
    return sorter;
  }
  getCurrentSorterByField(field) {
    return typeof field === 'string' && this.sorters.find(s => s.field === field) || null;
  }
  /**
   * Add a sorting level (a sorter).
   * @param {String|Sorter[]|Sorter|Function} field Field to sort by. Can also be an array of sorters, or a sorting
   * function, or a {@link Core.util.CollectionSorter sorter} config.
   * @param {Boolean} [ascending] Sort order (used only if field specified as string)
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  addSorter(field, ascending = true) {
    return this.sort(field, ascending, true);
  }
  /**
   * Remove a sorting level (a sorter)
   * @param {String|Function} field Stop sorting by this field (or sorter function)
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  removeSorter(field) {
    const sorterIndex = this.sorters.findIndex(sorter => sorter.field === field || sorter.sortFn === field);
    if (sorterIndex > -1) {
      this.sorters.splice(sorterIndex, 1);
      return this.sort();
    }
  }
  /**
   * Removes all sorters, turning store sorting off.
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  clearSorters(silent = false) {
    if (this.sorters.length) {
      this.sorters.length = 0;
      return this.sort(undefined, undefined, undefined, silent);
    }
  }
  //region
  //region Sorting logic
  /**
   * Creates a function used with Array#sort when sorting the store. Override to use your own custom sorting logic.
   * @param {Sorter[]} sorters An array of sorter config objects
   * @returns {Function}
   * @category Sort, group & filter
   */
  createSorterFn(sorters) {
    const storeLocaleSort = this.useLocaleSort;
    return (lhs, rhs) => {
      for (let i = 0; i < sorters.length; i++) {
        const sorter = sorters[i],
          {
            field,
            ascending = true,
            useLocaleSort = storeLocaleSort
          } = sorter,
          fn = sorter.fn || sorter.sortFn,
          direction = ascending ? 1 : -1;
        if (fn) {
          const val = fn.call(sorter, lhs, rhs);
          if (val === 0) {
            // equal values, let next sorter define order
            continue;
          }
          if (val !== null) {
            return val * direction;
          }
        }
        const lhsValue = lhs.isModel ? lhs.getValue(field) : lhs[field],
          rhsValue = rhs.isModel ? rhs.getValue(field) : rhs[field];
        if (lhsValue === rhsValue) {
          continue;
        }
        if (lhsValue == null) {
          return -direction;
        }
        if (rhsValue == null) {
          return direction;
        }
        if (useLocaleSort && typeof lhsValue === 'string') {
          // Use systems locale
          if (useLocaleSort === true) {
            return String(lhsValue).localeCompare(rhsValue) * direction;
          }
          // Use specified locale
          if (typeof useLocaleSort === 'string') {
            return String(lhsValue).localeCompare(rhsValue, useLocaleSort) * direction;
          }
          // Use locale config
          if (typeof useLocaleSort === 'object') {
            return String(lhsValue).localeCompare(rhsValue, useLocaleSort.locale, useLocaleSort) * direction;
          }
        }
        if (lhsValue > rhsValue) {
          return direction;
        }
        if (lhsValue < rhsValue) {
          return -direction;
        }
      }
      return 0;
    };
  }
  /**
   * The sorter function for sorting records in the store.
   * @member {Function}
   * @internal
   * @readonly
   */
  get sorterFn() {
    const me = this,
      {
        sorters
      } = me;
    // When remoteSort is enabled then always sort by data order received from remote server
    // _remoteSortIndex is set inside store.setStoreData() method
    return me.createSorterFn(me.remoteSort ? [{
      field: '_remoteSortIndex'
    }] : me.isGrouped ? me.groupers.concat(sorters) : sorters);
  }
  /**
   * Perform sorting according to the {@link #config-sorters} configured.
   * This is the internal implementation which is overridden in {@link Core.data.AjaxStore} and
   * must not be overridden.
   * @async
   * @private
   * @category Sort, group & filter
   */
  performSort(silent) {
    const me = this,
      {
        rootNode,
        storage,
        sorterFn: sorter
      } = me;
    if (me.tree) {
      !me.isChained && rootNode.traverse(node => {
        if (node.isLoaded && node.isParent) {
          node.children.sort(sorter);
          // Since child nodes change order their parentIndex needs to be updated.
          // Update is silent, records won't be considered modified because of the sort
          node.updateChildrenIndices(node.children, 'parentIndex', true);
        }
      });
      storage.replaceValues({
        values: me.collectDescendants(rootNode).visible,
        silent: true
      });
    } else if (me.isGrouped) {
      storage.replaceValues({
        ...me.prepareGroupRecords(sorter),
        silent: true
      });
    } else {
      storage.replaceValues({
        values: storage.values.sort(sorter),
        silent: true
      });
    }
    me.afterPerformSort(silent || me.isRemoteDataLoading);
  }
  afterPerformSort(silent) {
    if (silent) {
      return;
    }
    const me = this;
    me._idMap = null;
    const event = {
      action: 'sort',
      sorters: me.sorters,
      records: me.allRecords
    };
    me.trigger('sort', event);
    me.trigger('refresh', event);
  }
  //endregion
});

/**
 * @module Core/data/mixin/StoreChained
 */
const returnTrue = () => true;
/**
 * A chained Store contains a subset of records from a master store. Which records to include is determined by a
 * filtering function, {@link #config-chainedFilterFn}.
 *
 * ```javascript
 * masterStore.chain(record => record.percent < 10);
 *
 * // or
 *
 * new Store({
 *   masterStore     : masterStore,
 *   chainedFilterFn : record => record.percent < 10
 * });
 * ```
 *
 * @mixin
 */
var StoreChained = (Target => class StoreChained extends (Target || Base) {
  static get $name() {
    return 'StoreChained';
  }
  //region Config
  static get defaultConfig() {
    return {
      /**
       * Function used to filter records in the masterStore into a chained store. If not provided,
       * all records from the masterStore will be included in the chained store.
       * @config {Function}
       * @category Chained store
       */
      chainedFilterFn: null,
      /**
       * Array of field names that should trigger filtering of chained store when the fields are updated.
       * @config {String[]}
       * @category Chained store
       */
      chainedFields: null,
      /**
       * Master store that a chained store gets its records from.
       * @config {Core.data.Store}
       * @category Chained store
       */
      masterStore: null,
      /**
       * Method names calls to which should be relayed to master store.
       * @config {String[]}
       * @category Chained store
       */
      doRelayToMaster: ['add', 'remove', 'insert'],
      /**
       * Method names calls to which shouldn't be relayed to master store.
       * @config {String}
       * @category Chained store
       */
      dontRelayToMaster: [],
      /**
       * If true, collapsed records in original tree will be excluded from the chained store.
       * @config {Boolean}
       * @category Chained store
       */
      excludeCollapsedRecords: true,
      chainSuspended: 0
    };
  }
  // All props should be predefined to work properly with objectified stores
  static get properties() {
    return {
      chainedStores: null
    };
  }
  //endregion
  construct(config) {
    super.construct(config);
    const me = this,
      {
        masterStore
      } = me,
      sort = me.syncOrder ? 'sort' : '';
    if (masterStore) {
      me.methodNamesToRelay.forEach(fnName => me[fnName] = (...params) => me.relayToMaster(fnName, params));
      me.removeAll = (...params) => {
        masterStore.remove(me.getRange(), ...params);
      };
      masterStore.ion({
        // HACK to have chained stores react early in a async events scenario (with engine). Could be turned
        // into a config, but this way one does not have to think about it
        changePreCommit: me.onMasterDataChangedPreCommit,
        change: me.onMasterDataChanged,
        [sort]: me.onMasterDataChanged,
        prio: 1,
        thisObj: me
      });
      if (!masterStore.chainedStores) {
        masterStore.chainedStores = [];
      }
      masterStore.chainedStores.push(me);
      me.fillFromMaster();
    }
  }
  //region Properties
  // For accessing the full set of records, whether chained or not
  get $master() {
    return this.masterStore || this;
  }
  /**
   * Is this a chained store?
   * @property {Boolean}
   * @readonly
   * @category Advanced
   */
  get isChained() {
    return Boolean(this.masterStore);
  }
  set chainedFilterFn(chainedFilterFn) {
    this._chainedFilterFn = this.thisObj ? chainedFilterFn.bind(this.thisObj) : chainedFilterFn;
  }
  get chainedFilterFn() {
    return this._chainedFilterFn || returnTrue;
  }
  get methodNamesToRelay() {
    const doIsArray = Array.isArray(this.doRelayToMaster),
      dontIsArray = Array.isArray(this.dontRelayToMaster);
    return doIsArray && this.doRelayToMaster.filter(name => !dontIsArray || !this.dontRelayToMaster.includes(name)) || [];
  }
  //endregion
  //region Internal
  updateChainedStores() {
    if (this.chainedStores) {
      this.chainedStores.forEach(store => store.fillFromMaster());
    }
  }
  /**
   * Updates records available in a chained store by filtering the master store records using
   * {@link #config-chainedFilterFn}
   * @category Chained store
   */
  fillFromMaster() {
    const me = this,
      {
        masterStore,
        isTree
      } = me;
    let records = [];
    if (!me.isChained) {
      throw new Error('fillFromMaster only allowed on chained store');
    }
    if (me.isChainSuspended) {
      return;
    }
    if (masterStore.isGrouped && masterStore.isFiltered) {
      masterStore.forEach(r => records.push(r), masterStore, {
        includeFilteredOutRecords: true,
        includeCollapsedGroupRecords: true
      });
    } else {
      records = masterStore.allRecords.filter(r => !r.isSpecialRow && me.chainedFilterFn(r));
    }
    if (isTree) {
      // All nodes will be registered
      me.idRegister = {};
      me.internalIdRegister = {};
      // *all* owned records have to join, as they would have done if they'd all gone through
      // the appendChild route for this store.
      records.forEach(r => {
        if (r.stores.includes(me)) {
          me.register(r);
        } else {
          r.joinStore(me);
        }
      });
      // We exclude collapsed records by default. It's used in Columns Store.
      // Because grid columns is a tree store when subgrid columns is just a chained store of the columns store.
      // And we don't need to include collapsed column.
      // If we need to show collapsed nodes in Combo we need to chain tree store and set `excludeCollapsedRecords` to `false`.
      if (me.excludeCollapsedRecords) {
        const children = me.getChildren(me.rootNode);
        records = me.doIncludeExclude(children, true);
      }
    }
    me.isFillingFromMaster = true;
    me.data = records;
    me.isFillingFromMaster = false;
  }
  /**
   * Commits changes back to master.
   * - the records deleted from chained store and present in master will be deleted from master
   * - the records added to chained store and missing in master will added to master
   * Internally calls {Store#function-commit commit()}.
   * @returns {Object} Changes, see Store#changes
   * @internal
   */
  commitToMaster() {
    const me = this,
      master = me.masterStore;
    if (!me.isChained) {
      throw new Error('commitToMaster only allowed on chained store');
    }
    master.beginBatch();
    master.remove(me.removed.values);
    master.add(me.added.values);
    master.endBatch();
    return me.commit();
  }
  /**
   * Relays some function calls to the master store
   * @private
   */
  relayToMaster(fnName, params) {
    return this.masterStore[fnName](...params);
  }
  // HACK, when used with engine the chained store will catch events early (sync) and prevent late (async) listeners
  onMasterDataChangedPreCommit(event) {
    this.onMasterDataChanged(event);
    this.$masterEventhandled = true;
  }
  /**
   * Handles changes in master stores data. Updates the chained store accordingly
   * @private
   */
  onMasterDataChanged({
    action,
    changes,
    $handled,
    isMove
  }) {
    var _this$chainedFields;
    // Handled early in engine store (above), bail out
    if (this.$masterEventhandled) {
      this.$masterEventhandled = false;
      return;
    }
    // 'move' action triggers a remove event first, we wait for the 'add' - no need to fill twice
    if (isMove && action === 'remove') {
      return;
    }
    // if a field not defined in chainedFields is changed, ignore the change.
    // there is no need to refilter the store in such cases, the change will be available anyhow since data is
    // shared
    if (action !== 'update' || (_this$chainedFields = this.chainedFields) !== null && _this$chainedFields !== void 0 && _this$chainedFields.some(field => field in changes)) {
      this.fillFromMaster();
    }
  }
  //endregion
  //region public API
  /**
   * Creates a chained store, a new Store instance that contains a subset of the records from current store.
   * Which records is determined by a filtering function, which is reapplied when data in the base store changes.
   *
   * ```javascript
   * const oldies = store.makeChained(record => record.age > 50);
   * // or use a simple query
   * const ages = store.makeChained(() => store.allRecords.distinct('age')));
   * ```
   *
   * If this store is a {@link Core.data.mixin.StoreTree#property-isTree tree} store, then the resulting chained store
   * will be a tree store sharing the same root node, but only child nodes which pass the `chainedFilterFn` will be
   * considered when iterating the tree through the methods such as
   * {@link Core.data.Store#function-traverse} or {@link Core.data.Store#function-forEach}.
   *
   * @param {Function} [chainedFilterFn] Either a filter function called for every record to determine if it should be
   * included (return true / false), or a query function called with no arguments (see example below). Defaults to
   * including all records (fn always returning true)
   * @param {String[]} [chainedFields] Array of fields that trigger filtering when they are updated
   * @param {StoreConfig} [config] Additional chained store configuration. See {@link Core.data.Store#configs}
   * @param {Class} [config.storeClass] The Store class to use if this Store type is not required.
   * @returns {Core.data.Store}
   * @category Chained store
   */
  makeChained(chainedFilterFn = returnTrue, chainedFields, config) {
    return new ((config === null || config === void 0 ? void 0 : config.storeClass) || this.constructor)({
      ...(config || {}),
      tree: false,
      autoTree: false,
      // If someone ever chains a chained store, chain master instead
      masterStore: this.$master,
      modelClass: this.modelClass,
      // Chained store should never use syncDataOnLoad, that will create an infinite loop when they determine
      // that a record is added and then add it to master, repopulating this store and round we go
      syncDataOnLoad: false,
      chainedFilterFn,
      chainedFields
    });
  }
  /**
   * Alias for {@link Core.data.Store#function-makeChained}
   *
   * @param {Function} [chainedFilterFn] Either a filter function called for every record to determine if it should be
   * included (return true / false), or a query function called with no arguments (see example below). Defaults to
   * including all records (fn always returning true)
   * @param {String[]} [chainedFields] Array of fields that trigger filtering when they are updated
   * @param {StoreConfig} [config] Additional chained store configuration. See {@link Core.data.Store#configs}
   * @param {Class} [config.storeClass] The Store class to use if this Store type is not required.
   * @returns {Core.data.Store}
   * @category Chained store
   */
  chain() {
    return this.makeChained(...arguments);
  }
  //endregion
  doDestroy() {
    var _this$chainedStores;
    // Destroy chained store on master store destroy
    (_this$chainedStores = this.chainedStores) === null || _this$chainedStores === void 0 ? void 0 : _this$chainedStores.forEach(chainedStore => chainedStore.destroy());
    // Events superclass fires destroy event.
    super.doDestroy();
  }
  suspendChain() {
    this.chainSuspended++;
  }
  resumeChain(refill = false) {
    if (this.chainSuspended && ! --this.chainSuspended && refill) {
      this.fillFromMaster();
    }
  }
  get isChainSuspended() {
    return this.chainSuspended > 0;
  }
});

/**
 * @module Core/data/mixin/StoreState
 */
/**
 * A Mixin for Store that manages its state.
 *  * **sorters**
 *  * **groupers**
 *  * **filters**: Only serializable filters are saved (filters defined with `property` and `value`).
 * @mixin
 */
var StoreState = (Target => class StoreState extends (Target || Base) {
  static get $name() {
    return 'StoreState';
  }
  /**
   * Get store state. Used by State-plugin to serialize state
   * @private
   * @returns {{ sorters, groupers }}
   */
  getState() {
    const {
        sorters,
        groupers,
        filters
      } = this,
      state = {};
    if (sorters !== null && sorters !== void 0 && sorters.length) {
      state.sorters = sorters.map(sorter => {
        const clone = ObjectHelper.cleanupProperties(ObjectHelper.clone(sorter));
        // Remove sorting fns
        delete clone.fn;
        delete clone.sortFn;
        return clone;
      });
    }
    if (groupers !== null && groupers !== void 0 && groupers.length) {
      state.groupers = groupers.map(grouper => {
        const clone = ObjectHelper.cleanupProperties(ObjectHelper.clone(grouper));
        // Remove grouping fns
        delete clone.fn;
        return clone;
      });
    }
    if (filters !== null && filters !== void 0 && filters.values.length) {
      state.filters = filters.values.map(filter => {
        const clone = ObjectHelper.cleanupProperties(ObjectHelper.clone(filter.config));
        // Apply value, needed because of filterable fn reusing instance (so not in config)
        clone.value = filter.value;
        // Remove default value, no need to store that in state
        if (clone.caseSensitive) {
          delete clone.caseSensitive;
        }
        // Remove filtering fns
        // delete clone.filterBy; // Cannot remove it, required by export feature
        return clone;
      });
    }
    return state;
  }
  /**
   * Apply store state. Used by State-plugin to restore a previously serialized state
   * @private
   * @param {{ sorters, groupers }} state
   */
  applyState(state) {
    const me = this,
      {
        sorters = [],
        groupers = [],
        filters = []
      } = state,
      {
        sortParamName,
        filterParamName
      } = me;
    // We cannot apply sorters with a sortFn if we are doing server-side sorting
    me.sorters = sorters.filter(sorter => sorter.field || sorter.sortFn && !sortParamName);
    me.groupers = groupers.slice();
    me.sort();
    // We cannot apply filters with a filterBy if we are doing server-side filtering
    me.filters = filters.filter(filter => filter.property || filter.filterBy && !filterParamName);
    me.filter();
  }
});

/**
 * @module Core/data/Wbs
 */
const zeroPad = v => String(v).padStart(6, '0');
/**
 * This class holds a WBS (Work Breakdown Structure) value (e.g., '1.2.1'). This class ensures that such values compare
 * correctly, for example, that '1.2' is less than '1.10' (which do not compare that way as simple text).
 */
class Wbs {
  /**
   * Wbs constructor.
   * @param {String|Number} value The value of WBS
   */
  constructor(value) {
    this.value = value;
    this._padded = null;
  }
  /**
   * The WBS value
   * @readonly
   * @member {String} value
   */
  set value(value) {
    this._value = String(value ?? '');
  }
  get value() {
    return this._value;
  }
  /**
   * Returns a `Wbs` instance given a `value`. If the `value` is already a `Wbs` object, it is returned. Otherwise,
   * a new `Wbs` is created. If `value` is `null` or `undefined`, that value is returned.
   * @param {String|Number|Core.data.Wbs} value
   * @returns {Core.data.Wbs}
   */
  static from(value) {
    // this must preserve null to be useful as a data field, where a null value means no value present.
    return value == null ? value : value instanceof Wbs ? value : new Wbs(value);
  }
  /**
   * Returns a WBS code where each component is 0-padded on the left to 6 digits. That is "1.2" is padded to be
   * "000001.000002". These values can be compared for proper semantic order (e.g., Wbs.pad('1.2') < Wbs.pad('1.10')).
   * @param {String|Number|Core.data.Wbs} value
   * @returns {String}
   * @private
   */
  static pad(value) {
    return value instanceof Wbs ? value.valueOf() : Wbs.split(value).map(zeroPad).join('.');
  }
  /**
   * Returns an array of digits from a given WBS code `value`. If the value cannot be converted, an empty array is
   * returned.
   * @param {String|Number|Core.data.Wbs} value
   * @returns {Number[]}
   * @private
   */
  static split(value) {
    let i, ret;
    if (value || value === 0) {
      switch (typeof value) {
        case 'object':
          value = String(value);
        // noinspection FallThroughInSwitchStatementJS
        case 'string':
          // eslint-disable-line no-fallthrough
          ret = value.split('.');
          for /* empty */
          (i = ret.length; i-- > 0;) {
            ret[i] = parseInt(ret[i], 10);
          }
          break;
        case 'number':
          ret = [value];
          break;
      }
    }
    return ret || [];
  }
  /**
   * Compares two WBS values, returning 0 if equal, -1 if `lhs` is less than `rhs, or 1 if `lhs` is greater than `rhs`.
   * @param {String|Core.data.Wbs} lhs
   * @param {String|Core.data.Wbs} rhs
   * @returns {Number}
   */
  static compare(lhs, rhs) {
    if (lhs === rhs) {
      return 0;
    }
    if (!lhs || !rhs) {
      return lhs ? 1 : rhs ? -1 : 0;
    }
    lhs = Wbs.pad(lhs);
    rhs = Wbs.pad(rhs);
    return lhs < rhs ? -1 : rhs < lhs ? 1 : 0;
  }
  /**
   * Appends a sub-level WBS value to this WBS code and returns a `Wbs` instance for it.
   * @param {String|Number} value
   * @returns {Core.data.Wbs}
   */
  append(value) {
    const s = this.value;
    return Wbs.from(s ? `${s}.${value}` : value);
  }
  /**
   * Returns truthy value if this Wbs equals the passed value.
   * @param {String|Core.data.Wbs} value
   * @returns {Boolean}
   */
  isEqual(value) {
    return !Wbs.compare(this, value);
  }
  /**
   * Compares this WBS value with a specified pattern, returning `true` if they match. If the `pattern` is simply a
   * sequence of digits and decimal points (e.g., "1.2"), it is a match if it is a substring of this WBS code (e.g.,
   * "3.1.2.4"). If the `pattern` starts with `*` (e.g., "*.1.2"), it is a match if this WBS code ends with the text
   * following the `*` (e.g., "4.3.1.2"). If the `pattern` ends with `*`, it is a match if this WBS code starts with
   * the text up to the `*`.
   *
   * Some examples:
   * ```
   *  console.log(Wbs.from('1.2.3.4').match('2.3'));
   *  > true
   *  console.log(Wbs.from('1.2.3.4').match('*.4'));
   *  > true
   *  console.log(Wbs.from('1.2.3.4').match('1.2.*'));
   *  > true
   *
   *  console.log(Wbs.from('1.2.3.4').match('2.4'));
   *  > false
   *  console.log(Wbs.from('1.2.3.4').match('*.3'));
   *  > false
   *  console.log(Wbs.from('1.2.3.4').match('2.*'));
   *  > false
   * ```
   * @param {String} pattern A partial WBS code (e.g., "1.2"), optionally starting or ending with `*`.
   * @returns {Boolean}
   */
  match(pattern) {
    let ret = false;
    if (pattern) {
      const wbs = this.value,
        globLeft = pattern[0] === '*',
        globRight = pattern.endsWith('*'),
        n = pattern.length;
      if (globLeft === globRight) {
        // no globs behavior is the same as both globs ('1.2' is the same as '*1.2*')
        ret = wbs.indexOf(globLeft ? pattern.substr(1, n - 2) : pattern) > -1;
      } else if (globLeft) {
        ret = wbs.endsWith(pattern.substr(1));
      } else {
        ret = wbs.startsWith(pattern.substr(0, n - 1));
      }
    }
    return ret;
  }
  toString() {
    return this.value;
  }
  toJSON() {
    return this.toString();
  }
  valueOf() {
    // the value we return is implicitly used by < and > operators when comparing instances of this type, so we
    // need to return a value that makes "1.2 < 1.10" evaluate as true:
    return this._padded ?? (this._padded = Wbs.pad(this.value));
  }
}
Wbs._$name = 'Wbs';

/**
 * @module Core/data/mixin/StoreTree
 */
const emptyArray$4 = Object.freeze([]),
  StopBranch = Symbol('StopBranch');
/**
 * Mixin for store with tree related functionality. To learn more about working with tree nodes please see the
 * {@link Core/data/mixin/TreeNode} class and [this guide](#Core/guides/data/treedata.md).
 * @mixin
 */
var StoreTree = (Target => class StoreTree extends (Target || Base) {
  static $name = 'StoreTree';
  /**
   * A special `Symbol` signalizing treeify method that the current record grouping should be stopped.
   *
   * ```javascript
   * const newRoot = workerStore.treeify([
   *     // group workers by company
   *     worker => {
   *         // if the worker is unemployed we don't put it in a group
   *         // we just show such record on the root level
   *         if (!worker.company) {
   *             return Store.StopBranch
   *         }
   *
   *         return worker.company;
   *     ]
   * ]);
   * ```
   * @member {Symbol} StopBranch
   * @static
   * @category Advanced
   */
  static StopBranch = StopBranch;
  get StopBranch() {
    return StopBranch;
  }
  static configurable = {
    /**
     * Set to `true` to on load transform a flat dataset with raw objects containing `parentId` into the format
     * expected for tree data.
     *
     * Example input format:
     *
     * ```javascript
     * [
     *   { id : 1, name : 'Parent' },
     *   { id : 2, name : 'Child', parentId : 1 }
     * ]
     * ```
     *
     * Will be transformed into:
     *
     * ```javascript
     * [
     *   {
     *     id       : 1,
     *     name     : 'Parent',
     *     children : [
     *       { id : 2, name : 'Child', parentId : 1 }
     *     ]
     *   }
     * ]
     * ```
     *
     * @config {Boolean}
     * @category Tree
     */
    transformFlatData: null,
    /**
     * This flag prevents firing of 'remove' event when moving a node in the tree. In 6.0 this will be the default
     * behavior and this flag will be removed.
     * @config {Boolean}
     * @category Tree
     */
    fireRemoveEventForMoveAction: VersionHelper.checkVersion('core', '6.0', '<')
  };
  //region Getters
  /**
   * True if this Store is configured to handle tree data (with `tree : true`) or if this is a
   * {@link Core.data.Store#function-makeChained chained store} and the master store is a tree store.
   * @property {Boolean}
   * @readonly
   * @category Tree
   */
  get isTree() {
    return this.tree || this.masterStore && this.masterStore.tree;
  }
  /**
   * Returns all leaf records in a tree store
   * @property {Core.data.Model[]}
   * @category Tree
   */
  get leaves() {
    const me = this,
      result = [];
    if (me.isTree) {
      me.traverse(record => {
        if (record.isLeaf) {
          result.push(record);
        }
      });
      return result;
    } else {
      me.allRecords.forEach(r => {
        if (r.isLeaf) {
          result.push(r);
        }
        r.traverse(record => {
          if (record.isLeaf) {
            result.push(record);
          }
        }, true);
      });
    }
    return result;
  }
  //endregion
  //region Children
  /**
   * Loads children for a parent node that uses load on demand (when expanding it). Base implementation does nothing,
   * either use AjaxStore which implements it, create your own subclass with an implementation or listen for
   * `toggleNode` and insert records when you have them available.
   * @param {Core.data.Model} parentRecord
   * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is
   * vetoed by a {@link Core.data.AjaxStore#event-beforeLoadChildren} handler, or if an {@link Core.data.AjaxStore#event-exception} is detected.
   * The resolved function is passed the event object passed to any event handlers.
   * The rejected function is passed the {@link Core.data.AjaxStore#event-exception} event if an exception occurred,
   * or `false` if the load was vetoed by a {@link Core.data.AjaxStore#event-beforeLoadChildren} handler.
   * @category Tree
   */
  async loadChildren(parentRecord) {}
  /**
   * Called from Model when adding children. Not to be called directly, use Model#appendChild() instead.
   * @internal
   * @param {Core.data.mixin.TreeNode} parent
   * @param {Core.data.mixin.TreeNode[]} children
   * @param {Number} index
   * @param {Object} isMove
   * @param {Boolean} [silent]
   * @fires add
   * @fires change
   * @category Tree
   */
  onNodeAddChild(parent, children, index, isMove, silent = false) {
    const me = this,
      isRootLoad = parent === me.rootNode && parent.isLoading,
      {
        storage
      } = me,
      {
        previousSibling
      } = children[0];
    let storeInsertionPoint;
    const {
      visible: toAddToUI,
      all: toAdd
    } = me.collectDescendants(children, undefined, undefined, {
      inCollapsedBranch: !(parent.isExpanded(me) && parent.ancestorsExpanded(me)),
      applyFilter: me.isFiltered && me.reapplyFilterOnAdd
    });
    // Keep CRUD caches up to date unless it's a root load
    if (!isRootLoad && toAdd.length) {
      for (const record of toAdd) {
        // Only considered an add if not modified or moved
        if (!me.modified.includes(record) && !isMove[record.id]) {
          // If was removed, remove from `removed` list
          if (me.removed.includes(record)) {
            me.removed.remove(record);
          }
          // Else add to `added` list
          else if (!record.isLinked) {
            me.added.add(record);
          }
        }
      }
    }
    // Root node inserted first
    if (isRootLoad && me.rootVisible) {
      toAddToUI.unshift(parent);
      toAdd.unshift(parent);
    }
    if (toAddToUI.length) {
      // Calculate the insertion point into the flat store.
      // If the new node is the first, then it goes after the parent node.
      if (index === 0 || !previousSibling) {
        storeInsertionPoint = storage.indexOf(parent);
      }
      // Otherwise it has to go after the previous visible node which has
      // to be calculated. See indexOfPreviousVisibleNode for explanation.
      else {
        storeInsertionPoint = storage.indexOf(previousSibling) + previousSibling.getDescendantCount(true, me);
      }
      // Insert added child nodes at correct location in storage.
      // We must not react to change - we fire the events here.
      storage.suspendEvents();
      me.storage.splice(++storeInsertionPoint, 0, toAddToUI);
      storage.resumeEvents();
      me._idMap = null;
    } else {
      // Since storage is not updated, need to invalidate allRecords
      me._allRecords = null;
    }
    // Since we do not pass through Store#onDataChange we have to handle relations manually here. And since they are
    // not tied to flat part of store, use all children
    me.updateDependentStores('add', children);
    // If it's a root level set data op, then signal 'dataset'
    if (isRootLoad && toAddToUI.length) {
      var _me$afterLoadData;
      // If we have initial sorters, perform a silent sort before triggering `dataset`
      // NOTE: Records in toAddToUI will be in the original order, not affected by the sort
      if (me.sorters.length) {
        me.sort(null, null, false, true);
      }
      (_me$afterLoadData = me.afterLoadData) === null || _me$afterLoadData === void 0 ? void 0 : _me$afterLoadData.call(me);
      if (!silent) {
        const event = {
          action: 'dataset',
          data: me._data,
          records: toAddToUI
        };
        me.trigger('refresh', event);
        me.trigger('change', event);
      }
    }
    // Else, continue as before to signal an "isChild" add.
    else if (!silent) {
      const event = {
        action: 'add',
        parent,
        isChild: true,
        isMove,
        records: children,
        allRecords: toAdd,
        index: storeInsertionPoint
      };
      me.trigger('add', event);
      me.trigger('change', event);
      // Check if any add is actually a move
      if (Object.values(isMove).some(wasMoved => wasMoved)) {
        const event = {
          newParent: parent,
          records: children.filter(record => isMove[record.id]),
          oldParents: children.map(child => {
            return me.getById(child.meta.oldParentId);
          })
        };
        me.trigger('move', event);
      }
    }
  }
  onNodeRemoveChild(parent, children, index, flags = {
    isMove: false,
    silent: false,
    unfiltered: false
  }) {
    const me = this,
      {
        storage
      } = me,
      toRemoveFromUI = [],
      toRemove = [],
      {
        isMove,
        silent,
        unfiltered
      } = flags,
      removeUnfiltered = unfiltered && me.isFiltered,
      childrenToRemove = removeUnfiltered && parent.unfilteredChildren ? parent.unfilteredChildren : children;
    me.collectDescendants(childrenToRemove, toRemoveFromUI, toRemove, {
      inCollapsedBranch: !(parent.isExpanded(me) && parent.ancestorsExpanded(me)),
      unfiltered: removeUnfiltered
    });
    // test StoreTree.t.js should fail if the next line replaces the above line
    // me.collectDescendants(children, toRemoveFromUI, toRemove, { inCollapsedBranch : !(parent.isExpanded(me) && parent.ancestorsExpanded(me)) });
    if (!isMove) {
      // Unjoin is recursive, use flat children array
      for (const record of children) {
        record.unjoinStore(me);
      }
      // Keep CRUD caches up to date
      for (const record of toRemove) {
        if (record.stores.includes(me)) {
          record.unjoinStore(me);
        }
        // If was newly added, remove from `added` list
        if (me.added.includes(record)) {
          me.added.remove(record);
        }
        // Else add to `removed` list
        else if (!record.isLinked) {
          me.removed.add(record);
        }
      }
      me.modified.remove(toRemove);
    }
    // Remove removed child nodes at correct location in storage
    if (toRemoveFromUI.length) {
      index = storage.indexOf(toRemoveFromUI[0]);
      // We must not react to change - we fire the events here.
      if (index > -1) {
        storage.suspendEvents();
        storage.splice(index, toRemoveFromUI.length);
        storage.resumeEvents();
        me._idMap = null;
      }
    } else {
      // If nothing is removed from UI (storage) return -1, showing that removed node was in a collapsed branch
      index = -1;
      // Since storage is not updated, need to invalidate allRecords
      me._allRecords = null;
    }
    if (!silent && (me.fireRemoveEventForMoveAction || !isMove)) {
      const event = {
        action: 'remove',
        parent,
        isChild: true,
        isMove,
        records: children,
        allRecords: toRemove,
        index
      };
      me.trigger('remove', event);
      me.trigger('change', event);
    }
    return toRemove;
  }
  // IMPORTANT when using `applyFilter` option, should use the return value of this function
  // instead of relying on arguments mutation
  collectDescendants(node, visible = [], all = [], flags = {}) {
    const me = this,
      {
        inCollapsedBranch = false,
        unfiltered = false,
        applyFilter = false
      } = flags,
      children = Array.isArray(node) ? node : me.getChildren(node, unfiltered) ?? [];
    if (applyFilter) {
      return {
        visible: children.flatMap(child => this.collectVisibleNodeDescendantsFiltered(child)),
        all: children.flatMap(child => child.allChildren)
      };
    } else {
      for (let i = 0, len = children.length, child; i < len; i++) {
        child = children[i];
        if (!inCollapsedBranch) {
          visible.push(child);
        }
        all.push(child);
        me.collectDescendants(child, visible, all, {
          inCollapsedBranch: inCollapsedBranch || !child.isExpanded(me),
          unfiltered
        });
      }
      return {
        visible,
        all
      };
    }
  }
  collectVisibleNodeDescendantsFiltered(node) {
    const children = node.unfilteredChildren || node.children;
    if (!children || children.length === 0 || !node.isLeaf && !node.isExpanded(this)) {
      return this.filtersFunction(node) ? [node] : [];
    }
    const filteredChildren = children.flatMap(child => this.collectVisibleNodeDescendantsFiltered(child));
    return filteredChildren.length || this.filtersFunction(node) ? [node, ...filteredChildren] : [];
  }
  /**
   * Returns the children of the passed branch node which this store owns. By default, this
   * is the entire `children` array.
   *
   * **If this store {@link Core.data.mixin.StoreChained#property-isChained isChained}**, then
   * this returns only the subset of children which are filtered into this store by the
   * {@link Core.data.mixin.StoreChained#config-chainedFilterFn chainedFilterFn}.
   * @param {Core.data.Model} parent The node to return the children of.
   * @returns {Core.data.Model[]}
   * @category Tree
   */
  getChildren(parent, unfiltered = false) {
    const me = this,
      children = (unfiltered || me.isChained) && parent.unfilteredChildren || parent.children;
    return !(children !== null && children !== void 0 && children.length) ? emptyArray$4 : me.isChained
    // In case of chained store we need to apply chainedFilterFn and sorter
    ? children.filter(me.chainedFilterFn).sort(me.sorterFn) : children;
  }
  /**
   * Includes or excludes all records beneath parentRecord in storage. Used when expanding or collapsing
   * nodes.
   * @private
   * @param parentRecord Parent record
   * @param include Include (true) or exclude (false)
   * @category Tree
   */
  internalToggleTreeSubRecords(parentRecord, include) {
    const me = this,
      {
        storage
      } = me,
      index = storage.indexOf(parentRecord),
      children = me.doIncludeExclude(me.getChildren(parentRecord), include);
    // When expanded a parent node while being filtered, need to update the hidden flag of its children
    if (me.isFiltered && include && parentRecord.unfilteredChildren) {
      me.updateChildrenHiddenState(parentRecord);
    }
    // If we expanded a node which is yet to load children, the collected children
    // array will be empty, so do not broadcast any change event.
    // If we are collapsing a record which isn't visible (because parent is collapsed) we won't get an index,
    // which is fine since it is already removed from processedRecords
    if (children.length && index !== false) {
      // We must not react to change - we fire the events here with a flag
      // to tell responders that it's due to an expand or collapse.
      storage.suspendEvents();
      if (include) {
        storage.splice(index + 1, 0, ...children);
        const event = {
          action: 'add',
          isExpand: true,
          records: children,
          index: index + 1
        };
        me.trigger('add', event);
        me.trigger('change', event);
      } else {
        storage.splice(index + 1, children.length);
        const event = {
          action: 'remove',
          isCollapse: true,
          records: children,
          index: index + 1
        };
        me.trigger('remove', event);
        me.trigger('change', event);
      }
      storage.resumeEvents();
      me._idMap = null;
    }
  }
  // Updates the hidden flag of its children while store is filtered
  updateChildrenHiddenState(parentRecord) {
    var _parentRecord$unfilte;
    (_parentRecord$unfilte = parentRecord.unfilteredChildren) === null || _parentRecord$unfilte === void 0 ? void 0 : _parentRecord$unfilte.forEach(child => {
      child.instanceMeta(this.id).hidden = false;
      if (!child.isLeaf) {
        this.updateChildrenHiddenState(child);
      }
    });
  }
  doIncludeExclude(children, include, result = []) {
    const me = this,
      childCount = (children === null || children === void 0 ? void 0 : children.length) || 0;
    for (let i = 0; i < childCount; i++) {
      const child = children[i];
      // Only consider child nodes who we own.
      // If we are a chained store, skip nodes that are not ours.
      if (!me.isChained || me.chainedFilterFn(child)) {
        const mapMeta = child.instanceMeta(me.id);
        if (include || !mapMeta.hidden) {
          // if including sub-records, add those who are not hidden by a collapsed sub parent
          result.push(child);
        }
        mapMeta.hidden = !include;
        if (child.isExpanded(me)) {
          me.doIncludeExclude(me.getChildren(child), include, result);
        }
      }
    }
    return result;
  }
  /**
   * Collapse an expanded record or expand a collapsed. Optionally forcing a certain state.
   * @param {String|Number|Core.data.Model} idOrRecord Record (the record itself) or id of a record to toggle
   * @param {Boolean} [collapse] Force collapse (true) or expand (false)
   * @category Tree
   */
  async toggleCollapse(idOrRecord, collapse) {
    const me = this,
      record = me.getById(idOrRecord),
      meta = record.instanceMeta(me);
    if (collapse === undefined) {
      collapse = !meta.collapsed;
    }
    // Reject if we're in the middle of loading children, or it's a leaf, or it's a no-op
    if (!meta.isLoadingChildren && !record.isLeaf && record.isExpanded(me) === collapse) {
      me.trigger('beforeToggleNode', {
        record,
        collapse
      });
      meta.collapsed = collapse;
      if (meta.collapsed) {
        me.onNodeCollapse(record);
        return true;
      } else {
        me.onNodeExpand(record);
        let success = true;
        // Children not yet loaded, ask store for them.
        // It will append them. Appending to a node which
        // is expanded will insert the children into the UI.
        if (!record.isLoaded) {
          meta.isLoadingChildren = true;
          try {
            await me.loadChildren(record);
          } catch (exception) {
            // Revert to being collapsed
            meta.collapsed = true;
            success = false;
            me.trigger('loadChildrenException', {
              record,
              exception
            });
          } finally {
            meta.isLoadingChildren = false;
          }
        }
        return success;
      }
    }
  }
  /**
   * Remove all records beneath parentRecord from storage.
   * @private
   * @param parentRecord Parent record
   * @category Tree
   */
  onNodeCollapse(parentRecord) {
    // We don't care about collapse if it's inside a collapsed subtree
    if (parentRecord.ancestorsExpanded(this)) {
      return this.internalToggleTreeSubRecords(parentRecord, false);
    }
  }
  /**
   * Add all records beneath parentRecord from storage.
   * @private
   * @param parentRecord Parent record
   * @category Tree
   */
  onNodeExpand(parentRecord) {
    // We don't care about expand if it's inside a collapsed subtree
    if (parentRecord.ancestorsExpanded(this)) {
      return this.internalToggleTreeSubRecords(parentRecord, true);
    }
  }
  //endregion
  //region Transform flat data
  /**
   * Transforms flat data containing parent ids into tree data
   * @param {Object[]} data Flat raw data
   * @returns {Object[]} Tree data
   * @private
   */
  transformToTree(data) {
    const {
        parentIdField,
        idField,
        childrenField
      } = this.modelClass,
      indexById = new Map(),
      parentIds = new Set(),
      transformed = [];
    // build an index of all nodes, to avoid quadratic complexity
    for (const node of data) {
      const id = node[idField];
      if (id != null) {
        indexById.set(id, node);
      }
      if (node[parentIdField] != null) {
        parentIds.add(node[parentIdField]);
      }
    }
    // clone the parent, to avoid data mutation
    // https://github.com/bryntum/support/issues/4869
    const cloneParent = node => {
      const clone = Object.assign({}, node);
      clone[childrenField] = [];
      indexById.set(clone.id, clone);
      return clone;
    };
    for (let node of data) {
      // `node` can be both child and parent - need to clone it as soon as possible
      if (parentIds.has(node.id) && !node[childrenField]) {
        node = cloneParent(node);
      }
      const parentId = node[parentIdField];
      // Child, find parent
      if (parentId != null) {
        let parent = indexById.get(parentId);
        // Parent found, add node as child of it
        if (parent) {
          if (!parent[childrenField]) {
            parent = cloneParent(parent);
          }
          parent[childrenField].push(node);
        }
      }
      // parent - clone if needed (might be already cloned) and push to transformed
      else {
        // already cloned, push as is
        if (node[childrenField]) {
          transformed.push(node);
        }
        // not cloned, clone and push
        else if (node[idField] != null) {
          transformed.push(cloneParent(node));
        } else {
          transformed.push(node);
        }
      }
    }
    return transformed;
  }
  /**
   * Transforms data into a tree with parent levels based on supplied fields.
   *
   * ```javascript
   * const newRoot = store.treeify(['name', r => r.age % 10]);
   * ```
   *
   * Generated parent records are indicated with `generatedParent` and `key` properties. The first one is set to
   * `true` and the latter one has a value for the group the parent represents.
   *
   * @param {Array<String|Function>} fields The field names, or a function to call to extract a value to create parent
   * nodes for records with the same value.
   * @param {Function} [parentTransform] A function which is called to allow the caller to transform the raw data
   * object of any newly created parent nodes.
   * @param {Boolean} [convertParents] Pass `true` to convert raw new parent data objects to this Store's
   * {@link Core.data.Store#config-modelClass}.
   * @returns {Core.data.Model} New root node
   * @internal
   */
  treeify(fields, parentTransform, convertParents = false) {
    const {
        length
      } = fields,
      parents = [],
      orphans = [],
      newRoot = {};
    let i, lastParent;
    // New branch nodes are ID'd by their field values concatenated into
    // string form.
    //
    // The key value that was used to create them is their "key" property.
    //
    // rootNode : {
    //    children : [{
    //        id       : 'p1',
    //        name     : 'Parent 1',
    //        expanded : true,
    //        children : [
    //            { id : 700, name : 'Task 700', startDate : '2021-11-26', duration : 3, percentDone : 20 },
    //            { id : 500, name : 'Task 500', startDate : '2021-11-22', duration : 5, percentDone : 20 },
    //            { id : 300, name : 'Task 300', startDate : '2021-11-24', duration : 3, percentDone : 10 },
    //            { id : 100, name : 'Task 100', startDate : '2021-11-22', duration : 5, percentDone : 10 }
    //       ]
    //    },
    //    {
    //        id       : 'p2',
    //        name     : 'Parent 2',
    //        expanded : true,
    //        children : [
    //            { id : 600, name : 'Task 600', startDate : '2021-11-22', duration : 6, percentDone : 20 },
    //            { id : 800, name : 'Task 800', startDate : '2021-11-26', duration : 2, percentDone : 20 },
    //            { id : 400, name : 'Task 400', startDate : '2021-11-24', duration : 2, percentDone : 10 },
    //            { id : 200, name : 'Task 200', startDate : '2021-11-22', duration : 6, percentDone : 10 }
    //        ]
    //    }]
    // }
    //
    // Becomes the following. Note that all records are sorted into ascending
    // order of their field values:
    //
    // rootNode : {
    //    children : [{
    //        id       : '10',
    //        key      : 10,
    //        expanded : true,
    //        children : [
    //            {
    //                id       : '10Mon Nov 22 2021 00:00:00 GMT+0100 (Central European Standard Time)',
    //                key      : new Date(2021, 10, 22),
    //                expanded : true,
    //                children : [
    //                    { id : 100, name : 'Task 100', startDate : '2021-11-22', duration : 5, percentDone : 10 },
    //                    { id : 200, name : 'Task 200', startDate : '2021-11-22', duration : 6, percentDone : 10 }
    //                ]
    //            },
    //            {
    //                id       : '10Wed Nov 24 2021 00:00:00 GMT+0100 (Central European Standard Time)',
    //                key      : new Date(2021, 10, 24),
    //                expanded : true,
    //                children : [
    //                    { id : 300, name : 'Task 300', startDate : '2021-11-24', duration : 3, percentDone : 10 },
    //                    { id : 400, name : 'Task 400', startDate : '2021-11-24', duration : 2, percentDone : 10 }
    //                ]
    //            }
    //        ]
    //    },
    //    {
    //        id       : '20',
    //        key      : 20,
    //        expanded : true,
    //        children : [
    //            {
    //                id       : '20Mon Nov 22 2021 00:00:00 GMT+0100 (Central European Standard Time)',
    //                key      : new Date(2021, 10, 22),
    //                expanded : true,
    //                children : [
    //                    { id : 500, name : 'Task 500', startDate : '2021-11-22', duration : 5, percentDone : 20 },
    //                    { id : 600, name : 'Task 600', startDate : '2021-11-22', duration : 6, percentDone : 20 }
    //                ]
    //            },
    //            {
    //                id       : '20Fri Nov 26 2021 00:00:00 GMT+0100 (Central European Standard Time)',
    //                key      : new Date(2021, 10, 26),
    //                expanded : true,
    //                children : [
    //                    { id : 700, name : 'Task 700', startDate : '2021-11-26', duration : 3, percentDone : 20 },
    //                    { id : 800, name : 'Task 800', startDate : '2021-11-26', duration : 2, percentDone : 20 }
    //                ]
    //            }
    //        ]
    //    }]
    // }
    //
    // Convert field definitions to a function which extracts the field]
    // for a simpler field value extraction.
    for (i = 0; i < length; i++) {
      let field = fields[i];
      field = field.field || field;
      if (!fields[i].call) {
        fields[i] = n => n[field];
        fields[i].fieldName = field;
      }
      parents[i] = new Map();
    }
    this.rootNode.traverse(n => {
      lastParent = null;
      if (n.isLeaf) {
        for (i = 0; i < length; i++) {
          var _lastParent;
          const lastParentPath = ((_lastParent = lastParent) === null || _lastParent === void 0 ? void 0 : _lastParent.path) || '',
            nodeMap = parents[i],
            key = fields[i](n);
          // Break if level function has requested to skip further groups building for this record
          if (key === StopBranch) {
            break;
          }
          const path = `${lastParentPath + (key !== null && key !== void 0 && key.isModel ? key.id : key)}/`,
            id = StringHelper.makeValidDomId(`generated_${path}`, '_'),
            field = fields[i].fieldName,
            parent = nodeMap.get(id) || nodeMap.set(id, {
              id,
              key,
              path,
              expanded: true,
              readOnly: true,
              children: [],
              generatedParent: true,
              field,
              firstGroupChild: n
            }).get(id);
          if (lastParent && !lastParent.children.includes(parent)) {
            lastParent.children.push(parent);
          }
          lastParent = parent;
        }
        if (lastParent) {
          lastParent.children.push(n);
        } else {
          orphans.push(n);
        }
      }
    }, true);
    // Call the optional transformer, and if we are configured to do so,
    // convert the new branches into TreeNodes.
    if (parentTransform || convertParents) {
      parents.forEach(p => p.forEach((p, id, map) => {
        parentTransform === null || parentTransform === void 0 ? void 0 : parentTransform(p);
        if (convertParents) {
          p = this.createRecord(p);
          map.set(id, p);
        }
      }));
    }
    newRoot.children = [...parents[0].values(), ...orphans];
    // Cascade a sort down so that all "groups" are in order.
    const sort = n => {
      if (n.children) {
        n.children.sort((lhs, rhs) => {
          // If both records are either groups or leaves
          if (lhs.isLeaf === rhs.isLeaf) {
            // If it's a leaf, sort by comparing all "fields"
            if (lhs.isLeaf) {
              let result;
              for (let i = 0; !result && i < length; i++) {
                const lv = fields[i](lhs),
                  rv = fields[i](rhs);
                // If a grouping callback returned StopBranch symbol
                if (lv === StopBranch || rv === StopBranch) {
                  return lhs.isLeaf < rhs.isLeaf ? -1 : lhs.isLeaf > rhs.isLeaf ? 1 : 0;
                }
                result = lv < rv ? -1 : rv > lv ? 1 : 0;
              }
              return result;
            }
            // Sort branch nodes by their key values
            // Sort numbers in strings nicely
            else if (typeof lhs.key === 'string' && typeof rhs.key === 'string') {
              return lhs.key.localeCompare(rhs.key, undefined, {
                numeric: true
              });
            } else {
              return lhs.key < rhs.key ? -1 : lhs.key > rhs.key ? 1 : 0;
            }
          } else {
            return lhs.isLeaf < rhs.isLeaf ? -1 : lhs.isLeaf > rhs.isLeaf ? 1 : 0;
          }
        });
        n.children.forEach(sort);
      }
    };
    sort(newRoot);
    return newRoot;
  }
  //endregion
  treeifyFlatData(data) {
    const {
      childrenField,
      parentIdField
    } = this.modelClass;
    let hasParentId = false,
      shouldTransform = true;
    // Configured to transform flat data into tree data, make sure that we have:
    // - raw data without children defined
    // - parentIds
    for (const node of data) {
      if (node.isModel || Array.isArray(node[childrenField])) {
        shouldTransform = false;
        break;
      }
      if (node[parentIdField] != null) {
        hasParentId = true;
      }
    }
    if (shouldTransform && hasParentId) {
      data = this.transformToTree(data);
    }
    return data;
  }
  /**
   * Increase the indentation level of one or more nodes in the tree
   * @param {Core.data.Model|Core.data.Model[]} nodes The nodes to indent.
   * @fires indent
   * @fires change
   * @category Tree
   */
  async indent(nodes) {
    const me = this;
    nodes = Array.isArray(nodes) ? nodes : [nodes];
    // 2. Filtering out all nodes which parents are also to be indented as well as the ones having no previous
    //    sibling since such nodes can't be indented
    nodes = nodes.filter(node => {
      let result = Boolean(node.previousSibling);
      while (result && !node.isRoot) {
        result = !nodes.includes(node.parent);
        node = node.parent;
      }
      return result;
    });
    /**
     * Fired before nodes in the tree are indented. Return `false` from a listener to prevent the indent.
     * @event beforeIndent
     * @preventable
     * @param {Core.data.Store} source The store
     * @param {Core.data.Model|Core.data.Model[]} nodes The nodes to indent.
     */
    if (nodes.length && me.trigger('beforeIndent', {
      records: nodes
    }) !== false) {
      // 3. Sorting nodes into tree walk order
      nodes.sort((lhs, rhs) => Wbs.compare(lhs.wbsCode, rhs.wbsCode));
      // No events should go to the UI until we have finished the operation successfully
      me.beginBatch();
      // Ask the project to try the indent operation
      for (const node of nodes) {
        const newParent = node.previousSibling;
        newParent.appendChild(node);
        me.toggleCollapse(newParent, false);
      }
      // Now show the successful result
      me.endBatch();
      /**
       * Fired after tasks in the tree are indented
       * @event indent
       * @param {Core.data.Store} source The store
       * @param {Core.data.Model[]} records Nodes that were indented
       */
      me.trigger('indent', {
        records: nodes
      });
      me.trigger('change', {
        action: 'indent',
        records: nodes
      });
    }
  }
  /**
   * Decrease the indentation level of one or more nodes in the tree
   * @param {Core.data.Model|Core.data.Model[]} nodes The nodes to outdent.
   * @fires outdent
   * @fires change
   * @category Tree
   */
  async outdent(nodes) {
    const me = this;
    nodes = Array.isArray(nodes) ? nodes : [nodes];
    // 2. Filtering out all nodes which parents are also to be outdented as well as the ones having no previous sibling
    //    since such nodes can't be indented
    nodes = nodes.filter(node => {
      const {
        parent
      } = node;
      let result = parent && !parent.isRoot;
      while (result && !node.isRoot) {
        result = !nodes.includes(parent);
        node = node.parent;
      }
      return result;
    });
    /**
     * Fired before nodes in the tree are outdented. Return `false` from a listener to prevent the outdent.
     * @event beforeOutdent
     * @preventable
     * @param {Core.data.Store} source This store
     * @param {Core.data.Model[]} records Nodes to be outdented
     */
    if (nodes.length && me.trigger('beforeOutdent', {
      records: nodes
    }) !== false) {
      // 3. Sorting nodes into reverse tree walk order
      nodes.sort((lhs, rhs) => Wbs.compare(lhs.wbsCode, rhs.wbsCode));
      // No events should go to the UI until we have finished the operation successfully
      me.beginBatch();
      for (const node of nodes) {
        const {
            parent
          } = node,
          newChildren = parent.children.slice(parent.children.indexOf(node) + 1);
        parent.parent.insertChild(node, parent.nextSibling);
        node.appendChild(newChildren);
        me.toggleCollapse(node, false);
      }
      me.endBatch();
      /**
       * Fired after tasks in the tree are outdented
       * @event outdent
       * @param {Core.data.Store} source The store
       * @param {Core.data.Model[]} records Nodes that were outdented
       */
      me.trigger('outdent', {
        records: nodes
      });
      me.trigger('change', {
        action: 'outdent',
        records: nodes
      });
    }
  }
});

/**
 * @module Core/helper/WalkHelper
 */
/**
 * Tree walking helper
 * @internal
 */
class WalkHelper {
  /**
   * Pre-walks any hierarchical data structure
   *
   * @param {Object} data Walking starting point
   * @param {Function} childrenFn Function to return `data` children entries in an array
   *                   or null if no children exists for the entry
   * @param {Function} fn Function to call on each entry
   */
  static preWalk(data, childrenFn, fn) {
    const walkStack = [data];
    let node, children;
    while (walkStack.length) {
      node = walkStack.pop();
      fn(node);
      children = childrenFn(node);
      if (children) {
        walkStack.push.apply(walkStack, children.slice().reverse());
      }
    }
  }
  /**
   * Pre-walks any hierarchical data structure, passing along a link to the parent node
   *
   * @param {Object} data Walking starting point
   * @param {Function} childrenFn Function to return `data` children entries in an array
   *                   or null if no children exists for the entry
   * @param {Function} fn Function to call on each entry, called with `parent` and `node`
   */
  static preWalkWithParent(data, childrenFn, fn) {
    const walkStack = [{
      node: data,
      parent: null
    }];
    while (walkStack.length) {
      const {
        parent,
        node
      } = walkStack.pop();
      fn(parent, node);
      const children = childrenFn(node);
      if (Array.isArray(children)) {
        walkStack.push(...children.slice().reverse().map(child => ({
          node: child,
          parent: node
        })));
      }
    }
  }
  /**
   * Pre-walk unordered.
   *
   * Like {@link #function-preWalk-static} but doesn't reverse children before walk,
   * thus children will be walked last child first - first child last
   *
   * @param {Object} data Walking starting point
   * @param {Function} childrenFn Function to return `data` children entries in an array
   *                   or null if no children exists for the entry
   * @param {Function} fn Function to call on each entry
   */
  static preWalkUnordered(data, childrenFn, fn) {
    const walkStack = [data];
    let node, children;
    while (walkStack.length) {
      node = walkStack[walkStack.length - 1];
      fn(node);
      children = childrenFn(node);
      if (children) {
        walkStack.splice(walkStack.length - 1, 1, ...children);
      } else {
        walkStack.length = walkStack.length - 1;
      }
    }
  }
  /**
   * Post-walks any hierarchical data structure
   *
   * @param {Object} data Walking starting point
   * @param {Function} childrenFn Function to return `data` children entries in an array
   *                   or null if no children exists for the entry
   * @param {Function} fn Function to call on each entry
   */
  static postWalk(data, childrenFn, fn) {
    const visited = new Map(),
      walkStack = [data];
    let node, children;
    while (walkStack.length) {
      node = walkStack[walkStack.length - 1];
      if (visited.has(node)) {
        fn(node);
        walkStack.pop();
      } else {
        children = childrenFn(node);
        if (children) {
          walkStack.push(...children.slice().reverse());
        }
        visited.set(node, node);
      }
    }
  }
  /**
   * Pre-/Post-walks any hierarchical data structure calling inFn each node when it walks in,
   * and outFn when it walks out.
   *
   * @param {Object} data Walking starting point
   * @param {Function} childrenFn Function to return `data` children entries in an array
   *                   or null if no children exists for the entry
   * @param {Function} inFn  Function to call on each entry upon enter
   * @param {Function} outFn Function to call on each entry upon exit
   */
  static prePostWalk(data, childrenFn, inFn, outFn) {
    const visited = new Map(),
      walkStack = [data];
    let node, children;
    while (walkStack.length) {
      node = walkStack[walkStack.length - 1];
      if (visited.has(node)) {
        outFn(node);
        walkStack.pop();
      } else {
        inFn(node);
        children = childrenFn(node);
        if (children) {
          walkStack.push(...children.slice().reverse());
        }
        visited.set(node, node);
      }
    }
  }
}
WalkHelper._$name = 'WalkHelper';

/**
 * @module Core/data/mixin/StoreSync
 */
/**
 * Options available when supplying a config object to the `syncDataOnLoad` config.
 * @typedef {Object} SyncDataOnLoadOptions
 * @property {Boolean} [keepMissingValues] How to handle values for missing fields, see
 * {@link Core/data/Store#config-syncDataOnLoad}
 * @property {String|Number} [threshold] Threshold above which events are batched, see
 * {@link Core/data/Store#config-syncDataOnLoad}
 */
/**
 * Mixin that allows Store to sync a new dataset with its existing records, instead of fully replacing everything.
 * Configure Store with `syncDataOnLoad: true` to activate the functionality. Sync is performed when a new dataset
 * is loaded, either by directly assigning it to `store.data` or by loading it using Ajax (if using an AjaxStore).
 *
 * ```javascript
 * const store = new Store({
 *   syncDataOnLoad : true,
 *   data           : [
 *     { id : 1, name : 'Saitama' },
 *     { id : 2, name : 'Genos' },
 *     { id : 3, name : 'Mumen Rider' }
 *   ]
 * });
 *
 * // Sync a new dataset by assigning to data:
 * store.data = [
 *   { id : 1, name : 'Caped Baldy' },
 *   { id : 4, name : 'Horse-Bone' }
 * ];
 *
 *  // Result : Record 1 updated, record 2 & 3 removed, record 4 added
 * ```
 *
 * For more details, please see {@link #config-syncDataOnLoad}.
 *
 * @mixin
 */
var StoreSync = (Target => class StoreSync extends (Target || Base) {
  static get $name() {
    return 'StoreSync';
  }
  static get configurable() {
    return {
      /**
       * Configure with `true` to sync loaded data instead of replacing existing with a new dataset.
       *
       * By default (or when configured with `false`) assigning to `store.data` replaces the entire dataset
       * with a new one, creating all new records:
       *
       * ```javascript
       * store.data = [ { id : 1, name : 'Saitama' } ];
       *
       * const first = store.first;
       *
       * store.data = [ { id : 1, name : 'One-Punch man' } ];
       *
       * // store.first !== first;
       * ```
       *
       * When configured with `true` the new dataset is instead synced against the old, figuring out what was
       * added, removed and updated:
       *
       * ```javascript
       * store.data = [ { id : 1, name : 'Saitama' } ];
       *
       * const first = store.first;
       *
       * store.data = [ { id : 1, name : 'One-Punch man' } ];
       *
       * // store.first === first;
       * ```
       *
       * After the sync, any configured sorters, groupers and filters will be reapplied.
       *
       * #### Threshold
       *
       * The sync operation has a configurable threshold, above which the operation will be treated as a
       * batch/refresh and only trigger a single `refresh` event. If threshold is not reached, individual events
       * will be triggered (single `add`, `remove` and possible multiple `update`). To enable the threshold,
       * supply a config object with a `threshold` property instead of `true`:
       *
       * ```javascript
       * const store = new Store({
       *     syncDataOnLoad : {
       *         threshold : '20%'
       *     }
       * });
       * ```
       *
       * `threshold` accepts numbers or strings. A numeric threshold means number of affected records, while a
       * string is used as a percentage of the whole dataset (appending `%` is optional). By default no threshold
       * is used.
       *
       * #### Missing fields
       *
       * The value of any field not supplied in the new dataset is by default kept as is (if record is not removed
       * by the sync). This behaviour is configurable, by setting `keepMissingValues : false` in a config object
       * it will reset any unspecified field back to their default values:
       *
       * ```javascript
       * const store = new Store({
       *     syncDataOnLoad : {
       *         keepMissingValues : false
       *     }
       * });
       * ```
       *
       * Considering the following sync operation:
       *
       * ```javascript
       * // Existing data
       * { id : 1, name : 'Saitama', powerLevel : 100 }
       * // Sync data
       * { id : 1, name : 'One-Punch Man' }
       * ```
       *
       * The result would by default (or when explicitly configured with `true`)  be:
       *
       * ```javascript
       * { id : 1, name : 'One-Punch Man', powerLevel : 100 }
       * ```
       *
       * If configured with `keepMissingValues : false` it would instead be:
       *
       * ```javascript
       * { id : 1, name : 'One-Punch Man' }
       * ```
       *
       * <div class="note">Never enable `syncDataOnLoad` on a chained store, it will create an infinite loop when
       * it is populated from the main store (the main store can use the setting)</div>
       *
       * @config {Boolean|SyncDataOnLoadOptions} syncDataOnLoad
       * @default false
       * @category Common
       */
      syncDataOnLoad: null,
      shouldSyncDataset: null,
      shouldSyncRecord: null
    };
  }
  /**
   * Syncs a new dataset against the already loaded one, only applying changes.
   * Not intended to be called directly, please configure store with `syncDataOnLoad: true` and assign to
   * `store.data` as usual instead.
   *
   * ```
   * const store = new Store({
   *    syncDataOnLoad : true,
   *    data : [
   *        // initial data
   *    ]
   * });
   *
   * store.data = [ // new data ]; //  Difference between initial data and new data will be applied
   * ```
   *
   * @param {Object[]|Core.data.Model[]} data New dataset, an array of records or data objects
   * @private
   */
  syncDataset(data) {
    var _me$shouldSyncDataset;
    const me = this,
      {
        storage
      } = me,
      // Allow app to determine if sync should be performed, and/or for which records. It might have better
      // knowledge of the data to make a cheaper decision
      idsToCheck = (_me$shouldSyncDataset = me.shouldSyncDataset) === null || _me$shouldSyncDataset === void 0 ? void 0 : _me$shouldSyncDataset.call(me, {
        data
      });
    if (idsToCheck === false) {
      return;
    }
    me.isSyncingDataOnLoad = true;
    const {
      toAdd,
      toRemove,
      toMove,
      updated,
      ids
    } = me.tree ? me.syncTreeDataset(data, idsToCheck) : me.syncFlatDataset(data, idsToCheck);
    let {
        threshold
      } = me.syncDataOnLoad,
      surpassed = false;
    // Check if threshold is surpassed
    if (threshold) {
      // Any string is treated as a percentage
      if (typeof threshold === 'string') {
        threshold = parseInt(threshold, 10) / 100 * me.count;
      }
      surpassed = toAdd.length + toRemove.length + toMove.length + updated.length > threshold;
    }
    if (me.tree) {
      // Flat data is spliced into/out of the collection, but in a tree it has to be added/removed from store
      // to end up on correct parents
      if (toAdd.length) {
        // Add all new nodes in one go, will be added to correct parent using `parentId`. Triggering multiple times
        const added = me.add(toAdd, surpassed);
        // parentId was tucked on in syncTreeDataset() to allow the single flat add above, clean it out
        added.forEach(node => node.clearParentId());
      }
      if (toMove.length) {
        for (const {
          parent,
          node,
          index
        } of toMove) {
          const newParent = me.getById(parent.id);
          newParent.insertChild(node, index);
        }
      }
      // Remove in one go, removing from each parent. Triggering multiple times
      me.remove(toRemove, surpassed);
    } else {
      if (surpassed) {
        me.suspendEvents();
      }
      // Add and remove, will trigger if below threshold/no threshold
      // We cannot simply splice into our Collection because of the extra
      // processing various Store mixins do in add and remove implementations
      me.remove(toRemove);
      me.add(toAdd);
      if (surpassed) {
        me.resumeEvents();
      }
    }
    // Trigger updates if using threshold, but have not surpassed it. If threshold is not used, the updates
    // are triggered when data is set (avoiding another iteration)
    if (threshold && !surpassed) {
      updated.forEach(({
        record,
        toSet,
        wasSet
      }) => me.onModelChange(record, toSet, wasSet));
    }
    // Clear change-tracking
    me.acceptChanges();
    const event = {
      added: toAdd,
      removed: toRemove,
      updated,
      thresholdSurpassed: surpassed
    };
    if (me.isFiltered && !me.remoteFilter) {
      // Apply filtering to the next dataset if filtering is local
      me.filter({
        silent: me.isRemoteDataLoading
      });
    }
    if (me.isGrouped) {
      // Announced group
      me.group(null, null, false, true, me.isRemoteDataLoading);
    } else if (me.isSorted) {
      // If we updated records in-place, the order may not match what we sent to
      // the server, so silently sort the collection according to our sorters.
      if (me.remoteSort) {
        storage.replaceValues({
          values: storage.values.sort(me.createSorterFn(me.sorters)),
          silent: true
        });
      }
      // If we are sorting locally, just do a normal sort
      else {
        me.sort();
      }
    }
    // Neither grouped nor sorted, match order in incoming data
    else if (!me.tree) {
      // Only bother if data isn't already in order (to avoid unnecessary re-rendering)
      if (storage.values.some((record, index) => record.id !== ids[index])) {
        storage.replaceValues({
          values: storage.values.sort((a, b) => ids.indexOf(a.id) - ids.indexOf(b.id)),
          silent: true
        });
        // Announce the sort, unless we will refresh below
        !surpassed && me.afterPerformSort();
      }
    }
    // Ditto, but not flat data
    else {
      let unsorted = false,
        i = 0;
      WalkHelper.preWalk(me.rootNode, n => Array.isArray(n.children) && !unsorted ? n.children : null, node => {
        if (node.id !== ids[i++]) {
          unsorted = true;
        }
      });
      // Only bother if data isn't already in order (to avoid unnecessary re-rendering)
      if (unsorted) {
        me.sort((a, b) => ids.indexOf(a.id) - ids.indexOf(b.id), undefined, undefined, true);
        me.clearSorters(true);
        // Announce the sort, unless we will refresh below
        !surpassed && me.afterPerformSort();
      }
    }
    // Trigger `batch` if threshold is surpassed, more similar to a batch than a full `dataset`
    if (surpassed) {
      me.trigger('refresh', {
        action: 'batch',
        data,
        records: storage.values,
        syncInfo: event
      });
    }
    me.isSyncingDataOnLoad = false;
    me.trigger('loadSync', event);
  }
  // Used by syncDataset()
  syncFlatDataset(data, idsToCheck) {
    if (!data) {
      return {
        toRemove: this.records
      };
    }
    const me = this,
      {
        idField,
        allFields
      } = me.modelClass,
      toRemove = [],
      toAdd = [],
      updated = [],
      usedIds = {},
      ids = [],
      limitedSet = Array.isArray(idsToCheck);
    const {
      threshold,
      keepMissingValues
    } = me.syncDataOnLoad;
    let hitCount = 0;
    data.forEach(rawData => {
      rawData = rawData.isModel ? rawData.data : rawData;
      const id = rawData[idField],
        record = me.getById(id);
      // Only bother checking for changes if not passed a specific set of ids to check, or if the id is in the set
      if (!limitedSet || idsToCheck.includes(id)) {
        // Record exists, might be an update
        if (record) {
          var _me$shouldSyncRecord;
          // Allow app to determine if sync should be performed, it might have better knowledge of the data to
          // make a cheaper decision
          if (((_me$shouldSyncRecord = me.shouldSyncRecord) === null || _me$shouldSyncRecord === void 0 ? void 0 : _me$shouldSyncRecord.call(me, {
            record,
            data: rawData
          })) !== false) {
            // Apply default value for any missing fields if configured to do so
            if (keepMissingValues === false) {
              for (const field of allFields) {
                if (!(field.dataSource in rawData) && field.dataSource in record.data) {
                  rawData[field.dataSource] = field.defaultValue;
                }
              }
            }
            // Update silently if using threshold, otherwise trigger away
            const wasSet = record.set(rawData, null, Boolean(threshold));
            if (wasSet) {
              updated.push({
                record,
                wasSet,
                toSet: rawData
              });
            }
          }
        }
        // Does not exist, add
        else {
          toAdd.push(me.processRecord(me.createRecord(rawData)));
        }
      }
      if (record) {
        hitCount++;
      }
      usedIds[id] = 1;
      ids.push(id);
    });
    // Check removals, unless all records were visited above
    if (hitCount < me.storage.totalCount) {
      // If given a set of ids that should be checked, limit removals to those. Any id not represented in the new
      // dataset will be removed
      if (idsToCheck) {
        for (const id of idsToCheck) {
          if (!usedIds[id]) {
            toRemove.push(me.getById(id));
          }
        }
      }
      // Otherwise, check all records
      else {
        me.forEach(record => {
          if (!usedIds[record.id]) {
            toRemove.push(record);
          }
        });
      }
    }
    return {
      toAdd,
      toRemove,
      toMove: [],
      updated,
      ids
    };
  }
  // Used by syncDataset()
  syncTreeDataset(data) {
    if (!data) {
      return {
        toRemove: this.records
      };
    }
    const me = this,
      {
        idField,
        parentIdField,
        childrenField,
        allFields
      } = me.modelClass,
      {
        keepMissingValues,
        threshold
      } = me.syncDataOnLoad,
      toRemove = [],
      toAdd = [],
      toMove = [],
      updated = [],
      matchedNodes = new Set(),
      ids = [];
    if (me.transformFlatData) {
      data = me.treeifyFlatData(data);
    }
    WalkHelper.preWalkWithParent({
      isRoot: true,
      id: me.rootNode.id,
      children: data
    }, n => n.children, (parent, rawData) => {
      if (parent) {
        const {
          id,
          node
        } = me.resolveSyncNode(rawData);
        // Record exists, might be an update
        if (node) {
          var _me$shouldSyncRecord2;
          // Allow app to determine if sync should be performed, it might have better knowledge of the data to
          // make a cheaper decision
          if (((_me$shouldSyncRecord2 = me.shouldSyncRecord) === null || _me$shouldSyncRecord2 === void 0 ? void 0 : _me$shouldSyncRecord2.call(me, {
            record: node,
            data: rawData
          })) !== false) {
            let childrenUpdated;
            const oldChildrenValue = node.children;
            // Edge case: Check for conversion from normal parent to lazy loaded
            if (oldChildrenValue !== true && rawData[childrenField] === true) {
              node.clearChildren();
              node.data[childrenField] = node.children = true;
              delete rawData[childrenField];
              me.toggleCollapse(node, true);
              childrenUpdated = true;
            }
            // Changed parent?
            if (node.parent.id !== parent[idField]) {
              toMove.push({
                node,
                parent,
                index: parent[childrenField].indexOf(rawData)
              });
            }
            // parentIdField has no default value to not pollute flat data,
            // assign to root here if no value specified
            // else if (parent.isRoot && !(parentIdField in rawData)) {
            //     rawData[parentIdField] = null;
            // }
            // Apply default value for any missing fields if configured to do so
            if (keepMissingValues === false) {
              for (const field of allFields) {
                // Ignore parentId, handled above since it has no default
                if (field.name !== 'parentId' && !(field.dataSource in rawData) && field.dataSource in node.data) {
                  rawData[field.dataSource] = field.defaultValue;
                }
              }
            }
            // Update silently if using threshold, otherwise trigger away
            const wasSet = node.set(rawData, null, Boolean(threshold));
            if (wasSet) {
              updated.push({
                record: node,
                wasSet,
                toSet: rawData
              });
            } else if (childrenUpdated) {
              node.signalNodeChanged({
                [childrenField]: {
                  value: true,
                  oldValue: oldChildrenValue
                }
              });
            }
          }
        }
        // Does not exist, add
        else {
          rawData[parentIdField] = parent[idField];
          toAdd.push({
            ...rawData,
            ...(Array.isArray(rawData[childrenField]) ? {
              children: []
            } : undefined)
          });
        }
        matchedNodes.add(node);
        ids.push(id);
      }
    });
    if (matchedNodes.length !== data.length) {
      me.traverse(node => {
        if (!matchedNodes.has(node)) {
          toRemove.push(node);
        }
      });
    }
    return {
      toAdd,
      toRemove,
      toMove,
      updated,
      ids
    };
  }
  // ColumnStore overrides this fn to allow syncing by field & type
  resolveSyncNode(rawData) {
    const id = rawData[this.modelClass.idField],
      node = this.getById(id);
    return {
      id,
      node
    };
  }
});

/**
 * @module Core/data/stm/mixin/StoreStm
 */
const STM_PROP = Symbol('STM_PROP');
/**
 * Store mixin to make it compatible with {@link Core/data/stm/StateTrackingManager}.
 * @mixin
 */
var StoreStm = (Target => class StoreStm extends (Target || Base) {
  static get $name() {
    return 'StoreStm';
  }
  static get defaultConfig() {
    return {
      /**
       * Reference to STM manager
       *
       * @config {Core.data.stm.StateTrackingManager}
       * @default
       * @category Advanced
       */
      stm: null,
      /**
       * Set to `false` to not record transaction during `applyChangeset` call
       *
       * @prp {Boolean}
       * @default
       * @category Advanced
       */
      ignoreRemoteChangesInSTM: false
    };
  }
  get stm() {
    return this[STM_PROP];
  }
  set stm(stm) {
    const me = this;
    if (me.stm !== stm) {
      var _me$stm;
      if ((_me$stm = me.stm) !== null && _me$stm !== void 0 && _me$stm.hasStore(me)) {
        me.stm.removeStore(me);
      }
      me[STM_PROP] = stm;
      if (me.stm && !me.stm.hasStore(me)) {
        me.stm.addStore(me);
      }
    }
  }
  // Overridden to notify STM about flat add action
  add(records, silent = false, options = {}) {
    let result;
    const {
      stm
    } = this;
    // Tree adding is routed via rootNode.appendChild() it has it's own
    // STM override thus if the store is tree we ignore the action
    if (!this.tree && stm !== null && stm !== void 0 && stm.enabled) {
      var _result;
      // Flat adding here only, the only data needed to undo/redo the action
      // is the list of records added.
      result = super.add(records, silent);
      // If adding wasn't vetoed and something has been added then
      // notifying the STM about the fact.
      if ((_result = result) !== null && _result !== void 0 && _result.length) {
        stm.onStoreModelAdd(this, result, silent);
      }
    } else {
      result = super.add(records, silent, options);
    }
    return result;
  }
  // Overridden to notify STM about flat insert action
  insert(index, records, silent = false) {
    let result;
    const {
      stm
    } = this;
    // Tree inserting is routed via rootNode.insertChild() it has it's own
    // STM override thus if the store is tree we ignore the action
    if (!this.tree && stm !== null && stm !== void 0 && stm.enabled) {
      var _result2;
      // Flat inserting here only, the only data needed to undo/redo the action is:
      // - the list of record inserted
      // - index they are inserted at
      // - index they have been at if they are part of this store already and are moved
      // Here we are getting indices of records which are in this store already
      // not all records might be from this store, some might be new or from another store
      const context = (Array.isArray(records) ? records : [records]).reduce((context, r) => {
        const index = r instanceof Model ? this.indexOf(r) : undefined;
        if (index !== undefined && index !== -1) {
          context.set(r, index);
        }
        return context;
      }, new Map());
      // Result here is the array of Models inserted or undefined,
      // and it might be different from `records` we received as argument.
      result = super.insert(index, records);
      // Here we check if anything has been actually inserted.
      // The insertion action might be vetoed by event handler or something
      if ((_result2 = result) !== null && _result2 !== void 0 && _result2.length) {
        // We can't rely on `index` we've got as argument since `result` might
        // differ from records.
        index = this.indexOf(result[0]);
        // Notifying STM manager about the insertion action providing all
        // the required data to undo/redo.
        stm.onStoreModelInsert(this, index, result, context, silent);
      }
    } else {
      result = super.insert(index, records, silent);
    }
    return result;
  }
  // Overridden to notify STM about flat removing action
  remove(recordsOrIds, silent = false, fromRemoveChild) {
    let result;
    const {
      stm
    } = this;
    // Tree removing is routed via rootNode.removeChild() it has it's own
    // STM override thus if the store is tree we ignore the action
    if (!this.tree && stm !== null && stm !== void 0 && stm.enabled) {
      var _result3;
      // Flat removing here only, the only date needed to undo/redo the actions is:
      // - the list of records removed
      // - their original index to re-insert them back correctly
      const recordsOrIdsNormalized = (Array.isArray(recordsOrIds) ? recordsOrIds : [recordsOrIds]).map(r => this.getById(r)).filter(r => !!r);
      const context = recordsOrIdsNormalized.reduce((context, r) => {
        const index = this.indexOf(r);
        if (index !== undefined && index !== -1) {
          context.set(r, index);
        }
        return context;
      }, new Map());
      // Calling original store method
      result = super.remove(recordsOrIds, silent, fromRemoveChild);
      // Here we check if anything has been actually removed.
      // The removing action might be vetoed by event handler or something
      if ((_result3 = result) !== null && _result3 !== void 0 && _result3.length) {
        stm.onStoreModelRemove(this, result, context, silent);
      }
    } else {
      result = super.remove(recordsOrIds, silent, fromRemoveChild);
    }
    return result;
  }
  // Overridden to notify STM about flat clear action
  removeAll(silent) {
    const {
      stm
    } = this;
    let result;
    if (stm !== null && stm !== void 0 && stm.enabled) {
      // Here we are to detect if anything has been removed
      // the only way is to check if store has anything before removing all
      // and has nothing after.
      const {
          tree,
          rootNode,
          allRecords
        } = this,
        wasNotEmpty = allRecords.length,
        // need to store children/records before super method call, otherwise those would report empty list
        records = tree ? rootNode.children.slice() : allRecords.slice();
      result = super.removeAll(silent);
      // The trick here is to distinguish tree and flat case
      // For the flat case it's simple we just store all records
      // For the tree we are to store root node children only
      // Upon restoring store.add() will do the right thing for the flat case and tree case regardless.
      if (wasNotEmpty && this.count === 0) {
        stm.onStoreRemoveAll(this, records, silent);
      }
    } else {
      result = super.removeAll(silent);
    }
    return result;
  }
  beforeApplyChangeset() {
    const {
      stm,
      crudManager
    } = this;
    let shouldResume = false,
      transactionId = null;
    if (!(crudManager !== null && crudManager !== void 0 && crudManager.applyingChangeset) && stm !== null && stm !== void 0 && stm.enabled) {
      shouldResume = true;
      // If stm is recording at the moment, we need to stash changes and reject them
      if (stm.isRecording) {
        transactionId = stm.stash();
      }
      if (this.ignoreRemoteChangesInSTM) {
        stm.disable();
      } else {
        stm.startTransaction();
      }
    }
    return {
      shouldResume,
      transactionId
    };
  }
  // When applying changes while STM is in the recording state, first we need to discard local changes, then apply
  // changes from remote, then try to apply local changes. This would emulate starting transaction as if data was
  // already in the correct state
  applyChangeset(changes, transformFn, phantomIdField, remote, logChanges) {
    const {
        shouldResume,
        transactionId
      } = this.beforeApplyChangeset(),
      log = super.applyChangeset(changes, transformFn, phantomIdField, remote, logChanges);
    this.afterApplyChangeset(shouldResume, transactionId);
    return log;
  }
  afterApplyChangeset(shouldResume, transactionId) {
    if (shouldResume) {
      const {
        stm
      } = this;
      if (this.ignoreRemoteChangesInSTM) {
        stm.enable();
      } else {
        stm.stopTransaction();
      }
      stm.applyStash(transactionId);
    }
  }
});

/**
 * @module Core/data/Store
 */
const dataAddRemoveActions = {
    splice: 1,
    clear: 1
  },
  defaultTraverseOptions = {
    includeFilteredOutRecords: false,
    includeCollapsedGroupRecords: false
  },
  fixTraverseOptions = (store, options) => {
    // backward compatibility to support includeFilteredOutRecords parameter instead of options
    options = options || false;
    if (typeof options === 'boolean') {
      options = {
        includeFilteredOutRecords: options,
        includeCollapsedGroupRecords: false
      };
    }
    return options || defaultTraverseOptions;
  };
/**
 * The Store represents a data container which holds flat data or tree structures. An item in the Store is often called
 * a record and it is simply an instance of the {@link Core.data.Model} (or any subclass thereof).
 *
 * Typically you load data into a store to display it in a Grid or a ComboBox. The Store is the backing data component
 * for any component that is showing data in a list style UI.
 *
 * ## Data format
 * Data is store in a JSON array the Store offers an API to edit, filter, group and sort the records.
 *
 * ## Store with flat data
 * To create a flat store simply provide an array of objects that describe your records
 *
 * ```javascript
 * const store = new Store({
 *     data : [
 *         { id : 1, name : 'ABBA', country : 'Sweden' },
 *         { id : 2, name : 'Beatles', country : 'UK' }
 *     ]
 * });
 *
 * // retrieve record by id
 * const beatles = store.getById(2);
 * ```
 *
 * ## Store with tree data
 * To create a tree store use `children` property for descendant records
 *
 * ```javascript
 * const store = new Store({
 *     tree: true,
 *     data : [
 *         { id : 1, name : 'ABBA', country : 'Sweden', children: [
 *             { id: 2, name: 'Agnetha' },
 *             { id: 3, name: 'Bjorn' },
 *             { id: 4, name: 'Benny' },
 *             { id: 5, name: 'Anni-Frid' }
 *         ]},
 *     ]
 * });
 *
 * // retrieve record by id
 * let benny = store.getById(4);
 * ```
 *
 * Optionally a tree store can consume a flat dataset with nodes that have a `parentId` property. By configuring the
 * store with `tree : true` and `transformFlatData : true`, the flat data is transformed into tree data:
 *
 * ```javascript
 * const store = new Store({
 *     tree              : true,
 *     transformFlatData : true,
 *     data              : [
 *         { id : 1, name : 'ABBA', country : 'Sweden' },
 *         { id : 2, name : 'Agnetha', parentId : 1 },
 *         { id : 3, name : 'Bjorn', parentId : 1 },
 *         { id : 4, name : 'Benny', parentId : 1 },
 *         { id : 5, name : 'Anni-Frid', parentId : 1 }
 *     ]
 * });
 * ```
 *
 * ### Retrieving and consuming JSON
 * For both flat stores or tree stores it is possible to retrieve the data of all records in JSON format:
 *
 * ```javascript
 * const jsonString = store.json;
 *
 * // or
 *
 * const jsonArray = store.toJSON();
 * ```
 *
 * To plug the JSON data back in later:
 *
 * ```javascript
 * store.data = JSON.parse(jsonString);
 *
 * // or
 *
 * store.data = jsonArray;
 * ```
 *
 * ## Sharing stores
 * You cannot directly share a Store between widgets, but the data in a Store can be shared. There are two different
 * approaches depending on your needs, sharing data and chaining stores:
 *
 * ### Shared data
 * To create 2 widgets that share data, you can create 2 separate stores and pass records of the first store as the
 * dataset of the second store.
 *
 * ```javascript
 * let combo1 = new Combo({
 *     appendTo : document.body,
 *     store    : new Store({
 *         data : [
 *             { id : 1, name : 'ABBA', country : 'Sweden' },
 *             { id : 2, name : 'Beatles', country : 'UK' }
 *         ]
 *     }),
 *     valueField   : 'id',
 *     displayField : 'name'
 * });
 *
 * let combo2 = new Combo({
 *     appendTo : document.body,
 *     store    : new Store({
 *         data : combo1.store.records
 *     }),
 *     valueField   : 'id',
 *     displayField : 'name'
 * });
 *
 * combo1.store.first.name = 'foo';
 * combo2.store.first.name; // "foo"
 * ```
 *
 * ### Chained stores
 * Another more powerful option to share data between widgets is to create {@link Core.data.mixin.StoreChained chained}
 * stores. The easiest way to create a chained store is to call {@link #function-chain} function.
 *
 * ```javascript
 * let combo1 = new Combo({
 *     appendTo : document.body,
 *     store    : new Store({
 *         data : [
 *             { id : 1, name : 'ABBA', country : 'Sweden' },
 *             { id : 2, name : 'Beatles', country : 'UK' }
 *         ]
 *     }),
 *     valueField   : 'id',
 *     displayField : 'name'
 * });
 *
 * let combo2 = new Combo({
 *     appendTo     : document.body,
 *     store        : combo1.store.chain(),
 *     valueField   : 'id',
 *     displayField : 'name'
 * });
 *
 * combo1.store.first.name = 'foo';
 * combo2.store.first.name; // "foo"
 * ```
 *
 * A chained store can optionally be created with a filtering function, to only contain a subset of the records from
 * the main store. In addition, the chained store will reflect record removals/additions to the master store, something
 * the shared data approach will not.
 *
 * ## Non-homogeneous data structures
 *
 * You can use different Model classes to represent the records in the store by overriding the {@link #function-createRecord}
 * method:
 *
 * ```javascript
 * const store = new Store ({
 *     modelClass : Gate,
 *     readUrl    : 'data/the-airport.json',
 *     autoLoad   : true,
 *     // The default model is a Gate (see above) and in this createRecord method, we can decide at runtime based
 *     // on the data which model class to use. This is useful when your record types aren't homogenous.
 *     createRecord(data) {
 *         let modelClass = this.modelClass;
 *         if (data.type === 'terminal') {
 *             modelClass = Terminal;
 *         }
 *         return new modelClass(data, this);
 *     }
 * },
 * ```
 *
 * @mixes Core/mixin/Events
 * @mixes Core/data/mixin/StoreFilter
 * @mixes Core/data/mixin/StoreChanges
 * @mixes Core/data/mixin/StoreCRUD
 * @mixes Core/data/mixin/StoreSum
 * @mixes Core/data/mixin/StoreSearch
 * @mixes Core/data/mixin/StoreSort
 * @mixes Core/data/mixin/StoreGroup
 * @mixes Core/data/mixin/StoreChained
 * @mixes Core/data/mixin/StoreState
 * @mixes Core/data/mixin/StoreRelation
 * @mixes Core/data/mixin/StoreTree
 * @mixes Core/data/stm/mixin/StoreStm
 * @mixes Core/data/mixin/StoreSync
 *
 * @extends Core/Base
 */
class Store extends Base.mixin(Delayable, Identifiable, Events, Pluggable, State, StoreFilter, StoreChanges, StoreCRUD, StoreRelation,
// Private
StoreSum, StoreSearch, StoreSort, StoreGroup, StoreChained, StoreState, StoreTree, StoreStm, StoreSync, StoreProxy // Private for now, thus not mentioned in @mixes block above
) {
  //region Config & properties
  static get $name() {
    return 'Store';
  }
  static get properties() {
    return {
      relationCache: {},
      dependentStoreConfigs: new Map()
    };
  }
  static get configurable() {
    return {
      /**
       * Store's unique identifier.
       *
       * @member {String|Number} id
       * @readonly
       * @category Common
       */
      /**
       * Store's unique identifier. When set the store is added to a store map accessible through
       * `Store.getStore(id)`.
       *
       * @config {String|Number}
       * @category Common
       */
      id: true,
      /**
       * Class used to represent records in the store, should be a subclass of {@link Core.data.Model}. Only
       * applies when supplying data to the store (load, add), any supplied record instances are kept as is.
       *
       * ```javascript
       * class MyModel extends Model {
       *     static get fields() {
       *         return [
       *             'name',
       *             'city',
       *             'company'
       *         ]
       *     }
       * }
       *
       * const store = new Store({
       *     modelClass : MyModel,
       *     data : [
       *         { id : 1, name : 'Mark', city : 'London', company : 'Cool inc' },
       *         ...
       *     ]
       * });
       * ```
       *
       * @config {Core.data.Model}
       * @default
       * @typings {typeof Model}
       * @category Common
       */
      modelClass: Model,
      /**
       * Verify that loaded data does not contain any generated ids. If it does, a warning is logged on console.
       *
       * Set this to `false` to disable the check and give a very minor performance boost.
       *
       * @prp {Boolean}
       * @default
       */
      verifyNoGeneratedIds: true
    };
  }
  static get defaultConfig() {
    return {
      /**
       * An array of field definitions used to create a {@link Core.data.Model} (modelClass) subclass. Optional.
       * If the Model already has fields defined, these fields will extend those.
       *
       * ```javascript
       * const store = new Store({
       *     fields : ['name', 'city', 'company'],
       *     data   : [
       *         { id : 1, name : 'Mark', city : 'London', company : 'Cool inc' },
       *         ...
       *     ]
       * });
       * ```
       *
       * See {@link Core.data.Model} for more info on defining fields, changing data source and mapping fields to
       * nested objects.
       *
       * Note that pre-created record instances supplied to the store are kept as is and thus these fields will
       * not apply to them.
       *
       * @config {Array<String|ModelFieldConfig|Core.data.field.DataField>}
       * @category Common
       */
      fields: null,
      /**
       * Automatically detect from set data if used as tree store or flat store
       * @config {Boolean}
       * @default
       * @category Tree
       */
      autoTree: true,
      /**
       * Raw data to load initially.
       *
       * Expects an array of JavaScript objects, with properties matching store's fields (defined on its
       * {@link #config-modelClass model} or in the {@link #config-fields} config).
       *
       * ```javascript
       * const store = new Store({
       *     data : [
       *         { id : 1, name : 'Linda', city : 'NY' },
       *         { id : 2, name : 'Olivia', city : 'Paris' },
       *         ...
       *     ]
       * });
       * ```
       *
       * @config {Object[]|Core.data.Model[]}
       * @category Common
       */
      data: null,
      /**
       * `true` to act as a tree store.
       * @config {Boolean}
       * @category Tree
       */
      tree: false,
      callOnFunctions: true,
      /**
       * A {@link Core/util/Collection}, or Collection config object
       * to use to contain this Store's constituent records.
       * @config {Core.util.Collection|CollectionConfig}
       * @category Advanced
       */
      storage: null,
      /**
       * Retools the loaded data objects instead of making shallow copies of them. This increases performance but
       * pollutes the incoming data and does not allow remapping of fields (dataSource).
       *
       * Also allows disabling certain steps in data loading, to further improve performance. Either accepts an
       * object with the params described below or `true` which equals `disableDuplicateIdCheck` and
       * `disableTypeConversion`.
       *
       * ```javascript
       * // No duplicate id checking, no type conversions
       * new Store({ useRawData : true });
       *
       * new Store({
       *   // No type conversions only
       *   useRawData : {
       *     disableTypeConversion : true
       *   }
       * });
       * ```
       *
       * @config {Boolean|Object}
       * @param {Boolean} [disableDuplicateIdCheck] Data must not contain duplicate ids, check is bypassed.
       * @param {Boolean} [disableDefaultValue] Default values will not be applied to record fields.
       * @param {Boolean} [disableTypeConversion] No type conversions will be performed on record data.
       * @category Advanced
       */
      useRawData: false,
      /**
       * Specify `false` to prevent loading records without ids, a good practise to enforce when syncing with a
       * backend.
       *
       * By default Store allows loading records without ids, in which case a generated id will be assigned.
       *
       * @config {Boolean}
       * @default true
       * @category Advanced
       */
      allowNoId: true,
      /**
       * Prevent dynamically subclassing the modelClass. It does so by default to not pollute it when exposing
       * properties. Should rarely need to be used.
       * @config {Boolean}
       * @default false
       * @private
       * @category Advanced
       */
      preventSubClassingModel: null
    };
  }
  static get identifiable() {
    return {
      registerGeneratedId: false
    };
  }
  /**
   * Class used to represent records. Defaults to class Model.
   * @member {Core.data.Model} modelClass
   * @typings {typeof Model}
   * @category Records
   */
  //endregion
  //region Events
  /**
   * Fired when the id of a record has changed
   * @event idChange
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model} record Modified record
   * @param {String|Number} oldValue Old id
   * @param {String|Number} value New id
   */
  /**
   * Fired before record is modified in this store.
   * Modification may be vetoed by returning `false` from a handler.
   * @event beforeUpdate
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model} record Modified record
   * @param {Object} changes Modification data
   */
  /**
   * Fired when a record is modified
   * @event update
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model} record Modified record
   * @param {Object} changes Modification data
   */
  /**
   * Fired when one of this Store's constituent records is modified while in
   * {@link Core.data.Model#function-beginBatch batched} state. This may be used to keep
   * UIs up to date while "tentative" changes are made to a record which must not be synced with a server.
   * @event batchedUpdate
   * @private
   */
  /**
   * Fired when the root node is set
   * @event rootChange
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model} oldRoot The old root node.
   * @param {Core.data.Model} rootNode The new root node.
   */
  /**
   * Data in the store was changed. This is a catch-all event which is fired for all changes
   * which take place to the store's data.
   *
   * This includes mutation of individual records, adding and removal of records, as well as
   * setting a new data payload using the {@link #property-data} property, sorting, filtering,
   * and calling {@link Core.data.mixin.StoreCRUD#function-removeAll}.
   *
   * Simple databound widgets may use to the `change` event to refresh their UI without having to add multiple
   * listeners to the {@link #event-update}, {@link Core.data.mixin.StoreCRUD#event-add},
   * {@link Core.data.mixin.StoreCRUD#event-remove}, {@link #event-refresh} and
   * {@link Core.data.mixin.StoreCRUD#event-removeAll} events.
   *
   * A more complex databound widget such as a grid may use the more granular events to perform less
   * destructive updates more appropriate to each type of change. The properties will depend upon the value of the
   * `action` property.
   *
   * @event change
   * @param {Core.data.Store} source This Store.
   * @param {'remove'|'removeAll'|'add'|'updatemultiple'|'clearchanges'|'filter'|'update'|'dataset'|'replace'} action
   * Name of action which triggered the change. May be one of the options listed above
   * @param {Core.data.Model} record Changed record, for actions that affects exactly one record (`'update'`)
   * @param {Core.data.Model[]} records Changed records, passed for all actions except `'removeAll'`
   * @param {Object} changes Passed for the `'update'` action, info on which record fields changed
   */
  // NOTE: When updating params above, also update change event in ProjectModelMixin and dataChange in ProjectConsumer
  /**
   * Data in the store has completely changed, such as by a filter, or sort or load operation.
   * @event refresh
   * @param {Core.data.Store} source This Store.
   * @param {Boolean} batch Flag set to `true` when the refresh is triggered by ending a batch
   * @param {'dataset'|'sort'|'clearchanges'|'filter'|'create'|'update'|'delete'|'group'} action Name of
   * action which triggered the change. May be one of the options listed above.
   */
  //endregion
  /* break doc comment from next method */
  //region Init
  constructor(...args) {
    super(...args);
    // When using a Proxy, the Proxy is returned instead of the actual Store
    if (this.objectify) {
      return this.initProxy();
    }
  }
  construct(config = {}) {
    const me = this;
    Object.assign(me, {
      added: new StoreBag(),
      removed: new StoreBag(),
      modified: new StoreBag(),
      idRegister: {},
      internalIdRegister: {},
      oldIdMap: {}
    });
    if (config.storeId) {
      // avoid changing id when setting storeId:
      config = ObjectHelper.assign({
        id: config.storeId
      }, config);
      // We cannot remove storeId since it can also be inherited and if so, it will override the id above:
      // delete config.storeId;
    }

    super.construct(config);
    me.initRelations();
  }
  /**
   * Retrieves/creates a store based on the passed config.
   *
   * | Type              | Result                                                                 |
   * |-------------------|------------------------------------------------------------------------|
   * | Core.data.Store   | Returns supplied store as is                                           |
   * | String            | Retrieves an existing store by id                                      |
   * | Object            | Creates a new store using supplied config object                       |
   * | Object[]          | Creates a new store, populated with records created from supplied data |
   * | Core.data.Model[] | Creates a new store, populated with supplied records                   |
   *
   *
   * @param {Core.data.Store|StoreConfig|String|StoreConfig[]|Core.data.Model[]} config
   * @param {Object} [defaults] Config object to apply when creating a new store for passed data
   * @param {Function} [converterFn] Function called for each data object prior to creating a record from it. The
   * return value is used to create a record.
   * @private
   */
  static from(config, defaults = {}, converterFn = null) {
    // null and store instances pass through
    if (config && !config.isStore) {
      // Passed a string, get store by id
      if (typeof config === 'string') {
        config = Store.getStore(config);
      }
      // Passed something else, create a store using the input as its data
      else {
        // Array of records or data, pass to converterFn if one is supplied
        if (Array.isArray(config)) {
          if (converterFn) {
            config = config.map(data => data.isModel ? data : converterFn(data));
          }
          config = ObjectHelper.assign({}, defaults, {
            data: config
          });
        }
        config = new Store(config);
      }
    }
    return config;
  }
  doDestroy() {
    var _me$stm, _me$stm$removeStore, _me$_storage;
    const me = this,
      allRecords = me.registeredRecords;
    // Remove from STM if added there (STM might also have gotten destroyed before us)
    (_me$stm = me.stm) === null || _me$stm === void 0 ? void 0 : (_me$stm$removeStore = _me$stm.removeStore) === null || _me$stm$removeStore === void 0 ? void 0 : _me$stm$removeStore.call(_me$stm, me);
    for (let i = allRecords.length - 1, rec; i >= 0; i--) {
      var _rec;
      rec = allRecords[i];
      if (!((_rec = rec) !== null && _rec !== void 0 && _rec.isDestroyed)) {
        rec.unjoinStore(me);
      }
    }
    (_me$_storage = me._storage) === null || _me$_storage === void 0 ? void 0 : _me$_storage.destroy();
    if (!me.isChained) {
      var _me$rootNode;
      (_me$rootNode = me.rootNode) === null || _me$rootNode === void 0 ? void 0 : _me$rootNode.destroy();
    }
    // Events superclass fires destroy event.
    super.doDestroy();
  }
  /**
   * Stops this store from firing events until {@link #function-endBatch} is called. Multiple calls to `beginBatch`
   * stack up, and will require an equal number of `endBatch` calls to resume events.
   *
   * Upon call of {@link #function-endBatch}, a {@link #event-refresh} event is triggered to allow UIs to
   * update themselves based upon the new state of the store.
   *
   * This is extremely useful when making a large number of changes to a store. It is important not to trigger
   * too many UI updates for performance reasons. Batching the changes ensures that UIs attached to this
   * store are only updated once at the end of the updates.
   */
  beginBatch() {
    this.suspendEvents();
  }
  /**
   * Ends event suspension started by {@link #function-beginBatch}. Multiple calls to {@link #function-beginBatch}
   * stack up, and will require an equal number of `endBatch` calls to resume events.
   *
   * Upon call of `endBatch`, a {@link #event-refresh} event with `action: batch` is triggered to allow UIs to update
   * themselves based upon the new state of the store.
   *
   * This is extremely useful when making a large number of changes to a store. It is important not to trigger
   * too many UI updates for performance reasons. Batching the changes ensures that UIs attached to this
   * store are only updated once at the end of the updates.
   */
  endBatch() {
    if (this.resumeEvents()) {
      this.trigger('refresh', {
        action: 'batch',
        data: this.storage.values,
        records: this.storage.values
      });
    }
  }
  set storage(storage) {
    const me = this;
    if (storage !== null && storage !== void 0 && storage.isCollection) {
      me._storage = storage;
    } else {
      me._storage = new Collection(storage);
    }
    me._storage.autoFilter = me.reapplyFilterOnAdd;
    me._storage.autoSort = me.reapplySortersOnAdd;
    // Join all the constituent records to this Store
    for (const r of me._storage) {
      r.joinStore(me);
    }
    me._storage.ion({
      change: 'onDataChange',
      thisObj: me
    });
  }
  get storage() {
    if (!this._storage) {
      this.storage = {};
    }
    return this._storage;
  }
  /**
   * Returns all records (ignoring any filters) from the store.
   * @property {Core.data.Model[]}
   * @readonly
   * @category Records
   */
  get allRecords() {
    var _me$_allRecords;
    const me = this;
    if (((_me$_allRecords = me._allRecords) === null || _me$_allRecords === void 0 ? void 0 : _me$_allRecords.generation) !== me.storage.generation) {
      if (me.isTree) {
        const result = me.collectDescendants(me.rootNode, undefined, undefined, {
          unfiltered: true
        }).all;
        if (me.rootVisible) {
          result.unshift(me.rootNode);
        }
        me._allRecords = result;
      } else {
        me._allRecords = me.isGrouped ? me.collectGroupRecords() : me.storage.allValues;
      }
      me._allRecords.generation = me.storage.generation;
    }
    return me._allRecords;
  }
  // All records except special rows such group headers etc
  getAllDataRecords(searchAllRecords) {
    const me = this;
    if (me.tree) {
      return searchAllRecords ? me.allRecords : me.rootNode.allChildren;
    }
    return me.isGrouped ? me.collectGroupRecords(searchAllRecords, false) : searchAllRecords ? me.storage.allValues : me.storage.values;
  }
  /**
   * Called by owned record when the record has its {@link Core.data.Model#property-isCreating}
   * property toggled.
   * @param {Core.data.Model} record The record that is being changed.
   * @param {Boolean} isCreating The new value of the {@link Core.data.Model#property-isCreating} property.
   * @internal
   */
  onIsCreatingToggle(record, isCreating) {
    const me = this,
      newlyPersistable = record.isPersistable && !isCreating;
    // If it's a transient "isCreating" record, waiting to be confirmed as a new entry
    // into the store, then it should *not* be in the added Bag as a syncable record.
    // If we are upgrading it to a permanent record, it *should* be in the added Bag.
    me.added[newlyPersistable ? 'add' : 'remove'](record);
    // If the record is newly persistable...
    if (newlyPersistable) {
      /**
       * Fired when a temporary record with the {@link Core.data.Model#property-isCreating} property set
       * has been confirmed as a part of this store by having its {@link Core.data.Model#property-isCreating}
       * property cleared.
       * @event addConfirmed
       * @param {Core.data.Store} source This Store.
       * @param {Core.data.Model} record The record confirmed as added.
       */
      me.trigger('addConfirmed', {
        record
      });
      // AjaxStore to commit confirmed new record
      if (me.autoCommit) {
        me.doAutoCommit();
      }
    }
  }
  // Join added records to store, not called when loading
  joinRecordsToStore(records) {
    const {
      allCount
    } = this;
    for (let i = 0; i < records.length; i++) {
      const record = records[i];
      // Set a parentIndex on newly added records, based on count prior to the add
      record.setData('parentIndex', allCount + i - records.length);
      record.joinStore(this);
    }
  }
  /**
   * Responds to mutations of the underlying storage Collection
   * @param {Object} event
   * @protected
   */
  onDataChange({
    source: storage,
    action,
    added,
    removed,
    replaced,
    oldCount,
    items,
    from,
    to
  }) {
    const me = this,
      isAddRemove = dataAddRemoveActions[action],
      // The "filter" action's removed and added are not processed as adds and removes.
      // In a filter operation the records are still members of the store.
      addedCount = isAddRemove && (added === null || added === void 0 ? void 0 : added.length),
      removedCount = isAddRemove && (removed === null || removed === void 0 ? void 0 : removed.length);
    let filtersWereReapplied, sortersWereReapplied;
    me._idMap = null;
    if (addedCount) {
      me.joinRecordsToStore(added);
    }
    replaced === null || replaced === void 0 ? void 0 : replaced.forEach(([oldRecord, newRecord]) => {
      oldRecord.unjoinStore(me, true);
      newRecord.joinStore(me);
    });
    // Allow mixins to mutate the storage before firing events.
    // StoreGroup does this to introduce group records into the mix.
    super.onDataChange(...arguments);
    // Join/unjoin incoming/outgoing records unless it's as a result of TreeNode operations.
    // If we are a tree, joining is done when nodes are added/removed
    // as child nodes of a joined parent.
    if (!me.isTree) {
      if (addedCount) {
        for (const record of added) {
          // If was removed, remove from `removed` list
          if (me.removed.includes(record)) {
            me.removed.remove(record);
          }
          // Else add to `added` list
          else if (!record.isLinked) {
            me.added.add(record);
          }
        }
        // Re-evaluate the current *local* filter set silently so that the
        // information we are broadcasting below is up-to-date.
        filtersWereReapplied = !me.remoteFilter && me.isFiltered && me.reapplyFilterOnAdd;
        if (filtersWereReapplied) {
          me.filter({
            silent: true
          });
        }
        // if sortParamName not defined, is not remote sort
        sortersWereReapplied = !me.remoteSort && me.isSorted && me.reapplySortersOnAdd;
        if (sortersWereReapplied) {
          me.sort(null, null, false, true);
        }
      }
      if (removedCount) {
        for (const record of removed) {
          // If app was in the middle of a batched update, cancel the update.
          record.cancelBatch();
          record.unjoinStore(me);
          // If was newly added, remove from `added` list
          if (me.added.includes(record)) {
            me.added.remove(record);
          }
          // Else add to `removed` list
          // Unless it's StateTrackingManager reverting the record insertion.
          // Also unless it's a record which was a transient record created by the UI
          // and then the create was canceled at the edit stage.
          else if (!record._undoingInsertion && !record.isCreating && !record.isLinked) {
            me.removed.add(record);
          }
        }
        me.modified.remove(removed);
        // Re-evaluate the current *local* filter set silently so that the
        // information we are broadcasting below is up-to-date.
        filtersWereReapplied = !me.remoteFilter && me.isFiltered;
        if (filtersWereReapplied) {
          me.filter({
            silent: true
          });
        }
      }
    }
    switch (action) {
      case 'clear':
        // Clear our own relationCache, since we will be empty
        me.relationCache = {};
        // Signal to stores that depend on us
        me.updateDependentStores('removeall');
        me.trigger('removeAll');
        me.trigger('change', {
          action: 'removeall'
        });
        break;
      case 'splice':
        if (addedCount) {
          me.updateDependentStores('add', added);
          const
            // Collection does not handle moves, figure out if and where a record was moved from by checking
            // previous index value stored in meta
            oldIndex = added.reduce((lowest, record) => {
              const {
                previousIndex
              } = record.meta;
              if (previousIndex > -1 && previousIndex < lowest) lowest = previousIndex;
              return lowest;
            }, added[0].meta.previousIndex),
            index = storage.indexOf(added[0], !storage.autoFilter),
            params = {
              records: added,
              index
            };
          // Only include param oldIndex when used
          if (oldIndex > -1) {
            params.oldIndex = oldIndex;
          }
          me.trigger('add', params);
          me.trigger('change', Object.assign({
            action: 'add'
          }, params));
          if (filtersWereReapplied) {
            me.triggerFilterEvent({
              action: 'filter',
              filters: me.filters,
              oldCount,
              records: me.storage.allValues
            });
          }
          if (sortersWereReapplied) {
            me.trigger('sort', {
              action: 'sort',
              sorters: me.sorters,
              records: me.storage.allValues
            });
          }
        }
        if (removed.length) {
          me.updateDependentStores('remove', removed);
          me.trigger('remove', {
            records: removed
          });
          me.trigger('change', {
            action: 'remove',
            records: removed
          });
        }
        if (replaced.length) {
          me.trigger('replace', {
            records: replaced,
            all: me.records.length === replaced.length
          });
          me.trigger('change', {
            action: 'replace',
            replaced,
            all: me.records.length === replaced.length
          });
        }
        break;
      case 'filter':
        // Reapply grouping/sorting to make sure unfiltered records get sorted correctly
        if (me.isGrouped || me.isSorted) {
          me.performSort(true);
        }
        break;
      case 'move':
        {
          // silently update parentIndex of records affected
          const start = Math.min(from, to),
            // We need to constrain maximum index in case record gets removed due to moving to the
            // collapsed group
            end = Math.min(me.storage.allValues.length - 1, Math.max(from, to));
          for (let allRecords = me.storage.allValues, i = start; i <= end; i++) {
            allRecords[i].setData('parentIndex', i);
          }
          /**
           * Fired when a block of records has been moved within this Store
           * @event move
           * @param {Core.data.Store} source This Store
           * @param {Core.data.Model} record (DEPRECATED) The first record moved (The
           * {@link Core.data.mixin.StoreCRUD#function-move} API now accepts an array of records to move).
           * @param {Core.data.Model[]} records The records moved.
           * @param {Number} from The index from which the record was removed (applicable only for flat store).
           * @param {Number} to The index at which the record was inserted (applicable only for flat store).
           * @param {Core.data.Model} [newParent] The new parent record for the dragged records (applicable only for tree stores)
           * @param {Core.data.Model[]} [oldParents] The old parent records for the dragged records (applicable only for move operations in tree stores)
           */
          me.trigger('move', {
            record: items[0],
            records: items,
            from,
            to
          });
          // The move was in real data. If we are filtered, the
          // filtered set has to be refreshed.
          if (me.isFiltered) {
            me.performFilter();
          }
          me.trigger('change', {
            action,
            record: items[0],
            records: items,
            from,
            to
          });
          break;
        }
    }
  }
  onDataReplaced(action, data) {
    var _me$afterLoadData;
    const me = this,
      {
        storage
      } = me,
      all = storage.allValues,
      sorted = Boolean(me.sorters.length > 0);
    for (let i = 0; i < all.length; i++) {
      all[i].joinStore(me);
    }
    // The three operations below, filter, store and sort, all are passed
    // the "silent" parameter meaning they do not fire their own events.
    // The 'refresh' and 'change' events after are used to update UIs.
    if (!me.remoteFilter && me.isFiltered) {
      me.filter({
        silent: true
      });
    }
    if (me.remoteSort) {
      if (me.isGrouped) {
        storage.replaceValues({
          // Need to update group records info (headers and footers)
          ...me.prepareGroupRecords(),
          silent: true
        });
      }
    } else {
      if (me.isGrouped) {
        me.group(null, null, false, !sorted, true);
      }
      // Only request sorting of arriving data if sorting is not remote.
      if (sorted) {
        me.sort(null, null, false, true);
      }
    }
    // Check for duplicate ids, unless user guarantees data validity
    if (!me.useRawData.disableDuplicateIdCheck) {
      const {
        idMap
      } = me;
      if (Object.keys(idMap).length < storage.values.length) {
        // idMap has fewer entries than expected, a duplicate id was used. pick idMap apart to find out which
        const collisions = [];
        storage.values.forEach(r => idMap[r.id] ? delete idMap[r.id] : collisions.push(r));
        throw new Error(`Id collision on ${collisions.map(r => r.id)}`);
      }
    }
    const event = {
      action,
      data,
      records: storage.values
    };
    me.updateDependentStores(action, event.records);
    // Allow subclasses to postprocess a new dataset
    (_me$afterLoadData = me.afterLoadData) === null || _me$afterLoadData === void 0 ? void 0 : _me$afterLoadData.call(me);
    if (!me.isRemoteDataLoading) {
      me.trigger('refresh', event);
    }
    me.trigger('change', event);
  }
  /**
   * This is called from Model after mutating any fields so that Stores can take any actions necessary at that point,
   * and distribute mutation event information through events.
   * @param {Core.data.Model} record The record which has just changed
   * @param {Object} toSet A map of the field names and values that were passed to be set
   * @param {Object} wasSet A map of the fields that were set. Each property is a field name, and
   * the property value is an object containing two properties: `oldValue` and `value` eg:
   * ```javascript
   *     {
   *         name {
   *             oldValue : 'Rigel',
   *             value : 'Nigel'
   *         }
   *     }
   *
   * @param {Boolean} silent Do not trigger events
   * @param {Boolean} fromRelationUpdate Update caused by a change in related model
   * @private
   */
  onModelChange(record, toSet, wasSet, silent, fromRelationUpdate) {
    const me = this,
      event = {
        record,
        records: [record],
        changes: wasSet,
        // Cannot use isBatching, since change is triggered when batching has reached 0
        // (but before it is set to null)
        batch: record.batching != null,
        fromRelationUpdate
      },
      committable = record.ignoreBag || record.isLinked ? false : me.updateModifiedBagForRecord(record);
    // Inform underlying collection of the changes, allowing it to keep any indices up to date
    me.storage.onItemMutation(record, wasSet);
    // Always update indices, otherwise they will be left out of date (was previously skipped when silent)
    if ('id' in wasSet) {
      const {
        oldValue,
        value
      } = toSet.id;
      me.updateDependentRecordIds(oldValue, value);
      me.onRecordIdChange({
        record,
        oldValue,
        value
      });
    }
    if (!silent) {
      if ('id' in wasSet) {
        const {
          oldValue,
          value
        } = toSet.id;
        me.trigger('idChange', {
          store: me,
          record,
          oldValue,
          value
        });
      }
      me.onUpdateRecord(record, wasSet);
      me.trigger('update', event);
      me.trigger('change', Object.assign({
        action: 'update'
      }, event));
    }
    if (me.autoCommit && committable) {
      me.doAutoCommit();
    }
  }
  updateModifiedBagForRecord(record) {
    const me = this;
    let addedToBag = false;
    // Add or remove from our modified Bag
    if (record.isModified) {
      if (!me.modified.includes(record) && !me.added.includes(record) && record.isPartOfStore(me) && !record.isAutoRoot) {
        // When we add a new model first time and the model is not persistable (for example when the model is not valid),
        // it is not added to the "added" collection (StoreBag), but only joined to the store.
        // So if the record is not added neither to "modified" nor "added",
        // need to check if this record is phantom. If so, add it to the "added", otherwise to the "modified".
        if (record.isPhantom) {
          me.added.add(record);
        } else {
          me.modified.add(record);
        }
        addedToBag = true;
      }
    } else {
      me.modified.remove(record);
    }
    return addedToBag;
  }
  get idMap() {
    const me = this,
      needsRebuild = !me._idMap,
      idMap = me._idMap || (me._idMap = {});
    if (needsRebuild) {
      const processedRecords = me.storage.values;
      for (let record, index = 0, visibleIndex = 0; index < processedRecords.length; index++) {
        record = processedRecords[index];
        idMap[record.id] = {
          index,
          visibleIndex,
          record
        };
        if (!record.isSpecialRow) {
          visibleIndex++;
        }
      }
      // If store is filtered and grouped, we often need to lookup record index in filtered and unfiltered
      // collections
      if (me.isFiltered) {
        for (let index = 0, l = me.storage._values.length; index < l; index++) {
          const record = me.storage._values[index];
          if (record.id in idMap) {
            idMap[record.id].unfilteredIndex = index;
          } else {
            // If record is not in the idMap, set its index as -1 which allows
            // `store.includes` API work correctly
            idMap[record.id] = {
              index: -1,
              unfilteredIndex: index,
              record
            };
          }
        }
      }
    }
    return idMap;
  }
  changeModelClass(ClassDef) {
    const {
      fields
    } = this;
    this.originalModelClass = ClassDef;
    let ClassDefEx = ClassDef;
    // Ensure our modelClass is exchanged for an extended of modelClass decorated with any configured fields.
    if (fields !== null && fields !== void 0 && fields.length) {
      // angular prod build messes up "Foo = class extends Base" (https://github.com/bryntum/support/issues/6395)
      class ModelClass extends ClassDef {
        static get fields() {
          return fields;
        }
      }
      ClassDefEx = ModelClass;
    }
    // If we expose properties on Model we will pollute all other models, use internal subclass instead
    else if (!this.preventSubClassingModel) {
      // angular prod build messes up "Foo = class extends Base" (https://github.com/bryntum/support/issues/6395)
      class ModelClass extends ClassDef {}
      ClassDefEx = ModelClass;
    }
    // Need to properly expose relations on this new subclass
    ClassDefEx.initClass();
    return ClassDefEx;
  }
  //endregion
  //region Store id & map
  set storeId(storeId) {
    this.id = storeId;
  }
  get storeId() {
    return this.id;
  }
  changeId(id, oldId) {
    return super.changeId(id !== true && id, oldId);
  }
  updateId(id, oldId) {
    const duplicate = Store.getById(id);
    duplicate && Store.unregisterInstance(duplicate);
    super.updateId(id, oldId);
  }
  generateAutoId() {
    return Store.generateId(`store-`);
  }
  get tree() {
    return this._tree;
  }
  set tree(tree) {
    this._tree = tree;
    if (tree && !this.rootNode) {
      this.rootNode = this.buildRootNode();
      this.rootNode.isAutoRoot = true;
    }
  }
  // a hook to build a customized root node
  buildRootNode() {
    return {};
  }
  /**
   * Get a store from the store map by id.
   * @param {String|Number|Object[]} id The id of the store to retrieve, or an array of objects
   * from which to create the contents of a new Store.
   * @returns {Core.data.Store} The store with the specified id
   */
  static getStore(id, storeClass) {
    if (id instanceof Store) {
      return id;
    }
    if (this.getById(id)) {
      return this.getById(id);
    }
    if (Array.isArray(id)) {
      let storeModel;
      const storeData = id.map(item => {
        if (item instanceof Model) {
          storeModel = item.constructor;
        } else if (typeof item === 'string') {
          item = {
            text: item
          };
        } else ;
        return item;
      });
      if (!storeModel) {
        // angular prod build messes up "Foo = class extends Base" (https://github.com/bryntum/support/issues/6395)
        class ModelClass extends Model {}
        storeModel = ModelClass;
      }
      id = {
        autoCreated: true,
        data: storeData,
        modelClass: storeModel,
        allowNoId: true // String items have no id and are not guaranteed to be unique
      };

      if (!storeClass) {
        storeClass = Store;
      }
    }
    if (storeClass) {
      return new storeClass(id);
    }
  }
  /**
   * Get all registered stores
   * @property {Core.data.Store[]}
   */
  static get stores() {
    return Store.registeredInstances;
  }
  //endregion
  //region Data
  /**
   * The invisible root node of this tree.
   * @property {Core.data.Model}
   * @readonly
   * @category Tree
   */
  get rootNode() {
    return this.masterStore ? this.masterStore.rootNode : this._rootNode;
  }
  set rootNode(rootNode) {
    var _rootNode$children;
    const me = this,
      oldRoot = me._rootNode;
    // No change
    if (rootNode === oldRoot) {
      return;
    }
    if (oldRoot) {
      me.clear(true);
    }
    if (rootNode instanceof Model) {
      // We insist that the rootNode is expanded otherwise no children will be added
      rootNode.instanceMeta(me).collapsed = false;
      me._rootNode = rootNode;
    } else {
      me._rootNode = rootNode = new me.modelClass(Object.assign({
        expanded: true,
        [me.modelClass.idField]: `${me.id}-rootNode`
      }, rootNode), me, null, true);
    }
    me._tree = true;
    rootNode.isRoot = true;
    rootNode.joinStore(me);
    // If there are nodes to be inserted into the flat storage
    // then onNodeAddChild knows how to do that and what events
    // to fire based upon rootNode.isLoading.
    if ((_rootNode$children = rootNode.children) !== null && _rootNode$children !== void 0 && _rootNode$children.length || me.rootVisible) {
      rootNode.isLoading = true;
      me.onNodeAddChild(rootNode, rootNode.children || [], 0);
      rootNode.isLoading = false;
    }
    me.trigger('rootChange', {
      oldRoot,
      rootNode
    });
  }
  /**
   * Sets data in the store.
   *
   * Expects an array of JavaScript objects, with properties matching store's fields (defined on its
   * {@link #config-modelClass model} or in the {@link #config-fields} config).
   *
   * Called on initialization if data is in config otherwise call it yourself after ajax call etc. Can also be used to
   * get the raw original data.
   *
   * ```javascript
   * store.data = [
   *     { id : 1, name : 'Linda', city : 'NY' },
   *     { id : 2, name : 'Olivia', city : 'Paris' },
   *     ...
   * ];
   * ```
   *
   * @property {Object[]}
   * @fires refresh
   * @fires change
   * @category Records
   */
  set data(data) {
    this.setStoreData(data);
  }
  // For overridability in engine
  setStoreData(data) {
    var _data, _data2;
    const me = this,
      {
        idField,
        childrenField
      } = me.modelClass;
    // Take a peek at first data row, and clone data if we are provided immutable objects
    if (me.transformFlatData && ((_data = data) === null || _data === void 0 ? void 0 : _data.length) > 0 && !Object.isExtensible(data[0])) {
      // Avoid cloning object again in Model
      me.useRawData = me.useRawData || {
        disableDuplicateIdCheck: false,
        disableDefaultValue: false,
        disableTypeConversion: false
      };
      data = ObjectHelper.clone(data);
    }
    // Make sure that if the plugins have not been processed yet, we call
    // the temporary property getter which configuration injects to
    // process plugins at this point. Some plugins are required to
    // operate on incoming data.
    me.getConfig('plugins');
    // In case data is loaded during configuration before configuredListeners have been processed
    me.processConfiguredListeners();
    // Allow data as a "named object", using keys as ids
    if (data && !Array.isArray(data)) {
      data = ObjectHelper.transformNamedObjectToArray(data, idField);
    }
    // Convert to being a tree store if any of the new rows have a children property
    me.tree = !me.isChained && (me.tree || Boolean(me.autoTree && ((_data2 = data) === null || _data2 === void 0 ? void 0 : _data2.some(r => r[childrenField]))));
    // Store received data order to preserve on sort if remote data loading enabled
    if (data && (me.remoteSort || me.remoteFilter)) {
      for (let i = 0; i < data.length; i++) {
        data[i]._remoteSortIndex = i;
      }
    }
    // Always load a new dataset initially
    if (!me.syncDataOnLoad || !me._data) {
      me._data = data;
      // This means load the root node
      if (me.tree) {
        if (me.transformFlatData) {
          data = me.treeifyFlatData(data);
        }
        const root = me.rootNode;
        root.isLoading = true;
        // clear silently without marking as removed
        me.clear(true);
        // Append child will detect that this is a dataset operation and trigger sort + events needed
        root.appendChild(data);
        me.updateDependentStores('dataset', [root]);
        root.isLoading = false;
        if (data.length === 0) {
          const event = {
            action: 'dataset',
            data: [],
            records: []
          };
          me.trigger('refresh', event);
          me.trigger('change', event);
        }
        // we must re-apply filters for the filtered tree store
        else if (me.isFiltered) {
          me.filter();
        }
      } else {
        me.loadData(data);
      }
      // loading the store discards all tracked changes
      me.added.clear();
      me.removed.clear();
      me.modified.clear();
    }
    // Sync dataset if configured to do so
    else {
      me.syncDataset(data);
    }
  }
  loadData(data, action = 'dataset') {
    const me = this,
      {
        storage,
        allowNoId
      } = me,
      idField = me.modelClass.fieldMap.id.dataSource,
      creatingRecord = me.find(rec => rec.isCreating);
    if (creatingRecord) {
      storage.values.splice(me.records.indexOf(creatingRecord), 1);
    }
    let warnGenerated = me.verifyNoGeneratedIds;
    // Need to unregister all groups
    me.removeHeadersAndFooters(me.storage.values);
    me._idMap = null;
    me.oldIdMap = {};
    if (data) {
      const isRaw = !(data[0] instanceof Model);
      if (isRaw) {
        me.modelClass.exposeProperties(data[0]);
        const count = data.length,
          records = new Array(count);
        for (let i = 0; i < count; i++) {
          var _recordData$idField, _recordData$idField$s, _recordData$idField2;
          const recordData = data[i];
          if (!allowNoId && recordData[idField] == null) {
            throw new Error(`Id required but not found on row ${i}`);
          }
          if (warnGenerated && (_recordData$idField = recordData[idField]) !== null && _recordData$idField !== void 0 && (_recordData$idField$s = (_recordData$idField2 = _recordData$idField).startsWith) !== null && _recordData$idField$s !== void 0 && _recordData$idField$s.call(_recordData$idField2, '_generated')) {
            console.warn(`Generated id found in data: ${recordData[idField]}. Generated ids are temporary and should be replaced with real ids by the backend`);
            warnGenerated = false;
          }
          records[i] = me.processRecord(me.createRecord(recordData, true), true);
          records[i].setData('parentIndex', i);
        }
        // clear without marking as removed
        me.clear(true);
        // Allow Collection's own filters to work on the Collection by
        // passing the isNewDataset param as true.
        // The storage Collection may have been set up with its own filters
        // while we are doing remote filtering. An example is ComboBox
        // with filterSelected: true. Records which are in the selection are
        // filtered out of visibility using a filter directly in the Combobox's
        // Store's Collection.
        storage.replaceValues({
          values: records,
          isNewDataset: true,
          silent: true
        });
      } else {
        // clear without marking as removed
        me.clear(true);
        storage.replaceValues({
          values: data.slice(),
          isNewDataset: true,
          silent: true
        });
      }
      if (creatingRecord && !storage.values.includes(creatingRecord)) {
        storage.values.push(creatingRecord);
      }
      me._data = data;
      me.onDataReplaced(action, data);
    } else {
      // clear without marking as removed
      me.clear(true);
      me._data = null;
    }
    me.isSyncingDataOnLoad = false;
  }
  get data() {
    return this._data;
  }
  /**
   * Creates an array of records from this store from the `start` to the `end' - 1
   * @param {Number} [start] The index of the first record to return
   * @param {Number} [end] The index *after* the last record to return `(start + length)`
   * @returns {Core.data.Model[]} The requested records.
   * @category Records
   */
  getRange(start, end, all = true) {
    return (all ? this.storage.allValues : this.storage.values).slice(start, end);
  }
  /**
   * Creates a model instance, used internally when data is set/added. Override this in a subclass to do your own custom
   * conversion from data to record.
   * @param {Object} data Json data
   * @param {Boolean} [skipExpose=false] Supply true when batch setting to not expose properties multiple times
   * @category Records
   */
  createRecord(data, skipExpose = false, rawData = false) {
    return new this.modelClass(data, this, null, skipExpose, false, rawData);
  }
  processRecord(record, isDataset = false) {
    return record;
  }
  refreshData() {
    this.filter();
    this.sort();
  }
  onRecordIdChange({
    record,
    oldValue,
    value
  }) {
    const me = this,
      idMap = me._idMap,
      {
        idRegister,
        oldIdMap
      } = me;
    me.storage._indicesInvalid = true;
    // Remember the record used to have this identifier
    // this is used by STM to understand when a foreign key
    // value update really means targeting other record or
    // it's just a reaction to the target record id change
    oldIdMap[oldValue] = record;
    // Update idMap to reflect the changed id. Some code paths (auto syncing changes with CrudManager) will lead to
    // idMap already being up-to-date when we get here
    if (idMap && !idMap[value]) {
      const entry = idMap[oldValue];
      delete idMap[oldValue];
      idMap[value] = entry;
    }
    me.added.changeId(oldValue, value);
    me.removed.changeId(oldValue, value);
    me.modified.changeId(oldValue, value);
    delete idRegister[oldValue];
    idRegister[value] = record;
    record.index = me.storage.indexOf(record);
  }
  onUpdateRecord(record, changes) {
    const me = this,
      {
        internalId
      } = changes,
      {
        internalIdRegister
      } = me;
    if (internalId) {
      this.storage._indicesInvalid = true;
      delete internalIdRegister[internalId.oldValue];
      internalIdRegister[internalId.value] = record;
    }
    // Reapply filters when records change?
    if (me.reapplyFilterOnUpdate && me.isFiltered) {
      me.filter();
    }
  }
  get useRawData() {
    return this._useRawData;
  }
  set useRawData(options) {
    if (options === true) {
      this._useRawData = {
        enabled: true,
        disableDuplicateIdCheck: true,
        disableTypeConversion: true,
        disableDefaultValue: false
      };
    } else {
      this._useRawData = options ? Object.assign(options, {
        enabled: true
      }) : {
        enabled: false
      };
    }
  }
  //endregion
  //region Count
  /**
   * Number of records in the store
   * @param {Boolean} [countProcessed] Count processed (true) or real records (false)
   * @returns {Number} Record count
   * @category Records
   */
  getCount(countProcessed = true) {
    return countProcessed ? this.count : this.originalCount;
  }
  /**
   * Record count, for data records. Not including records added for group headers etc.
   * @property {Number}
   * @readonly
   * @category Records
   */
  get originalCount() {
    var _this$groupRecords;
    return this.storage.totalCount - (((_this$groupRecords = this.groupRecords) === null || _this$groupRecords === void 0 ? void 0 : _this$groupRecords.length) || 0);
  }
  /**
   * Record count, including records added for group headers etc.
   * @property {Number}
   * @readonly
   * @category Records
   */
  get count() {
    return this.storage.count;
  }
  /**
   * Returns the complete dataset size regardless of tree node collapsing or filtering
   * @property {Number}
   * @readonly
   * @category Records
   */
  get allCount() {
    return this.isTree ? this.rootNode.descendantCount : this.storage.totalCount;
  }
  //endregion
  //region Get record(s)
  /**
   * Returns all "visible" records.
   * **Note:** The returned value **may not** be mutated!
   * @property {Core.data.Model[]}
   * @readonly
   * @immutable
   * @category Records
   */
  get records() {
    return this.storage.values;
  }
  /**
   * Get the first record in the store.
   * @property {Core.data.Model}
   * @readonly
   * @category Records
   */
  get first() {
    return this.storage.values[0];
  }
  /**
   * Get the last record in the store.
   * @property {Core.data.Model}
   * @readonly
   * @category Records
   */
  get last() {
    return this.storage.values[this.storage.values.length - 1];
  }
  /**
   * Get the record at the specified index
   * @param {Number} index Index for the record
   * @returns {Core.data.Model} Record at the specified index
   * @category Records
   */
  getAt(index, all = false) {
    // all means include filtered out records
    return this.storage.getAt(index, all);
  }
  // These are called by Model#join and Model#unjoin
  // register a record as a findable member keyed by id and internalId
  register(record) {
    const me = this;
    if (!me.useRawData.disableDuplicateIdCheck) {
      // Test for duplicate IDs on register only when a tree store.
      // loadData does it in the case of a non-tree
      const existingRec = me.isTree && me.idRegister[record.id];
      if (existingRec && existingRec !== record) {
        throw new Error(`Id collision on ${record.id}`);
      }
    }
    me.idRegister[record.id] = record;
    me.internalIdRegister[record.internalId] = record;
  }
  unregister(record) {
    delete this.idRegister[record.id];
    delete this.internalIdRegister[record.internalId];
  }
  get registeredRecords() {
    return Object.values(this.idRegister);
  }
  /**
   * Get a record by id. Find the record even if filtered out, part of collapsed group or collapsed node
   * @param {Core.data.Model|String|Number} id Id of record to return.
   * @returns {Core.data.Model} A record with the specified id
   * @category Records
   */
  getById(id) {
    // In case `id` is a record, we use its ID to try to find the record in the store,
    // because if the record is removed from the store it shouldn't be found.
    // if (id instanceof Model) {
    //     id = id.id;
    // }
    if (id !== null && id !== void 0 && id.isModel) {
      const record = id;
      // When asking for a record that has links, we resolve first link if original is not found.
      // This allows `linkedStore.isAvailable(original)` to return true and `linkedStore.getById(original)` to
      // return the linked record.
      if (record.hasLinks && !this.storage.allValues.includes(record)) {
        return record.$links.find(r => this.storage.allValues.includes(r));
      }
      return record;
    }
    //return this.tree ? this.idRegister[id] : this.storage.get(id);
    return this.idRegister[id];
  }
  /**
   * Checks if a record is available, in the sense that it is not filtered out,
   * hidden in a collapsed group or in a collapsed node.
   * @param {Core.data.Model|String|Number} recordOrId Record to check
   * @returns {Boolean}
   * @category Records
   */
  isAvailable(recordOrId) {
    const record = this.getById(recordOrId);
    return record && this.storage.includes(record) || false;
  }
  /**
   * Get a record by internalId.
   * @param {Number} internalId The internalId of the record to return
   * @returns {Core.data.Model} A record with the specified internalId
   * @category Records
   */
  getByInternalId(internalId) {
    return this.internalIdRegister[internalId];
  }
  /**
   * Checks if the specified record is contained in the store
   * @param {Core.data.Model|String|Number} recordOrId Record, or `id` of record
   * @returns {Boolean}
   * @category Records
   */
  includes(recordOrId) {
    if (this.isTree) {
      return this.idRegister[Model.asId(recordOrId)] != null;
    }
    return this.indexOf(recordOrId) > -1;
  }
  //endregion
  //region Get index
  /**
   * Returns the index of the specified record/id, or `-1` if not found.
   * @param {Core.data.Model|String|Number} recordOrId Record, or `id` of record to return the index of.
   * @param {Boolean} [visibleRecords] Pass `true` to find the visible index.
   * as opposed to the dataset index. This omits group header records.
   * @param {Boolean} [allExceptFilteredOutRecords] For trees, when true this searches all except filtered out records
   * in the flattened tree, similar to a flat store.
   * @returns {Number} Index for the record/id, or `-1` if not found.
   * @category Records
   */
  indexOf(recordOrId, visibleRecords = false, allExceptFilteredOutRecords = false) {
    // Only check records actually in the store ($store is for objectify scenario)
    if (recordOrId !== null && recordOrId !== void 0 && recordOrId.isModel && !recordOrId.stores.includes(this.$store || this)) {
      // When asking for a record that has links, we resolve first link if original is not found.
      // This allows finding index for links using relations to original records (dep -> event for example)
      const linkedRecord = recordOrId.$links.find(r => this.storage.allValues.includes(r));
      if (linkedRecord) {
        return this.indexOf(linkedRecord, visibleRecords);
      }
      return -1;
    }
    // When a tree, indexOf is always in the visible records - filtering is different in trees.
    if (this.isTree) {
      // Cheaper than this.storage.indexOf() which takes a detour to result in the same call
      return (allExceptFilteredOutRecords ? this.rootNode.allChildren : this.storage.values).indexOf(this.getById(recordOrId));
    }
    const id = Model.asId(recordOrId);
    if (id == null) {
      return -1;
    }
    const found = this.idMap[id];
    return found ? found[visibleRecords ? 'visibleIndex' : 'index'] : -1;
  }
  allIndexOf(recordOrId) {
    if (this.isTree) {
      return this.allRecords.indexOf(this.getById(recordOrId));
    } else {
      return this.storage.indexOf(recordOrId, true);
    }
  }
  //endregion
  //region Get values
  /**
   * Returns an array of distinct values for the specified field.
   *
   * ```javascript
   * store.getDistinctValues('age'); // Returns an array of the unique age values
   * ```
   *
   * @param {String} field Field to extract values for
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters
   * @returns {Array} Array of values
   * @category Values
   */
  getDistinctValues(field, searchAllRecords = false) {
    const me = this,
      values = [],
      keys = {};
    let value;
    me.forEach(r => {
      if (!r.isSpecialRow && !r.isRoot) {
        value = r.getValue(field);
        const primitiveValue = value instanceof Date ? value.getTime() : value;
        if (!keys[primitiveValue]) {
          values.push(value);
          keys[primitiveValue] = 1;
        }
      }
    }, me, searchAllRecords);
    return values;
  }
  /**
   * Counts how many times the specified value appears in the store
   * @param {String} field Field to look in
   * @param {*} value Value to look for
   * @returns {Number} Found count
   * @category Values
   */
  getValueCount(field, value) {
    let count = 0;
    this.forEach(r => {
      if (ObjectHelper.isEqual(r.getValue(field), value)) count++;
    });
    return count;
  }
  //endregion
  //region JSON & console
  /**
   * Retrieve or set the data of all records as a JSON string
   *
   * ```javascript
   * const store = new Store({
   *     data : [
   *         { id : 1, name : 'Superman' },
   *         { id : 2, name : 'Batman' }
   *     ]
   * });
   *
   * const jsonString = store.json;
   *
   * //jsonString:
   * '[{"id":1,"name":"Superman"},{"id":2,"name":"Batman"}]
   * ```
   *
   * @property {String}
   */
  set json(json) {
    if (typeof json === 'string') {
      json = StringHelper.safeJsonParse(json);
    }
    this.data = json;
  }
  get json() {
    return StringHelper.safeJsonStringify(this);
  }
  /**
   * Pretty printed version of {@link #property-json}
   * @readonly
   * @property {String}
   */
  get formattedJSON() {
    return StringHelper.safeJsonStringify(this, null, 4);
  }
  /**
   * Retrieve the data of all (unfiltered) records as an array of JSON objects.
   *
   * ```javascript
   * const store = new Store({
   *     data : [
   *         { id : 1, name : 'Superman' },
   *         { id : 2, name : 'Batman' }
   *     ]
   * });
   *
   * const jsonArray = store.toJSON();
   *
   * //jsonArray:
   * [{id:1,name:"Superman"},{id:2,name:"Batman"}]
   * ```
   *
   * @returns {Object[]}
   */
  toJSON() {
    // extract entire structure.
    // If we're a tree, then that consists of the payload of the rootNode.
    return (this.isTree ? this.rootNode.unfilteredChildren || this.rootNode.children || [] : this.allRecords).map(record => record.toJSON());
  }
  //endregion
  //region Extract config
  // These functions are not meant to be called by any code other than Base#getCurrentConfig()
  preProcessCurrentConfigs(configs) {
    super.preProcessCurrentConfigs(configs);
    delete configs.project;
  }
  // Extract current data for all accessible records
  getInlineData(options) {
    const data = [];
    if (this.tree) {
      var _this$rootNode$childr;
      (_this$rootNode$childr = this.rootNode.children) === null || _this$rootNode$childr === void 0 ? void 0 : _this$rootNode$childr.forEach(r => data.push(r.getCurrentConfig(options)));
    } else {
      this.forEach(r => data.push(r.getCurrentConfig(options)));
    }
    return data;
  }
  // Extract current configs and data
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options),
      {
        state
      } = this;
    if (result) {
      var _result$modelClass;
      // Replace initial data with values from current records
      if (result.data) {
        result.data = this.getInlineData(options);
      }
      // Never include project or stm
      delete result.project;
      delete result.stm;
      delete result.asyncEvents;
      // Exclude default modelClass, gets added to config by engine, spam
      if (((_result$modelClass = result.modelClass) === null || _result$modelClass === void 0 ? void 0 : _result$modelClass.$meta.hierarchy[result.modelClass.$meta.hierarchy.length - 2]) === this.constructor.defaultConfig.modelClass) {
        delete result.modelClass;
      }
      // Pollution from grid
      if (!this.tree) {
        delete result.tree;
      }
      // Include current state
      if (state) {
        Object.assign(result, state);
      }
    }
    return result;
  }
  //endregion
  //region Iteration & traversing
  /**
   * Iterates over all normal records in store. Omits group header and footer records if this store is grouped.
   * @param {Function} fn A function that is called for each record. Returning `false` from that function cancels
   * iteration. It is called with the following arguments:
   * @param {Core.data.Model} fn.record Current record
   * @param {Number} fn.index Current index
   * @param {Object} [thisObj] `this` reference for the function
   * @param {Object|Boolean} [options] A boolean for `includeFilteredOutRecords`, or detailed options for
   * exclude/include records
   * @param {Boolean} [options.includeFilteredOutRecords] `true` to also include filtered out records
   * @param {Boolean} [options.includeCollapsedGroupRecords] `true` to also include records from collapsed groups of
   * grouped store
   * @category Iteration
   */
  forEach(fn, thisObj = this, options) {
    const me = this,
      callback = (r, i) => {
        if (!r.isRoot && !r.isSpecialRow) {
          return fn.call(thisObj, r, i);
        }
      };
    options = fixTraverseOptions(me, options);
    if (me.isTree) {
      // forEach uses traverse() but is not perceived as a tree walk, so we want to apply our sorter
      if (me.isChained) {
        options = {
          ...options,
          sorterFn: me.sorterFn
        };
      }
      me.rootNode.traverseWhile(callback, false, options);
    } else {
      // native forEach cannot be aborted by returning false, have to loop "manually"
      const records = options.includeFilteredOutRecords ? me.storage.allValues : me.storage.values;
      // grouped store has own tree-like structure, but cannot be handled like a regular tree
      if (me.isGrouped && options.includeCollapsedGroupRecords) {
        for (let i = 0; i < records.length; i++) {
          const record = records[i],
            groupChildren = options.includeFilteredOutRecords ? record.unfilteredGroupChildren : record.groupChildren;
          if (groupChildren && record.meta.collapsed === true) {
            for (let j = 0; j < groupChildren.length; j++) {
              const rec = groupChildren[j];
              if (callback(rec, j) === false) {
                return;
              }
            }
          } else if (callback(record, i) === false) {
            return;
          }
        }
      } else {
        for (let i = 0; i < records.length; i++) {
          if (callback(records[i], i) === false) {
            return;
          }
        }
      }
    }
  }
  /**
   * Equivalent to Array.map(). Creates a new array with the results of calling a provided function on every record
   * @param {Function} fn
   * @param {Object} [thisObj] The `this` reference to call the function with. Defaults to this Store
   * @returns {Array}
   * @category Iteration
   */
  map(fn, thisObj = this) {
    return this.storage.values.map(fn, thisObj);
  }
  /**
   * Equivalent to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap Array.flatMap()}.
   * Creates a new array by spreading the results of calling a provided function on every record
   * @param {Function} fn A function returning an array of items to be spread into the new array, or a single item to include in it
   * @param {Object} [thisObj] The `this` reference to call the function with. Defaults to this Store
   * @returns {Array} The new array
   * @category Iteration
   */
  flatMap(fn, thisObj = this) {
    return this.storage.values.flatMap(fn, thisObj);
  }
  /**
   * Equivalent to Array.every(). Returns `true` if every call of the provided function
   * on each record yields a truthy value.
   * @param {Function} fn
   * @param {Function} fn.record The record to test.
   * @param {Object} [thisObj] The `this` reference to call the function with. Defaults to this Store.
   * @param {Boolean} [ignoreFilters] Pass `true` to iterate all records including filtered out ones.
   * @returns {Array}
   * @category Iteration
   */
  every(fn, thisObj = this, ignoreFilters) {
    return this.storage[ignoreFilters ? 'allValues' : 'values'].every(fn, thisObj);
  }
  /**
   * Equivalent to Array.reduce(). Applies a function against an accumulator and each record (from left to right) to
   * reduce it to a single value.
   * @param {Function} fn
   * @param {*} initialValue
   * @param {Object} [thisObj] The `this` reference to call the function with. Defaults to this Store
   * @returns {*}
   * @category Iteration
   */
  reduce(fn, initialValue = [], thisObj = this) {
    if (thisObj !== this) {
      fn = fn.bind(thisObj);
    }
    return this.storage.values.reduce(fn, initialValue, thisObj);
  }
  /**
   * Iterator that allows you to do for (let record of store)
   * @category Iteration
   */
  [Symbol.iterator]() {
    return this.storage.values[Symbol.iterator]();
  }
  /**
   * Traverse all tree nodes (only applicable for Tree Store)
   * @param {Function} fn The function to call on visiting each node.
   * @param {Core.data.Model} [topNode=this.rootNode] The top node to start the traverse at.
   * @param {Boolean} [skipTopNode] Pass true to not call `fn` on the top node, but proceed directly to its children.
   * @param {Object|Boolean} [options] A boolean for includeFilteredOutRecords, or detailed options for exclude/include records
   * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records
   * @param {Boolean} [options.includeCollapsedGroupRecords] True to also include records from collapsed groups of grouped store
   * @param {Boolean} [options.useOrderedTree] True to traverse unsorted/unfiltered tree
   * @category Traverse
   */
  traverse(fn, topNode = this.rootNode, skipTopNode = topNode === this.rootNode, options) {
    const me = this;
    options = fixTraverseOptions(me, options);
    if (me.isTree) {
      // Allow store.traverse(fn, true) to start from rootNode
      if (typeof topNode === 'boolean') {
        skipTopNode = topNode;
        topNode = me.rootNode;
      }
      if (me.isChained) {
        const passedFn = fn;
        fn = node => {
          if (me.chainedFilterFn(node)) {
            passedFn(node);
          }
        };
      }
      topNode.traverse(fn, skipTopNode, options);
    } else {
      me.forEach(rec => rec.traverse(fn, false, options), me, options);
    }
  }
  /**
   * Traverse all tree nodes while the passed `fn` returns true
   * @param {Function} fn The function to call on visiting each node. Returning `false` from it stops the traverse.
   * @param {Core.data.Model} [topNode=this.rootNode] The top node to start the traverse at.
   * @param {Boolean} [skipTopNode] Pass true to not call `fn` on the top node, but proceed directly to its children.
   * @param {Object} [options] An options object to exclude/include records
   * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records
   * @param {Boolean} [options.includeCollapsedGroupRecords] True to also include records from collapsed groups of grouped store
   * @category Traverse
   */
  traverseWhile(fn, topNode = this.rootNode, skipTopNode = topNode === this.rootNode, options) {
    const me = this;
    options = fixTraverseOptions(me, options);
    if (me.isTree) {
      // Allow store.traverse(fn, true) to start from rootNode
      if (typeof topNode === 'boolean') {
        skipTopNode = topNode;
        topNode = me.rootNode;
      }
      if (me.isChained) {
        const passedFn = fn;
        fn = node => {
          if (me.chainedFilterFn(node)) {
            passedFn(node);
          }
        };
      }
      topNode.traverseWhile(fn, skipTopNode, options);
    } else {
      for (const record of me.storage) {
        if (record.traverse(fn, false, options) === false) {
          break;
        }
      }
    }
  }
  /**
   * Finds the next record.
   * @param {Core.data.Model|String|Number} recordOrId Current record or its id
   * @param {Boolean} [wrap=false] Wrap at start/end or stop there
   * @param {Boolean} [skipSpecialRows=false] True to not return specialRows like group headers
   * @returns {Core.data.Model} Next record or null if current is the last one
   * @category Traverse
   */
  getNext(recordOrId, wrap = false, skipSpecialRows = false) {
    const me = this,
      records = me.storage.values;
    let idx = me.indexOf(recordOrId);
    if (idx >= records.length - 1) {
      if (wrap) {
        idx = -1;
      } else {
        return null;
      }
    }
    const record = records[idx + 1];
    // Skip the result if it's a specialRow and we are told to skip them
    if (skipSpecialRows && record && record.isSpecialRow) {
      return me.getNext(records[idx + 1], wrap, true);
    }
    return record;
  }
  /**
   * Finds the previous record.
   * @param {Core.data.Model|String|Number} recordOrId Current record or its id
   * @param {Boolean} [wrap=false] Wrap at start/end or stop there
   * @param {Boolean} [skipSpecialRows=false] True to not return specialRows like group headers
   * @returns {Core.data.Model} Previous record or null if current is the last one
   * @category Traverse
   */
  getPrev(recordOrId, wrap = false, skipSpecialRows = false) {
    const me = this,
      records = me.storage.values;
    let idx = me.indexOf(recordOrId);
    if (idx === 0) {
      if (wrap) {
        idx = records.length;
      } else {
        return null;
      }
    }
    const record = records[idx - 1];
    // Skip the result if it's a specialRow and we are told to skip them
    if (skipSpecialRows && record && record.isSpecialRow && idx > 0) {
      return me.getPrev(records[idx - 1], wrap, true);
    }
    return record;
  }
  /**
   * Gets the next or the previous record. Optionally wraps from first -> last and vice versa
   * @param {String|Core.data.Model} recordOrId Record or records id
   * @param {Boolean} next Next (true) or previous (false)
   * @param {Boolean} wrap Wrap at start/end or stop there
   * @param {Boolean} [skipSpecialRows=false] True to not return specialRows like group headers
   * @returns {Core.data.Model}
   * @category Traverse
   * @internal
   */
  getAdjacent(recordOrId, next = true, wrap = false, skipSpecialRows = false) {
    return next ? this.getNext(recordOrId, wrap, skipSpecialRows) : this.getPrev(recordOrId, wrap, skipSpecialRows);
  }
  /**
   * Finds the next record among leaves (in a tree structure)
   * @param {Core.data.Model|String|Number} recordOrId Current record or its id
   * @param {Boolean} [wrap] Wrap at start/end or stop there
   * @returns {Core.data.Model} Next record or null if current is the last one
   * @category Traverse
   * @internal
   */
  getNextLeaf(recordOrId, wrap = false) {
    const me = this,
      records = me.leaves,
      record = me.getById(recordOrId);
    let idx = records.indexOf(record);
    if (idx >= records.length - 1) {
      if (wrap) {
        idx = -1;
      } else {
        return null;
      }
    }
    return records[idx + 1];
  }
  /**
   * Finds the previous record among leaves (in a tree structure)
   * @param {Core.data.Model|String|Number} recordOrId Current record or its id
   * @param {Boolean} [wrap] Wrap at start/end or stop there
   * @returns {Core.data.Model} Previous record or null if current is the last one
   * @category Traverse
   * @internal
   */
  getPrevLeaf(recordOrId, wrap = false) {
    const me = this,
      records = me.leaves,
      record = me.getById(recordOrId);
    let idx = records.indexOf(record);
    if (idx === 0) {
      if (wrap) {
        idx = records.length;
      } else {
        return null;
      }
    }
    return records[idx - 1];
  }
  /**
   * Gets the next or the previous record among leaves (in a tree structure). Optionally wraps from first -> last and
   * vice versa
   * @param {String|Core.data.Model} recordOrId Record or record id
   * @param {Boolean} [next] Next (true) or previous (false)
   * @param {Boolean} [wrap] Wrap at start/end or stop there
   * @returns {Core.data.Model}
   * @category Traverse
   * @internal
   */
  getAdjacentLeaf(recordOrId, next = true, wrap = false) {
    return next ? this.getNextLeaf(recordOrId, wrap) : this.getPrevLeaf(recordOrId, wrap);
  }
  //endregion
}

Store.initClass();
Store._$name = 'Store';

/**
 * @module Core/data/AjaxStore
 */
/**
 * Http methods used by the AjaxStore in restful mode.
 * @typedef {Object} HttpMethods
 * @property {'POST'|'PUT'} create
 * @property {'GET'|'POST'} read
 * @property {'PATCH'|'POST'|'PUT'} update
 * @property {'DELETE'|'POST'} delete
 */
const processParamEntry = (paramArray, entry) => {
    if (Array.isArray(entry[1])) {
      entry[1].forEach(value => paramArray.push(encodeURIComponent(entry[0]) + '=' + encodeURIComponent(value)));
    } else {
      paramArray.push(encodeURIComponent(entry[0]) + '=' + encodeURIComponent(entry[1]));
    }
    return paramArray;
  },
  immediatePromise$2 = Promise.resolve(),
  prependZeros = num => {
    return String(num).padStart(2, '0');
  },
  dateToString = date => {
    return `${date.getFullYear()}-${prependZeros(date.getMonth() + 1)}-${prependZeros(date.getDate())}T${prependZeros(date.getHours())}:${prependZeros(date.getMinutes())}:${prependZeros(date.getSeconds())}.${date.getMilliseconds()}`;
  };
/**
 * Store that uses the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) to read data
 * from a remote server, and optionally sends synchronization requests to the server containing information about
 * locally created, modified and deleted records.
 *
 * ## Create
 * Posts array of JSON data for newly added records to {@link #config-createUrl}, expects response containing an array
 * of JSON objects in same order with id set (uses Model#idField as id).
 *
 * ## Read
 * Reads array of JSON data from the data packet returned from the {@link #config-readUrl}. Unique id for each row is
 * required.
 *
 * By default looks in field 'id' but can be configured by setting {@link Core.data.Model#property-idField-static}.
 *
 * ## Update
 * Posts array of JSON data containing modified records to {@link #config-updateUrl}. By default, only changed fields
 * and any fields configured with {@link Core.data.field.DataField#config-alwaysWrite} are sent.
 * If you want all fields to always be sent, please see {@link #config-writeAllFields}
 *
 * ## Delete
 * Posts to {@link #config-deleteUrl} with removed records ids (for example id=1,4,7).
 *
 * ```javascript
 * new AjaxStore({
 *   createUrl  : 'php/create',
 *   readUrl    : 'php/read',
 *   updateUrl  : 'php/update',
 *   deleteUrl  : 'php/delete',
 *   modelClass : Customer
 * });
 * ```
 *
 * ## Pagination
 * Configuring an `AjaxStore` with {@link #config-pageParamName} or {@link #config-pageStartParamName} means that the
 * store requests **pages** of data from the remote source, sending the configured {@link #config-pageParamName} or
 * {@link #config-pageStartParamName} to request the page along with the {@link #config-pageSizeParamName}.
 *
 * If `pageParamName` is set, that is passed with the requested page number **(one based)**, along with the
 * {@link #config-pageSizeParamName}.
 *
 * If `pageStartParamName` is set, that is passed with the requested page starting record index **(zero based)**, along
 * with the {@link #config-pageSizeParamName}.
 *
 * ## Remote filtering
 * To specify that filtering is the responsibility of the server, configure the store with
 * `{@link #config-filterParamName}: 'nameOfFilterParameter'`
 *
 * When this is set, any {@link Core.data.mixin.StoreFilter#function-filter} operation causes the store to reload
 * itself, encoding the filters as JSON representations in the {@link #config-filterParamName} HTTP parameter.
 *
 * The filters will look like this:
 * ```javascript
 * {
 *     "field": "country",
 *     "operator": "=",
 *     "value": "sweden",
 *     "caseSensitive": false
 * }
 * ```
 *
 * If the value of the filter is a date - it is serialized as a local time, using the format: `YYYY-MM-DDThh:mm:ss.ms`
 *
 * The encoding may be overridden by configuring an implementation of {@link #function-encodeFilterParams}
 * into the store which returns the value for the {@link #config-filterParamName} when passed an _Iterable_ of filters.
 *
 * ## Remote sorting
 * To specify that sorting is the responsibility of the server, configure the store with
 * `{@link #config-sortParamName}: 'nameOfSortParameter'`
 *
 * When this is set, any {@link Core.data.mixin.StoreSort#function-sort} operation causes the store to
 * reload itself, encoding the sorters as JSON representations in the {@link #config-sortParamName} HTTP
 * parameter.
 *
 * The sorters will look like this:
 * ```javascript
 * {
 *     "field": "name",
 *     "ascending": true
 * }
 * ```
 *
 * The encoding may be overridden by configuring an implementation of {@link #function-encodeSorterParams}
 * into the store which returns the value for the {@link #config-sortParamName} when passed an _Iterable_ of sorters.
 *
 * ## Passing HTTP headers
 * As mentioned above `AjaxStore` uses the Fetch API under the hood. Specify {@link #config-fetchOptions} and/or
 * {@link #config-headers} to have control over the options passed with all fetch calls. For example to pass along an
 * authorization header:
 *
 * ```javascript
 * const store = new AjaxStore({
 *    headers : {
 *        Authorization : 'auth-contents-goes-here'
 *    }
 * });
 * ```
 *
 * Learn more about the Fetch API over at [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch).
 *
 * @extends Core/data/Store
 */
class AjaxStore extends Store {
  static $name = 'AjaxStore';
  // region Events
  /**
   * Fired when a remote request fails, either at the network level, or the server returns a failure, or an invalid
   * response.
   *
   * Note that when a {@link #function-commit} fails, more than one exception event will be triggered. The individual
   * operation, `create`, `update` or `delete` will trigger their own `exception` event, but the encapsulating commit
   * operation will also trigger an `exception` event when all the operations have finished, so if exceptions are
   * going to be handled gracefully, the event's `action` property must be examined, and the constituent operations of
   * the event must be examined.
   * @event exception
   * @param {Core.data.Store} source This Store
   * @param {Boolean} exception `true`
   * @param {'create'|'read'|'update'|'delete'|'commit'} action Action that failed, `'create'`, `'read'`,
   * `'update'` or `'delete'`. May also be fired with '`commit'` to indicate the failure of an aggregated `create`,
   * `update` and `delete` operation. In this case, the event will contain a property for each operation of the commit
   * named `'create'`, `'update'` and `'delete'`, each containing the individual `exception` events.
   * @param {'network'|'failure'} exceptionType The type of failure, `'network'` or `'server'`
   * @param {Response} response the `Response` object
   * @param {Object} json The decoded response object *if the exceptionType is `'server'`*
   */
  /**
   * Fired after committing added records
   * @event commitAdded
   * @param {Core.data.Store} source This Store
   */
  /**
   * Fired after committing modified records
   * @event commitModified
   * @param {Core.data.Store} source This Store
   */
  /**
   * Fired on successful load
   * @event load
   * @param {Core.data.Store} source This Store
   * @param {Object[]} data Data loaded
   * @param {Response} response the `Response` object
   * @param {Object} json The decoded response object.
   */
  /**
   * Fired on successful load of remote child nodes for a tree node.
   * @event loadChildren
   * @param {Core.data.Store} source This Store
   * @param {Object[]} data Data loaded
   * @param {Object} json The decoded response object.
   */
  /**
   * Fired after committing removed records
   * @event commitRemoved
   * @param {Core.data.Store} source This Store
   */
  /**
   * Fired before loading starts. Allows altering parameters and is cancelable
   * @event beforeLoad
   * @preventable
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax request.
   */
  /**
   * Fired before loading of remote child nodes of a tree node starts. Allows altering parameters and is cancelable
   * @event beforeLoadChildren
   * @preventable
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax request.
   */
  /**
   * When the store {@link #property-isPaged is paged}, this is fired before loading a page and is cancelable
   * @event beforeLoadPage
   * @preventable
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax request.
   */
  /**
   * Fired when loading is beginning. This is not cancelable. Parameters in the event may still be
   * mutated at this stage.
   * @event loadStart
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax request.
   */
  /**
   * Fired when loading of remote child nodes into a tree node is beginning. This is not cancelable. Parameters in the
   * event may still be mutated at this stage.
   * @event loadChildrenStart
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax request.
   */
  /**
   * Fired before any remote request is initiated.
   * @event beforeRequest
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing key/value pairs that are passed on the request query string
   * @param {Object} body The body of the request to be posted to the server.
   * @param {'create'|'read'|'update'|'delete'} action Action that is making the request, `'create'`,
   * `'read'`, `'update'` or `'delete'`
   */
  /**
   * Fired after any remote request has finished whether successfully or unsuccessfully.
   * @event afterRequest
   * @param {Boolean} exception `true`. *Only present if the request triggered an exception.*
   * @param {'create'|'read'|'update'|'delete'} action Action that has finished, `'create'`, `'read'`,
   * `'update'` or `'delete'`
   * @param {'network'|'failure'} exceptionType The type of failure, `'network'` or `'server'`. *Only present
   * if the request triggered an exception.*
   * @param {Response} response The `Response` object
   * @param {Object} json The decoded response object if there was no `'network'` exception.
   */
  // endregion
  //region Config
  static get defaultConfig() {
    return {
      /**
       * A string keyed object containing the HTTP headers to add to each server request issued by this store.
       *
       * `AjaxStore` uses the Fetch API under the hood, read more about headers on
       * [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#headers)
       *
       * Example usage:
       *
       * ```javascript
       * const store = new AjaxStore({
       *    headers : {
       *        Authorization : 'auth-contents-goes-here'
       *    }
       * });
       * ```
       *
       * @config {Object<String,String>}
       * @category Remote
       */
      headers: null,
      /**
       * An object containing the Fetch options to pass to each server request issued by this store. Use this to
       * control if credentials are sent and other options, read more at
       * [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#supplying_request_options).
       *
       * Example usage:
       *
       * ```javascript
       * const store = new AjaxStore({
       *    fetchOptions : {
       *        credentials : 'omit',
       *        redirect    : 'error'
       *    }
       * });
       * ```
       *
       * @config {Object}
       * @category Remote
       */
      fetchOptions: null,
      /**
       * Specify `true` to send payloads as form data, `false` to send as regular JSON.
       * @config {Boolean}
       * @default false
       * @category Remote
       */
      sendAsFormData: null,
      /**
       * Specify `true` to send all model fields when committing modified records (as opposed to just the
       * modified fields)
       * @config {Boolean}
       * @default false
       * @category Remote
       */
      writeAllFields: null,
      /**
       * The name of the HTTP parameter passed to this Store's {@link #config-readUrl} to indicate the node `id`
       * to load when loading child nodes on demand if the node being expanded was created with data containing
       * `children: true`.
       * @config {String}
       * @default
       * @category Remote
       */
      parentIdParamName: 'id',
      /**
       * The optional property name in JSON responses from the server that contains a boolean
       * success/fail status.
       * ```json
       * {
       *   "responseMeta" : {
       *   {
       *     "success" : true,
       *     "count" : 100
       *   },
       *   // The property name used here should match that of 'responseDataProperty'
       *   "data" : [
       *     ...
       *   ]
       * }
       * ```
       *
       * The store would be configured with:
       * ```javascript
       *  {
       *      ...
       *      successDataProperty : 'responseMeta.success',
       *      responseTotalProperty : 'responseMeta.count'
       *      ...
       *  }
       *
       * ```
       * @config {String}
       * @default
       * @category Remote
       */
      responseSuccessProperty: 'success',
      /**
       * The property name in JSON responses from the server that contains the data for the records
       * ```json
       * {
       *   "success" : true,
       *   // The property name used here should match that of 'responseDataProperty'
       *   "data" : [
       *     ...
       *   ]
       * }
       * ```
       * @config {String}
       * @default
       * @category Remote
       */
      responseDataProperty: 'data',
      /**
       * The property name in JSON responses from the server that contains the dataset total size
       * **when this store {@link #property-isPaged is paged}**
       * ```json
       * {
       *   "success" : true,
       *   // The property name used here should match that of 'responseDataProperty'
       *   "data" : [
       *     ...
       *   ],
       *   // The property name used here should match that of 'responseTotalProperty'
       *   "total" : 65535
       * }
       * ```
       * @config {String}
       * @default
       * @category Remote
       */
      responseTotalProperty: 'total',
      /**
       * The name of the HTTP parameter to use to pass any encoded filters when loading data from the server and a
       * filtered response is required.
       *
       * **Note:** When this is set, filters must be defined using a field name, an operator and a value
       * to compare, **not** a comparison function.
       * @config {String}
       * @category Remote
       */
      filterParamName: null,
      /**
       * Set this flag to true if you are filtering remote using restful URLs (e.g.
       * https://nominatim.openstreetmap.org/search/paris?format=json)
       *
       * **Note:** When this is set, the filter string is appended to the readUrl.
       * @config {Boolean}
       * @category Remote
       */
      restfulFilter: false,
      /**
       * The name of the HTTP parameter to use to pass any encoded sorters when loading data from the server and a
       * sorted response is required.
       *
       * **Note:** When this is set, sorters must be defined using a field name and an ascending flag,
       * **not** a sort function.
       * @config {String}
       * @category Remote
       */
      sortParamName: null,
      /**
       * The name of the HTTP parameter to use when requesting pages of data using the **one based** page number
       * required.
       * @config {String}
       * @category Paging
       */
      pageParamName: null,
      /**
       * The name of the HTTP parameter to use when requesting pages of data using the **zero based** index of the
       * required page's starting record.
       * @config {String}
       * @category Paging
       */
      pageStartParamName: null,
      /**
       * The name of the HTTP parameter to use when requesting pages of data using the **zero based** index of the
       * required page's starting record.
       * @config {String}
       * @default
       * @category Paging
       */
      pageSizeParamName: 'pageSize',
      /**
       * When paging of data is requested by setting _either_ the {@link #config-pageParamName} _or_ the
       * {@link #config-pageStartParamName}, this is the value to send in the {@link #config-pageSizeParamName}.
       * @config {Number}
       * @default
       * @category Paging
       */
      pageSize: 50,
      /**
       * Set to true to use restful {@link #config-httpMethods}
       * @config {Boolean}
       * @default false
       * @category Remote
       */
      useRestfulMethods: null,
      /**
       * The HTTP methods to use for CRUD requests when {@link #config-useRestfulMethods} is enabled.
       *
       * ```javascript
       * new AjaxStore({
       *    useRestfulMethods : true,
       *    httpMethods : {
       *        create : 'POST',
       *        read   : 'POST',
       *        update : 'PATCH',
       *        delete : 'DELETE'
       *    }
       * });
       *
       * ```
       * @config {HttpMethods}
       * @default
       * @category Remote
       */
      httpMethods: {
        create: 'POST',
        read: 'GET',
        update: 'PUT',
        delete: 'DELETE'
      }
    };
  }
  static get configurable() {
    return {
      /**
       * An object containing key/value pairs that are passed on the request query string.
       * @member {Object} params
       * @category Remote
       */
      /**
       * An object containing key/value pairs that are passed on the request query string.
       * @config {Object}
       * @category Remote
       */
      params: null
    };
  }
  /**
   * Url to post newly created records to.
   *
   * The response must be in the form:
   *
   *     {
   *         "success": true,
   *         "data": [{
   *             "id": 0, "name": "General Motors"
   *         }, {
   *             "id": 1, "name": "Apple"
   *         }]
   *     }
   *
   * Just the array of data may be returned, however that precludes the orderly handling of errors encountered at the
   * server.
   *
   * If the server encountered an error, the packet would look like this:
   *
   *     {
   *         "success": false,
   *         "message": "Some kind of database error"
   *     }
   *
   * And that packet would be available in the {@link #event-exception} handler in the `response` property of the
   * event.
   *
   * The `success` property may be omitted, it defaults to `true`.
   *
   * @prp {String} createUrl
   * @category CRUD
   */
  /**
   * Url to read data from.
   *
   * The response must be in the form:
   *
   *     {
   *         "success": true,
   *         "data": [{
   *             "id": 0, "name": "General Motors"
   *         }, {
   *             "id": 1, "name": "Apple"
   *         }]
   *     }
   *
   * If the store {@link #property-isPaged is paged}, the total dataset size must be returned in the
   * {@link #config-responseTotalProperty} property:
   *
   *     {
   *         "success": true,
   *         "data": [{
   *             "id": 0, "name": "General Motors"
   *         }, {
   *             "id": 1, "name": "Apple"
   *         }],
   *         "total": 65535
   *     }
   *
   * Just the array of data may be returned, however that precludes the orderly handling of errors encountered at the
   * server.
   *
   * If the server encountered an error, the packet would look like this:
   *
   *     {
   *         "success": false,
   *         "message": "Some kind of database error"
   *     }
   *
   * And that packet would be available in the {@link #event-exception} handler in the `response` property of the
   * event.
   *
   * The `success` property may be omitted, it defaults to `true`.
   *
   * @prp {String} readUrl
   * @category CRUD
   */
  /**
   * Url to post record modifications to.
   *
   * The response must be in the form:
   *
   *     {
   *         "success": true,
   *         "data": [{
   *             "id": 0, "name": "General Motors"
   *         }, {
   *             "id": 1, "name": "Apple"
   *         }]
   *     }
   *
   * Just the array of data may be returned, however that precludes the orderly handling of errors encountered at the
   * server.
   *
   * If the server encountered an error, the packet would look like this:
   *
   *     {
   *         "success": false,
   *         "message": "Some kind of database error"
   *     }
   *
   * And that packet would be available in the {@link #event-exception} handler in the `response` property of the
   * event.
   *
   * The `success` property may be omitted, it defaults to `true`.
   *
   * @prp {String} updateUrl
   * @category CRUD
   */
  /**
   * Url for deleting records.
   *
   * The response must be in the form:
   *
   *     {
   *         "success": true
   *     }
   *
   * If the server encountered an error, the packet would look like this:
   *
   *     {
   *         "success": false,
   *         "message": "Some kind of database error"
   *     }
   *
   * And that packet would be available in the {@link #event-exception} handler in the `response` property of the
   * event.
   *
   * The `success` property may be omitted, it defaults to `true`.
   *
   * @prp {String} deleteUrl
   * @category CRUD
   */
  /**
   * True to initiate a load when the store is instantiated
   * @config {Boolean} autoLoad
   * @category Common
   */
  //endregion
  afterConstruct(config) {
    super.afterConstruct(config);
    if (this.autoLoad) {
      this.load().catch(() => {});
    }
  }
  /**
   * Returns a truthy value if the Store is currently loading.
   *
   * A load operation is initiated by a load call, but the network request is not sent until
   * after a delay until the next event loop because of allowing all operations which may
   * request a load to coalesce into one call.
   *
   * If the loading request is in this waiting state, the value will be `1`,
   *
   * If the network request is in flight, the value will be `2`
   * @property {Boolean|Number}
   * @readonly
   * @category CRUD
   */
  get isLoading() {
    return this._isLoading ? 2 : this.loadTriggerPromise ? 1 : false;
  }
  /**
   * Returns true if the Store is currently committing
   * @property {Boolean}
   * @readonly
   * @category CRUD
   */
  get isCommitting() {
    return Boolean(this.commitPromise);
  }
  set pageParamName(pageParamName) {
    if (this.tree) {
      throw new Error('Paging cannot be supported for tree stores');
    }
    if (this.pageStartParamName) {
      throw new Error('Configs pageStartParamName and pageParamName are mutually exclusive');
    }
    this._pageParamName = pageParamName;
  }
  get pageParamName() {
    return this._pageParamName;
  }
  set pageStartParamName(pageStartParamName) {
    if (this.tree) {
      throw new Error('Paging cannot be supported for tree stores');
    }
    if (this.pageParamName) {
      throw new Error('Configs pageParamName and pageStartParamName are mutually exclusive');
    }
    this._pageStartParamName = pageStartParamName;
  }
  get pageStartParamName() {
    return this._pageStartParamName;
  }
  /**
   * Yields true if this Store is loaded page by page. This yields `true` if either of the
   * {@link #config-pageParamName} of {@link #config-pageStartParamName} configs are set.
   * @property {Boolean}
   * @readonly
   * @category Paging
   */
  get isPaged() {
    return this.pageParamName || this.pageStartParamName;
  }
  /**
   * Yields the complete dataset size. If the store is {@link #property-isPaged is paged} this is the value
   * returned in the last loaded data block in the {@link #config-responseTotalProperty} property. Otherwise it is
   * the number of records in the store's underlying storage collection.
   * @property {Number}
   * @readonly
   * @category Paging
   */
  get allCount() {
    return 'remoteTotal' in this ? this.remoteTotal : super.allCount;
  }
  /**
   * **If the store {@link #property-isPaged is paged}**, yields the highest page number in the dataset as calculated
   * from the {@link #config-responseTotalProperty}
   * returned in the last page data block loaded.
   * @property {Number}
   * @readonly
   * @category Paging
   */
  get lastPage() {
    if (this.isPaged) {
      return Math.floor((this.allCount + this.pageSize - 1) / this.pageSize);
    }
  }
  buildQueryString(url, ...paramObjects) {
    const hasParamsInUrl = url.includes('?'),
      queryString = Object.entries(Object.assign({}, ...paramObjects)).reduce(processParamEntry, []).join('&');
    return queryString ? (hasParamsInUrl ? '&' : '?') + queryString : '';
  }
  /**
   * Internal sort method.
   * Should not be used in application code directly.
   * @param silent
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @internal
   */
  async performSort(silent) {
    const me = this;
    if (me.remoteSort && !me.isRemoteDataLoading) {
      me.isRemoteDataLoading = true;
      const result = await me.internalLoad({}, '', event => {
        me.data = event.data;
        me.afterPerformSort(silent);
      });
      me.isRemoteDataLoading = false;
      return result;
    } else {
      super.performSort(silent);
    }
  }
  /**
   * Internal filter method.
   * Should not be used in application code directly.
   * @param silent
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @internal
   */
  async performFilter(silent) {
    const me = this;
    // For remote filtering, the dataset cannot be preserved. The size may be completely different.
    // This is a reload operation.
    if (me.remoteFilter) {
      var _me$loadingPromise;
      (_me$loadingPromise = me.loadingPromise) === null || _me$loadingPromise === void 0 ? void 0 : _me$loadingPromise.abort();
      // Flag store data loading state to not get into loop when data is sorted internally after request
      me.isRemoteDataLoading = true;
      const oldCount = me.count,
        {
          filters
        } = me;
      // load should default to page 1
      me.currentPage = 1;
      const result = await me.internalLoad({}, '', event => {
        me.data = event.data;
        event = silent ? null : {
          action: 'filter',
          filters,
          oldCount,
          records: me.storage.values
        };
        me.afterPerformFilter(event);
        me.trigger('refresh', event);
      });
      me.isRemoteDataLoading = false;
      return result;
    } else {
      super.performFilter(silent);
    }
  }
  /**
   * A provided function which creates an array of values for the {@link #config-filterParamName} to pass
   * any filters to the server upon load.
   *
   * By default, this creates a JSON string containing the following properties:
   *
   * ```javascript
   *    [{
   *        field         : <theFieldName>
   *        operator      : May be: `'='`, `'!='`, `'>'`, `'>='`, `'<'`, `'<='`, `'*'`, `'startsWith'`, `'endsWith'`
   *        value         : The value to compare
   *        caseSensitive : true for case sensitive comparisons
   *    }]
   * ```
   * @param {Core.util.CollectionFilter[]} filters The filters to encode.
   */
  encodeFilterParams(filters) {
    const result = [];
    for (const {
      property,
      operator,
      value,
      caseSensitive
    } of filters) {
      result.push({
        field: property,
        operator,
        value,
        caseSensitive
      });
    }
    return JSON.stringify(result, function (key, value) {
      return key === '' ? value : this[key] instanceof Date ? dateToString(this[key]) : value;
    });
  }
  /**
   * A provided function which creates an array of values for the {#config-sortParamName} to pass
   * any sorters to the server upon load.
   *
   * By default, this creates a JSON string containing the following properties:
   *
   * ```javascript
   *    [{
   *        field     : <theFieldName>
   *        ascending : true/false
   *    }]
   * ```
   *
   * @param {Sorter[]} sorters The sorters to encode.
   */
  encodeSorterParams(sorters) {
    return JSON.stringify(sorters.filter(sorter => !sorter.sortFn).map(sorter => sorter));
  }
  buildReadUrl() {
    const {
      readUrl
    } = this;
    if (this.restfulFilter && this.filters.count) {
      const url = readUrl.endsWith('/') ? readUrl : readUrl + '/';
      return url + this.filters.first.value;
    }
    return readUrl;
  }
  /**
   * Internal data loading method.
   * @returns {Promise}
   * @internal
   */
  internalLoad(params, eventName, successFn, delay = 0) {
    // Accumulate all configured parameters
    params = ObjectHelper.assign({}, this.params, params);
    const me = this,
      url = me.buildReadUrl(),
      event = {
        action: 'read' + eventName,
        params,
        url
      };
    if (!url) {
      throw new Error('No load url specified');
    }
    if (me.trigger('beforeLoad' + eventName, event) === false) {
      throw false; // eslint-disable-line no-throw-literal
    }

    me.loadArgs = [url, event, params, eventName, successFn];
    if (delay === false) {
      return new Promise((resolve, reject) => me.sendLoadRequest(resolve, reject));
    }
    return me.loadTriggerPromise || (me.loadTriggerPromise = new Promise((resolve, reject) => {
      me.setTimeout({
        delay,
        fn: 'sendLoadRequest',
        args: [resolve, reject],
        cancelOutstanding: true
      });
    }));
  }
  // Send the request for the internalLoad.
  // This is called on a timeout 1ms after the internalLoad call.
  async sendLoadRequest(resolve, reject) {
    const me = this,
      [url, event, params, eventName, successFn] = me.loadArgs;
    // As soon as it kicks off, new load requests can be made which will result in another load
    me.loadTriggerPromise = null;
    if (url) {
      me._isLoading = true;
      // This may look redundant, but it allows for two levels of event listening.
      // Granular, where the observer observes only the events of interest, and
      // catch-all, where the observer is interested in all requests.
      me.trigger(`load${eventName}Start`, event);
      me.trigger('beforeRequest', event);
      // Add filter information to the request parameters
      if (me.filterParamName && me.isFiltered) {
        params[me.filterParamName] = me.encodeFilterParams(me.filters.values);
      }
      // Add sorter information to the request parameters.
      // isSorted includes grouping in its evaluation.
      if (me.remoteSort && me.isSorted) {
        params[me.sortParamName] = me.encodeSorterParams(me.groupers ? me.groupers.concat(me.sorters) : me.sorters);
      }
      // Ensure our next page is passed to the server in the params if not already set.
      // Ensure our page size is always passed.
      if (me.isPaged) {
        if (!(me.pageParamName in params || me.pageStartParamName in params)) {
          const page = Math.min(me.currentPage || 1, me.allCount ? me.lastPage : Infinity);
          if (me.pageParamName) {
            params[me.pageParamName] = page;
          } else {
            params[me.pageStartParamName] = (page - 1) * me.pageSize;
          }
        }
        params[me.pageSizeParamName] = me.pageSize;
      }
      const options = {
        headers: me.headers,
        parseJson: true
      };
      if (me.useRestfulMethods) {
        options.method = me.httpMethods.read;
        // user might define body in case of using custom restful method
        if (event.body) {
          options.body = JSON.stringify(event.body);
        }
      }
      try {
        const promise = me.loadingPromise = AjaxHelper.get(event.url + me.buildQueryString(event.url, params), ObjectHelper.assign(options, me.fetchOptions)),
          response = await promise,
          data = response.parsedJson,
          isArray = Array.isArray(data),
          success = isArray || data && ObjectHelper.getPath(data, me.responseSuccessProperty) !== false,
          remoteTotal = isArray ? null : ObjectHelper.getPath(data, me.responseTotalProperty);
        if (me.isDestroyed) {
          return;
        }
        me.loadingPromise = null;
        me._isLoading = false;
        event.response = response;
        event.json = data;
        if (success) {
          if (remoteTotal != null) {
            me.remoteTotal = parseInt(remoteTotal, 10);
          }
          // If we are issuing paged requests, work out what page we are on based
          // on the requested page and the size of the dataset declared.
          if (me.isPaged) {
            if (me.remoteTotal >= 0) {
              const requestedPage = me.pageParamName ? params[me.pageParamName] : params[me.pageStartParamName] / me.pageSize + 1;
              me.currentPage = Math.min(requestedPage, me.lastPage);
            } else {
              throw new Error('A paged store must receive its responseTotalProperty in each data packet');
            }
          }
          event.data = isArray ? data : ObjectHelper.getPath(data, me.responseDataProperty);
          await successFn(event);
          !me.isDestroyed && me.trigger('load' + eventName, event);
          resolve(event);
        } else {
          Object.assign(event, {
            exception: true,
            exceptionType: 'server',
            error: data === null || data === void 0 ? void 0 : data.error
          });
          !me.isDestroyed && me.trigger('exception', event);
          reject(event);
        }
        // finally
        !me.isDestroyed && me.trigger('afterRequest', event);
      } catch (responseOrError) {
        me._isLoading = false;
        event.exception = true;
        if (responseOrError instanceof Response) {
          event.exceptionType = responseOrError.ok ? 'server' : 'network';
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = 'server';
          event.error = responseOrError;
        }
        !me.isDestroyed && me.trigger('exception', event);
        reject(event);
        // finally
        !me.isDestroyed && me.trigger('afterRequest', event);
      }
    }
  }
  /**
   * Load data from the {@link #config-readUrl}.
   * @param {Object} [params] A hash of parameters to append to querystring (will also append Store#params)
   * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is
   * vetoed by a {@link #event-beforeLoad} handler, or if an {@link #event-exception} is detected.
   * The resolved function is passed the event object passed to any event handlers.
   * The rejected function is passed the {@link #event-exception} event if an exception occurred,
   * or `false` if the load was vetoed by a {@link #event-beforeLoad} handler.
   * @fires beforeLoad
   * @fires loadStart
   * @fires beforeRequest
   * @fires load
   * @fires exception
   * @fires afterRequest
   * @category CRUD
   */
  async load(params) {
    const me = this;
    if (me.isPaged) {
      return me.loadPage(me.currentPage || 1, params);
    } else {
      return me.internalLoad(params, '', event => {
        // The set Data setter will trigger the refresh event with { action: 'dataset' }
        me.data = event.data;
      });
    }
  }
  /**
   * Loads children into specified parent record. Parent records id is sent as a param (param name configured with
   * {@link #config-parentIdParamName}.
   * @param {Core.data.Model} parentRecord Parent record
   * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is
   * vetoed by a {@link #event-beforeLoadChildren} handler, or if an {@link #event-exception} is detected.
   * The resolved function is passed the event object passed to any event handlers.
   * The rejected function is passed the {@link #event-exception} event if an exception occurred,
   * or `false` if the load was vetoed by a {@link #event-beforeLoadChildren} handler.
   * @fires beforeLoadChildren
   * @fires loadChildrenStart
   * @fires beforeRequest
   * @fires loadChildren
   * @fires exception
   * @fires afterRequest
   * @category CRUD
   */
  async loadChildren(parentRecord) {
    // Immediate call to sendLoadRequest because we can make multiple, concurrent requests
    // to load many tree nodes at once, so pass delay parameter as false.
    return this.readUrl ? this.internalLoad({
      [this.parentIdParamName]: parentRecord.id
    }, 'Children', event => {
      event.parentRecord = parentRecord;
      if (parentRecord.children.length) {
        parentRecord.clearChildren(true);
      }
      // Append received children
      parentRecord.data[parentRecord.constructor.childrenField] = event.data;
      parentRecord.processChildren(parentRecord.stores);
    }, false) : this.immediatePromise;
  }
  /**
   * Loads a page of data from the {@link #config-readUrl}.
   * @param {Number} page The *one based* page number to load.
   * @param {Object} params A hash of parameters to append to querystring (will also append Store#params)
   * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is
   * vetoed by a {@link #event-beforeLoadPage} handler, or if an {@link #event-exception} is detected.
   * The resolved function is passed the event object passed to any event handlers.
   * The rejected function is passed the {@link #event-exception} event if an exception occurred,
   * or `false` if the load was vetoed by a {@link #event-beforeLoadPage} handler.
   * @fires beforeLoadPage
   * @fires loadPageStart
   * @fires beforeRequest
   * @fires loadPage
   * @fires exception
   * @fires afterRequest
   * @category CRUD
   */
  async loadPage(page, params) {
    if (this.allCount) {
      page = Math.min(page, this.lastPage);
    }
    const me = this,
      pageParam = me.pageParamName ? {
        [me.pageParamName]: page
      } : {
        [me.pageStartParamName]: (page - 1) * me.pageSize
      };
    pageParam[me.pageSizeParamName] = me.pageSize;
    return me.internalLoad(ObjectHelper.assign(pageParam, params), 'Page', event => {
      // We go directly to loadPage because paging a tree store is unsupportable.
      // loadPage will trigger the refresh event with { action: 'pageLoad' }
      me.loadData(event.data, 'pageLoad');
    });
  }
  /**
   * If this store {@link #property-isPaged is paged}, and is not already at the {@link #property-lastPage}
   * then this will load the next page of data.
   * @fires beforeLoadPage
   * @fires loadPageStart
   * @fires beforeRequest
   * @fires loadPage
   * @fires exception
   * @fires afterRequest
   * @category CRUD
   * @returns {Promise} A promise which is resolved when the Ajax request completes and has been processed.
   */
  async nextPage(params) {
    const me = this;
    return me.isPaged && me.currentPage !== me.lastPage ? me.loadPage(me.currentPage + 1, params) : immediatePromise$2;
  }
  /**
   * If this store {@link #property-isPaged is paged}, and is not already at the first page
   * then this will load the previous page of data.
   * @fires beforeLoadPage
   * @fires loadPageStart
   * @fires beforeRequest
   * @fires loadPage
   * @fires exception
   * @fires afterRequest
   * @category CRUD
   * @returns {Promise} A promise which is resolved when the Ajax request completes and has been processed.
   */
  async previousPage(params) {
    return this.isPaged && this.currentPage !== 1 ? this.loadPage(this.currentPage - 1, params) : immediatePromise$2;
  }
  /**
   * Commits all changes (added, modified and removed) using corresponding urls ({@link #config-createUrl},
   * {@link #config-updateUrl} and {@link #config-deleteUrl})
   * @fires beforeCommit
   * @returns {Promise} A Promise which is resolved only if all pending changes (Create, Update and Delete)
   * successfully resolve. Both the resolve and reject functions are passed a `commitState` object which is stored the
   * {@link #event-afterRequest} event for each request. Each event contains the `exception`, `request` and `response`
   * properties eg:
   *
   * ```javascript
   * {
   *      // If *all* commits succeeded
   *      success: true,
   *      changes: {
   *          added: [records...],
   *          modified: [records...],
   *          removed: [records...],
   *      },
   *      added: {
   *          source: theStore,
   *
   *          // Only if the add request triggered an exception
   *          exception: true,
   *
   *          // Only if the add request triggered an exception
   *          exceptionType: 'server', // Or 'network'
   *
   *          response: Response,
   *          json: parsedResponseObject
   *      },
   *      // Same format as added
   *      modified: {},
   *      removed: {}
   * }
   * ```
   *
   * If there were no pending changes, the resolve and reject functions are passed no parameters.
   *
   * Returns `false` if a commit operation is already in progress.
   * The resolved function is passed the event object passed to any event handlers.
   * The rejected function is passed the {@link #event-exception} event if an exception occurred,
   * @category CRUD
   */
  async commit() {
    const me = this,
      {
        changes
      } = me,
      allPromises = [];
    // not allowing additional commits while in progress
    if (me.commitPromise) {
      return false;
    }
    // No outstanding changes, return a Promise that resolves immediately.
    if (!changes) {
      // Special handling of modified. If only non-persistable fields have been modified, it won't count among
      // `changes`, but still needs to be cleared
      if (me.modified.count) {
        me.modified.forEach(record => record.clearChanges(true, false));
        me.modified.clear();
      }
      return immediatePromise$2;
    }
    if (me.trigger('beforeCommit', {
      changes
    }) !== false) {
      // Flag all affected records as being committed
      [...changes.added, ...changes.modified, ...changes.removed].forEach(record => record.meta.committing = true);
      // Commit was not prevented in beforeCommit listener, so we begin the commit
      me.trigger('commitStart', {
        changes
      });
      const commitState = {
        action: 'commit',
        exception: false,
        changes
      };
      let p = me.commitRemoved(commitState);
      if (p) {
        allPromises.push(p);
      }
      p = me.commitAdded(commitState);
      if (p) {
        allPromises.push(p);
      }
      p = me.commitModified(commitState);
      if (p) {
        allPromises.push(p);
      }
      // If there were no urls configured, behave as a local store
      if (!allPromises.length) {
        me.modified.forEach(r => r.clearChanges(true, false));
        me.modified.clear();
        me.added.forEach(r => r.clearChanges(true, false));
        me.added.clear();
        me.removed.clear();
        me.trigger('commit', {
          changes
        });
        return immediatePromise$2;
      }
      // The Promises from the commit methods all resolve whether the request
      // succeeded or not. They each contribute their afterrequest event to the
      // commitState which can be used to detect overall success or failure
      // and granular inspection of which operations succeeded or failed.
      // If there's only one operation, wait for it.
      // If there's more than one operation, we have to wait for allPromises to resolve.
      p = allPromises.length === 1 ? allPromises[0] : Promise.all(allPromises);
      return me.commitPromise = new Promise((resolve, reject) => {
        p.then(() => {
          me.commitPromise = null;
          if (commitState.exception) {
            me.trigger('exception', commitState);
            reject(commitState);
          } else {
            me.trigger('commit', {
              changes
            });
            resolve(commitState);
          }
        }).catch(() => {
          me.commitPromise = null;
          reject(commitState);
        });
      });
    }
  }
  // Performs background autocommit with reject checking
  doAutoCommit() {
    if (this.suspendCount <= 0) {
      this.commit().catch(commitState => {
        const {
          response
        } = commitState;
        // Skip throw if response is `ok` or `status` is 500 or 404 and request is successfully parsed
        // These errors are notified by API events
        if (!(response && (response.ok && response.parsedJson || [500, 404].includes(response.status)))) {
          throw commitState;
        }
      });
    }
  }
  /**
   * Commits added records by posting to {@link #config-createUrl}.
   * Server should return a JSON object with a 'success' property indicating whether the operation was successful.
   * @param {Object} commitState An object into which is added a `delete` property being the
   * {@link #event-afterRequest} event.
   * @returns {Promise|null} If there are added records, a Promise which will be resolved whether the commit
   * succeeds or fails. The resulting event is placed into the `add` property of the passed `commitState`
   * parameter. If there are no added records, `null` is returned.
   * The resolved function is passed the event object passed to any event handlers.
   * @async
   * @private
   * @fires beforeRequest
   * @fires commitAdded
   * @fires refresh
   * @fires exception
   * @fires afterRequest
   */
  commitAdded(commitState) {
    const me = this,
      added = me.added,
      event = {
        action: 'create',
        params: me.params
      };
    return added.count && me.createUrl ? new Promise(resolve => {
      const toAdd = added.values.map(r => r.persistableData);
      commitState.create = event;
      event.body = {
        data: toAdd
      };
      me.trigger('beforeRequest', event);
      let dataToSend = event.body;
      if (me.sendAsFormData) {
        const formData = new FormData();
        formData.append('data', JSON.stringify(toAdd));
        dataToSend = formData;
      }
      const options = {
          headers: me.headers,
          parseJson: true
        },
        url = me.createUrl + me.buildQueryString(me.createUrl, me.params);
      if (me.useRestfulMethods) {
        options.method = me.httpMethods.create;
      }
      AjaxHelper.post(url, dataToSend, ObjectHelper.assign(options, me.fetchOptions)).then(response => {
        const data = response.parsedJson,
          isArray = Array.isArray(data),
          success = isArray || data && data.success !== false;
        commitState.response = response;
        event.json = data;
        event.response = response;
        if (success) {
          // Copy updated fields and updated ID back into records.
          // This also calls clearChanges on each record.
          me.processReturnedData(added.values, isArray ? data : ObjectHelper.getPath(data, me.responseDataProperty));
          // Clear down added records cache
          added.clear();
          me.trigger('commitAdded');
          // We must signal a full refresh because any number of records could have received any number of field updates
          // back from the server, so a refresh is more efficient than picking through the received updates.
          me.trigger('refresh', event);
          resolve(commitState);
        } else {
          // Clear committing flag
          added.forEach(r => r.meta.committing = false);
          commitState.exception = event.exception = true;
          commitState.exceptionType = event.exceptionType = 'server';
          me.trigger('exception', event);
          resolve(commitState);
        }
        // finally
        me.trigger('afterRequest', event);
      }).catch(responseOrError => {
        // Clear committing flag
        added.forEach(r => r.meta.committing = false);
        commitState.exception = event.exception = true;
        if (responseOrError instanceof Response) {
          commitState.response = responseOrError;
          event.exceptionType = responseOrError.ok ? 'server' : 'network';
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = 'server';
          event.error = responseOrError;
        }
        me.trigger('exception', event);
        resolve(commitState);
        // finally
        me.trigger('afterRequest', event);
      });
    }) : null;
  }
  /**
   * Commits modified records by posting to {@link #config-updateUrl}.
   * Server should return a JSON object with a 'success' property indicating whether the operation was successful.
   * @param {Object} commitState An object into which is added a `delete` property being the
   * {@link #event-afterRequest} event.
   * @returns {Promise|null} If there are added records, a Promise which will be resolved whether the commit
   * succeeds or fails. The resulting event is placed into the `update` property of the passed `commitState`
   * parameter. If there are no added records, `null` is returned.
   * The resolved function is passed the event object passed to any event handlers.
   * @async
   * @private
   * @fires beforeRequest
   * @fires commitModified
   * @fires refresh
   * @fires exception
   * @fires afterRequest
   */
  commitModified(commitState) {
    const me = this,
      // Only include persistable changes
      {
        modified
      } = me.changes,
      event = {
        action: 'update',
        params: me.params
      },
      result = modified.length && me.updateUrl ? new Promise(resolve => {
        // Use the record's modificationData, not modifications.
        // modifications returns a map using *field names*
        // The server will expect a map using the original dataSource properties.
        const modifications = modified.map(record => {
          if (me.writeAllFields) {
            return record.persistableData;
          } else {
            return record.modificationDataToWrite;
          }
        }).filter(el => !ObjectHelper.isEmpty(el));
        // Check if modifications are empty and don't make request
        if (modifications.length === 0) {
          me.modified.clear();
          modified.forEach(r => r.meta.committing = false);
          resolve();
          return;
        }
        commitState.update = event;
        event.body = {
          data: modifications
        };
        me.trigger('beforeRequest', event);
        let dataToSend = event.body;
        if (me.sendAsFormData) {
          const formData = new FormData();
          formData.append('data', JSON.stringify(modifications));
          dataToSend = formData;
        }
        const options = {
          headers: me.headers,
          parseJson: true
        };
        if (me.useRestfulMethods) {
          options.method = me.httpMethods.update;
        }
        AjaxHelper.post(me.updateUrl + me.buildQueryString(me.updateUrl, me.params), dataToSend, ObjectHelper.assign(options, me.fetchOptions)).then(response => {
          const data = response.parsedJson,
            isArray = Array.isArray(data),
            success = isArray || data && data.success !== false;
          commitState.response = response;
          event.json = data;
          event.response = response;
          if (success) {
            // Copy updated fields and updated ID back into records.
            // This also calls clearChanges on each record.
            me.processReturnedData(modified, isArray ? data : ObjectHelper.getPath(data, me.responseDataProperty), true);
            // Clear down modified records cache
            me.modified.clear();
            me.trigger('commitModified');
            // We must signal a full refresh because any number of records could have received any number of
            // field updates back from the server, so a refresh is more efficient than picking through the
            // received updates.
            me.trigger('refresh', event);
            resolve(commitState);
          } else {
            // Clear committing flag
            modified.forEach(r => r.meta.committing = false);
            commitState.exception = event.exception = true;
            event.exceptionType = 'server';
            me.trigger('exception', event);
            resolve(commitState);
          }
          // finally
          me.trigger('afterRequest', event);
        }).catch(responseOrError => {
          // Clear committing flag
          modified.forEach(r => r.meta.committing = false);
          commitState.exception = event.exception = true;
          if (responseOrError instanceof Response) {
            commitState.response = responseOrError;
            event.exceptionType = responseOrError.ok ? 'server' : 'network';
            event.response = responseOrError;
            event.error = responseOrError.error;
          } else {
            event.exceptionType = 'server';
            event.error = responseOrError;
          }
          me.trigger('exception', event);
          resolve(commitState);
          // finally
          me.trigger('afterRequest', event);
        });
      }) : null;
    // Also clear non-persistable changes
    if (!modified.length && me.modified.count) {
      me.modified.clear();
    }
    return result;
  }
  processReturnedData(localRecords, returnedData, isUpdating = false) {
    const me = this,
      Model = me.modelClass,
      idDataSource = Model.fieldMap.id.dataSource;
    returnedData.forEach((recData, i) => {
      const record = localRecords[i];
      // Must clear changed state before syncId goes through store.onModelChange
      record.clearChanges(true, false);
      // Using syncId to update record's id with no flagging the property as modified.
      record.syncId(recData[idDataSource]);
      // When updating, only want to apply the actual changes and not reapply defaults. When adding, also
      // apply the defaults
      Object.assign(localRecords[i].data, Model.processData(recData, isUpdating, me, record));
    });
  }
  /**
   * Commits removed records by posting to {@link #config-deleteUrl}.
   * Server should return a JSON object with a 'success' property indicating whether the operation was successful.
   * @param {Object} commitState An object into which is added a `delete` property being the
   * {@link #event-afterRequest} event.
   * @returns {Promise|null} If there are added records, a Promise which will be resolved whether the commit
   * succeeds or fails. The resulting event is placed into the `delete` property of the passed `commitState`
   * parameter. If there are no added records, `null` is returned.
   * The resolved function is passed the event object passed to any event handlers.
   * @async
   * @private
   * @fires beforerequest
   * @fires commitremoved
   * @fires refresh
   * @fires exception
   * @fires afterrequest
   */
  commitRemoved(commitState) {
    const me = this,
      removed = me.removed,
      event = {
        action: 'delete',
        params: me.params
      };
    return removed.count && me.deleteUrl ? new Promise(resolve => {
      commitState.delete = event;
      event.body = {
        ids: removed.map(r => r.id)
      };
      me.trigger('beforeRequest', event);
      let dataToSend = event.body;
      if (me.sendAsFormData) {
        const formData = new FormData();
        formData.append('id', JSON.stringify(dataToSend.ids));
        dataToSend = formData;
      }
      const options = {
        headers: me.headers,
        parseJson: true
      };
      if (me.useRestfulMethods) {
        options.method = me.httpMethods.delete;
      }
      AjaxHelper.post(me.deleteUrl + me.buildQueryString(me.deleteUrl, me.params), dataToSend, ObjectHelper.assign(options, me.fetchOptions)).then(response => {
        const data = response.parsedJson,
          isArray = Array.isArray(data),
          success = isArray || data && data.success !== false;
        commitState.response = response;
        event.json = data;
        event.response = response;
        if (success) {
          removed.forEach(record => record.meta.committing = false); // In case used by other store etc.
          removed.clear();
          me.trigger('commitRemoved');
          me.trigger('refresh', event);
          resolve(commitState);
        } else {
          // Clear committing flag
          removed.forEach(r => r.meta.committing = false);
          commitState.exception = event.exception = true;
          event.exceptionType = 'server';
          me.trigger('exception', event);
          resolve(commitState);
        }
        // finally
        me.trigger('afterRequest', event);
      }).catch(responseOrError => {
        // Clear committing flag
        removed.forEach(r => r.meta.committing = false);
        commitState.exception = event.exception = true;
        if (responseOrError instanceof Response) {
          commitState.response = responseOrError;
          event.exceptionType = responseOrError.ok ? 'server' : 'network';
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = 'server';
          event.error = responseOrError;
        }
        me.trigger('exception', event);
        resolve(commitState);
        // finally
        me.trigger('afterRequest', event);
      });
    }) : null;
  }
  get remoteFilter() {
    return Boolean(this.filterParamName || this.restfulFilter);
  }
  get remoteSort() {
    return Boolean(this.sortParamName);
  }
}
AjaxStore._$name = 'AjaxStore';

/**
 * @module Core/data/DomDataStore
 */
/**
 * Stores data on a dom element (by setting element._domData).
 * Instead of using HTML5:s element.dataset, which turned out to be slow.
 * @internal
 */
class DomDataStore {
  /**
   * Get data that is connected to specified element.
   * @param {HTMLElement} element DOM element
   * @param {String} [key] The name of the property in the element data to return
   * @returns {Object} Data
   */
  static get(element, key) {
    const result = element._domData || (element._domData = {});
    return key != null ? result[key] : result;
  }
  /**
   * Remove data connected to specified element.
   * @param {HTMLElement} element DOM element
   * @param {String} key The name of the property in the element data to remove.
   */
  static remove(element, key) {
    const {
        _domData
      } = element,
      was = _domData === null || _domData === void 0 ? void 0 : _domData[key];
    _domData === null || _domData === void 0 ? true : delete _domData[key];
    return was;
  }
  /**
   * Set data connected to specified element (completely replacing any existing).
   * To update data, use DomDataStore#assign instead.
   * @param {HTMLElement} element DOM element
   * @param {Object|String} data Data object to set, or property name to set
   * @param {*} [value] If the previous parameter was a property name, this is the value to set.
   */
  static set(element, data, value) {
    if (arguments.length === 3) {
      (element._domData || (element._domData = {}))[data] = value;
    } else {
      element._domData = data;
    }
  }
  /**
   * Updates data connected to specified element.
   * @param {HTMLElement} element DOM element
   * @param {Object} data Data to assign
   */
  static assign(element, data) {
    Object.assign(element._domData || (element._domData = {}), data);
  }
}
DomDataStore._$name = 'DomDataStore';

/**
 * @module Core/helper/CSSHelper
 */
/**
 * Provides methods to add and manipulate CSS style rules.
 *
 * Note that this class is incompatible with [CSP](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)
 *
 * ```javascript
 * this.criticalRule = CSSHelper.insertRule(`#${this.id} .b-sch-event.critical {background-color:${this.criticalColor}}`);
 * ```
 */
class CSSHelper {
  /**
   * Inserts a CSS style rule based upon the passed text
   * @param {String} cssText The text of the rule including selector and rule body just as it would
   * be specified in a CSS file.
   * @returns {CSSRule} The resulting CSS Rule object if the add was successful.
   */
  static insertRule(cssText, parentElement = document.head) {
    const styleSheet = this.getStyleSheet(parentElement),
      oldCount = styleSheet.cssRules.length;
    styleSheet.insertRule(cssText, 0);
    // Only return element zero if the add was successful.
    if (styleSheet.cssRules.length > oldCount) {
      return styleSheet.cssRules[0];
    }
  }
  /**
   * Looks up the first rule which matched the passed selector.
   * @param {String|Function} selector Either the selector string to exactly match or a function which
   * when passed a required selector, returns `true`.
   * @returns {CSSRule} The first matching CSS Rule object if any found.
   */
  static findRule(selector) {
    let result;
    const isFn = typeof selector === 'function';
    // Array#find will stop when the function returns true, stop when the inner
    // find call yields a value from the search string.
    // Array#find better: to http://www.andygup.net/fastest-way-to-find-an-item-in-a-javascript-array/
    Array.prototype.find.call(document.head.querySelectorAll('link[rel=stylesheet],style[type*=css]'), element => {
      result = Array.prototype.find.call(element.sheet.rules || element.sheet.cssRules, r => {
        return isFn ? selector(r) : r.selectorText === selector;
      });
      if (result) {
        return true;
      }
    });
    return result;
  }
  static getStyleSheet(parentElement = document.head) {
    if (!parentElement.$bryntumStylesheet) {
      parentElement.$bryntumStylesheet = DomHelper.createElement({
        tag: 'style',
        id: 'bryntum-private-styles',
        type: 'text/css',
        parent: parentElement
      }).sheet;
    }
    return parentElement.$bryntumStylesheet;
  }
  /**
   * Returns current CSS version
   * @returns {String}
   * @internal
   */
  static getCSSVersion() {
    return getComputedStyle(document.documentElement).getPropertyValue('--bryntum-version').replace(/[" ]/gm, '');
  }
}
CSSHelper._$name = 'CSSHelper';

/**
 * @module Core/helper/DomSync
 */
const arraySlice = Array.prototype.slice,
  emptyArray$3 = Object.freeze([]),
  emptyObject$4 = Object.freeze({}),
  htmlRe = /[&<]/,
  // tests if setInnerText is equivalent to innerHTML
  {
    getPrototypeOf
  } = Object,
  {
    toString
  } = Object.prototype,
  {
    isEqual,
    isObject
  } = ObjectHelper,
  // Attributes used during creation that should not be compared
  checkEqualityIgnore = {
    parent: 1,
    elementData: 1,
    ns: 1,
    syncOptions: 1
  },
  makeCheckEqualityOptions = () => ({
    ignore: checkEqualityIgnore,
    refsFound: new Set()
  }),
  isClass = {
    class: 1,
    className: 1,
    classname: 1
  },
  simpleTypes = {
    bigint: 1,
    boolean: 1,
    function: 1,
    number: 1,
    // object
    string: 1,
    symbol: 1
    // undefined
  },
  // Attributes to ignore on sync
  syncIgnoreAttributes = {
    tag: 1,
    html: 1,
    text: 1,
    children: 1,
    tooltip: 1,
    parent: 1,
    nextSibling: 1,
    ns: 1,
    reference: 1,
    elementData: 1,
    retainElement: 1,
    compareHtml: 1,
    syncOptions: 1,
    listeners: 1,
    // eslint-disable-line bryntum/no-listeners-in-lib
    isReleased: 1,
    null: 1,
    '': 1,
    keepChildren: 1
  };
const addAndCacheCls = (cls, lastDomConfig) => {
  const propertyName = 'className' in lastDomConfig ? 'className' : 'class',
    propertyValue = lastDomConfig[propertyName];
  if (propertyValue) {
    if (typeof propertyValue === 'string') {
      const value = propertyValue.split(' ');
      if (!value.includes(cls)) {
        value.push(cls);
        lastDomConfig[propertyName] = value.join(' ');
      }
    } else if (Array.isArray(propertyValue)) {
      if (!propertyValue.includes(cls)) {
        propertyValue.push(cls);
      }
    } else if (propertyValue.isDomClassList) {
      propertyValue.add(cls);
    } else if (ObjectHelper.isObject(propertyValue)) {
      propertyValue[cls] = 1;
    }
  }
};
const removeAndUncacheCls = (cls, lastDomConfig) => {
  const propertyName = 'className' in lastDomConfig ? 'className' : 'class',
    propertyValue = lastDomConfig[propertyName];
  if (propertyValue) {
    if (typeof propertyValue === 'string') {
      const value = propertyValue.split(' ');
      if (value.includes(cls)) {
        value.splice(value.indexOf(cls), 1);
        lastDomConfig[propertyName] = value.join(' ');
      }
    } else if (Array.isArray(propertyValue)) {
      if (propertyValue.includes(cls)) {
        propertyValue.splice(propertyValue.indexOf(cls), 1);
      }
    } else if (propertyValue.isDomClassList) {
      propertyValue.remove(cls);
    } else if (ObjectHelper.isObject(propertyValue)) {
      delete propertyValue[cls];
    }
  }
};
/**
 * A utility class for syncing DOM config objects to DOM elements. Syncing compares the new config with the previously
 * used for that element, only applying the difference. Very much like a virtual DOM approach on a per element basis
 * (element + its children).
 *
 * Usage example:
 *
 * ```javascript
 * DomSync.sync({
 *     domConfig: {
 *         className : 'b-outer',
 *         children : [
 *             {
 *                 className : 'b-child',
 *                 html      : 'Child 1',
 *                 dataset   : {
 *                     custom : true
 *                 }
 *             },
 *             {
 *                 className : 'b-child',
 *                 html      : 'Child 2',
 *                 style     : {
 *                     fontWeight : 'bold',
 *                     color      : 'blue'
 *                 }
 *             }
 *         ]
 *     },
 *     targetElement : target
 * });
 * ```
 */
class DomSync {
  /**
   * Compares two DOM configs or properties of such objects for equality.
   * @param {Object} is The new value.
   * @param {Object} was The old value.
   * @param {Object} options An object with various options to control the comparison.
   * @param {Object} options.ignore An object containing names of attributes to ignore having `true` value.
   * @param {Map} options.equalityCache A map that can be used to record equality results for objects to avoid
   * recomputing the result for the same objects.
   * @param {Set} options.refsFound A Set that must be populated with the values of any `reference` properties found.
   * @param {Boolean|String} [ignoreRefs] Pass `true` to ignore `reference` properties on domConfigs. Pass `'children'`
   * to ignore `reference` properties only on child element configs.
   * @returns {Boolean}
   * @private
   */
  static checkEquality(is, was, options, ignoreRefs) {
    if (is === was) {
      return true;
    }
    // For purposes of DomSync, null and undefined are equivalent
    if (is == null) {
      return was == null;
    }
    if (!is || !was) {
      return false; // false since is !== was and is != null (we get here if was == null)
    }

    const typeA = typeof is,
      typeB = typeof was;
    if (typeA !== typeB || simpleTypes[typeA]) {
      // only test simpleTypes[typeA] since typeA === typeB
      return false;
    }
    // a and b are distinct objects or maybe arrays
    let cache = options.equalityCache || (options.equalityCache = new Map()),
      ignoreChildRefs = Boolean(ignoreRefs),
      equal,
      i,
      ignore,
      ignoreRefOpt,
      key,
      syncOptions,
      val;
    // We must cache results based on both sides of the comparison. If we only cache the result of "is" vs
    // any other value, we get failures in SchedulerWithAutoCommitStore.t.js
    cache = cache.get(is) || cache.set(is, new Map()).get(is);
    equal = cache.get(was);
    if (equal === undefined) {
      equal = true;
      if (getPrototypeOf(is) !== getPrototypeOf(was) || is instanceof Node) {
        // Two Nodes are not equal since they are !==
        equal = false;
      } else if (Array.isArray(is)) {
        // Since we have === prototypes, we know that "was" is also an array
        i = is.length;
        if (i !== was.length) {
          equal = false;
        } else {
          while (i-- > 0) {
            if (!DomSync.checkEquality(is[i], was[i], options, ignoreChildRefs)) {
              equal = false;
              break;
            }
          }
        }
      } else {
        var _syncOptions;
        syncOptions = is.syncOptions;
        ignoreRefOpt = (_syncOptions = syncOptions) === null || _syncOptions === void 0 ? void 0 : _syncOptions.ignoreRefs;
        if (ignoreRefOpt) {
          ignoreChildRefs = true;
          ignoreRefs = ignoreRefOpt !== 'children';
        }
        ignore = options.ignore || emptyObject$4;
        // We have 2 objects w/same prototype and that are not HTML nodes
        // https://jsbench.me/n2kgfre1r5/1 - profiles for-in-object loops vs for loop over keys array
        // fwiw, the smaller the object, the greater the benefit of for-in loop
        for (key in was) {
          if (!ignore[key] && !(key in is) && !(ignoreRefs && key === 'reference')) {
            equal = false;
            break;
          }
        }
        if (equal) {
          if (toString.call(was) === '[object Date]') {
            // Since we have === prototypes, we know that "was" is also a Date
            equal = is.getTime() === was.getTime();
          } else {
            for (key in is) {
              if (!ignore[key] && !(ignoreRefs && key === 'reference')) {
                if (!(key in was)) {
                  equal = false;
                  break;
                }
                val = is[key];
                // Per Johan:
                //  Not sure we still use DocumentFragment. Used to be part of event rendering earlier,
                //  but I think I have refactored it away. Worth checking
                //  ...
                //  Not finding any usages
                //
                // DocumentFragment, compare separately supplied html
                // if (key === 'html' && typeof val !== 'string' && `compareHtml` in is) {
                //     if (is.compareHtml === was.compareHtml) {
                //         continue;
                //     }
                // }
                if (!DomSync.checkEquality(val, was[key], options, ignoreChildRefs)) {
                  equal = false;
                  break;
                }
              }
            }
          }
        }
      }
      if (!ignoreRefs && isObject(is) && is.reference) {
        var _options$refsFound;
        // We need to track object w/reference properties to know what reference elements may have
        // been removed since we may skip synchronizing them.
        (_options$refsFound = options.refsFound) === null || _options$refsFound === void 0 ? void 0 : _options$refsFound.add(is.reference);
      }
      cache.set(was, equal);
    }
    return equal;
  }
  /**
   * Sync a DOM config to a target element
   * @param {Object} options Options object
   * @param {DomConfig} options.domConfig A DOM config object
   * @param {HTMLElement} options.targetElement Target element to apply to
   * @param {Boolean} [options.strict=false] Specify `true` to limit synchronization to only the values set by
   * previous calls. Styles and classes placed directly on the DOM elements by other means will not be affected.
   * @param {String} [options.syncIdField] Field in dataset to use to match elements for re-usage
   * @param {String|String[]} [options.affected] The references affected by a partial sync.
   * @param {Function} [options.callback] A function that will be called on element re-usage, creation and similar
   * @param {Boolean} [options.configEquality] A function that will be called to compare an incoming config to
   * the last config applied to the `targetElement`. This function returns `true` if the passed values are equal and
   * `false` otherwise.
   * @returns {HTMLElement} Returns the updated target element (which is also updated in place)
   */
  static sync(options) {
    const optionsIn = options,
      {
        refOwner
      } = options,
      refsWas = refOwner === null || refOwner === void 0 ? void 0 : refOwner.byRef,
      checkEqualityOptions = makeCheckEqualityOptions();
    let affected = options.affected,
      i,
      ref,
      targetNode,
      lastDomConfig;
    if (typeof affected === 'string') {
      affected = [affected];
    }
    // NOTE: it is possible to reenter this method in at least the following way:
    //   - sync() causes a focus change by manipulating the activeElement.
    //   - a focus/blur/focusin/out event causes a widget config to initiate a recompose.
    //   - the event also triggers code that forces the recompose to flush (e.g., by using a reference el).
    options = {
      ...options,
      checkEqualityOptions
    };
    if (refOwner) {
      // We always rebuild the byRef map on each call
      refOwner.byRef = {};
      if (affected) {
        // We need to preserve all previously rendered refs that are not going to be affected by this partial
        // update...
        for (ref in refsWas) {
          if (!affected.includes(ref)) {
            refOwner.byRef[ref] = refsWas[ref];
          }
        }
      }
      options.refsWas = refsWas;
    }
    // performSync() returns false if nothing was done because the configs were equal... we bend the rules on
    // modifying input objects so we can return this potentially important detail to our caller:
    optionsIn.changed = DomSync.performSync(options, options.targetElement);
    if (refOwner) {
      if (!affected) {
        affected = Object.keys(refsWas);
      }
      for (i = 0; i < affected.length; ++i) {
        ref = affected[i];
        targetNode = refsWas[ref];
        if (checkEqualityOptions.refsFound.has(ref) || targetNode.retainElement) {
          refOwner.byRef[ref] = targetNode;
        } else {
          lastDomConfig = targetNode.lastDomConfig;
          targetNode.remove();
          refOwner.detachRef(ref, targetNode, lastDomConfig);
        }
      }
    }
    return options.targetElement;
  }
  static performSync(options, targetElement) {
    const {
        domConfig,
        callback
      } = options,
      {
        lastDomConfig
      } = targetElement,
      configIsEqual = options.configEquality || DomSync.checkEquality;
    if (!configIsEqual(domConfig, lastDomConfig, options.checkEqualityOptions, options.ignoreRefs)) {
      if (domConfig) {
        // Sync without affecting the containing element?
        if (!domConfig.onlyChildren) {
          DomSync.syncAttributes(domConfig, targetElement, options);
          DomSync.syncContent(domConfig, targetElement);
        }
        if (!domConfig.keepChildren) {
          DomSync.syncChildren(options, targetElement);
        }
      }
      // Allow null to clear html
      else {
        targetElement.innerHTML = null;
        targetElement.syncIdMap = null;
      }
      // Cache the config on the target for future comparison
      targetElement.lastDomConfig = !(domConfig !== null && domConfig !== void 0 && domConfig.onlyChildren && lastDomConfig) ? domConfig : {
        ...lastDomConfig,
        children: domConfig.children
      };
      return true;
    } else {
      // Sync took no action, notify the world
      callback === null || callback === void 0 ? void 0 : callback({
        action: 'none',
        domConfig,
        targetElement
      });
    }
    return false;
  }
  //region Attributes
  static syncDataset(domConfig, targetElement) {
    const {
        lastDomConfig
      } = targetElement,
      sameConfig = domConfig === lastDomConfig,
      source = Object.keys(domConfig.dataset),
      target = lastDomConfig && lastDomConfig.dataset && Object.keys(lastDomConfig.dataset),
      delta = ArrayHelper.delta(source, target);
    let attr, i, name, value;
    // New attributes in dataset
    for (i = 0; i < delta.onlyInA.length; i++) {
      attr = delta.onlyInA[i];
      value = domConfig.dataset[attr];
      // Prevent data-property="null" or data-property="undefined"
      if (value != null) {
        targetElement.setAttribute(`data-${StringHelper.hyphenate(attr)}`, value);
      }
    }
    // Might have changed
    for (i = 0; i < delta.inBoth.length; i++) {
      attr = delta.inBoth[i];
      value = domConfig.dataset[attr];
      // Intentional != since dataset is always string but want numbers to match
      // noinspection EqualityComparisonWithCoercionJS
      if (sameConfig || value != lastDomConfig.dataset[attr]) {
        name = `data-${StringHelper.hyphenate(attr)}`;
        if (value == null) {
          targetElement.removeAttribute(name);
        } else {
          targetElement.setAttribute(name, value);
        }
      }
    }
    // Removed
    for (i = 0; i < delta.onlyInB.length; i++) {
      targetElement.removeAttribute(`data-${StringHelper.hyphenate(delta.onlyInB[i])}`);
    }
  }
  /**
   * Adds CSS classes to the element and to the cache.
   * @param {Core.helper.util.DomClassList|String|String[]|Object} cls
   * @param {HTMLElement} targetElement A previously DomSynced element
   * @internal
   */
  static addCls(cls, targetElement) {
    const {
      lastDomConfig
    } = targetElement;
    cls = DomClassList.normalize(cls, 'array');
    cls.forEach(cls => {
      targetElement.classList.add(cls);
      addAndCacheCls(cls, lastDomConfig);
    });
  }
  /**
   * Adds CSS classes from the element and from the cache.
   * @param {Core.helper.util.DomClassList|String|String[]|Object} cls
   * @param {HTMLElement} targetElement A previously DomSynced element
   * @internal
   */
  static removeCls(cls, targetElement) {
    const {
      lastDomConfig
    } = targetElement;
    cls = DomClassList.normalize(cls, 'array');
    cls.forEach(cls => {
      targetElement.classList.remove(cls);
      removeAndUncacheCls(cls, lastDomConfig);
    });
  }
  static syncClassList(domConfig, targetElement, lastDomConfig) {
    let cls = domConfig.className || domConfig.class,
      changed = false,
      c,
      currentClasses,
      i,
      k,
      keep,
      last;
    if (lastDomConfig) {
      // NOTE: The following reads the DOM to determine classes that may have been added by other means. This
      //  diff is only enabled when "strict" is used (see our callers)
      currentClasses = DomClassList.normalize(targetElement, 'array');
      cls = DomClassList.normalize(cls, 'object');
      last = DomClassList.normalize(lastDomConfig.className || lastDomConfig.class, 'object');
      keep = [];
      for (i = 0, k = currentClasses.length; i < k; ++i) {
        c = currentClasses[i];
        // We want to keep classes not in cls if we didn't add them last time
        if (cls[c] || !(c in last)) {
          last[c] = 1;
          keep.push(c);
        } else {
          changed = true;
        }
      }
      for (c in cls) {
        if (!last[c]) {
          keep.push(c);
          changed = true;
        }
      }
      if (!changed) {
        return;
      }
      cls = keep.join(' ');
    } else {
      cls = DomClassList.normalize(cls); // to string
    }

    targetElement.setAttribute('class', cls);
  }
  // Attributes as map { attr : value, ... }
  static getSyncAttributes(domConfig) {
    const attributes = {},
      // Attribute names, simplifies comparisons and calls to set/removeAttribute
      names = [];
    // On a first sync, there are no domConfig on the target element yet
    if (domConfig) {
      Object.keys(domConfig).forEach(attr => {
        if (!syncIgnoreAttributes[attr]) {
          const name = attr.toLowerCase();
          attributes[name] = domConfig[attr];
          names.push(name);
        }
      });
    }
    return {
      attributes,
      names
    };
  }
  static syncAttributes(domConfig, targetElement, options) {
    const {
        lastDomConfig
      } = targetElement,
      // If the same config has come through, due to configEquality, we must update all attrs.
      sameConfig = domConfig === lastDomConfig,
      sourceSyncAttrs = DomSync.getSyncAttributes(domConfig),
      // Extract attributes from elements (sourceElement might be a config)
      {
        attributes: sourceAttributes,
        names: sourceNames
      } = sourceSyncAttrs,
      {
        attributes: targetAttributes,
        names: targetNames
      } = sameConfig ? sourceSyncAttrs : DomSync.getSyncAttributes(lastDomConfig),
      // Intersect arrays to determine what needs adding, removing and syncing
      {
        onlyInA: toAdd,
        onlyInB: toRemove,
        inBoth: toSync
      } = sameConfig ? {
        onlyInA: emptyArray$3,
        onlyInB: emptyArray$3,
        inBoth: sourceNames
      } : ArrayHelper.delta(sourceNames, targetNames);
    let attr, i;
    // Add new attributes
    for (i = 0; i < toAdd.length; i++) {
      attr = toAdd[i];
      const sourceAttr = sourceAttributes[attr];
      // Style requires special handling
      if (attr === 'style' && sourceAttr != null) {
        DomHelper.applyStyle(targetElement, sourceAttr, true);
      }
      // So does dataset
      else if (attr === 'dataset') {
        DomSync.syncDataset(domConfig, targetElement);
      }
      // And class, which might be an object
      else if (isClass[attr]) {
        DomSync.syncClassList(domConfig, targetElement);
      }
      // Other attributes are set using setAttribute (since it calls toString() DomClassList works fine),
      // unless they are undefined in which case they are ignored to not get `href="undefined"` etc
      else if (sourceAttr != null) {
        targetElement.setAttribute(attr, sourceAttr);
      }
    }
    // Removed no longer used attributes
    for (i = 0; i < toRemove.length; i++) {
      targetElement.removeAttribute(toRemove[i]);
    }
    for (i = 0; i < toSync.length; i++) {
      attr = toSync[i];
      const sourceAttr = sourceAttributes[attr],
        targetAttr = targetAttributes[attr];
      // Attribute value null means remove attribute
      if (sourceAttr == null) {
        targetElement.removeAttribute(attr);
      }
      // Set all attributes that has changed, with special handling for style.
      else if (attr === 'style') {
        if (options.strict) {
          if (sameConfig) {
            DomSync.syncStyles(targetElement, sourceAttr);
          } else if (!isEqual(sourceAttr, targetAttr, true)) {
            DomSync.syncStyles(targetElement, sourceAttr, targetAttr);
          }
        } else if (sameConfig || !isEqual(sourceAttr, targetAttr, true)) {
          DomHelper.applyStyle(targetElement, sourceAttr, true);
        }
      }
      // And dataset
      else if (attr === 'dataset') {
        DomSync.syncDataset(domConfig, targetElement);
      }
      // And class, which might be an object
      else if (isClass[attr]) {
        DomSync.syncClassList(domConfig, targetElement, options.strict && targetElement.lastDomConfig);
      } else if (sameConfig || sourceAttr !== targetAttr) {
        targetElement.setAttribute(attr, sourceAttr);
      }
    }
  }
  static syncStyles(targetElement, sourceAttr, targetAttr) {
    let styles, key, value;
    if (!targetAttr) {
      styles = sourceAttr;
    } else {
      styles = {};
      // Style could be a string so we parse it to object to iterate over it's properties correctly
      sourceAttr = DomHelper.parseStyle(sourceAttr);
      targetAttr = DomHelper.parseStyle(targetAttr);
      if (sourceAttr) {
        for (key in sourceAttr) {
          value = sourceAttr[key];
          if (targetAttr[key] !== value) {
            styles[key] = value;
          }
        }
      }
      for (key in targetAttr) {
        if (!(key in sourceAttr)) {
          styles[key] = '';
        }
      }
    }
    DomHelper.applyStyle(targetElement, styles);
  }
  //endregion
  //region Content
  static syncContent(domConfig, targetElement) {
    const {
        html,
        text
      } = domConfig,
      content = text ?? html;
    targetElement.didSetTextContent = false;
    // elementData holds custom data that we want to attach to the element (not visible in dom)
    if (domConfig.elementData) {
      targetElement.elementData = domConfig.elementData;
    }
    // Apply html from config
    if (content instanceof DocumentFragment) {
      // If given a DocumentFragment, replace content with it
      if (targetElement.childNodes.length === 1 && DomHelper.getChildElementCount(targetElement) === 0 && content.childNodes.length === 1 && DomHelper.getChildElementCount(content) === 0) {
        // Syncing a textNode to a textNode? Use shortcut
        DomHelper.setInnerText(targetElement, content.firstChild.data);
      } else {
        targetElement.innerHTML = '';
        targetElement.appendChild(content);
      }
    }
    // If content is likely html we set innerHTML
    else if (html != null && htmlRe.test(html)) {
      targetElement.innerHTML = String(html); // convert numbers to strings
    } else if (content != null) {
      var _lastDomConfig$childr;
      const {
        lastDomConfig
      } = targetElement;
      // If element had children or actual html content in last sync we force innerHTML to get rid of them
      if (lastDomConfig !== null && lastDomConfig !== void 0 && (_lastDomConfig$childr = lastDomConfig.children) !== null && _lastDomConfig$childr !== void 0 && _lastDomConfig$childr.length || lastDomConfig !== null && lastDomConfig !== void 0 && lastDomConfig.html && htmlRe.test(targetElement.lastDomConfig.html)) {
        targetElement.innerHTML = content;
      }
      // Otherwise we try to update the text as cheaply as possible (node data if possible)
      else {
        DomHelper.setInnerText(targetElement, String(content));
        // syncChildren won't sync the text node, since we set it here. Instead, it will attempt to release it,
        // which we prevent using this flag
        targetElement.didSetTextContent = true;
      }
    }
  }
  static insertTextNode(text, targetElement, callback, refOwner, beforeElement = null) {
    const newNode = document.createTextNode(text);
    targetElement.insertBefore(newNode, beforeElement);
    if (refOwner) {
      newNode.$refOwnerId = refOwner.id;
    }
    callback === null || callback === void 0 ? void 0 : callback({
      action: 'newNode',
      domConfig: text,
      targetElement: newNode
    });
  }
  static insertElement(domConfig, targetElement, targetNode, refOwner, syncIdMap, syncId, options) {
    var _options$callback;
    // Create a new element
    const newElement = options.ns ? document.createElementNS(options.ns, domConfig.tag || 'svg') : document.createElement(domConfig.tag || 'div');
    // Insert (or append if no targetNode)
    targetElement.insertBefore(newElement, targetNode);
    // Sync to it
    DomSync.performSync(options, newElement);
    if (syncId != null) {
      syncIdMap[syncId] = newElement;
    }
    // ARIA. In the absence of a defined role or the element being hidden from ARIA,
    // omit unfocusable elements from the accessibility tree.
    if (!domConfig.role && !domConfig.tabIndex && !domConfig['aria-hidden'] && !DomHelper.isFocusable(newElement, true) && !newElement.htmlFor) {
      newElement.setAttribute('role', 'presentation');
    }
    if (refOwner) {
      newElement.$refOwnerId = refOwner.id;
      if (syncId) {
        newElement.$reference = syncId;
        refOwner.attachRef(syncId, newElement, domConfig);
      }
    }
    (_options$callback = options.callback) === null || _options$callback === void 0 ? void 0 : _options$callback.call(options, {
      action: 'newElement',
      domConfig,
      targetElement: newElement,
      syncId
    });
  }
  //endregion
  //region Children
  static syncChildren(options, targetElement) {
    let {
        domConfig,
        syncIdField,
        callback,
        releaseThreshold,
        configEquality,
        ns,
        refOwner,
        refsWas,
        strict,
        checkEqualityOptions,
        ignoreRefs
      } = options,
      cleanupNodes = null,
      index,
      nextNode,
      syncId;
    const syncOptions = domConfig.syncOptions || {};
    // Having specified html or text replaces all inner content, no point in syncing
    if (domConfig.html ?? domConfig.text) {
      return;
    }
    // This will affect the whole subtree since this goes into syncChildOptions (we convert 'children' to true
    // here because we are only processing the children):
    ignoreRefs = Boolean(syncOptions.ignoreRefs ?? ignoreRefs);
    if (ignoreRefs) {
      refOwner = refsWas = null;
    }
    if ('strict' in syncOptions) {
      strict = syncOptions.strict;
    }
    const
      // Always repopulate the map, since elements might get used by other syncId below
      newSyncIdMap = refOwner ? refOwner.byRef : {},
      sourceConfigs = arraySlice.call(domConfig.children || []),
      targetNodes = arraySlice.call(targetElement.childNodes),
      syncIdMap = refsWas || targetElement.syncIdMap || {},
      releasedIdMap = targetElement.releasedIdMap || {},
      nextTarget = remove => {
        // Recursive calls to performSync can teleport elements around the DOM tree (when we are given
        // the DOM nodes in the domConfig), so be sure to skip over any elements that are no longer children
        // of our targetElement
        while (targetNodes.length && targetNodes[0].parentNode !== targetElement) {
          targetNodes.shift();
        }
        return (remove ? targetNodes.shift() : targetNodes[0]) || null;
      };
    // Each level can optionally specify its own syncIdField, strict and callback, if left out parent levels will be used
    syncIdField = syncOptions.syncIdField || syncIdField;
    strict = syncOptions.strict || strict;
    callback = syncOptions.callback || callback;
    configEquality = syncOptions.configEquality || configEquality;
    // Make sure releaseThreshold 0 is respected...
    releaseThreshold = 'releaseThreshold' in syncOptions ? syncOptions.releaseThreshold : releaseThreshold;
    if (syncIdField) {
      targetElement.syncIdMap = newSyncIdMap;
    }
    // Settings to use in all syncs below
    const syncChildOptions = {
      checkEqualityOptions: checkEqualityOptions || makeCheckEqualityOptions(),
      ignoreRefs,
      refOwner,
      refsWas,
      strict,
      syncIdField,
      releaseThreshold,
      callback,
      configEquality
    };
    while (sourceConfigs.length) {
      const sourceConfig = sourceConfigs.shift();
      syncId = null;
      // Allowing null, convenient when using Array.map() to generate children
      if (!sourceConfig) {
        continue;
      }
      // React JSX, pass directly to callback
      if (DomHelper.isReactElement(sourceConfig)) {
        callback({
          jsx: sourceConfig,
          targetElement
        });
        continue;
      }
      // If a child item is an array, unroll it
      if (Array.isArray(sourceConfig)) {
        this.syncChildren({
          ...options,
          domConfig: {
            ...options.domConfig,
            children: sourceConfig
          }
        }, targetElement);
        continue;
      }
      if (sourceConfig instanceof Node) {
        nextNode = nextTarget();
        // Widgets may supply the element of another widget in their rendering... just insert it and move on
        if (sourceConfig !== nextNode) {
          targetElement.insertBefore(sourceConfig, nextNode);
        }
        index = targetNodes.indexOf(sourceConfig);
        if (index > -1) {
          targetNodes.splice(index, 1);
        }
        continue;
      }
      const isTextNode = typeof sourceConfig === 'string';
      // Used in all syncs
      syncChildOptions.domConfig = sourceConfig;
      syncChildOptions.ns = sourceConfig.ns || ns;
      if (!isTextNode) {
        // If syncIdField was supplied, we should first try to reuse element with
        // matching "id"
        if (refOwner) {
          syncId = sourceConfig.reference;
        } else if (syncIdField && sourceConfig.dataset) {
          syncId = sourceConfig.dataset[syncIdField];
        }
        // We have an id to look for
        if (syncId != null && !sourceConfig.unmatched) {
          // Find any matching element, either in use or previously released
          const syncTargetElement = syncIdMap[syncId] || releasedIdMap[syncId];
          if (syncTargetElement) {
            const {
              lastDomConfig
            } = syncTargetElement;
            // Just relink if flagged with `retainElement` (for example during dragging)
            if (syncTargetElement.retainElement) ;
            // Otherwise sync with the matched element
            else if (DomSync.performSync(syncChildOptions, syncTargetElement)) {
              var _callback;
              // Sync took some action, notify the world
              (_callback = callback) === null || _callback === void 0 ? void 0 : _callback({
                action: 'reuseOwnElement',
                domConfig: sourceConfig,
                targetElement: syncTargetElement,
                lastDomConfig,
                syncId
              });
            }
            // Since it won't sync above when flagged to be retained, we need to apply the flag here
            if (sourceConfig.retainElement) {
              syncTargetElement.retainElement = true;
            }
            // Cache the element on the syncIdMap for faster retrieval later
            newSyncIdMap[syncId] = syncTargetElement;
            // Remove target from targetElements & release tracking, no-one else is allowed to sync with it
            ArrayHelper.remove(targetNodes, syncTargetElement);
            delete releasedIdMap[syncId];
            syncTargetElement.isReleased = false;
            nextNode = nextTarget();
            if (syncTargetElement.parentNode !== targetElement || strict && syncTargetElement.nextSibling !== nextNode) {
              targetElement.insertBefore(syncTargetElement, nextNode);
            }
          } else if (strict) {
            DomSync.insertElement(sourceConfig, targetElement, nextTarget(), refOwner, newSyncIdMap, syncId, syncChildOptions);
          } else {
            // No match, move to end of queue to not steal some one else's element
            sourceConfigs.push(sourceConfig);
            // Also flag as unmatched to know that when we reach this element again
            sourceConfig.unmatched = true;
          }
          // Node handled, carry on with next one
          continue;
        }
        // Avoid polluting the config object when done
        if (sourceConfig.unmatched) {
          delete sourceConfig.unmatched;
        }
      }
      // Skip over any retained elements
      let beforeNode = null,
        targetNode = null,
        cleanupNode;
      while (!targetNode && (cleanupNode = nextTarget(true))) {
        if (refOwner) {
          // When syncing for a refOwner, foreign elements are skipped.
          if (cleanupNode.$refOwnerId !== refOwner.id) {
            continue;
          }
          if (cleanupNode.$reference) {
            // In refOwner mode we always pass strict:true, so this won't happen... but if it did, the
            // idea is that ref els do not get cleaned up until the end of the sync process.
            if (!strict) {
              continue;
            }
            // Since we want to maintain DOM order, this ref el marks the spot where to insert. We also
            // don't want to put it into cleanupNodes (see above). We cannot reuse ref els.
            beforeNode = cleanupNode;
            break;
          }
          // The element is owned by this refOwner and not assigned a reference...
          // We can reuse it
          targetNode = cleanupNode;
        } else if (!cleanupNode.retainElement) {
          targetNode = cleanupNode;
        }
        if (!targetNode) {
          (cleanupNodes || (cleanupNodes = [])).push(cleanupNode);
        }
      }
      if (beforeNode || !targetNode) {
        if (isTextNode) {
          DomSync.insertTextNode(sourceConfig, targetElement, callback, refOwner, beforeNode);
        } else {
          // Will append if beforeNode === null
          DomSync.insertElement(sourceConfig, targetElement, beforeNode, refOwner, newSyncIdMap, syncId, syncChildOptions);
        }
      }
      // We have targets left
      else {
        // Matching element tag, sync it
        if (!isTextNode && targetNode.nodeType === Node.ELEMENT_NODE && (sourceConfig.tag || 'div').toLowerCase() === targetNode.tagName.toLowerCase()) {
          var _lastDomConfig$datase, _callback2;
          const {
              lastDomConfig
            } = targetNode,
            result = DomSync.performSync(syncChildOptions, targetNode);
          // Remove reused element from release tracking
          if (syncIdField && (lastDomConfig === null || lastDomConfig === void 0 ? void 0 : (_lastDomConfig$datase = lastDomConfig.dataset) === null || _lastDomConfig$datase === void 0 ? void 0 : _lastDomConfig$datase[syncIdField]) != null) {
            const lastSyncId = lastDomConfig.dataset[syncIdField];
            delete releasedIdMap[lastSyncId];
            // Also remove from syncIdMap to not reuse again in the same sync
            delete syncIdMap[lastSyncId];
          }
          if (syncId != null) {
            newSyncIdMap[syncId] = targetNode;
          }
          targetNode.isReleased = false;
          // Only use callback if sync succeeded (anything changed)
          result && ((_callback2 = callback) === null || _callback2 === void 0 ? void 0 : _callback2({
            action: 'reuseElement',
            domConfig: sourceConfig,
            targetElement: targetNode,
            lastDomConfig,
            syncId
          }));
        }
        // Text node to text node, change text :)
        else if (isTextNode && targetNode.nodeType === Node.TEXT_NODE) {
          targetNode.data = sourceConfig;
          // Not using callback for updating text of node, have no usecase for it currently
        }
        // Not matching, replace it
        else {
          if (isTextNode) {
            DomSync.insertTextNode(sourceConfig, targetElement, callback, refOwner, targetNode);
          } else {
            // Will insert
            DomSync.insertElement(sourceConfig, targetElement, targetNode, refOwner, newSyncIdMap, syncId, syncChildOptions);
          }
          targetNode.remove();
        }
      }
    } // while (sourceConfigs.length)
    // If we have a single text node remaining, and we did set node data or textContent, we should not clean it up
    if (targetElement.didSetTextContent && targetNodes.length === 1 && targetNodes[0].nodeType === Node.TEXT_NODE) {
      return;
    }
    // Out of source nodes, remove remaining target nodes
    while (nextNode = nextTarget(true)) {
      // Any remaining nodes that belong to this refOwner need to be cleaned up. If
      // they have an assigned reference, however, they will be handled at the very
      // end of the sync process since those elements can move in the node hierarchy.
      if (!refOwner || nextNode.$refOwnerId === refOwner.id && !nextNode.$reference) {
        (cleanupNodes || (cleanupNodes = [])).push(nextNode);
      }
    }
    if (cleanupNodes) {
      DomSync.syncChildrenCleanup(targetElement, cleanupNodes, newSyncIdMap, callback, refOwner, releaseThreshold, syncIdField);
    }
  }
  static syncChildrenCleanup(targetElement, cleanupNodes, newSyncIdMap, callback, refOwner, releaseThreshold, syncIdField) {
    let releaseCount = 0,
      ref;
    for (const targetNode of cleanupNodes) {
      const {
        lastDomConfig
      } = targetNode;
      // Text nodes are always just wiped out as they are not recycled
      if (targetNode.nodeType === Element.TEXT_NODE) {
        targetNode.remove();
        continue;
      }
      // Element might be retained, hands off (for example while dragging)
      if (!targetNode.retainElement) {
        // When using syncId to reuse elements, "release" left over elements instead of removing them, up to a
        // limit specified as releaseThreshold, above which elements are removed instead
        if (!refOwner && syncIdField && (releaseThreshold == null || releaseCount < releaseThreshold)) {
          // Prevent releasing already released element
          if (!targetNode.isReleased) {
            targetNode.className = 'b-released';
            targetNode.isReleased = true;
            // Store released element in syncIdMap, to facilitate reusing it for self later
            if (lastDomConfig !== null && lastDomConfig !== void 0 && lastDomConfig.dataset) {
              if (!targetElement.releasedIdMap) {
                targetElement.releasedIdMap = {};
              }
              targetElement.releasedIdMap[lastDomConfig.dataset[syncIdField]] = targetNode;
            }
            callback === null || callback === void 0 ? void 0 : callback({
              action: 'releaseElement',
              domConfig: lastDomConfig,
              lastDomConfig,
              targetElement: targetNode
            });
            // Done after callback on purpose, to allow checking old className
            if (lastDomConfig) {
              // Make sure lastDomConfig differs even from the same domConfig applied again
              // Do not want to discard it completely since it is needed for diff when reused later
              lastDomConfig.isReleased = true;
              // To force reapply of classes on reuse
              if (lastDomConfig.className) {
                lastDomConfig.className = 'b-released';
              }
              if (lastDomConfig.class) {
                lastDomConfig.class = 'b-released';
              }
              // Same for style
              // (for elements positioned using style, when moved in a non DomSync way, aka EventDrag)
              if (lastDomConfig.style) {
                lastDomConfig.style = null;
              }
            }
          }
          releaseCount++;
        }
        // In normal sync mode, remove left overs
        else {
          targetNode.remove();
          if (refOwner) {
            ref = targetNode.$reference;
            if (ref) {
              refOwner.detachRef(ref, targetNode, lastDomConfig);
            }
          }
          // Remove from "release tracking"
          if (targetElement.releasedIdMap && syncIdField && lastDomConfig !== null && lastDomConfig !== void 0 && lastDomConfig.dataset) {
            delete targetElement.releasedIdMap[lastDomConfig.dataset[syncIdField]];
          }
          callback === null || callback === void 0 ? void 0 : callback({
            action: 'removeElement',
            domConfig: targetNode.lastDomConfig,
            lastDomConfig: targetNode.lastDomConfig,
            targetElement: targetNode
          });
        }
      } else if (syncIdField) {
        // Keep retained element in map
        if (lastDomConfig) {
          newSyncIdMap[targetNode.dataset[syncIdField]] = targetNode;
        }
      }
    }
  }
  /**
   * Remove a child element without syncing, for example when dragging an element to some other parent.
   * Removes it both from DOM and the parent elements syncMap
   * @param {HTMLElement} parentElement
   * @param {HTMLElement} childElement
   */
  static removeChild(parentElement, childElement) {
    if (parentElement.contains(childElement)) {
      const syncIdMap = parentElement.syncIdMap;
      if (syncIdMap) {
        const index = Object.values(syncIdMap).indexOf(childElement);
        if (index > -1) {
          delete syncIdMap[Object.keys(syncIdMap)[index]];
        }
      }
      parentElement.removeChild(childElement);
    }
  }
  /**
   * Adds a child element without syncing, making it properly available for later syncs. Useful for example
   * when dragging and dropping an element from some other parent.
   * @param {HTMLElement} parentElement
   * @param {HTMLElement} childElement
   * @param {String|Number} syncId
   */
  static addChild(parentElement, childElement, syncId) {
    parentElement.appendChild(childElement);
    if (!parentElement.syncIdMap) {
      parentElement.syncIdMap = {};
    }
    parentElement.syncIdMap[syncId] = childElement;
  }
  /**
   * Get a child element using a dot separated syncIdMap path.
   *
   * ```javascript
   * DomSync.getChild(eventWrap, 'event.percentBar');
   * ```
   *
   * @param {HTMLElement} element "root" element, under which the path starts
   * @param {String} path Dot '.' separated path of syncIdMap entries
   * @returns {HTMLElement} Child element or `null` if path did not match any element
   */
  static getChild(element, path) {
    const syncIds = String(path).split('.');
    for (const id of syncIds) {
      var _element, _element$syncIdMap;
      element = (_element = element) === null || _element === void 0 ? void 0 : (_element$syncIdMap = _element.syncIdMap) === null || _element$syncIdMap === void 0 ? void 0 : _element$syncIdMap[id];
      if (!element) {
        return null;
      }
    }
    return element;
  }
  //endregion
}

DomSync._$name = 'DomSync';

/**
 * @module Core/helper/util/Fullscreen
 */
/**
 * Encapsulates the functionality related to switching cross-browser to full screen view and back.
 */
class Fullscreen {
  static init() {
    const fnNames = ['fullscreenEnabled', 'requestFullscreen', 'exitFullscreen', 'fullscreenElement'],
      // turns fnNames into function calls to prefixed functions, fullscreenEnabled -> document.mozFullscreenEnabled
      prefixFn = prefix => fnNames.map(fn => {
        let result = prefix + StringHelper.capitalize(fn);
        // fullscreenEnabled in Firefox is called fullScreenEnabled
        if (prefix === 'moz') {
          result = result.replace('screen', 'Screen');
          // #6555 - Crash when clicking full screen button twice
          // firefox doesn't support exitFullScreen method
          if ('mozCancelFullScreen' in document && fn === 'exitFullscreen') {
            result = 'mozCancelFullScreen';
          }
        }
        return result;
      });
    this.functions = 'fullscreenEnabled' in document && fnNames || 'webkitFullscreenEnabled' in document && prefixFn('webkit') || 'mozFullScreenEnabled' in document && prefixFn('moz') || 'msFullscreenEnabled' in document && prefixFn('ms') || [];
    const eventNames = ['fullscreenchange', 'fullscreenerror'],
      msEventNames = ['MSFullscreenChange', 'MSFullscreenError'],
      prefixEvt = prefix => eventNames.map(eventName => prefix + StringHelper.capitalize(eventName));
    this.events = 'fullscreenEnabled' in document && eventNames || 'webkitFullscreenEnabled' in document && prefixEvt('webkit') || 'mozFullscreenEnabled' in document && prefixEvt('moz') || 'msFullscreenEnabled' in document && msEventNames || [];
    this.onFullscreenChange(this.onInternalFullscreenChange.bind(this));
  }
  /**
   * True if the fullscreen mode is supported and enabled, false otherwise
   * @property {Boolean}
   */
  static get enabled() {
    return Boolean(this.functions[0] && document[this.functions[0]]);
  }
  /**
   * Request entering the fullscreen mode.
   * @param {HTMLElement} element Element to be displayed fullscreen
   * @returns {Promise} A promise which is resolved with a value of undefined when the transition to full screen is complete.
   */
  static async request(element) {
    return this.functions[1] && (element === null || element === void 0 ? void 0 : element[this.functions[1]]());
  }
  /**
   * Exit the previously entered fullscreen mode.
   * @returns {Promise} A promise which is resolved once the user agent has finished exiting full-screen mode
   */
  static async exit() {
    return this.functions[2] && document[this.functions[2]]();
  }
  /**
   * True if fullscreen mode is currently active, false otherwise
   * @property {Boolean}
   */
  static get isFullscreen() {
    return !!this.element;
  }
  static get element() {
    return this.functions[3] && document[this.functions[3]];
  }
  /**
   * Installs the passed listener to fullscreenchange event
   * @param {Function} fn The listener to install
   */
  static onFullscreenChange(fn) {
    if (this.events[0]) {
      document.addEventListener(this.events[0], fn);
    }
  }
  /**
   * Uninstalls the passed listener from fullscreenchange event
   * @param {Function} fn
   */
  static unFullscreenChange(fn) {
    if (this.events[0]) {
      document.removeEventListener(this.events[0], fn);
    }
  }
  // Make sure the floatRoot is added to any element going fullscreen
  static onInternalFullscreenChange() {
    const me = this,
      {
        element: fullscreenElement
      } = me;
    if (fullscreenElement) {
      if (!fullscreenElement.closest('.b-floatroot')) {
        const rootElement = DomHelper.getRootElement(fullscreenElement),
          {
            floatRoot
          } = rootElement;
        if (floatRoot) {
          me._floatRoot = floatRoot;
          me._oldParent = floatRoot.parentElement;
          fullscreenElement.appendChild(floatRoot);
        }
      }
    } else {
      if (me._floatRoot) {
        me._oldParent.appendChild(me._floatRoot);
      }
      me._oldParent = null;
      me._floatRoot = null;
    }
  }
}
Fullscreen.init();
Fullscreen._$name = 'Fullscreen';

/* globals ResizeObserver: true */
let resizeFireTimer = null;
const resizedQueue = [],
  isAbsolutelyPositioned = n => {
    var _n$ownerDocument$defa;
    return n.nodeType === n.ELEMENT_NODE && ((_n$ownerDocument$defa = n.ownerDocument.defaultView) === null || _n$ownerDocument$defa === void 0 ? void 0 : _n$ownerDocument$defa.getComputedStyle(n).getPropertyValue('position')) === 'absolute';
  };
/**
 * @module Core/helper/ResizeMonitor
 */
/**
 * Allows size monitoring of elements (or optionally a Window instance).
 *
 * ```javascript
 * ResizeMonitor.addResizeListener(
 *   myElement,
 *   element => {
 *      console.log(element, ' changed size');
 *   }
 * );
 * ```
 *
 * @internal
 */
class ResizeMonitor {
  /**
   * Adds a resize listener to the passed element which is called when the element
   * is resized by layout.
   * @param {HTMLElement} element The element to listen for resizing.
   * @param {Function} handler The handling function. Will be passed the element.
   */
  static addResizeListener(element, handler) {
    const me = this;
    if (element === document || element === globalThis) {
      element = document.body;
    }
    if (element.nodeType === element.DOCUMENT_FRAGMENT_NODE) {
      element = element.host;
    }
    if (!element.classList.contains('b-resize-monitored')) {
      element.classList.add('b-resize-monitored');
      element._bResizemonitor = {
        handlers: []
      };
    }
    // If we're looking at the document body, use a window resize listener.
    if (element === document.body) {
      if (!me.hasWindowResizeListener) {
        globalThis.addEventListener('resize', me.onWindowResize);
        me.hasWindowResizeListener = true;
      }
    }
    // Regular element - use ResizeObserver by preference
    else if (globalThis.ResizeObserver) {
      if (!me.resizeObserver) {
        me.resizeObserver = new ResizeObserver(me.onElementResize);
      }
      me.resizeObserver.observe(element);
    }
    // Polyfill ResizeObserver
    else {
      element.classList.add('b-no-resizeobserver');
      const [monitors, expand, shrink] = DomHelper.createElement({
        parent: element,
        className: 'b-resize-monitors',
        children: [{
          className: 'b-resize-monitor-expand'
        }, {
          className: 'b-resize-monitor-shrink'
        }]
      }, {
        returnAll: true
      });
      expand.scrollLeft = expand.scrollTop = shrink.scrollLeft = shrink.scrollTop = 1000000;
      expand.addEventListener('scroll', me.onSizeMonitorScroll, true);
      shrink.addEventListener('scroll', me.onSizeMonitorScroll, true);
      // Also need to fake a resize-scroll on DOM mutation
      (handler.targetMutationMonitor = new MutationObserver(m => {
        const addedNodes = [],
          removedNodes = [];
        // MutationObserver may report a mutation which consists of removing a node and adding it back again.
        // We need to filter such nodes
        for (const mr of m) {
          if (mr.type === 'childList') {
            addedNodes.push.apply(addedNodes, mr.addedNodes);
            removedNodes.push.apply(removedNodes, mr.removedNodes);
          }
        }
        const changedNodes = [...addedNodes.filter(r => !removedNodes.includes(r)), ...removedNodes.filter(r => !addedNodes.includes(r))];
        if (changedNodes.length === 0) {
          return;
        }
        // If the changed nodes were absolutely positioned, then they won't
        // cause a resize, so return
        if (changedNodes.length > 0 && changedNodes.every(isAbsolutelyPositioned)) {
          return;
        }
        // We only want the size monitor listener to trigger, so this event must NOT bubble
        // to any application or other framework listeners.
        expand.dispatchEvent(new CustomEvent('scroll', {
          bubbles: false
        }));
      })).observe(element, {
        childList: true,
        subtree: true
      });
      // store reference for easier cleanup later
      handler.monitorElement = monitors;
    }
    element._bResizemonitor.handlers.push(handler);
  }
  /**
   * Removes a resize listener from the passed element.
   * @param {HTMLElement} element The element to listen for resizing.
   * @param {Function} handler The handling function to remove.
   */
  static removeResizeListener(element, handler) {
    if (element) {
      if (element === document || element === globalThis) {
        element = document.body;
      }
      const resizeMonitor = element._bResizemonitor;
      let listenerCount = 0;
      if (resizeMonitor && resizeMonitor.handlers) {
        ArrayHelper.remove(resizeMonitor.handlers, handler);
        // See if we should unobserve the element
        listenerCount = resizeMonitor.handlers.length;
      }
      // Down to no listeners.
      if (!listenerCount) {
        element.classList.remove('b-resize-monitored');
        if (this.resizeObserver) {
          this.resizeObserver.unobserve(element);
        }
        // Remove the polyfill resize listeners
        else {
          // remove any added elements
          if (handler.monitorElement) {
            handler.monitorElement.remove();
            handler.monitorElement = null;
          }
          // remove the DOM mutation observer
          if (handler.targetMutationMonitor) {
            handler.targetMutationMonitor.disconnect();
          }
        }
      }
    }
  }
  static onElementResize(entries) {
    for (const resizeObserverEntry of entries) {
      const resizedElement = resizeObserverEntry.target,
        resizeMonitor = resizedElement._bResizemonitor,
        newRect = resizeObserverEntry.contentRect || resizedElement.getBoundingClientRect();
      if (hasLayout(resizedElement)) {
        if (!resizeMonitor.rectangle || newRect.width !== resizeMonitor.rectangle.width || newRect.height !== resizeMonitor.rectangle.height) {
          const oldRect = resizeMonitor.rectangle;
          resizeMonitor.rectangle = newRect;
          for (const resizeHandler of resizeMonitor.handlers) {
            resizeHandler(resizedElement, oldRect, newRect);
          }
        }
      }
    }
  }
  static onSizeMonitorScroll(e) {
    var _document$body;
    // If no body exists or the element has gone, ignore the event; the listener will be removed automatically.
    if ((_document$body = document.body) !== null && _document$body !== void 0 && _document$body.contains(e.target)) {
      e.stopImmediatePropagation();
      const monitorNode = e.target.parentNode,
        resizedElement = monitorNode.parentNode,
        resizeMonitor = resizedElement._bResizemonitor,
        newRect = resizedElement.getBoundingClientRect();
      if (!resizeMonitor.rectangle || newRect.width !== resizeMonitor.rectangle.width || newRect.height !== resizeMonitor.rectangle.height) {
        resizedQueue.push([resizedElement, resizeMonitor.rectangle, newRect]);
        resizeMonitor.rectangle = newRect;
        if (!resizeFireTimer) {
          resizeFireTimer = requestAnimationFrame(ResizeMonitor.fireResizeEvents);
        }
      }
      monitorNode.firstChild.scrollLeft = monitorNode.firstChild.scrollTop = monitorNode.childNodes[1].scrollTop = monitorNode.childNodes[1].scrollLeft = 1000000;
    }
  }
  static onWindowResize(e) {
    const resizedElement = document.body,
      resizeMonitor = resizedElement._bResizemonitor,
      oldRect = resizeMonitor.rectangle;
    resizeMonitor.rectangle = document.documentElement.getBoundingClientRect();
    for (const resizeHandler of resizeMonitor.handlers) {
      resizeHandler(resizedElement, oldRect, resizeMonitor.rectangle);
    }
  }
  static fireResizeEvents() {
    for (const resizedEntry of resizedQueue) {
      for (const resizeHandler of resizedEntry[0]._bResizemonitor.handlers) {
        // Checking offsetParent to avoid resizing of elements which are not visible or exist in DOM
        if (resizedEntry[0].offsetParent) {
          resizeHandler.apply(this, resizedEntry);
        }
      }
    }
    resizeFireTimer = null;
    resizedQueue.length = 0;
  }
  static removeGlobalListeners() {
    globalThis.removeEventListener('resize', this.onWindowResize);
  }
}
ResizeMonitor._$name = 'ResizeMonitor';

/**
 * @module Core/helper/util/Scroller
 */
const scrollLiterals = {
    auto: 'auto',
    true: 'auto',
    false: 'hidden',
    'hidden-scroll': 'auto',
    clip: BrowserHelper.supportsOverflowClip ? 'clip' : 'hidden'
  },
  scrollerCls = 'b-widget-scroller',
  defaultScrollOptions = {
    block: 'nearest'
  },
  immediatePromise$1 = Promise.resolve(),
  scrollPromise = element => new Promise(resolve => EventHelper.on({
    element: element === document.documentElement ? globalThis : element,
    scroll: resolve,
    once: true
  })),
  xAxis = {
    x: 1
  },
  isScrollable = {
    auto: 1,
    scroll: 1
  },
  isScrollableConfig = {
    true: 1,
    auto: 1
  },
  allScroll = {
    overflowX: 'auto',
    overflowY: 'auto'
  },
  normalizeEdgeOffset = edgeOffset => {
    let top, bottom, start, end;
    if (!edgeOffset) {
      top = bottom = start = end = 0;
    } else if (typeof edgeOffset === 'number') {
      top = bottom = start = end = edgeOffset;
    } else {
      top = edgeOffset.top ?? 0;
      bottom = edgeOffset.bottom ?? 0;
      start = edgeOffset.start ?? 0;
      end = edgeOffset.end ?? 0;
    }
    return {
      top,
      bottom,
      start,
      end
    };
  };
/**
 * Animation options for scrolling.
 *
 * @typedef {Object} AnimateScrollOptions
 * @property {Number} [duration] The number of milliseconds to animate over.
 * @property {String} [easing] The name of an easing function.
 * */
/**
 * Options accepted by some scroll functions. Note that not all options are valid for all functions.
 *
 * @typedef {Object} ScrollOptions
 * @property {'start'|'end'|'center'|'nearest'} [block] How far to scroll the element.
 * @property {Number} [edgeOffset] edgeOffset A margin around the element or rectangle to bring into view.
 * @property {AnimateScrollOptions|Boolean|Number} [animate] Set to `true` to animate the scroll by 300ms,
 * or the number of milliseconds to animate over, or an animation config object.
 * @property {Boolean|Function} [highlight] Set to `true` to highlight the element when it is in view.
 * May be a function which is called passing the element, to provide customized highlighting.
 * @property {Boolean} [focus] Set to `true` to focus the element when it is in view.
 * @property {Boolean} [x] Pass as `false` to disable scrolling in the `X` axis.
 * @property {Boolean} [y] Pass as `false` to disable scrolling in the `Y` axis.
 * @property {String} [column] **Only applies for certain scroll functions in Grid-based products**. Field name or ID of
 * the column, or the Column instance to scroll to.
 * @property {Boolean} [extendTimeAxis=true] **Only applies when scrolling an event into view in Scheduler**. By
 * default, if the requested event is outside the time axis, the time axis is extended.
 */
/**
 * Encapsulates scroll functionality for a Widget. All requests for scrolling and scrolling information
 * must go through a Widget's {@link Core.widget.Widget#config-scrollable} property.
 * @mixes Core/mixin/Events
 * @mixes Core/mixin/Delayable
 * @extends Core/Base
 */
class Scroller extends Delayable(Events(Base)) {
  static get configurable() {
    return {
      /**
       * The widget which is to scroll.
       * @config {Core.widget.Widget}
       */
      widget: null,
      /**
       * The element which is to scroll. Defaults to the {@link Core.widget.Widget#property-overflowElement} of
       * the configured {@link #config-widget}
       * @config {HTMLElement}
       */
      element: {
        $config: {
          nullify: true
        },
        value: null
      },
      /**
       * The element, or a selector which identifies a descendant element whose size
       * will affect the scroll range.
       * @config {HTMLElement|String}
       */
      contentElement: {
        $config: {
          nullify: true
        },
        value: null
      },
      /**
       * How to handle overflowing in the `X` axis.
       * May be:
       * * `'auto'`
       * * `'visible'`
       * * `'hidden'`
       * * `'scroll'`
       * * `'hidden-scroll'` Meaning scrollable from the UI but with no scrollbar,
       * for example a grid header. Only on platforms which support this feature.
       * * `true` - meaning `'auto'`
       * * `false` - meaning `'hidden'`
       * * `clip` - Uses `clip` where supported. Where not supported it uses
       * `hidden` and rolls back any detected scrolls in this dimension.
       * @config {String|Boolean}
       */
      overflowX: null,
      /**
       * How to handle overflowing in the `Y` axis.
       * May be:
       * * `'auto'`
       * * `'visible'`
       * * `'hidden'`
       * * `'scroll'`
       * * `'hidden-scroll'` Meaning scrollable from the UI but with no scrollbar.
       * Only on platforms which support this feature.
       * * `true` - meaning `'auto'`
       * * `false` - meaning `'hidden'`
       * * `clip` - Uses `clip` where supported. Where not supported it uses
       * `hidden` and rolls back any detected scrolls in this dimension.
       * @config {String|Boolean}
       */
      overflowY: null,
      /**
       * If configured as `true`, the {@link #config-element} is not scrolled but is translated using CSS
       * transform when controlled by this class's API. Scroll events are fired when the element is translated.
       * @default
       * @config {Boolean}
       */
      translate: null,
      x: 0,
      y: 0,
      rtlSource: null,
      /**
       * Configure as `true` to immediately sync partner scrollers when being synced by a controlling partner
       * instead of waiting for our own `scroll` event to pass the scroll on to partners.
       * @prp {Boolean}
       * @default false
       */
      propagateSync: null
    };
  }
  static get delayable() {
    return {
      onScrollEnd: {
        type: 'buffer',
        delay: 100
      }
    };
  }
  /**
   * Fired when scrolling happens on this Scroller's element. The event object is a native `scroll` event
   * with the described extra properties injected.
   * @event scroll
   * @param {Core.widget.Widget} widget The owning Widget which has been scrolled.
   * @param {Core.helper.util.Scroller} source This Scroller
   */
  /**
   * Fired when scrolling finished on this Scroller's element. The event object is the last native `scroll` event
   * fires by the element with the described extra properties injected.
   * @event scrollend
   * @param {Core.widget.Widget} widget The owning Widget which has been scrolled.
   * @param {Core.helper.util.Scroller} source This Scroller
   */
  /**
   * The `overflow-x` setting for the widget. `true` means `'auto'`.
   * @member {Boolean|String} overflowX
   */
  /**
   * The `overflow-y` setting for the widget. `true` means `'auto'`.
   * @member {Boolean|String} overflowY
   */
  get isRTL() {
    var _this$rtlSource;
    return Boolean((_this$rtlSource = this.rtlSource) === null || _this$rtlSource === void 0 ? void 0 : _this$rtlSource.rtl);
  }
  syncOverflowState() {
    const me = this,
      {
        element
      } = me,
      classList = new DomClassList(element.classList),
      x = me.hasOverflowX = element.scrollWidth > element.clientWidth,
      y = me.hasOverflowY = element.scrollHeight > element.clientHeight;
    classList.value = element.classList;
    // We use classes to indicate presence of overflow. This carries no rules by default.
    // Widget SASS may or may not attach rules or use these to select elements.
    const changed = classList.toggle('b-horizontal-overflow', x) || classList.toggle('b-vertical-overflow', y);
    if (changed) {
      DomHelper.syncClassList(element, classList);
      if (!me.isConfiguring) {
        /**
         * Fired when either the X or the Y axis changes from not showing a space-consuming scrollbar
         * to showing a space-consuming scrollbar or vice-versa.
         *
         * *_Does not fire on platforms which show overlayed scrollbars_*
         * @event overflowChange
         * @param {Boolean} x `true` if the X axis overflow, `false` otherwise.
         * @param {Boolean} y `true` if the Y axis overflow, `false` otherwise.
         * @internal
         */
        me.trigger('overflowChange', {
          x,
          y
        });
      }
    }
  }
  /**
   * Returns `true` if there is overflow in the specified axis.
   * @param {'x'|'y'} [axis='y'] The axis to check scrollbar for. Note that this is subtly different to asking
   * whether an axis is showing a space-consuming scrollbar, see {@link #function-hasScrollbar}.
   * @internal
   */
  hasOverflow(axis = 'y') {
    const me = this,
      overflowSetting = me[`overflow${axis.toUpperCase()}`],
      otherAxis = me[`overflow${axis === 'y' ? 'x' : 'y'}`];
    // If there are no space-consuming scrollbars, we will not be recording overflow
    // state on change of scrollbars (There will be no resize event when overflow state changes).
    // If we're not overflow:auto in that axis there will be no resize events from overflow state change.
    // If the other axis won't be changing size on scroll change we can't track this.
    if (!DomHelper.scrollBarWidth || !isScrollableConfig[overflowSetting] || otherAxis === 'hidden-scroll') {
      const dimension = axis === 'y' ? 'Height' : 'Width';
      return me[`scroll${dimension}`] > me[`client${dimension}`];
    }
    return me[`hasOverflow${axis.toUpperCase()}`];
  }
  /**
   * Returns `true` if there is a *space-consuming* scrollbar controlling scroll in the specified axis.
   * @param {'x'|'y'} [axis='y'] The axis to check scrollbar for. Note that this is subtly different to asking
   * whether an axis *has any* overflow, see {@link #function-hasOverflow}.
   * @internal
   */
  hasScrollbar(axis = 'y') {
    const {
      element
    } = this;
    if (element && DomHelper.scrollBarWidth) {
      const vertical = axis === 'y',
        dimension = vertical ? 'Width' : 'Height',
        clientSize = element[`client${dimension}`],
        borderSize = parseInt(DomHelper.getStyleValue(element, `border${vertical ? 'Left' : 'Top'}Width`)) + parseInt(DomHelper.getStyleValue(element, `border${vertical ? 'Right' : 'Bottom'}Width`)),
        difference = element[`offset${dimension}`] - borderSize - clientSize;
      // If the difference between the content width and the client width is
      // scrollBarWidth, then we have a scrollbar
      return Math.abs(difference - DomHelper.scrollBarWidth) < 2;
    }
  }
  /**
   * Partners this Scroller with the passed scroller in order to sync the scrolling position in the passed axes
   * @param {Core.helper.util.Scroller} otherScroller
   * @param {String|Object} [axes='x'] `'x'` or `'y'` or `{x: true/false, y: true/false}` axes to sync
   * @param {Boolean} [axes.x] Sync horizontal scroll
   * @param {Boolean} [axes.y] Sync vertical scroll
   */
  addPartner(otherScroller, axes = xAxis) {
    const me = this;
    if (typeof axes === 'string') {
      axes = {
        [axes]: 1
      };
    }
    if (!me.partners) {
      me.partners = {};
    }
    me.partners[otherScroller.id] = {
      scroller: otherScroller,
      axes
    };
    // Initial sync of the other axis to match our current state
    if (axes.x) {
      otherScroller.x = me.x;
    }
    if (axes.y) {
      otherScroller.y = me.y;
    }
    // It's a mutual relationship - the other scroller partners with us.
    if (!otherScroller.isPartneredWith(me)) {
      otherScroller.addPartner(me, axes);
    }
  }
  eachPartner(fn) {
    const {
      partners
    } = this;
    if (partners) {
      Object.values(partners).forEach(fn);
    }
  }
  /**
   * Breaks the link between this Scroller and the passed Scroller set up by the
   * {@link #function-addPartner} method.
   * @param {Core.helper.util.Scroller} otherScroller The Scroller to unlink from.
   */
  removePartner(otherScroller) {
    if (otherScroller && this.isPartneredWith(otherScroller)) {
      delete this.partners[otherScroller.id];
      otherScroller.removePartner(this);
    }
  }
  isPartneredWith(otherScroller) {
    var _this$partners;
    return Boolean((_this$partners = this.partners) === null || _this$partners === void 0 ? void 0 : _this$partners[otherScroller.id]);
  }
  /**
   * Breaks the link between this Scroller and all other Scrollers set up by the
   * {@link #function-addPartner} method.
   * @internal
   */
  clearPartners() {
    if (this.partners) {
      Object.values(this.partners).forEach(otherScroller => otherScroller.scroller.removePartner(this));
    }
  }
  /**
   * Scrolls the passed element or {@link Core.helper.util.Rectangle} into view according to the passed options.
   * @param {HTMLElement|Core.helper.util.Rectangle} element The element or a Rectangle in document space to scroll
   * into view.
   * @param {ScrollOptions} [options] How to scroll.
   * @returns {Promise} A promise which is resolved when the element has been scrolled into view.
   */
  async scrollIntoView(element, options = defaultScrollOptions) {
    const me = this,
      {
        isRectangle
      } = element,
      originalRect = isRectangle ? element : Rectangle.from(element),
      {
        xDelta,
        yDelta
      } = me.getDeltaTo(element, options),
      result = me.scrollBy(xDelta, yDelta, options);
    if (options.highlight || options.focus) {
      result.then(() => {
        if (isRectangle) {
          element = originalRect.translate(-xDelta, -yDelta);
        }
        if (options.highlight) {
          // Not coercible to a number means its a function or name of a function
          if (isNaN(options.highlight)) {
            (me.widget || me).callback(options.highlight, null, [element]);
          }
          // Otherwise, it's truthy or falsy
          else {
            DomHelper.highlight(element, me);
          }
        }
        if (options.focus) {
          DomHelper.focusWithoutScrolling(element);
        }
      });
    }
    return result;
  }
  /**
   * Scrolls the passed element into view according to the passed options.
   * @param {HTMLElement} element The element in document space to scroll into view.
   * @param {ScrollOptions} [options] How to scroll.
   * @returns {Promise} A promise which is resolved when the element has been scrolled into view.
   */
  static async scrollIntoView(element, options = defaultScrollOptions, rtl = false) {
    const target = Rectangle.from(element),
      animate = typeof options === 'object' ? options.animate : options,
      scrollable = Scroller._globalScroller || (Scroller._globalScroller = new Scroller()),
      deltas = [];
    scrollable.rtlSource = {
      rtl
    };
    let totalX = 0,
      totalY = 0,
      result;
    // Build up all the scroll deltas necessary to bring the requested element into view
    for (let ancestor = element.parentNode; ancestor.nodeType === Node.ELEMENT_NODE; ancestor = ancestor.parentNode) {
      if (ancestor === document.body && ancestor !== document.scrollingElement) {
        continue;
      }
      // The <html> element, although it scrolls is overflow:visible by default.
      const style = ancestor === document.scrollingElement ? allScroll : ancestor.ownerDocument.defaultView.getComputedStyle(ancestor);
      // If the ancestor overflows and scrolls in a dimension we are being asked to scroll in
      // Accumulate a scroll command for the ancestor.
      if (options.y !== false && isScrollable[style.overflowY] && ancestor.scrollHeight > ancestor.clientHeight || options.x !== false && isScrollable[style.overflowX] && ancestor.scrollWidth > ancestor.clientWidth) {
        // Global Scrollable
        scrollable.element = ancestor;
        // In case same element used as last time and didn't make it to the updater.
        scrollable.positionDirty = true;
        // See if the target is outside of this ancestor
        const {
          xDelta,
          yDelta
        } = scrollable.getDeltaTo(target, options);
        if (xDelta || yDelta) {
          deltas.push({
            element: ancestor,
            x: ancestor.scrollLeft,
            y: ancestor.scrollTop,
            xDelta,
            yDelta
          });
          target.translate(-xDelta, -yDelta);
          totalX += xDelta;
          totalY += yDelta;
        }
      }
    }
    // If scrolling was found to be necessary
    if (deltas.length) {
      const absX = Math.abs(totalX),
        absY = Math.abs(totalY);
      let duration = animate && (typeof animate === 'number' ? animate : typeof animate.duration === 'number' ? animate.duration : 300);
      // Only go through animation if there is significant scrolling to do.
      if (duration && (absX > 10 || absY > 10)) {
        // For small distances, constrain duration
        if (Math.max(absX, absY) < 50) {
          duration = Math.min(duration, 500);
        }
        result = scrollable.scrollAnimation = FunctionHelper.animate(duration, progress => {
          const isEnd = progress === 1;
          for (const {
            element,
            x,
            y,
            xDelta,
            yDelta
          } of deltas) {
            scrollable.element = element;
            if (xDelta) {
              scrollable.x = Math[rtl ? 'min' : 'max'](x + (isEnd ? xDelta : Math.round(xDelta * progress)), 0);
            }
            if (yDelta) {
              scrollable.y = Math.max(y + (isEnd ? yDelta : Math.round(yDelta * progress)), 0);
            }
          }
        }, null, animate.easing);
        result.then(() => {
          scrollable.scrollAnimation = null;
        });
      }
      // No animation
      else {
        for (const {
          element,
          xDelta,
          yDelta
        } of deltas) {
          element.scrollTop += yDelta;
          element.scrollLeft += xDelta;
        }
        result = scrollPromise(deltas[deltas.length - 1].element);
      }
    } else {
      result = immediatePromise$1;
    }
    // Postprocess element after scroll.
    if (options.highlight || options.focus) {
      result.then(() => {
        if (options.highlight) {
          // Not coercible to a number means it's a function or name of a function
          if (isNaN(options.highlight)) {
            scrollable.callback(options.highlight, null, [element]);
          }
          // Otherwise, it's truthy or falsy
          else {
            DomHelper.highlight(element, scrollable);
          }
        }
        if (options.focus) {
          element.focus();
        }
      });
    }
    return result;
  }
  /**
   * Scrolls by the passed deltas according to the passed options.
   * @param {Number} [xDelta=0] How far to scroll in the X axis.
   * @param {Number} [yDelta=0] How far to scroll in the Y axis.
   * @param {Object|Boolean} [options] How to scroll. May be passed as `true` to animate.
   * @param {Boolean} [options.silent] Set to `true` to suspend `scroll` events during scrolling.
   * @param {AnimateScrollOptions|Boolean|Number} [options.animate] Set to `true` to animate the scroll by 300ms,
   * or the number of milliseconds to animate over, or an animation config object.
   * @returns {Promise} A promise which is resolved when the scrolling has finished.
   */
  scrollBy(xDelta = 0, yDelta = 0, options = defaultScrollOptions) {
    const me = this,
      animate = typeof options === 'object' ? options.animate : options,
      absX = Math.abs(xDelta),
      absY = Math.abs(yDelta);
    if (me.scrollAnimation) {
      me.scrollAnimation.cancel();
      me.scrollAnimation = null;
    }
    // Only set the flag if there is going to be scrolling done.
    // It is cleared by the scrollEnd handler, so there must be scrolling.
    if (xDelta || yDelta) {
      me.silent = options.silent;
    }
    let duration = animate && (typeof animate === 'number' ? animate : typeof animate.duration === 'number' ? animate.duration : 300);
    // Only go through animation if there is significant scrolling to do.
    if (duration && (absX > 10 || absY > 10)) {
      const {
        x,
        y
      } = me;
      let lastX = x,
        lastY = y;
      // For small distances, constrain duration
      if (Math.max(absX, absY) < 50) {
        duration = Math.min(duration, 500);
      }
      me.scrollAnimation = FunctionHelper.animate(duration, progress => {
        const isEnd = progress === 1;
        if (xDelta) {
          // If the user, or another process has substantially changed the position since last time, abort.
          // Unless called with the force option to proceed regardless.
          if (Math.abs(me.x - lastX) > 1 && !options.force) {
            var _me$scrollAnimation;
            return (_me$scrollAnimation = me.scrollAnimation) === null || _me$scrollAnimation === void 0 ? void 0 : _me$scrollAnimation.cancel();
          }
          me.x = Math.max(x + (isEnd ? xDelta : Math.round(xDelta * progress)), 0);
        }
        if (yDelta) {
          // If the user, or another process has substantially changed the position since last time, abort.
          // Unless called with the force option to proceed regardless.
          if (Math.abs(me.y - lastY) > 1 && !options.force) {
            var _me$scrollAnimation2;
            return (_me$scrollAnimation2 = me.scrollAnimation) === null || _me$scrollAnimation2 === void 0 ? void 0 : _me$scrollAnimation2.cancel();
          }
          me.y = Math.max(y + (isEnd ? yDelta : Math.round(yDelta * progress)), 0);
        }
        // Store actual position from DOM
        lastX = me.x;
        lastY = me.y;
      }, me, animate.easing);
      me.element.classList.add('b-scrolling');
      me.scrollAnimation.then(() => {
        if (!me.isDestroyed) {
          me.element.classList.remove('b-scrolling');
          me.scrollAnimation = null;
        }
      });
      return me.scrollAnimation;
    } else {
      if (xDelta || yDelta) {
        const xBefore = me.x,
          yBefore = me.y;
        me.x += xDelta;
        me.y += yDelta;
        // Another change check for the possibility that setting me.x doesn't really scroll any significant
        // amount of pixels.
        if (me.x !== xBefore || me.y !== yBefore) {
          return scrollPromise(me.element);
        }
      }
      return immediatePromise$1;
    }
  }
  /**
   * Scrolls to the passed position according to the passed options.
   * @param {Number} [toX=0] Where to scroll to in the X axis.
   * @param {Number} [toY=0] Where to scroll to in the Y axis.
   * @param {Object|Boolean} [options] How to scroll. May be passed as `true` to animate.
   * @param {AnimateScrollOptions|Boolean|Number} [options.animate] Set to `true` to animate the scroll by 300ms,
   * or the number of milliseconds to animate over, or an animation config object.
   * @returns {Promise} A promise which is resolved when the scrolling has finished.
   */
  async scrollTo(toX, toY, options) {
    const {
        x,
        y
      } = this,
      xDelta = toX == null ? 0 : toX - x,
      yDelta = toY == null ? 0 : toY - y;
    return this.scrollBy(xDelta, yDelta, options);
  }
  doDestroy() {
    var _me$scrollAnimation3;
    const me = this;
    if (me._element) {
      var _me$wheelListenerRemo;
      me._element.removeEventListener('scroll', me.scrollHandler);
      (_me$wheelListenerRemo = me.wheelListenerRemover) === null || _me$wheelListenerRemo === void 0 ? void 0 : _me$wheelListenerRemo.call(me);
    }
    (_me$scrollAnimation3 = me.scrollAnimation) === null || _me$scrollAnimation3 === void 0 ? void 0 : _me$scrollAnimation3.cancel();
    Object.values(me.partners || {}).forEach(({
      scroller
    }) => scroller.removePartner(me));
    super.doDestroy();
  }
  /**
   * Respond to style changes to monitor scroll *when this Scroller is in `translate: true` mode.*
   * @param {Object[]} mutations The ElementMutation records.
   * @private
   */
  onElMutation(mutations) {
    const me = this,
      [x, y] = DomHelper.getTranslateXY(me.element);
    // If the mutation was due to a change in the translateX/Y styles, this is
    // a scroll event, so inform observers and partners
    if (me._x !== -x || me.y !== -y) {
      const scrollEvent = new CustomEvent('scroll', {
        bubbles: true
      });
      Object.defineProperty(scrollEvent, 'target', {
        get: () => me.element
      });
      me.onScroll(scrollEvent);
    }
  }
  onElResize() {
    const me = this,
      {
        widget
      } = me;
    // If it's not animating its size, sync immediately
    if (!(widget !== null && widget !== void 0 && widget.isAnimating)) {
      me.syncOverflowState();
    }
    // If it's animating, sync chen it's finished
    else if (widget.findListener('animationend', 'onElResize', me) === -1) {
      widget.ion({
        animationEnd: 'onElResize',
        thisObj: me,
        once: true
      });
    }
  }
  onScroll(e) {
    const me = this,
      {
        _x,
        _y,
        element
      } = me;
    let vetoed = 0;
    // Until overflow:clip is 100% supported just veto (and rollback) scrolls in clipped axes
    if (me.overflowX === 'clip' && element.scrollLeft !== _x) {
      element.scrollLeft = _x;
      ++vetoed;
    }
    if (me.overflowY === 'clip' && element.scrollTop !== _y) {
      element.scrollTop = _y;
      ++vetoed;
    }
    if (vetoed === 2) {
      return;
    }
    if (!me.widget || !me.widget.isDestroyed) {
      // Don't read the value until we have to. The x & y getters will check this flag
      me.positionDirty = true;
      if (!element.classList.contains('b-scrolling')) {
        element.classList.add('b-scrolling');
      }
      e.widget = me.widget;
      // If we have the scroll silent flag, do not fire the event.
      if (!me.silent) {
        me.trigger('scroll', e);
      }
      // Keep partners in sync
      me.syncPartners();
      // If this scroll impulse was from a controlling partner, clear that now
      me.controllingPartner = null;
      // Buffered method will fire in 100ms, unless another scroll event comes round.
      // In which case execution will be pushed out by another 100ms.
      me.onScrollEnd(e);
    }
  }
  /**
   * Syncs all attached scrolling partners with the scroll state of this Scroller.
   * @param {Boolean} force Allow this to sync a partner which is controlling this via a sync.
   * @param {Boolean} [propagate] Propagate any change immediately onwards through
   * further linked partners immediately rather than waiting for our own scroll event.
   * @internal
   */
  syncPartners(force, propagate = this.propagateSync) {
    const me = this;
    // Keep partners in sync
    if (me.partners) {
      Object.values(me.partners).forEach(({
        axes,
        scroller
      }) => {
        // Don't feed back to the one who's just told us to scroll here.
        // Unless we have assumed command. For example Scheduler timeline infinite scrolling
        // has reset the scroll position and the partner who thinks it's controlling
        // must stay in sync with that reset.
        if (scroller !== me.controllingPartner || force) {
          // Propagate means update all linked partners immediately rather than scroller reacting
          // to its scroll events to sync its partners. Only bother if the scroller actually changed.
          if (scroller.sync(me, axes) && propagate) {
            scroller.syncPartners(force, propagate);
          }
        }
      });
    }
  }
  onScrollEnd(e) {
    const me = this;
    if (me.silent) {
      me.silent = false;
    }
    me.trigger('scrollEnd', e);
    // Controlling partner is required for scrollable not to change its partners on scroll. This method is buffered
    // and landing here essentially means that no scrolling has occurred during the onScrollEnd buffer
    // time. We can safely cleanup controlling partner here.
    // https://github.com/bryntum/support/issues/1095
    me.controllingPartner = null;
    me.element.classList.remove('b-scrolling');
  }
  /**
   * Returns the xDelta and yDelta values in an object from the current scroll position to the
   * passed element or Rectangle.
   * @param {HTMLElement|Core.helper.util.Rectangle} element The element or a Rectangle to calculate deltas for.
   * @param {Object} [options] How to scroll.
   * @param {'start'|'end'|'center'|'nearest'} [options.block] How far to scroll the element.
   * @param {Number} [options.edgeOffset] A margin around the element or rectangle to bring into view.
   * @param {Boolean} [options.x] Pass as `false` to disable scrolling in the `X` axis.
   * @param {Boolean} [options.y] Pass as `false` to disable scrolling in the `Y` axis.
   * @returns {Object} `{ xDelta, yDelta }`
   * @internal
   */
  getDeltaTo(element, options) {
    const me = this;
    // scroller may belong to a collapsed subgrid widget
    if (!me.viewport) {
      return {
        xDelta: 0,
        yDelta: 0
      };
    }
    const {
        x,
        y,
        scrollWidth,
        scrollHeight,
        isRTL
      } = me,
      elementRect = element instanceof Rectangle ? element : Rectangle.from(element),
      block = options.block || 'nearest',
      scrollerRect = me.viewport,
      edgeOffset = normalizeEdgeOffset(options.edgeOffset),
      // Only include the offset round the target if the viewport is big enough to accommodate it.
      xOffset = scrollerRect.width >= elementRect.width + (edgeOffset.start + edgeOffset.end) ? edgeOffset : {
        start: 0,
        end: 0
      },
      yOffset = scrollerRect.height >= elementRect.height + (edgeOffset.top + edgeOffset.bottom) ? edgeOffset : {
        top: 0,
        bottom: 0
      },
      constrainTo = new Rectangle(isRTL ? scrollerRect.right - -x - scrollWidth : scrollerRect.x - x, scrollerRect.y - y, scrollWidth, scrollHeight),
      elRect = elementRect.clone().adjust(-xOffset.start, -yOffset.top, xOffset.end, yOffset.bottom).constrainTo(constrainTo),
      targetRect = elRect.clone(),
      // X scrolling is always +ve along the X scroll axis
      xFactor = me.isRTL ? -1 : 1;
    let xDelta = 0,
      yDelta = 0;
    if (block === 'start') {
      targetRect.moveTo(scrollerRect.x + (me.isRTL ? scrollerRect.width - targetRect.width : 0), scrollerRect.y);
      xDelta = elRect.x - targetRect.x;
      yDelta = elRect.y - targetRect.y;
    } else if (block === 'end') {
      targetRect.moveTo(scrollerRect.x + (!me.isRTL ? scrollerRect.width - targetRect.width : 0), scrollerRect.bottom - targetRect.height);
      xDelta = elRect.x - targetRect.x;
      yDelta = elRect.y - targetRect.y;
    }
    // Calculate deltas unless the above has done that for non-fitting target
    else if (block === 'center') {
      const center = scrollerRect.center;
      targetRect.moveTo(center.x - targetRect.width / 2, center.y - targetRect.height / 2);
      xDelta = xDelta || elRect.x - targetRect.x;
      yDelta = yDelta || elRect.y - targetRect.y;
    }
    // Use "nearest"
    else {
      // Can't fit width in, scroll what is possible into view so that start is visible.
      if (targetRect.width > scrollerRect.width) {
        xDelta = targetRect.x - scrollerRect.x;
      }
      // If it's *possible* to scroll to nearest x, calculate the delta
      else {
        if (targetRect.right > scrollerRect.right) {
          xDelta = targetRect.right - scrollerRect.right;
        } else if (targetRect.x < scrollerRect.x) {
          xDelta = targetRect.x - scrollerRect.x;
        }
      }
      // Can't fit height in, scroll what is possible into view so that start is visible.
      if (targetRect.height > scrollerRect.height) {
        yDelta = targetRect.y - scrollerRect.y;
      }
      // If it's *possible* to scroll to nearest y, calculate the delta
      else {
        if (targetRect.bottom > scrollerRect.bottom) {
          yDelta = targetRect.bottom - scrollerRect.bottom;
        } else if (targetRect.y < scrollerRect.y) {
          yDelta = targetRect.y - scrollerRect.y;
        }
      }
    }
    // Ensure x scrolling proceeds in +ve direction in RTL mode
    xDelta = xFactor * Math.round(xDelta);
    yDelta = Math.round(yDelta);
    // Do not allow deltas which would produce -ve scrolling or scrolling past the maxX/Y
    return {
      // When calculating how much delta is necessary to scroll the targetRect to the center
      // constrain that to what is *possible*. If what you are trying to scroll into the
      // center is hard against the right edge of the scroll range, then it cannot scroll
      // to the center, and the result must reflect that even though scroll is self limiting.
      // This is because highlighting the requested "element", if that element is in fact
      // a Rectangle, uses a temporary element placed at the requested region which
      // MUST match where the actual scroll has moved the requested region.
      xDelta: options.x === false ? 0 : Math.max(Math.min(xDelta, me.maxX - x), -x),
      yDelta: options.y === false ? 0 : Math.max(Math.min(yDelta, me.maxY - y), -y)
    };
  }
  /**
   * A {@link Core/helper/util/Rectangle} describing the bounds of the scrolling viewport.
   * @property {Core.helper.util.Rectangle}
   */
  get viewport() {
    return Rectangle.client(this.element);
  }
  updateWidget(widget) {
    this.rtlSource = this.owner = widget;
  }
  updateElement(element, oldElement) {
    const me = this;
    // The global Scroller doesn't monitor its element.
    // It's only used for *commanding* scrolls.
    if (me === Scroller._globalScroller) {
      me._element = element;
      me.positionDirty = true;
      return;
    }
    const scrollHandler = me.scrollHandler || (me.scrollHandler = me.onScroll.bind(me)),
      resizeHandler = me.resizeHandler || (me.resizeHandler = me.onElResize.bind(me));
    if (oldElement) {
      if (me.translate) {
        var _me$mutationObserver;
        (_me$mutationObserver = me.mutationObserver) === null || _me$mutationObserver === void 0 ? void 0 : _me$mutationObserver.disconnect();
      } else {
        oldElement.removeEventListener('scroll', scrollHandler);
        oldElement.classList.remove(scrollerCls);
        oldElement.style.overflowX = oldElement.style.overflowY = '';
      }
      ResizeMonitor.removeResizeListener(oldElement, resizeHandler);
    }
    if (element) {
      if (me.translate) {
        if (!me.mutationObserver) {
          me.mutationObserver = new MutationObserver(me.mutationHandler || (me.mutationHandler = me.onElMutation.bind(me)));
        }
        me._x = me._y = 0;
        if (document.contains(element)) {
          const [x, y] = DomHelper.getTranslateXY(element);
          me._x = -x;
          me._y = -y;
        }
        me.mutationObserver.observe(element, {
          attributes: true
        });
      } else {
        element.addEventListener('scroll', scrollHandler);
        element.classList.add(scrollerCls);
      }
      ResizeMonitor.addResizeListener(element, resizeHandler);
      if (!me.widget) {
        me.rtlSource = {
          get rtl() {
            return DomHelper.getStyleValue(element, 'direction') === 'rtl';
          }
        };
      }
      if (me.isRTL) {
        element.classList.add('b-rtl');
      }
      // Ensure the overflow configs, which are unable to process themselves
      // in the absence of the element get applied to the newly arrived element.
      if (me.positionDirty) {
        me.updateOverflowX(me.overflowX);
        me.updateOverflowY(me.overflowY);
      }
      // Keep flags synced from the start
      me.syncOverflowState();
      // Apply initially configured scroll position if we have non-zero positions
      if (me.isConfiguring) {
        me._x && me.updateX(me._x);
        me._y && me.updateY(me._y);
      }
    }
    me.positionDirty = true;
  }
  /**
   * The horizontal scroll position of the widget.
   *
   * Note that this is always +ve. Horizontal scrolling using the `X` property akways proceeds
   * in the +ve direction.
   *
   * @property {Number}
   */
  get x() {
    const me = this,
      {
        element
      } = me;
    if (element && me.positionDirty) {
      if (me.translate) {
        const [x, y] = DomHelper.getTranslateXY(element);
        me._x = -x;
        me._y = -y;
      } else {
        // A Scroller's conception is that X is an offset from the origin in whatever the direction is.
        me._x = Math.abs(element.scrollLeft);
        me._y = element.scrollTop;
      }
      me.positionDirty = false;
    }
    return me._x;
  }
  /**
   * The natural DOM horizontal scroll position of the widget.
   *
   * Note that this proceeds from 0 into negative space in RTL mode.
   *
   * @property {Number}
   */
  get scrollLeft() {
    return this.x * (this.isRTL ? -1 : 1);
  }
  changeX(x) {
    // We do not accept the concept of -ve X values.
    // Although scrolling in an RTL element sets scrollLeft to -ve, a Scroller's conception
    // is that X is an offset from the origin in whatever the direction is. So all code should
    // use this concept.
    x = Math.max(x, 0);
    // Only process initial X if we were configured to start at non-zero
    if (!this.isConfiguring || x) {
      return x;
    }
    this._x = x;
  }
  updateContentElement(contentElement) {
    if (contentElement) {
      contentElement = typeof contentElement === 'string' ? this.element.querySelector(contentElement) : contentElement;
      ResizeMonitor.addResizeListener(contentElement, this.resizeHandler);
    }
  }
  updateX(x) {
    var _me$widget;
    const me = this,
      {
        element
      } = me;
    // When element is outside of DOM, this can have no effect
    if (element && !((_me$widget = me.widget) !== null && _me$widget !== void 0 && _me$widget.isConfiguring)) {
      // https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollLeft
      // On systems using display scaling, scrollLeft may give you a decimal value.
      // Round possible decimal value to integer
      x = Math.round(x);
      me.trigger('scrollStart', {
        x
      });
      if (me.translate) {
        DomHelper.setTranslateX(element, -x);
      } else {
        element.scrollLeft = me.isRTL ? -x : x;
      }
    }
    // The scroll position will need to be read before we can return it.
    // Do not read it back now, we may not have our element, or if we do,
    // that would cause a forced synchronous layout.
    me.positionDirty = true;
  }
  /**
   * Syncs this Scroller with the passed Scroller in the passed axes.
   * @param {Core.helper.util.Scroller} controllingPartner The Scroller which is dictating our new scroll position.
   * @param {Object} axes `{x : <boolean>, y : <boolean> }` which axes to sync.
   * @param {Boolean} axes.x Sync horizontal scroll.
   * @param {Boolean} axes.y Sync vertical scroll.
   * @returns {Boolean} `true` if this Scroller needed the passed axes syncing, `false`
   * if no changes were made.
   * @internal
   */
  sync(controllingPartner, axes) {
    const me = this,
      {
        x,
        y
      } = axes;
    let result = false;
    if (x != null) {
      if (me.x !== controllingPartner.x) {
        // Only set controlling partner when scroll will actually change. This helps to increase stability of
        // state restoring API.
        me.controllingPartner = controllingPartner;
        me.x = controllingPartner.x;
        result = true;
      }
    }
    if (y != null) {
      if (me.y !== controllingPartner.y) {
        me.controllingPartner = controllingPartner;
        me.y = controllingPartner.y;
        result = true;
      }
    }
    // Returns true if the sync was needed
    return result;
  }
  /**
   * The vertical scroll position of the widget.
   * @property {Number}
   */
  get y() {
    const me = this,
      {
        element
      } = me;
    if (element && me.positionDirty) {
      if (me.translate) {
        const [x, y] = DomHelper.getTranslateXY(element);
        me._x = -x;
        me._y = -y;
      } else {
        me._x = element.scrollLeft;
        me._y = element.scrollTop;
      }
      me.positionDirty = false;
    }
    return me._y;
  }
  changeY(y) {
    // Only process initial Y if we were configured to start at non-zero
    if (!this.isConfiguring || y) {
      return y;
    }
    this._y = y;
  }
  updateY(y) {
    const {
      element,
      widget
    } = this;
    // When element is outside of DOM, this can have no effect
    if (element && !(widget !== null && widget !== void 0 && widget.isConfiguring)) {
      this.trigger('scrollStart', {
        y
      });
      if (this.translate) {
        DomHelper.setTranslateY(element, -y);
      } else {
        element.scrollTop = y;
      }
    }
    // The scroll position will need to be read before we can return it.
    // Do not read it back now, we may not have our element, or if we do,
    // that would cause a forced synchronous layout.
    this.positionDirty = true;
  }
  /**
   * The maximum `X` scrollable position of the widget.
   * @property {Number}
   * @readonly
   */
  get maxX() {
    return this.scrollWidth - this.clientWidth;
  }
  /**
   * The maximum `Y` scrollable position of the widget.
   * @property {Number}
   * @readonly
   */
  get maxY() {
    return this.scrollHeight - this.clientHeight;
  }
  /**
   * The furthest possible `scrollLeft` position of the widget. Will be -ve
   * if in writing direction is RTL.
   * @property {Number}
   * @readonly
   */
  get lastScrollLeft() {
    return (this.scrollWidth - this.clientWidth) * (this.isRTL ? -1 : 1);
  }
  updateOverflowX(overflowX, oldOverflowX) {
    const me = this,
      {
        element,
        translate
      } = me,
      {
        style,
        classList
      } = element;
    if (oldOverflowX === 'hidden-scroll') {
      classList.remove('b-hide-scroll');
    }
    // Scroll, but without showing scrollbars.
    // For example a grid header. Only works on platforms which
    // support suppression of scrollbars through CSS.
    if (overflowX === 'hidden-scroll' && !translate) {
      const otherAxisScrollable = isScrollable[style.overflowY];
      // Can't do one axis hidden-scroll, and the other scrollable because the b-hide-scroll
      // class hides "all" scrollbars, so we have to make this axis hidden and use a wheel
      // listener to scroll the content.
      if (otherAxisScrollable) {
        overflowX = 'hidden';
        // Adds a wheel listener if we don't already have one.
        me.enableWheel();
      } else {
        classList.add('b-hide-scroll');
      }
    }
    if (!translate) {
      style.overflowX = scrollLiterals[overflowX] || overflowX;
    }
    if (!me.isConfiguring) {
      me.positionDirty = true;
      me.syncOverflowState();
    }
  }
  updateOverflowY(overflowY, oldOverflowY) {
    const me = this,
      {
        element,
        translate
      } = me,
      {
        style,
        classList
      } = element;
    if (oldOverflowY === 'hidden-scroll') {
      classList.remove('b-hide-scroll');
    }
    // Scroll, but without showing scrollbars.
    // For example a grid header.
    // On platforms which show space-consuming scrollbars we hide scrollbars
    // and add a 'wheel' listener.
    if (overflowY === 'hidden-scroll' && !translate) {
      const otherAxisScrollable = isScrollable[style.overflowX];
      // Can't do one axis hidden-scroll, and the other scrollable because the b-hide-scroll
      // class hides "all" scrollbars, so we have to make this axis hidden and use a wheel
      // listener to scroll the content.
      if (otherAxisScrollable) {
        overflowY = 'hidden';
        // Adds a wheel listener if we don't already have one.
        me.enableWheel();
      } else {
        classList.add('b-hide-scroll');
      }
    }
    if (!translate) {
      style.overflowY = scrollLiterals[overflowY] || overflowY;
    }
    if (!me.isConfiguring) {
      me.positionDirty = true;
      me.syncOverflowState();
    }
  }
  enableWheel() {
    if (!this.wheelListenerRemover) {
      this.wheelListenerRemover = EventHelper.on({
        element: this.element,
        wheel: 'onWheel',
        thisObj: this
      });
    }
  }
  onWheel(e) {
    if (Math.abs(e.deltaX) > Math.abs(e.deltaY) && this.overflowX === 'hidden-scroll') {
      this.x += e.deltaX;
    } else if (this.overflowY === 'hidden-scroll') {
      this.y += e.deltaY;
    }
  }
  /**
   * The horizontal scroll range of the widget.
   * @property {Number}
   * @readonly
   */
  get scrollWidth() {
    var _this$element;
    return ((_this$element = this.element) === null || _this$element === void 0 ? void 0 : _this$element.scrollWidth) ?? 0;
  }
  set scrollWidth(scrollWidth) {
    const me = this,
      {
        element,
        isRTL
      } = me;
    let stretcher = me.widthStretcher;
    // "Unsetting" scrollWidth removes the stretcher
    if (stretcher && scrollWidth == null) {
      stretcher.remove();
      me.widthStretcher = null;
    } else if (scrollWidth) {
      // Although DOM has crazy negative scrollLeft values in RTL, we treat the scrollWidth
      // as a pure magnitude. It is then applied correctly negated if RTL. In this way
      // app code can just use element widths and not consider RTL.
      scrollWidth = Math.abs(scrollWidth);
      if (!stretcher) {
        stretcher = me.widthStretcher = DomHelper.createElement({
          className: 'b-scroller-stretcher b-horizontal-stretcher',
          // Should survive its surroundings being DomSynced
          retainElement: true
        });
      }
      stretcher.style.transform = `translateX(${(scrollWidth - 1) * (isRTL ? -1 : 1)}px)`;
      if (element && !element.contains(stretcher)) {
        element.insertBefore(stretcher, element.firstElementChild);
      }
    }
    // Propagate call to partners so they will establish own scroller stretcher
    if (me.propagate !== false) {
      me.eachPartner(({
        scroller
      }) => {
        // Raise a flag on partner to not propagate changes from it further
        scroller.propagate = false;
        scroller.scrollWidth = scrollWidth;
        delete scroller.propagate;
      });
    }
    me.positionDirty = true;
    me.syncOverflowState();
  }
  get scrollHeight() {
    var _this$element2;
    return ((_this$element2 = this.element) === null || _this$element2 === void 0 ? void 0 : _this$element2.scrollHeight) ?? 0;
  }
  /**
   * The vertical scroll range of the widget. May be set to larger than the actual data
   * height to enable virtual scrolling. This is how the grid extends its scroll range
   * while only rendering a small subset of the dataset.
   * @property {Number}
   */
  set scrollHeight(scrollHeight) {
    const me = this,
      stretcher = me.stretcher || (me.stretcher = DomHelper.createElement({
        className: 'b-scroller-stretcher'
      }));
    stretcher.style.transform = `translateY(${scrollHeight - 1}px)`;
    if (me.element && me.element.lastChild !== stretcher) {
      me.element.appendChild(stretcher);
    }
    me.positionDirty = true;
    me.syncOverflowState();
  }
  /**
   * The client width of the widget.
   * @property {Number}
   * @readonly
   */
  get clientWidth() {
    var _this$element3;
    return ((_this$element3 = this.element) === null || _this$element3 === void 0 ? void 0 : _this$element3.clientWidth) || 0;
  }
  /**
   * The client height of the widget.
   * @property {Number}
   * @readonly
   */
  get clientHeight() {
    var _this$element4;
    return ((_this$element4 = this.element) === null || _this$element4 === void 0 ? void 0 : _this$element4.clientHeight) || 0;
  }
  /**
   * The unique ID of this Scroller
   * @property {String}
   * @readonly
   */
  get id() {
    if (!this._id) {
      if (this.widget) {
        this._id = `${this.widget.id}-scroller`;
      } else {
        this._id = IdHelper.generateId('scroller-');
      }
    }
    return this._id;
  }
  //region Extract configs
  // This function is not meant to be called by any code other than Base#getCurrentConfig().
  preProcessCurrentConfigs(configs) {
    super.preProcessCurrentConfigs();
    delete configs.widget;
    delete configs.element;
  }
  //endregion
}

Scroller._$name = 'Scroller';

/**
 * @module Core/helper/util/Promissory
 */
/**
 * Encapsulates a Promise and provides `resolve()` and `reject()` methods.
 *
 * For example:
 *
 * ```javascript
 *  load() {
 *      this.loading = new Promissory();
 *      this.store.load();
 *
 *      return this.loading.promise;
 *  }
 *
 *  onStoreLoad(store, err) {
 *      if (err) {
 *          this.loading.resolve(this);
 *      }
 *      else {
 *          this.loading.reject(err);
 *      }
 *  }
 *
 * ```
 *
 * @internal
 */
class Promissory {
  constructor(fn) {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
    if (fn) {
      fn(this);
    }
  }
}
Promissory._$name = 'Promissory';

const {
  defineProperty: defineProperty$1
} = Reflect;
/**
 * @module Core/widget/Renderable
 */
/**
 * This class provides element rendering and automatic synchronization based on config property changes.
 *```
 *  class Label extends Renderable {
 *      static get configurable() {
 *          return {
 *              text : {
 *                  value: null,
 *
 *                  $config : 'render'
 *              }
 *          };
 *      }
 *
 *      renderDom() {
 *          return {
 *              tag: 'label',
 *              children: [
 *                  this.text
 *              ]
 *          };
 *      }
 *  }
 *```
 * A class can opt to not specify its render configs. In this case, these will be determined automatically, but with
 * some additional cost. This may not be worth considering if only a few instances are ever likely.
 *
 * @private
 */
class Renderable extends Base.mixin(Localizable, Events, Delayable, Identifiable) {
  static get configurable() {
    return {
      /**
       * The top-level DOM element for this object. This element is produced from the {@link #function-renderDom}
       * method of the derived class. As configs used by `renderDom` change, a synchronization of the DOM is
       * scheduled by calling {@link #function-refreshDom}. This call is made automatically by this class, making
       * it rarely necessary to call `refreshDom` directly.
       * @config {HTMLElement}
       * @category DOM
       */
      element: null
    };
  }
  static get delayable() {
    return {
      refreshDom: 'raf'
    };
  }
  static get identifiable() {
    return {};
  }
  /**
   * Returns the Set of configs defined as `render: true`, that is, the configs that determine the rendering (via
   * `renderDom`). If no such configs are defined, this method returns `null`.
   *
   * @returns {Set}
   * @private
   */
  static get renderConfigs() {
    const me = this,
      meta = me.$meta;
    let renderConfigs = meta.renderConfigs,
      configs,
      name;
    if (renderConfigs === undefined) {
      // if (first time for this class)
      renderConfigs = null;
      configs = meta.configs;
      for (name in configs) {
        if (configs[name].render) {
          (renderConfigs || (renderConfigs = new Set())).add(name);
        }
      }
      // Put $renderConfigs on the prototype so that onConfigChange is as simple as possible:
      meta.renderConfigs = me.prototype.$renderConfigs = renderConfigs;
    }
    return renderConfigs;
  }
  //region Init
  construct(...args) {
    this.$iid = ++Renderable.$idSeed;
    this.byRef = {};
    super.construct(...args);
    if (this.onDraw !== Renderable.prototype.onDraw) {
      this.initDrawable();
    }
  }
  startConfigure(config) {
    this.element = this.renderContext.renderDom(); // calls changeElement()
    super.startConfigure(config);
  }
  //endregion
  //region Configs
  get element() {
    // NOTE: We can replace the getter of a config property
    // Asking for the primary el is a good sign that we need to sync the DOM:
    this.refreshDom.flush();
    return this._element;
  }
  /**
   * This is called when the `element` config is assigned (via the setter).
   * @param {HTMLElement} element The new element being assigned.
   * @param {HTMLElement|null} oldElement The old element (previously assigned) or `null`.
   * @returns {HTMLElement}
   * @private
   */
  changeElement(element, oldElement) {
    const me = this;
    if (oldElement) {
      oldElement.remove();
    }
    if (element) {
      element.id = me.id;
      element = DomHelper.createElement(element, {
        refOwner: me
      });
    }
    return element;
  }
  updateId(id, oldId) {
    const me = this;
    if (oldId) {
      const element = me.element;
      element.id = id;
      me.fixRefOwnerId(element, id, oldId);
    }
  }
  //endregion
  //region Misc
  /**
   * Returns the `classList` of this instance's `element`.
   * @property {DOMTokenList}
   */
  get classes() {
    return this.element.classList;
  }
  /**
   * This method fixes the element's `$refOwnerId` when this instance's `id` is changing.
   * @param {HTMLElement} el The element to fix.
   * @param {String} id The new id being assigned.
   * @param {String} oldId The old id (previously assigned).
   * @private
   */
  fixRefOwnerId(el, id, oldId) {
    if (el.$refOwnerId === oldId) {
      el.$refOwnerId = id;
      const ref = el.$reference;
      if (ref) {
        el.id = `${id}-${ref}`;
      }
      for (const c of el.childNodes) {
        this.fixRefOwnerId(c, id, oldId);
      }
    }
  }
  onConfigChange({
    name
  }) {
    // The $renderConfigs Set is either on our prototype (due to renderConfigs getter) or on our instance (due to
    // renderContext getter):
    if (!this.isConfiguring && this.$renderConfigs.has(name)) {
      this.refreshDom();
    }
  }
  //endregion
  //region Rendering
  /**
   * This method is called by `DomHelper.createElement` and `DomSync.sync` as new reference elements are created.
   * @param {String} name The name of the element, i.e., the value of its `reference` attribute.
   * @param {HTMLElement} el The element instance
   * @param {Object} domConfig The DOM config object.
   * @private
   */
  attachRef(name, el, domConfig) {
    const me = this,
      key = '_' + name,
      // eslint-disable-next-line bryntum/no-listeners-in-lib
      {
        listeners
      } = domConfig;
    if (!(key in me)) {
      defineProperty$1(me, name, {
        get() {
          // Asking for a ref el is a good sign that we need to sync the DOM:
          me.refreshDom.flush();
          return me[key];
        },
        set(el) {
          me[key] = el;
          // Key elements contain owner pointer (Not supported on IE SVG).
          // if (el && el.dataset) {
          //     el.dataset.ownerCmp = me.id;
          // }
        }
      });
    }

    el.id = `${me.id}-${name}`;
    me.byRef[name] = el;
    me[name] = el;
    if (listeners) {
      domConfig.listeners = {
        on: listeners,
        un: EventHelper.on(Object.assign({
          element: el,
          thisObj: me
        }, listeners))
      };
    }
  }
  /**
   * This method is called by `DomSync.sync` as reference elements are removed from the DOM.
   * @param {String} name The name of the element, i.e., the value of its `reference` attribute.
   * @param {HTMLElement} el The element instance
   * @param {Object} domConfig The DOM config object.
   * @private
   */
  detachRef(name, el, domConfig) {
    if (domConfig.listeners) {
      domConfig.listeners.un();
      domConfig.listeners = null;
    }
    this[name] = null;
    delete this.byRef[name];
  }
  /**
   * This method returns a {@link Core.helper.DomHelper#function-createElement-static} config object that describes
   * the desired elements for this instance.
   *
   * This method is called to produce the initial DOM structure and again as necessary to generate the DOM for the
   * current state. The DOM produced by these subsequent calls is then passed through
   * {@link Core.helper.DomSync#function-sync-static DomSync.sync()} to update the DOM.
   * @returns {Object}
   */
  renderDom() {
    // abstract method provided by derived class
    return {};
  }
  /**
   * This property is the object to use when calling the `renderDom` method. It may evaluate to this instance (if
   * the class declares its render configs) or a helper object to track config usage during the `renderDom` call.
   * @property {Object}
   * @private
   */
  get renderContext() {
    const me = this,
      meta = me.$meta,
      C = me.constructor;
    let renderConfigs = meta.renderConfigs || C.renderConfigs,
      context = me;
    // If the class author did not declare any configs as render:true, then we make a proxy-like object that can
    // detect getter calls to build that Set. Since the getters may not all trigger on any given rendering, we
    // cannot share this work across instances since they may take different control paths.
    if (!renderConfigs) {
      context = Object.create(me);
      renderConfigs = new Set();
      for (const name in meta.configs) {
        defineProperty$1(context, name, {
          get() {
            renderConfigs.add(name);
            return me[name];
          }
        });
      }
      // In order to be substitutable for the Renderable, we need the same method name... we just need to run
      // renderDom w/ our context as "this":
      context.renderDom = () => {
        return me.renderDom.call(context);
      };
      me.$renderConfigs = renderConfigs;
    }
    // Replace this getter with the actual context so we don't get called again:
    defineProperty$1(me, 'renderContext', {
      value: context
    });
    return context;
  }
  /**
   * This method synchronized the DOM produced by {@link #function-renderDom} with what was previously produced and
   * updates the elements accordingly.
   *
   * This method is buffered such that calls to it do not immediately execute. To perform the refresh immediately,
   * do this:
   *```
   *  instance.refreshDom.now();
   *```
   * To flush any potential updates to the DOM (and do nothing if there are none), do this:
   *```
   *  instance.refreshDom.flush();
   *```
   * To determine if there are updates to the DOM pending, do this:
   *```
   *  if (instance.refreshDom.isPending) {
   *      ...
   *  }
   *```
   */
  refreshDom() {
    DomSync.sync({
      targetElement: this.element,
      domConfig: this.renderContext.renderDom(),
      refOwner: this,
      // This limits the sync() to only removing the classes and styles added by previous renderings. This
      // allows dynamically added styles and classes to be preserved:
      strict: true
    });
  }
  //endregion
  onListen(eventName) {
    // Only add the b-drawable-el when someone first listens for the draw event since it may never happen...
    if (eventName === 'draw') {
      this.initDrawable();
    }
  }
  initDrawable() {
    const me = this;
    if (!me.intersector) {
      let el = Object.values(me.byRef).find(el => el.classList.contains('b-drawable'));
      if (!el) {
        el = me.element;
        el.classList.add('b-drawable');
      }
      me.intersector = new IntersectionObserver(entries => {
        if (!me.isDestroyed) {
          entries.forEach(ent => {
            if (ent.isIntersecting) {
              me.onDraw({
                count: ++me.drawCounter
              });
            }
          });
        }
      });
      me.intersector.observe(el);
    }
  }
  onDraw(ev) {
    this.trigger('draw', ev);
  }
}
Renderable.$idSeed = 0;
Object.assign(Renderable.prototype, {
  drawCounter: 0,
  hasGeneratedId: false,
  intersector: null
});
Renderable._$name = 'Renderable';

/**
 * @module Core/widget/Mask
 */
/**
 * Masks a target element (document.body if none is specified). Call static methods for ease of use or make instance
 * for reusability.
 *
 * ```javascript
 * Mask.mask('hello');
 * Mask.unmask();
 * ````
 *
 * {@inlineexample Core/widget/Mask.js}
 *
 * Can show progress:
 *
 * ```javascript
 * // Using progress by calling static method
 * const mask = Mask.mask({
 *   text        :'The task is in progress',
 *   progress    : 0,
 *   maxProgress : 100
 * });
 *
 * let timer = setInterval(()=>{
 *   mask.progress += 5;
 *   if(mask.progress >= mask.maxProgress) {
 *     Mask.unmask();
 *     clearInterval(timer)
 *   }
 * }, 100);
 * ```
 *
 * Shortcut to masking Bryntum components:
 *
 * ```javascript
 * // Using progress to mask a Bryntum component
 * scheduler.mask({
 *  text:'Loading in progress',
 *   progress: 0,
 *   maxProgress: 100
 * })
 * let timer = setInterval(()=>{
 *   scheduler.masked.progress += 5;
 *   if(scheduler.masked.progress >= scheduler.masked.maxProgress) {
 *     scheduler.unmask();
 *     clearInterval(timer)
 *   }
 * },100)
 * ```
 */
class Mask extends Renderable {
  //region Config
  static $name = 'Mask';
  // Factoryable type name
  static type = 'mask';
  static configurable = {
    /**
     * Set this config to trigger an automatic close after the desired delay:
     * ```javascript
     *  mask.autoClose = 2000;
     * ```
     * If the mask has an `owner`, its `onMaskAutoClosing` method is called when the close starts and its
     * `onMaskAutoClose` method is called when the close finishes.
     * @config {Number}
     * @private
     */
    autoClose: null,
    /**
     * The portion of the {@link #config-target} element to be covered by this mask. By default, the mask fully
     * covers the `target`. In some cases, however, it may be desired to only cover the `'body'` (for example,
     * in a grid).
     *
     * This config is set in conjunction with `owner` which implements the method `syncMaskCover`.
     *
     * @config {String}
     * @private
     */
    cover: null,
    /**
     * The icon to show next to the text. Defaults to showing a spinner
     * @config {String}
     * @default
     */
    icon: 'b-icon b-icon-spinner',
    errorDefaults: {
      icon: 'b-icon b-icon-warning',
      autoClose: 3000,
      showDelay: 0
    },
    /**
     * The maximum value of the progress indicator
     * @property {Number}
     */
    maxProgress: null,
    /**
     * Mode: bright, bright-blur, dark or dark-blur
     * @config {'bright'|'bright-blur'|'dark'|'dark-blur'}
     * @default
     */
    mode: 'dark',
    /**
     * Number expressing the progress
     * @property {Number}
     */
    progress: null,
    // The owner is involved in the following features:
    //
    // - The `autoClose` timer calls `onMaskAutoClose`.
    // - The `cover` config calls `syncMaskCover`.
    // - If the `target` is a string, that string names the property of the `owner` that holds the
    //   `HTMLElement` reference.
    /**
     * The owning widget of this mask. This is required if `target` is a string.
     *
     * @config {Core.widget.Widget}
     */
    owner: {
      $config: 'nullify',
      value: null
    },
    /**
     * The element to be masked. If this config is a string, that string is the name of the property of the
     * `owner` that holds the `HTMLElement` that is the actual target of the mask.
     *
     * NOTE: In prior releases, this used to be specified as the `element` config, but that is now, as with
     * `Widget`, the primary element of the mask.
     *
     * @config {String|HTMLElement}
     */
    target: null,
    /**
     * The text (or HTML) to show in mask
     * @config {String}
     */
    text: null,
    type: null,
    /**
     * The number of milliseconds to delay before making the mask visible. If set, the mask will have an
     * initial `opacity` of 0 but will function in all other ways as a normal mask. Setting this delay can
     * reduce flicker in cases where load operations are typically short (for example, a second or less).
     *
     * @config {Number}
     */
    showDelay: null,
    useTransition: false
  };
  static delayable = {
    deferredClose: 0,
    delayedShow: 0,
    syncCover: {
      type: 'throttle',
      delay: 100
    }
  };
  //endregion
  //region Init
  // Used to give masks unique names
  static counter = 0;
  // Tracks open masks
  static masks = [];
  construct(config) {
    if (config) {
      let el = config.element,
        cfg;
      // Upgrade config -> cfg
      // Treat config as readonly, cfg is lazily copied and writable
      if (el) {
        VersionHelper.deprecate('Core', '4.0.0', 'Mask "element" config has been renamed to "target"');
        config = cfg = Object.assign({}, config);
        delete cfg.element;
        cfg.target = el;
      }
      el = config.target;
      if (typeof el === 'string') {
        config = cfg = cfg || Object.assign({}, config);
        cfg.target = config.owner[el]; // must supply "owner" in this case
      }
    }

    super.construct(config);
    const me = this,
      {
        type
      } = me;
    if (!me.target) {
      me.target = document.body;
    }
    me.maskName = `mask${typeof type === 'string' ? type.trim() : ''}-${Mask.counter++}`;
    me.show();
  }
  doDestroy() {
    const me = this,
      {
        element
      } = me;
    if (me.type === 'trial') {
      return false;
    }
    if (element) {
      me.element = null;
      if (me.mode.endsWith('blur')) {
        DomHelper.forEachChild(element, child => {
          child.classList.remove(`b-masked-${me.mode}`);
        });
      }
      me.target.classList.remove('b-masked');
      me.target[me.maskName] = null;
      ArrayHelper.remove(Mask.masks, me);
    }
    super.doDestroy();
  }
  get maskElement() {
    return this.element;
  }
  set error(value) {
    this.setConfig(this.errorDefaults);
    this.text = value;
  }
  renderDom() {
    const me = this,
      {
        maxProgress
      } = me;
    return {
      class: {
        'b-mask': 1,
        'b-delayed-show': me.showDelay,
        'b-widget': 1,
        [`b-mask-${me.mode}`]: 1,
        'b-progress': maxProgress,
        'b-prevent-transitions': !me.useTransition
      },
      children: [{
        reference: 'maskContent',
        class: 'b-mask-content b-drawable',
        children: [maxProgress ? {
          reference: 'progressElement',
          class: 'b-mask-progress-bar',
          style: {
            width: `${Math.max(0, Math.min(100, Math.round(me.progress / maxProgress * 100)))}%`
          }
        } : null, {
          reference: 'maskText',
          class: 'b-mask-text',
          html: (me.icon ? `<i class="b-mask-icon ${me.icon}"></i>` : '') + me.text
        }]
      }]
    };
  }
  //endregion
  //region Static
  static mergeConfigs(...sources) {
    const ret = {};
    for (const src of sources) {
      if (typeof src === 'string') {
        ret.text = src;
      } else {
        ObjectHelper.assign(ret, src); // not Object.assign!
      }
    }

    return ret;
  }
  /**
   * Shows a mask with the specified message.
   *
   * Masks stack, call {@link #function-unmask-static} to remove the topmost mask. Or call {@link #function-close}
   * on the returned mask to close it specifically.
   *
   * @param {String|MaskConfig} text Message
   * @param {HTMLElement} target The element to mask
   * @returns {Core.widget.Mask}
   */
  static mask(text, target = document.body) {
    return Mask.new({
      target
    }, typeof text !== 'string' ? {
      ...text
    } : {
      text
    });
  }
  /**
   * Close the topmost mask for the specified element
   * @param {HTMLElement} element Element to unmask
   * @returns {Promise|null} A promise which is resolved when the mask is gone, or null if element is not masked
   */
  static unmask(element = document.body) {
    const masks = this.getElementMasks(element);
    if (masks.length > 0) {
      return masks[masks.length - 1].close();
    }
    return null;
  }
  /**
   * Close all masks for the specified element
   * @internal
   */
  static unmaskAll(element = document.body) {
    return this.getElementMasks(element).forEach(mask => mask.close());
  }
  static getElementMasks(element) {
    return this.masks.filter(mask => mask.target === element);
  }
  //endregion
  //region Config
  updateAutoClose(delay) {
    this.deferredClose.cancel();
    if (delay) {
      this.deferredClose.delay = delay;
      this.deferredClose();
    }
  }
  updateCover() {
    this.syncCover();
  }
  syncCover() {
    var _this$owner, _this$owner$syncMaskC;
    (_this$owner = this.owner) === null || _this$owner === void 0 ? void 0 : (_this$owner$syncMaskC = _this$owner.syncMaskCover) === null || _this$owner$syncMaskC === void 0 ? void 0 : _this$owner$syncMaskC.call(_this$owner, this); // pass "this" since owner may not yet have assigned us to "masked"
  }

  onOwnerResize() {
    this.syncCover();
  }
  updateOwner(owner) {
    this.detachListeners('cover');
    owner === null || owner === void 0 ? void 0 : owner.ion({
      name: 'cover',
      recompose: 'onOwnerResize',
      resize: 'onOwnerResize',
      thisObj: this
    });
  }
  updateShowDelay(delay) {
    const {
      delayedShow
    } = this;
    delayedShow.delay = delay;
    if (!delay) {
      delayedShow.flush();
    }
  }
  //endregion
  //region Show & hide
  deferredClose() {
    var _owner$onMaskAutoClos2;
    const {
      owner
    } = this;
    this.close().then(() => {
      var _owner$onMaskAutoClos;
      owner === null || owner === void 0 ? void 0 : (_owner$onMaskAutoClos = owner.onMaskAutoClose) === null || _owner$onMaskAutoClos === void 0 ? void 0 : _owner$onMaskAutoClos.call(owner, this);
    });
    owner === null || owner === void 0 ? void 0 : (_owner$onMaskAutoClos2 = owner.onMaskAutoClosing) === null || _owner$onMaskAutoClos2 === void 0 ? void 0 : _owner$onMaskAutoClos2.call(owner, this);
  }
  delayedShow() {
    this.classes.remove('b-delayed-show');
  }
  /**
   * Show mask
   */
  show() {
    const me = this,
      {
        element,
        target,
        hiding,
        maskName
      } = me;
    // We don't do this because we may want to show but automatically close after a
    // brief delay. The order of applying those configs should not be an issue. In
    // other words, to stop the deferredClose, you must set autoClose to falsy.
    // me.deferredClose.cancel();
    if (hiding) {
      // Resolving seems much better than the only other options:
      //  1. Never settling
      //  2. Rejecting
      hiding.resolve();
      // This will be nulled out as the promise resolves but that is a race condition
      // compared to the next hide() call.
      me.hiding = null;
      me.clearTimeout('hide');
    }
    if (me.showDelay) {
      element.classList.add('b-delayed-show');
      me.delayedShow();
    }
    element.classList.add('b-visible');
    element.classList.remove('b-hidden');
    target.classList.add('b-masked');
    if (!target[maskName]) {
      target[maskName] = me;
      target.appendChild(element);
    }
    ArrayHelper.include(Mask.masks, me);
    me.shown = true;
    me.trigger('show');
    // blur has to blur child elements
    if (me.mode.endsWith('blur')) {
      DomHelper.forEachChild(target, child => {
        if (child !== element) {
          child.classList.add(`b-masked-${me.mode}`);
        }
      });
    }
  }
  /**
   * Hide mask
   * @returns {Promise} A promise which is resolved when the mask is hidden, or immediately if already hidden
   */
  hide() {
    const me = this,
      {
        target,
        element
      } = me;
    let {
      hiding
    } = me;
    if (!hiding) {
      if (!me.shown) {
        return Promise.resolve();
      }
      me.hiding = hiding = new Promissory();
      me.shown = false;
      element.classList.remove('b-visible');
      element.classList.add('b-hidden');
      target.classList.remove('b-masked');
      if (me.mode.endsWith('blur')) {
        DomHelper.forEachChild(target, child => {
          if (child !== element) {
            child.classList.remove(`b-masked-${me.mode}`);
          }
        });
      }
      hiding.promise = hiding.promise.then(() => {
        if (me.hiding === hiding) {
          me.hiding = null;
        }
      });
      me.setTimeout(() => hiding.resolve(), 500, 'hide');
    }
    return hiding.promise;
  }
  /**
   * Close mask (removes it)
   * @returns {Promise} A promise which is resolved when the mask is closed
   */
  async close() {
    await this.hide();
    this.destroy();
  }
  //endregion
}

Mask._$name = 'Mask';

/**
 * @module Core/widget/mixin/KeyMap
 */
/**
 * Mixin for widgets that allows for standardized and customizable keyboard shortcuts functionality. Can be configured
 * on any widget or compatible feature.
 *
 * ```javascript
 * const grid = new Grid({
 *     keyMap: {
 *         // Changing keyboard navigation to respond to WASD keys.
 *         w : 'navigateUp',
 *         a : 'navigateLeft',
 *         s : 'navigateDown',
 *         d : 'navigateRight',
 *
 *         // Removes mappings for arrow keys.
 *         ArrowUp    : null,
 *         ArrowLeft  : null,
 *         ArrowDown  : null,
 *         ArrowRight : null
 *     }
 * });
 * ```
 *
 * For more information on how to customize keyboard shortcuts, please see our guide (Guides/Customization/Keyboard
 * shortcuts)
 * @mixin
 */
var KeyMap = (Target => class KeyMap extends (Target || Base) {
  static $name = 'KeyMap';
  get widgetClass() {}
  /**
   * Override to attach the keyMap keydown event listener to something else than this.element
   * @private
   */
  get keyMapElement() {
    return this.element;
  }
  /**
   * Override to make keyMap resolve subcomponent actions to something else than this.features.
   * @private
   */
  get keyMapSubComponents() {
    return this.features;
  }
  static configurable = {
    keyMap: {
      value: null,
      $config: {
        merge: 'objects',
        nullify: true
      }
    }
  };
  /**
   * Returns the `keyMap` property name which matches the passed KeyboardEvent if any.
   * @param {KeyboardEvent} keyEvent
   * @param {Object} [keyMap=this.keyMap]
   * @returns {String} the key into the `keyMap` matched by the passed KeyboardEvent
   * @internal
   */
  matchKeyMapEntry(keyEvent, keyMap = this.keyMap) {
    if (keyMap && !keyEvent.handled && keyEvent.key !== undefined) {
      // Match a defined key combination, such as `Ctrl + Enter`
      return ObjectHelper.keys(keyMap).find(keyString => {
        const keys = keyString.split('+'),
          requireAlt = keys.includes('Alt'),
          requireShift = keys.includes('Shift'),
          requireCtrl = keys.includes('Ctrl');
        // Last key should be the actual key,
        let actualKey = keys[keys.length - 1].toLowerCase();
        if (actualKey === 'space') {
          actualKey = ' ';
        }
        // Modifiers in any order before the actual key
        return actualKey === keyEvent.key.toLowerCase() && (!keyEvent.altKey && !requireAlt || keyEvent.altKey && requireAlt) && (!keyEvent.ctrlKey && !requireCtrl || keyEvent.ctrlKey && requireCtrl) && (!keyEvent.shiftKey && !requireShift || keyEvent.shiftKey && requireShift);
      });
    }
  }
  /**
   * Called on keyMapElement keyDown
   * @private
   */
  performKeyMapAction(event) {
    const {
      keyMap
    } = this;
    let actionHandled = false;
    // We ignore if event is marked as handled
    if (keyMap && !event.handled && event.key !== undefined) {
      const key = this.matchKeyMapEntry(event);
      // Is there an action (fn to call) for that key combination
      if (keyMap[key]) {
        // Internally, action can be an array of actions in case of key conflicts
        const actions = ArrayHelper.asArray(keyMap[key]);
        // Flag to let actions know that's its keyMap that's calling
        event.fromKeyMap = true;
        let preventDefault;
        // The actions will be called in the order they were added to the array.
        for (let action of actions) {
          preventDefault = true;
          // Support for providing a config object as handler function to prevent event.preventDefault
          if (ObjectHelper.isObject(action)) {
            if (!action.handler) {
              continue;
            }
            if (action.preventDefault === false) {
              preventDefault = false;
            }
            action = action.handler;
          }
          if (typeof action === 'string') {
            var _thisObj$isActionAvai;
            const {
              thisObj,
              handler
            } = this.resolveKeyMapAction(action);
            // Check if action is available, for example widget is enabled
            if (((_thisObj$isActionAvai = thisObj.isActionAvailable) === null || _thisObj$isActionAvai === void 0 ? void 0 : _thisObj$isActionAvai.call(thisObj, {
              key,
              action,
              event,
              actionName: action.split('.').pop()
            })) !== false) {
              // If action function returns false, that means that it did not handle the action
              if (handler.call(thisObj, event) !== false) {
                actionHandled = true;
                break;
              }
            }
          } else if (action.call(this) !== false) {
            actionHandled = true;
            break;
          }
        }
        // Remove flag when completed
        delete event.fromKeyMap;
        if (actionHandled) {
          if (preventDefault) {
            event.preventDefault();
          }
          event.handled = true;
        }
      }
    }
    return actionHandled;
  }
  /**
   * Resolves correct `this` and handler function.
   * If subComponent (action includes a dot) it will resolve in keyMapSubComponents (defaults to this.features).
   *
   * For example, in feature configurable:
   * `keyMap: {
   *     ArrowUp: 'navigateUp'
   * }`
   *
   * Will be translated (by InstancePlugin) to:
   * `keyMap: {
   *     ArrowUp: 'featureName.navigateUp'
   * }
   *
   * And resolved to correct function path here.
   *
   * Override to change action function mapping.
   * @private
   */
  resolveKeyMapAction(action) {
    const {
      keyMapSubComponents
    } = this;
    if (action.startsWith('up.') || action.startsWith('this.')) {
      return this.resolveCallback(action);
    }
    if (keyMapSubComponents && action.includes('.')) {
      const [component, actionName] = action.split('.');
      if (component && actionName) {
        return {
          thisObj: keyMapSubComponents[component],
          handler: keyMapSubComponents[component][actionName]
        };
      }
    }
    return {
      thisObj: this,
      handler: this[action]
    };
  }
  updateKeyMap(keyMap) {
    var _this$keyMapDetacher;
    (_this$keyMapDetacher = this.keyMapDetacher) === null || _this$keyMapDetacher === void 0 ? void 0 : _this$keyMapDetacher.call(this);
    if (!ObjectHelper.isEmpty(keyMap)) {
      this.keyMapDetacher = EventHelper.on({
        element: this.keyMapElement,
        keydown: 'keyMapOnKeyDown',
        thisObj: this
      });
    }
  }
  // Hook on to this to catch keydowns before keymap does
  keyMapOnKeyDown(event) {
    this.performKeyMapAction(event);
  }
  /**
   * This function is used for merging two keyMaps with each other. It can be used for example by a Grid's feature to
   * merge the fetature's keyMap into the Grid's with the use of a subPrefix.
   * @param {Object} target - The existing keyMap.
   * @param {Object} source - The keyMap we want to merge into target.
   * @param {Object} subPrefix - If keyMap actions in source should be prefixed, the prefix should be provided here.
   * As example, the prefix * `rowCopyPaste` will give the action 'rowCopyPaste.action'.
   * @private
   */
  mergeKeyMaps(target, source, subPrefix = null) {
    const mergedKeyMap = {};
    if (target) {
      ObjectHelper.assign(mergedKeyMap, target);
    }
    for (const key in source) {
      if (!source[key]) {
        continue;
      }
      const existingActions = ArrayHelper.asArray(target === null || target === void 0 ? void 0 : target[key]),
        actions = [];
      if (existingActions !== null && existingActions !== void 0 && existingActions.length) {
        actions.push(...existingActions);
      }
      for (const action of ArrayHelper.asArray(source[key])) {
        // Mapping keymap actions to their corresponding feature's name, like group.toggleGroup
        if (ObjectHelper.isObject(action) && action.handler) {
          actions.push(ObjectHelper.assignIf({
            handler: (subPrefix ? subPrefix + '.' : '') + action.handler
          }, action));
        } else {
          actions.push((subPrefix ? subPrefix + '.' : '') + action);
        }
      }
      actions.sort((a, b) => {
        // Sort on weight
        const weight = (a.weight || 0) - (b.weight || 0);
        // Then put new actions before old
        if (weight === 0 && existingActions !== null && existingActions !== void 0 && existingActions.length) {
          return existingActions.indexOf(a) - existingActions.indexOf(b);
        }
        return weight;
      });
      mergedKeyMap[key] = actions;
    }
    return mergedKeyMap;
  }
});

/**
 * @module Core/widget/mixin/RTL
 */
/**
 * Mixin for RTL operation
 * @mixin
 * @private
 */
var RTL = (Target => class RTL extends (Target || Base) {
  static $name = 'RTL';
  get widgetClass() {}
  static configurable = {
    /**
     * If a widget is rendered into an element which has computed style `direction:rtl`, this property will be
     * set to `true`
     *
     * Rendering a widget into an element which, either by a CSS rule, or by its inline `style` has an
     * explicit direction will cause the widget to use that direction regardless of the owning document's
     * direction.
     *
     * In this way, an RTL widget may operate normally inside an LTR page and vice versa.
     *
     * If you are using Bryntum widgets in a different direction to that of the owning document, you
     * must use the following CSS rule to have Popups such as tooltips and event editors use
     * the desired direction instead of the direction of the document:
     *
     * ```CSS
     * .b-float-root {
     *     direction : xxx; // Floatings widgets to differ from the document
     * }
     * ```
     * @member {Boolean} rtl
     * @readonly
     * @private
     */
    /**
     * This may be configured as `true` to make the widget's element use the `direction:rtl` style.
     * @config {Boolean}
     * @default false
     * @private
     */
    rtl: null
  };
  // Replace generated is-property, to reduce risk of confusion
  get isRTL() {
    return this.rtl;
  }
  updateRtl(rtl) {
    const {
      element
    } = this;
    if (element) {
      element.classList.toggle('b-rtl', rtl === true);
      element.classList.toggle('b-ltr', rtl === false);
    }
  }
  startConfigure(config) {
    var _super$startConfigure;
    (_super$startConfigure = super.startConfigure) === null || _super$startConfigure === void 0 ? void 0 : _super$startConfigure.call(this, arguments);
    // If we are not configured with an rtl setting, acquire our rtl setting from our owner,
    // or our encapsulating (renderTo or adopt etc) element.
    // Floating widgets will do this at render time.
    if (!config.floating && config.rtl == null) {
      var _me$parent;
      const me = this,
        el = config.rootElement || config.forElement || ((_me$parent = me.parent) === null || _me$parent === void 0 ? void 0 : _me$parent.contentElement) || (me.floating ? me.floatRoot : me.changeElementRef(me.getRenderContext(config)[0] || config.adopt || document.body)),
        owner = config.owner || config.parent || me.constructor.fromElement(el);
      if (owner) {
        config.rtl = owner[owner.isConfiguring ? 'peekConfig' : 'getConfig']('rtl');
      } else {
        config.rtl = (el === null || el === void 0 ? void 0 : el.nodeType) === 1 && getComputedStyle(el).getPropertyValue('direction') === 'rtl';
      }
      // Ensure it is read in the ingestion phase.
      if (config.rtl) {
        me.configDone.rtl = false;
      }
    }
  }
  // Render is only called on outer widgets, children read their setting from their owner unless explicitly set
  render(...args) {
    var _this$owner;
    super.render && super.render(...args);
    if (BrowserHelper.isChrome && BrowserHelper.chromeVersion < 87 || BrowserHelper.isFirefox && BrowserHelper.firefoxVersion < 66 || BrowserHelper.isSafari && BrowserHelper.safariVersion < 14.1) {
      this.element.classList.add('b-legacy-inset');
    }
    // Detect if rtl (catches both attribute `dir="rtl"` and CSS `direction: rtl`, as well as if owner uses rtl)
    if (getComputedStyle(this.element).direction === 'rtl' || (_this$owner = this.owner) !== null && _this$owner !== void 0 && _this$owner.rtl) {
      var _this$childItems;
      this.rtl = true;
      (_this$childItems = this.childItems) === null || _this$childItems === void 0 ? void 0 : _this$childItems.forEach(i => i.rtl = true);
    }
  }
});

/**
 * @module Core/widget/Widget
 */
const assignValueDefaults = Object.freeze({
    highlight: false,
    onlyName: false
  }),
  floatRoots = [],
  highlightExternalChange = 'highlightExternalChange',
  isTransparent = /transparent|rgba\(0,\s*0,\s*0,\s*0\)/,
  renderConfigObserver = Symbol('renderConfigObserver'),
  textInputTypes = {
    INPUT: 1,
    TEXTAREA: 1
  },
  addElementListeners = (me, element, domConfig, refName) => {
    var _listeners;
    let listeners = (domConfig === null || domConfig === void 0 ? void 0 : domConfig.listeners) || (domConfig === null || domConfig === void 0 ? void 0 : domConfig.internalListeners);
    // eslint-disable-next-line bryntum/no-on-in-lib
    listeners = ((_listeners = listeners) === null || _listeners === void 0 ? void 0 : _listeners.on) || listeners;
    if (listeners) {
      const un = EventHelper.on(ObjectHelper.assign({
        element,
        thisObj: me
      }, listeners));
      if (refName) {
        // The domConfig for refs gets regenerated on each compose() so we cannot use them to store the un
        // functions.
        (me._refListeners || (me._refListeners = Object.create(null)))[refName] = un;
      } else {
        domConfig.listeners = {
          on: listeners,
          un
        };
      }
    }
  },
  mergeAnim = (value, was) => {
    // The show/hideAnimation objects can only have one animation property, but it is fine to merge if they have
    // the same property.
    return value && was && was[ObjectHelper.keys(value)[0]] ? Config.merge(value, was) : value;
  },
  // Need braces here. MUST NOT return false
  widgetTriggerPaint = w => {
    w.isVisible && w.triggerPaint();
  },
  negationPseudo = /^:not\((.+)\)$/,
  nonFlowedPositions = /absolute|fixed/i,
  isScaled = w => w.scale != null,
  {
    hasOwn
  } = ObjectHelper,
  {
    defineProperty
  } = Reflect,
  parseDuration = d => parseFloat(d) * (d.endsWith('ms') ? 1 : 1000),
  alignedClass = ['b-aligned-above', 'b-aligned-right', 'b-aligned-below', 'b-aligned-left'],
  returnFalseProp = {
    configurable: true,
    get() {
      return false;
    }
  },
  localizeRE = /(?:L\{([^}.]+)\})/,
  localizeTooltip = (string, part) => 'L{Tooltip.' + part + '}',
  alignSpecRe = /^([trblc])(\d*)-([trblc])(\d*)$/i,
  mergeAlign = (oldValue, newValue) => {
    // Promote eg 'l-r' to { align : 'l-r' } so that align configs can merge.
    // But only if they are rectangle align strings. align:'left', align:'start' etc. must not change.
    if (alignSpecRe.test(oldValue)) {
      oldValue = {
        align: oldValue
      };
    }
    if (alignSpecRe.test(newValue)) {
      newValue = {
        align: newValue
      };
    }
    return Config.merge(oldValue, newValue);
  },
  callbackRe = /^[\w.]+$/,
  // alignmentChanges flag encapsulates whether the aligning operation
  // has resized either dimension and in which way they are changed.
  // 0001 = Height has been reduced from original
  // 0010 = Height has been increased from original
  // 0100 = Width has been reduced from original
  // 1000 = Width has been increased from original
  alignChangeDims = {
    1: 'maxHeight',
    2: 'height',
    4: 'maxWidth',
    8: 'width'
  };
/**
 * Specification for how to align a Widget to another Widget, Element or Rectangle.
 *
 * @typedef {Object} AlignSpec
 * @property {HTMLElement|Core.widget.Widget|Core.helper.util.Rectangle} target The Widget or Element or Rectangle to
 * align to.
 * @property {Event} [domEvent] A pointer event to position this Widget by.
 * @property {Boolean} [anchor] True to show a pointer arrow connecting to the target. Defaults to false.
 * @property {Boolean} [overlap] True to allow this to overlap the target.
 * @property {String} [align] The edge alignment specification string, `[trblc]n-[trblc]n`.
 *
 * Defaults to this instance's `align` config.
 *
 * The edge alignment specification string describes two points to bring together. Each point is described by an edge
 * initial (`t` for top edge, `b` for bottom edge etc.) followed by a percentage along that edge.
 *
 * So the form would be `[trblc][n]-[trblc][n].` The `n` is the percentage offset along that edge which defines the
 * alignment point. This is not valid for alignment point `c` which means the center point.
 *
 * For example `t0-b0` would align this Widget's top left corner with the bottom left corner of the `target`.
 *
 * Also supports direction independent edges horizontally, `s` for start and `e` for end (maps to `l` and `r` for
 * LTR, `r` and `l` for RTL).
 * @property {HTMLElement|Core.widget.Widget|Core.helper.util.Rectangle} [constrainTo] The Widget or Element or
 * Rectangle to constrain to. If the requested alignment cannot be constrained (it will first shrink the resulting
 * Rectangle according to the `minWidth` and `minHeight` properties of this spec, or the Widget), then it will try
 * aligning at other edges (honouring the `axisLock` option), and pick the fallback alignment which results in the
 * shortest translation.
 * @property {Number|Number[]} [constrainPadding] The amount of pixels to pad from the `constrainTo` target, either a
 * single value, or an array of values in CSS edge order.
 * @property {Number} [minHeight] The minimum height this widget may be compressed to when constraining within the
 * `constrainTo` option.
 * @property {Number} [minWidth] The minimum width this widget may be compressed to when constraining within the
 * `constrainTo` option.
 * @property {Boolean|'flexible'} [axisLock] Specify as `true` to fall back to aligning against the opposite edge if the
 * requested alignment cannot be constrained into the `constrainTo` option. Specify as `'flexible'` to allow
 * continuation to try the other edges if a solution cannot be found on the originally requested axis.
 * @property {Boolean} [matchSize] When aligning edge-to-edge, match the length of the aligned-to edge of the target.
 * This is only honored when `axisLock` is enabled and alignment succeeds on the requested axis.
 * If __not__ aligning edge-to-edge, `matchSize` matches both dimensions of the target.
 * Specify as `true` to have this widget's size along the aligned edge match the size of the target's edge.
 * For example, a combobox's dropdown should match the width of the combobox.
 * @property {Number|Number[]} [offset] The offset to create an extra margin round the target to offset the aligned
 * widget further from the target. May be configured as -ve to move the aligned widget towards the target - for example
 * producing the effect of the anchor pointer piercing the target.
 * @property {Boolean} [monitorResize] Configure as `true` to monitor the element being aligned to for resizing while
 * visible to correct alignment.
 */
/**
 * Base class for other widgets. The Widget base class simply encapsulates an element, and may optionally contain some
 * specified {@link #config-html}.
 *
 * ## Rendering
 *
 * Subclasses should override the {@link #function-compose} method to return their encapsulating element and internal
 * DOM structure. The `compose()` method returns a {@link Core.helper.DomHelper#function-createElement-static} config
 * object that is* used to create the DOM structure, based on its {@link Core.Base#property-configurable-static}
 * properties:
 *
 * ```javascript
 *  class Button extends Widget {
 *      static get configurable() {
 *          return {
 *              cls  : null,
 *              text : null
 *          };
 *      }
 *
 *      compose() {
 *          const { cls, text } = this;  // collect all relevant configs properties (for auto-detection)
 *
 *          return {
 *              tag   : 'button',
 *              class : cls,
 *              text
 *          };
 *      }
 *  }
 * ```
 *
 * The config properties used by the `compose()` method are auto-detected when the method is first called for a class.
 * All relevant properties must be read, even if they end up not being used so that future changes to these properties
 * will mark the rendering as dirty.
 *
 * When a config property used by `compose()` is modified, the {@link #function-recompose} method is called. Since
 * `recompose()` is a {@link Core.mixin.Delayable#property-delayable-static delayable} method, calling it schedules a
 * delayed call to `compose()` and a DOM update. Accessing the Widget's primary `element` or any reference element
 * property will force the DOM update to occur immediately.
 *
 * ### Child Elements
 *
 * Unlike typical {@link Core.helper.DomHelper#function-createElement-static DOM config} objects, the object returned
 * by `compose()` can use an object to simplify naming:
 *
 * ```javascript
 *  class Button extends Widget {
 *      ...
 *
 *      compose() {
 *          const { cls, iconCls, text } = this;  // collect all relevant configs properties (for auto-detection)
 *
 *          return {
 *              tag   : 'button',
 *              class : cls,
 *
 *              children : {
 *                  iconElement : iconCls && {
 *                      class : {
 *                          'button-icon' : 1,
 *                          [iconCls]     : 1
 *                      }
 *                  },
 *
 *                  textElement : {
 *                      text
 *                  }
 *              }
 *          };
 *      }
 *  }
 * ```
 *
 * The keys of the `children` are [iterated](https://2ality.com/2015/10/property-traversal-order-es6.html) to convert
 * the values into the array required by {@link Core.helper.DomHelper#function-createElement-static}. The names of the
 * properties becomes the `reference` of the element.
 *
 * For example, the above is equivalent to the following:
 *
 * ```javascript
 *  class Button extends Widget {
 *      ...
 *
 *      compose() {
 *          const { cls, iconCls, text } = this;  // collect all relevant configs properties (for auto-detection)
 *
 *          return {
 *              tag   : 'button',
 *              class : cls,
 *
 *              children : [iconCls && {
 *                  reference : 'iconElement',
 *                  class : {
 *                      'button-icon' : 1,
 *                      [iconCls]     : 1
 *                  }
 *              }, {
 *                  reference : 'textElement',
 *                  text
 *              }]
 *          };
 *      }
 *  }
 * ```
 *
 * The object form of `children` is preferred for clarity but also because it facilitates inheritance.
 *
 * ### Inheritance
 *
 * When a derived class implements `compose()`, the object it returns is automatically merged with the object returned
 * by the base class.
 *
 * For example, the following class adds a new child element:
 *
 * ```javascript
 *  class MenuButton extends Button {
 *      ...
 *
 *      compose() {
 *          const { menuCls } = this;  // collect all relevant configs properties (for auto-detection)
 *
 *          return {
 *              children : {
 *                  menuElement : {
 *                      class : {
 *                          'button-menu' : 1,
 *                          [menuCls]     : 1
 *                      }
 *                  }
 *              }
 *          };
 *      }
 *  }
 * ```
 *
 * ### Listeners
 *
 * Reference elements may also define event `listeners` in the `compose()` method:
 *
 * ```javascript
 *  class Button extends Widget {
 *      compose() {
 *          const { cls, text } = this;
 *
 *          return {
 *              tag   : 'button',
 *              class : cls,
 *              text,
 *
 *              listeners : {
 *                  click : 'onClick'
 *              }
 *          };
 *      }
 *
 *      onClick(event) {
 *          // handle click event
 *      }
 *  }
 * ```
 *
 * ## Resolving properties
 *
 * Values for a Widgets properties can be resolved from the ownership hierarchy. For example a text field in a toolbar
 * can get its initial value from a property on the container owning the toolbar. This is achieved by prefixing the
 * desired property name with 'up.':
 *
 * ```javascript
 *  const grid = new Grid((
 *      tbar : [{
 *          type  : 'numberfield',
 *          // Fields value will be retrieved from the grids rowHeight property
 *          value : 'up.rowHeight'
 *      }]
 *  });
 * ```
 *
 * NOTE: this is for now a one way one time binding, the value will only be read initially and not kept up to date on
 * later changes.
 *
 * @mixes Core/mixin/Events
 * @mixes Core/localization/Localizable
 * @mixes Core/widget/mixin/KeyMap
 * @extends Core/Base
 * @classType widget
 * @widget
 */
class Widget extends Base.mixin(Localizable, Events, Delayable, Identifiable, Factoryable, KeyMap, RTL) {
  //region Config
  // Used when a config is a class and internally stored as a DomClassList
  // So that subclasses can add class names.
  static mergeCls(newValue, oldValue) {
    if (oldValue && newValue) {
      newValue = new DomClassList(oldValue).assign(typeof newValue === 'string' ? new DomClassList(newValue) : newValue);
    } else if (newValue && !newValue.isDomClassList) {
      newValue = new DomClassList(newValue);
    }
    return newValue;
  }
  /**
   * Class name getter.
   * Used when original ES6 class name is minified or mangled during production build.
   * Should be overridden in each class which extends Widget or it descendants.
   *
   * ```javascript
   * class MyNewClass extends Widget {
   *     static get $name() {
   *        return 'MyNewClass';
   *     }
   * }
   * ```
   *
   * @static
   * @member {String} $name
   * @advanced
   */
  static get $name() {
    return 'Widget';
  }
  /**
   * Widget name alias which you can use in the `items` of a Container widget.
   *
   * ```javascript
   * class MyWidget extends Widget {
   *     static get type() {
   *        return 'mywidget';
   *     }
   * }
   * ```
   *
   * ```javascript
   * const panel = new Panel({
   *    title : 'Cool widgets',
   *    items : [
   *       { type : 'mywidget', html : 'Lorem ipsum dolor sit amet...' }
   *    ]
   * });
   * ```
   *
   * @static
   * @member {String} type
   */
  static get type() {
    return 'widget';
  }
  static get configurable() {
    return {
      /**
       * Get this widget's encapsulating HTMLElement, which is created along with the widget but added to DOM at
       * render time.
       * @member {HTMLElement} element
       * @readonly
       * @category DOM
       */
      /**
       * A {@link Core.helper.DomHelper#function-createElement-static} config object or HTML string from which to
       * create the Widget's element.
       * @private
       * @config {DomConfig|String}
       * @category DOM
       */
      element: true,
      /**
       * Set to false to not call onXXX method names (e.g. `onShow`, `onClick`), as an easy way to listen for events.
       *
       * ```javascript
       * const container = new Container({
       *     callOnFunctions : true
       *
       *     onHide() {
       *          // Do something when the 'hide' event is fired
       *     }
       * });
       * ```
       * @config {Boolean}
       * @default
       */
      callOnFunctions: true,
      /**
       * Get/set widgets id
       * @member {String} id
       * @category DOM
       */
      /**
       * Widget id, if not specified one will be generated. Also used for lookups through Widget.getById
       * @config {String}
       * @category DOM
       */
      id: '',
      /**
       * The HTML to display initially or a function returning the markup (called at widget construction time)
       *
       * This may be specified as the name of a function which can be resolved in the component ownership
       * hierarchy, such as 'up.getHTML' which will be found on an ancestor Widget.
       * @config {String|Function}
       * @param {Core.widget.Widget} me The calling Widget
       * @category DOM
       */
      html: null,
      /**
       * Set HTML content safely, without disturbing sibling elements which may have been
       * added to the {@link #property-contentElement} by plugins and features.
       * When specifying html, this widget's element will also have the {@link #config-htmlCls}
       * added to its classList, to allow targeted styling.
       * @member {String} content
       * @category DOM
       * @advanced
       */
      /**
       * The HTML content that coexists with sibling elements which may have been added to the
       * {@link #property-contentElement} by plugins and features.
       * When specifying html, this widget's element will also have the {@link #config-htmlCls}
       * class added to its classList, to allow targeted styling.
       * @config {String} content
       * @category DOM
       * @advanced
       */
      content: null,
      /**
       * Custom CSS classes to add to element.
       * May be specified as a space separated string, or as an object in which property names
       * with truthy values are used as the class names:
       * ```javascript
       *  cls : {
       *      'b-my-class'     : 1,
       *      [this.extraCls]  : 1,
       *      [this.activeCls] : this.isActive
       *  }
       *  ```
       *
       * @prp {String|Object}
       * @category CSS
       */
      cls: {
        $config: {
          merge: 'classList'
        },
        value: null
      },
      /**
       * Custom CSS class name suffixes to apply to the elements rendered by this widget. This may be specified
       * as a space separated string, an array of strings, or as an object in which property names with truthy
       * values are used as the class names.
       *
       * For example, consider a `Panel` with a `ui` config like so:
       *
       * ```javascript
       *  new Panel({
       *      text : 'OK',
       *      ui   : 'light'
       *  });
       * ```
       * This will apply the CSS class `'b-panel-ui-light'` to the main element of the panel as well as its many
       * child elements. This allows simpler CSS selectors to match the child elements of this particular panel
       * UI:
       *
       * ```css
       *  .b-panel-content.b-panel-ui-light {
       *      background-color : #eee;
       *  }
       * ```
       * Using the {@link #config-cls cls config} would make matching the content element more complex, and in
       * the presence of {@link Core.widget.Panel#config-strips docked items} and nested panels, impossible to
       * target accurately.
       *
       * @config {String|Object}
       * @category CSS
       */
      ui: {
        $config: {
          merge: 'classList'
        },
        value: null
      },
      /**
       * Determines how a {@link Core.widget.Panel#config-collapsed} panel will treat this widget if it resides
       * within the panel's header (for example, as one of its {@link Core.widget.Panel#config-strips} or
       * {@link Core.widget.Panel#config-tools}).
       *
       * Valid options are:
       *  - `null` : The widget will be moved to the overlay header when the panel is collapsed (the default).
       *  - `false` : The widget will be unaffected when the panel is collapsed and will remain in the primary
       *    panel header at all times.
       *  - `'hide'` : The widget will be hidden when the panel is collapsed.
       *  - `'overlay'` : The widget will only appear in the collapsed panel's overlay header. See
       *    {@link Core.widget.panel.PanelCollapserOverlay collapsible type='overlay'}.
       *
       * @config {Boolean|'hide'|'overlay'}
       * @internal
       */
      collapsify: null,
      /**
       * Custom CSS classes to add to the {@link #property-contentElement}.
       * May be specified as a space separated string, or as an object in which property names
       * with truthy values are used as the class names:
       * ```javascript
       *  cls : {
       *      'b-my-class'     : 1,
       *      [this.extraCls]  : 1,
       *      [this.activeCls] : this.isActive
       *  }
       *  ```
       *
       * @config {String|Object}
       * @category CSS
       * @advanced
       */
      contentElementCls: {
        $config: {
          merge: 'classList'
        },
        value: null
      },
      /**
       * Custom CSS classes to add to this widget's `element`. This property is typically used internally to
       * assign default CSS classes while allowing `cls` to alter these defaults. It is not recommended that
       * client code set this config but instead should set `cls`.
       *
       * For example, to remove a class defined by `defaultCls` using `cls`, declare the class name as a key with
       * a falsy value:
       *
       * ```javascript
       *  cls : {
       *      'default-class' : false
       *  }
       * ```
       * @config {String|Object|String[]}
       * @internal
       */
      defaultCls: {
        $config: {
          merge: 'classList'
        },
        value: null
      },
      /**
       * Controls the placement of this widget when it is added to a {@link Core.widget.Panel panel's }
       * {@link Core.widget.Panel#config-strips strips collection}. Typical values for this config are `'top'`,
       * `'bottom'`, `'left'`, or `'right'`, which cause the widget to be placed on that side of the panel's
       * body. Such widgets are called "edge strips".
       *
       * Also accepts direction neutral horizontal values `'start'` and `'end'`.
       *
       * If this config is set to `'header'`, the widget is placed in the panel's header, following the title. If
       * this config is set to `'pre-header'`, the widget is placed before the title. Such widgets are called
       * "header strips".
       *
       * @config {'top'|'bottom'|'left'|'right'|'start'|'end'|'header'|'pre-header'|Object} dock
       * @category Layout
       */
      dock: null,
      /**
       * The events to forward from an overflow twin to its origin widget.
       *
       * May be specified as a space separated string, or as an object in which property names
       * with truthy values are used as the event names:
       * ```javascript
       *  forwardTwinEvents : {
       *      change : this.syncTwinOnChange,
       *      input  : 1
       *  }
       *  ```
       * NOTE: This config cannot be dynamically changed after the `overflowTwin` has been created (see
       * {@link #function-ensureOverflowTwin}.
       * @config {String|String[]|Object}
       * @internal
       */
      forwardTwinEvents: {
        $config: {
          merge: 'classList'
        },
        value: null
      },
      parent: null,
      /**
       * The {@link Core.widget.Tab tab} created for this widget when it is placed in a
       * {@link Core.widget.TabPanel}.
       * @member {Core.widget.Tab} tab
       * @readonly
       * @category Misc
       */
      /**
       * A configuration for the {@link Core.widget.Tab tab} created for this widget when it is placed in a
       * {@link Core.widget.TabPanel}. For example, this config can be used to control the icon of the `tab` for
       * this widget:
       *
       * ```javascript
       *  items : [{
       *      type : 'panel',
       *      // other configs...
       *
       *      tab : {
       *          icon : 'b-fa-wrench'
       *      }
       *  }, ... ]
       * ```
       *
       * Another use for this config is to set the tab's {@link Core.widget.mixin.Rotatable#config-rotate} value
       * differently than the default managed by the `TabPanel`:
       *
       * ```javascript
       *  items : [{
       *      type : 'panel',
       *      // other configs...
       *
       *      tab : {
       *          rotate : false   // don't rotate even if tabBar is docked left or right
       *      }
       *  }, ... ]
       * ```
       *
       * Set this to `false` to prevent the creation of a `tab` for this widget. In this case, this widget must
       * be {@link #function-show shown} explicitly. The {@link Core.widget.TabPanel#config-activeTab} for the
       * tab panel will be -1 in this situation.
       *
       * ```javascript
       *  items : [{
       *      type : 'panel',
       *      tab  : false,    // no tab for this item
       *
       *      // other configs...
       *  }, ... ]
       * ```
       *
       * @config {Boolean|TabConfig} tab
       * @category Misc
       */
      tab: null,
      /**
       * An object specifying attributes to assign to the root element of this widget
       * @internal
       * @config {Object}
       * @category Misc
       */
      elementAttributes: null,
      /**
       * The CSS class(es) to add when HTML content is being applied to this widget.
       * @config {String|Object}
       * @category CSS
       */
      htmlCls: {
        $config: {
          merge: 'classList'
        },
        value: {
          'b-html': 1
        }
      },
      /**
       * Custom style spec to add to element
       * @config {String}
       * @category CSS
       */
      style: null,
      /**
       * Get/set element's disabled state
       * @member {Boolean} disabled
       * @category Misc
       */
      /**
       * Disable or enable the widget. It is similar to {@link #config-readOnly} except a disabled widget
       * cannot be focused, uses a different rendition (usually greyish) and does not allow selecting its value.
       * @default false
       * @config {Boolean}
       * @category Misc
       */
      disabled: null,
      /**
       * Get/set element's readOnly state. This is only valid if the widget is an input
       * field, __or contains input fields at any depth__. Updating this property will trigger
       * a {@link #event-readOnly} event.
       *
       * All descendant input fields follow the widget's setting. If a descendant
       * widget has a readOnly config, that is set.
       * @member {Boolean} readOnly
       * @category Misc
       */
      /**
       * Whether this widget is read-only.  This is only valid if the widget is an input
       * field, __or contains input fields at any depth__.
       *
       * All descendant input fields follow the widget's setting. If a descendant
       * widget has a readOnly config, that is set.
       * @default false
       * @config {Boolean}
       * @category Misc
       */
      readOnly: {
        value: null,
        default: false,
        $config: null
      },
      /**
       * Determines if the widgets read-only state should be controlled by its parent.
       *
       * When set to `false`, setting a parent container to read-only will not affect the widget. When set to
       * `true`, it will.
       *
       * @category Misc
       * @config {Boolean}
       * @default false
       */
      ignoreParentReadOnly: null,
      /**
       * Element (or element id) to adopt as this Widget's encapsulating element. The widget's
       * content will be placed inside this element.
       *
       * If this widget has not been configured with an id, it will adopt the id of the element
       * in order to preserve CSS rules which may apply to the id.
       * @config {HTMLElement|String}
       * @default
       * @category DOM
       */
      adopt: null,
      /**
       * Element (or the id of an element) to append this widget's element to. Can be configured, or set once at
       * runtime. To access the element of a rendered widget, see {@link #property-element}.
       * @prp {HTMLElement}
       * @accepts {HTMLElement|String}
       * @category DOM
       */
      appendTo: null,
      /**
       * Element (or element id) to insert this widget before. If provided, {@link #config-appendTo} config is ignored.
       * @prp {HTMLElement|String}
       * @category DOM
       */
      insertBefore: null,
      /**
       * Element (or element id) to append this widget element to, as a first child. If provided, {@link #config-appendTo} config is ignored.
       * @prp {HTMLElement|String}
       * @category DOM
       */
      insertFirst: null,
      /**
       * Object to apply to elements dataset (each key will be used as a data-attribute on the element)
       * @config {Object}
       * @category DOM
       */
      dataset: null,
      /**
       * Tooltip for the widget, either as a string or as a Tooltip config object.
       *
       * By default, the Widget will use a single, shared instance to display its tooltip as configured,
       * reconfiguring it to the specification before showing it. Therefore, it may not be permanently
       * mutated by doing things such as adding fixed event listeners.
       *
       * To have this Widget *own* its own `Tooltip` instance, add the property `newInstance : true`
       * to the configuration. In this case, the tooltip's {@link #property-owner} will be this Widget.
       *
       * __Note that in the absence of a configured {@link #config-ariaDescription}, the tooltip's value
       * will be used to populate an `aria-describedBy` element within this Widget.__
       * @config {String|TooltipConfig}
       * @category Misc
       */
      tooltip: {
        $config: ['lazy', 'nullify'],
        value: null
      },
      /**
       * Set to false to not show the tooltip when this widget is {@link #property-disabled}
       * @config {Boolean}
       * @default
       * @category Misc
       */
      showTooltipWhenDisabled: true,
      /**
       * Prevent tooltip from being displayed on touch devices. Useful for example for buttons that display a
       * menu on click etc, since the tooltip would be displayed at the same time.
       * @config {Boolean}
       * @default false
       * @category Misc
       */
      preventTooltipOnTouch: null,
      /**
       * When this is configured as `true` a [ResizeObserver](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver)
       * is used to monitor this element for size changes caused by either style manipulation, or by CSS
       * layout.
       *
       * Size changes are announced using the {@link #event-resize} event.
       * @config {Boolean}
       * @default false
       * @category Misc
       * @advanced
       */
      monitorResize: {
        $config: ['lazy', 'nullify'],
        value: null
      },
      /**
       * Set to `true` to apply the default mask to the widget. Alternatively, this can be the mask message or a
       * {@link Core.widget.Mask} config object.
       * @config {Boolean|String|MaskConfig}
       * @category Misc
       */
      masked: {
        $config: 'nullify',
        value: null
      },
      /**
       * This config object contains the defaults for the {@link Core.widget.Mask} created for the
       * {@link #config-masked} config. Any properties specified in the `masked` config will override these
       * values.
       * @config {MaskConfig}
       * @category Misc
       */
      maskDefaults: {
        target: 'element'
      },
      cache: {},
      /**
       * Set to `true` to move the widget out of the document flow and position it
       * absolutely in browser viewport space.
       * @config {Boolean}
       * @default
       * @category Float & align
       */
      floating: null,
      /**
       * Set to `true` when a widget is rendered into another widget's {@link #property-contentElement}, but must
       * not participate in the standard layout of that widget, and must be positioned relatively to that
       * widget's {@link #property-contentElement}.
       *
       * {@link Core.widget.Editor Editor}s are positioned widgets.
       * @config {Boolean}
       * @default
       * @category Float & align
       */
      positioned: null,
      /**
       * _Only valid if this Widget is {@link #config-floating}._
       * Set to `true` to be able to drag a widget freely on the page. Or set to an object with a handleSelector
       * property which controls when a drag should start.
       *
       * ```javascript
       *
       * draggable : {
       *     handleSelector : ':not(button)'
       * }
       *
       * ```
       *
       * @config {Boolean|Object}
       * @property {String} handleSelector CSS selector used to determine if drag can be started from a
       * mouse-downed element inside the widget
       * @default false
       * @category Float & align
       */
      draggable: null,
      /**
       * _Only valid if this Widget is {@link #config-floating}._
       *
       * How to align this element with its target when {@link #function-showBy} is called
       * passing a simple element as an align target.
       *
       * Either a full alignment config object, or for simple cases, the edge alignment string to use.
       *
       * When using a simple string, the format is `'[trblc]n-[trblc]n'` and it specifies our edge and
       * the target edge plus optional offsets from 0 to 100 along the edges to align to. Also supports direction
       * independent edges horizontally, `s` for start and `e` for end (maps to `l` and `r` for LTR, `r` and `l`
       * for RTL).
       *
       * See the {@link #function-showBy} function for more details about using the object form.
       *
       * Once set, this is stored internally in object form.
       * @config {AlignSpec|String}
       * @category Float & align
       */
      align: {
        $config: {
          merge: mergeAlign
        },
        value: 't-b'
      },
      /**
       * _Only valid if this Widget is {@link #config-floating}._
       * Set to `true` to centre the Widget in browser viewport space.
       * @config {Boolean}
       * @default
       * @category Float & align
       */
      centered: null,
      /**
       * _Only valid if this Widget is {@link #config-floating} or {@link #config-positioned}._
       * Element, Widget or Rectangle to which this Widget is constrained.
       * @config {HTMLElement|Core.widget.Widget|Core.helper.util.Rectangle}
       * @default document.body
       * @category Float & align
       */
      constrainTo: undefined,
      /**
       * _Only valid if this Widget is {@link #config-floating} and being shown through {@link #function-showBy}._
       * `true` to show a connector arrow pointing to the align target.
       * @config {Boolean}
       * @default false
       * @category Float & align
       */
      anchor: null,
      /**
       * The owning Widget of this Widget. If this Widget is directly contained, this will be the containing Widget.
       * If there is a `forElement`, this config will be that element's encapsulating Widget.
       *
       * If this Widget is floating, this config must be specified by the developer.
       * @config {Core.widget.Widget}
       * @category Misc
       */
      owner: null,
      /**
       * Defines what to do if document is scrolled while Widget is visible (only relevant when floating is set to true).
       * Valid values: null: do nothing, hide: hide the widget or realign: realign to the target if possible.
       * @config {'hide'|'realign'|null}
       * @default
       * @category Float & align
       */
      scrollAction: null,
      /**
       * _Only valid if this Widget is {@link #config-floating}._
       *
       * An object which defined which CSS style property should be animated upon hide, and how it should be
       * animated eg:
       *
       * ```javascript
       * {
       *    opacity: {
       *        to : 0,
       *        duration: '10s',
       *        delay: '0s'
       *    }
       * }
       * ```
       *
       * Set to `'false'` to disable animation.
       *
       * @config {Boolean|Object}
       * @category Float & align
       */
      hideAnimation: {
        $config: {
          merge: mergeAnim
        },
        value: null
      },
      /**
       * _Only valid if this Widget is {@link #config-floating}._
       *
       * An object which defined which CSS style property should be animated upon show, and how it should be
       * animated eg:
       *
       * ```javascript
       * {
       *    opacity: {
       *        to : 1,
       *        duration: '10s',
       *        delay: '0s'
       *    }
       * }
       * ```
       *
       * Set to `'false'` to disable animation.
       *
       * @config {Boolean|Object}
       * @category Float & align
       */
      showAnimation: {
        $config: {
          merge: mergeAnim
        },
        value: null
      },
      /**
       * The x position for the widget.
       *
       * _Only valid if this Widget is {@link #config-floating} and not aligned or anchored to an element._
       *
       * @config {Number}
       * @default
       * @category Float & align
       */
      x: null,
      /**
       * The y position for the widget.
       *
       * _Only valid if this Widget is {@link #config-floating} and not aligned or anchored to an element._
       *
       * @config {Number}
       * @default
       * @category Float & align
       */
      y: null,
      /**
       * Accessor to the {@link Core.helper.util.Scroller} which can be used
       * to both set and read scroll information.
       * @member {Core.helper.util.Scroller} scrollable
       * @category Layout
       */
      /**
       * Specifies whether (and optionally in which axes) a Widget may scroll. `true` means this widget may scroll
       * in both axes. May be an object containing boolean `overflowX` and `overflowY` properties which are
       * applied to CSS style properties `overflowX` and `overflowY`. If they are boolean, they are translated to
       * CSS overflow properties thus:
       *
       * *`true` -> `'auto'`
       * *`false` -> `'hidden'`
       *
       * After initialization, this property yields a {@link Core.helper.util.Scroller} which may be used to both
       * set and read scroll information.
       *
       * A Widget uses its `get overflowElement` property to select which element is to be scrollable. By default,
       * in the base `Widget` class, this is the Widget's encapsulating element. Subclasses may implement `get
       * overflowElement` to scroll inner elements.
       * @config {Boolean|ScrollerConfig|Core.helper.util.Scroller}
       * @default false
       * @category Scrolling
       */
      scrollable: {
        $config: ['lazy', 'nullify'],
        value: null
      },
      /**
       * The class to instantiate to use as the {@link #config-scrollable}. Defaults to
       * {@link Core.helper.util.Scroller}.
       * @internal
       * @config {Core.helper.util.Scroller}
       * @typings {typeof Scroller}
       * @category Scrolling
       */
      scrollerClass: Scroller,
      /**
       * The name of the property to set when a single value is to be applied to this Widget. Such as when used
       * in a grid WidgetColumn, this is the property to which the column's `field` is applied.
       * @config {String}
       * @default 'html'
       * @category Misc
       */
      defaultBindProperty: 'html',
      /**
       * Event that should be considered the default action of the widget. When that event is triggered the
       * widget is also expected to trigger an `action` event. Purpose is to allow reacting to most widgets in
       * a coherent way.
       * @private
       * @config {String}
       * @category Misc
       */
      defaultAction: null,
      /**
       * When set to `true`, this widget is considered as a whole when processing {@link Core.widget.Toolbar}
       * overflow. When `false`, this widget's child items are considered instead.
       *
       * When set to the string `'none'`, this widget is ignored by overflow processing. This option should be
       * used with caution as it prevents the overflow algorithm from moving such widgets into the overflow
       * popup which may result in not clearing enough space to avoid overflowing the toolbar.
       * @config {Boolean|String}
       * @default true
       * @category Layout
       * @internal
       */
      overflowable: {
        value: null,
        default: true,
        $config: null
      },
      /**
       * Widget's width, used to set element style.width. Either specify a valid width string or a number, which
       * will get 'px' appended. We recommend using CSS as the primary way to control width, but in some cases
       * this config is convenient.
       * @config {String|Number}
       * @category Layout
       */
      width: null,
      /**
       * Widget's height, used to set element style.height. Either specify a valid height string or a number, which
       * will get 'px' appended. We recommend using CSS as the primary way to control height, but in some cases
       * this config is convenient.
       * @config {String|Number}
       * @category Layout
       */
      height: null,
      /**
       * The element's maxHeight. Can be either a String or a Number (which will have 'px' appended). Note that
       * like {@link #config-height}, _reading_ the value will return the numeric value in pixels.
       * @config {String|Number}
       * @category Layout
       */
      maxHeight: null,
      /**
       * The elements maxWidth. Can be either a String or a Number (which will have 'px' appended). Note that
       * like {@link #config-width}, _reading_ the value will return the numeric value in pixels.
       * @config {String|Number}
       * @category Layout
       */
      maxWidth: null,
      /**
       * The elements minWidth. Can be either a String or a Number (which will have 'px' appended). Note that
       * like {@link #config-width}, _reading_ the value will return the numeric value in pixels.
       * @config {String|Number}
       * @category Layout
       */
      minWidth: null,
      /**
       * The element's minHeight. Can be either a String or a Number (which will have 'px' appended). Note that
       * like {@link #config-height}, _reading_ the value will return the numeric value in pixels.
       * @config {String|Number}
       * @category Layout
       */
      minHeight: null,
      // not public, only used by us in docs
      scaleToFitWidth: null,
      allowGrowWidth: true,
      // only used if scaleToFitWidth is true
      /**
       * Get element's margin property. This may be configured as a single number or a `TRBL` format string.
       * numeric-only values are interpreted as pixels.
       * @member {Number|String} margin
       * @category Layout
       */
      /**
       * Widget's margin. This may be configured as a single number or a `TRBL` format string.
       * numeric-only values are interpreted as pixels.
       * @config {Number|String}
       * @category Layout
       */
      margin: null,
      /**
       * Get element's flex property. This may be configured as a single number or a format string:
       *
       *      <flex-grow> <flex-shrink> <flex-basis>
       *
       * Numeric-only values are interpreted as the `flex-grow` value.
       * @member {Number|String} flex
       * @category Layout
       */
      /**
       * When this widget is a child of a {@link Core.widget.Container}, it will by default be participating in a
       * flexbox layout. This config allows you to set this widget's
       * <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex">flex</a> style.
       * This may be configured as a single number or a `<flex-grow> <flex-shrink> <flex-basis>` format string.
       * numeric-only values are interpreted as the `flex-grow` value.
       * @config {Number|String}
       * @category Layout
       */
      flex: null,
      /**
       * A widgets weight determines its position among siblings when added to a {@link Core.widget.Container}.
       * Higher weights go further down.
       * @config {Number}
       * @category Layout
       */
      weight: null,
      /**
       * Get/set this widget's `align-self` flexbox setting. This may be set to modify how this widget is aligned
       * within the cross axis of a flexbox layout container.
       * @member {String} alignSelf
       * @category Layout
       */
      /**
       * When this widget is a child of a {@link Core.widget.Container}, it will by default be participating in a
       * flexbox layout. This config allows you to set this widget's
       * <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/align-self">align-self</a> style.
       * @config {String}
       * @category Layout
       */
      alignSelf: null,
      /**
       * Configure as `true` to have the component display a translucent ripple when its
       * {@link #property-focusElement}, or {@link #property-element} is tapped *if the
       * current theme supports ripples*. Out of the box, only the Material theme supports ripples.
       *
       * This may also be a config object containing the properties listed below.
       *
       * eg:
       *```
       *    columns  : [{}...],
       *    ripple   : {
       *        color : 'red',
       *        clip  : '.b-grid-row'
       *    },
       *    ...
       *```
       * @config {Boolean|Object}
       * @property {String} [delegate] A CSS selector to filter which child elements trigger ripples. By default,
       * the ripple is clipped to the triggering element.
       * @property {String} [color='#000'] A CSS color name or specification.
       * @property {Number} [radius=100] The ending radius of the ripple. Note that it will be clipped by the
       * target element by default.
       * @property {String} [clip] A string which describes how to clip the ripple if it is not to be clipped to
       * the default element. Either the property of the widget to use as the clipping element, or a selector to
       * allow clipping to the closest matching ancestor to the target element.
       * @category Misc
       */
      ripple: null,
      /**
       * A title to display for the widget. Only in effect when inside a container that uses it (such as TabPanel)
       * @default
       * @config {String}
       * @category DOM
       */
      title: null,
      localizableProperties: ['title', 'ariaLabel', 'ariaDescription'],
      // Set this flag to require element to have a size to be considered visible
      requireSize: false,
      /**
       * An identifier by which this widget will be registered in the {@link Core.widget.Container#property-widgetMap}
       * of all ancestor containers.
       *
       * If omitted, this widget will be registered using its {@link #config-id}. In most cases `ref` is
       * preferable over `id` since `id` is required to be globally unique while `ref` is not.
       *
       * The `ref` value is also added to the elements dataset, to allow targeting it using CSS etc.
       * @prp {String}
       * @readonly
       * @category Misc
       */
      ref: null,
      /**
       * Get/set the widget hidden state.
       *
       * Note: `hidden : false` does *not* mean that this widget is definitely visible.
       * To ascertain visibility, use the {@link #property-isVisible} property.
       * @member {Boolean} hidden
       * @category Visibility
       */
      /**
       * Configure with true to make widget initially hidden.
       * @default false
       * @config {Boolean}
       * @category Layout
       */
      hidden: null,
      /**
       * Text alignment: 'left', 'center' or 'right'. Also accepts direction neutral 'start' and 'end'.
       *
       * Applied by adding a `b-text-align-xx` class to the widgets element. Blank by default, which does not add
       * any alignment class.
       *
       * To be compliant with RTL, 'left' yields same result as 'start' and 'right' as 'end'.
       *
       * @config {'left'|'center'|'right'|'start'|'end'}
       * @category Layout
       */
      textAlign: null,
      // When adding our scroll listeners to hide/realign, we ignore events
      // happening too quickly as a result of the show/align action
      ignoreScrollDuration: 500,
      /**
       * The tag name of this Widget's root element
       * @config {String}
       * @default
       * @category DOM
       * @advanced
       */
      tag: 'div',
      /**
       * Set this config to `false` to disable batching DOM updates on animation frames for this widget. This
       * has the effect of synchronously updating the DOM when configs affecting the rendered DOM are modified.
       * Depending on the situation, this could simplify code while increasing time spent updating the DOM.
       * @config {Boolean}
       * @default true
       * @internal
       */
      recomposeAsync: null,
      /**
       * If you are rendering this widget to a shadow root inside a web component, set this config to the shadowRoot
       * @config {ShadowRoot}
       * @default
       * @category Misc
       */
      rootElement: null,
      htmlMutationObserver: {
        $config: ['lazy', 'nullify'],
        value: {
          childList: true,
          subtree: true
        }
      },
      role: {
        $config: 'lazy',
        value: 'presentation'
      },
      /**
       * A localizable string (May contain `'L{}'` tokens which resolve in the locale file) to inject as
       * the `aria-label` attribute.
       *
       * This widget is passed as the `templateData` so that functions in the locale file can
       * interrogate the widget's state.
       * @config {String}
       * @category Accessibility
       * @advanced
       */
      ariaLabel: {
        $config: 'lazy',
        value: null
      },
      /**
       * A localizable string (May contain `'L{}'` tokens which resolve in the locale file) to inject
       * into an element which will be linked using the `aria-describedby` attribute.
       *
       * This widget is passed as the `templateData` so that functions in the locale file can
       * interrogate the widget's state.
       * @config {String}
       * @category Accessibility
       * @advanced
       */
      ariaDescription: {
        $config: 'lazy',
        value: null
      },
      ariaElement: 'element',
      ariaHasPopup: null,
      realignTimeout: 300,
      testConfig: {
        ignoreScrollDuration: 100,
        realignTimeout: 50
      },
      /**
       * _Only valid if this Widget is {@link #config-floating}._
       *
       * When configured as `true`, this widget uses {@link Core.helper.BrowserHelper#property-isMobile-static}
       * to maximize itself on mobile devices.
       * @prp {Number|String}
       * @category Float & align
       */
      maximizeOnMobile: null
    };
  }
  static get prototypeProperties() {
    return {
      /**
       * true if no id was set, will use generated id instead (widget1, ...). Toggle automatically on creation
       * @member {Boolean} hasGeneratedId
       * @private
       * @category Misc
       */
      hasGeneratedId: false,
      /**
       * This readonly property is `true` for normal widgets in the {@link Core.widget.Container#config-items} of
       * a container. It is `false` for special widgets such as a {@link Core.widget.Panel#config-tbar}.
       * @member {Boolean} innerItem
       * @internal
       * @category Misc
       */
      innerItem: true
    };
  }
  static get declarable() {
    return [
    /**
     * This property declares the set of config properties that affect a Widget's rendering, i.e., the configs
     * used by the {@link #function-compose} method.
     *
     * For example:
     * ```javascript
     *  class Button extends Widget {
     *      static renderConfigs = [ 'cls', 'iconCls', 'text' ];
     *  }
     * ```
     *
     * Alternatively this can be an object:
     *
     * ```javascript
     *  class Button extends Widget {
     *      static renderConfigs = {
     *          cls     : true,
     *          iconCls : true,
     *          text    : true
     *      };
     *  }
     * ```
     * @member {Object|String[]} renderConfigs
     * @static
     * @category Configuration
     * @internal
     */
    'renderConfigs'];
  }
  /**
   * An object providing the `record` and `column` for a widget embedded inside a {@link Grid.column.WidgetColumn}
   *
   * ```javascript
   * columns : [
   *    {
   *        type   : 'widget',
   *        widgets: [{
   *            type     : 'button',
   *            icon     : 'b-fa b-fa-trash',
   *            onAction : ({ source : btn }) => btn.cellInfo.record.remove()
   *        }]
   *    }
   * ]
   * ```
   * @readonly
   * @member {Object} cellInfo
   * @property {Core.data.Model} cellInfo.record Record for the widgets row
   * @property {Object} cellInfo.column Column the widget is displayed in
   * @category Misc
   */
  static get delayable() {
    return {
      recompose: 'raf',
      doHideOrRealign: 'raf',
      // Screen size and orientation changes must be buffered in line with.
      // ResponsiveMixin whose responsiveUpdate method is on a RAF.
      onAlignConstraintChange: 'raf'
    };
  }
  static get factoryable() {
    return {
      defaultType: 'widget'
    };
  }
  static get identifiable() {
    return {};
  }
  /**
   * Returns an array containing all existing Widgets. The returned array is generated by this call and is not an
   * internal structure.
   * @property {Core.widget.Widget[]}
   * @readonly
   * @internal
   */
  static get all() {
    return super.all;
  }
  /**
   * Get/set the {@link #config-recomposeAsync} config for all widgets. Setting this value will set the config for
   * all existing widgets and will be the default value for newly created widgets. Set this value to `null` to disable
   * the default setting for new widgets while leaving existing widgets unaffected.
   * @property {Boolean}
   * @internal
   */
  static get recomposeAsync() {
    return Widget._recomposeAsync;
  }
  static set recomposeAsync(value) {
    Widget._recomposeAsync = value;
    if (value != null) {
      const {
        all
      } = Widget;
      for (let i = 0; i < all.length; ++i) {
        if (all[i].isComposable) {
          all[i].recomposeAsync = value;
        }
      }
    }
  }
  isType(type, deep) {
    return Widget.isType(this, type, deep);
  }
  static setupRenderConfigs(cls, meta) {
    const
      // Once a class declares renderConfigs, those are inherited and augmented:
      classRenderConfigs = meta.getInherited('renderConfigs'),
      {
        renderConfigs
      } = cls;
    if (renderConfigs) {
      // Ex: renderConfigs: ['cls', 'text']
      if (Array.isArray(renderConfigs)) {
        for (const name of renderConfigs) {
          classRenderConfigs[name] = true;
        }
      }
      // Ex: renderConfigs: { cls : true, text : true }
      else {
        ObjectHelper.assign(classRenderConfigs, renderConfigs);
      }
      classRenderConfigs[renderConfigObserver] = null; // hasOwn() == null is "no auto-detect"
    }
    // else a class may declare renderConfigs=null to re-enable auto detection
  }
  /**
   * Call once per class for custom widgets to have them register with the `Widget` class, allowing them to be created
   * by type.
   *
   * For example:
   * ```javascript
   * class MyWidget extends Widget {
   *   static get type() {
   *     return 'mywidget';
   *   }
   * }
   * MyWidget.initClass();
   * ```
   * @method initClass
   * @static
   * @category Lifecycle
   * @advanced
   */
  //endregion
  //region Init & destroy
  construct(config = {}, ...args) {
    const me = this,
      {
        domSyncCallback
      } = me;
    if (!globalThis.bryntum.cssVersion) {
      const cssVersion = globalThis.bryntum.cssVersion = CSSHelper.getCSSVersion(),
        jsVersion = VersionHelper.getVersion('core');
      if (cssVersion && cssVersion !== jsVersion) {
        console.warn(`CSS version ${cssVersion} doesn't match bundle version ${jsVersion}!` + '\nMake sure you have imported css from the appropriate product version.');
      }
    }
    me.configureAriaDescription = config.ariaDescription;
    me._isAnimatingCounter = 0;
    // Flag so we know when our dimensions have been constrained during alignment
    me.alignmentChanges = 0;
    me.byRef = Object.create(null);
    me.onTargetResize = me.onTargetResize.bind(me);
    me.onFullscreenChange = me.onFullscreenChange.bind(me);
    me.domSyncCallback = domSyncCallback.$nullFn ? null : domSyncCallback.bind(me);
    me._isUserAction = false;
    // Base class applies configs.
    super.construct(config, ...args);
    const {
      recomposeAsync
    } = Widget;
    if (recomposeAsync != null && me.recomposeAsync == null) {
      me.recomposeAsync = recomposeAsync;
    }
    me.finalizeInit();
  }
  startConfigure(config) {
    super.startConfigure(config);
    const me = this,
      // This will run the element change/update process if it was not kicked off by a derived class impl of
      // this method:
      {
        adopt,
        element
      } = me;
    if (adopt) {
      // Adopt the preexisting element as our element before configuration proceeds.
      me.adoptElement(element, adopt, config.id);
      me.updateElement(me._element, element);
    }
  }
  /**
   * Called by the Base constructor after all configs have been applied.
   * @internal
   * @category Lifecycle
   */
  finalizeInit() {
    const me = this,
      refElement = me.insertBefore || me.appendTo || me.insertFirst || me.adopt;
    if (refElement) {
      var _ref;
      // If connected to DOM, proceed as normal
      if (me.owner || (_ref = refElement.nodeType ? refElement : document.getElementById(refElement)) !== null && _ref !== void 0 && _ref.isConnected) {
        me.render();
      } else {
        // Not in DOM yet, wait for a resize to happen (triggered by first insertion)
        me.onFirstResizeAfterConnect = me.onFirstResizeAfterConnect.bind(me);
        ResizeMonitor.addResizeListener(refElement, me.onFirstResizeAfterConnect);
      }
    }
  }
  onFirstResizeAfterConnect(el) {
    ResizeMonitor.removeResizeListener(el, this.onFirstResizeAfterConnect);
    if (!this.isDestroyed && !this.rendered) {
      this.render();
    }
  }
  doDestroy() {
    var _me$connectedObserver;
    const me = this,
      {
        preExistingElements,
        element,
        adopt,
        _refListeners,
        _rootElement
      } = me;
    if (Fullscreen.element === element) {
      Fullscreen.exit();
    }
    if (_refListeners) {
      Object.values(_refListeners, un => un());
      me._refListeners = null;
    }
    if (element) {
      var _Widget$Tooltip, _me$dragEventDetacher, _me$dragOverEventDeta;
      const sharedTooltip = !me._tooltip && _rootElement && ((_Widget$Tooltip = Widget.Tooltip) === null || _Widget$Tooltip === void 0 ? void 0 : _Widget$Tooltip.getSharedTooltip(_rootElement, me.eventRoot, true));
      // If we are current user of the shared tooltip, hide it
      if ((sharedTooltip === null || sharedTooltip === void 0 ? void 0 : sharedTooltip.owner) === me) {
        sharedTooltip.owner = null;
        sharedTooltip.hide();
      }
      me.onExitFullscreen();
      // If we get destroyed very quickly after a call to show,
      // we must kill the timers which add the realign listeners.
      me.clearTimeout(me.scrollListenerTimeout);
      me.clearTimeout(me.resizeListenerTimeout);
      // Remove listeners which are only added during the visible phase.
      // In its own method because it's called on hide and destroy.
      me.removeTransientListeners();
      if (me.floating || me.positioned) {
        // Hide without animation, destruction is sync
        me.hide(false);
      } else {
        me.revertFocus();
      }
      ResizeMonitor.removeResizeListener(element.parentElement, me.onParentElementResize);
      ResizeMonitor.removeResizeListener(element, me.onElementResize);
      // Remove elements *which we own* on destroy,
      if (adopt) {
        for (let nodes = Array.from(element.childNodes), i = 0, {
            length
          } = nodes; i < length; i++) {
          const el = nodes[i];
          // If it's not preexisting, and not the floatRoot, remove it
          if (!preExistingElements.includes(el) && el !== me.floatRoot) {
            el.remove();
          }
        }
        element.className = me.adoptedElementClassName;
        element.style.cssText = me.adoptedElementCssText;
      }
      (_me$dragEventDetacher = me.dragEventDetacher) === null || _me$dragEventDetacher === void 0 ? void 0 : _me$dragEventDetacher.call(me);
      (_me$dragOverEventDeta = me.dragOverEventDetacher) === null || _me$dragOverEventDeta === void 0 ? void 0 : _me$dragOverEventDeta.call(me);
      me.dragGhost.remove();
    }
    (_me$connectedObserver = me.connectedObserver) === null || _me$connectedObserver === void 0 ? void 0 : _me$connectedObserver.disconnect();
    super.doDestroy();
    // Only remove our element after full destruction is done
    if (!adopt) {
      element.remove();
    }
  }
  //endregion
  //region Values
  get assignValueDefaults() {
    return assignValueDefaults;
  }
  get valueName() {
    return this.name || this.ref || this.id;
  }
  getValueName(onlyName) {
    onlyName = onlyName && typeof onlyName === 'object' ? onlyName.onlyName : onlyName;
    return onlyName ? this.name : this.valueName;
  }
  assignFieldValue(values, key, value) {
    const me = this,
      valueBindProperty = me.defaultBindProperty;
    if (valueBindProperty in me) {
      me[valueBindProperty] = value;
    }
  }
  assignValue(values, options = assignValueDefaults) {
    const me = this,
      hec = me[highlightExternalChange],
      key = me.getValueName(options);
    if (key && (!values || key in values)) {
      if (options.highlight === false) {
        // Don't want a field highlight on mass change
        me[highlightExternalChange] = false;
      }
      // Setting to null when value not matched clears field
      me.assignFieldValue(values, key, values ? values[key] : null);
      me[highlightExternalChange] = hec;
    }
  }
  gatherValue(values) {
    const me = this,
      valueBindProperty = me.defaultBindProperty;
    if (me.constructor !== Widget && valueBindProperty in me) {
      values[me.name || me.ref || me.id] = me[valueBindProperty];
    }
  }
  gatherValues(values) {
    this.eachWidget(widget => widget.gatherValue(values), false);
  }
  //endregion
  get forwardTwinEvents() {
    const value = this._forwardTwinEvents;
    return value && ObjectHelper.getTruthyKeys(value);
  }
  /**
   * This widget's twin that is placed in an overflow menu when this widget has been hidden by its owner, typically
   * a {@link Core.widget.Toolbar} due to {@link Core.widget.Toolbar#config-overflow}. The `overflowTwin` is created
   * lazily by {@link #function-ensureOverflowTwin}.
   *
   * @member {Core.widget.Widget} overflowTwin
   * @readonly
   * @internal
   */
  /**
   * This method returns the config object to use for creating this widget's {@link #property-overflowTwin}.
   *
   * @param {Function|Object} [overrides] If an object is passed, it is a set of config properties to override the
   * config object returned by {@link #function-configureOverflowTwin}. If a function is passed, it is called with
   * the config object. The function may either alter the object it is given or return a replacement.
   * @returns {Object} The `overflowTwin` config object
   * @internal
   */
  configureOverflowTwin(overrides) {
    var _me$forwardTwinEvents;
    const me = this;
    let config = ObjectHelper.clone(me.initialConfig);
    // Must not duplicate IDs
    delete config.id;
    // If the initialConfig was hidden, we must override that
    config.hidden = false;
    config.type = me.type;
    config._overflowTwinOrigin = me;
    // These properties are things that may be changed frequently from the initialConfig state.
    config.disabled = me.disabled;
    if ('value' in me) {
      config.value = me.value;
    }
    // Ensure we don't have any onFoo for a forwarded 'foo' event:
    (_me$forwardTwinEvents = me.forwardTwinEvents) === null || _me$forwardTwinEvents === void 0 ? void 0 : _me$forwardTwinEvents.forEach(ev => {
      delete config[`on${StringHelper.capitalize(ev)}`];
    });
    if (overrides) {
      config = typeof overrides === 'function' ? overrides(config) || config : ObjectHelper.assign(config, overrides);
    }
    return config;
  }
  /**
   * This method creates the {@link #property-overflowTwin} for this widget. It is called by
   * {@link #function-ensureOverflowTwin} if the `overflowTwin` does not yet exist.
   *
   * The config for the {@link #property-overflowTwin} is produced by {@link #function-configureOverflowTwin}.
   *
   * @param {Function|Object} [overrides] If an object is passed, it is a set of config properties to override the
   * config object returned by {@link #function-configureOverflowTwin}. If a function is passed, it is called with
   * the config object. The function may either alter the object it is given or return a replacement.
   * @returns {Core.widget.Widget} The `overflowTwin`
   * @internal
   */
  createOverflowTwin(overrides) {
    var _me$forwardTwinEvents2;
    const me = this,
      config = me.configureOverflowTwin(overrides),
      overflowTwin = Widget.create(config);
    (_me$forwardTwinEvents2 = me.forwardTwinEvents) === null || _me$forwardTwinEvents2 === void 0 ? void 0 : _me$forwardTwinEvents2.forEach(ev => {
      overflowTwin.ion({
        [ev]: info => {
          // Only forward events if the twin is still connected to its owner
          if (me.overflowTwin === info.source) {
            info = ObjectHelper.assign({}, info);
            // The twin is not the source:
            delete info.source;
            me.trigger(info.eventName, info);
          }
        }
      });
    });
    return overflowTwin;
  }
  /**
   * This method returns the existing {@link #property-overflowTwin} or creates it, if it has not yet been created
   * (see {@link #function-createOverflowTwin}).
   *
   * @param {Function|Object} [overrides] If an object is passed, it is a set of config properties to override the
   * config object returned by {@link #function-configureOverflowTwin}. If a function is passed, it is called with
   * the config object. The function may either alter the object it is given or return a replacement.
   * @param {Function} [onCreate] A function to call when the `overflowTwin` is initially created.
   * @returns {Core.widget.Widget} The `overflowTwin`
   * @internal
   */
  ensureOverflowTwin(overrides, onCreate) {
    let {
      overflowTwin
    } = this;
    if (!overflowTwin) {
      this.overflowTwin = overflowTwin = this.createOverflowTwin(overrides);
      onCreate === null || onCreate === void 0 ? void 0 : onCreate(overflowTwin);
    }
    return overflowTwin;
  }
  //---------------------------------------------------------------------------------------------------------
  //region Render
  /**
   * Returns `true` if this class uses `compose()` to render itself.
   * @returns {Boolean}
   * @internal
   */
  get isComposable() {
    return !this.compose.$nullFn;
  }
  adoptElement(element, adopt, id) {
    const me = this,
      adoptElement = typeof adopt === 'string' ? document.getElementById(adopt) : adopt,
      previousHolder = Widget.fromElement(adoptElement);
    // If we are taking it over from a previous iteration, destroy the previous holder. This is not officially
    // supported, but CodeEditor relies on it working
    if (previousHolder && previousHolder.adopt && previousHolder !== me) {
      const previousHolderAdopt = typeof previousHolder.adopt === 'string' ? document.getElementById(previousHolder.adopt) : previousHolder.adopt;
      if (previousHolderAdopt === adoptElement) {
        previousHolder.destroy();
      }
    }
    // On destroy, leave these
    me.preExistingElements = Array.from(adoptElement.childNodes);
    me.adoptedElementClassName = adoptElement.className;
    me.adoptedElementCssText = adoptElement.style.cssText;
    // Adopt the host element's id if we don't have one so that we do not override
    // it and invalidate any ad-based CSS rules.
    if (adoptElement.id && !id) {
      me.id = element.id = adoptElement.id;
    }
    DomHelper.syncAttributes(element, adoptElement);
    for (let i = 0, {
        length
      } = element.childNodes; i < length; i++) {
      adoptElement.appendChild(element.childNodes[0]);
    }
    delete me._contentRange;
    // Silently update our element config (do not re-run change/update cycle):
    me._element = adoptElement;
    const domConfig = element.lastDomConfig,
      listeners = domConfig === null || domConfig === void 0 ? void 0 : domConfig.listeners;
    if (listeners && me.isComposable) {
      var _listeners$un;
      (_listeners$un = listeners.un) === null || _listeners$un === void 0 ? void 0 : _listeners$un.call(listeners);
      addElementListeners(me, adoptElement, domConfig);
    }
    // Maintain DomSync internal state from our original element:
    adoptElement.lastDomConfig = domConfig || adoptElement.lastDomConfig;
    adoptElement.$refOwnerId = me.id;
    if (!me.scaleToFitWidth) {
      me.getConfig('monitorResize');
    }
  }
  /**
   * Defines an element reference accessor on the class prototype. This accessor is used to flush any pending DOM
   * changes prior to accessing such elements.
   * @param {String} name
   * @param {String} key
   * @private
   */
  addRefAccessor(name, key) {
    const {
      prototype
    } = this.constructor;
    defineProperty(prototype, key, {
      writable: true,
      value: null
    });
    defineProperty(prototype, name, {
      get() {
        // Asking for a ref el is a good sign that we need to sync the DOM:
        this.recompose.flush();
        return this[key];
      },
      set(el) {
        this[key] = el;
      }
    });
  }
  /**
   * This method is called by `DomHelper.createElement` and `DomSync.sync` as new reference elements are created.
   * @param {String} name The name of the element, i.e., the value of its `reference` attribute.
   * @param {HTMLElement} el The element instance
   * @param {DomConfig} [domConfig] The DOM config object.
   * @internal
   */
  attachRef(name, el, domConfig) {
    const me = this,
      key = '_' + name;
    // Key elements contain owner pointer if data is supported (Not on IE SVG).
    el.dataset && (el.dataset.ownerCmp = me.id);
    if (me.isComposable) {
      if (!(key in me)) {
        me.addRefAccessor(name, key);
      }
      addElementListeners(me, el, domConfig, name);
    }
    me.byRef[name] = el;
    me[name] = el;
  }
  /**
   * This method is called by `DomSync.sync` as reference elements are removed from the DOM.
   * @param {String} name The name of the element, i.e., the value of its `reference` attribute.
   * @param {HTMLElement} el The element instance
   * @param {DomConfig} domConfig The DOM config object.
   * @internal
   */
  detachRef(name, el, domConfig) {
    const me = this,
      listeners = me._refListeners;
    if (listeners !== null && listeners !== void 0 && listeners[name]) {
      listeners[name]();
      delete listeners[name];
    }
    me[name] = null;
    delete me.byRef[name];
  }
  /**
   * This method is called following an update to the widget's rendered DOM.
   * @internal
   */
  afterRecompose() {
    // empty
  }
  /**
   * Returns a {@link Core.helper.DomHelper#function-createElement-static} config object that defines this widget's
   * DOM structure. This object should be determined using {@link Core.Base#property-configurable-static} properties
   * to ensure this method is called again if these properties are modified.
   *
   * For more information see {@link Core.widget.Widget class documentation}.
   * @returns {DomConfig}
   * @advanced
   */
  compose() {
    return {
      class: DomClassList.normalize(this.widgetClassList, 'object')
    };
  }
  /**
   * This method iterates the class hierarchy from Widget down to the class of this instance and calls any `compose`
   * methods implemented by derived classes.
   * @returns {Object}
   * @private
   */
  doCompose() {
    const me = this,
      {
        $meta: meta
      } = me,
      classes = meta.hierarchy,
      renderConfigs = meta.renderConfigs || meta.getInherited('renderConfigs');
    let {
        composers
      } = meta,
      domConfig = null,
      c,
      key,
      i,
      proto;
    me.recompose.suspend();
    if (!composers) {
      meta.composers = composers = [];
      // Widget starts the process w/the widgetClassList
      for (i = classes.indexOf(Widget); i < classes.length; ++i) {
        proto = classes[i].prototype;
        if (hasOwn(proto, 'compose')) {
          composers.push(proto);
        }
      }
      // If the class declared renderConfigs, we assign the observer to null (only for that class)
      if (!hasOwn(renderConfigs, renderConfigObserver)) {
        renderConfigs[renderConfigObserver] = {
          get(name) {
            renderConfigs[name] = true;
          }
        };
      }
    }
    me.configObserver = renderConfigs[renderConfigObserver];
    // This loop always runs at least once due to Widget base class, so ret will be assigned here:
    for (i = 0; i < composers.length; ++i) {
      c = composers[i].compose.call(me, domConfig);
      domConfig = domConfig ? DomHelper.merge(domConfig, c) : c;
    }
    if (hasOwn(me, 'compose') && (c = me.compose)) {
      c = c.call(me, domConfig);
      DomHelper.merge(domConfig, c);
    }
    me.configObserver = null;
    // When converting a children:{} into an array, we take a moment to ensure we have an accessor defined for
    // the element. This is needed if the element is initially unrendered since we need the accessor to flush a
    // pending recompose through just in time via the reference element getter.
    return DomHelper.normalizeChildren(domConfig, (childName, hoist) => {
      // Only care about refs that should be hoisted up to us
      if (hoist) {
        key = '_' + childName;
        if (!(key in me)) {
          me.addRefAccessor(childName, key);
        }
      }
    });
  }
  get element() {
    // NOTE: We can replace the getter of a config property
    if (this.isComposable && !this.isDestroying) {
      // Asking for the primary el is a good sign that we need to sync the DOM:
      this.recompose.flush();
    }
    return this._element;
  }
  /**
   * Template method called during DOM updates. See {@link Core.helper.DomSync#function-sync-static DomSync.sync()}.
   * @param {Object} info Properties describing the sync action taken.
   * @internal
   */
  domSyncCallback(info) {
    // bound in construct. Override in subclass
  }
  changeElement(element) {
    const me = this,
      compose = me.isComposable;
    if (compose) {
      element = me.doCompose();
    }
    if (typeof element === 'string') {
      element = DomHelper.createElementFromTemplate(element);
    } else if (ObjectHelper.isObject(element)) {
      element = DomHelper.createElement(element, {
        refOwner: me,
        callback: me.domSyncCallback // mimic DomSync callbacks (needed by TaskBoard)
      });

      me.recompose.resume();
      compose && addElementListeners(me, element, element.lastDomConfig);
    } else if (DomHelper.isReactElement(me.peekConfig('html'))) {
      // Will portal the React element into the element later
      element = document.createElement('div');
    } else if (element.nodeType !== 1) {
      element = DomHelper.createElementFromTemplate(me.template(me));
    }
    element.id = me.id;
    if (me.elementAttributes) {
      DomHelper.setAttributes(element, me.elementAttributes);
    }
    return element;
  }
  updateElement(element) {
    const me = this,
      {
        className
      } = element,
      {
        contentElement,
        contentElementCls,
        isComposable
      } = me,
      hasChildContent = contentElement !== element,
      namedElements = !isComposable && element.querySelectorAll('[data-reference]'),
      // Start with the hierarchy classes, eg ['b-combo b-pickerfield b-textfield b-widget']
      classes = isComposable ? [] : me.widgetClassList; // a dynamic array that we can safely modify
    // The ui classes need to put on the content element even if isComposable, but widgetClassList contains the
    // ui classes, so we don't need to do that if the main element is the contentElement
    let uiClasses = (hasChildContent || !isComposable) && me.uiClasses;
    className && classes.unshift(className);
    me._hidden && classes.push('b-hidden');
    me._readOnly && classes.push('b-readonly');
    // Calling element.remove() when we have the focus can result in a DOMException (notably when a blur/focusout
    // handler reentrancy results in a remove):
    //  DOMException: Failed to execute 'remove' on 'Element': The node to be removed is no longer a child
    //  of this node. Perhaps it was moved in a 'blur' event handler?
    FunctionHelper.noThrow(element, 'remove' /*, () => { debugger; } /**/); // delete "/*" to break on exception
    if (uiClasses) {
      if (contentElementCls !== null && contentElementCls !== void 0 && contentElementCls.value) {
        uiClasses = uiClasses.slice(); // clone cached array
        uiClasses.push(contentElementCls.value);
      }
      uiClasses = uiClasses.join(' ');
    } else {
      uiClasses = contentElementCls === null || contentElementCls === void 0 ? void 0 : contentElementCls.value;
    }
    if (uiClasses) {
      if (hasChildContent) {
        contentElement.className += ' ' + uiClasses;
      } else {
        classes.push(uiClasses);
      }
    }
    // The environmental classes only need to be added to outermost Widgets.
    // If we have a parent container, that will have them.
    if (!me.parent) {
      const {
          defaultCls
        } = me,
        {
          outerCls
        } = Widget;
      classes.push(...(defaultCls ? outerCls.filter(c => !(c in defaultCls) || defaultCls[c]) : outerCls));
    }
    element.className = classes.join(' ');
    if (namedElements) {
      for (let el, i = 0; i < namedElements.length; ++i) {
        el = namedElements[i];
        me.attachRef(el.getAttribute('data-reference'), el);
        el.removeAttribute('data-reference');
      }
    }
    // Mutually exclusive with scaleToFitWidth.
    // Observe container element before the cascade down to descendants.
    // Outer elements are expected to fire resize first.
    // It's a lazy config, so this is the time to flush it through to begin monitoring.
    if (!me.adopt && !me.scaleToFitWidth) {
      me.getConfig('monitorResize');
    }
    // Pull in lazy configs now we have the element.
    me.getConfig('role');
    me.getConfig('ariaLabel');
    me.getConfig('ariaDescription');
    // Ensure our content mutation observer keeps us informed of changes by third parties
    // so that our config system can keep up to date.
    if (me._html) {
      me.getConfig('htmlMutationObserver');
    }
    /**
     * Triggered when a widget's {@link #property-element} is available.
     * @event elementCreated
     * @param {HTMLElement} element The Widget's element.
     * @internal
     */
    me.trigger('elementCreated', {
      element
    });
  }
  updateAriaDescription(ariaDescription) {
    const {
        ariaElement
      } = this,
      descElId = `${this.id}-aria-desc-el`;
    if (ariaDescription) {
      const ariaDescEl = this._ariaDescEl || (this._ariaDescEl = DomHelper.createElement({
        className: 'b-aria-desc-element',
        id: descElId,
        parent: ariaElement
      }));
      ariaDescEl.innerText = ariaDescription.match(localizeRE) ? this.L(ariaDescription, this) : ariaDescription;
      ariaElement.setAttribute('aria-describedBy', ariaDescEl.id);
    } else if (ariaElement.getAttribute('aria-describedby') === descElId) {
      ariaElement.removeAttribute('aria-describedBy');
    }
  }
  updateAriaLabel(ariaLabel) {
    DomHelper.setAttributes(this.ariaElement, {
      'aria-label': ariaLabel !== null && ariaLabel !== void 0 && ariaLabel.match(localizeRE) ? this.L(ariaLabel, this) : ariaLabel
    });
  }
  updateAriaHasPopup(ariaHasPopup) {
    DomHelper.setAttributes(this.ariaElement, {
      'aria-haspopup': ariaHasPopup
    });
  }
  updateRole(role) {
    if (role) {
      var _this$ariaElement;
      (_this$ariaElement = this.ariaElement) === null || _this$ariaElement === void 0 ? void 0 : _this$ariaElement.setAttribute('role', role);
    } else {
      var _this$ariaElement2;
      (_this$ariaElement2 = this.ariaElement) === null || _this$ariaElement2 === void 0 ? void 0 : _this$ariaElement2.removeAttribute('role');
    }
  }
  get ariaElement() {
    // Ensure element has been created.
    this.getConfig('element');
    const {
      _ariaElement
    } = this;
    // Note that we use ObjectHelper.getPath enabling expressions containing dots.
    // So that widget classes may use `ownedWidget.input` to reference elements inside owned widgets.
    return _ariaElement.nodeType === Node.ELEMENT_NODE ? _ariaElement : ObjectHelper.getPath(this, _ariaElement);
  }
  /**
   * This method determines if this widget (typically a {@link Core.widget.Tool}) should be placed in the header of
   * the calling {@link Core.widget.Panel}.
   * @param {Object} options An object specifying various options.
   * @param {Boolean} options.collapsed True if the panel is in a {@link Core.widget.Panel#config-collapsed} state.
   * @param {Boolean} options.alt True if the panel is rendering its alternate panel header, false for the primary header.
   * @returns {Boolean}
   * @internal
   */
  isCollapsified({
    collapsed,
    alt
  }) {
    const {
        collapsify
      } = this,
      // Possible values:
      //   null: The widget will be moved to the overlay header when the panel is collapsed (the default).
      //   false: The widget will be unaffected when the panel is collapsed and will remain in the primary header.
      //   'hide': The widget will be hidden when the panel is collapsed (remains in primary header).
      //   'overlay': The widget will only appear in the collapsed panel's overlay header.
      // Only one of these will be true:
      hideIfCollapsed = collapsify === 'hide',
      alwaysPrimary = collapsify === false,
      altIfCollapsedElsePrimary = collapsify == null,
      alwaysAlt = collapsify === 'overlay';
    // Both overlay mode and inline mode (when the collapse direction is transverse) create a secondary panel
    // header. In overlay mode, the header is used when the collapsed panel header is clicked to reveal the panel
    // content in an overlay. In transverse-collapse inline mode, the panel uses an alternate header during the
    // expand/collapse animations to maintain the layout of the panel's content. In both cases the primary panel
    // header remains visible when the panel is collapsed.
    return alt ? alwaysAlt || altIfCollapsedElsePrimary && collapsed : alwaysPrimary || hideIfCollapsed || altIfCollapsedElsePrimary && !collapsed;
  }
  /**
   * Calling this {@link Core.mixin.Delayable#property-delayable-static} method marks this widget as dirty. The DOM
   * will be updated on the next animation frame:
   *
   * ```javascript
   *  widget.recompose();
   *
   *  console.log(widget.recompose.isPending);
   *  > true
   * ```
   *
   * A pending update can be flushed by calling `flush()` (this does nothing if no update is pending):
   *
   * ```javascript
   *  widget.recompose.flush();
   * ```
   *
   * This can be combined in one call to force a DOM update without first scheduling one:
   *
   * ```javascript
   *  widget.recompose.now();
   * ```
   * @advanced
   */
  async recompose() {
    const me = this,
      options = {
        targetElement: me.element,
        domConfig: me.doCompose(),
        refOwner: me,
        callback: me.domSyncCallback,
        // This limits the sync() to only removing the classes and styles added by previous renderings. This
        // allows dynamically added styles and classes to be preserved:
        strict: true
      };
    if (me.transitionRecompose) {
      me.isTransitioningDom = true;
      await DomHelper.transition(ObjectHelper.assign({
        element: me.element,
        action() {
          DomSync.sync(options);
        }
      }, me.transitionRecompose));
      if (me.isDestroyed) {
        return;
      }
      me.isTransitioningDom = false;
      me.trigger('transitionedRecompose');
    } else {
      DomSync.sync(options);
    }
    if (options.changed) {
      me.afterRecompose();
      /**
       * This event is fired after a widget's elements have been synchronized due to a direct or indirect call
       * to {@link #function-recompose}, if this results in some change to the widget's rendered DOM elements.
       *
       * @event recompose
       * @advanced
       */
      me.trigger('recompose');
    }
    me.resumeRecompose();
  }
  // To allow hooking into resuming recompose, used by TaskBoard
  resumeRecompose() {
    this.recompose.resume();
  }
  changeElementRef(el) {
    if (typeof el === 'string') {
      const id = el;
      if (!(el = document.getElementById(id))) {
        throw new Error(`No element found with id '${id}'`);
      }
    }
    return el;
  }
  changeAppendTo(appendTo) {
    return this.changeElementRef(appendTo);
  }
  updateAppendTo(appendTo) {
    if (!this.isConfiguring && appendTo) {
      this.render();
    }
  }
  changeInsertBefore(insertBefore) {
    return this.changeElementRef(insertBefore);
  }
  updateInsertBefore(insertBefore) {
    if (!this.isConfiguring && insertBefore) {
      this.render();
    }
  }
  changeInsertFirst(insertFirst) {
    return this.changeElementRef(insertFirst);
  }
  updateInsertFirst(insertFirst) {
    if (!this.isConfiguring && insertFirst) {
      this.render();
    }
  }
  /**
   * Interprets the {@link #config-appendTo}, {@link #config-insertBefore} and {@link #config-insertFirst}
   * configs to return an array containing `[parentElement, insertBefore]`
   * @internal
   * @param {Core.widget.Widget} source The widget for which to ascertain its render context.
   * @returns {HTMLElement[]} The `[parentElement, insertBefore]` elements.
   */
  getRenderContext(config = this, renderTo) {
    let parentElement = renderTo || config.appendTo,
      {
        insertFirst,
        insertBefore
      } = config;
    if (insertFirst) {
      parentElement = insertFirst;
      insertBefore = parentElement.firstChild;
    }
    if (insertBefore) {
      if (!parentElement) {
        parentElement = insertBefore.parentElement;
      }
    }
    // Must use undefined as insertBefore if not configured; DOM insertBefore won't accept null
    return [parentElement, insertBefore || undefined];
  }
  render(renderTo, triggerPaint = true) {
    const me = this,
      {
        element
      } = me,
      [parentElement, insertBefore] = me.getRenderContext(me, renderTo);
    me.emptyCache();
    if (me.syncElement && me.currentElement) {
      DomHelper.sync(element, me.currentElement);
    } else {
      parentElement === null || parentElement === void 0 ? void 0 : parentElement.insertBefore(element, insertBefore);
      me.currentElement = element;
    }
    // The environmental classes only need to be added to a naked Widget.
    // If we are inside a Widget's element, that will have them.
    if (Widget.fromElement(element.parentElement)) {
      element.classList.remove(...Widget.outerCls);
    }
    super.render(parentElement, triggerPaint);
    me.rendered = true;
    // Now that we have our complete DOM, update our role if we have one.
    me.getConfig('role');
    if (triggerPaint) {
      me.getConfig('contentRange');
      me.triggerPaint();
    }
    me.setupFocusListeners();
  }
  /**
   * A function which, when passed an instance of this Widget, produces a valid HTML string which is compiled
   * to create the encapsulating element for this Widget, and its own internal DOM structure.
   *
   * Note that this just creates the DOM structure that *this* Widget owns. If it contains child widgets
   * (Such as for example a grid), this is not included. The template creates own structure.
   *
   * Certain elements within the generated element can be identified as special elements with a `reference="name"`
   * property. These will be extracted from the element upon creation and injected as the named property into
   * the Widget. For example, a {@link Core.widget.TextField} will have an `input` property which is its
   * `<input>` element.
   * @param {Core.widget.Widget} me The widget for which to produce the initial HTML structure.
   * @internal
   */
  template({
    tag,
    html,
    htmlCls,
    name
  }) {
    var _html;
    const me = this;
    // Allow a string callback such as 'up.getHTML' to be used
    if (typeof html === 'string' && callbackRe.test(html) && me.resolveCallback(html, me, false)) {
      html = me.callback(html, me, [me]);
    }
    const content = (_html = html) !== null && _html !== void 0 && _html.call ? html.call(me, me) : html;
    return `<${tag} class="${content ? htmlCls : ''}" ${name ? `data-name="${name}"` : ''}>${content || ''}</${tag}>`;
  }
  updateRecomposeAsync(async) {
    this.recompose.immediate = !async;
  }
  //endregion
  //---------------------------------------------------------------------------------------------------------
  onConfigChange({
    name
  }) {
    var _this$$meta$renderCon;
    // The renderConfigs object is either on our prototype (due to renderConfigs getter) or on our instance (due
    // to "get composer") unless we are not using compose(), in which case it will be null:
    if (this._element && !this.isDestroying && (_this$$meta$renderCon = this.$meta.renderConfigs) !== null && _this$$meta$renderCon !== void 0 && _this$$meta$renderCon[name]) {
      this.recompose();
    }
  }
  //region Extract config
  // These functions are not meant to be called by any code other than Base#getCurrentConfig()
  // Clean up configs
  preProcessCurrentConfigs(configs) {
    super.preProcessCurrentConfigs(configs);
    // Remove link to parent, is set when added
    delete configs.parent;
  }
  // Extract config's current value, special handling for style
  getConfigValue(name, options) {
    // Don't want the full CSSStyleDeclaration object
    if (name === 'style') {
      return this._style;
    }
    return super.getConfigValue(name, options);
  }
  // Extract current value of all initially used configs, special handling for widget type
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options);
    // Always include type, except for on outermost level
    if ((options === null || options === void 0 ? void 0 : options.depth) > 0) {
      result.type = this.type;
    }
    return result;
  }
  //endregion
  /**
   * Get widgets elements dataset or assign to it
   * @property {Object}
   * @category DOM
   */
  get dataset() {
    return this.element.dataset;
  }
  changeDataset(dataset) {
    // Must use ObjectHelper so that properties in the prototype copied
    ObjectHelper.assign(this.dataset, dataset);
  }
  get dragGhost() {
    return this.constructor._dragGhost || (this.constructor._dragGhost = DomHelper.createElement({
      // Safari won't allow dragging an empty node
      html: '\xa0',
      style: 'position:absolute;top:-10000em;left:-10000em'
    }));
  }
  updateParent(parent) {
    const {
      _element: element
    } = this;
    if (element) {
      element.classList[parent ? 'remove' : 'add'](...Widget.outerCls);
    }
  }
  get constrainTo() {
    var _result;
    let result = this._constrainTo;
    result = result === undefined ? globalThis : ((_result = result) === null || _result === void 0 ? void 0 : _result.nodeType) === Node.DOCUMENT_FRAGMENT_NODE ? result.host || result.ownerDocument : result;
    // If we're positioned, any constrainTo must be a Rectangle in our offsetParent's coordinate space
    if (this.positioned) {
      const {
        offsetParent
      } = this.element;
      // We can't be seen outside our offsetParent, so that's the de-facto constrainTo
      // regardless of what is passed.
      if (offsetParent && DomHelper.getStyleValue(offsetParent, 'overflow') === 'hidden') {
        result = Rectangle.from(offsetParent).moveTo(0, 0);
      } else if (result && !result.isRectangle) {
        const isViewport = result === document || result === globalThis;
        result = Rectangle.from(result, offsetParent);
        if (isViewport) {
          result.translate(globalThis.pageXOffset, globalThis.pageYOffset);
        }
      }
    }
    return result;
  }
  updateCentered(value) {
    const {
      element,
      _anchorElement
    } = this;
    if (value && !this.floating && !this.positioned) {
      throw new Error('`centered` is only relevant when a Widget is `floating` or `positioned`');
    }
    if (value) {
      element.classList.add('b-centered');
      element.style.transform = element.style.left = element.style.top = '';
      _anchorElement === null || _anchorElement === void 0 ? void 0 : _anchorElement.classList.add('b-hide-display');
      element.classList.remove('b-anchored');
    } else {
      element.classList.remove('b-centered');
    }
  }
  /**
   * The child element into which content should be placed. This means where {@link #config-html} should be put,
   * or, for {@link Core.widget.Container Container}s, where child items should be rendered.
   * @property {HTMLElement}
   * @readonly
   * @category DOM
   * @advanced
   */
  get contentElement() {
    return this.element;
  }
  get contentRange() {
    const me = this,
      {
        contentElement
      } = me,
      contentRange = me._contentRange || (me._contentRange = new Range());
    // Initialize the contentRange if it's collapsed.
    // It gets collapsed if the widget's element is removed from the DOM.
    if (contentRange.collapsed) {
      contentRange.setStart(contentElement, me.contentRangeStartOffset || 0);
      contentRange.setEnd(contentElement, me.contentRangeEndOffset || contentElement.childNodes.length);
    }
    return contentRange;
  }
  /**
   * This method fixes the element's `$refOwnerId` when this instance's `id` is changing.
   * @param {Node} el The element or DOM node to fix.
   * @param {String} id The new id being assigned.
   * @param {String} oldId The old id (previously assigned).
   * @private
   */
  fixRefOwnerId(el, id, oldId) {
    if (el.$refOwnerId === oldId) {
      el.$refOwnerId = id;
      for /* empty */
      (let {
          childNodes
        } = el, i = childNodes.length; i-- > 0;) {
        this.fixRefOwnerId(childNodes[i], id, oldId);
      }
    }
  }
  get placement() {
    const me = this,
      {
        element
      } = me;
    let adjRect, placement, rect;
    if (element !== null && element !== void 0 && element.offsetParent && !nonFlowedPositions.test(DomHelper.getStyleValue(element, 'position'))) {
      const next = element.nextElementSibling,
        previous = element.previousElementSibling,
        last = !next && previous;
      placement = DomHelper.getStyleValue(element.parentElement, 'flex-direction');
      // If used in a flex layout, determine orientation from flex-direction
      if (placement) {
        placement = placement.startsWith('row') ? 'h' : 'v';
      } else {
        var _ref2;
        adjRect = (_ref2 = next || previous) === null || _ref2 === void 0 ? void 0 : _ref2.getBoundingClientRect();
        rect = adjRect && element.getBoundingClientRect();
        placement = adjRect && Math.abs(adjRect.top - rect.top) < Math.abs(adjRect.left - rect.left) ? 'h' : 'v';
        // if there is another item, check for more horz delta than vert and if so, call it a horz container
      }

      placement += placement === 'h' ? last ? 'r' : 'l' : last ? 'b' : 't';
    }
    return placement;
  }
  updateId(id, oldId) {
    super.updateId(id, oldId);
    if (oldId) {
      // NOTE this happens when we adopt an element w/an assigned id...
      const {
        byRef,
        element
      } = this;
      for (const ref in byRef) {
        byRef[ref].dataset && (byRef[ref].dataset.ownerCmp = id); // SVG elements have no dataset
      }

      element.id = id;
      this.fixRefOwnerId(element, id, oldId);
    }
  }
  /**
   * Get/set widgets elements style. The setter accepts a cssText string or a style config object, the getter always
   * returns a CSSStyleDeclaration
   * @property {CSSStyleDeclaration}
   * @accepts {String|Object|CSSStyleDeclaration}
   * @category DOM
   */
  get style() {
    const {
      element
    } = this;
    return (element === null || element === void 0 ? void 0 : element.ownerDocument.defaultView.getComputedStyle(element)) || this._style;
  }
  updateStyle(style) {
    this.element && DomHelper.applyStyle(this.element, style);
  }
  updateTitle(title) {
    if (this.titleElement) {
      this.titleElement.innerHTML = title;
    }
  }
  //region floating
  // Hook used by Tooltip to handle RTL
  beforeAlignTo(spec) {}
  /**
   * If this Widget is {@link #config-floating} or {@link #config-positioned}, and visible, aligns the widget
   * according to the passed specification. To stop aligning, call this method without arguments.
   * @param {AlignSpec|HTMLElement} [spec] Alignment options. May be an alignment specification object, or an
   * `HTMLElement` to align to using this Widget's {@link #config-align} configuration.
   * @category Float & align
   */
  alignTo(spec) {
    var _targetEvent$target, _anchor;
    const me = this,
      {
        lastAlignSpec,
        element
      } = me,
      {
        offsetParent,
        style,
        classList
      } = element;
    if (lastAlignSpec) {
      // Remove intersection observation from our previous align target element.
      lastAlignSpec.monitorIntersection && me.intersectionObserver.unobserve(lastAlignSpec.target);
      // Ensure marker class of previous alignment side is removed.
      if (isFinite(lastAlignSpec.zone)) {
        element.classList.remove(alignedClass[lastAlignSpec.zone]);
      }
    }
    // Change the widget state to non-aligned if called with no align spec.
    if (!spec) {
      me.removeTransientListeners();
      me.anchor = me.lastAlignSpec = null;
      return;
    }
    // Hook used by Tooltip to handle RTL
    me.beforeAlignTo(spec);
    // You can "alignTo" an element or a Widget or a Point, and allow our align config.
    // property to specify how.
    if (spec.nodeType === Element.ELEMENT_NODE || spec.isWidget || spec.$$name === 'Point') {
      spec = {
        target: spec
      };
    }
    // Release size constraints so we can align from scratch each time.
    me.releaseSizeConstraints();
    const {
        scrollable,
        constrainTo
      } = me,
      elMinHeight = DomHelper.measureSize(DomHelper.getStyleValue(element, 'minHeight'), element),
      elMinWidth = DomHelper.measureSize(DomHelper.getStyleValue(element, 'minWidth'), element),
      positioned = me.positioned && DomHelper.getStyleValue(element, 'position') !== 'fixed',
      scale = me.scale || 1,
      passedTarget = spec.target,
      targetEvent = spec.domEvent || spec.event || passedTarget,
      target = passedTarget !== null && passedTarget !== void 0 && passedTarget.isRectangle ? passedTarget : (passedTarget === null || passedTarget === void 0 ? void 0 : passedTarget.element) || passedTarget,
      myPosition = Rectangle.from(element, positioned ? offsetParent : null, true),
      {
        width: startWidth,
        height: startHeight
      } = myPosition,
      aligningToElement = (target === null || target === void 0 ? void 0 : target.nodeType) === Element.ELEMENT_NODE,
      aligningToEvent = (targetEvent === null || targetEvent === void 0 ? void 0 : (_targetEvent$target = targetEvent.target) === null || _targetEvent$target === void 0 ? void 0 : _targetEvent$target.nodeType) === Element.ELEMENT_NODE;
    spec = spec.realignTarget ? spec : ObjectHelper.assign({
      aligningToEvent,
      aligningToElement,
      constrainTo,
      align: 'b-t',
      // we can end up w/o a value for this if an object replaces a string
      axisLock: me.axisLock,
      anchor: me.anchor
    }, me.align, spec);
    // As part of fallback process when fitting within constraints, this may shrink to minima specified
    // either on the align spec or the widget itself.
    const minWidth = spec.minWidth || elMinWidth,
      minHeight = spec.minHeight || elMinHeight;
    // Minima have a different meaning in an alignRectangle.
    // It means that the rectangle is willing to shrink down
    // to that size during constraint, *not* that it can never
    // be smaller than that size.
    myPosition.isAlignRectangle = true;
    minWidth && (myPosition.minWidth = minWidth * scale);
    minHeight && (myPosition.minHeight = minHeight * scale);
    // This is used by the realign call which may be called either when a global scroll is detected
    // or the constraining element is resized.
    me.lastAlignSpec = spec;
    // If we are aligning to an event, wipe out the target property in case caller had
    // passed that as the event. target implies it's an element.
    // Inject the element that we are anchored to - the event's element
    if (aligningToEvent) {
      delete spec.target;
      spec.domEvent = targetEvent;
      spec.anchoredTo = targetEvent.target;
      // Widget must not show below the pointer because user will not expect
      // mouseover effects, so offset the X position by 1 pixel.
      spec.position = new Point(targetEvent.clientX + 1, targetEvent.clientY + 1);
    } else if (aligningToElement) {
      // Cache element, not the widget
      spec.target = target;
      // If we're aligning to an alement which has layout
      if (hasLayout(target instanceof SVGElement ? target.closest('svg') : target)) {
        // Don't destroy the spec which was cached above with the element in it.
        spec = Object.setPrototypeOf({}, spec);
        // If we are being called from realign, there will be a realignTarget present which is
        // a viewport-based *visible* rectangle. Otherwise translate the element into a browser
        // viewport based Rectangle. Rectangle doesn't have the knowledge that we do to make this
        // decision. Floating alignment all takes place within browser viewport space, not document
        // space.
        spec.target = me.lastAlignSpec.targetRect = spec.realignTarget || (spec.allowTargetOut ? Rectangle.from(target, positioned ? offsetParent : null, !positioned) : DomHelper.isInView(target, false, me));
        // This is the case where the target is scrolled or positioned out of view.
        if (!spec.target) {
          const result = me.hide();
          // The hide method clears this flag.
          // Only this hide invocation must complete with the
          // targetOutOfView flag as true
          // Hiding *might* destroy if autoClose is set.
          if (!me.isDestroyed) {
            me.lastAlignSpec.targetOutOfView = true;
          }
          return result;
        }
        // Force the target to have an area so that intersect works.
        spec.target.height = Math.max(spec.target.height, 1);
        spec.target.width = Math.max(spec.target.width, 1);
        // This is the element which determines our position.
        // This is used in doHideOrRealign to see if a scroll event
        // will have affected our position.
        me.lastAlignSpec.anchoredTo = target;
      }
    }
    if (spec.anchor) {
      spec.anchorSize = me.anchorSize;
      if (!element.contains(me.anchorPathElement)) {
        element.appendChild(me.anchorElement);
      }
    }
    // Flag to prevent infinite loop when setting html from a beforeAlign listener
    me.isAligning = true;
    // Allow outside world to modify the suggested position
    me.trigger('beforeAlign', spec);
    me.isAligning = false;
    // This changes the 0% - 100% orientation along horizontal edges
    spec.rtl = me.rtl;
    // Handle direction neutral edges (s & e, asserted in PopupRTL.t.js)
    if (spec.align.includes('s') || spec.align.includes('e')) {
      if (me.rtl) {
        spec.align = spec.align.replace(/s/g, 'r').replace(/e/g, 'l');
      } else {
        spec.align = spec.align.replace(/s/g, 'l').replace(/e/g, 'r');
      }
    }
    // Calculate the best position WRT target rectangle, our rectangle, a constrainTo rectangle
    // and the rectangle of an anchor pointer.
    const result = me.lastAlignSpec.result = myPosition.alignTo(spec);
    // May change if constraint changes our shape, and we have to go round again
    let {
      align,
      anchor,
      x,
      y,
      width,
      height,
      overlap
    } = result;
    // Which zone, T=0, R=1, B=2, L=3 the result is in
    me.lastAlignSpec.zone = result.zone;
    // If the alignment specified that we must change a dimension, then obey that.
    // This may be either decreasing it to the constrainTo option, or changing it
    // as requested by the matchSize option (as used by Combo to make its List the same width)
    // If we own a Scroller, then inform it that we do now need to scroll that dimension.
    // These conditions are released upon each alignment call because conditions may change.
    // 0001 = Height has been reduced from original
    // 0010 = Height has been increased from original
    // 0100 = Width has been reduced from original
    // 1000 = Width has been increased from original
    if (height != startHeight) {
      const shrunk = height < startHeight;
      me.alignmentChanges = me.alignmentChanges | (shrunk ? 1 : 2);
      style[me.alignedHeightStyle = alignChangeDims[me.alignmentChanges & 0b0011]] = `${height / scale}px`;
      // If the element acquired its height only from a minHeight style, override it to
      // conform to the shrink, because minHeight wins over maxHeight
      if (shrunk && !me._minHeight && elMinHeight) {
        style.minHeight = `${Math.min(height, elMinHeight) / scale}px`;
      }
      if (scrollable) {
        scrollable.overflowY = shrunk;
      }
    }
    if (width != startWidth) {
      const shrunk = width < startWidth;
      me.alignmentChanges = me.alignmentChanges | (shrunk ? 4 : 8);
      style[me.alignedWidthStyle = alignChangeDims[me.alignmentChanges & 0b1100]] = `${width / scale}px`;
      // If the element acquired its width only from a minWidth style, override it to
      // conform to the shrink, because minWidth wins over maxWidth
      if (shrunk && !me._minWidth && elMinWidth) {
        style.minWidth = `${Math.min(width, elMinWidth) / scale}px`;
      }
      if (scrollable) {
        scrollable.overflowX = shrunk;
      }
    }
    // If either dimension has been adjusted by alignment, we may have changed shape
    // due to text wrapping/overflowing, so we have to realign at the
    // successful align setting.
    if (align && me.alignmentChanges) {
      const newRect = Rectangle.from(element, positioned ? offsetParent : null, true);
      // The new Rectangle must use the minWidth and minHeight that we are using
      newRect.minWidth = result.minWidth;
      newRect.minHeight = result.minHeight;
      spec.align = align;
      const newResult = me.lastAlignSpec.result = newRect.alignTo(spec);
      anchor = newResult.anchor;
      x = newResult.x;
      y = newResult.y;
      width = newResult.width;
      height = newResult.height;
    }
    // Aligning while centered just processes the constrainTo, and adds the transient listeers
    if (!me.centered) {
      me.setXY(x, y);
    }
    // Class indicates which edge of the target this is aligned to: 0, 1, 2, or 3 (TRBL)
    if (!result.overlap && isFinite(result.zone)) {
      classList.add(alignedClass[result.zone]);
    }
    // If we asked it to also calculate our anchor position, position our anchor.
    // If we're not edge-to-edge aligned with our target, we cannot anchor.
    if ((_anchor = anchor) !== null && _anchor !== void 0 && _anchor.edge) {
      var _colourSource;
      const {
          edge
        } = anchor,
        {
          anchorElement
        } = me,
        {
          style: anchorStyle
        } = anchorElement,
        elRect = Rectangle.from(element),
        colorMatchPoint = [];
      // Make the anchor color match the color of the closest adjacent element
      if (edge === 'top' || edge === 'bottom') {
        colorMatchPoint[0] = anchor.x;
        colorMatchPoint[1] = edge === 'top' ? 1 : elRect.height - 1;
      } else {
        // No RTL handling needed here as long as `s` and `e` alignment is used
        colorMatchPoint[0] = edge === 'left' ? 1 : elRect.width - 1;
        colorMatchPoint[1] = anchor.y;
      }
      // Must not be "seen" by childFromPoint
      anchorStyle.display = 'none';
      let colourSource = DomHelper.childFromPoint(element, ...colorMatchPoint);
      // Jump up past inner elements which have hover or focus because that may cause us to read
      // a transient background-color.
      if ((_colourSource = colourSource) !== null && _colourSource !== void 0 && _colourSource.matches(':hover,:focus') && element.compareDocumentPosition(colourSource) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
        colourSource = colourSource.parentNode;
      }
      // 2nd check is relevant when stylesheet fails to load
      if (colourSource && colourSource !== document) {
        let fillColour = DomHelper.getStyleValue(colourSource, 'background-color');
        while (fillColour.match(isTransparent) && DomHelper.getStyleValue(colourSource, 'position') !== 'absolute') {
          colourSource = colourSource.parentNode;
          // Ensure stylesheet is loaded
          if (colourSource === document) {
            break;
          }
          fillColour = DomHelper.getStyleValue(colourSource, 'background-color');
        }
        if (fillColour.match(isTransparent)) {
          me.anchorPathElement.setAttribute('fill', me.defaultAnchorBackgroundColor);
        } else {
          me.anchorPathElement.setAttribute('fill', fillColour);
        }
      }
      anchorStyle.transform = anchorStyle.display = '';
      anchorElement.className = `b-anchor b-anchor-${edge}`;
      // Anchor's position needs boosting if we are scaled down
      anchor.x && (anchor.x /= scale);
      anchor.y && (anchor.y /= scale);
      DomHelper.setTranslateXY(anchorElement, anchor.x, anchor.y);
      classList.add('b-anchored');
    } else if (me._anchorElement) {
      me.anchorElement.classList.add('b-hide-display');
      classList.remove('b-anchored');
    }
    // If we are to hide on scroll, we still need to know if the element we are
    // aligned to moves. If we have not been *explicitly* aligned to an element,
    // Use the element at our display position. For example, when a context menu
    // is shown on a grid header, then is the grid header is moved by a scroll
    // event, then we must hide.
    if (!aligningToElement) {
      // Our element is over the X, Y point now,
      // elementFromPoint must "see through" it.
      style.pointerEvents = 'none';
      const el = DomHelper.elementFromPoint(x, y);
      // If we own the element at the point, it means we are already visible
      // and have visible descendants, so we must not update the anchoredTo
      if (!me.owns(el)) {
        me.lastAlignSpec.anchoredTo = el;
      }
      style.pointerEvents = '';
    }
    // If we're aligning to an element, then listen for scrolls so that we can remain aligned.
    // Scrolls can be instigated with no mousedown, so transient floating Widgets can be put
    // out of alignment by scrolls.
    if ((me.scrollAction === 'realign' && aligningToElement || me.scrollAction === 'hide') && !me.documentScrollListener) {
      // Firefox requires a longer timeout to not autohide as the result of a scroll event firing during Menu show
      me.clearTimeout(me.scrollListenerTimeout);
      // If the align spec demands, request to be notified if the target element
      // we're aligning to exits the document or an element which contains it gets
      // mutated - for example realigned - so that we can follow it.
      if (spec.monitorTargetMutation && !me.targetObserver) {
        const targetObserver = me.targetObserver || (me.targetObserver = new MutationObserver(me.onTargetParentMutation.bind(me)));
        targetObserver.observe(DomHelper.getRootElement(target), {
          childList: true,
          attributes: true,
          subtree: true
        });
      }
      me.scrollListenerTimeout = me.setTimeout(() => {
        var _getRootNode, _ref3;
        const targetRoot = (_getRootNode = (_ref3 = aligningToElement ? target : me.lastAlignSpec.anchoredTo).getRootNode) === null || _getRootNode === void 0 ? void 0 : _getRootNode.call(_ref3);
        // Realign if the main document detects a scroll.
        // On raf to avoid scroll syncing other elements causing multiple realigns (grids body and header etc)
        me.documentScrollListener = EventHelper.addListener(document, 'scroll', 'doHideOrRealign', {
          capture: true,
          thisObj: me
        });
        // In case the align target is in a WC, also capture scrolls scoped with in its shadow root
        if (targetRoot !== null && targetRoot !== void 0 && targetRoot.mode) {
          me.targetRootScrollListener = EventHelper.addListener(targetRoot, 'scroll', 'doHideOrRealign', {
            capture: true,
            thisObj: me
          });
        }
      }, me.scrollAction === 'hide' ? me.ignoreScrollDuration : 0);
    }
    // If alignment specified monitorResize add a resize listener to the target so we can stay aligned.
    if (aligningToElement) {
      if (spec.monitorResize && !me.targetResizeListener) {
        ResizeMonitor.addResizeListener(target, me.onTargetResize);
        me.targetResizeListener = true;
      }
      // If configured to monitor intersection, and we are not potentially obscuring
      // it ourselves, and it's not an SVG element, observe its intersection changes.
      // Bug with IntersectionObserver and SVG elements, so omit them:
      // https://bugs.chromium.org/p/chromium/issues/detail?id=1159196
      if (spec.monitorIntersection && !(overlap || target.contains(element) || target.ownerSVGElement)) {
        me.intersectionObserver.observe(target);
      }
    }
    // Don't try to listen for window resizes to try realigning on Android.
    // That just means the keyboard has been shown.
    if (!BrowserHelper.isAndroid) {
      if (!me.constrainListeners) {
        const el = constrainTo !== null && constrainTo !== void 0 && constrainTo.isRectangle ? globalThis : constrainTo;
        // Always observe for changes to window size since aligned things
        // will possibly be out of place after a window resize
        me.clearTimeout(me.resizeListenerTimeout);
        me.resizeListenerTimeout = me.setTimeout(() => {
          me.constrainListeners = true;
          ResizeMonitor.addResizeListener(el || globalThis, me.onAlignConstraintChange);
        }, me.ignoreScrollDuration);
      }
    }
  }
  onTargetParentMutation(mutationRecords) {
    const {
      element,
      lastAlignSpec
    } = this;
    if (lastAlignSpec !== null && lastAlignSpec !== void 0 && lastAlignSpec.aligningToElement) {
      var _lastAlignSpec$target;
      // If the target we are aligning to has exited the document, we must hide.
      if (!((_lastAlignSpec$target = lastAlignSpec.target) !== null && _lastAlignSpec$target !== void 0 && _lastAlignSpec$target.isConnected)) {
        this.hide();
      }
      // Any mutation of an element which owns the target but not this must cause realign.
      else if (mutationRecords.some(({
        target
      }) => target.contains(lastAlignSpec.target) && !element.contains(target))) {
        this.realign();
      }
    }
  }
  get intersectionObserver() {
    return this._intersectionObserver || (this._intersectionObserver = new IntersectionObserver(this.onTargetIntersectionchange.bind(this), {
      root: BrowserHelper.isSafari ? this.rootElement : this.rootElement.ownerDocument
    }));
  }
  onTargetIntersectionchange(entries) {
    if (!this.isDestroyed) {
      // It may go through several states. Only interrogate the latest.
      const e = entries[entries.length - 1];
      if (!e.isIntersecting) {
        this.onAlignTargetOutOfView(e.target);
      }
    }
  }
  onTargetResize() {
    const {
      lastAlignSpec
    } = this;
    if (lastAlignSpec) {
      const {
          width: lastWidth,
          height: lastHeight
        } = lastAlignSpec.targetRect,
        {
          width,
          height
        } = lastAlignSpec.target.getBoundingClientRect();
      // If the target's outer size has changed size since alignTo measured it, realign
      if (width !== lastWidth || height !== lastHeight) {
        this.onAlignConstraintChange(...arguments);
      }
    }
  }
  /**
   * This method is called when the {@link #function-alignTo} target element loses intersection with the
   * visible viewport. That means it has been scrolled out of view, or becomes zero size, or hidden or
   * is removed from the DOM.
   *
   * The base class implementation hides by default.
   * @param {HTMLElement} target The alignTo target that is no longer in view.
   * @internal
   */
  onAlignTargetOutOfView(target) {
    this.hide();
    this.lastAlignSpec && (this.lastAlignSpec.targetOutOfView = true);
  }
  onAlignConstraintChange(el, oldRect, {
    height
  }) {
    const {
        style
      } = this.contentElement,
      {
        overflowY
      } = style;
    // We must jump over any Responsive mixin changes which happen in this animation frame.
    this.setTimeout(this.realign, 50);
    // Blink doesn't remove vertical scrollbar upon release of size constraint without this.
    if (oldRect && height > oldRect.height) {
      style.overflowY = 'hidden';
      this.requestAnimationFrame(() => style.overflowY = overflowY);
    }
  }
  /**
   * Called when an element which affects the position of this Widget's
   * {@link #function-alignTo align target} scrolls so that this can realign.
   *
   * If the target has scrolled out of view, then this Widget is hidden.
   * @internal
   */
  realign() {
    const me = this,
      {
        lastAlignSpec
      } = me;
    if ((me.floating || me.positioned) && lastAlignSpec && me.isVisible) {
      if (lastAlignSpec.aligningToElement) {
        const insideTarget = lastAlignSpec.target.contains(this.element),
          realignTarget = DomHelper.isInView(lastAlignSpec.target, false, me);
        // If the target that we are realigning to is not in view, we hide, and set the
        // flag in the lastAlignSpec to explain why
        if (!lastAlignSpec.allowTargetOut && (!hasLayout(lastAlignSpec.target) || !realignTarget)) {
          me.hide();
          // Hiding *might* destroy if autoClose is set.
          if (!me.isDestroyed) {
            me.lastAlignSpec.targetOutOfView = true;
          }
          return;
        }
        // We use a different align target when *re*aligning. It's the *visible* rectangle.
        // Unless we re inside the target, in which case the target itself is used.
        lastAlignSpec.realignTarget = insideTarget ? null : realignTarget;
      }
      DomHelper.addTemporaryClass(me.element, 'b-realigning', me.realignTimeout, me);
      me.alignTo(lastAlignSpec);
    }
  }
  /**
   * Returns the specified bounding rectangle of this widget.
   * @param {'border'|'client'|'content'|'inner'|'outer'} [which='border'] By default, the rectangle returned is the
   * bounding rectangle that contains the `element` border. Pass any of these values to retrieve various rectangle:
   *  - `'border'` to get the {@link Core.helper.util.Rectangle#function-from-static border rectangle} (the default).
   *  - `'client'` to get the {@link Core.helper.util.Rectangle#function-client-static client rectangle}.
   *  - `'content'` to get the {@link Core.helper.util.Rectangle#function-content-static content rectangle}.
   *  - `'inner'` to get the {@link Core.helper.util.Rectangle#function-inner-static inner rectangle}.
   *  - `'outer'` to get the {@link Core.helper.util.Rectangle#function-outer-static outer rectangle}.
   * @param {HTMLElement|Core.widget.Widget} [relativeTo] Optionally, a parent element or widget in whose space to
   * calculate the Rectangle.
   * @param {Boolean} [ignorePageScroll=false] Use browser viewport based coordinates.
   * @returns {Core.helper.util.Rectangle}
   * @internal
   */
  rectangle(which, relativeTo, ignorePageScroll) {
    return this.rectangleOf('element', which, relativeTo, ignorePageScroll);
  }
  /**
   * Returns the specified bounding rectangle of the specified child `element` of this widget.
   * @param {String} [element] The child element name.
   * @param {'border'|'client'|'content'|'inner'|'outer'} [which='border'] By default, the rectangle returned
   * is the bounding rectangle that contains the `element` border. Pass any of these values to retrieve various
   * rectangle:
   *  - `'border'` to get the {@link Core.helper.util.Rectangle#function-from-static border rectangle} (the default).
   *  - `'client'` to get the {@link Core.helper.util.Rectangle#function-client-static client rectangle}.
   *  - `'content'` to get the {@link Core.helper.util.Rectangle#function-content-static content rectangle}.
   *  - `'inner'` to get the {@link Core.helper.util.Rectangle#function-inner-static inner rectangle}.
   *  - `'outer'` to get the {@link Core.helper.util.Rectangle#function-outer-static outer rectangle}.
   * @param {HTMLElement|Core.widget.Widget} [relativeTo] Optionally, a parent element or widget in whose space to
   * calculate the Rectangle. If `element` is not `'element'`, then this defaults to the widget's primary element.
   * @param {Boolean} [ignorePageScroll=false] Use browser viewport based coordinates.
   * @returns {Core.helper.util.Rectangle}
   * @internal
   */
  rectangleOf(element, which, relativeTo, ignorePageScroll) {
    var _relativeTo;
    if (typeof which !== 'string') {
      ignorePageScroll = relativeTo;
      relativeTo = which;
      which = '';
    } else if (which === 'border') {
      which = '';
    }
    // which is locked in
    if (typeof relativeTo === 'boolean') {
      ignorePageScroll = relativeTo;
      relativeTo = undefined;
    }
    if (element !== 'element' && relativeTo === undefined) {
      relativeTo = this.element;
    }
    relativeTo = (_relativeTo = relativeTo) !== null && _relativeTo !== void 0 && _relativeTo.isWidget ? relativeTo.element : relativeTo;
    return Rectangle[which || 'from'](this[element], relativeTo, ignorePageScroll);
  }
  releaseSizeConstraints() {
    const me = this,
      {
        scrollable,
        element,
        alignmentChanges
      } = me,
      {
        style
      } = element;
    // Release constraints so we can align from scratch each time.
    // 0001 = Height has been reduced from original
    // 0010 = Height has been increased from original
    // 0100 = Width has been reduced from original
    // 1000 = Width has been increased from original
    if (alignmentChanges & 0b1100) {
      DomHelper.setLength(element, me.alignedWidthStyle, me[`_last${StringHelper.capitalize(me.alignedWidthStyle)}`] || '');
      style.minWidth = me._minWidth || '';
      if (scrollable) {
        scrollable.overflowY = scrollable.config.overflowY;
      }
    }
    if (alignmentChanges & 0b0011) {
      DomHelper.setLength(element, me.alignedHeightStyle, me[`_last${StringHelper.capitalize(me.alignedHeightStyle)}`] || '');
      style.minHeight = me._minHeight || '';
      if (scrollable) {
        scrollable.overflowX = scrollable.config.overflowX;
      }
    }
    me.alignmentChanges = 0;
  }
  /**
   * Only valid for {@link #config-floating} Widgets. Moves to the front of the visual stacking order.
   * @category Float & align
   */
  toFront() {
    const {
        element
      } = this,
      parent = this.floating ? this.floatRoot : this.positioned ? element === null || element === void 0 ? void 0 : element.parentNode : null,
      widgetsFrag = document.createDocumentFragment();
    // If we contain focus and therefore should not be moved, collect all following elements which
    // it does not own, push them into a documentFragment and insert it before this.
    // If we containe focus, appending it triggers a focusOut event which will not be expected.
    if (this.containsFocus) {
      for (let followingEl = element.nextSibling, nextEl; followingEl; followingEl = nextEl) {
        nextEl = followingEl.nextSibling;
        if (parent.contains(followingEl) && !this.owns(followingEl)) {
          widgetsFrag.appendChild(followingEl);
        }
      }
      parent.insertBefore(widgetsFrag, element);
    }
    // If we do not contain focus, we can safely just be moved to the top of the stack.
    else {
      parent.appendChild(element);
    }
  }
  //endregion
  //region Getters/setters
  updateRef(ref) {
    this.element.dataset.ref = ref;
  }
  /**
   * The child element which scrolls if any. This means the element used by the {@link #config-scrollable}.
   * @property {HTMLElement}
   * @readonly
   * @category DOM
   * @advanced
   */
  get overflowElement() {
    return this.contentElement;
  }
  get maxHeightElement() {
    return this.element;
  }
  changeAlign(align) {
    return typeof align === 'string' ? {
      align
    } : align;
  }
  changeScrollable(scrollable, oldScrollable) {
    if (typeof scrollable === 'boolean') {
      scrollable = {
        overflowX: scrollable,
        overflowY: scrollable
      };
    }
    if (scrollable) {
      scrollable.element = this.overflowElement;
      scrollable.widget = this;
      if (!scrollable.isScroller) {
        scrollable = oldScrollable ? oldScrollable.setConfig(scrollable) : new this.scrollerClass(scrollable);
      }
      // Keep overflow indicator classes in sync
      scrollable.syncOverflowState();
    }
    // Destroy the old scroller if the scroller is being nulled.
    else {
      oldScrollable === null || oldScrollable === void 0 ? void 0 : oldScrollable.destroy();
    }
    return scrollable;
  }
  handleReactElement(html) {
    const parent = this.closest(cmp => cmp.reactComponent);
    if (parent !== null && parent !== void 0 && parent.reactComponent) {
      parent.reactComponent.processWidgetContent({
        reactElement: html,
        widget: this,
        reactComponent: parent.reactComponent
      });
    }
  }
  /**
   * Get/set HTML to display. When specifying HTML, this widget's element will also have the
   * {@link #config-htmlCls} added to its classList, to allow targeted styling.
   * @property {String}
   * @category DOM
   */
  get html() {
    // Maintainer, we cannot use a ternary here, we need the this.initializingElement test to shortcut
    // to the true case to return the _html property to avoid infinite loops.
    if (this.initializingElement || !this.element) {
      return this.content || this._html;
    }
    return this.contentElement.innerHTML;
  }
  updateHtml(html) {
    const me = this,
      isClearing = html == null,
      {
        element,
        contentElement,
        htmlCls
      } = me;
    // An existing element is needed for React support to work
    if (!element && DomHelper.isReactElement(html)) {
      me.whenVisible(() => me.handleReactElement(html));
      return;
    }
    if (element) {
      // So that our contentElement MutationObserver doesn't react
      me.updatingHtml = true;
      const anchorEl = contentElement === element && me._anchorElement;
      // Flag class that we are an HTML carrying element
      if (htmlCls) {
        // Salesforce doesn't support passing array
        htmlCls.values.forEach(value => element.classList[isClearing ? 'remove' : 'add'](value));
      }
      // Setting innerHTML destroys the anchorElement in some browsers, we must temporarily remove it to preserve
      // it. Only if the contentElement is the main element.
      if (anchorEl) {
        element.removeChild(anchorEl);
      }
      if (html && typeof html === 'object') {
        if (DomHelper.isReactElement(html)) {
          me.handleReactElement(html);
        } else {
          DomSync.sync({
            domConfig: {
              ...html,
              onlyChildren: true
            },
            targetElement: me.contentElement
          });
        }
      } else {
        me.contentElement.innerHTML = isClearing ? '' : html;
      }
      // Ensure our content mutation observer keeps us informed of changes by third parties
      // so that our config system can keep up to date.
      me.getConfig('htmlMutationObserver');
      if (anchorEl) {
        element.appendChild(anchorEl);
      }
      if (me.isComposable) {
        me.recompose();
      } else if (me.floating || me.positioned) {
        // Must realign because content change might change dimensions
        if (!me.isAligning) {
          me.realign();
        }
      }
    }
  }
  changeHtmlMutationObserver(htmlMutationObserver, was) {
    const me = this,
      {
        contentElement
      } = me;
    // Clean up old one
    was === null || was === void 0 ? void 0 : was.disconnect();
    // Create MutationObserver
    if (htmlMutationObserver) {
      const result = new MutationObserver(() => {
        if (me.updatingHtml) {
          me.updatingHtml = false;
        } else {
          me._html = contentElement.innerHTML;
        }
      });
      result.observe(contentElement, htmlMutationObserver);
      return result;
    }
  }
  updateContent(html) {
    const me = this,
      isClearing = html == null,
      {
        element,
        htmlCls
      } = me;
    if (element) {
      const {
        contentRange
      } = me;
      // Flag class that we are an HTML carrying element
      if (htmlCls) {
        // Salesforce doesn't support passing array
        htmlCls.values.forEach(value => element.classList[isClearing ? 'remove' : 'add'](value));
      }
      // Only works if we are in the DOM
      if (element.isConnected) {
        // Replace the contents of our content range with the new content
        contentRange.deleteContents();
        if (!isClearing) {
          contentRange.insertNode(DomHelper.createElementFromTemplate(html, {
            fragment: true
          }));
        }
      } else {
        me.contentElement.innerHTML = html;
      }
      // Cache in case it gets collapsed
      me.contentRangeStartOffset = contentRange.startOffset;
      me.contentRangeEndOffset = contentRange.endOffset;
      // Must realign because content change might change dimensions
      if ((me.floating || me.positioned) && !me.isAligning) {
        me.realign();
      }
    }
  }
  onThemeChange() {
    var _this$anchorElement;
    // If we have a *visible* anchor element, then a theme change may
    // invalidate it's size or this.defaultAnchorBackgroundColor, so a
    // run through realign (and get anchorSize) will fix that.
    if ((_this$anchorElement = this.anchorElement) !== null && _this$anchorElement !== void 0 && _this$anchorElement.offsetParent) {
      this._anchorSize = null;
      this.realign();
    }
  }
  /**
   * Returns an `[x, y]` array containing the width and height of the anchor arrow used when
   * aligning this Widget to another Widget or element.
   *
   * The height is the height of the arrow when pointing upwards, the width is the width
   * of the baseline.
   * @property {Number[]}
   * @category Float & align
   */
  get anchorSize() {
    const me = this;
    let result = this._anchorSize;
    if (!result) {
      const borderWidth = parseFloat(DomHelper.getStyleValue(me.element, 'border-top-width')),
        borderColour = DomHelper.getStyleValue(me.element, 'border-top-color'),
        anchorElement = me.anchorElement,
        {
          className
        } = anchorElement,
        svgEl = anchorElement.firstElementChild,
        pathElement = me.anchorPathElement = svgEl.lastElementChild,
        hidden = me._hidden;
      // In case we are measuring after the size has been invalidated (such as via theme change)
      // and the widget is shown and aligned left or right. We must measure it in top alignment
      // so as to get the dimensions the right way round.
      anchorElement.className = 'b-anchor b-anchor-top';
      let backgroundColour = DomHelper.getStyleValue(me.contentElement, 'background-color');
      // If the background colour comes through from the outer element, use that.
      if (backgroundColour.match(isTransparent)) {
        backgroundColour = DomHelper.getStyleValue(me.element, 'background-color');
      }
      me.defaultAnchorBackgroundColor = backgroundColour;
      result = anchorElement.getBoundingClientRect();
      const [width, height] = result = me._anchorSize = [result.width, result.height];
      // Restore orientation
      anchorElement.className = className;
      svgEl.setAttribute('height', height + borderWidth);
      svgEl.setAttribute('width', width);
      pathElement.setAttribute('d', `M0,${height}L${width / 2},0.5L${width},${height}`);
      if (borderWidth) {
        pathElement.setAttribute('stroke-width', borderWidth);
        pathElement.setAttribute('stroke', borderColour);
      }
      result[1] -= borderWidth;
      if (hidden) {
        me.element.classList.add('b-hidden');
      }
      if (!me.themeChangeListener) {
        me.themeChangeListener = GlobalEvents.ion({
          theme: 'onThemeChange',
          thisObj: me
        });
      }
      // Reset to default in case it has been positioned by a coloured header
      me.anchorPathElement.setAttribute('fill', me.defaultAnchorBackgroundColor);
    }
    return result;
  }
  get anchorElement() {
    const me = this;
    if (!me._anchorElement) {
      const useFilter = me.floating,
        filterId = `${me.id}-shadow-filter`;
      me._anchorElement = DomHelper.createElement({
        parent: me.element,
        className: 'b-anchor b-anchor-top',
        children: [{
          tag: 'svg',
          ns: 'http://www.w3.org/2000/svg',
          version: '1.1',
          class: 'b-pointer-el',
          children: [useFilter ? {
            tag: 'defs',
            children: [{
              tag: 'filter',
              id: filterId,
              children: [{
                tag: 'feDropShadow',
                dx: 0,
                dy: -1,
                stdDeviation: 1,
                'flood-opacity': 0.2
              }]
            }]
          } : null, {
            tag: 'path',
            [useFilter ? 'filter' : '']: `url(#${filterId})`
          }]
        }]
      });
    }
    return me._anchorElement;
  }
  updateAnchor(anchor) {
    if (this._anchorElement) {
      this._anchorElement.classList[anchor ? 'remove' : 'add']('b-hide-display');
    }
  }
  updateDraggable(draggable) {
    const me = this,
      {
        element
      } = me;
    if (draggable) {
      me.dragEventDetacher = EventHelper.addListener({
        element,
        dragstart: 'onWidgetDragStart',
        dragend: 'onWidgetDragEnd',
        thisObj: me
      });
      me.dragDetacher = EventHelper.on({
        element,
        mousedown(event) {
          const {
              target
            } = event,
            closestWidget = Widget.fromElement(target);
          // Fix for FF draggable bug https://bugzilla.mozilla.org/show_bug.cgi?id=1189486
          if (!event.target.closest('.b-field-inner') &&
          // Only allow drag to start when the action originates from the widget element itself,
          // or one of its toolbars. https://github.com/bryntum/support/issues/3214
          closestWidget === this || this.strips && Object.values(this.strips).includes(closestWidget)) {
            element.setAttribute('draggable', 'true');
          }
        },
        // Only needed for automatic listener removal on destruction of the thisObj
        thisObj: me
      });
    } else {
      var _me$dragEventDetacher2, _me$dragOverEventDeta2, _me$dragDetacher;
      (_me$dragEventDetacher2 = me.dragEventDetacher) === null || _me$dragEventDetacher2 === void 0 ? void 0 : _me$dragEventDetacher2.call(me);
      (_me$dragOverEventDeta2 = me.dragOverEventDetacher) === null || _me$dragOverEventDeta2 === void 0 ? void 0 : _me$dragOverEventDeta2.call(me);
      (_me$dragDetacher = me.dragDetacher) === null || _me$dragDetacher === void 0 ? void 0 : _me$dragDetacher.call(me);
    }
  }
  onWidgetDragStart(e) {
    var _ref4;
    const me = this;
    if (!me.validateDragStartEvent(e)) {
      return;
    }
    const {
        element,
        align,
        constrainTo
      } = me,
      positioned = me.positioned && DomHelper.getStyleValue(element, 'position') !== 'fixed',
      parentElement = positioned ? element.parentElement : me.rootElement,
      myRect = Rectangle.from(element, positioned ? parentElement : null),
      dragStartX = e.clientX,
      dragStartY = e.clientY,
      scrollingPageElement = document.scrollingElement || document.body,
      [widgetX, widgetY] = positioned ? DomHelper.getOffsetXY(element, parentElement) : me.getXY(),
      constrainRect = (_ref4 = positioned ? Rectangle.content(parentElement).moveTo(0, 0) : constrainTo && (constrainTo !== null && constrainTo !== void 0 && constrainTo.isRectangle ? constrainTo : Rectangle.from(constrainTo))) === null || _ref4 === void 0 ? void 0 : _ref4.deflate(align.constrainPadding || 0),
      dragListeners = {
        element: parentElement,
        dragover: event => {
          // Centered adds positioning rules, it can't be centered during drag.
          element.classList.remove('b-centered');
          // Shift our rectangle to the desired point.
          myRect.moveTo(widgetX + event.clientX - dragStartX - (positioned ? 0 : scrollingPageElement.scrollLeft), widgetY + event.clientY - dragStartY - (positioned ? 0 : scrollingPageElement.scrollTop));
          // Constrain it if we are configured to be constrained
          if (constrainRect) {
            myRect.constrainTo(constrainRect);
          }
          // Position using direct DOM access, do not go though the setXY method which clears
          // any centered config. User dragging only moves this show of the widget. Upon next
          // neutral show (with no extra positioning info), a centered widget will show centered again.
          DomHelper.setTranslateXY(element, myRect.x, myRect.y);
        }
      };
    // Stop viewport panning on drag on touch devices
    if (BrowserHelper.isTouchDevice) {
      dragListeners.touchmove = e => e.preventDefault();
    }
    me.floatRoot.appendChild(me.dragGhost);
    me.setDragImage(e);
    // Prevent special cursor from being shown
    e.dataTransfer.effectAllowed = 'none';
    me.dragOverEventDetacher = EventHelper.addListener(dragListeners);
    // Various app events (Such as resize or visible child count change) can
    // cause a request to realign, so opt out of anchoring and alignedness
    // until we are next hidden.
    me.alignTo();
  }
  /**
   * Validates a `dragstart` event with respect to the target element. Dragging is not normally
   * initiated when the target is interactive such as an input field or its label, or a button.
   * This may be overridden to provide custom drag start validation.
   * @param {DragEvent} e The `dragstart` event to validate.
   * @returns {Boolean} Return `true` if the drag is to be allowed.
   * @internal
   */
  validateDragStartEvent(e) {
    const me = this,
      {
        element
      } = me,
      actualTarget = DomHelper.elementFromPoint(e.clientX, e.clientY),
      // Can't be resolved from the event :/
      {
        handleSelector
      } = me.draggable;
    if (handleSelector) {
      var _negationPseudo$exec;
      const blacklist = (_negationPseudo$exec = negationPseudo.exec(handleSelector)) === null || _negationPseudo$exec === void 0 ? void 0 : _negationPseudo$exec[1]; // Extract the content of :not()
      // If the selector was :not(), then if we are a descendant of a matching element, it's a no-drag
      if (blacklist) {
        if (actualTarget.closest(`#${element.id} ${blacklist}`)) {
          e.preventDefault();
          return false;
        }
      }
      // If we are not the descendant of a matching element, it's a no-drag
      else if (!actualTarget.closest(`#${element.id} ${handleSelector}`)) {
        e.preventDefault();
        return false;
      }
    }
    return true;
  }
  setDragImage(e) {
    if (e.dataTransfer.setDragImage) {
      // Firefox requires this to be called before setDragImage
      e.dataTransfer.setData('application/node type', '');
      // Override the default HTML5 drag ghost and just drag an empty node.
      // The large offset will cause it to be displayed offscreen on platforms
      // which will not hide drag images (iOS)
      e.dataTransfer.setDragImage(this.dragGhost, -9999, -9999);
    }
  }
  setStyle(name, value) {
    DomHelper.applyStyle(this.element, ObjectHelper.isObject(name) ? name : {
      [name]: value
    });
    return this;
  }
  onWidgetDragEnd() {
    this.dragGhost.remove();
    this.dragOverEventDetacher();
    this.element.removeAttribute('draggable');
  }
  changeFloating(value) {
    // Coerce all to boolean so that we have a true/false value
    return Boolean(value);
  }
  changePositioned(value) {
    // Coerce all to boolean so that we have a true/false value
    return Boolean(value);
  }
  updatePositioned(positioned) {
    this.element.classList[positioned ? 'add' : 'remove']('b-positioned');
  }
  getXY() {
    return [DomHelper.getPageX(this.element), DomHelper.getPageY(this.element)];
  }
  /**
   * Moves this Widget to the x,y position. Both arguments can be omitted to just set one value.
   *
   * *For {@link #config-floating} Widgets, this is a position in the browser viewport.*
   * *For {@link #config-positioned} Widgets, this is a position in the element it was rendered into.*
   *
   * @param {Number} [x]
   * @param {Number} [y]
   * @category Float & align
   */
  setXY(x, y) {
    const me = this,
      {
        element
      } = me;
    if (me.floating || me.positioned) {
      if (x != null) {
        me._x = x;
      }
      if (y != null) {
        me._y = y;
      }
      // If we're position:fixed then it is positioned relative to either the viewport
      // or an ancestor which has a transform, perspective of filter property.
      // See https://developer.mozilla.org/en-US/docs/Web/CSS/position.
      // So translate it *relative* to its actual position/
      if (DomHelper.getStyleValue(element, 'position') === 'fixed') {
        const r = element.getBoundingClientRect(),
          [cx, cy] = DomHelper.getTranslateXY(element),
          xDelta = x - r.x,
          yDelta = y - r.y;
        DomHelper.setTranslateXY(element, cx + xDelta, cy + yDelta);
      } else {
        DomHelper.setTranslateXY(element, me._x || 0, me._y || 0);
      }
      if (me.isConstructing) {
        me.centered = false;
      } else {
        element.classList.remove('b-centered');
      }
    }
  }
  /**
   * Moves this Widget to the desired x position.
   *
   * Only valid if this Widget is {@link #config-floating} and not aligned or anchored to an element.
   * @property {Number}
   * @category Float & align
   */
  get x() {
    return this.getXY()[0];
  }
  changeX(x) {
    this.setXY(x);
  }
  /**
   * Moves this Widget to the desired y position.
   *
   * Only valid if this Widget is {@link #config-floating} and not aligned or anchored to an element.
   * @property {Number}
   * @category Float & align
   */
  get y() {
    return this.getXY()[1];
  }
  changeY(y) {
    this.setXY(null, y);
  }
  /**
   * Get elements offsetWidth or sets its style.width, or specified width if element not created yet.
   * @property {Number}
   * @accepts {Number|String}
   * @category Layout
   */
  get width() {
    const me = this,
      element = me.element;
    if (me.monitorResize) {
      // If the width is invalid, read it now.
      if (me._width == null) {
        me._width = element.offsetWidth;
      }
      // Usually this will be set in onInternalResize
      return me._width;
    }
    // No monitoring, we have to measure;
    return element.offsetWidth;
  }
  changeWidth(width) {
    const me = this;
    DomHelper.setLength(me.element, 'width', width);
    me._lastWidth = width;
    // Invalidate the width, so it will be read from the DOM if a read is requested before the resize event
    me._width = null;
    // Setting width explicitly should reset flex, since it's not flexed anymore
    me._flex = null;
    me.element.style.flex = '';
  }
  // This method is used by State API to drop cached width early to not rely on ResizeMonitor
  clearWidthCache() {
    this._width = null;
  }
  /**
   * Get/set elements maxWidth. Getter returns max-width from elements style, which is always a string. Setter accepts
   * either a String or a Number (which will have 'px' appended). Note that like {@link #config-width},
   * _reading_ the value will return the numeric value in pixels.
   * @property {String}
   * @accepts {String|Number}
   * @category Layout
   */
  get maxWidth() {
    return DomHelper.measureSize(this.element.style.maxWidth, this.element);
  }
  updateMaxWidth(maxWidth) {
    this._lastMaxWidth = maxWidth;
    DomHelper.setLength(this.element, 'maxWidth', maxWidth);
  }
  /**
   * Get/set elements minWidth. Getter returns min-width from elements style, which is always a string. Setter accepts
   * either a String or a Number (which will have 'px' appended). Note that like {@link #config-width},
   * _reading_ the value will return the numeric value in pixels.
   * @property {String}
   * @accepts {String|Number}
   * @category Layout
   */
  get minWidth() {
    return DomHelper.measureSize(this.element.style.minWidth, this.element);
  }
  updateMinWidth(minWidth) {
    DomHelper.setLength(this.element, 'minWidth', minWidth);
  }
  updateFlex(flex) {
    // Width must be processed first, because its changer clears flex because flex wins over width;
    // The assumption that the containing element's flex-direction is 'row'
    // seems dodgy.
    this.getConfig('width');
    // Default grow to the same as flex and basis to 0.
    if (typeof flex === 'number' || !isNaN(flex)) {
      flex = `${flex} ${flex}`;
    }
    this.element.style.flex = flex;
    this.element.style.width = '';
  }
  updateAlignSelf(alignSelf) {
    this.element.style.alignSelf = alignSelf;
  }
  updateMargin(margin) {
    // Convert eg 1 to "1px 1px 1px 1px" or "0 8px" to "0px 8px 0px 8px"
    this.element.style.margin = this.parseTRBL(margin).join(' ');
  }
  updateTextAlign(align, oldAlign) {
    oldAlign && this.element.classList.remove(`b-text-align-${oldAlign}`);
    this.element.classList.add(`b-text-align-${align}`);
  }
  updatePlaceholder(placeholder) {
    if (this.input) {
      if (placeholder == null) {
        this.input.removeAttribute('placeholder');
      } else {
        this.input.placeholder = placeholder;
      }
    }
  }
  /**
   * Get element's offsetHeight or sets its style.height, or specified height if element no created yet.
   * @property {Number}
   * @accepts {Number|String}
   * @category Layout
   */
  get height() {
    const me = this,
      element = me.element;
    if (me.monitorResize) {
      // If the height is invalid, read it now.
      if (me._height == null) {
        me._height = element.offsetHeight;
      }
      // Usually this will be set in onInternalResize
      return me._height;
    }
    // No monitoring, we have to measure;
    return element.offsetHeight;
  }
  changeHeight(height) {
    DomHelper.setLength(this.element, 'height', height);
    this._lastHeight = height;
    // Invalidate the height, so it will be read from the DOM if a read is requested before the resize event
    this._height = null;
  }
  /**
   * Get/set element's maxHeight. Getter returns max-height from elements style, which is always a string. Setter
   * accepts either a String or a Number (which will have 'px' appended). Note that like {@link #config-height},
   * _reading_ the value will return the numeric value in pixels.
   * @property {String}
   * @accepts {String|Number}
   * @category Layout
   */
  get maxHeight() {
    return DomHelper.measureSize(this.maxHeightElement.style.maxHeight, this.element);
  }
  updateMaxHeight(maxHeight) {
    this._lastMaxHeight = maxHeight;
    DomHelper.setLength(this.maxHeightElement, 'maxHeight', maxHeight);
  }
  /**
   * Get/set element's minHeight. Getter returns min-height from elements style, which is always a string. Setter
   * accepts either a String or a Number (which will have 'px' appended). Note that like {@link #config-height},
   * _reading_ the value will return the numeric value in pixels.
   * @property {String}
   * @accepts {String|Number}
   * @category Layout
   */
  get minHeight() {
    return DomHelper.measureSize(this.element.style.minHeight, this.element);
  }
  updateMinHeight(minHeight) {
    DomHelper.setLength(this.element, 'minHeight', minHeight);
  }
  updateDisabled(disabled = false) {
    const {
      element,
      focusElement,
      ariaElement
    } = this;
    this.trigger('beforeUpdateDisabled', {
      disabled
    });
    if (disabled) {
      this.revertFocus();
      // If some focus listener changed our state, we must not continue
      if (this._disabled !== disabled) {
        return;
      }
    }
    if (element) {
      element.classList[disabled ? 'add' : 'remove']('b-disabled');
      if (focusElement) {
        focusElement.disabled = disabled;
      }
      if (ariaElement) {
        ariaElement.setAttribute('aria-disabled', disabled);
      }
    }
    this.onDisabled(disabled);
  }
  /**
   * Called when disabled state is changed.
   * Override in subclass that needs special handling when being disabled.
   * @param {Boolean} disabled current state
   * @private
   */
  onDisabled(disabled) {}
  /**
   * Disable the widget
   */
  disable() {
    this.disabled = true;
  }
  /**
   * Enable the widget
   */
  enable() {
    this.disabled = false;
  }
  /**
   * Requests fullscreen display for this widget
   * @returns {Promise} A Promise which is resolved with a value of undefined when the transition to full screen is complete.
   */
  requestFullscreen() {
    const me = this,
      // If we are floating, target the float root as the fullscreen element
      result = Fullscreen.request(me.floating ? me.floatRoot : me.element);
    Fullscreen.onFullscreenChange(me.onFullscreenChange);
    me.element.classList.add('b-fullscreen');
    return result;
  }
  /**
   * Exits fullscreen mode
   * @returns {Promise} A Promise which is resolved once the user agent has finished exiting full-screen mode
   */
  exitFullscreen() {
    return Fullscreen.exit();
  }
  onFullscreenChange() {
    if (!Fullscreen.isFullscreen) {
      this.onExitFullscreen();
    }
  }
  onExitFullscreen() {
    Fullscreen.unFullscreenChange(this.onFullscreenChange);
    this.element.classList.remove('b-fullscreen');
  }
  /**
   * Get/set a tooltip on the widget. Accepts a string or tooltip config (specify true (or 'true') to use placeholder
   * as tooltip). When using a string it will configure the tooltip with `textContent: true` which enforces a default
   * max width.
   *
   * By default, this uses a singleton Tooltip instance which may be accessed from the `{@link Core.widget.Widget}`
   * class under the name `Widget.tooltip`. This is configured according to the config object on pointer over.
   *
   * To request a separate instance be created just for this widget, add `newInstance : true` to the configuration.
   *
   * @property {String|TooltipConfig}
   * @category Misc
   */
  get tooltip() {
    const me = this;
    if (me._tooltip) {
      return me._tooltip;
    } else {
      var _Widget$Tooltip2;
      const tooltip = (_Widget$Tooltip2 = Widget.Tooltip) === null || _Widget$Tooltip2 === void 0 ? void 0 : _Widget$Tooltip2.getSharedTooltip(me.rootElement, me.eventRoot);
      // If the shared tooltip is currently in use by us, return it.
      // If it's not in use by us, we don't have a tooltip.
      if (tooltip && tooltip.activeTarget === me._element && tooltip.isVisible) {
        return tooltip;
      }
    }
  }
  //noinspection JSAnnotator
  changeTooltip(tooltip, oldTooltip) {
    const me = this,
      {
        element
      } = me;
    if (tooltip) {
      if (!(me.preventTooltipOnTouch && BrowserHelper.isTouchDevice)) {
        if (!tooltip.isTooltip && tooltip.constructor.name !== 'Object') {
          tooltip = {
            html: typeof tooltip === 'string' ? tooltip : me.placeholder,
            textContent: true
          };
        }
        // Tooltip text becomes ariaDescription unless we already have ariaDescription configured.
        // If it is localized using {key}, it will need to be converted to {Tooltip.key}
        // so that when we come to resolve it, localization looks in the right place.
        if (!me.configureAriaDescription) {
          var _tooltip$html;
          me.ariaDescription = (_tooltip$html = tooltip.html) !== null && _tooltip$html !== void 0 && _tooltip$html.match(localizeRE) ? tooltip.html.replace(localizeRE, localizeTooltip) : tooltip.html;
        }
        // We have to explicitly request a new instance to avoid spam Tooltip instances.
        // If there is an incoming oldTooltip, then we own a newInstance.
        if (oldTooltip !== null && oldTooltip !== void 0 && oldTooltip.isTooltip || tooltip.newInstance) {
          tooltip.type = 'tooltip';
          if (!tooltip.forElement) tooltip.forElement = element;
          if (!('showOnHover' in tooltip) && !tooltip.forSelector) tooltip.showOnHover = true;
          if (!('autoClose' in tooltip)) tooltip.autoClose = true;
          tooltip = Widget.reconfigure(oldTooltip, tooltip, me);
          // We need to update our ariaDescription when the tooltip changes
          me.detachListeners('tooltipValueListener');
          if (!me.configureAriaDescription) {
            tooltip.ion({
              name: 'tooltipValueListener',
              innerHtmlUpdate: 'onTooltipValueChange',
              thisObj: me
            });
          }
        }
        // The default is that tooltip content and configs from tipConfig
        else {
          element.dataset.btip = true;
          me.tipConfig = tooltip;
          // We do not set our property if we are sharing the singleton
          return;
        }
      }
    } else {
      // If there is an incoming oldTooltip, then we own a newInstance.
      // Only destroy it if it's being set to null. Empty string
      // just means clear its content.
      if (oldTooltip) {
        if (tooltip == null && oldTooltip.isTooltip) {
          oldTooltip.destroy();
        } else {
          // We do not update the property if we are just clearing its content
          oldTooltip.html = null;
          return;
        }
      }
      // We are sharing, so just clear the btip
      else {
        delete element.dataset.btip;
      }
    }
    return tooltip;
  }
  /**
   * The shared {@link Core.widget.Tooltip} instance which handles
   * {@link Core.widget.Widget#config-tooltip tooltips} which are __not__ configured
   * with `newInstance : true`.
   * @member {Core.widget.Tooltip} tooltip
   * @readonly
   * @static
   */
  // This property is defined in the Tooltip module but must be documented here.
  // If our tooltip is dynamic, then we must update our aria-describedBy whenever it changes.
  onTooltipValueChange({
    value,
    source
  }) {
    this.ariaDescription = typeof value == 'string' ? value : source.contentElement.innerText;
  }
  get tooltipText() {
    const tooltip = this._tooltip;
    if (tooltip) {
      return tooltip.isTooltip ? tooltip.contentElement.innerText : typeof tooltip === 'string' ? tooltip : tooltip.html;
    } else if (this.tipConfig) {
      return this.tipConfig.html;
    }
  }
  /**
   * Determines visibility by checking if the Widget is hidden, or any ancestor is hidden and that it has an
   * element which is visible in the DOM
   * @property {Boolean}
   * @category Visibility
   * @readonly
   */
  get isVisible() {
    const me = this,
      {
        element
      } = me;
    // Added so that we only acquire owner once. `get owner()` *may* have to search DOM
    let owner;
    // If we are hidden, or destroying, or any ancestors are hidden, we're not visible
    return Boolean(element && !me._hidden && !me.isDestroying && element.isConnected && (!me.requireSize || hasLayout(element)) && (!(owner = me.containingWidget) || owner.isVisible));
  }
  whenVisible(callback, thisObj = this, args, id = callback) {
    const me = this;
    // Might be visible before being painted, queued calls are processed on paint, matching for direct calls
    if (me.isVisible && me.isPainted) {
      me.callback(callback, thisObj, args);
    } else {
      // Multiple calls should replace previous requests so latest requested args are used.
      (me.toCallWhenVisible || (me.toCallWhenVisible = new Map())).set(id, {
        callback,
        thisObj,
        args
      });
    }
  }
  /**
   * Focuses this widget if it has a focusable element.
   */
  focus() {
    if (this.isFocusable) {
      DomHelper.focusWithoutScrolling(this.focusElement);
    }
  }
  /**
   * Get this widget's primary focus holding element if this widget is itself focusable, or contains focusable widgets.
   * @property {HTMLElement}
   * @readonly
   * @category DOM
   * @advanced
   */
  get focusElement() {
    // Override in widgets which are focusable.
  }
  get isFocusable() {
    // Not focusable if we are in a destroy sequence or are disabled or not visible.
    const focusElement = !this.isDestroying && this.isVisible && !this.disabled && this.focusElement;
    // We are only focusable if the focusEl is deeply visible, that means
    // it must have layout - an offsetParent. Body does not have offsetParent.
    return focusElement && (focusElement === document.body || focusElement.offsetParent);
  }
  /**
   * Shows this widget
   * @param {Object} [options] modifications to the show operation
   * @param {AlignSpec} [options.align] An alignment specification as passed to {@link #function-alignTo}
   * @param {Boolean} [options.animate=true] Specify as `false` to omit the {@link #config-showAnimation}
   * @category Visibility
   * @returns {Promise} A promise which is resolved when the widget is shown
   */
  async show({
    align,
    animate = true
  } = {}) {
    const me = this,
      {
        element,
        floating
      } = me,
      {
        style
      } = element,
      showAnimation = animate && me.showAnimation;
    let styleProp,
      animProps,
      trigger = !me.isVisible;
    if (trigger) {
      /**
       * Triggered before a widget is shown. Return `false` to prevent the action.
       * @preventable
       * @async
       * @event beforeShow
       * @param {Core.widget.Widget} source The widget being shown.
       */
      trigger = me.trigger('beforeShow');
      if (ObjectHelper.isPromise(trigger)) {
        trigger = await trigger;
      }
    }
    if (trigger !== false && (!me.internalBeforeShow || me.internalBeforeShow() !== false)) {
      return new Promise(resolve => {
        // Cancel any current hide/show animation
        me.cancelHideShowAnimation();
        // Centered config value takes precedence over x and y configs.
        // This also ensures that widgets configured with centered: true
        // and draggable : true will show in the center on next show after
        // being dragged by the user which is the intuitive UX.
        me.updateCentered(me._centered);
        if (floating) {
          const floatRoot = me.floatRoot;
          if (!floatRoot.contains(element)) {
            // Replace this Widget's DOM into the container if it's already rendered
            if (me.rendered) {
              floatRoot.appendChild(me.element);
            } else {
              // Pass triggerPaint as false. The calls will not propagate
              // anyway since we are still hidden.
              me.render(floatRoot, false);
            }
          }
          // Because we are outside of any owner's element, we need to see if they're scaled so
          // that we match. See scaled examples with tooltips in API docs guides section.
          if (style.transform.includes('scale')) {
            me.scale = null;
            style.transform = style.transformOrigin = '';
          }
          const scaledAncestor = me.closest(isScaled);
          if (scaledAncestor) {
            const {
              scale
            } = scaledAncestor;
            // Our scale is the same while we are visible and owned by that scaled ancestor.
            // Now floating descendants will follow suit.
            me.scale = scale;
            style.transform = `scale(${scale})`;
            style.transformOrigin = `0 0`;
          }
        }
        me._hidden = false;
        element.classList.remove('b-hidden');
        // We may have been hidden by application CSS outside our knowledge
        // so explicitly hide. If we are already in the hidden state, this is a no-op.
        if (floating && !isVisible(element)) {
          me.hide(false);
          resolve();
        }
        // The changer vetoes the config change and routes here, so we must call this.
        me.onConfigChange({
          name: 'hidden',
          value: false,
          was: true,
          config: me.$meta.configs.hidden
        });
        if (showAnimation) {
          styleProp = Object.keys(showAnimation)[0];
          animProps = showAnimation[styleProp];
          const currentAnimation = me.currentAnimation = {
            showing: true,
            styleProp,
            resolve
          };
          me.isAnimating = true;
          // No transition when forcing style to the animation start state
          style.transition = 'none';
          // Setting transition style initial value before showing,
          // then reading the style to ensure transition will animate
          style[styleProp] = animProps.from;
          DomHelper.getStyleValue(element, styleProp);
          // afterHideShowAnimate will always be called even if the transition aborts
          me.currentAnimation.detacher = EventHelper.onTransitionEnd({
            element,
            property: styleProp,
            duration: parseDuration(animProps.duration) + 20,
            handler: () => me.afterHideShowAnimate(currentAnimation),
            thisObj: me
          });
          style.transition = `${styleProp} ${animProps.duration} ease ${animProps.delay}`;
          style[styleProp] = animProps.to;
        }
        me.afterShow(align, !showAnimation ? resolve : null);
      });
    } else {
      return Promise.resolve();
    }
  }
  /**
   * Show aligned to another target element or {@link Core.widget.Widget} or {@link Core.helper.util.Rectangle}
   * @param {AlignSpec|HTMLElement|Number[]} align Alignment specification, or the element to align to using the
   * configured {@link #config-align}.
   * @category Float & align
   * @returns {Promise} A promise which is resolved when the widget is shown
   */
  async showBy(align, yCoord, options) {
    const me = this,
      isArray = Array.isArray(align);
    // We are being asked to align to a point
    if (isArray || typeof align === 'number') {
      const xy = isArray ? align : [align, yCoord];
      align = Object.assign({
        target: new Point(xy[0] + 1, xy[1] + 1),
        // Override any matchSize that we might have in our align config.
        // Otherwise we are going to be 1px wide/high
        matchSize: false,
        align: 't0-b0'
      }, isArray ? yCoord : options);
    }
    // Needs to have a layout to be aligned.
    me.requireSize = true;
    if (me.isVisible) {
      DomHelper.addTemporaryClass(me.element, 'b-realigning', 300, me);
      // Pass on possible [x, y, options] signature for showing at coordinates.
      me.alignTo(align);
    } else {
      return me.show({
        align
      });
    }
  }
  /**
   * Show this widget anchored to a coordinate
   * @param {Number|Number[]} x The x position (or an array with [x,y] values) to show by
   * @param {Number} [y] The y position to show by
   * @param {AlignSpec} [options] See {@link #function-showBy} for reference
   * @category Float & align
   * @deprecated Since 5.0.2. Use {@link #function-showBy} method with the same signature.
   * @returns {Promise} A promise which is resolved when the widget is shown
   */
  async showByPoint() {
    VersionHelper.deprecate('Core', '6.0.0', 'Widget.showByPoint() replaced by Widget.showBy() with the same signature');
    return this.showBy(...arguments);
  }
  afterShow(align, resolveFn) {
    var _me$owner, _me$owner$onChildShow;
    const me = this;
    /**
     * Triggered after a widget is shown.
     * @event show
     * @param {Core.widget.Widget} source The widget
     */
    me.trigger('show');
    // Cache our preferred anchoredness in case it's overridden by a drag.
    me._configuredAnchorState = me.anchor;
    // Keep any owning container informed about visibility state.
    // It may not be a Container. SubGrid class is still a Widget
    // which contains grid headers.
    (_me$owner = me.owner) === null || _me$owner === void 0 ? void 0 : (_me$owner$onChildShow = _me$owner.onChildShow) === null || _me$owner$onChildShow === void 0 ? void 0 : _me$owner$onChildShow.call(_me$owner, me);
    me.triggerPaint();
    // Align either as explicitly requested, or according to configuration
    if (me.floating || me.positioned) {
      if (align) {
        me.alignTo(align);
      }
      // Go through alignTo to apply constrainTo and the transient listeners if centered
      else if (me.centered) {
        me.alignTo({
          target: me.constrainTo,
          align: 'c-c'
        });
      } else if (me.forElement) {
        me.alignTo(me.forElement);
      }
    }
    resolveFn === null || resolveFn === void 0 ? void 0 : resolveFn();
  }
  onChildHide(hidden) {
    if (hidden.floating) {
      this.ariaElement.removeAttribute('aria-owns');
    }
  }
  onChildShow(shown) {
    if (shown.floating) {
      this.ariaHasPopup = shown.role;
      this.ariaElement.setAttribute('aria-owns', shown.id);
    }
  }
  triggerPaint() {
    const me = this,
      {
        element,
        toCallWhenVisible
      } = me,
      firstPaint = !me.isPainted;
    if (me.isVisible) {
      if (firstPaint) {
        me.getConfig('scrollable');
        // Not for public use, only used in docs
        if (me.scaleToFitWidth && !me.monitorResize) {
          me.onParentElementResize = me.onParentElementResize.bind(me);
          ResizeMonitor.addResizeListener(element.parentElement, me.onParentElementResize);
          me.updateScale();
        }
        // Add a comment node "Powered by Bryntum"
        if (!me.hideBryntumDomMessage && (me.isTaskBoardBase || me.isGridBase || me.isCalendar)) {
          element.insertBefore(new Comment('POWERED BY BRYNTUM (https://bryntum.com)'), element.firstChild);
        }
        // ResizeObserver check needed since we have a test removing it to check polyfill.
        // All supported platforms have it though, so no need to use polyfill here
        if (me.onConnectedCallback && globalThis.ResizeObserver) {
          // Track when element is added to or removed from DOM
          me.connectedObserver = new ResizeObserver(() => {
            if (me.isElementConnected && !element.isConnected) {
              me.onConnectedCallback(false);
              me.isElementConnected = false;
            } else if (!me.isElementConnected && element.isConnected) {
              me.onConnectedCallback(true, me.isElementConnected == null);
              me.isElementConnected = true;
            }
          });
          me.connectedObserver.observe(element);
        }
      }
      // Trigger paint only on immediate children.
      // Each one will call this recursively.
      // paint is triggered in a bottom up manner.
      me.eachWidget(widgetTriggerPaint, false);
      if (firstPaint) {
        // Make sure the shared tooltip is initialized
        me.getConfig('tooltip');
        // Late setup of Ripple
        if (!Widget.Ripple && Widget.RippleClass) {
          Widget.Ripple = new Widget.RippleClass({
            rootElement: me.rootElement
          });
        }
        // Hack for Docs to be able to have a consistent font size for floating fiddle subviews
        if (globalThis.DocsBrowser && me.floating && me.closest(w => {
          var _w$element;
          return (_w$element = w.element) === null || _w$element === void 0 ? void 0 : _w$element.closest('.fiddlePanelResult,.b-owned-by-fiddle');
        })) {
          element.classList.add('b-owned-by-fiddle');
        }
      }
      /**
       * Triggered when a widget which had been in a non-visible state for any reason
       * achieves visibility.
       *
       * A non-visible state *might* mean the widget is hidden and has just been shown.
       *
       * But this event will also fire on widgets when a non-visible (unrendered, or hidden)
       * ancestor achieves visibility, for example a {@link Core.widget.Popup Popup} being shown.
       *
       * TLDR: __This event can fire multiple times__
       * @event paint
       * @param {Core.widget.Widget} source The widget being painted.
       * @param {Boolean} firstPaint `true` if this is the first paint.
       */
      me.isPainted = true;
      // Initialize any paint configs now. This comes after setting isPainted in case update logic finds itself
      // off in code that checks. This timing being equivalent to the paint event should result in no widget
      // state issues for moving logic out of a onetime paint listener into a paint config.
      firstPaint && me.triggerConfigs('paint');
      me.trigger('paint', {
        firstPaint
      });
      if (toCallWhenVisible !== null && toCallWhenVisible !== void 0 && toCallWhenVisible.size) {
        for (const {
          callback,
          thisObj,
          args
        } of toCallWhenVisible.values()) {
          me.callback(callback, thisObj, args);
        }
        toCallWhenVisible.clear();
      }
      if (firstPaint) {
        // On first paint, we should announce our size immediately.
        // When the real event comes along, onElementResize will reject it because the size will be the same.
        if (me.monitorResize && !me.scaleToFitWidth) {
          ResizeMonitor.onElementResize([{
            target: element
          }]);
        }
      }
    }
  }
  cancelHideShowAnimation() {
    const me = this,
      {
        currentAnimation,
        element
      } = me;
    if (currentAnimation) {
      me.isAnimating = false;
      // If it is an animated hide that we are aborting, reverse the set of the hidden flag
      // If hide is animated, we only get genuinely hidden at animation end.
      if (element.classList.contains('b-hiding')) {
        element.classList.remove('b-hiding');
        me._hidden = false;
      }
      currentAnimation.detacher();
      currentAnimation.resolve();
      element.style.transition = element.style[currentAnimation.styleProp] = '';
      me.currentAnimation = null;
      me.trigger(`${currentAnimation.showing ? 'show' : 'hide'}AnimationEnd`);
    }
  }
  afterHideShowAnimate(currentAnimation) {
    // We receive the currentAnimation as understood by the party starting the animation... if that is not the
    // current value of "this.currentAnimation" we can ignore this call.
    const me = this;
    // If menu is destroyed too soon in Edge, this method will be invoked for destroyed element. Since all of our
    // properties are cleared on destroy, this check will prevent undesired reactions:
    if (currentAnimation === me.currentAnimation) {
      // Ensure cancelHideShowAnimation doesn't think we're aborting before the end.
      me.element.classList.remove('b-hiding');
      me.cancelHideShowAnimation();
      // Element must be fully hidden after the animation effect finishes
      if (me._hidden) {
        me.afterHideAnimation();
      }
    }
  }
  /**
   * Temporarily changes the {@link #property-isVisible} to yield `false` regardless of this
   * Widget's true visibility state. This can be useful for suspending operations which rely on
   * the {@link #property-isVisible} property.
   *
   * This increments a counter which {@link #function-resumeVisibility} decrements.
   * @internal
   */
  suspendVisibility() {
    this._visibilitySuspended = (this._visibilitySuspended || 0) + 1;
    Object.defineProperty(this, 'isVisible', returnFalseProp);
  }
  /**
   * Resumes visibility. If the suspension counter is returned to zero by this, then the
   * {@link #event-paint} event is triggered, causing a cascade of `paint` events on all
   * descendants. This can be prevented by passing `false` as the only parameter.
   * @param {Boolean} [triggerPaint=true] Trigger the {@link #event-paint} event.
   * @internal
   */
  resumeVisibility(triggerPaint = true) {
    if (! --this._visibilitySuspended) {
      delete this.isVisible;
      if (triggerPaint) {
        this.triggerPaint();
      }
    }
  }
  /**
   * Hide widget
   * @param {Boolean} animate Pass `true` (default) to animate the hide action
   * @category Visibility
   * @returns {Promise} A promise which is resolved when the widget has been hidden
   */
  hide(animate = true) {
    return new Promise(resolve => {
      const me = this,
        {
          element,
          lastAlignSpec
        } = me,
        {
          style
        } = element,
        hideAnimation = animate && me.hideAnimation;
      // If we get hidden very quickly after a call to show,
      // we must kill the timers which add the realign listeners.
      me.clearTimeout(me.scrollListenerTimeout);
      me.clearTimeout(me.resizeListenerTimeout);
      /**
       * Triggered before a widget is hidden. Return `false` to prevent the action.
       * @preventable
       * @event beforeHide
       * @param {Core.widget.Widget} source The widget being hidden.
       */
      // replaced check for isVisible with _hidden, need to hide a component not yet in view in EventEditor
      if (!me._hidden && me.trigger('beforeHide', {
        animate
      }) !== false) {
        me._hidden = true;
        // The flag must be cleared on a normal hide.
        // It's set if we hide due to the target being scrolled out of view.
        if (lastAlignSpec) {
          lastAlignSpec.targetOutOfView = null;
          if (lastAlignSpec.monitorIntersection) {
            me.intersectionObserver.takeRecords();
            me.intersectionObserver.unobserve(lastAlignSpec.target);
          }
        }
        // The changer vetoes the config change and routes here, so we must call this.
        me.onConfigChange({
          name: 'hidden',
          value: true,
          was: false,
          config: me.$meta.configs.hidden
        });
        if (!element) {
          resolve();
          return;
        }
        if (element.contains(DomHelper.getActiveElement(element))) {
          me.revertFocus(true);
        }
        // Focus exit causes close if autoClose: true, and if closeAction: 'hide'
        // that might destroy us, so exit now if that happens.
        if (me.isDestroyed) {
          resolve();
          return;
        }
        // Cancel any current hide/show animation
        me.cancelHideShowAnimation();
        if (hideAnimation) {
          const styleProp = Object.keys(hideAnimation)[0],
            animProps = hideAnimation[styleProp];
          // Make sure we are not already at the final value of the hide animation (i.e. calling hide() directly after show())
          if (Number(getComputedStyle(me.element)[styleProp]) !== animProps.to) {
            const currentAnimation = me.currentAnimation = {
              hiding: true,
              styleProp,
              resolve
            };
            // Element must behave as though it were not there during
            // the animated hide. This means pointer-events:none
            element.classList.add('b-hiding');
            me.isAnimating = true;
            // afterHideShowAnimate will always be called even if the transition aborts
            me.currentAnimation.detacher = EventHelper.onTransitionEnd({
              element,
              property: styleProp,
              duration: parseDuration(animProps.duration) + 20,
              handler: () => me.afterHideShowAnimate(currentAnimation),
              thisObj: me
            });
            // Setting transition style initial value before showing,
            // then reading the style to ensure transition will animate
            style[styleProp] = animProps.from;
            DomHelper.getStyleValue(element, styleProp);
            style.transition = `${styleProp} ${animProps.duration} ease ${animProps.delay}`;
            style[styleProp] = animProps.to;
          } else {
            element.classList.add('b-hidden');
          }
        } else {
          element.classList.add('b-hidden');
        }
        // only supply resolve function if not using animation
        me.afterHide(!hideAnimation && resolve, hideAnimation);
      }
    });
  }
  doHideOrRealign({
    target,
    isTrusted
  }) {
    const me = this,
      {
        lastAlignSpec,
        element
      } = me,
      anchoredTo = lastAlignSpec === null || lastAlignSpec === void 0 ? void 0 : lastAlignSpec.anchoredTo,
      lastTarget = lastAlignSpec === null || lastAlignSpec === void 0 ? void 0 : lastAlignSpec.target,
      position = lastAlignSpec === null || lastAlignSpec === void 0 ? void 0 : lastAlignSpec.position,
      activeEl = DomHelper.getActiveElement(me);
    if (
    // If it's a synthesized scroll event (such as from our ResizeMonitor polyfill), ignore it.
    !isTrusted ||
    // Realign happens on frame, might have been removed from DOM so check whether it has layout
    !hasLayout(element) ||
    // event.target might be missing with LockerService enabled. we still need to call the logic as it does not
    // depend much on the scroll target
    target && (
    // If the scroll is inside our element, ignore it.
    element.contains(target) || target.nodeType === Element.ELEMENT_NODE && me.owns(target) ||
    // If we're scrolling because a focused textual input field which we contain is being shifted into view,
    // we must not reposition - we'll just move with the document content.

    target.nodeType === Element.DOCUMENT_NODE && element.contains(activeEl) && textInputTypes[activeEl] && globalThis.innerHeight < document.body.offsetHeight)) {
      return;
    }
    // If we were aligned to an element and the new visible rectangle is the same as the old one
    // then ignore the scroll. It had no effect on our aligment status.
    if (lastAlignSpec.aligningToElement) {
      const newTarget = DomHelper.isInView(lastTarget, false, me);
      // newTarget?.equals doesn't work if value is `false`
      if (newTarget && newTarget.equals(lastAlignSpec.targetRect)) {
        return;
      }
    }
    // Store current position if we are to hide on scroll below,
    // used to determine if realigning did actually move us and thus should hide
    const xy = me.scrollAction === 'hide' && me.getXY();
    // Perform the realignment
    me.realign();
    // Might destroy on hide in realign, so check for isDestroyed.
    if (!me.isDestroyed && isVisible(element) && me.scrollAction === 'hide') {
      const [newX, newY] = me.getXY(),
        moved = newX !== xy[0] || newY !== xy[1];
      // If the scroll caused our position to become invalid, and we either don't know what element
      // we're anchored to (or not anchored to one at all), or the element we're anchored to has been
      // removed, or affected by the scroll, we must hide.
      // target might be missing with LockerService enabled
      if (lastAlignSpec !== null && lastAlignSpec !== void 0 && lastAlignSpec.aligningToEvent || (moved || (lastTarget === null || lastTarget === void 0 ? void 0 : lastTarget.$$name) === 'Point' || position) && (!anchoredTo || !hasLayout(anchoredTo) || target && DomHelper.isDescendant(target, anchoredTo))) {
        me.hide();
      }
    }
  }
  afterHide(resolveFn = null, hideAnimation = this.hideAnimation) {
    var _me$owner2, _me$owner2$onChildHid;
    const me = this;
    // If a drag caused us to lose our anchor, restore it upon hide.
    me._anchor = me._configuredAnchorState;
    // Remove listeners which are only added during the visible phase.
    // In its own method because it's called on hide and destroy.
    me.removeTransientListeners();
    // Postprocessing to be done after the hideAnimation finishes.
    // If there's no animation, we call it immediately.
    // We set the element to be hidden here, after any animation completes.
    // We also remove floating Widgets from the DOM when they are hidden.
    if (!hideAnimation) {
      me.afterHideAnimation();
    }
    /**
     * Triggered after a widget was hidden
     * @event hide
     * @param {Core.widget.Widget} source The widget
     */
    me.trigger('hide');
    // Keep any owning container informed about visibility state.
    // It may not be a Container. SubGrid class is still a Widget
    // which contains grid headers.
    (_me$owner2 = me.owner) === null || _me$owner2 === void 0 ? void 0 : (_me$owner2$onChildHid = _me$owner2.onChildHide) === null || _me$owner2$onChildHid === void 0 ? void 0 : _me$owner2$onChildHid.call(_me$owner2, me);
    resolveFn && resolveFn(); // cannot do resolveFn?.() since resolveFn can be false
  }

  removeTransientListeners() {
    var _me$documentScrollLis, _me$targetRootScrollL;
    const me = this,
      {
        targetObserver,
        lastAlignSpec
      } = me;
    me.clearTimeout(me.resizeListenerTimeout);
    me.clearTimeout(me.scrollListenerTimeout);
    // Stop observing whether our alignTo target is there.
    if (targetObserver) {
      targetObserver.disconnect();
      delete me.targetObserver;
    }
    me.documentScrollListener = (_me$documentScrollLis = me.documentScrollListener) === null || _me$documentScrollLis === void 0 ? void 0 : _me$documentScrollLis.call(me);
    me.targetRootScrollListener = (_me$targetRootScrollL = me.targetRootScrollListener) === null || _me$targetRootScrollL === void 0 ? void 0 : _me$targetRootScrollL.call(me);
    if (me.targetResizeListener) {
      ResizeMonitor.removeResizeListener(lastAlignSpec.target, me.onTargetResize);
      me.targetResizeListener = false;
    }
    if (me.constrainListeners) {
      var _lastAlignSpec$constr;
      const el = (_lastAlignSpec$constr = lastAlignSpec.constrainTo) !== null && _lastAlignSpec$constr !== void 0 && _lastAlignSpec$constr.isRectangle ? globalThis : lastAlignSpec.constrainTo;
      ResizeMonitor.removeResizeListener(el || globalThis, me.onAlignConstraintChange);
      me.constrainListeners = false;
    }
  }
  afterHideAnimation() {
    const me = this,
      {
        element
      } = me;
    if (me.floating && me.floatRoot.contains(element)) {
      element.remove();
    } else {
      element.classList.add('b-hidden');
    }
    // Reset anchor to its default colour after hide
    if (me.defaultAnchorBackgroundColor) {
      // Reset to default in case it has been positioned by a coloured header
      me.anchorPathElement.setAttribute('fill', me.defaultAnchorBackgroundColor);
    }
  }
  changeHidden(value) {
    const me = this;
    let ret;
    if (me.isConfiguring) {
      ret = Boolean(value);
      me.element.classList[value ? 'add' : 'remove']('b-hidden');
    } else {
      // These methods are async but set _hidden when they get past the before event, so don't set ret and
      // the setter won't set _hidden automatically.
      me.trigger('beforeChangeHidden', {
        hidden: value
      });
      if (value) {
        me.hide();
      } else {
        me.show();
      }
    }
    return ret;
  }
  /**
   * Get id assigned by user (not generated id)
   * @returns {String}
   * @readonly
   * @private
   * @category Misc
   */
  get assignedId() {
    return this.hasGeneratedId ? null : this.id;
  }
  /**
   * Get this Widget's parent when used as a child in a {@link Core.widget.Container},
   * @member {Core.widget.Widget} parent
   * @readonly
   * @category Widget hierarchy
   */
  /**
   * Get the owning Widget of this Widget. If this Widget is directly contained, then the containing
   * Widget is returned. If this Widget is floating, the configured `owner` property is returned.
   * If there is a `forElement`, that element's encapsulating Widget is returned.
   * @property {Core.widget.Widget}
   * @readonly
   * @category Widget hierarchy
   */
  get owner() {
    return this.parent || this._owner || this.containingWidget;
  }
  get containingWidget() {
    let result = this.parent;
    if (!result) {
      var _this$forElement, _this$element;
      const owningEl = ((_this$forElement = this.forElement) === null || _this$forElement === void 0 ? void 0 : _this$forElement.nodeType) === Element.ELEMENT_NODE ? this.forElement : (_this$element = this.element) === null || _this$element === void 0 ? void 0 : _this$element.parentNode;
      result = (owningEl === null || owningEl === void 0 ? void 0 : owningEl.closest('.b-widget')) && Widget.fromElement(owningEl);
    }
    return result;
  }
  /**
   * Get this Widget's previous sibling in the parent {@link Core.widget.Container Container}, or, if not
   * in a Container, the previous sibling widget in the same _parentElement_.
   * @property {Core.widget.Widget}
   * @readonly
   * @category Widget hierarchy
   */
  get previousSibling() {
    return this.getSibling(-1);
  }
  /**
   * Get this Widget's next sibling in the parent {@link Core.widget.Container Container}, or, if not
   * in a Container, the next sibling widget in the same _parentElement_.
   * @property {Core.widget.Widget}
   * @readonly
   * @category Widget hierarchy
   */
  get nextSibling() {
    return this.getSibling(1);
  }
  getSibling(increment) {
    const me = this,
      {
        parent
      } = me,
      siblings = parent ? parent.childItems : Array.from(me.element.parentElement.querySelectorAll('.b-widget'));
    return parent ? siblings[siblings.indexOf(me) + increment] : Widget.fromElement(siblings[siblings.indexOf(me.element) + increment]);
  }
  /**
   * Looks up the {@link #property-owner} axis to find an ancestor which matches the passed selector.
   * The selector may be a widget type identifier, such as `'grid'`, or a function which will return
   * `true` when passed the desired ancestor.
   * @param {String|Function} [selector] A Type identifier or selection function. If not provided, this method returns
   * the {@link #property-owner} of this widget
   * @param {Boolean} [deep] When using a string identifier, pass `true` if all superclasses should be included, i.e.,
   * if a `Grid` should match `'widget'`.
   * @param {Number|String|Core.widget.Widget} [limit] how many steps to step up before aborting the search, or a
   * selector to stop at or the topmost ancestor to consider.
   * @category Widget hierarchy
   */
  up(selector, deep, limit) {
    var _owner$closest;
    const {
      owner
    } = this;
    return selector ? owner === null || owner === void 0 ? void 0 : (_owner$closest = owner.closest) === null || _owner$closest === void 0 ? void 0 : _owner$closest.call(owner, selector, deep, limit) : owner;
  }
  /**
   * Starts with this Widget, then Looks up the {@link #property-owner} axis to find an ancestor which matches the
   * passed selector. The selector may be a widget type identifier, such as `'grid'`, or a function which will return
   * `true` when passed the desired ancestor.
   * @param {String|Function} selector A Type identifier or selection function.
   * @param {Boolean} [deep] When using a string identifier, pass `true` if all superclasses should be included, i.e.,
   * if a `Grid` should match `'widget'`.
   * @param {Number|String|Core.widget.Widget} [limit] how many steps to step up before aborting the search, or a
   * selector to stop at or the topmost ancestor to consider.
   * @category Widget hierarchy
   */
  closest(selector, deep, limit) {
    const limitType = typeof limit,
      numericLimit = limitType === 'number',
      selectorLimit = limitType === 'string';
    for (let result = this, steps = 1; result; result = result.owner, steps++) {
      if (Widget.widgetMatches(result, selector, deep)) {
        return result;
      }
      if (numericLimit && steps >= limit) {
        return;
      } else if (selectorLimit && Widget.widgetMatches(result, limit, deep)) {
        return;
      } else if (result === limit) {
        return;
      }
    }
  }
  /**
   * Returns `true` if this Widget owns the passed Element, Event or Widget. This is based on the widget hierarchy,
   * not DOM containment. So an element in a `Combo`'s dropdown list will be owned by the `Combo`.
   * @param {HTMLElement|Event|Core.widget.Widget} target The element event or Widget to test for being
   * within the ownership tree of this Widget.
   * @category Widget hierarchy
   */
  owns(target) {
    if (target) {
      // Passed an event, grab its target
      if ('eventPhase' in target) {
        target = target.target;
      }
      // We were passed an HTMLElement
      if (target.nodeType === Element.ELEMENT_NODE) {
        if (this.element.contains(target)) {
          return true;
        }
        target = Widget.fromElement(target);
      }
      while (target) {
        if (target === this) {
          return true;
        }
        target = target.owner;
      }
    }
    return false;
  }
  /**
   * Iterate over all ancestors of this widget.
   *
   * *Note*: Due to this method aborting when the function returns `false`, beware of using short form arrow
   * functions. If the expression executed evaluates to `false`, iteration will terminate.
   * @param {Function} fn Function to execute for all ancestors. Terminate iteration by returning `false`.
   * @returns {Boolean} Returns `true` if iteration was not aborted by a step returning `false`
   * @category Widget hierarchy
   */
  eachAncestor(fn) {
    let ancestor = this.owner;
    while (ancestor) {
      if (fn(ancestor) === false) {
        return false;
      }
      ancestor = ancestor.owner;
    }
    return true;
  }
  changeMaximizeOnMobile(maximizeOnMobile) {
    const me = this;
    if (me.floating && BrowserHelper.isMobile) {
      const {
        initialConfig
      } = me;
      if (maximizeOnMobile) {
        me.centered = me.modal = false;
        me.maximized = true;
      } else {
        me.centered = initialConfig.modal;
        me.modal = initialConfig.centered;
        me.maximized = initialConfig.maximized;
      }
    }
  }
  changeMonitorResize(monitorResize, oldMonitorResize) {
    // They are mutually exclusive. scaleToFitWidth disables monitorResize
    const result = this.scaleToFitWidth ? false : Boolean(monitorResize);
    // null and undefined both mean false. Avoid going through the updater if no change.
    if (result !== Boolean(oldMonitorResize)) {
      return result;
    }
  }
  updateMonitorResize(monitorResize) {
    const me = this;
    if (!hasOwn(me, 'onElementResize')) {
      me.onElementResize = me.onElementResize.bind(me);
    }
    ResizeMonitor[monitorResize ? 'addResizeListener' : 'removeResizeListener'](me.element, me.onElementResize);
  }
  changeReadOnly(readOnly) {
    readOnly = Boolean(readOnly);
    // It starts as undefined, so if false is passed, that's a no-change.
    if (Boolean(this._readOnly) !== readOnly) {
      return readOnly;
    }
  }
  updateReadOnly(readOnly) {
    var _this$element2;
    // Can be called from the element initialization because of the way Panel is set up.
    // tbar and bbar are instantiated, and their elements added to the gathered element
    // config object, but that can have consequences which can lead here.
    (_this$element2 = this.element) === null || _this$element2 === void 0 ? void 0 : _this$element2.classList[readOnly ? 'add' : 'remove']('b-readonly');
    // Do not update children at configure time.
    // Container will sync its items.
    if (!this.isConfiguring) {
      // Implemented at this level because Widgets can own a descendant tree without being
      // a Container. For example Combos own a ChipView and a List. Buttons own a Menu etc.
      this.eachWidget(widget => {
        // Some fields may not want to automatically be readOnly (such as a nested filter field not affecting data)
        if (widget.ignoreParentReadOnly) {
          return;
        }
        if (!('_originalReadOnly' in widget)) {
          // Store initial readOnly/disabled value.
          // the config getter copies the properties in a loop
          // so execute once and cache the value.
          widget._originalReadOnly = widget.config.readOnly || false;
        }
        // Set if truthy, otherwise reset to initial value
        widget.readOnly = readOnly || widget._originalReadOnly;
      }, false);
      /**
       * Fired when a Widget's read only state is toggled
       * @event readOnly
       * @param {Boolean} readOnly Read only or not
       */
      this.trigger('readOnly', {
        readOnly
      });
    }
  }
  /**
   * Iterate over all widgets owned by this widget and any descendants.
   *
   * *Note*: Due to this method aborting when the function returns `false`, beware of using short form arrow
   * functions. If the expression executed evaluates to `false`, iteration will terminate.
   * @param {Function} fn A function to execute upon each descendant widget.
   * Iteration terminates if this function returns `false`.
   * @param {Core.widget.Widget} fn.widget The current descendant widget.
   * @param {Object} fn.control An object containing recursion control options.
   * @param {Boolean} fn.control.down A copy of the `deep` parameter. This can be adjusted by `fn` to decide which
   * widgets should be recursed. This value will always be the value of `deep` on entry and the value of `control.down`
   * upon return determines the recursion into the current widget.
   * @param {Boolean} [deep=true] Pass as `false` to only consider immediate child widgets.
   * @returns {Boolean} Returns `true` if iteration was not aborted by a step returning `false`
   * @category Widget hierarchy
   */
  eachWidget(fn, deep = true) {
    const widgets = this.childItems,
      length = (widgets === null || widgets === void 0 ? void 0 : widgets.length) || 0,
      control = {};
    for (let i = 0; i < length; i++) {
      const widget = widgets[i];
      control.down = deep;
      // Abort if a call returns false
      if (fn(widget, control) === false) {
        return false;
      }
      if (control.down && widget.eachWidget) {
        // Abort if a deep call returns false
        if (widget.eachWidget(fn, deep) === false) {
          return false;
        }
      }
    }
    return true;
  }
  /**
   * Returns an array of all descendant widgets which the passed
   * filter function returns `true` for.
   * @param {Function} filter A function which, when passed a widget,
   * returns `true` to include the widget in the results.
   * @returns {Core.widget.Widget[]} All matching descendant widgets.
   * @category Widget hierarchy
   */
  queryAll(filter) {
    const result = [];
    this.eachWidget(w => {
      if (filter(w)) {
        result.push(w);
      }
    });
    return result;
  }
  /**
   * Returns the first descendant widgets which the passed
   * filter function returns `true` for.
   * @param {Function} filter A function which, when passed a widget,
   * returns `true` to return the widget as the sole result.
   * @returns {Core.widget.Widget} The first matching descendant widget.
   * @category Widget hierarchy
   */
  query(filter) {
    let result = null;
    this.eachWidget(w => {
      if (filter(w)) {
        result = w;
        return false;
      }
    });
    return result;
  }
  /**
   * Get a widget by ref, starts on self and traverses up the owner hierarchy checking `widgetMap` at each level.
   * Not checking the top level widgetMap right away to have some acceptance for duplicate refs.
   * @param {String} ref ref to find
   * @returns {Core.widget.Widget}
   * @internal
   * @category Widget hierarchy
   */
  getWidgetByRef(ref) {
    var _this$widgetMap, _this$owner;
    if (ref instanceof Widget) {
      return ref;
    }
    return (this === null || this === void 0 ? void 0 : (_this$widgetMap = this.widgetMap) === null || _this$widgetMap === void 0 ? void 0 : _this$widgetMap[ref]) || (this === null || this === void 0 ? void 0 : (_this$owner = this.owner) === null || _this$owner === void 0 ? void 0 : _this$owner.getWidgetByRef(ref));
  }
  onFocusIn(e) {
    const me = this,
      {
        element
      } = me;
    me.containsFocus = true;
    me.focusInEvent = e;
    // Focusing moves a floating or positioned widget to the front of the DOM stack.
    if (me.floating || me.positioned) {
      me.toFront();
    }
    element.classList.add('b-contains-focus');
    me.updateAriaLabel(me.localizeProperty('ariaLabel'));
    me.updateAriaDescription(me.localizeProperty('ariaDescription'));
    if (element.contains(e._target) && me.onInternalKeyDown && !me.keyDownListenerRemover) {
      me.keyDownListenerRemover = EventHelper.on({
        element,
        keydown: 'onInternalKeyDown',
        thisObj: me
      });
    }
    /**
     * Fired when focus enters this Widget.
     * @event focusIn
     * @param {Core.widget.Widget} source - This Widget
     * @param {HTMLElement} fromElement The element which lost focus.
     * @param {HTMLElement} toElement The element which gained focus.
     * @param {Core.widget.Widget} fromWidget The widget which lost focus.
     * @param {Core.widget.Widget} toWidget The widget which gained focus.
     * @param {Boolean} backwards `true` if the `toElement` is before the `fromElement` in document order.
     */
    me.trigger('focusin', e);
  }
  onFocusOut(e) {
    const me = this;
    if (me.keyDownListenerRemover) {
      me.keyDownListenerRemover();
      me.keyDownListenerRemover = null;
    }
    if (!me.isDestroyed) {
      // Focus to nowhere, focus a close relation
      if (!e.relatedTarget) {
        me.revertFocus(!me.isVisible);
      }
      me.containsFocus = false;
      me.element.classList.remove('b-contains-focus');
      me.updateAriaLabel(me.localizeProperty('ariaLabel'));
      me.updateAriaDescription(me.localizeProperty('ariaDescription'));
      /**
       * Fired when focus exits this Widget's ownership tree. This is different from a `blur` event.
       * focus moving from within this Widget's ownership tree, even if there are floating widgets
       * will not trigger this event. This is when focus exits this widget completely.
       * @event focusOut
       * @param {Core.widget.Widget} source - This Widget
       * @param {HTMLElement} fromElement The element which lost focus.
       * @param {HTMLElement} toElement The element which gained focus.
       * @param {Core.widget.Widget} fromWidget The widget which lost focus.
       * @param {Core.widget.Widget} toWidget The widget which gained focus.
       * @param {Boolean} backwards `true` if the `toElement` is before the `fromElement` in document order.
       */
      me.trigger('focusout', e);
    }
  }
  /**
   * Returns a function that will set the focus (`document.activeElement`) to the most consistent element possible
   * based on the focus state at the time this method was called. Derived classes can implement `captureFocusItem()`
   * to refine this process to include logical items (e.g., a grid cell) that would be more stable than DOM element
   * references.
   *
   * If this widget does not contain the focus, the returned function will do nothing.
   * @returns {Function}
   * @internal
   */
  captureFocus() {
    const me = this,
      activeElementWas = DomHelper.getActiveElement(me),
      restore = me.contains(activeElementWas) && me.captureFocusItem(activeElementWas);
    return (scrollIntoView, force) => {
      if (restore && !me.isDestroying) {
        const activeElementNow = DomHelper.getActiveElement(me);
        if (activeElementNow !== activeElementWas || force) {
          restore(scrollIntoView);
        }
      }
    };
  }
  /**
   * This method is called by `captureFocus()` when this widget contains the focus and it returns a function that
   * restores the focus to the correct internal element. The returned function is only called if the current
   * `document.activeElement` is different from the passed `activeElement`.
   *
   * This method can be replaced by derived classes to capture stable identifiers for the currently focused, logical
   * item (for example, a cell of a grid).
   *
   * @param {HTMLElement} activeElement The current `document.activeElement`.
   * @returns {Function} Returns a function that accepts a boolean argument. Defaults to `true`, `false` attempts to
   * focus without scrolling.
   * @internal
   */
  captureFocusItem(activeElement) {
    return (scrollIntoView = true) => {
      if (this.contains(activeElement)) {
        scrollIntoView ? activeElement.focus() : DomHelper.focusWithoutScrolling(activeElement);
      }
    };
  }
  /**
   * Returns `true` if this widget is or contains the specified element or widget.
   * @param {HTMLElement|Core.widget.Widget} elementOrWidget The element or widget
   * @param {Boolean} [strict] Pass `true` to test for strict containment (if `elementOrWidget` is this widget, the
   * return value will be `false`).
   * @returns {Boolean}
   * @category Widget hierarchy
   */
  contains(elementOrWidget, strict) {
    const {
      element
    } = this;
    if (elementOrWidget && element) {
      if (elementOrWidget.isWidget) {
        elementOrWidget = elementOrWidget.element;
      }
      // el.contains(el) === true
      return element.contains(elementOrWidget) && (!strict || element !== elementOrWidget);
    }
  }
  /**
   * If this Widget contains focus, focus is reverted to the source from which it entered if possible,
   * or to a close relative if not.
   * @param {Boolean} [force] Pass as `true` to move focus to the previously focused item, or the
   * closest possible relative even if this widget does not contain focus.
   * @advanced
   */
  revertFocus(force) {
    var _me$focusInEvent, _target;
    const me = this,
      activeElement = DomHelper.getActiveElement(me);
    let target = (_me$focusInEvent = me.focusInEvent) === null || _me$focusInEvent === void 0 ? void 0 : _me$focusInEvent.relatedTarget;
    if (force || me.containsFocus && ((_target = target) === null || _target === void 0 ? void 0 : _target.nodeType) === Element.ELEMENT_NODE && me.element.contains(activeElement)) {
      if (!target || !DomHelper.isFocusable(target)) {
        target = me.getFocusRevertTarget();
      }
      me._isRevertingFocus = true;
      if (target && DomHelper.isFocusable(target)) {
        target._isRevertingFocus = true;
        DomHelper.focusWithoutScrolling(target);
        target._isRevertingFocus = false;
      } else {
        // If we could not find a suitable target to receive focus, we still need to not be focused. Oddly,
        // one cannot do "document.body.focus()" but explicitly calling blur() has that effect. If we do not
        // do this, and we retain the focus, we can have issue w/closeAction=destroy which can cause the blur
        // in afterHideAnimation which then causes that element.remove() to throw DOM exceptions.
        activeElement === null || activeElement === void 0 ? void 0 : activeElement.blur();
      }
      me._isRevertingFocus = false;
    }
  }
  /**
   * This method finds a close sibling (or parent, or parent's sibling etc. recursively) to which focus
   * can be directed in the case of revertFocus not having a focusable element from our focusInEvent.
   *
   * This can happen when the "from" component is destroyed or hidden. We should endeavour to prevent
   * focus escaping to `document.body` for accessibility and ease of use, and keep focus close.
   * @internal
   */
  getFocusRevertTarget() {
    const me = this,
      {
        owner,
        focusInEvent
      } = me,
      searchDirection = focusInEvent ? focusInEvent.backwards ? 1 : -1 : -1;
    let target = focusInEvent && focusInEvent.relatedTarget;
    const toComponent = target && Widget.fromElement(target);
    // If the from element is now not focusable, for example an Editor which hid
    // itself on focus leave, then we have to find a sibling/parent/parent's sibling
    // to take focus. Anything is better than flipping to document.body.
    if (owner && !owner.isDestroyed && (!target || !DomHelper.isFocusable(target) || toComponent && !toComponent.isFocusable)) {
      var _owner$getFocusRevert;
      target = null;
      // If this widget can have siblings, then find the closest
      // (in the direction focus arrived from) focusable sibling.
      if (owner.eachWidget) {
        const siblings = [];
        // Collect focusable siblings.
        // With this included so we can find ourselves.
        owner.eachWidget(w => {
          if (w === me || w.isFocusable) {
            siblings.push(w);
          }
        }, false);
        if (siblings.length > 1) {
          const myIndex = siblings.indexOf(me);
          target = siblings[myIndex + searchDirection] || siblings[myIndex - searchDirection];
        }
      }
      // No focusable siblings found to take focus, try the owner
      if (!target && owner.isFocusable) {
        target = owner;
      }
      // If non of the above found any related focusable widget,
      // Go through these steps for the owner.
      target = target ? target.focusElement : (_owner$getFocusRevert = owner.getFocusRevertTarget) === null || _owner$getFocusRevert === void 0 ? void 0 : _owner$getFocusRevert.call(owner);
    }
    return target;
  }
  /**
   * Returns a `DomClassList` computed from the `topMostBase` (e.g., `Widget` or `Panel`) with the given `suffix`
   * appended to each `widgetClass`.
   * @param {Function} topMostBase The top-most base class constructor at which to start gathering classes.
   * @param {String} [suffix] An optional suffix to apply to all widget classes.
   * @returns {Core.helper.util.DomClassList}
   * @internal
   * @category DOM
   */
  getStaticWidgetClasses(topMostBase, suffix) {
    const classList = new DomClassList(),
      hierarchy = this.$meta.hierarchy;
    let cls, i, name, widgetClass, widgetClassProperty;
    for (i = hierarchy.indexOf(topMostBase); i < hierarchy.length; ++i) {
      var _widgetClassProperty;
      cls = hierarchy[i];
      widgetClassProperty = Reflect.getOwnPropertyDescriptor(cls.prototype, 'widgetClass');
      // If the Class has its own get widgetClass, call it upon this instance.
      if ((_widgetClassProperty = widgetClassProperty) !== null && _widgetClassProperty !== void 0 && _widgetClassProperty.get) {
        widgetClass = widgetClassProperty.get.call(this);
      } else {
        // All built in widgets should define $name to be safer from minification/obfuscation, but user
        // created might not so fall back to actual name. UMD files use a _$name property
        // which the Base $$name getter uses as a fallback.
        name = hasOwn(cls, '$$name') || hasOwn(cls, '$name') || hasOwn(cls, '_$name') ? cls.$$name : cls.name;
        // Throw error in case of an obfuscated name or an autogenerated name.
        // These should never be released without a meaningful $name getter.
        if (name.length < 3 || name.includes('$')) {
          // class.$name comes from parent API class which has it
          console.warn(`Class "${name}" extending "${cls.$name}" should have "$name" static getter with no less than 3 chars.`);
        }
        widgetClass = `b-${name.toLowerCase()}`;
      }
      if (widgetClass) {
        classList.add(suffix ? widgetClass + suffix : widgetClass);
      }
    }
    return classList;
  }
  get rootUiClass() {
    return Widget;
  }
  /**
   * Returns the `DomClassList` for this widget's class. This object should not be mutated.
   * @returns {Core.helper.util.DomClassList}
   * @internal
   * @category DOM
   */
  get staticClassList() {
    const {
      $meta: meta
    } = this;
    let classList = meta.staticClassList;
    if (!classList) {
      // Compute the class part of the widgetList just once per class (cache it on the $meta object):
      meta.staticClassList = classList = this.getStaticWidgetClasses(Widget);
      BrowserHelper.isTouchDevice && classList.add('b-touch');
    }
    return classList;
  }
  /**
   * Returns the cross-product of the classes `staticClassList` with each `ui` as an array of strings.
   *
   * For example, a Combo with a `ui: 'foo bar'` would produce:
   *
   *      [
   *          'b-widget-foo', 'b-field-foo', 'b-textfield-foo', 'b-pickerfield-foo', 'b-combo-foo',
   *          'b-widget-bar', 'b-field-bar', 'b-textfield-bar', 'b-pickerfield-bar', 'b-combo-bar'
   *      ]
   *
   * @returns {String[]}
   * @internal
   * @category DOM
   */
  get uiClasses() {
    // our result is maintained by updateUi so ensure the ui config has been evaluated:
    this.getConfig('ui');
    return this._uiClasses;
  }
  /**
   * Returns the cross-product of the classes `staticClassList` with each `ui` as a `DomClassList` instance.
   *
   * For example, a Combo with a `ui: 'foo bar'` would produce:
   *
   * ```javascript
   *      new DomClassList({
   *          'b-field-ui-foo'       : 1,
   *          'b-textfield-ui-foo'   : 1,
   *          'b-pickerfield-ui-foo' : 1,
   *          'b-combo-ui-foo'       : 1,
   *
   *          'b-field-ui-bar'       : 1,
   *          'b-textfield-ui-bar'   : 1,
   *          'b-pickerfield-ui-bar' : 1,
   *          'b-combo-ui-bar'       : 1
   *      });
   * ```
   *
   * A Panel with a `ui: 'foo bar'` would produce:
   *
   * ```javascript
   *      new DomClassList({
   *          'b-panel-ui-foo' : 1,
   *          'b-panel-ui-bar' : 1
   *      });
   * ```
   * @returns {Core.helper.util.DomClassList}
   * @internal
   * @category DOM
   */
  get uiClassList() {
    // our result is maintained by updateUi so ensure the ui config has been evaluated:
    this.getConfig('ui');
    return this._uiClassList;
  }
  /**
   * Used by the Widget class internally to create CSS classes based on this Widget's
   * inheritance chain to allow styling from each level to apply.
   *
   * For example Combo would yield `"["b-widget", "b-field", "b-textfield", "b-pickerfield", "b-combo"]"`
   *
   * May be implemented in subclasses to add or remove classes from the super.widgetClassList
   * @returns {String[]} The css class list named using the class name.
   * @internal
   * @category DOM
   */
  get widgetClassList() {
    const me = this,
      {
        cls,
        defaultCls,
        uiClasses
      } = me;
    let {
      staticClassList
    } = me;
    if (defaultCls || cls) {
      // clone the class-level classList before instance stuff goes on...
      staticClassList = staticClassList.clone();
      defaultCls && staticClassList.assign(defaultCls); // note: these can be falsy keys
      cls && staticClassList.assign(cls);
    }
    const classList = staticClassList.values; // a new array of truthy keys...
    uiClasses && classList.push(...uiClasses);
    me.floating && classList.push('b-floating');
    if (me.collapsify === 'hide') {
      classList.push('b-collapsify-hide');
    }
    return classList;
  }
  changeCls(cls) {
    return DomClassList.from(cls);
  }
  updateCls(cls, was) {
    if (!this.isConfiguring && !this.isComposable) {
      const {
        element
      } = this;
      if (was) {
        ObjectHelper.getTruthyKeys(was).forEach(c => element.classList.remove(c));
      }
      cls.assignTo(element);
    }
  }
  changeContentElementCls(cls) {
    return DomClassList.from(cls);
  }
  changeHtmlCls(cls) {
    return DomClassList.from(cls);
  }
  changeDefaultCls(cls) {
    return DomClassList.from(cls, /* returnEmpty */true);
  }
  changeUi(ui) {
    return DomClassList.from(ui);
  }
  updateUi(ui) {
    var _uiClassList;
    let uiClassList = null,
      cls,
      suffix;
    if (ui) {
      const staticClassList = this.getStaticWidgetClasses(this.rootUiClass);
      for (suffix in ui) {
        if (ui[suffix]) {
          for (cls in staticClassList) {
            if (staticClassList[cls]) {
              (uiClassList || (uiClassList = new DomClassList()))[`${cls}-ui-${suffix}`] = 1;
            }
          }
        }
      }
    }
    this._uiClasses = (_uiClassList = uiClassList) === null || _uiClassList === void 0 ? void 0 : _uiClassList.values; // an array of each value
    this._uiClassList = uiClassList;
  }
  //endregion
  //region Cache
  /**
   * Gets dom elements in the view. Caches the results for faster future calls.
   * @param {String} query CSS selector
   * @param {Boolean} children true to fetch multiple elements
   * @param {HTMLElement} element Element to use as root for the query, defaults to the views outermost element
   * @returns {HTMLElement|HTMLElement[]|null} A single element or an array of elements (if parameter children is set to true)
   * @internal
   * @category DOM
   */
  fromCache(query, children = false, element = this.element) {
    if (!element) return null;
    const me = this;
    if (!me.cache[query]) {
      me.cache[query] = children ? DomHelper.children(element, query) : DomHelper.down(element, query);
    }
    return me.cache[query];
  }
  /**
   * Clear caches, forces all calls to fromCache to requery dom. Called on render/rerender.
   * @internal
   * @category DOM
   */
  emptyCache() {
    this.cache = {};
  }
  //endregion
  //region Mask
  changeMasked(mask, maskInstance) {
    var _this$masked;
    if (((_this$masked = this.masked) === null || _this$masked === void 0 ? void 0 : _this$masked.type) === 'trial') {
      return;
    }
    if (mask === true || mask === '') {
      mask = '\xA0'; // empty string don't render well, so promote to &nbsp;
    }

    if (maskInstance && !maskInstance.isDestroyed) {
      if (typeof mask === 'string') {
        maskInstance.text = mask;
        mask = maskInstance;
      } else if (mask) {
        maskInstance.setConfig(mask);
        mask = maskInstance;
      } else {
        maskInstance.destroy();
      }
    } else if (mask) {
      const Mask = Widget.resolveType('mask');
      mask = Mask.mergeConfigs(this.maskDefaults, mask);
      mask.owner = this;
      mask = Mask.mask(mask);
    }
    return mask || null;
  }
  onMaskAutoClose(mask) {
    if (mask.isDestroyed && mask === this.masked) {
      this.masked = null;
    }
  }
  /**
   * Mask the widget, showing the specified message
   * @param {String|MaskConfig} msg Mask message (or a {@link Core.widget.Mask} config object
   * @returns {Core.widget.Mask}
   */
  mask(msg) {
    this.masked = msg;
    return this.masked;
  }
  /**
   * Unmask the widget
   */
  unmask() {
    this.masked = null;
  }
  //endregion
  //region Monitor resize
  onInternalResize(element, width, height, oldWidth, oldHeight) {
    this._width = element.offsetWidth;
    this._height = element.offsetHeight;
  }
  onElementResize(resizedElement, lastRect) {
    const me = this,
      {
        element
      } = me,
      oldWidth = me._width,
      oldHeight = me._height,
      newWidth = element.offsetWidth,
      newHeight = element.offsetHeight;
    // Don't do this on initial paint.
    // The show method now applies aligning as part of the show process.
    if (me.floating && lastRect) {
      me.onFloatingWidgetResize(...arguments);
    }
    if (!me.suspendResizeMonitor && (oldWidth !== newWidth || oldHeight !== newHeight)) {
      me.onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight);
      /**
       * Fired when the encapsulating element of a Widget resizes *only when {@link #config-monitorResize} is `true`*.
       * @event resize
       * @param {Core.widget.Widget} source - This Widget
       * @param {Number} width The new width
       * @param {Number} height The new height
       * @param {Number} oldWidth The old width
       * @param {Number} oldHeight The old height
       */
      me.trigger('resize', {
        width: newWidth,
        height: newHeight,
        oldWidth,
        oldHeight
      });
    }
  }
  onFloatingWidgetResize(resizedElement, lastRect, myRect) {
    const me = this,
      {
        lastAlignSpec,
        constrainTo
      } = me;
    // If this Popup changes size while we are aligned and we are aligned to
    // a target (not a position), then we might need to realign.
    if (me.isVisible && lastAlignSpec && lastAlignSpec.target) {
      const heightChange = !lastRect || myRect.height !== lastRect.height,
        widthChange = !lastRect || myRect.width !== lastRect.width,
        failsConstraint = constrainTo && !Rectangle.from(constrainTo).contains(Rectangle.from(me.element, null, true));
      // Only realign if:
      // the height has changed and we are not aligned below, or
      // the width has changed and we are not aligned to the right.
      if (heightChange && lastAlignSpec.zone !== 2 || widthChange && lastAlignSpec.zone !== 1 || failsConstraint) {
        // Must move to next AF because in Chrome, the resize monitor might fire
        // before the element is painted and the anchor color matching
        // scheme cannot work in that case.
        me.requestAnimationFrame(() => me.realign());
      }
    }
  }
  updateScale() {
    const me = this,
      element = me.element,
      parentElement = element.parentElement;
    // this could be placed elsewhere but want to keep it contained to not spam other code,
    // since this is a very specific use case in our docs
    if (!me.configuredWidth) {
      me.configuredWidth = me.width;
    }
    // We are scaling to fit inside the width, so ensure that we are not the cause of a scrollbar
    // in our current, unscaled state by hiding while we measure the parent's offsetWidth which
    // we are going to scale to.
    element.style.display = 'none';
    const rect = Rectangle.client(parentElement),
      scale = rect.width / me.configuredWidth,
      adjustedScale = me.scale = me.allowGrowWidth ? Math.min(scale, 1) : scale;
    element.style.transform = `scale(${adjustedScale})`;
    element.style.transformOrigin = 'top left';
    element.style.display = '';
    if (me.allowGrowWidth && scale > 1) {
      // increase width
      me.width = me.configuredWidth * scale;
    }
  }
  onParentElementResize(event) {
    this.updateScale();
  }
  //endregion
  /**
   * Returns a `TRBL` array of values parse from the passed specification. This can be used to parse`
   * a value list for `margin` or `padding` or `border-width` etc - any CSS value which takes a `TRBL` value.
   * @param {Number|String|String[]} values The `TRBL` value
   * @param {String} [units=px] The units to add to values which are specified as numeric.
   * @internal
   */
  parseTRBL(values, units = 'px') {
    values = values || 0;
    if (typeof values === 'number') {
      return [`${values}${units}`, `${values}${units}`, `${values}${units}`, `${values}${units}`];
    }
    const parts = values.split(' '),
      len = parts.length;
    if (len === 1) {
      parts[1] = parts[2] = parts[3] = parts[0];
    } else if (len === 2) {
      parts[2] = parts[0];
      parts[3] = parts[1];
    } else if (len === 3) {
      parts[3] = parts[1];
    }
    return [isFinite(parts[0]) ? `${parts[0]}${units}` : parts[0], isFinite(parts[1]) ? `${parts[1]}${units}` : parts[2], isFinite(parts[2]) ? `${parts[2]}${units}` : parts[3], isFinite(parts[3]) ? `${parts[3]}${units}` : parts[4]];
  }
  // Returns root node for this widget, either a document or a shadowRoot
  get documentRoot() {
    var _this$owner2;
    return ((_this$owner2 = this.owner) === null || _this$owner2 === void 0 ? void 0 : _this$owner2.documentRoot) || this.element.getRootNode();
  }
  // Returns the root from which to add global events. Prioritizes owner last.
  get eventRoot() {
    var _this$element3, _this$owner3;
    return (_this$element3 = this.element) !== null && _this$element3 !== void 0 && _this$element3.isConnected ? DomHelper.getRootElement(this.element) : ((_this$owner3 = this.owner) === null || _this$owner3 === void 0 ? void 0 : _this$owner3.eventRoot) || this._rootElement;
  }
  // Returns top most DOM element of the visible DOM tree for this widget element, either document.body or a shadowRoot
  get rootElement() {
    const me = this;
    if (!me._rootElement) {
      var _me$owner3, _me$element;
      // Find the root either from our forElement, or, if we are in the document from our element, or
      // the element we are to be rendered to.
      let root = ((_me$owner3 = me.owner) === null || _me$owner3 === void 0 ? void 0 : _me$owner3.rootElement) || DomHelper.getRootElement(me.forElement || ((_me$element = me.element) !== null && _me$element !== void 0 && _me$element.isConnected ? me.element : me.getRenderContext()[0] || me.element));
      if (!root) {
        root = document.body;
      }
      me._rootElement = root;
    }
    return me._rootElement;
  }
  get floatRoot() {
    const me = this,
      {
        rootElement
      } = me;
    let {
      floatRoot
    } = rootElement;
    if (!floatRoot) {
      var _DomHelper$getThemeIn;
      const {
          outerCls
        } = Widget,
        themeName = (_DomHelper$getThemeIn = DomHelper.getThemeInfo(null, rootElement)) === null || _DomHelper$getThemeIn === void 0 ? void 0 : _DomHelper$getThemeIn.name;
      if (!DomHelper.isValidFloatRootParent(rootElement)) {
        throw new Error('Attaching float root to wrong root');
      }
      // When outside our examples, the body element doesn't get the theme class.
      // The floatRoot must carry it for floating items to be themed.
      if (themeName) {
        outerCls.push(`b-theme-${themeName.toLowerCase()}`);
      }
      floatRoot = rootElement.floatRoot = DomHelper.createElement({
        className: `b-float-root ${outerCls.join(' ')}`,
        parent: rootElement
      });
      floatRoots.push(floatRoot);
      // Make float root immune to keyboard-caused size changes
      if (BrowserHelper.isAndroid) {
        floatRoot.style.height = `${screen.height}px`;
        EventHelper.on({
          element: globalThis,
          orientationchange: () => floatRoot.style.height = `${screen.height}px`,
          thisObj: this
        });
      }
      // Keep floatRoot up to date with the theme
      GlobalEvents.ion({
        theme: ({
          theme,
          prev
        }) => {
          floatRoot.classList.add(`b-theme-${theme.toLowerCase()}`);
          floatRoot.classList.remove(`b-theme-${prev.toLowerCase()}`);
        }
      });
    }
    // Angular might shuffle elements around so we have to ensure floatRoot is a child of the right parent
    else if (!rootElement.contains(floatRoot)) {
      // Reattach floatRoot if it was detached
      rootElement.appendChild(floatRoot);
    }
    return floatRoot;
  }
  get floatRootMaxZIndex() {
    let max = 1;
    Array.from(this.floatRoot.children).forEach(child => {
      const zIndex = parseInt(getComputedStyle(child).zIndex || 0, 10);
      if (zIndex > max) {
        max = zIndex;
      }
    });
    return max;
  }
  static resetFloatRootScroll() {
    floatRoots.forEach(floatRoot => floatRoot.scrollTop = floatRoot.scrollLeft = 0);
  }
  static get floatRoots() {
    return floatRoots;
  }
  static removeFloatRoot(floatRoot) {
    floatRoots.splice(floatRoots.indexOf(floatRoot), 1);
  }
  // CSS classes describing outer-most Widgets to provide styling / behavioral CSS style rules
  static get outerCls() {
    const result = ['b-outer'],
      {
        platform
      } = BrowserHelper;
    if (platform) {
      result.push(`b-${platform}`);
    }
    if (BrowserHelper.isTouchDevice) {
      result.push('b-touch-events');
    }
    if (BrowserHelper.isMobile) {
      result.push('b-mobile');
    }
    if (DomHelper.scrollBarWidth) {
      result.push('b-visible-scrollbar');
    } else {
      result.push('b-overlay-scrollbar');
    }
    if (BrowserHelper.isChrome) {
      result.push('b-chrome');
    } else if (BrowserHelper.isSafari) {
      result.push('b-safari');
    } else if (BrowserHelper.isFirefox) {
      result.push('b-firefox');
    }
    // Allow space-saving CSS to be activated
    if (BrowserHelper.isPhone) {
      result.push('b-phone');
    }
    // So that we don't get the polyfill styles applied if we have ResizeMonitor available.
    // The polyfill styles can break certain elements styling.
    if (!globalThis.ResizeObserver) {
      result.push('b-no-resizeobserver');
    }
    return result;
  }
  get isAnimating() {
    return this._isAnimatingCounter > 0;
  }
  set isAnimating(value) {
    const me = this,
      {
        _isAnimatingCounter
      } = me;
    // Ensure flag is correct when code called by listeners interrogates it
    me._isAnimatingCounter = Math.max(0, _isAnimatingCounter + (value ? 1 : -1));
    if (_isAnimatingCounter === 0 && value) {
      me.element.classList.add('b-animating');
      me.trigger('animationStart');
    } else if (_isAnimatingCounter === 1 && !value) {
      me.element.classList.remove('b-animating');
      me.trigger('animationEnd');
    }
  }
  // Waits until all transitions are completed
  async waitForAnimations() {
    if (this.isAnimating) {
      await this.await('animationend', {
        checkLog: false
      });
    }
  }
  /**
   * Analogous to `document.querySelector`, finds the first Bryntum widget matching the passed
   * selector. Right now, only class name (lowercased) selector strings, or
   * a filter function which returns `true` for required object are allowed:
   *
   * ```javascript
   * Widget.query('grid').destroy();
   * ```
   *
   * @param {String|Function} selector A lowercased class name, or a filter function.
   * @param {Boolean} [deep] Specify `true` to search the prototype chain (requires supplying a string `selector`). For
   * example 'widget' would then find a Grid
   * @returns {Core.widget.Widget} The first matched widget if any.
   * @category Widget hierarchy
   */
  static query(selector, deep = false) {
    const {
      idMap
    } = Widget.identifiable;
    for (const id in idMap) {
      if (Widget.widgetMatches(idMap[id], selector, deep)) {
        return idMap[id];
      }
    }
    return null;
  }
  /**
   * Analogous to document.querySelectorAll, finds all Bryntum widgets matching the passed
   * selector. Right now, only registered widget `type` strings, or a filter function which
   * returns `true` for required object are allowed:
   *
   * ```javascript
   * let allFields = Widget.queryAll('field', true);
   * ```
   *
   * @param {String|Function} selector A lowercased class name, or a filter function.
   * @param {Boolean} [deep] Specify `true` to search the prototype chain (requires supplying a string `selector`). For
   * example 'widget' would then find a Grid
   * @returns {Core.widget.Widget[]} The first matched widgets if any - an empty array will be returned
   * if no matches are found.
   * @category Widget hierarchy
   */
  static queryAll(selector, deep = false) {
    const {
        idMap
      } = Widget.identifiable,
      result = [];
    for (const id in idMap) {
      if (Widget.widgetMatches(idMap[id], selector, deep)) {
        result.push(idMap[id]);
      }
    }
    return result;
  }
  /**
   * Returns the Widget which owns the passed element (or event).
   * @param {HTMLElement|Event} element The element or event to start from
   * @param {String|Function} [type] The type of Widget to scan upwards for. The lowercase
   * class name. Or a filter function which returns `true` for the required Widget
   * @param {HTMLElement|Number} [limit] The number of components to traverse upwards to find a
   * match of the type parameter, or the element to stop at
   * @returns {Core.widget.Widget|null} The found Widget or null
   * @category Misc
   */
  static fromElement(element, type, limit) {
    const typeOfType = typeof type;
    // Check if an event was passed
    if (element && !element.nodeType) {
      element = element.target;
    }
    if (typeOfType === 'number' || type && type.nodeType === Element.ELEMENT_NODE) {
      limit = type;
      type = null;
    }
    let target = element,
      depth = 0,
      topmost,
      cmpId,
      cmp;
    if (typeof limit !== 'number') {
      topmost = limit;
      limit = Number.MAX_VALUE;
    }
    if (typeOfType === 'string') {
      type = type.toLowerCase();
    }
    while (target && target.nodeType === Element.ELEMENT_NODE && depth < limit && target !== topmost) {
      cmpId = target.dataset && target.dataset.ownerCmp || target.id;
      if (cmpId) {
        cmp = Widget.getById(cmpId);
        if (cmp) {
          if (type) {
            if (typeOfType === 'function') {
              if (type(cmp)) {
                return cmp;
              }
            } else if (Widget.widgetMatches(cmp, type, true)) {
              return cmp;
            }
          } else {
            return cmp;
          }
        }
        // Increment depth on every *Widget* found
        depth++;
      }
      target = target.parentNode;
    }
    return null;
  }
  /**
   * Returns the Widget which owns the passed CSS selector.
   *
   * ```javascript
   * const button = Widget.fromSelector('#my-button');
   * ```
   *
   * @param {String} selector CSS selector
   * @returns {Core.widget.Widget|null} The found Widget or null
   * @category Misc
   */
  static fromSelector(selector) {
    const element = document.querySelector(selector);
    return element ? Widget.fromElement(element) : null;
  }
  // NOTE: Not named `triggerChange` to not conflict with existing fn on Field
  /**
   * Triggers a 'change' event with the supplied params. After triggering it also calls `onFieldChange()` on each
   * ancestor the implements that function, supplying the same set of params.
   * @param {Object} params Event params, used both for triggering and notifying ancestors
   * @param {Boolean} [trigger] `false` to not trigger, only notifying ancestors
   * @internal
   */
  triggerFieldChange(params, trigger = true) {
    var _this$eachAncestor;
    if (trigger) {
      this.trigger('change', params);
    }
    (_this$eachAncestor = this.eachAncestor) === null || _this$eachAncestor === void 0 ? void 0 : _this$eachAncestor.call(this, ancestor => {
      var _ancestor$onFieldChan, _ancestor$isolateFiel;
      (_ancestor$onFieldChan = ancestor.onFieldChange) === null || _ancestor$onFieldChan === void 0 ? void 0 : _ancestor$onFieldChan.call(ancestor, params);
      // Stop going up when reaching an ancestor that isolates its fields
      if ((_ancestor$isolateFiel = ancestor.isolateFieldChange) !== null && _ancestor$isolateFiel !== void 0 && _ancestor$isolateFiel.call(ancestor, this)) {
        return false;
      }
    });
  }
  /**
   * Returns `true` if the given `field`'s value change should be isolated (kept hidden by this widget). By default,
   * this method returns the value of {@link Core.widget.Container#config-isolateFields} for all fields.
   * @param {Core.widget.Field} field The field in question.
   * @internal
   */
  isolateFieldChange(field) {
    return this.isolateFields;
  }
  // Sets up the focus listeners, one set for every document root (shadow root or document)
  setupFocusListeners() {
    // Listen to focus events on shadow root to handle focus inside the shadow dom
    GlobalEvents.setupFocusListenersOnce(this.eventRoot, EventHelper);
  }
  static widgetMatches(candidate, selector, deep) {
    if (selector === '*') {
      return true;
    }
    if (typeof selector === 'function') {
      return selector(candidate);
    }
    return Widget.isType(candidate, selector, deep);
  }
  /**
   * Attached a tooltip to the specified element.
   * @example
   * Widget.attachTooltip(element, {
   *   text: 'Useful information goes here'
   * });
   * @param {HTMLElement} element Element to attach tooltip for
   * @param {TooltipConfig|String} configOrText Tooltip config or tooltip string, see example and source
   * @returns {HTMLElement} The passed element
   * @category Misc
   */
  static attachTooltip(element, configOrText) {
    if (typeof configOrText === 'string') configOrText = {
      html: configOrText
    };
    Widget.create(Object.assign({
      forElement: element
    }, configOrText), 'tooltip');
    return element;
  }
  //region RTL
  // Since we use flexbox docking flips correctly out of the box. start and end values can be mapped straight to
  // left and right, for both LTR and RTL
  changeDock(dock) {
    if (dock === 'start') {
      return 'left';
    }
    if (dock === 'end') {
      return 'right';
    }
    return dock;
  }
  updateRtl(rtl) {
    super.updateRtl(rtl);
    // Cascade the rtl setting to owned widgets which are not configured with an rtl value
    this.eachWidget(item => {
      if (!('rtl' in item.initialConfig)) {
        item.rtl = rtl;
      }
    });
  }
  //endregion
}

const proto = Widget.prototype;
['compose', 'domSyncCallback'].forEach(fn => proto[fn].$nullFn = true);
// Register this widget type with its Factory
Widget.initClass();
Widget.register('mask', Mask);
// These low level classes must not import Widget because that would cause circularity.
// Instead Widget injects a reference to itself into them.
DomHelper.Widget = Widget;
GlobalEvents.Widget = Widget;
// We use the same map to track instances by ID
Mask.identifiable.idMap = Widget.identifiable.idMap;
// Simplify querying widgets by exposing methods to bryntum namespace
Object.assign(globalThis.bryntum || (globalThis.bryntum = {}), {
  get: Widget.getById.bind(Widget),
  query: Widget.query,
  queryAll: Widget.queryAll,
  fromElement: Widget.fromElement,
  fromSelector: Widget.fromSelector
});
Widget._$name = 'Widget';

/**
 * @module Core/widget/layout/Layout
 */
/**
  * A helper class used by {@link Core.widget.Container}s which renders child widgets to their
  * {@link Core.widget.Widget#property-contentElement}. It also adds the Container's
  * {@link Core.widget.Container#config-itemCls} class to child items.
  *
  * Subclasses may modify the way child widgets are rendered, or may offer APIs for manipulating the child widgets.
  *
  * The {@link Core.widget.layout.Card} layout class offers slide-in, slide-out animation of multiple
  * child widgets. {@link Core.widget.TabPanel} uses Card layout.
  * @layout
  * @classtype default
  */
class Layout extends Base.mixin(Events, Factoryable) {
  static type = 'default';
  static configurable = {
    /**
     * The owning Widget.
     * @member {Core.widget.Widget} owner
     * @readonly
     */
    /**
     * @config {Core.widget.Widget} owner
     * @private
     */
    owner: null,
    /**
     * The CSS class which should be added to the owning {@link Core.widget.Container}'s.
     * {@link Core.widget.Widget#property-contentElement}.
     * @config {String}
     */
    containerCls: 'b-auto-container',
    /**
     * The CSS class which should be added to the encapsulating element of child items.
     * @config {String}
     */
    itemCls: null
  };
  // establish this class as the Factoryable base
  static factoryable = {
    defaultType: 'default'
  };
  get contentElement() {
    var _this$owner;
    return (_this$owner = this.owner) === null || _this$owner === void 0 ? void 0 : _this$owner.contentElement;
  }
  onChildAdd(item) {}
  onChildRemove(item) {}
  renderChildren() {
    const me = this,
      {
        owner,
        itemCls
      } = me,
      {
        contentElement,
        items
      } = owner,
      ownerItemCls = owner.itemCls,
      itemCount = items === null || items === void 0 ? void 0 : items.length;
    // Need to check that container has widgets, for example TabPanel can have no tabs
    if (itemCount) {
      owner.textContent = false;
      for (let i = 0; i < itemCount; i++) {
        const item = items[i],
          {
            element
          } = item,
          {
            classList
          } = element;
        element.dataset.itemIndex = i;
        // If instantiated by the app developer, external to Container#createWidget
        // a widget will have the b-outer class. Remove that if it's contained.
        if (classList.contains('b-outer')) {
          classList.remove(...Widget.outerCls);
        }
        if (itemCls) {
          classList.add(itemCls);
        }
        if (ownerItemCls) {
          classList.add(ownerItemCls);
        }
        // Only trigger paint if the owner is itself painted, otherwise
        // the outermost Container will cascade the paint signal down.
        item.render(contentElement, Boolean(owner.isPainted));
      }
    }
    me.syncPendingConfigs();
    me.syncChildCount();
  }
  removeChild(child) {
    const me = this,
      {
        element
      } = child,
      {
        owner,
        itemCls
      } = me,
      {
        contentElement
      } = owner,
      ownerItemCls = owner.itemCls;
    // Chrome has turned very fussy recently.
    // If the parent does not contain the child to be removed, it throws.
    if (contentElement.contains(element)) {
      element.remove();
    }
    delete element.dataset.itemIndex;
    if (itemCls) {
      element.classList.remove(itemCls);
    }
    if (ownerItemCls) {
      element.classList.remove(ownerItemCls);
    }
    me.fixChildIndices();
    me.syncChildCount();
  }
  appendChild(child) {
    const {
        element
      } = child,
      {
        owner,
        itemCls
      } = this,
      {
        contentElement
      } = owner,
      ownerItemCls = owner.itemCls;
    element.dataset.itemIndex = owner.indexOfChild(child);
    owner.textContent = false;
    if (itemCls) {
      element.classList.add(itemCls);
    }
    if (ownerItemCls) {
      element.classList.add(ownerItemCls);
    }
    child.render(contentElement, Boolean(owner.isPainted));
    this.syncChildCount();
  }
  insertChild(toAdd, childIndex) {
    const me = this,
      {
        element
      } = toAdd,
      {
        owner,
        itemCls
      } = me,
      {
        contentElement
      } = owner,
      nextSibling = DomHelper.getChild(contentElement, `[data-item-index="${childIndex}"]`),
      ownerItemCls = owner.itemCls;
    owner.textContent = false;
    if (itemCls) {
      element.classList.add(itemCls);
    }
    if (ownerItemCls) {
      element.classList.add(ownerItemCls);
    }
    contentElement.insertBefore(element, nextSibling);
    toAdd.render(null, Boolean(owner.isPainted));
    me.fixChildIndices();
    me.syncChildCount();
  }
  fixChildIndices() {
    this.owner.items.forEach((child, index) => {
      child.element.dataset.itemIndex = index;
    });
  }
  syncChildCount() {
    var _owner$contentElement;
    const {
        owner
      } = this,
      {
        length
      } = owner.items;
    // Special CSS conditions may apply if there's only a single child.
    (_owner$contentElement = owner.contentElement) === null || _owner$contentElement === void 0 ? void 0 : _owner$contentElement.classList[length === 1 ? 'add' : 'remove']('b-single-child');
  }
  /**
   * Registers a layout `config` property that cannot be acted upon at this time but must wait for the `owner` to
   * fully render its elements (in particular the `contentElement`).
   * @param {String} config The name of the config to sync later.
   * @internal
   */
  syncConfigLater(config) {
    const pendingConfigs = this.pendingConfigs || (this.pendingConfigs = []);
    if (!pendingConfigs.includes(config)) {
      pendingConfigs.push(config);
    }
  }
  /**
   * Sets the specified `style` to the value of the config given its `name`.
   * @param {Object} options The name of the config with the value to apply to the given `style`.
   * @param {String} options.name The name of the config with the value to apply to the given `style`.
   * @param {String} options.style The style property to set on the `contentElement`.
   * @param {String[]} [options.classes] A list of config values that should be added as CSS classes.
   * @param {Object} [options.map] An mapping object to convert the config's value to the `style` value.
   * @internal
   */
  syncConfigStyle({
    name,
    style,
    classes,
    map
  }) {
    const me = this,
      baseCls = `b-box-${name}-`,
      // ex: 'b-box-justify-'
      {
        contentElement
      } = me,
      raw = me[name];
    let value = (map === null || map === void 0 ? void 0 : map[raw]) || raw;
    if (contentElement) {
      if (classes) {
        const {
          classList
        } = contentElement;
        classes.forEach(c => {
          if (c !== value) {
            classList.remove(baseCls + c);
          }
        });
        if (classes.includes(value)) {
          classList.add(baseCls + value);
          value = ''; // to remove the inline style
        }
      }

      contentElement.style[style] = value;
    } else {
      me.syncConfigLater(name);
    }
  }
  syncPendingConfigs() {
    const me = this,
      {
        pendingConfigs
      } = me;
    let name;
    if (pendingConfigs) {
      me.pendingConfigs = null;
      while (name /* assignment */ = pendingConfigs.pop()) {
        me[me.$meta.configs[name].updater](me[name]);
      }
    }
  }
}
Layout.initClass();
Layout._$name = 'Layout';

let lastTouchTime = 0;
const hasRipple = w => w.ripple;
class Ripple extends Widget {
  static get defaultConfig() {
    return {
      old_element: {
        children: [{
          className: 'b-ripple-inner',
          reference: 'rippleElement'
        }]
      },
      element: {
        children: [{
          tag: 'svg',
          class: 'b-ripple-inner',
          reference: 'rippleElement',
          ns: 'http://www.w3.org/2000/svg',
          version: '1.1',
          viewBox: '0 0 100 100',
          children: [{
            reference: 'circleElement',
            tag: 'circle',
            cx: '0',
            cy: '0',
            r: 10
          }]
        }]
      },
      floating: true,
      hideAnimation: false,
      showAnimation: false,
      scrollAction: 'realign',
      color: 'rgba(0,0,0,.3)',
      startRadius: 10,
      radius: 100
    };
  }
  static get $name() {
    return 'Ripple';
  }
  afterConstruct() {
    super.afterConstruct();
    EventHelper.on({
      element: this.rootElement,
      mousedown: 'onRippleControllingEvent',
      thisObj: this,
      capture: true,
      once: true
    });
  }
  onRippleControllingEvent(event) {
    var _me$listenerDetacher;
    const me = this;
    me.show();
    const rippleAnimation = DomHelper.getStyleValue(me.circleElement, 'animationName');
    me.hide();
    (_me$listenerDetacher = me.listenerDetacher) === null || _me$listenerDetacher === void 0 ? void 0 : _me$listenerDetacher.call(me);
    // If our theme supports ripples, add our listeners
    if (rippleAnimation && rippleAnimation !== 'none') {
      me.listenerDetacher = EventHelper.on({
        // Trap all mousedowns and see if the encapsulating Component is configured to ripple
        mousedown: {
          element: me.rootElement,
          capture: true,
          handler: 'onMousedown'
        },
        touchstart: {
          element: me.rootElement,
          capture: true,
          handler: 'onTouchStart'
        },
        // Hide at the end of the ripple
        animationend: {
          element: me.circleElement,
          handler: 'onAnimationEnd'
        },
        thisObj: me
      });
      // If this is the first mousedown, start listening to theme changes and trigger ripple manually
      if (event.type === 'mousedown') {
        me.onMousedown(event);
        GlobalEvents.ion({
          theme: 'onRippleControllingEvent',
          thisObj: this
        });
      }
    }
  }
  onTouchStart(event) {
    lastTouchTime = performance.now();
    this.handleTriggerEvent(event);
  }
  onMousedown(event) {
    // We need to prevent a touchend->mousedown simulated mousedown from triggering a ripple.
    // https://developer.mozilla.org/en-US/docs/Web/API/Touch_events/Supporting_both_TouchEvent_and_MouseEvent
    if (performance.now() - lastTouchTime > 200) {
      this.handleTriggerEvent(event);
    }
  }
  handleTriggerEvent(event) {
    const targetWidget = Widget.fromElement(event.target, hasRipple);
    if (targetWidget) {
      const rippleCfg = targetWidget.ripple,
        target = rippleCfg.delegate ? event.target.closest(rippleCfg.delegate) : targetWidget.focusElement || targetWidget.element;
      if (target) {
        const ripple = ObjectHelper.assign({
          event,
          target,
          radius: this.radius
        }, rippleCfg);
        // The clip option is specified as a string property name or delegate
        if (typeof ripple.clip === 'string') {
          ripple.clip = targetWidget[ripple.clip] || event.target.closest(ripple.clip);
          // Not inside an instance of the clip delegate, then no ripple
          if (!ripple.clip) {
            return;
          }
        }
        this.ripple(ripple);
      }
    }
  }
  ripple({
    event,
    point = EventHelper.getClientPoint(event),
    target = event.target,
    clip = target,
    radius = this.radius,
    color = this.color
  }) {
    this.clip = clip;
    clip = Rectangle.from(clip, null, true);
    const me = this,
      centreDelta = clip.getDelta(point),
      rippleStyle = me.rippleElement.style,
      circleElement = me.circleElement,
      borderRadius = DomHelper.getStyleValue(target, 'border-radius');
    me.hide();
    rippleStyle.transform = `translateX(${centreDelta[0]}px) translateY(${centreDelta[1]}px)`;
    rippleStyle.height = rippleStyle.width = `${radius}px`;
    me.element.style.borderRadius = borderRadius;
    circleElement.setAttribute('r', radius);
    circleElement.setAttribute('fill', color);
    // Show aligned center to center with our clipping region.
    me.showBy({
      target: clip,
      align: 'c-c',
      matchSize: true
    });
  }
  // When fully expanded, it's all over.
  onAnimationEnd(event) {
    if (event.animationName === 'b-ripple-expand') {
      this.hide();
    }
  }
}
Widget.RippleClass = Ripple;
Ripple._$name = 'Ripple';

/**
 * @module Core/widget/Container
 */
const emptyObject$3 = Object.freeze({}),
  {
    isArray
  } = Array,
  returnWeight = i => i.weight,
  // Allowing string weights (used by subgrids for backwards compatibility)
  sortByWeight = ({
    weight: a
  }, {
    weight: b
  }) => {
    if (typeof a === 'string' || typeof b === 'string') {
      return String(a).localeCompare(String(b));
    }
    // Items without weight sort last
    return (a ?? Number.MAX_SAFE_INTEGER) - (b ?? Number.MAX_SAFE_INTEGER);
  },
  isNotHidden = w => w && !w.hidden,
  stylesToCheck = ['display', 'flex-direction'],
  boxLayouts = {
    default: 1,
    box: 1
  };
/**
 * Widget that can contain other widgets. Layout is flexbox by default, see the {@link #config-layout} config.
 *
 * ```javascript
 * // create a container with two widgets
 * let container = new Container({
 *     items : {
 *         name  : { type : 'textfield', label : 'Name' },
 *         score : { type : 'numberfield', label : 'Score' }
 *     }
 * });
 * ```
 *
 * Containers can have child widgets added, or removed during their lifecycle to accommodate business needs.
 *
 * For example:
 *
 *  ```javascript
 *  myTaskPopup.on({
 *      beforeShow() {
 *          if (task.type === task.MASTER) {
 *              // Insert the childTask multiselect before the masterTask field
 *              myPopup.insert(childTaskMultiselect, masterTaskField)
 *
 *              // We don't need this for master tasks
 *              myPopup.remove(masterTaskField);
 *          }
 *          else {
 *              // Insert the masterTask combo before the childTask multiselect
 *              myPopup.insert(masterTaskField, childTaskMultiselect)
 *
 *              // We don't need this for child tasks
 *              myPopup.remove(childTaskMultiselect);
 *          }
 *      }
 *  });
 * ```
 *
 * @extends Core/widget/Widget
 * @classType container
 * @inlineexample Core/widget/Container.js
 * @widget
 */
class Container extends Widget {
  static get $name() {
    return 'Container';
  }
  // Factoryable type name
  static get type() {
    return 'container';
  }
  static get configurable() {
    return {
      /**
       * An object containing typed child widget config objects or Widgets. May also be specified
       * as an array.
       *
       * If configured as an Object, the property names are used as the child component's
       * {@link Core.widget.Widget#config-ref} name, and the value is the child component's config object.
       *
       * ```javascript
       *
       *  class MyContainer extends Container {
       *      static get configurable() {
       *          return {
       *              items : {
       *                  details : {
       *                      type : 'panel',
       *                      ....
       *                  },
       *                  button : {
       *                      type : 'button',
       *                      text : 'Save'
       *                  }
       *              }
       *          }
       *      }
       *  }
       *
       *  new MyContainer({
       *      title    : 'Test Container',
       *      floating : true,
       *      centered : true,
       *      width    : 600,
       *      height   : 400,
       *      layout   : 'fit',
       *      items    : {
       *          button : {
       *              disabled : true
       *          },
       *          details : {
       *              title : 'More coolness',
       *              html  : 'Details content'
       *          }
       *      }
       *  }).show();
       * ```
       *
       * The order of the child widgets is determined by the order they are defined in `items`, but can also be
       * affected by configuring a {@link Core.widget.Widget#config-weight} on one or more widgets.
       *
       * To remove existing items, set corresponding keys to `null`.
       *
       * If you want to customize child items of an existing class, you can do this using the child widget
       * 'ref' identifier (useful for reconfiguring Event Editor in Scheduler / Gantt):
       *
       * ```javascript
       *  new MyCustomTabPanel({
       *      items    : {
       *          // Reconfigure tabs
       *          firstTab : {
       *              title : 'My custom title'
       *          },
       *          secretTab : null // hide this tab
       *      }
       *  }).show();
       * ```
       *
       * @config {Object<String,ContainerItemConfig|Boolean|null>|ContainerItemConfig[]|Core.widget.Widget[]}
       * @category Content
       */
      items: null,
      /**
       * An array of {@link #config-items child item} _config objects_ which is to be converted into
       * instances only when this Container is rendered, rather than eagerly at construct time.
       *
       * _This is mutually exclusive with the {@link #config-items} config._
       *
       * @config {Object<String,ContainerItemConfig>|ContainerItemConfig[]|Core.widget.Widget[]}
       * @category Content
       */
      lazyItems: {
        $config: ['lazy'],
        value: null
      },
      /**
       * A config object containing default settings to apply to all child widgets.
       * @config {Object}
       * @category Content
       */
      defaults: null,
      defaultType: 'widget',
      /**
       * The CSS style properties to apply to the {@link Core.widget.Widget#property-contentElement}.
       *
       * By default, a Container's {@link Core.widget.Widget#property-contentElement} uses flexbox layout, so this
       * config may contain the following properties:
       *
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction">flexDirection</a> default '`row`'
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex-wrap">flexWrap</a>
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex-flow">flexFlow</a>
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content">justifyContent</a>
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/align-items">alignItems</a>
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/align-content">alignContent</a>
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/place-content">placeContent</a>
       * @prp {Object}
       * @category Layout
       */
      layoutStyle: null,
      /**
       * An optional CSS class to add to child items of this container.
       * @config {String}
       * @category CSS
       */
      itemCls: null,
      /**
       * The {@link #config-layout} as an instance of {@link Core.widget.layout.Layout}.
       * This is a helper class which adds and removes child widgets to this Container's
       * DOM and applies CSS classes based upon its requirements.
       *
       * The {@link Core.widget.layout.Card card} layout provides for showing one child
       * widget at a time, and provides a switching API to change which child widget is
       * currently active.
       * @member {Core.widget.layout.Layout} layout
       * @category Layout
       */
      /**
       * The short name of a helper class which manages rendering and styling of child items.
       *
       * Or a config object which includes a `type` property which specifies which type
       * of layout to use, and how to configure that layout.
       *
       * By default, the only special processing that is applied is that the Container class's
       * {@link #config-itemCls} is added to child items.
       *
       * Containers use CSS flexbox in its default configuration to arrange child items. You may either use the
       * {@link #config-layoutStyle} configuration to tune how child items are layed out, or use one of the built
       * in helper classes which include:
       *
       *  - `fit` A single child item is displayed fitting exactly into the
       *  {@link Core.widget.Widget#property-contentElement}.
       *  - `card` Child items are displayed one at a time, size to fit the
       *  {@link Core.widget.Widget#property-contentElement} and are slid in from the side when activated.
       *  - `box` Child items are layed out using flexbox.
       *
       * For example:
       * ```javascript
       * {
       *     id     : 'myContainer',
       *     // Our child items flow downwards and are stretched to fill our width
       *     layout : {
       *         type       : 'box',
       *         direction  : 'column'
       *         align      : 'stretch'
       *     }
       * }
       * @config {String|ContainerLayoutConfig}
       * @category Layout
       */
      layout: {
        type: 'default'
      },
      /**
       * An object containing named config objects which may be referenced by name in any {@link #config-items}
       * object. For example, a specialized {@link Core.widget.Menu Menu} subclass may have a `namedItems` default
       * value defined like this:
       *
       * ```javascript
       *  namedItems : {
       *      removeRow : {
       *          text : 'Remove row',
       *          onItem() {
       *              this.ownerGrid.remove(this.ownerGrid.selectedRecord);
       *          }
       *      }
       *  }
       * ```
       *
       * Then whenever that subclass is instantiated and configured with an {@link #config-items} object, the
       * items may be configured like this:
       *
       * ```javascript
       *  items : {
       *      removeRow : true,   // The referenced namedItem will be applied to this
       *      otherItemRef : {
       *          text : 'Option 2',
       *          onItem() {
       *          }
       *      }
       * }
       * ```
       * @config {Object<string,ContainerItemConfig>}
       * @category Content
       */
      namedItems: null,
      /**
       * When set to `true`, this widget is considered as a whole when processing {@link Core.widget.Toolbar}
       * overflow. When `false`, this widget's child items are considered instead.
       *
       * When set to the string `'none'`, this widget is ignored by overflow processing. This option should be
       * used with caution as it prevents the overflow algorithm from moving such widgets into the overflow
       * popup which may result in not clearing enough space to avoid overflowing the toolbar.
       * @config {Boolean|String}
       * @default false
       * @category Layout
       * @internal
       */
      overflowable: {
        value: null,
        default: false,
        $config: null
      },
      /**
       * Specify `true` for a container used to show text markup. It will apply the CSS class `b-text-content`
       * which specifies a default max-width that makes long text more readable.
       *
       * This CSS class is automatically removed if the container adds/defines child Widgets.
       * @config {Boolean}
       * @default
       * @category Content
       */
      textContent: true,
      /**
       * {@link Core.data.Model Record} whose values will be used to populate fields in the container.
       *
       * Any descendant widgets of this Container with a `name` property (or a `ref` if no name is configured)
       * will have its value set to the value of that named property of the record.
       *
       * If no record is passed, the widget has its value set to `null`.
       *
       * To strictly match by the `name` property, configure {@link #config-strictRecordMapping} as `true`.
       *
       * @prp {Core.data.Model}
       * @category Record
       */
      record: null,
      /**
       * Specify `true` to match fields by their `name` property only when assigning a {@link #config-record},
       * without falling back to `ref`.
       *
       * @prp {Boolean}
       * @default false
       * @category Record
       */
      strictRecordMapping: null,
      /**
       * Update assigned {@link #config-record} automatically on field changes
       * @config {Boolean}
       * @category Record
       */
      autoUpdateRecord: null,
      /**
       * Update fields if the {@link #config-record} changes
       * @config {Boolean}
       * @internal
       */
      autoUpdateFields: null,
      /**
       * Specify `true` to make this container hide when it has no visible children (Either empty
       * or all children hidden).
       *
       * Container will show itself when there are visible children, ie: hidden children are
       * shown, or new visible children are added.
       * @config {Boolean}
       * @default
       * @category Layout
       */
      hideWhenEmpty: null,
      contentElMutationObserver: {
        $config: ['lazy', 'nullify'],
        value: true
      },
      /**
       * Specify `true` to isolate record changes to this container and its ancestors. Prevents record updates
       * from propagating up from here and also prevents record updates from parent from propagating down to us.
       *
       * @config {Boolean}
       * @default false
       * @internal
       */
      isolateFields: false,
      /**
       * Can be set to `true` to make a focus of a focusable encapsulating element relay focus down into a
       * focusable child. This is normally `false` to allow mousedown to begin text selection in Popups.
       * @internal
       */
      focusDescendant: false,
      // Our own setValues/getValues system should not set/get HTML content
      defaultBindProperty: null,
      /**
       * A {@link #function-query} selector function which can identify the descendant widget to which
       * focus should be directed by default.
       *
       * By default, the first focusable descendant widget is chosen. This may direct focus to a different
       * widget:
       *
       * ```javascript
       *     new Popup({
       *         title        : 'Details',
       *         width        : '25em',
       *         centered     : true,
       *         modal        : true,
       *
       *         // Focus goes straight to OK button in the bottom toolbar on show
       *         defaultFocus : w => w.ref ==='okButton',
       *         items        : {
       *             nameField : {
       *                 type  : 'textfield',
       *                 label : 'Name'
       *             },
       *             ageField  : {
       *                 type  : 'numberfield',
       *                 label : 'Name'
       *             }
       *         },
       *         bbar     : {
       *             items : {
       *                 okButton : {
       *                     text    : 'OK',
       *                     handler : okFunction
       *                 },
       *                 cncelButton : {
       *                     text    : 'Cancel',
       *                     handler : cancelFunction
       *                 }
       *             }
       *         }
       *     }).show();
       * ```
       * @config {Function}
       */
      defaultFocus: null
    };
  }
  static get prototypeProperties() {
    return {
      // These classes have opinions about how fields should fill the space, so allow them to be replaced by the
      // less opinionated b-hbox/b-vbox classes when that is not desired. Using ":not(.b-toolbar-content)" in
      // the CSS does not scale now that FieldSet wants similar treatment... adding more ":not()"s is not only a
      // messy approach, it increases the selector specificity and causes interference with other selectors (e.g.
      // TimePicker's number field rules).
      flexRowCls: 'b-flex-row',
      flexColCls: 'b-flex-column',
      /**
       * @member {Boolean} initialItems
       * This property is `true` until the container's initial `items` config has been processed. This property
       * is set to `false` by the `updateItems` method.
       * @readonly
       * @internal
       */
      initialItems: true
    };
  }
  startConfigure(config) {
    // Set a flag so that code can test for presence of items.
    // Widgets which render child widgets outside of the Container scheme
    // can set this flag (eg Panels with tools and tbar).
    const items = config.items || config.lazyItems;
    if (!(this.hasItems = Boolean(items && (isArray(items) ? items : Object.keys(items)).length))) {
      this.initialItems = false; // we won't be running updateItems, so clear this flag now
    }

    super.startConfigure(config);
  }
  /**
   * Returns the first widget in this Container.
   * @property {Core.widget.Widget}
   * @readonly
   */
  get firstItem() {
    return this.getAt(0);
  }
  /**
   * Returns the last widget in this Container.
   * @property {Core.widget.Widget}
   * @readonly
   */
  get lastItem() {
    return this.getAt(-1);
  }
  /**
   * Returns the widget at the specified `index` in this Container.
   * @param {Number} index The index of the widget to return. Negative numbers index for the last item. For example,
   * `index = -1` returns the last matching item, -2 the 2nd to last matching item etc..
   * @returns {Core.widget.Widget} The requested widget.
   */
  getAt(index) {
    return this.ensureItems().at(index);
  }
  /**
   * Removes the passed child/children from this Container.
   * @param  {...Core.widget.Widget} toRemove The child or children to remove.
   * @returns {Core.widget.Widget|Core.widget.Widget[]} All the removed items. An array if multiple items
   * were removed, otherwise, just the item removed.
   */
  remove(...toRemove) {
    let returnArray = true;
    if (toRemove.length === 1) {
      if (isArray(toRemove[0])) {
        toRemove = toRemove[0];
      } else {
        returnArray = false;
      }
    }
    const me = this,
      {
        _items
      } = me,
      result = [];
    for (let i = 0; i < toRemove.length; i++) {
      const childToRemove = toRemove[i];
      if (_items.includes(childToRemove)) {
        _items.remove(childToRemove);
        me.layout.removeChild(childToRemove);
        result.push(childToRemove);
        me.onChildRemove(childToRemove);
      }
    }
    return returnArray ? result : result[0];
  }
  /**
   * Removes all children from this Container.
   * @returns {Core.widget.Widget[]} All the removed items.
   */
  removeAll() {
    return this.remove(this.items);
  }
  /**
   * Appends the passed widget / widgets or config(s) describing widgets to this Container.
   *
   * If the widgets specify a `weight`, they are inserted at the correct index compared to the existing items weights.
   *
   * @param {ContainerItemConfig|ContainerItemConfig[]|Core.widget.Widget|Core.widget.Widget[]} toAdd The child or children instances (or config objects) to add.
   * @returns {Core.widget.Widget|Core.widget.Widget[]} All the added widgets. An array if multiple items
   * were added, otherwise just the item added.
   */
  add(...toAdd) {
    const me = this,
      items = me.ensureItems(),
      result = [];
    let returnArray = true,
      childToAdd,
      i,
      index;
    if (toAdd.length === 1) {
      if (isArray(toAdd[0])) {
        toAdd = toAdd[0];
      } else {
        returnArray = false;
      }
    }
    for (i = 0; i < toAdd.length; i++) {
      var _childToAdd;
      childToAdd = toAdd[i];
      if (childToAdd.isWidget) {
        childToAdd.parent = me;
      } else {
        childToAdd = me.createWidget(childToAdd);
      }
      // Items with weight are inserted at correct index
      if (((_childToAdd = childToAdd) === null || _childToAdd === void 0 ? void 0 : _childToAdd.weight) != null) {
        // Cannot use cached items, weights might be unordered in set being added
        index = ArrayHelper.findInsertionIndex(childToAdd, items.values, sortByWeight);
        result.push(me.insert(childToAdd, index));
      }
      // Those without are appended
      else if (childToAdd) {
        if (!items.includes(childToAdd)) {
          items.add(childToAdd);
          me.onChildAdd(childToAdd);
          me.layout.appendChild(childToAdd);
          result.push(childToAdd);
        }
      }
    }
    return returnArray ? result : result[0];
  }
  ensureItems() {
    const me = this;
    me.getConfig('items');
    me.getConfig('lazyItems');
    // Force creation of our items Bag
    if (!me._items) {
      me.items = [];
    }
    return me._items;
  }
  /**
   * Inserts the passed widget into this Container at the specified position.
   * @param  {Core.widget.Widget} toAdd The child to insert.
   * @param {Number|Core.widget.Widget} index The index to insert at or the existing child to insert before.
   * @returns {Core.widget.Widget} The added widget.
   */
  insert(toAdd, index) {
    const me = this,
      items = me.ensureItems();
    if (toAdd instanceof Widget) {
      toAdd.parent = me;
    } else {
      toAdd = me.createWidget(toAdd);
    }
    if (items.includes(index)) {
      index = me.indexOfChild(index);
    }
    index = Math.min(index, items.count);
    const newValues = items.values;
    newValues.splice(index, 0, toAdd);
    items.values = newValues;
    // Register inserted item
    me.onChildAdd(toAdd);
    me.layout.insertChild(toAdd, index);
    return toAdd;
  }
  indexOfChild(child) {
    return this.items.indexOf(child);
  }
  changeLazyItems(lazyItems) {
    this.items = lazyItems;
    this.layout.renderChildren();
  }
  changeItems(items, oldItems) {
    const me = this,
      newItems = [],
      result = new Bag();
    if (isArray(items)) {
      me.processItemsArray(items, newItems);
    } else if (items) {
      me.processItemsObject(items, me.namedItems, newItems);
    }
    // Allow child items to have a weight to establish their order
    if (newItems.some(returnWeight)) {
      newItems.sort(sortByWeight);
    }
    result.add(newItems);
    // Remove previous child payload if any
    if (oldItems) {
      oldItems.forEach(w => {
        me.remove(w);
        // Destroy outgoing-only widgets which we created.
        if (!result.includes(w) && w._createdBy === me) {
          w.destroy();
        }
      });
    }
    return result;
  }
  afterConstruct() {
    const {
        rtl
      } = this,
      {
        classList
      } = this.contentElement;
    // Content element must get class.
    // Panels and Toolbars use an inner element to arrange child items.
    classList.toggle('b-rtl', rtl === true);
    classList.toggle('b-ltr', rtl === false);
  }
  updateRtl(rtl) {
    super.updateRtl(rtl);
    const {
      contentElement
    } = this;
    // contentElement may not exist at config time. The afterConstruct handles it in those cases.
    if (contentElement) {
      // Content element must get class.
      // Panels and Toolbars use an inner element to arrange child items.
      contentElement.classList.toggle('b-rtl', rtl === true);
      contentElement.classList.toggle('b-ltr', rtl === false);
    }
  }
  updateItems(items, oldItems) {
    let index = 0;
    items.forEach(item => {
      // no "index" argument from Bag
      this.onChildAdd(item);
      // If this is *change* to items from actual old items, when the old items is not a placeholder inserted
      // from very early items access
      if (oldItems && !oldItems.temporary) {
        this.layout.insertChild(item, index);
      }
      ++index;
    });
    this.initialItems = false;
  }
  updateHideWhenEmpty() {
    this.syncChildCount(this.rendered);
  }
  /**
   * A property, which, when *read*, returns an array of the child items of this container in rendered order.
   *
   * This property may also be *set* to change the child items of the container. Just as in the
   * {@link #config-items initial items configuration}, the new value may either be an array of
   * Widgets/Widget configs or an object.
   *
   * If specified as an Object, the property names are used as the child Widget's
   * {@link Core.widget.Widget#config-ref} name, and the value is the child Widget/Widget config.
   *
   * When setting this, any items which are *only* in the outgoing child items which were created
   * by this container from raw config objects are destroyed.
   *
   * Usage patterns:
   *
   * ```javascript
   * myContainer.items = {
   *     name : {
   *         type  : 'textfield',
   *         label : 'User name'
   *     },
   *     age : {
   *         type  : 'numberfield',
   *         label : 'User age'
   *     }
   * };
   * ```
   *
   * or
   *
   * ```javascript
   * myContainer.items = [{
   *     ref   : 'name',
   *     type  : 'textfield',
   *     label : 'User name'
   * },
   *     ref   : 'age',
   *     type  : 'numberfield',
   *     label : 'User age'
   * }];
   * ```
   * @property {Core.widget.Widget[]}
   * @accepts {Core.widget.Widget[]|ContainerItemConfig[]|Object<String,ContainerItemConfig>}
   */
  get items() {
    const me = this;
    // If we are being asked for items, ingest lazyItems.
    me.getConfig('lazyItems');
    // The documented API for items is an Array.
    // Internal code should access _items
    if (!me._items) {
      // Currently initializing items, flag set by the config system
      if (me.initializingItems) {
        // This is a created array. User may mutate it.
        return [];
      }
      // Accessing items very early, not set up yet. Need a placeholder
      me._items = new Bag();
      me._items.temporary = true;
    }
    // This is the Collection's array. User may not mutate it.
    return me._items.values;
  }
  processItemsArray(items, result) {
    const len = items.length;
    let i, item;
    for (i = 0; i < len; i++) {
      item = items[i];
      if (item instanceof Widget) {
        item.parent = this;
        item.element.classList.remove(...Widget.outerCls);
      } else {
        item = this.createWidget(item);
      }
      // If the widget creation function returns null, nothing to add
      if (item) {
        if (item.ref || item.id) {
          // Add early to widgetMap, to allow using 'up.widgetMap.ref' in later siblings configs
          this.addDescendant(item);
        }
        result.push(item);
      }
    }
  }
  processItemsObject(items, namedItems, result) {
    let item, ref;
    for (ref in items) {
      item = items[ref];
      // It might come in as itemRef : false
      if (item) {
        // If this class or instance has a "namedItems" object
        // named by this ref, then use it as the basis for the item
        if (namedItems && ref in namedItems) {
          item = typeof item === 'object' ? ObjectHelper.merge(ObjectHelper.clone(namedItems[ref]), item) : namedItems[ref];
        }
        // Allow namedItems to be overridden with itemKey : false to indicate unavailability of an item
        if (item) {
          if (item instanceof Widget) {
            item.parent = this;
          } else {
            if (item instanceof Object) {
              item.ref = ref;
            }
            item = this.createWidget(item);
          }
          // If the widget creation function returns null, nothing to add
          if (item) {
            item.ref = ref;
            // Add early to widgetMap, to allow later siblings to use 'up.'
            this.addDescendant(item);
            result.push(item);
          }
        }
      }
    }
  }
  onChildAdd(item) {
    // Don't just assign the property across since the default value is undefined
    // which means false. Only set to true if we are readOnly
    if (item.innerItem && this.readOnly && !item.ignoreParentReadOnly) {
      item.readOnly = true;
    }
    this.onChildAddLayout(item);
    if (item.ref || item.id) {
      for (let current = this; current; current = current.parent) {
        // Silently add the descendant to the ancestor's widgetMap without kicking off
        // the ancestor's items processing by directly accessing the widgetMap property.
        current.addDescendant(item);
      }
    }
    this.syncChildCount(true);
  }
  onChildAddLayout(item) {
    // Set innerItem=false on an item that should not be managed by the layout...
    if (item.innerItem) {
      // Keep layout informed of child item state
      this.layout.onChildAdd(item);
    }
  }
  onChildHide(hidden) {
    var _this$_items;
    super.onChildHide(hidden);
    // Only sync when it's a direct child, not just the "owner" link of a floater
    if ((_this$_items = this._items) !== null && _this$_items !== void 0 && _this$_items.includes(hidden)) {
      this.syncChildCount(true);
    }
  }
  onChildShow(shown) {
    var _this$_items2;
    super.onChildShow(shown);
    // Only sync when it's a direct child, not just the "owner" link of a floater
    if ((_this$_items2 = this._items) !== null && _this$_items2 !== void 0 && _this$_items2.includes(shown)) {
      this.syncChildCount(true);
    }
  }
  syncChildCount(enforceHideWhenEmpty) {
    // If called during configuration, the element may not be available because
    // some non-item widgets (eg, Tools) instantiate and declare themselves through
    // onChildAdd before the element is set.
    // But also there may be no items because of     lazyItems.
    // So do the initial sync at render time.
    if (!this.isConfiguring) {
      const me = this,
        {
          // This must be our direct child item payload, not all items owned by this Container.
          // It's used to sync the b-first-visible-child/b-last-visible-child class presence.
          items,
          hasItems
        } = me,
        visibleItems = items.filter(isNotHidden),
        {
          length: visibleLength
        } = visibleItems;
      /**
       * @member {Number} visibleChildCount The number of *visible* child items shown in this Container.
       * @readonly
       * @category Widget hierarchy
       */
      me.visibleChildCount = visibleLength;
      // Do not toggle visibility on render - we're just here to sync class names.
      // hiding and showing must only depend upon children being dynamically
      // hidden or shown.
      if (me.hideWhenEmpty && enforceHideWhenEmpty) {
        const shouldHide = Boolean(!visibleLength);
        if (Boolean(me._hidden) !== shouldHide) {
          me.hidden = shouldHide;
        }
      }
      items.forEach(childItem => childItem.element.classList.remove('b-last-visible-child', 'b-first-visible-child'));
      if (visibleLength) {
        visibleItems[0].element.classList.add('b-first-visible-child');
        visibleItems[visibleLength - 1].element.classList.add('b-last-visible-child');
      }
      // Keep hasItems property up to date. It's used by the isFocusable getter.
      // Note that because this is to do with focusability, this includes all
      // possible items, not just contained items.
      me.hasItems = Boolean(me.childItems.length);
      me.contentElement.classList[visibleLength ? 'remove' : 'add']('b-no-visible-children');
      // Reevaluate whether we should have the b-text-content class
      if (!me.isComposable) {
        me.updateTextContent(me._textContent);
      } else if (hasItems !== me.hasItems) {
        me.recompose();
      }
    }
  }
  syncFlexDirection() {
    const me = this,
      {
        contentElement,
        flexColCls,
        flexRowCls
      } = me,
      classList = new DomClassList(contentElement.className),
      styles = DomHelper.getStyleValue(contentElement, stylesToCheck);
    // We might not be flexing at all anymore.
    classList[flexRowCls] = classList[flexColCls] = 0;
    // If we are, add a flag class to indicate direction
    if (styles.display === 'flex') {
      classList[styles['flex-direction'] === 'row' ? flexRowCls : flexColCls] = 1;
    }
    // Will only mutate the DOM if there are changes to apply.
    // We don't want to cause an infinite loop through our MutationObserver.
    DomHelper.syncClassList(contentElement, classList);
  }
  addDescendant(item) {
    const ref = item.ref || item.id,
      widgetMap = this._widgetMap || (this._widgetMap = {});
    if (!widgetMap[ref]) {
      widgetMap[ref] = item;
    }
  }
  onChildRemove(item) {
    const me = this,
      ref = item.ref || item.id;
    if (ref) {
      for (let current = me; current; current = current.parent) {
        if (current.widgetMap[ref] === item) {
          delete current.widgetMap[ref];
        }
      }
    }
    // Keep layout informed of child item state
    me.layout.onChildRemove(item);
    me.syncChildCount(true);
  }
  /**
   * An object which contains a map of descendant widgets keyed by their {@link Core.widget.Widget#config-ref}.
   * All descendant widgets will be available in the `widgetMap`.
   * @property {Object<String,Core.widget.Widget>}
   * @readonly
   * @category Widget hierarchy
   */
  get widgetMap() {
    if (!this._widgetMap) {
      this._widgetMap = {};
    }
    // Force evaluation of the configured items by the getter
    // so that configs are promoted to widgets and the widgetMap
    // is created, and if there are widgets, populated.
    if (!this.initializingItems) {
      this.getConfig('items');
    }
    return this._widgetMap;
  }
  //region Record & values
  changeRecord(record) {
    // The config system's non-change vetoing must be bypassed.
    // The record might have changed, or the destination fields may be out of sync.
    this._record = record == null ? emptyObject$3 : null;
    return record;
  }
  updateRecord(record) {
    var _me$recordUpdateDetac;
    const me = this;
    (_me$recordUpdateDetac = me.recordUpdateDetacher) === null || _me$recordUpdateDetac === void 0 ? void 0 : _me$recordUpdateDetac.call(me);
    /**
     * Fired before this container will load record values into its child fields. This is useful if you
     * want to modify the UI before data is loaded (e.g. set some input field to be readonly)
     * @event beforeSetRecord
     * @param {Core.widget.Container} source The container
     * @param {Core.data.Model} record The record
     */
    me.trigger('beforeSetRecord', {
      record
    });
    me.setValues(record, {
      onlyName: me.strictRecordMapping,
      highlight: Boolean(me.$highlight)
    });
    if (me.autoUpdateFields && record !== null && record !== void 0 && record.firstStore) {
      me.recordUpdateDetacher = record.firstStore.ion({
        update: me.onRecordUpdated,
        thisObj: me
      });
    }
  }
  setRecord(record, highlightChanges) {
    this.$highlight = highlightChanges;
    this.record = record;
    this.$highlight = false;
  }
  onRecordUpdated({
    record
  }) {
    if (record === this.record) {
      this.setValues(this.record, true, true);
    }
  }
  /**
   * A function called by descendant widgets after they trigger their 'change' event, in reaction to field changes.
   * By default, implements the functionality for the `autoUpdateRecord` config.
   *
   * @param {Object} params Normally the event params used when triggering the 'change' event
   * @internal
   */
  onFieldChange({
    source,
    userAction
  }) {
    // When configured with `autoUpdateRecord`, changes from descendant fields/widgets are applied to the loaded
    // record using the fields `name`. Only changes from valid fields will be applied
    if (this.autoUpdateRecord && userAction) {
      const {
          record,
          strictRecordMapping
        } = this,
        {
          name,
          ref,
          isValid = true,
          value
        } = source,
        key = strictRecordMapping ? name : name || ref;
      if (record && key && isValid) {
        if (record.isModel) {
          record.setValue(key, value);
        } else {
          record[key] = value;
        }
      }
    }
  }
  getValues(filterFn) {
    const values = {};
    this.eachWidget((widget, control) => {
      // Do not drill down when reaching a container that isolates its fields
      if (widget.isolateFields) {
        control.down = false;
      } else if ('name' in widget && (!filterFn || filterFn(widget))) {
        values[widget.name] = widget.value;
      }
    }, true);
    return values;
  }
  /**
   * Retrieves or sets all values from/to contained widgets.
   *
   * The property set or read from a contained widget is its {@link Core.widget.Widget#config-defaultBindProperty}.
   *
   * This defaults to the `value` for fields.
   *
   * You may add child widgets which may accept and yield a value to/from another property, such as a `Button` having
   * its {@link Core.widget.Button#config-href} set.
   *
   * Accepts and returns a map, using {@link Core.widget.Field#config-name}, {@link Core.widget.Widget#config-ref} or
   * {@link Core.widget.Widget#config-id} (in that order) as keys.
   *
   * ```javascript
   * const container = new Container({
   *     appendTo : document.body,
   *     items    : {
   *         firstName : {
   *             type : 'textfield
   *         },
   *         surName : {
   *             type : 'textfield
   *         }
   *         saveButton : {
   *             type                : 'button',
   *             text                : 'Save',
   *             defaultBindProperty : 'href'
   *             href                : '#'
   *         }
   *     }
   * });
   *
   * container.values = {
   *     firstName  : 'Clark',
   *     surname    : 'Kent',
   *     saveButton : '#save-route'
   * };
   * ```
   *
   * @property {Object<String,Object>}
   */
  get values() {
    const values = {};
    this.gatherValue(values);
    return values;
  }
  set values(values) {
    // if the container itself has a value allow it to be grabbed as well
    this.assignValue(values);
  }
  /**
   * Returns `true` if currently setting values. Allow fields to change highlighting to distinguishing between
   * initially setting values and later on changing values.
   * @property {Boolean}
   */
  get isSettingValues() {
    return Boolean(this.assigningValues);
  }
  get assigningValues() {
    var _this$parent;
    // Fields query their parent, pass the question up in case containers are nested
    return this._assigningValues || ((_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.assigningValues);
  }
  set assigningValues(v) {
    this._assigningValues = v;
  }
  assignValue(values, options) {
    // use default check for a value config from super...
    super.assignValue(values, options);
    if (!this.isolateFields) {
      this.setValues(values, options);
    }
  }
  gatherValue(values) {
    super.gatherValue(values);
    if (!this.isolateFields) {
      this.gatherValues(values);
    }
  }
  setValues(values, options = this.assignValueDefaults) {
    // Flag checked by Field to determine if it should highlight change or not
    this.assigningValues = options;
    this.eachWidget(widget => widget.assignValue(values, options), false);
    this.assigningValues = false;
  }
  //endregion
  get hasNoChildren() {
    // If we have *uningested* lazyItems, use them to find our items length.
    // In that case we must not cause ingestion of the lazyItems by referencing this.items.
    // If we have items, then only those that are visible have any bearing.
    // Popup also has to consult this property to decide on its CSS classes.
    const me = this,
      {
        items,
        lazyItems
      } = me.initialConfig,
      itemsArray = items && (isArray(items) ? items : ObjectHelper.values(items)),
      lazyItemsArray = lazyItems && (isArray(lazyItems) ? lazyItems : ObjectHelper.values(lazyItems)),
      // avoid triggering items initialization
      whichItems = me.isConfiguring ? lazyItemsArray || itemsArray : me.items;
    return !(whichItems !== null && whichItems !== void 0 && whichItems.filter(isNotHidden).length);
  }
  afterRecompose() {
    super.afterRecompose();
    this.realign();
  }
  updateTextContent(textContent) {
    const me = this;
    // Add the text content class if we have no visible immediate item children.
    if (!me.isComposable) {
      const needsClass = Boolean(textContent && me.hasNoChildren),
        {
          classList
        } = me.contentElement,
        changed = needsClass !== classList.contains('b-text-content');
      // Depending on CSS settings around how this widget handles text content and widthing
      // we *may* have to realign. Realign only goes ahead if we're visible and floating.
      if (changed) {
        classList[needsClass ? 'add' : 'remove']('b-text-content');
        if (me.rendered) {
          me.realign();
        }
      }
    }
  }
  updateLayoutStyle(layoutStyle) {
    DomHelper.applyStyle(this.contentElement, layoutStyle);
  }
  updateElement(element) {
    super.updateElement(...arguments);
    if (element) {
      const {
          classList
        } = this.contentElement,
        {
          containerCls
        } = this.layout;
      // Ensure contentElement gets its full complement of class names upon element creation
      classList.add('b-content-element');
      if (containerCls) {
        classList.add(containerCls);
      }
    }
  }
  onPaint() {
    var _super$onPaint;
    (_super$onPaint = super.onPaint) === null || _super$onPaint === void 0 ? void 0 : _super$onPaint.call(this, ...arguments);
    // Bring the lazy config into existence now that we have a layout.
    this.getConfig('contentElMutationObserver');
  }
  changeContentElMutationObserver(contentElMutationObserver, oldContentElMutationObserver) {
    if (oldContentElMutationObserver) {
      // Clear the queue. Any remaining notifications will be undeliverable.
      oldContentElMutationObserver.takeRecords();
      oldContentElMutationObserver.disconnect();
    }
    // We need to monitor our contentElement for attribute changes.
    // Changes to the inline style, or the classList/className will trigger this.
    // At that point we can sync our layout flag classes.
    if (contentElMutationObserver) {
      // NOTE: Do not hoist the vars, that will pull things in during destruction
      const me = this,
        {
          element,
          contentElement
        } = me;
      contentElMutationObserver = new MutationObserver(mutations => me.onContentElMutation(mutations));
      contentElMutationObserver.observe(contentElement, {
        attributes: true
      });
      // If our contentElement is an inner element (eg Panel, Toolbar)
      // then styling might apply from classes on the outer element
      // so monitor that too.
      if (contentElement !== element) {
        contentElMutationObserver.observe(element, {
          attributes: true
        });
      }
      me.syncFlexDirection();
    }
    return contentElMutationObserver;
  }
  onContentElMutation() {
    // We can only do it if we are visible, otherwise the computed style won't work
    // and the classes will be removed. Doesn't need doing for card and fit layouts.
    if (boxLayouts[this.layout.type] && this.isVisible) {
      this.syncFlexDirection();
    }
  }
  changeLayout(config, existingLayout) {
    return Layout.reconfigure(existingLayout, config, {
      owner: this,
      defaults: {
        owner: this
      }
    });
  }
  // Items to iterate over
  get childItems() {
    return this.items;
  }
  /**
   * Returns a directly contained widget by id
   * @param {String} id The widget id
   * @returns {Core.widget.Widget}
   */
  getWidgetById(id) {
    return this.widgetMap[id];
  }
  /**
   * This function is called prior to creating widgets, override it in subclasses to allow containers to modify the
   * configuration of each widget. When adding a widget to a container hierarchy each parent containers
   * `processWidgetConfig` will be called. Returning false from the function prevents the widget from being added at
   * all.
   */
  processWidgetConfig(widget) {}
  /**
   * This method combines container {@link #config-defaults}
   * @param {String|ContainerItemConfig} widgetConfig
   * @param {String|Function} [type] The type of widget described by `widgetConfig`.
   * @returns {ContainerItemConfig}
   * @internal
   */
  setupWidgetConfig(widgetConfig, type) {
    const me = this;
    // A string becomes the defaultType (see below) with the html set to the string.
    if (typeof widgetConfig === 'string') {
      widgetConfig = {
        html: widgetConfig
      };
    }
    // An element is encapsulated by a Widget
    else if (widgetConfig.nodeType === Element.ELEMENT_NODE) {
      widgetConfig = {
        element: widgetConfig,
        id: widgetConfig.id
      };
    }
    if (typeof type === 'string' || !type && (type /* assignment */ = widgetConfig.type)) {
      // True/false values are selected using a SlideToggle on mobile if app has imported SlideToggle
      if (type === 'checkbox' && BrowserHelper.isMobile && Widget.resolveType('slidetoggle', true)) {
        type = widgetConfig.type = 'slidetoggle';
      }
      type = Widget.resolveType(type, true);
    }
    // widgetConfig = ObjectHelper.assign({}, me.defaults, widgetConfig, { parent : me });
    widgetConfig = (type || Widget).mergeConfigs(me.defaults, widgetConfig, {
      parent: me
    });
    for (let ancestor = widgetConfig.parent; ancestor; ancestor = ancestor.parent) {
      if (ancestor.processWidgetConfig(widgetConfig) === false) {
        return null;
      }
    }
    if (me.trigger('beforeWidgetCreate', {
      widgetConfig
    }) === false) {
      return null;
    }
    return widgetConfig;
  }
  /**
   * This function converts a Widget config object into a Widget.
   * @param {ContainerItemConfig} widget A Widget config object.
   * @internal
   */
  createWidget(widget) {
    const result = Widget.create(this.setupWidgetConfig(widget), this.defaultType);
    // If we created a widget from a config object, then upon items replacement
    // we must destroy outgoing widgets.
    result && (result._createdBy = this);
    return result;
  }
  // Reapply defaults, not used during config
  updateDefaults(defaults, oldDefaults) {
    if (!this.isConfiguring && defaults) {
      const entries = Object.entries(defaults);
      this.eachWidget(widget => {
        entries.forEach(([prop, value]) => {
          // Apply defaults only if current value matches the old default
          if (!oldDefaults || widget[prop] === oldDefaults[prop]) {
            widget[prop] = value;
          }
        });
      }, false);
    }
  }
  render() {
    // Pull in lazyItems at last second
    this.getConfig('lazyItems');
    this.layout.renderChildren();
    // If called during configuration, the element may not have been available because
    // some non-item widgets (eg, Tools) instantiate and declare themselves through
    // onChildAdd before the element is set.
    // But also there may have been no items because of lazyItems.
    // So do the initial sync at render time.
    this.syncChildCount();
    super.render(...arguments);
  }
  get focusElement() {
    // Find first focusable descendant widget that is not our close or collapse tool.
    const firstFocusable = this.query(this.defaultFocus || (w => {
      var _w$ref;
      return w.isFocusable && w.ref !== 'close' && !((_w$ref = w.ref) !== null && _w$ref !== void 0 && _w$ref.endsWith('collapse'));
    }));
    if (firstFocusable) {
      return firstFocusable.focusElement;
    }
    return super.focusElement;
  }
  doDestroy() {
    var _this$_items3;
    (_this$_items3 = this._items) === null || _this$_items3 === void 0 ? void 0 : _this$_items3.forEach(widget => {
      var _widget$destroy;
      return (_widget$destroy = widget.destroy) === null || _widget$destroy === void 0 ? void 0 : _widget$destroy.call(widget);
    });
    this.layout.destroy();
    super.doDestroy();
  }
  /**
   * Returns `true` if all contained fields are valid, otherwise `false`
   * @property {Boolean}
   */
  get isValid() {
    let valid = true;
    this.eachWidget(widget => {
      // Touch each widget so that they all update their invalid state. This is important for required fields
      // since they don't initially complain if they start as empty.
      if (widget.isVisible && 'isValid' in widget && !widget.isValid) {
        valid = false;
      }
    }, true);
    return valid;
  }
}
// Register this widget type with its Factory
Container.initClass();
Container._$name = 'Container';

/**
 * @module Core/util/Animator
 */
const {
    assign
  } = ObjectHelper,
  now = () => performance.now(),
  nostart = {
    start: false
  },
  unitRe = /^[.\d]+([^\d].*)?$/,
  getTransitions = element => {
    const $bryntum = element.$bryntum || (element.$bryntum = {});
    return $bryntum.transitions || ($bryntum.transitions = Object.create(null));
  },
  milliseconds = (duration, unit) => {
    if (typeof duration === 'string') {
      var _unitRe$exec;
      unit = (_unitRe$exec = unitRe.exec(duration)) === null || _unitRe$exec === void 0 ? void 0 : _unitRe$exec[1];
      duration = parseFloat(duration);
    }
    // a number could be sec or ms so guess sec if duration is small
    return duration && duration * (unit === 's' || !unit && duration < 10 ? 1000 : 1);
  },
  syncTransitions = element => {
    const all = ObjectHelper.values(getTransitions(element)).filter(a => a.completed == null).map(a => a.toString());
    element.style.transition = all.join(', ');
  },
  Anim = Target => class Anim extends Target {
    static get prototypeProperties() {
      return {
        _delay: null,
        _duration: null,
        _retain: null,
        _timing: null,
        _unit: null,
        owner: null,
        reverting: null
      };
    }
    constructor(...args) {
      super(...args);
      this.id = ++idSeed$1;
    }
    start() {
      this.startTime = now();
    }
    get delay() {
      var _this$owner;
      return milliseconds(this._delay ?? ((_this$owner = this.owner) === null || _this$owner === void 0 ? void 0 : _this$owner.delay) ?? 0, this.unit);
    }
    set delay(v) {
      this._delay = v;
    }
    get duration() {
      const {
        owner,
        unit
      } = this;
      return milliseconds(this._duration ?? (owner ? owner.duration : Animator.defaultDuration), unit);
    }
    set duration(v) {
      this._duration = v;
    }
    get elapsed() {
      return now() - this.startTime;
    }
    get remaining() {
      return this.duration - this.elapsed;
    }
    get retain() {
      var _this$owner2;
      return this._retain ?? ((_this$owner2 = this.owner) === null || _this$owner2 === void 0 ? void 0 : _this$owner2.retain);
    }
    set retain(v) {
      this._retain = v;
    }
    get timing() {
      var _this$owner3;
      return this._timing ?? ((_this$owner3 = this.owner) === null || _this$owner3 === void 0 ? void 0 : _this$owner3.timing);
    }
    set timing(v) {
      this._timing = v;
    }
    get unit() {
      var _this$owner4;
      return this._unit ?? ((_this$owner4 = this.owner) === null || _this$owner4 === void 0 ? void 0 : _this$owner4.unit);
    }
    set unit(v) {
      this._unit = v;
    }
  };
let idSeed$1 = 0;
/**
 * These objects are passed as values in the config object of an `Animator`. The `property` name is the key in the
 * config object.
 *
 * For example:
 * ```javascript
 *  const anim = Animator.run({
 *      element,
 *      opacity : {
 *          // AnimatorTransition properties
 *      }
 *  });
 * ```
 *
 * The {@link Core.util.Animator#config-items anim.items} array will contain a single `AnimatorTransition` instance.
 *
 * @typedef {Object} AnimatorTransition
 * @property {Number|String} property The name of the style property from the key in the `Animator` config object (in
 * the above example, this will be `'opacity'`).
 * @property {Boolean} completed This readonly property is set to `true` when the transition completes.
 * @property {Number|String} [delay=0] The delay before starting the transition. Numbers less than 10 are assumed to be
 * seconds (instead of milliseconds) unless the `unit` property is specified.
 * @property {Number|String} [duration=200] The duration of the transition. Numbers less than 10 are assumed to be
 * seconds (instead of milliseconds) unless the `unit` property is specified.
 * @property {Number|String} [from] The value from which to start the transition.
 * @property {Boolean} [retain] Set to `true` to retain the style property value after the transition. This defaults to
 * `true` if a {@link Core.util.Animator#config-finalize} function is not specified.
 * @property {String} [timing='ease-in-out'] The transition
 * [timing function](https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function).
 * @property {Number|String} to The final value to which the transition will animate.
 * @property {'s'|'ms'} [unit] The duration/delay unit (either `'s'` or `'ms'`).
 * @internal
 */
class AnimatorTransition extends Base.mixin(Anim) {
  static get $name() {
    return 'AnimatorTransition';
  }
  static get prototypeProperties() {
    return {
      element: null,
      property: null,
      from: null,
      to: null,
      completed: null,
      promissory: null,
      reverting: null
    };
  }
  afterConstruct() {
    super.afterConstruct();
    const me = this,
      {
        element,
        transitions
      } = me;
    let {
      property
    } = me;
    [property, me.to] = DomHelper.unitize(property, me.to);
    me.from = DomHelper.unitize(property, me.from)[1];
    me.promissory = new Promissory();
    me.property = property;
    const was = transitions[property];
    transitions[property] = me;
    let {
      from
    } = me;
    if (was) {
      // Remember where we come from. If there was an animation running, its "to" value is where we would have
      // been had it completed.
      me.from = was.to;
      from = null;
      was.destroy();
    }
    if (from === null) {
      from = me.getCurrentStyleValue();
      if (!was) {
        me.from = from;
      }
    }
    // Set transitioning style's initial value
    element.style[property] = from;
    // then read the style to ensure transition will animate
    me.getCurrentStyleValue();
  }
  doDestroy() {
    const me = this;
    me.finish(false);
    if (me.completed && !me.retain) {
      me.clearStyle();
    }
    super.doDestroy();
  }
  get promise() {
    var _this$promissory;
    return (_this$promissory = this.promissory) === null || _this$promissory === void 0 ? void 0 : _this$promissory.promise;
  }
  get transitions() {
    return getTransitions(this.element);
  }
  clearStyle() {
    this.setStyle('');
  }
  finish(complete) {
    const me = this,
      {
        transitions,
        promissory,
        property
      } = me;
    if (promissory) {
      me.completed = complete;
      me.promissory = null;
      promissory.resolve(complete);
      if (transitions[property] === me) {
        delete transitions[property];
        if (!complete) {
          // if we are the current transition, this destroy is a cancellation of the animation (not a
          // revert), so remove our transition and clear the style to reset the element.
          syncTransitions(me.element);
          me.clearStyle();
        }
      } else {
        me.completed = false; // this can most likely never happen, but better to be safe
      }
    }
  }

  getCurrentStyleValue() {
    return DomHelper.getStyleValue(this.element, this.property);
  }
  revert() {
    const {
      duration,
      elapsed,
      element,
      from,
      property,
      _retain: retain,
      _timing: timing
    } = this;
    return new AnimatorTransition({
      element,
      property,
      retain,
      timing,
      duration: Math.round(Math.min(duration, elapsed)),
      reverting: this,
      to: from,
      unit: 'ms'
    });
  }
  setStyle(value) {
    this.element.style[this.property] = value;
  }
  start() {
    const me = this,
      {
        delay,
        duration,
        element,
        property
      } = me;
    EventHelper.onTransitionEnd({
      element,
      property,
      duration: delay + duration + 20,
      thisObj: me.owner,
      handler: () => {
        var _me$finish;
        return (_me$finish = me.finish) === null || _me$finish === void 0 ? void 0 : _me$finish.call(me, true);
      } // finish() is gone if destroyed
    });

    super.start();
    me.setStyle(me.to);
  }
  toString() {
    const {
      delay,
      duration,
      property,
      timing
    } = this;
    return `${property} ${duration}ms ${timing || 'ease-in-out'}${delay ? ` ${delay}ms` : ''}`;
  }
}
AnimatorTransition.initClass();
/**
 * Manages one or more {@link AnimatorTransition style transitions} or other `Animator` instances. Unlike typical
 * config objects, the config object for this class is a mixture of config properties and style names that define
 * {@link AnimatorTransition style transitions}.
 *
 * For example:
 * ```javascript
 *  const anim = Animator.run({
 *      element,
 *      duration : 500,
 *
 *      // style transitions:
 *      opacity : 0
 *  });
 *
 *  await anim.done();
 * ```
 *
 * The static {@link #function-run-static} method is typically used (as above) instead of the `new Animator()` style for
 * brevity (since a manually created `Animator` must also be manually {@link #function-start started}).
 *
 * An `Animator` can be {@link #function-done awaited} and will resolve once all of its transitions and/or child
 * animations complete or are aborted (via `destroy()`).
 *
 * ## Compound Transitions
 * The following custom transitions can present in the `Animator` config object as if they were normal style transitions:
 *
 * - {@link #function-puff-static}
 *
 * For example:
 *
 * ```javascript
 *  const anim = Animator.run({
 *      element,
 *      marginLeft : -200,
 *      puff       : true   // true for default scale, a number, or config object
 *  });
 * ```
 *
 * @extends Core/Base
 * @internal
 */
class Animator extends Base.mixin(Anim) {
  static get $name() {
    return 'Animator';
  }
  static get prototypeProperties() {
    return {
      /**
       * The optional delay before starting the animation. Numbers less than 10 are assumed to be seconds
       * (instead of milliseconds) unless the `unit` property is specified.
       * @config {Number|String} delay
       */
      /**
       * The duration of the animation. Numbers less than 10 are assumed to be seconds (instead of milliseconds)
       * unless the `unit` property is specified.
       * @config {Number|String} duration
       * @default
       */
      /**
       * The element to animate.
       * @config {HTMLElement} element
       */
      element: null,
      /**
       * A callback function called when the animation completes. This is called after restoring styles to the
       * original values (based on {@link #config-retain}). When this function is provided, `retain` defaults to
       * `false`. By implementing this function, a CSS class can be applied to the {@link #config-element} to
       * give the proper style, while the inline styles are removed (e.g., a hide animation based on opacity).
       *
       * For example:
       * ```javascript
       *  const anim = Animator.run({
       *      element,
       *      duration : 500,
       *      opacity  : 0,
       *
       *      finalize() {
       *          element.classList.add('hidden');
       *      }
       *  });
       *
       *  await anim.done();
       * ```
       * @config {Function} finalize
       */
      finalize: null,
      /**
       * A callback function called when the animation completes. This is called prior to restoring styles to the
       * original values (based on {@link #config-retain}).
       * @config {Function} prefinalize
       * @internal
       */
      prefinalize: null,
      /**
       * Set to `true` to retain the style property values after the animation. This defaults to `true` if a
       * {@link #config-finalize} function is not specified, and `false` otherwise. When a `finalize` function
       * is provided, it is typically to apply a CSS class to achieve the desired styling so that inline styles
       * can be removed.
       * @config {Boolean} retain
       */
      /**
       * The [timing function](https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function) for
       * the animation.
       * @config {String} timing
       * @default 'ease-in-out'
       */
      /**
       * The duration/delay unit (either `'s'` or `'ms'`).
       * @config {'s'|'ms'} unit
       */
      /**
       * This readonly property is set to `true` when the animation completes or `false` if the animation is
       * aborted (by calling the `destroy()` method).
       * @member {Boolean} completed
       * @readonly
       */
      completed: null,
      /**
       * An array containing a mixture of `Animator` and/or `AnimatorTransition` objects, depending on what was
       * specified at construction time.
       * @member {Core.util.Animator[]|AnimatorTransition[]} items
       * @readonly
       */
      /**
       * When passed at construction time, `items` can be an array of other `Animator` config objects. This can be
       * used to animate multiple elements and wait for this instance to be {@link #function-done done}.
       * @config {Core.util.Animator[]} items
       */
      items: null
    };
  }
  static register(name, fn) {
    if (ObjectHelper.isObject(name)) {
      ObjectHelper.entries(name).forEach(entry => Animator.register(...entry));
      return;
    }
    Animator.fx[name] = fn;
    Animator[name] = options => {
      if (DomHelper.isElement(options)) {
        options = {
          element: options,
          [name]: {}
        };
      } else {
        options = {
          element: options.element,
          [name]: options
        };
        delete options[name].element;
      }
      return Animator.run(options);
    };
  }
  /**
   * A short-hand way to create an `Animator` instance and call its {@link #function-start} method.
   *
   * ```javascript
   *  const anim = Animator.run({
   *      element,
   *      duration : 500,
   *
   *      // style transitions:
   *      opacity : 0
   *  });
   *
   *  await anim.done();
   * ```
   * @param {Core.util.Animator|AnimatorConfig} options A config object for an `Animator` instance.
   * @returns {Core.util.Animator}
   */
  static run(options) {
    return new Animator(options).start();
  }
  constructor(options) {
    var _me$items;
    super(null); // our options is not like a normal config object since is has styles mixed in w/configs
    const me = this,
      items = [],
      properties = {};
    let anim, fx, key, t;
    if (Array.isArray(options)) {
      me.items = options;
    } else {
      for (key in options) {
        (Animator.specialPropsRe.test(key) ? me : properties)[key] = options[key];
      }
    }
    ObjectHelper.keys(properties).forEach(property => {
      t = properties[property];
      // ignore values of null, undefined, false and NaN (NaN !== NaN)
      if (t != null && t !== false && t === t) {
        // eslint-disable-line no-self-compare
        if (!(fx = Animator.fx[property])) {
          t = assign(me.defaults, typeof t === 'object' ? t : {
            to: t
          });
          t.owner = me;
          t.property = property;
          anim = new AnimatorTransition(t);
        } else {
          t = assign(me.defaults, fx(t, me, property));
          t.owner = me;
          anim = new Animator(t);
        }
        items.push(anim);
      }
    });
    // me.items can be set if options was an array or if options.items was passed.
    (_me$items = me.items) === null || _me$items === void 0 ? void 0 : _me$items.forEach(item => {
      if (ObjectHelper.isInstantiated(item)) {
        item.owner = me;
      } else {
        item = assign(me.defaults, item);
        item.owner = me;
        item = new Animator(item);
      }
      items.push(item);
    });
    me.items = items;
    me.promise = (items.length === 1 ? items[0].promise : Promise.all(items.map(it => it.promise))).then(res => {
      var _me$finish2;
      (_me$finish2 = me.finish) === null || _me$finish2 === void 0 ? void 0 : _me$finish2.call(me, res);
      return me.completed || false;
    });
  }
  doDestroy() {
    this.items.forEach(a => a.destroy());
    super.doDestroy();
  }
  get defaults() {
    return {
      element: this.element
    };
  }
  get retain() {
    const {
      _retain,
      finalize,
      owner
    } = this;
    return _retain ?? (finalize ? false : owner ? owner.retain : true);
  }
  set retain(v) {
    super.retain = v;
  }
  /**
   * Returns a `Promise` that resolves to a `Boolean` when this animation completes. The resolved value is that of
   * this instance's {@link #property-completed} property.
   * @async
   */
  done() {
    return this.promise;
  }
  finish(complete) {
    var _me$prefinalize, _me$finalize;
    const me = this,
      {
        items
      } = me;
    syncTransitions(me.element);
    me.completed = typeof complete === 'boolean' ? complete : !complete.some(a => !a);
    (_me$prefinalize = me.prefinalize) === null || _me$prefinalize === void 0 ? void 0 : _me$prefinalize.call(me, me.completed, me);
    while (items.length) {
      items.pop().destroy();
    }
    (_me$finalize = me.finalize) === null || _me$finalize === void 0 ? void 0 : _me$finalize.call(me, me.completed, me);
  }
  revert(options) {
    const me = this,
      {
        reverting
      } = me,
      start = !options || (options.start ?? true);
    let anim = me.defaults;
    if (reverting) {
      // If this anim is a revert of some previous anim and that anim had a finalizer, then reverting us should
      // (by default) carry forward the original finalizer:
      if (reverting.finalize) {
        anim.finalize = reverting.finalize;
      }
      if (reverting.prefinalize) {
        anim.prefinalize = reverting.prefinalize;
      }
      anim.retain = reverting._retain;
    }
    anim = assign(anim, options, {
      items: me.items.map(it => it.revert(nostart)),
      reverting: me
    });
    anim = new Animator(anim);
    start && anim.start();
    return anim;
  }
  /**
   * Starts this animation and returns a reference to itself. This method is called automatically by the
   * {@link #function-run-static} method.
   * @returns {Core.util.Animator}
   */
  start() {
    const {
      element,
      items
    } = this;
    super.start();
    if (items.length) {
      syncTransitions(element);
      items.forEach(a => a.start());
    }
    return this;
  }
}
Animator.initClass().Transition = AnimatorTransition;
Animator.specialPropsRe = new RegExp(`^(?:${Object.keys(Animator.prototypeProperties).concat(Object.keys(Animator.superclass.prototypeProperties)).map(s => s[0] === '_' ? s.substr(1) : s).join('|')})$`);
Animator.defaultDuration = 200;
Animator.fx = {};
Animator.register({
  /**
   * A compound animation to achieve `transform: scale()` and `opacity: 0`. The `scale` defaults to 8 but can be set
   * in the `anim` config object.
   *
   * For example
   * ```javascript
   *  const puff = Animator.puff(element);
   *
   *  const puff = Animator.puff({
   *      element,
   *      scale : 12
   *  });
   * ```
   *
   * This compound animation can also be specified in an `Animator` config object along with other style transitions:
   * ```javascript
   *  const anim = Animator.run({
   *      element,
   *      marginLeft : -200,
   *      puff       : true   // true for default scale, a number, or config object
   *  });
   * ```
   * @param {Element|AnimatorConfig|Core.util.Animator} anim The element to animate or the config object containing at least
   * the `element` property. This config object can contain an optional `scale` property to adjust the animation's
   * `transform: scale()` value.
   * @param {Number} [anim.scale=8] The scale value for the `transform:scale()` transition.
   * @returns {Core.util.Animator}
   * @static
   */
  puff(anim) {
    if (anim === true) {
      anim = {};
    } else if (typeof anim !== 'object') {
      // string || number
      anim = {
        transform: `scale(${anim})`
      };
    } else if (anim.scale) {
      anim = ObjectHelper.clone(anim);
      anim.transform = `scale(${anim.scale})`;
      delete anim.scale;
    }
    return assign({
      opacity: 0,
      transform: 'scale(8)'
    }, anim);
  }
});
Animator._$name = 'Animator';

/**
 * @module Core/util/ClickRepeater
 */
/**
 * A helper class, which, when applied to an {@link #config-element} means that a mousedown and hold on that element
 * will, after a configured {@link #config-delay}, begin autorepeating `click` events on that element, starting at a
 * rate of {@link #config-startRate} clicks per second, and over {@link #config-accelerateDuration} milliseconds,
 * accelerate to firing clicks at {@link #config-endRate} times per second.
 *
 * An example of this is used by the {@link Core.widget.NumberField}'s spinner triggers.
 */
class ClickRepeater extends Base.mixin(Delayable) {
  static get configurable() {
    return {
      /**
       * The element on which to fire autorepeating `click` events when the mouse is held down.
       * @config {HTMLElement}
       */
      element: null,
      /**
       * A query selector which specifies subtargets of this ClickRepeater's {@link #config-element}
       * which act as the click auto repeat event targets.
       * @config {String}
       * @default
       */
      delegate: null,
      /**
       * How long in milliSeconds to pause before starting the click repeats.
       * @config {Number}
       * @default
       */
      delay: 500,
      /**
       * Clicks per second to start firing after the initial {@link #config-delay}
       * @config {Number}
       * @default
       */
      startRate: 2,
      /**
       * Clicks per second to fire at top speed, after accelerating over the {@link #config-accelerateDuration}
       * @config {Number}
       * @default
       */
      endRate: 20,
      /**
       * How long in milliseconds to accelerate from the
       * {@link #config-startRate} to the {@link #config-startRate}.
       * @config {Number}
       * @default
       */
      accelerateDuration: 4000,
      pressedCls: 'b-pressed'
    };
  }
  doDestroy() {
    var _this$mousedownRemove;
    (_this$mousedownRemove = this.mousedownRemover) === null || _this$mousedownRemove === void 0 ? void 0 : _this$mousedownRemove.call(this);
    this.cancel();
    super.doDestroy();
  }
  cancel() {
    var _me$activeElement, _me$acceleration, _me$activeListenerRem;
    const me = this;
    (_me$activeElement = me.activeElement) === null || _me$activeElement === void 0 ? void 0 : _me$activeElement.classList.remove(me.pressedCls);
    me.activeElement = null;
    (_me$acceleration = me.acceleration) === null || _me$acceleration === void 0 ? void 0 : _me$acceleration.cancel();
    me.activeListenerRemover = (_me$activeListenerRem = me.activeListenerRemover) === null || _me$activeListenerRem === void 0 ? void 0 : _me$activeListenerRem.call(me);
    me.clearTimeout(me.autoRepeatTimer);
    me.clearTimeout(me.repeatTimer);
  }
  updateElement(element) {
    var _this$mousedownRemove2;
    (_this$mousedownRemove2 = this.mousedownRemover) === null || _this$mousedownRemove2 === void 0 ? void 0 : _this$mousedownRemove2.call(this);
    this.mousedownRemover = EventHelper.on({
      element,
      mousedown: 'onMouseDown',
      thisObj: this
    });
  }
  onMouseDown(e) {
    const me = this,
      target = me.delegate ? e.target.closest(me.delegate) : me.element;
    me.cancel();
    if (target) {
      me.activeElement = target;
      me.triggerEvent = e;
      target.classList.add(me.pressedCls);
      me.activeListenerRemover = EventHelper.on({
        mouseup: {
          element: document,
          capture: true,
          handler: 'onMouseUp'
        },
        mousemove: {
          element: target,
          handler: 'onTargetMouseMove'
        },
        mouseleave: {
          element: target,
          handler: 'onTargetMouseLeave'
        },
        mouseenter: {
          element: target,
          handler: 'onTargetMouseEnter'
        },
        thisObj: me
      });
      me.autoRepeatTimer = me.setTimeout('startAutoRepeat', me.delay);
    }
  }
  onMouseUp() {
    this.cancel();
  }
  onTargetMouseLeave() {
    this.activeElement.classList.remove(this.pressedCls);
    this.clearTimeout(this.repeatTimer);
  }
  onTargetMouseEnter(e) {
    const me = this;
    if (!e.buttons) {
      // mostly seen due to breakpoints in click handling, but easy to detect if mouse was released...
      me.cancel();
    } else {
      me.activeElement.classList.add(me.pressedCls);
      me.triggerEvent = e;
      me.fireClick();
    }
  }
  onTargetMouseMove(e) {
    this.triggerEvent = e;
  }
  startAutoRepeat() {
    const me = this;
    me.interval = me.startInterval = 1000 / me.startRate;
    me.accelerationDelta = me.startInterval - 1000 / me.endRate;
    // Begin animating the interval from 1000/me.startRate to 1000/me.endRate
    me.fireClick();
    me.acceleration = FunctionHelper.animate(me.accelerateDuration, me.nextTick, me, 'easeOutQuad');
  }
  nextTick(progress) {
    this.interval = this.startInterval - this.accelerationDelta * progress;
  }
  fireClick() {
    const me = this,
      clickEvent = new MouseEvent('click', me.triggerEvent);
    me.triggerEvent.target.dispatchEvent(clickEvent);
    me.repeatTimer = me.setTimeout(me.fireClick, me.interval);
  }
}
ClickRepeater._$name = 'ClickRepeater';

/**
 * @module Core/widget/mixin/Rotatable
 */
// we set rotate to 'LEFT' or 'RIGHT' when we auto rotate so we can tell it was (most likely) us:
const autoRotateRe = /^(?:undefined|null|LEFT|RIGHT)$/,
  inverted = {
    TOP: 'BOTTOM',
    RIGHT: 'LEFT',
    BOTTOM: 'TOP',
    LEFT: 'RIGHT'
  };
const canonicalDock = dock => {
  const DOCK = dock === null || dock === void 0 ? void 0 : dock.toUpperCase();
  return [DOCK, DOCK === 'LEFT' || DOCK === 'RIGHT'];
};
/**
 * A mixin that provides support for rotating a widget's primary element.
 * @mixin
 * @internal
 */
var Rotatable = (Target => class Rotatable extends (Target || Base) {
  static get $name() {
    return 'Rotatable';
  }
  static get configurable() {
    return {
      /**
       * Set to `'left'` to rotate the button content 90 degrees counter-clockwise or `'right'` for clockwise.
       * @member {'left'|'right'} rotate
       */
      /**
       * Specify `'left'` to rotate the button content 90 degrees counter-clockwise or `'right'` for clockwise.
       * @config {'left'|'right'}
       */
      rotate: null,
      invertRotate: null
    };
  }
  compose() {
    const {
      rotate
    } = this;
    return {
      class: {
        [`b-rotate-${(rotate || '').toLowerCase()}`]: rotate,
        'b-rotate-vertical': rotate
      }
    };
  }
  syncRotationToDock(dock) {
    if (autoRotateRe.test(String(this.rotate))) {
      const [DOCK, vertical] = canonicalDock(dock);
      this.rotate = vertical ? this.invertRotate ? inverted[DOCK] : DOCK : null;
    }
  }
  get widgetClass() {
    return null;
  }
});

/**
 * @module Core/widget/Tool
 */
/**
 * Base class for tools.
 *
 * May be configured with a `cls` and a `handler` which is a function (or name of a function)
 * in the owning Panel.
 * @extends Core/widget/Widget
 *
 * @classType tool
 */
class Tool extends Widget.mixin(Rotatable) {
  static $name = 'Tool';
  static type = 'tool';
  static configurable = {
    /**
     * Specify `'start'` to place the tool before the owner's central element (e.g., the `title` of the panel).
     * @config {'start'|'end'}
     * @default 'end'
     * @category Float & align
     */
    align: {
      value: null,
      $config: {
        merge: 'replace'
      }
    },
    /**
     * If provided, turns the tool into a link
     * @config {String}
     */
    href: null,
    /**
     * The function to call when this tool is clicked. May be a function or function name
     * prepended by `"up."` that is resolvable in an ancestor component (such as an owning
     * Grid, Scheduler, Calendar, Gantt or TaskBoard)
     * @param {Event} handler.event The DOM event which activated the tool.
     * @param {Core.widget.Panel} handler.panel The owning Panel of the tool.
     * @param {Core.widget.Tool} handler.tool The clicked Tool.
     * @config {Function|String} handler
     */
    /**
     * A {@link Core.util.ClickRepeater } config object to specify how click-and-hold gestures repeat the click
     * action.
     * @config {ClickRepeaterConfig}
     */
    repeat: null,
    defaultBindProperty: null
  };
  compose() {
    const {
      align,
      href
    } = this;
    return {
      tag: href != null ? 'a' : 'button',
      class: {
        [`b-align-${align || 'end'}`]: 1,
        'b-icon': 1
      },
      // eslint-disable-next-line bryntum/no-listeners-in-lib
      listeners: {
        click: 'onInternalClick'
      }
    };
  }
  get focusElement() {
    return this.element;
  }
  get panel() {
    var _this$parent, _this$element;
    // Only fire toolClick if we are in a Panel's header.
    // If a Tool is used in any other context than a Panel tool config, it
    // should be used via its click and action events.
    if ((_this$parent = this.parent) !== null && _this$parent !== void 0 && _this$parent.isPanel && (_this$element = this.element) !== null && _this$element !== void 0 && _this$element.parentNode.matches('.b-panel-header')) {
      return this.parent;
    }
  }
  changeAlign(align) {
    return align; // replace Widget.changeAlign
  }

  onInternalClick(domEvent) {
    const me = this,
      {
        handler,
        panel
      } = me,
      bryntumEvent = {
        domEvent,
        tool: me
      };
    // Safari && FF trigger click on disabled button, Chrome does not. Handling it here
    if (me.disabled) {
      return;
    }
    /**
     * Fires when the tool is clicked
     * @event click
     * @param {Core.widget.Tool} source The Tool
     * @param {Event} domEvent DOM event
     */
    me.trigger('click', bryntumEvent);
    // A handler may have resulted in destruction.
    if (!me.isDestroyed) {
      /**
       * Fires when the default action is performed (the button is clicked)
       * @event action
       * @param {Core.widget.Tool} source The Tool
       * @param {Event} domEvent DOM event
       */
      me.trigger('action', bryntumEvent);
      if (!me.isDestroyed && (panel === null || panel === void 0 ? void 0 : panel.trigger('toolClick', bryntumEvent)) !== false) {
        handler && me.callback(handler, panel, [domEvent, panel, me]);
      }
    }
  }
  onInternalKeyDown(keyEvent) {
    const keyName = keyEvent.key.trim() || keyEvent.code;
    // Don't allow key invocations to bubble and trigger owning
    // widget's key handlers.
    if (keyName === 'Enter') {
      keyEvent.cancelBubble = true;
      keyEvent.stopPropagation();
    }
  }
  updateDisabled(disabled, was) {
    var _this$repeat;
    super.updateDisabled(disabled, was);
    disabled && ((_this$repeat = this.repeat) === null || _this$repeat === void 0 ? void 0 : _this$repeat.cancel());
  }
  changeRepeat(repeat, oldRepeat) {
    oldRepeat === null || oldRepeat === void 0 ? void 0 : oldRepeat.destroy();
    return repeat && ClickRepeater.new({
      element: this.element
    }, repeat);
  }
}
// Register this widget type with its Factory
Tool.initClass();
Tool._$name = 'Tool';

/**
 * @module Core/widget/panel/CollapseTool
 */
const rightRe = /right/i,
  autoAlign = tool => (tool.collapsed || tool.collapsing) &&
  // special case to align the expand tool with the collapse tool
  tool.owner.expandedHeaderDock === 'top' && tool.owner.collapsible.direction.match(rightRe) ? 'start' : 'end';
/**
 * This ensures the correct icon is used to represent the {@link Core.widget.Panel panel's}
 * {@link Core.widget.Panel#config-collapsed} state.
 * @extends Core/widget/Tool
 *
 * @classType collapsetool
 * @internal
 */
class CollapseTool extends Tool {
  static get $name() {
    return 'CollapseTool';
  }
  // Factoryable type name
  static get type() {
    return 'collapsetool';
  }
  static get configurable() {
    return {
      /**
       * Set to `false` to disable automatic adjustment of the {@link #config-align} config based on the state
       * of the panel's {@link Core.widget.Panel#config-collapsed} config and the
       * {@link Core.widget.panel.PanelCollapser#config-direction}.
       *
       * If this is set to a function, that function is called passing the owning `Panel` instance and its
       * return value is assigned to the {@link #config-align} config.
       * @config {Boolean|Function}
       * @default
       */
      autoAlign: true,
      collapsed: null,
      collapsing: null,
      collapsify: false,
      // ...unaffected when the panel is collapsed
      direction: 'up',
      // Our own setValues/getValues system should not set/get HTML content
      defaultBindProperty: null
    };
  }
  compose() {
    const {
      collapsed,
      direction
    } = this;
    return {
      class: {
        [`b-icon-collapse-${direction}`]: 1,
        'b-collapsed': collapsed
      }
    };
  }
  changeAutoAlign(v) {
    return v === true ? autoAlign : v;
  }
  syncAutoAlign() {
    const {
      autoAlign
    } = this;
    if (autoAlign) {
      this.align = autoAlign(this);
    }
  }
  updateAutoAlign() {
    this.syncAutoAlign();
  }
  updateCollapsed() {
    this.syncAutoAlign();
  }
  updateCollapsing() {
    this.syncAutoAlign();
  }
  updateDirection() {
    this.syncAutoAlign();
  }
}
// Register this widget type with its Factory
CollapseTool.initClass();
CollapseTool._$name = 'CollapseTool';

/**
 * @module Core/widget/panel/PanelCollapser
 */
const defaultedDirectionRe = /^(?:UP|DOWN|LEFT|RIGHT)$/,
  dockBeforeRe = /^(left|top)$/i,
  emptyObject$2 = {},
  headerDockRe = /^b-dock-(top|left|right|bottom)$/,
  revealerCls = 'b-panel-collapse-revealer',
  sideDockRe = /^(?:left|right)$/i,
  unflexCls = 'b-collapse-unflex',
  {
    round
  } = Math,
  canonicalDirection = ['up', 'down', 'left', 'right'].reduce((o, v) => {
    o[v.toUpperCase()] = o[v] = v;
    return o;
  }, {}),
  clipByDock = {
    top: ['top', 'bottom'],
    right: ['right', 'left'],
    bottom: ['bottom', 'top'],
    left: ['left', 'right']
  },
  collapseDirectionByPlacement = {
    hl: 'LEFT',
    hr: 'RIGHT',
    vb: 'DOWN',
    vt: 'UP'
  },
  crossAxis = {
    h: 'w',
    w: 'h'
  },
  dockByDirection = {
    up: 'top',
    right: 'right',
    down: 'bottom',
    left: 'left'
  },
  dockIsHorz = {
    top: false,
    right: true,
    bottom: false,
    left: true
  },
  directionByDock = {
    top: 'UP',
    right: 'RIGHT',
    bottom: 'DOWN',
    left: 'LEFT'
  },
  transverseTransform = {
    top: rect => `translate(0, -${round(rect.height || 0)}px)`,
    bottom: rect => `translate(0, ${round(rect.height || 0)}px)`,
    right: rect => `translate(${round(rect.width || 0)}px, 0)`,
    left: rect => `translate(-${round(rect.width || 0)}px, 0)`
  };
let idSeed = 0;
/**
 * Instances of this class are used to implement the {@link Core.widget.Panel#config-collapsible} config.
 *
 * For example, the following creates an instance of this class:
 *
 * ```javascript
 *      {
 *          type        : 'panel',
 *          collapsible : true
 *      }
 * ```
 *
 * In this mode, a panel will collapse inline, within its container.
 * @classtype inline
 */
class PanelCollapser extends Base.mixin(Factoryable) {
  static get $name() {
    return 'PanelCollapser';
  }
  // Factoryable type name
  static get type() {
    return 'inline';
  }
  static get configurable() {
    return {
      /**
       * An animation config object.
       * @config {Object} animation
       * @property {Number} [animation.duration=200] The duration of the animation (in milliseconds).
       */
      animation: {
        duration: 200
      },
      /**
       * Tracks whether or not the panel is collapsed.
       * @config {Boolean}
       * @private
       */
      collapsed: {
        value: null,
        $config: null,
        default: false
      },
      /**
       * Specifies the direction of panel collapse. The default value for this config is determined dynamically
       * based on the {@link Core.widget.Panel#config-header header's} `dock` property and the containing layout's
       * flex direction and, therefore, often does not need to be explicitly specified.
       *
       * This config can be any of the following:
       * - `'up'`
       * - `'down'`
       * - `'left'`
       * - `'right'`
       *
       * @config {'up'|'down'|'left'|'right'}
       */
      direction: null,
      /**
       * The tooltip to use for the collapse tool when the panel is expanded.
       * @config {String}
       */
      collapseTooltip: 'L{Collapse}',
      /**
       * The tooltip to use for the expand tool when the panel is collapsed.
       * @config {String}
       */
      expandTooltip: 'L{Expand}',
      panel: {
        value: null,
        $config: 'nullify'
      },
      /**
       * To support the panel's collapsed size, a minimum width and height may be assigned to the panel's header,
       * based on this config and the panel's positioning style.
       *
       * When a panel is collapsed it may need to retain the pre-collapse dimension perpendicular to the collapse
       * {@link #config-direction}. For example, the height of a panel that collapses to the left. The dimension
       * parallel to the collapse (the width in this example) may also need to be supported using the pre-collapse
       * size of the panel's header.
       *
       * When this config is set to `true`, or by default when the owning panel is `position: absolute`, both
       * axes are given a minimum size based on the panel's pre-collapse size. When this config is `false`, no
       * minimum sizes will be assigned.
       *
       * This config can also be a string containing the single letters 'w' and/or 'h' indicating which axis/axes
       * of the panel header should be assigned a minimum size. That is, 'w' to assign only a minimum width, 'h'
       * for only a minimum height, or 'wh' to assign both.
       *
       * @config {String|Boolean}
       * @internal
       */
      supportAxis: null,
      /**
       * The collapse/expand tool. The `type` of this instance should not be changed but the tool instance can be
       * configured in other ways via this config property.
       * @config {ToolConfig|Core.widget.Tool}
       */
      tool: {
        type: 'collapsetool',
        handler(ev) {
          var _this$collapsible;
          // NOTE: As a tool, our this pointer is the Panel so we use it to access the current collapser
          (_this$collapsible = this.collapsible) === null || _this$collapsible === void 0 ? void 0 : _this$collapsible.onCollapseClick(ev);
        }
      }
    };
  }
  static get factoryable() {
    return {
      defaultType: 'inline'
    };
  }
  get collapsing() {
    return this.collapsingExpanding === 'collapsing';
  }
  get collapsingExpanding() {
    var _this$currentOperatio;
    const state = (_this$currentOperatio = this.currentOperation) === null || _this$currentOperatio === void 0 ? void 0 : _this$currentOperatio.collapsing;
    return state == null ? null : state ? 'collapsing' : 'expanding';
  }
  get currentDock() {
    var _this$panel, _this$panel$header, _this$panel$header$do;
    return ((_this$panel = this.panel) === null || _this$panel === void 0 ? void 0 : (_this$panel$header = _this$panel.header) === null || _this$panel$header === void 0 ? void 0 : (_this$panel$header$do = _this$panel$header.dock) === null || _this$panel$header$do === void 0 ? void 0 : _this$panel$header$do.toLowerCase()) ?? 'top';
  }
  get expanding() {
    return this.collapsingExpanding === 'expanding';
  }
  get collapseTool() {
    var _this$panel2, _this$panel2$tools;
    return (_this$panel2 = this.panel) === null || _this$panel2 === void 0 ? void 0 : (_this$panel2$tools = _this$panel2.tools) === null || _this$panel2$tools === void 0 ? void 0 : _this$panel2$tools.collapse;
  }
  get collapseDim() {
    return sideDockRe.test(this.collapseDir) ? 'width' : 'height';
  }
  getCollapseDir(canonical) {
    let {
      direction,
      panel
    } = this;
    if (!direction || defaultedDirectionRe.test(direction)) {
      const placement = panel === null || panel === void 0 ? void 0 : panel.placement;
      if (placement) {
        direction = collapseDirectionByPlacement[placement];
      } else {
        var _panel$header;
        direction = directionByDock[(panel === null || panel === void 0 ? void 0 : (_panel$header = panel.header) === null || _panel$header === void 0 ? void 0 : _panel$header.dock) || 'top'];
      }
      // direction in this case will be uppercase so that we can tell later that it was a default value vs a
      // user-defined one
    }

    return canonical ? canonicalDirection[direction] : direction;
  }
  get collapseDir() {
    return this.getCollapseDir(true);
  }
  get collapseDock() {
    return this.collapseInfo[0];
  }
  get collapseInfo() {
    const {
        panel
      } = this,
      headerDock = panel.hasHeader && panel.expandedHeaderDock;
    let dock = dockByDirection[this.collapseDir],
      transverse = false;
    if (headerDock) {
      if (!(transverse = dockIsHorz[dock] !== dockIsHorz[headerDock])) {
        dock = headerDock;
      }
    }
    return [dock, transverse];
  }
  get toolsConfig() {
    const {
      direction,
      tool
    } = this;
    return tool && {
      collapse: ObjectHelper.assign({
        direction: direction.toLowerCase()
      }, tool)
    };
  }
  beforeCollapse(operation) {
    const {
        panel
      } = this,
      {
        element
      } = panel;
    // This is essentially a hide, so move focus back to whence it came
    if (element.contains(DomHelper.getActiveElement(element))) {
      panel.revertFocus(true);
    }
  }
  changeTool(tool) {
    const me = this,
      {
        panel
      } = me;
    if (me.isConfiguring || me.isDestroying || !panel || panel.isDestroying) {
      return tool;
    }
    panel.tools = {
      collapse: tool
    };
  }
  collapse(collapsed) {
    var _currentOperation, _currentOperation$ani;
    const me = this,
      {
        panel
      } = me,
      operation = {
        id: ++idSeed,
        completed: false,
        panel
      };
    let {
      currentOperation
    } = me;
    collapsed = collapsed ?? true;
    if (ObjectHelper.isObject(collapsed)) {
      operation.collapsed = true;
      ObjectHelper.assign(operation, collapsed);
      collapsed = operation.collapsed;
      delete operation.collapsed;
    }
    operation.collapsing = collapsed;
    operation.previous = currentOperation ?? null;
    if (collapsed !== me.collapsed) {
      // We aren't in the desired state (yet)
      if (currentOperation) {
        if (currentOperation.collapsing !== collapsed) {
          // we are not heading to the desired state, so revert it:
          operation.animation = currentOperation.animation.revert({
            finalize() {
              var _me$collapseFinalize;
              (_me$collapseFinalize = me.collapseFinalize) === null || _me$collapseFinalize === void 0 ? void 0 : _me$collapseFinalize.call(me, operation, true); // ?. in case we are destroyed
            }
          });

          operation.collapsing = collapsed;
          currentOperation = operation;
        }
      } else {
        // No currentOperation, so this is the first request to change state.
        // don't mutate our parameter or config object
        operation.animation = ObjectHelper.clone(('animation' in operation ? operation : me).animation);
        if (me.beforeCollapse(operation) !== false) {
          if (operation.animation) {
            operation.animation.finalize = complete => {
              var _me$collapseFinalize2;
              return (_me$collapseFinalize2 = me.collapseFinalize) === null || _me$collapseFinalize2 === void 0 ? void 0 : _me$collapseFinalize2.call(me, operation, complete);
            };
          }
          panel.changingCollapse = true;
          me[collapsed ? 'collapseBegin' : 'expandBegin'](operation);
          if (operation.animation) {
            currentOperation = operation;
          } else {
            operation.completed = true;
            me[collapsed ? 'collapseEnd' : 'expandEnd'](operation);
          }
          panel.changingCollapse = false;
          if (!operation.animation) {
            me.onComplete(collapsed ? 'collapse' : 'expand');
          }
        }
      }
    } else if (currentOperation && currentOperation.collapsing !== collapsed) {
      // We are still in the desired state but we are animating to the now undesired state...
      me[collapsed ? 'expandRevert' : 'collapseRevert'](operation);
      // revert the animation and clear it when done
      operation.animation = currentOperation.animation.revert({
        finalize() {
          var _me$collapseFinalize3;
          (_me$collapseFinalize3 = me.collapseFinalize) === null || _me$collapseFinalize3 === void 0 ? void 0 : _me$collapseFinalize3.call(me, operation, false); // ?. in case we are destroyed
        }
      });

      currentOperation = operation;
    }
    // else if (currentOperation) we are already reverting
    me.currentOperation = currentOperation;
    return ((_currentOperation = currentOperation) === null || _currentOperation === void 0 ? void 0 : (_currentOperation$ani = _currentOperation.animation) === null || _currentOperation$ani === void 0 ? void 0 : _currentOperation$ani.done()) ?? Promise.resolve(collapsed === me.collapsed);
  }
  collapseFinalize(operation, complete) {
    const me = this,
      {
        currentOperation,
        panel
      } = me,
      action = panel.collapsed ? 'expand' : 'collapse';
    if (currentOperation === operation) {
      me.currentOperation = null;
      operation.completed = complete;
      panel.changingCollapse = true;
      me[action + 'End'](operation);
      panel.changingCollapse = false;
      complete && me.onComplete(action);
    }
  }
  applyHeaderDock(collapsed, flush = true) {
    const me = this,
      {
        currentDock,
        panel
      } = me,
      dock = collapsed ? me.collapseDock : panel.expandedHeaderDock;
    if (dock !== currentDock && panel.hasHeader) {
      panel.header = {
        dock
      };
      flush && panel.recompose.flush();
    }
  }
  composeHeader(header) {
    const {
        panel
      } = this,
      {
        class: cls
      } = header,
      dock = panel.expandedHeaderDock || Object.keys(cls).filter(k => cls[k] && headerDockRe.test(k)).map(k => headerDockRe.exec(k)[1][0]);
    cls[revealerCls] = 1;
    cls[`b-collapsible-${dock[0]}${this.collapseDir[0]}`] = 1;
    return header;
  }
  composeTitle(title) {
    title.class[revealerCls] = 1;
    return title;
  }
  collapseBegin(operation) {
    var _panel$headerElement;
    const me = this,
      {
        animation
      } = operation,
      {
        collapseDim,
        collapseTool,
        panel
      } = me,
      {
        element,
        placement
      } = panel,
      [collapseDock, transverse] = me.collapseInfo,
      collapseToolClasses = collapseTool === null || collapseTool === void 0 ? void 0 : collapseTool.element.classList,
      unflex = !placement || placement[0] === 'h' && collapseDim === 'width' || placement[0] === 'v' && collapseDim === 'height';
    me.configuredWidth = panel._lastWidth;
    me.configuredHeight = panel._lastHeight;
    me.transverseCollapse = transverse;
    me.applyHeaderDock(true);
    // Lock the bodyWrap to its current size while we animate the height of the outer element and clip it. We
    // also leave the bodyWrap locked to its expanded size to avoid crushing the content while collapsed since
    // that could cause virtual rendering widgets to have 0 height to work with and explode or at least waste
    // time adjusting back and forth.
    const panelRect = panel.rectangle(),
      bodyWrapRect = me.lockInnerSize().moveTo(0, 0),
      // we must lockInnerSize even if !animation
      bodyWrapClipRect = bodyWrapRect.clone(),
      clipDir = clipByDock[collapseDock],
      headerRect = (_panel$headerElement = panel.headerElement) === null || _panel$headerElement === void 0 ? void 0 : _panel$headerElement.getBoundingClientRect(),
      collapsedSize = round((headerRect === null || headerRect === void 0 ? void 0 : headerRect[collapseDim]) || 0);
    element.classList.toggle(unflexCls, unflex);
    if (animation) {
      bodyWrapClipRect[clipDir[0]] = bodyWrapClipRect[clipDir[1]];
      element.classList.add('b-collapsing');
      // Flip to collapsed while skipping the animation (via b-collapsing)
      collapseToolClasses === null || collapseToolClasses === void 0 ? void 0 : collapseToolClasses.add('b-collapsed', 'b-collapsing');
      if (collapseTool) {
        collapseTool.collapsing = true;
      }
      if (collapseToolClasses) {
        collapseToolClasses.remove('b-collapsed'); // put the tool back to pre-collapse state
        panel.rectangle(); // force a layout to allow us to enable transitions
        collapseToolClasses.remove('b-collapsing'); // enable transitions
        collapseToolClasses.add('b-collapsed'); // start the tool's transition
      }

      animation.element = element;
      animation.retain = true;
      animation[collapseDim] = {
        from: round(panelRect[collapseDim]),
        to: collapsedSize
      };
      // While we animate the panel, we also need to clip the bodyWrap or it would be exposed on cases where
      // overflow=visible (like a tooltip w/anchor element)... doubtful we'd collapse such a panel but perhaps
      // there are  (or will be) other reasons to set overflow=visible on the panel.
      animation.items = [{
        element: me.innerElement,
        retain: false,
        clip: {
          from: `rect(${bodyWrapRect})`,
          to: `rect(${bodyWrapClipRect})`
        }
      }];
      if (transverse) {
        animation.items.push({
          element: panel.headerElement,
          duration: animation.duration,
          retain: false,
          transform: {
            from: transverseTransform[collapseDock](headerRect),
            to: `translate(0, 0)`
          }
        });
      }
      operation.animation = Animator.run(animation);
    } else {
      // When animating we retain this style, so we need to just jam it on the element now since we aren't doing
      // the animation:
      element.style[collapseDim] = `${collapsedSize}px`;
      if (collapseTool) {
        collapseToolClasses.add('b-collapsing', 'b-collapsed'); // disable transition & snap to correct state
        collapseTool.rectangle(); // force a layout
        collapseToolClasses.remove('b-collapsing'); // now we can remove this cls w/o triggering a transition
      }
    }
  }

  collapseEnd(operation) {
    const me = this,
      {
        collapseTool
      } = me;
    me.panel.element.classList.remove('b-collapsing');
    if (collapseTool) {
      collapseTool.collapsing = false;
    }
    if (operation.completed) {
      me.collapsed = true;
    } else {
      me.applyHeaderDock(false);
      me.restoreConfiguredSize();
      me.lockInnerSize(false);
    }
  }
  collapseRevert(operation) {
    var _this$collapseTool;
    (_this$collapseTool = this.collapseTool) === null || _this$collapseTool === void 0 ? void 0 : _this$collapseTool.element.classList.remove('b-collapsed');
  }
  expandBegin(operation) {
    const me = this,
      {
        animation
      } = operation,
      {
        collapseDim,
        collapseTool,
        panel
      } = me,
      [collapseDock, transverse] = me.collapseInfo,
      {
        element
      } = panel,
      elementClassList = element.classList,
      unflex = elementClassList.contains(unflexCls),
      fromRect = panel.rectangle();
    elementClassList.remove('b-collapsed', 'b-collapsing');
    // This style is retained by the collapse animation and must be cleared to get a right measurement of the
    // expanded panel
    panel.element.style[collapseDim] = '';
    me.restoreConfiguredSize();
    me.lockInnerSize(false); // unlock the bodyWrap size
    const toRect = panel.rectangle(),
      // Lock the bodyWrap to its current size while we animate the height of the outer element and unclip it:
      bodyWrapRect = me.lockInnerSize().moveTo(0, 0),
      bodyWrapClipRect = bodyWrapRect.clone(),
      clipDir = clipByDock[me.collapseDock];
    collapseTool === null || collapseTool === void 0 ? void 0 : collapseTool.element.classList.remove('b-collapsed');
    if (animation) {
      bodyWrapClipRect[clipDir[0]] = bodyWrapClipRect[clipDir[1]];
      elementClassList.add('b-collapsed', 'b-expanding');
      unflex && elementClassList.add(unflexCls);
      animation.element = element;
      animation[collapseDim] = {
        from: round(fromRect[collapseDim]),
        to: round(toRect[collapseDim])
      };
      animation.items = [{
        element: me.innerElement,
        retain: false,
        clip: {
          from: `rect(${bodyWrapClipRect})`,
          to: `rect(${bodyWrapRect})`
        }
      }];
      if (transverse) {
        animation.items.push({
          element: panel.headerElement,
          duration: animation.duration,
          retain: false,
          transform: {
            from: `translate(0, 0)`,
            to: transverseTransform[collapseDock](fromRect)
          }
        });
      }
      operation.animation = Animator.run(animation);
    }
  }
  expandEnd(operation) {
    const me = this;
    me.panel.element.classList.remove('b-expanding');
    if (operation.completed) {
      me.collapsed = false;
      me.applyHeaderDock(false);
      me.restoreConfiguredSize();
      me.lockInnerSize(false);
    }
  }
  expandRevert(operation) {
    var _this$collapseTool2;
    (_this$collapseTool2 = this.collapseTool) === null || _this$collapseTool2 === void 0 ? void 0 : _this$collapseTool2.element.classList.add('b-collapsed');
  }
  get innerElement() {
    return this.panel.collapseWrapElement || this.panel.bodyWrapElement;
  }
  get innerSizeElement() {
    return this.transverseCollapse ? this.panel.element : this.innerElement;
  }
  get supportAxis() {
    let {
      _supportAxis
    } = this;
    const fullSupport = _supportAxis === true;
    if (fullSupport || _supportAxis == null) {
      _supportAxis = this.collapseDim[0]; // 'w' or 'h'
      if (fullSupport || DomHelper.getStyleValue(this.panel.element, 'position') === 'absolute') {
        _supportAxis += crossAxis[_supportAxis];
      }
    }
    return _supportAxis || '';
  }
  lockInnerSize(lock = true) {
    const me = this,
      {
        innerElement,
        panel
      } = me,
      supportAxis = lock ? me.supportAxis : '',
      panelEl = panel.element,
      headerEl = panel.headerElement,
      headerRect = lock && headerEl && Rectangle.from(headerEl, panelEl),
      innerRect = lock && Rectangle.from(me.innerSizeElement, panelEl),
      innerStyle = innerElement.style;
    // We have to prop up the cross-axis of the panel header in cases where the panel is not receiving a size from
    // its container (an auto layout). Otherwise, the header may shrink in width (when docked top) once the bodyWrap
    // flips to position:absolute... it will no longer be providing a natural size to prop up the panel, so we
    // shift that responsibility to the header element while we are collapsed.
    if (headerEl) {
      headerEl.style.minWidth = supportAxis.includes('w') ? `${headerRect.width}px` : '';
      headerEl.style.minHeight = supportAxis.includes('h') ? `${headerRect.height}px` : '';
    }
    // We must set w/h on the inner element before we flip it to position:absolute to avoid layout changes on items
    // in the panel (like grids)
    innerStyle.width = lock ? `${innerRect.width}px` : '';
    innerStyle.height = lock ? `${innerRect.height}px` : '';
    innerElement.classList[lock ? 'add' : 'remove']('b-panel-collapse-size-locker');
    return innerRect;
  }
  onCollapseClick(e) {
    let collapsed = this.collapsing ? false : this.expanding ? true : !this.collapsed;
    if (e.altKey) {
      collapsed = {
        animation: null,
        collapsed
      };
    }
    this.collapse(collapsed);
  }
  onComplete(action) {
    var _this$panel3;
    (_this$panel3 = this.panel) === null || _this$panel3 === void 0 ? void 0 : _this$panel3.trigger(action);
  }
  onHeaderClick({
    event
  }) {
    if (event.button === 0 && this.panel.collapsed && event.target.classList.contains(revealerCls)) {
      this.onRevealerClick();
    }
  }
  onPanelConfigChange({
    name,
    value
  }) {
    const me = this,
      {
        panel
      } = me;
    if (name === 'collapsed') {
      if (panel.isPainted) {
        me.collapsed = value;
      }
    } else if (name === 'header' && !panel.changingCollapse) {
      me.syncDirection();
    }
  }
  onPanelPaint() {
    this.syncDirection();
    if (this.panel.collapsed && !this.collapsed) {
      this.collapse({
        animation: null,
        collapsed: true
      });
    }
  }
  onRevealerClick() {
    this.panel._collapse({
      collapsed: false
    });
  }
  restoreConfiguredSize(which) {
    const {
      configuredHeight,
      configuredWidth,
      panel
    } = this;
    which = which ?? 'wh';
    panel.element.classList.remove(unflexCls);
    if (configuredWidth != null && which.includes('w')) {
      panel.width = configuredWidth;
    }
    if (configuredHeight != null && which.includes('h')) {
      panel.height = configuredHeight;
    }
  }
  splitHeaderItems({
    as,
    dock
  } = emptyObject$2) {
    var _this$panel4;
    return (_this$panel4 = this.panel) === null || _this$panel4 === void 0 ? void 0 : _this$panel4.splitHeaderItems({
      as,
      dock,
      alt: true
    });
  }
  syncDirection() {
    const me = this,
      {
        direction
      } = me;
    if (!direction || defaultedDirectionRe.test(direction)) {
      // getCollapseDir() returns uppercase values when they are being defaulted, so we can tell if the value
      // is from the user (which must be lowercase)
      me.direction = me.getCollapseDir();
    }
  }
  changeCollapsed(collapsed) {
    // Falsy must be coerced to false so that non-changes do not propagate
    return Boolean(collapsed);
  }
  updateCollapsed(collapsed) {
    const {
      collapseTool,
      panel
    } = this;
    if (panel) {
      panel.collapsed = collapsed;
      panel.element.classList[collapsed ? 'add' : 'remove']('b-collapsed');
    }
    if (collapseTool) {
      collapseTool.collapsed = collapsed;
    }
  }
  updateDirection(direction) {
    const {
      collapseTool,
      panel
    } = this;
    if (collapseTool) {
      collapseTool.direction = canonicalDirection[direction];
    }
    if (panel !== null && panel !== void 0 && panel.rendered) {
      panel.recompose();
    }
  }
  updatePanel(panel) {
    var _me$panelChangeDetach;
    const me = this;
    me.syncDirection();
    (_me$panelChangeDetach = me.panelChangeDetacher) === null || _me$panelChangeDetach === void 0 ? void 0 : _me$panelChangeDetach.call(me);
    me.panelChangeDetacher = panel && FunctionHelper.after(panel, 'onConfigChange', 'onPanelConfigChange', me, {
      return: false
    });
  }
  wrapCollapser(key, body) {
    var _panel$tools;
    const me = this,
      [collapseDock, transverse] = me.collapseInfo;
    if (!transverse) {
      return [key, body];
    }
    const {
        collapseDir,
        panel
      } = me,
      {
        expandedHeaderDock,
        header: panelHeader,
        uiClassList
      } = panel,
      recollapse = (_panel$tools = panel.tools) === null || _panel$tools === void 0 ? void 0 : _panel$tools.recollapse,
      [before, after] = me.splitHeaderItems({
        as: 'element',
        dock: collapseDock
      }),
      title = panel.hasHeader ? panel.title || (panelHeader === null || panelHeader === void 0 ? void 0 : panelHeader.title) || '\xA0' : null,
      headerElement = title && {
        tag: 'header',
        class: new DomClassList({
          ...uiClassList,
          [`b-dock-${expandedHeaderDock}`]: 1,
          'b-panel-header': 1,
          'b-panel-collapser-header': 1
        }, panelHeader === null || panelHeader === void 0 ? void 0 : panelHeader.cls),
        children: [...before, {
          reference: 'collapserTitleElement',
          html: title,
          class: {
            ...uiClassList,
            [`b-align-${(panelHeader === null || panelHeader === void 0 ? void 0 : panelHeader.titleAlign) || 'start'}`]: 1,
            'b-header-title': 1
          }
        }, ...after]
      };
    if (recollapse) {
      recollapse.direction = collapseDir;
    }
    return ['collapseWrapElement', {
      class: {
        ...uiClassList,
        [`b-panel-collapser-header-${expandedHeaderDock}`]: 1,
        [`b-panel-collapser-${collapseDir}`]: 1,
        [`b-${dockIsHorz[expandedHeaderDock] ? 'h' : 'v'}box`]: 1,
        'b-panel-collapser': 1,
        'b-box-center': 1
      },
      children: dockBeforeRe.test(expandedHeaderDock) ? {
        collapserHeaderElement: headerElement,
        [key]: body
      } : {
        [key]: body,
        collapserHeaderElement: headerElement
      }
    }];
  }
}
PanelCollapser.maps = {
  clipByDock,
  dockByDirection,
  dockIsHorz
};
// Register this widget type with its Factory
PanelCollapser.initClass();
PanelCollapser._$name = 'PanelCollapser';

/**
 * @module Core/util/DynamicObject
 */
const PENDING = Symbol('pendingCreate');
/**
 * This class is used to manage dynamic creation and configuration of individual properties of an object. This pattern
 * is used to allow the names of an object to each represent a dynamically instantiated object. For example, the
 * `features` config of Calendar is defined like so:
 *
 * ```javascript
 *  class Calendar extends ... {
 *      static get configurable() {
 *          return {
 *              features : {
 *                  drag : {
 *                      // configs for Drag feature
 *                  }
 *              }
 *          }
 *      }
 *  }
 * ```
 *
 * This class is used to manage the `features` objects in the above case. The `drag` property value is promoted from
 * the config object defined by the class and user instance on first request. Like config properties themselves, these
 * features may access other features during their initialization. These accesses are trapped by this class to ensure
 * the config object is promoted to an instantiated instance.
 *
 * A {@link #config-factory} is provided to this object to allow it to create instances from names like `'drag'`.
 * @internal
 */
class DynamicObject extends Base {
  static get prototypeProperties() {
    return {
      /**
       * Optional function that will be passed an instance prior to destroying it.
       * @param {String} name The property name in the Dynamic object by which the new instance may be referenced.
       * @param {Object} instance The value of the property.
       * @config {Function}
       */
      cleanup: null,
      /**
       * Optional name of the config property managed by this instance. If changes are made directly, this
       * property is used to run the `onConfigChange` method of the `owner`.
       * @config {String}
       */
      configName: null,
      /**
       * Optional function to call as instances are created. Each new instance is passed to this function.
       * @param {Object} instance The newly created instance.
       * @param {String} key The property name in the dynamic object by which the new instance may be referenced.
       * @config {Function}
       */
      created: null,
      /**
       * The {@link Core.mixin.Factoryable factory} to use to create instances.
       * @config {Object}
       */
      factory: null,
      /**
       * By default, the name of the member is used for the type. Set this config to `true` to also allow the
       * config object for a property to contain a `type` property. Set this to `false` to ignore the name of the
       * member and rely on the {@link #config-factory} to process the config object.
       * @config {Boolean|String}
       * @default
       */
      inferType: 'name',
      /**
       * The owning object to pass along to the instances as the `ownerName` property.
       * @config {Object}
       */
      owner: null,
      /**
       * The property name by which to store the `owner` on each instance.
       * @config {String}
       */
      ownerName: null,
      /**
       * Set to `false` to prevent using a `Proxy` even if that JavaScript platform feature is available. Using
       * a `Proxy` is ideal because it allows for all forms of access to the dynamic properties to be handled
       * instead of only those that have predefined configuration values.
       * @config {Boolean}
       * @private
       */
      proxyable: typeof Proxy !== 'undefined',
      /**
       * Optional function that will be passed a config object prior to instantiating an object. This function
       * can either modify the passed object or return a new object.
       * @param {Object} config The config object used to create the object
       * @param {String} name The property name in the Dynamic object by which the new instance may be referenced.
       * @config {Function}
       */
      setup: null,
      /**
       * Optional function that will be passed a raw config object prior to processing and the value it returns
       * replaces the raw value. This function is used to transform strings or arrays (for example) into proper
       * config objects.
       * @param {*} config The original value of the config object parameter
       * @config {Function}
       */
      transform: null
    };
  }
  static get properties() {
    return {
      /**
       * Holds config objects for each defined object. These are used to hold class and instance config values
       * and use them to create instances on first request, or when `flush()` is called. Further, if the instance
       * is initially assigned instead of retrieved, these values act as the defaults for the instance and are
       * combined with those provided in the assignment.
       * @member {Object} defaults
       * @private
       */
      defaults: {},
      /**
       * This object holds the actual instances that are retrieved by the dynamic accessor or `Proxy`.
       * @member {Object} instances
       * @private
       */
      instances: {},
      /**
       * The object that contains the dynamic accessors for each instance. This object is not used when using a
       * `Proxy`.
       * @member {Object} object
       * @private
       */
      object: Object.create({})
    };
  }
  /**
   * Returns the `Proxy` instance used to manage dynamic assignments. If the JavaScript platform does not support the
   * `Proxy` class, this will be `null`.
   * @property {Proxy}
   * @private
   */
  get proxy() {
    const me = this;
    let proxy = null;
    if (me.proxyable) {
      proxy = new Proxy(me.instances, {
        get(o, name) {
          return me.get(name);
        },
        set(o, name, value) {
          me.set(name, value);
          return true;
        },
        deleteProperty(o, name) {
          me.set(name, null);
          return true;
        }
      });
    }
    // Replace our getter with the result for quicker future use.
    Reflect.defineProperty(me, 'proxy', {
      configurable: true,
      // allow destroy() to delete it
      value: proxy
    });
    return proxy;
  }
  /**
   * Returns the object that contains the dynamic properties. This may be a `Proxy` instance or an object with getter
   * and setter accessors.
   * @property {Object}
   * @internal
   */
  get target() {
    return this.proxy || this.object;
  }
  /**
   * This method establishes the initial definition of a dynamic property. When using a `Proxy`, this method simply
   * needs to cache away the initial config for use by the getter. When `Proxy` is unavailable, this method will
   * also defined a getter/setter to intercept access to the dynamic property.
   * @param {String} name The name of the dynamic property.
   * @param {Object} config The initial config object for the dynamic property.
   * @private
   */
  define(name, config) {
    const me = this,
      {
        transform
      } = me,
      transformed = transform ? transform(config, name) : config,
      instantiated = ObjectHelper.isInstantiated(transformed);
    me.instances[name] = PENDING;
    if (!instantiated) {
      me.setDefaults(name, transformed);
    }
    // We provide get/set accessors on our `object` so that we can create the instance on first use and provide
    // the correct defaults. The setter also handles reassignment and reconfiguration. These accessors are
    // placed on the prototype of `object` so that we can add/remove the same accessors from `object` itself.
    // This allows users of the object to see the correct number of "own" keys for enumeration.
    me.defineProp(name, true);
    if (instantiated) {
      me.set(name, transformed);
    }
  }
  /**
   * Define the get/set accessors for `name` on our `object` or its prototype.
   * @param {String} name
   * @param {Boolean} [base] Pass `true` to indicate the property should be defined on the prototype.
   * @private
   */
  defineProp(name, base) {
    const me = this,
      {
        object
      } = me;
    if (!me.proxy) {
      Reflect.defineProperty(base ? Object.getPrototypeOf(object) : object, name, {
        configurable: !base,
        enumerable: true,
        get() {
          return me.get(name);
        },
        set(value) {
          return me.set(name, value);
        }
      });
    }
  }
  /**
   * Ensures that all defined members are touched to trigger their creation.
   * @internal
   */
  flush() {
    const me = this;
    // Iterate the defaults object to loop over all the defined items:
    try {
      var _me$afterConfigureOwn;
      me.updating = true;
      for (const name in me.defaults) {
        me.get(name);
      }
      me.afterConfigureOwner = (_me$afterConfigureOwn = me.afterConfigureOwner) === null || _me$afterConfigureOwn === void 0 ? void 0 : _me$afterConfigureOwn.call(me);
    } finally {
      me.updating = false;
    }
  }
  /**
   * Returns (lazily creating as necessary) the value of a dynamic property given its name.
   * @param {String} name
   * @returns {Object}
   * @private
   */
  get(name) {
    const {
      defaults,
      instances
    } = this;
    if (instances[name] === PENDING) {
      this.set(name, PENDING);
    }
    // Return null for defined instances that have been nulled out and undefined otherwise:
    return instances[name] || defaults[name] && null;
  }
  /**
   * Sets the value of a dynamic property given its name and value.
   * @param {String} name
   * @param {Object} value
   * @private
   */
  set(name, value) {
    const me = this,
      {
        cleanup,
        configName,
        defaults,
        factory,
        instances,
        owner,
        setup,
        transform,
        updating
      } = me,
      inform = owner && configName && !updating,
      was = instances[name] === PENDING ? null : instances[name],
      instance = factory.reconfigure(was, value === PENDING ? {} : value || null, {
        cleanup: cleanup && (instance => cleanup(instance, name)),
        defaults: defaults[name] || me.setDefaults(name, {}),
        owner: me.owner,
        setup: setup && ((config, type, defaults) => setup(config, name, type, defaults)),
        transform: transform && (config => transform(config, name))
      });
    if (instance !== was) {
      const before = inform && {
        ...instances
      };
      instances[name] = instance;
      if (instance) {
        var _me$created;
        me.defineProp(name);
        (_me$created = me.created) === null || _me$created === void 0 ? void 0 : _me$created.call(me, instance, name);
      } else {
        delete me.object[name];
        delete instances[name];
      }
      if (inform) {
        owner.onConfigChange({
          name: configName,
          config: owner.$meta.configs[configName],
          value: me.target,
          was: before
        });
      }
    }
  }
  /**
   * Stores the default config values for use in the factory reconfiguration process.
   * @param {String} name The name and default type of the dynamic property. Depending on {@link #config-inferType},
   * this may not be overridden by a type property in the config object.
   * @param {Object} config The config object.
   * @returns {Object}
   * @private
   */
  setDefaults(name, config) {
    const {
        defaults,
        factory,
        inferType,
        instances,
        owner,
        ownerName
      } = this,
      {
        typeKey
      } = factory.factoryable;
    config = config === true ? {} : ObjectHelper.assign({}, config); // copy props even from prototype
    if (inferType === 'name' || inferType === true && !config[typeKey]) {
      config[typeKey] = name;
    }
    // Store this object as the "owner" on the config object so instances can access their creating object:
    if (ownerName) {
      config[ownerName] = owner;
    }
    config.beforeConfigure = instance => {
      // Ensure the feature is injected into the features object before initialization so that it is
      // available to call chains from its initialization.
      instances[name] = instance;
    };
    return defaults[name] = config;
  }
  /**
   * Updates the members of `object` based on the provided configuration.
   * @param {Object} members The configuration for the instances of `object`.
   * @internal
   */
  update(members) {
    const me = this,
      {
        owner
      } = me;
    let name, config;
    try {
      me.updating = true;
      if (members) {
        // We prime the features so that if any configuration code accesses a feature, it will self initialize,
        // but if not, they will remain in a primed state until afterConfigure.
        for (name in members) {
          config = members[name];
          if (me.defaults[name]) {
            // if (already defined)
            me.set(name, config);
          } else if (config) {
            me.define(name, config);
          }
        }
        // NOTE: we leave alone any existing features that were not present in the given object. To remove a
        // feature, you must set it to null or set all features to null.
      } else {
        for (name in me.instances) {
          me.set(name, null);
        }
      }
    } finally {
      me.updating = false;
    }
    if (owner) {
      // Normally we wait for afterConfigure to create all the objects, but if we are being called after that
      // point in the life cycle, we need to flush them out now. We still use the same delay technique in case
      // the user adds multiple properties dynamically.
      if (!owner.isConfiguring) {
        me.flush();
      } else if (!me.afterConfigureOwner) {
        // Since we are being called while the owner isConfiguring, set a hook on owner.afterConfigure() so
        // that we can make good on creating the child objects.
        me.afterConfigureOwner = FunctionHelper.before(owner, 'afterConfigure', 'flush', me);
      }
    }
  }
}
DynamicObject.initClass();
DynamicObject._$name = 'DynamicObject';

/**
 * @module Core/widget/mixin/Toolable
 */
const emptyArray$2 = [],
  emptyObject$1 = {},
  toolConfigs = {
    align: 1,
    // hidden : 1,
    weight: 1
  };
/**
 * A mixin that manages {@link #config-tools}.
 *
 * @mixin
 * @mixinbase Widget
 */
var Toolable = (Target => class Toolable extends (Target || Widget) {
  static get $name() {
    return 'Toolable';
  }
  static get configurable() {
    return {
      /**
       * The {@link Core.widget.Tool tools} as specified by the {@link #config-tools} configuration. Each is a
       * {@link Core.widget.Tool} instance which may be hidden, shown and observed and styled just like any other
       * widget.
       * @member {Object<String,Core.widget.Tool>} tools
       * @category Content
       */
      /**
       * The {@link Core.widget.Tool tools} to add either before or after the `title` in the Panel header. Each
       * property name is the reference by which an instantiated tool may be retrieved from the live
       * `{@link #property-tools}` property.
       * @config {Object<String,ToolConfig>}
       * @category Content
       */
      tools: {
        value: null,
        $config: {
          nullify: true
        }
      },
      /**
       * An object containing config defaults for corresponding {@link #config-tools} objects with a matching name.
       *
       * This object contains a key named `'*'` with default config properties to apply to all tools. This
       * object provides the default `type` (`'tool').
       * @config {Object} toolDefaults
       * @private
       */
      toolDefaults: {
        '*': {
          type: 'tool',
          align: 'end'
        }
      }
    };
  }
  byWeightSortFn(a, b) {
    return (a.weight || 0) - (b.weight || 0);
  }
  byWeightReverseSortFn(a, b) {
    return (b.weight || 0) - (a.weight || 0);
  }
  gatherTools({
    align,
    alt,
    refs
  } = emptyObject$1) {
    const {
        collapsed,
        tools
      } = this,
      options = {
        collapsed,
        alt
      };
    let ret = [],
      alignment,
      key,
      i,
      item,
      tool;
    for (key in tools) {
      var _tool, _tool$align, _tool2;
      tool = tools[key];
      // Tools redefine "align" config to be a simple string, but other widgets promote align config to an align
      // spec object
      alignment = ((_tool = tool) === null || _tool === void 0 ? void 0 : (_tool$align = _tool.align) === null || _tool$align === void 0 ? void 0 : _tool$align.align) ?? ((_tool2 = tool) === null || _tool2 === void 0 ? void 0 : _tool2.align) ?? 'end';
      if (alignment === align && tool.isCollapsified(options)) {
        ret.push(tool);
      }
    }
    ret.sort(this[align === 'end' ? 'byWeightReverseSortFn' : 'byWeightSortFn']);
    if (refs) {
      const asWidget = refs === 'widget',
        asRefs = {};
      for (i = 0; i < ret.length; ++i) {
        item = ret[i];
        asRefs[item.ref] = asWidget ? item : item.element;
      }
      ret = asRefs;
    }
    return ret;
  }
  getEndTools({
    alt,
    refs
  } = emptyObject$1) {
    return this.gatherTools({
      align: 'end',
      alt,
      refs
    });
  }
  getStartTools({
    alt,
    refs
  } = emptyObject$1) {
    return this.gatherTools({
      align: 'start',
      alt,
      refs
    });
  }
  get childItems() {
    return [...this.getStartTools(), ...(this._items || emptyArray$2), ...this.getEndTools()];
  }
  changeTools(tools, oldTools) {
    const me = this,
      manager = me.$tools || (me.$tools = new DynamicObject({
        configName: 'tools',
        factory: Widget,
        inferType: false,
        // the name of a tool in the tools object is not its type
        owner: me,
        created(instance) {
          var _instance$syncRotatio, _me$header;
          instance.innerItem = false;
          (_instance$syncRotatio = instance.syncRotationToDock) === null || _instance$syncRotatio === void 0 ? void 0 : _instance$syncRotatio.call(instance, (_me$header = me.header) === null || _me$header === void 0 ? void 0 : _me$header.dock);
          FunctionHelper.after(instance, 'onConfigChange', (ret, {
            name
          }) => {
            if (toolConfigs[name]) {
              me.onConfigChange({
                name: 'tools',
                value: manager.target
              });
            }
          });
          me.onChildAdd(instance);
        },
        setup(config, name) {
          config = ObjectHelper.merge({}, me.toolDefaults['*'], me.toolDefaults[name], config);
          config.parent = me; // so parent can be accessed during construction
          config.ref = name;
          return config;
        }
      }));
    manager.update(tools);
    if (!oldTools) {
      // Only return the target once. Further calls are processed above so we need to return undefined to ensure
      // onConfigChange is called. By returning the same target on 2nd+ call, it passes the === test and won't
      // trigger onConfigChange.
      return manager.target;
    }
  }
  get widgetClass() {}
});

/**
 * @module Core/widget/layout/Box
 */
const directionCls = ['b-hbox', 'b-vbox'],
  syncAlign = {
    name: 'align',
    style: 'alignItems'
  },
  syncContentAlign = {
    name: 'contentAlign',
    style: 'alignContent'
  },
  syncDirection = {
    name: 'direction',
    style: 'flexDirection'
  },
  syncJustify = {
    name: 'justify',
    style: 'justifyContent',
    classes: ['stretch']
  },
  syncWrap = {
    name: 'wrap',
    style: 'flexWrap',
    map: {
      false: 'nowrap',
      true: 'wrap',
      reverse: 'wrap-reverse'
    }
  };
/**
 * A layout that applies `display: flex` to the {@link Core.widget.Widget#property-contentElement contentElement} of
 * its container to layout child items. This defaults to a horizontal layout of items, also known as an `'hbox'`.
 *
 * ```javascript
 *  layout : {
 *      type : 'box'   // or equivalently, 'hbox'
 *  }
 * ```
 *
 * @extends Core/widget/layout/Layout
 * @layout
 * @classtype box
 */
class Box extends Layout {
  static $name = 'Box';
  static type = 'box';
  static alias = 'hbox';
  static configurable = {
    containerCls: 'b-box-container',
    itemCls: 'b-box-item',
    /**
     * Sets the [align-items](https://developer.mozilla.org/en-US/docs/Web/CSS/align-items) style of the
     * {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}.
     * @config {String} align
     * @default 'stretch'
     */
    align: null,
    /**
     * Sets the [align-content](https://developer.mozilla.org/en-US/docs/Web/CSS/align-content) style of the
     * {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}.
     * @config {String} contentAlign
     * @default 'normal'
     */
    contentAlign: null,
    /**
     * Sets the [direction](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction) style of the
     * {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}.
     * This config is not set directly. Set {@link #config-horizontal}, {@link #config-vertical}, and/or
     * {@link #config-reverse} instead.
     * @config {String} direction
     * @private
     */
    direction: null,
    /**
     * Set this value to `false` to set the [flex-direction](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction)
     * style of the {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}
     * to `column`. Or alternatively, set {@link #config-vertical} to `true`.
     * @config {Boolean} horizontal
     * @default
     */
    horizontal: true,
    /**
     * Sets the [justify-content](https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content) style of the
     * {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}.
     * @config {String} justify
     * @default 'flex-start'
     */
    justify: null,
    /**
     * Set this value to `true` to add `'-reverse'` to the [flex-direction](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction)
     * style of the {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}.
     * This config combines with {@link #config-horizontal} or {@link #config-vertical} to set the `flex-direction`
     * style.
     * @config {Boolean} reverse
     * @default false
     */
    reverse: null,
    /**
     * Sets the [flex-wrap](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-wrap) style of the
     * {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}.
     *
     * The value of `true` is equivalent to `'wrap'`, `false` is equivalent to `'nowrap'`, and `'reverse'` is
     * equivalent to `'wrap-reverse'`.
     *
     * ```javascript
     *  layout : {
     *      type : 'box',
     *      wrap : false        // equivalent to 'nowrap'
     *      wrap : true         // equivalent to 'wrap'
     *      wrap : 'reverse'    // equivalent to 'wrap-reverse'
     *  }
     * ```
     * @config {String|Boolean} wrap
     * @default false
     */
    wrap: null
  };
  /**
   * Set this value to `true` to set the [flex-direction](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction)
   * style of the {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}
   * to `column`. Or alternatively, set {@link #config-horizontal} to `false`.
   * @config {Boolean} vertical
   * @default false
   */
  get vertical() {
    return this.horizontal === false;
  }
  set vertical(v) {
    return this.horizontal = !v;
  }
  updateAlign() {
    this.syncConfigStyle(syncAlign);
  }
  updateContentAlign() {
    this.syncConfigStyle(syncContentAlign);
  }
  updateDirection() {
    this.syncConfigStyle(syncDirection);
  }
  updateHorizontal() {
    var _me$contentElement;
    const me = this,
      classList = (_me$contentElement = me.contentElement) === null || _me$contentElement === void 0 ? void 0 : _me$contentElement.classList,
      vertical = Number(me.vertical);
    if (classList) {
      classList.remove(directionCls[1 - vertical]);
      classList.add(directionCls[vertical]);
    } else {
      me.syncConfigLater('horizontal');
    }
    me.syncDirection();
  }
  updateJustify() {
    this.syncConfigStyle(syncJustify);
  }
  updateReverse() {
    this.syncDirection();
  }
  updateWrap() {
    this.syncConfigStyle(syncWrap);
  }
  syncDirection() {
    const me = this,
      {
        reverse
      } = me;
    me.direction = reverse ? `${me.vertical ? 'column' : 'row'}${reverse ? '-reverse' : ''}` : null;
  }
}
// Layouts must register themselves so that the static layout instantiation
// in Layout knows what to do with layout type names
Box.initClass();
Box._$name = 'Box';

/**
 * @module Core/widget/layout/VBox
 */
/**
 * A {@link Core.widget.layout.Box} layout that defaults to `horizontal : false`.
 *
 * The following:
 *
 * ```javascript
 *  layout : {
 *      type : 'vbox'
 *  }
 * ```
 *
 * Is equivalent to:
 *
 * ```javascript
 *  layout : {
 *      type       : 'box',
 *      horizontal : false
 *  }
 * ```
 *
 * @extends Core/widget/layout/Box
 * @layout
 * @classtype vbox
 */
class VBox extends Box {
  static $name = 'VBox';
  static type = 'vbox';
  static configurable = {
    horizontal: false
  };
}
// Layouts must register themselves so that the static layout instantiation
// in Layout knows what to do with layout type names
VBox.initClass();
VBox._$name = 'VBox';

/**
 * @module Core/widget/mixin/Badge
 */
/**
 * Mixin that allows a widget to display a badge (mostly done as css)
 *
 * ```javascript
 * // show badge
 * button.badge = 5;
 *
 * // hide badge
 * button.badge = null;
 * ```
 *
 * @inlineexample Core/widget/Badge.js
 *
 * @mixin
 */
var Badge = (Target => class Badge extends (Target || Base) {
  static get $name() {
    return 'Badge';
  }
  static get configurable() {
    return {
      /**
       * Get/sets and display badge, set to null or empty string to hide.
       * @member {String} badge
       * @category Misc
       */
      /**
       * Initial text to show in badge.
       * @config {String} badge
       * @category Misc
       */
      badge: null
    };
  }
  compose() {
    const {
      badge
    } = this;
    return {
      dataset: {
        badge
      },
      class: {
        'b-badge': badge != null && badge !== ''
      }
    };
  }
});

/**
 * @module Core/widget/Button
 */
const bIcon$1 = /(?:^|\s)b-icon-/,
  bFa$1 = /(?:^|\s)b-fa-/,
  defaultToggleable = Symbol('defaultToggleable'),
  fullConfigKeys = ['items', 'type', 'widgets', 'html', 'listeners'],
  menuListenersName = Symbol('defaultListener');
/**
 * Button widget, wraps and styles a regular <code>&lt;button&gt;</code> element. Can display text and icon and also
 * allows specifying button {@link #config-color}. Supports different appearances, by setting {@link #config-cls} to one
 * of:
 *
 * * 'b-raised' - Raised buttons
 * * 'b-rounded' - Round buttons
 * * 'b-transparent' - Buttons without border or background
 *
 * ## Default appearance
 *
 * By default, buttons uses a flat look in all themes:
 *
 * {@inlineexample Core/widget/ButtonDefault.js}
 *
 * ```javascript
 * // Green button with text and icon
 * const button = new Button({
 *     appendTo : document.body,
 *     icon    : 'b-fa-plus-circle',
 *     text    : 'Add',
 *     color   : 'b-green',
 *     onClick : () => {}
 * });
 * ```
 *
 * ## Raised appearance
 *
 * By configuring a button with `cls : 'b-raised'` its appearance change. In Material the button appears raised, in the
 * other themes it is instead filled:
 *
 * {@inlineexample Core/widget/ButtonRaised.js}
 *
 * ```javascript
 * // Raised green button with text and icon
 * const button = new Button({
 *     appendTo : document.body,
 *     cls     : 'b-raised',
 *     icon    : 'b-fa-plus-circle',
 *     text    : 'Add',
 *     color   : 'b-green',
 *     onClick : () => {}
 * });
 * ```
 *
 * ## Rounded appearance
 *
 * Configure a button with `cls : 'b-rounded'` to make it round. Works best for icon only buttons or buttons with very
 * short texts:
 *
 * {@inlineexample Core/widget/ButtonRounded.js}
 *
 * ```javascript
 * // Rounded button with icon
 * const button = new Button({
 *     appendTo : document.body,
 *     cls     : 'b-raised b-rounded',
 *     icon    : 'b-fa-plus-circle',
 *     color   : 'b-green',
 *     onClick : () => {}
 * });
 * ```
 *
 * ## Transparent appearance
 *
 * Configure a button with `cls : 'b-transparent'` to display it without border or background:
 *
 * {@inlineexample Core/widget/ButtonTransparent.js}
 * ```javascript
 * // Transparent green button with text and icon
 * const button = new Button({
 *     appendTo : document.body,
 *     cls     : 'b-transparent',
 *     icon    : 'b-fa-plus-circle',
 *     text    : 'Add',
 *     color   : 'b-green',
 *     onClick : () => {}
 * });
 * ```
 *
 * ## Button with menu
 *
 * Buttons can also have a menu that is shown on click:
 *
 * {@inlineexample Core/widget/ButtonWithMenu.js}
 *
 * ```javascript
 * // Transparent green button with text and icon
 * const button = new Button({
 *     appendTo : document.body,
 *     icon    : 'b-fa-chart',
 *     menu    : {
 *         items : [
 *             {
 *                 text : 'Click me',
 *                 onItem : () => console.log('I was clicked')
 *             }
 *         ]
 *     }
 * });
 * ```
 *
 * ## Click handling in a complex widget
 *
 * In the case of a button which is part of a complex UI within a larger Bryntum widget, use
 * of the string form for handlers is advised. A handler which starts with `'up.'` will
 * be resolved by looking in owning widgets of the Button. For example a Calendar may
 * have handlers for its buttons configured in:
 *
 * ```javascript
 * new Calendar({
 *     appendTo : document.body,
 *     project  : myProjectConfig,
 *     sidebar  : {
 *         items : {
 *             addNew : {
 *                 weight  : 0,
 *                 text    : 'New',
 *
 *                 // The Button's ownership will be traversed to find this function name.
 *                 // It will be called on the outermost Calendar widget.
 *                 onClick : 'up.onAddNewClick'
 *             }
 *         }
 *     },
 *
 *     // Button handler found here
 *     addNewClick() {
 *         // Use Calendar API which creates event in the currently active date
 *         this.createEvent();
 *     }
 * });
 * ```
 *
 * This class may be operated by the keyboard. `Space` presses the button and invokes any
 * click handler, and `ArrowDown` activates any configured {@link #config-menu}.
 * @classType button
 * @extends Core/widget/Widget
 * @mixes Core/widget/mixin/Badge
 * @widget
 */
class Button extends Widget.mixin(Badge, Rotatable) {
  //region Config
  static get $name() {
    return 'Button';
  }
  // Factoryable type name
  static get type() {
    return 'button';
  }
  static get configurable() {
    return {
      /**
       * Button icon class.
       *
       * All [Font Awesome](https://fontawesome.com/cheatsheet) icons may also be specified as `'b-fa-' + iconName`.
       *
       * Otherwise this is a developer-defined CSS class string which results in the desired icon.
       * @prp {String}
       */
      icon: null,
      /**
       * The menu icon class to show when the button has a menu. Set to `null` to not show a menu icon.
       *
       * All [Font Awesome](https://fontawesome.com/cheatsheet) icons may also be specified as `'b-fa-' + iconName`.
       *
       * @prp {String}
       * @default
       */
      menuIcon: 'b-icon-picker',
      /**
       * Icon class for the buttons pressed state. Only applies to toggle buttons
       *
       * All [Font Awesome](https://fontawesome.com/cheatsheet) icons may also be specified as `'b-fa-' + iconName`.
       *
       * Otherwise this is a developer-defined CSS class string which results in the desired icon.
       *
       * ```
       * new Button({
       *    // Icon for unpressed button
       *    icon        : 'b-fa-wine-glass',
       *
       *    // Icon for pressed button
       *    pressedIcon : 'b-fa-wine-glass-alt',
       *
       *    // Only applies to toggle buttons
       *    toggleable  : true
       * });
       * ```
       *
       * @prp {String}
       */
      pressedIcon: null,
      /**
       * Button icon alignment. May be `'start'` or `'end'`. Defaults to `'start'`
       * @prp {'start'|'end'}
       * @default
       */
      iconAlign: 'start',
      /**
       * The button behavioral type, will be applied as a `type` attribute to this button's element.
       * @prp {'button'|'submit'|'reset'}
       * @default
       */
      behaviorType: 'button',
      /**
       * The button's text.
       * @prp {String}
       */
      text: {
        value: null,
        $config: null,
        default: ''
      },
      /**
       * Button color (should have match in button.scss or your custom styling). Valid values in Bryntum themes
       * are:
       * * b-amber
       * * b-blue
       * * b-dark-gray
       * * b-deep-orange
       * * b-gray
       * * b-green
       * * b-indigo
       * * b-lime
       * * b-light-gray
       * * b-light-green
       * * b-orange
       * * b-purple
       * * b-red
       * * b-teal
       * * b-white
       * * b-yellow
       * Combine with specifying `b-raised` for raised/filled style (theme dependent).
       *
       * ```
       * new Button({
       *    color : 'b-teal b-raised'
       * });
       * ```
       *
       * @prp {String}
       */
      color: null,
      /**
       * Enabled toggling of the button (stays pressed when pressed).
       * @prp {Boolean}
       * @default false
       */
      toggleable: defaultToggleable,
      /**
       * Initially pressed or not. Only applies with `toggleable = true`.
       *
       * ```javascript
       * const toggleButton = new Button({
       *    toggleable : true,
       *    text : 'Enable cool action'
       * });
       * ```
       * @prp {Boolean}
       * @default
       */
      pressed: false,
      /**
       * Indicates that this button is part of a group where only one button can be pressed. Assigning a value
       * also sets `toggleable` to `true`.
       *
       * When part of a {@link Core.widget.ButtonGroup}, you can set {@link Core.widget.ButtonGroup#config-toggleGroup}
       * on it as an alternative to on each button. This config can then be used to override that value if needed.
       *
       * ```javascript
       * const yesButton = new Button({
       *    toggleGroup : 'yesno',
       *    text        : 'Yes'
       * });
       *
       * const noButton = new Button({
       *    toggleGroup : 'yesno',
       *    text        : 'No'
       * });
       * ```
       * @prp {String}
       */
      toggleGroup: null,
      /**
       * Set to `true` to perform action on clicking the button if it's already pressed
       * and belongs to a {@link #config-toggleGroup}.
       * @config {Boolean}
       * @default
       */
      supportsPressedClick: false,
      ripple: {
        radius: 75
      },
      forwardTwinEvents: ['action', 'toggle'],
      localizableProperties: ['text'],
      /**
       * Returns the instantiated menu widget as configured by {@link #config-menu}.
       * @member {Core.widget.Widget} menu
       */
      /**
       * A submenu configuration object, or an array of MenuItem configuration objects from which to create a
       * submenu which is shown when this button is pressed.
       *
       * Note that this does not have to be a Menu. The `type` config can be used to specify any widget as the
       * submenu.
       *
       * May also be specified as a fully instantiated {@link Core.widget.Widget#config-floating floating Widget}
       * such as a {@link Core/widget/Popup}.
       * @config {ContainerItemConfig|MenuConfig|MenuItemConfig[]|Core.widget.Widget}
       */
      menu: {
        $config: ['lazy', 'nullify'],
        value: null
      },
      menuDefaults: {
        type: 'menu',
        autoShow: false,
        autoClose: true,
        floating: true,
        scrollAction: 'realign',
        align: 't0-b0'
      },
      /**
       * If provided, turns the button into a link.
       * <div class="note">Not compatible with the {@link Core.widget.Widget#config-adopt} config.</div>
       * @prp {String}
       */
      href: null,
      /**
       * The `target` attribute for the {@link #config-href} config
       * @prp {String}
       */
      target: null,
      // Our own setValues/getValues system should not set/get HTML content
      defaultBindProperty: null
    };
  }
  updateElement(element, oldElement) {
    var _constructor$resolveT, _constructor$resolveT2, _constructor$configur;
    const me = this,
      {
        constructor
      } = me,
      result = super.updateElement(element, oldElement),
      menu = me.peekConfig('menu'),
      role = menu ? menu.isWidget ? menu.role : ((_constructor$resolveT = constructor.resolveType(menu.type)) === null || _constructor$resolveT === void 0 ? void 0 : (_constructor$resolveT2 = _constructor$resolveT.configurable) === null || _constructor$resolveT2 === void 0 ? void 0 : _constructor$resolveT2.role) || ((_constructor$configur = constructor.configurable.menuDefaults) === null || _constructor$configur === void 0 ? void 0 : _constructor$configur.type) || 'menu' : false;
    me.ariaHasPopup = role;
    return result;
  }
  compose() {
    const {
        color,
        href,
        icon,
        iconAlign,
        pressed,
        pressedIcon,
        target,
        text,
        toggleable,
        toggleGroup,
        menuIcon,
        behaviorType
      } = this,
      hasMenu = this.hasConfig('menu'),
      iconCls = pressed && pressedIcon ? pressedIcon : icon;
    return {
      tag: href ? 'a' : 'button',
      href,
      target,
      type: behaviorType,
      class: {
        [`b-icon-align-${iconAlign}`]: icon,
        [color]: Boolean(color),
        'b-pressed': pressed && toggleable,
        'b-text': Boolean(text),
        'b-has-menu': hasMenu
      },
      'aria-pressed': pressed,
      dataset: {
        group: toggleGroup
      },
      // eslint-disable-next-line bryntum/no-listeners-in-lib
      listeners: {
        click: 'onInternalClick',
        mousedown: 'onInternalMousedown'
      },
      children: {
        iconElement: (icon || pressedIcon) && {
          // This element is a purely visual cue with no meaning to the A11Y tree
          'aria-hidden': true,
          tag: 'i',
          class: {
            ...DomClassList.normalize(iconCls, 'object'),
            'b-icon': bIcon$1.test(iconCls),
            'b-fa': bFa$1.test(iconCls)
          }
        },
        label: text && {
          tag: 'label',
          text
        },
        menuIconElement: hasMenu && menuIcon && {
          tag: 'i',
          class: {
            'b-icon': bIcon$1.test(menuIcon),
            'b-fa': bFa$1.test(menuIcon),
            'b-button-menu-icon': 1,
            [menuIcon]: 1
          }
        }
      }
    };
  }
  //endregion
  configureOverflowTwin(overrides) {
    const me = this,
      config = super.configureOverflowTwin(overrides);
    // Icon-only buttons are not useful in a menu.
    // Use text, or any tooltip text as the button text.
    if (!config.text) {
      config.text = me.text || me.tooltipText;
    }
    return config;
  }
  onHide() {
    var _this$_menu;
    // Stop a menu from being visually orphaned if this button is hidden while its menu is visible
    (_this$_menu = this._menu) === null || _this$_menu === void 0 ? void 0 : _this$_menu.hide();
  }
  /**
   * Iterate over all widgets owned by this widget and any descendants.
   *
   * *Note*: Due to this method aborting when the function returns `false`, beware of using short form arrow
   * functions. If the expression executed evaluates to `false`, iteration will terminate.
   *
   * _Due to the {@link #config-menu} config being a lazy config and only being converted to be a
   * `Menu` instance just before it's shown, the menu will not be part of the iteration before
   * it has been shown once_.
   * @function eachWidget
   * @param {Function} fn A function to execute upon all descendant widgets.
   * Iteration terminates if this function returns `false`.
   * @param {Boolean} [deep=true] Pass as `false` to only consider immediate child widgets.
   * @returns {Boolean} Returns `true` if iteration was not aborted by a step returning `false`
   */
  get childItems() {
    return this._menu && [this.menu];
  }
  onFocusOut(e) {
    var _this$menu;
    super.onFocusOut(e);
    (_this$menu = this.menu) === null || _this$menu === void 0 ? void 0 : _this$menu.hide();
  }
  //region Getters/Setters
  get focusElement() {
    return this.element;
  }
  changeText(text) {
    return text == null ? '' : text;
  }
  changeToggleable(toggleable) {
    if (toggleable === defaultToggleable) {
      return this.toggleGroup || this.config.menu;
    }
    return toggleable;
  }
  changeMenu(menu, oldMenu) {
    const me = this,
      {
        element: forElement
      } = me;
    if (menu) {
      if (menu.isWidget) {
        menu.forElement = forElement;
        menu.owner = me;
        menu.constrainTo = me.rootElement;
      } else {
        // This covers both Array and Object which are valid items config formats.
        // menu could be { itemRef : { text : 'sub item 1 } }. But if it has
        // child items or html property in it, it's the main config
        if (typeof menu === 'object' && !fullConfigKeys.some(key => key in menu)) {
          menu = {
            lazyItems: menu
          };
        }
        menu = Widget.reconfigure(oldMenu, menu ? ObjectHelper.merge({
          owner: me,
          constrainTo: me.rootElement,
          forElement
        }, me.menuDefaults, menu) : null, me);
      }
      // Menu will shrink and fit inside a 10px inset of viewport.
      // Rectangle.alignTo prioritizes alignment if the target edge is closer to
      // the constrainTo edge than this in order to produce visually correct results.
      menu.align.constrainPadding = 10;
      me.detachListeners(menuListenersName);
      // https://github.com/bryntum/support/issues/6014
      // Before assigning new portions of listeners, make sure they don't exist already. Menu can be replaced by
      // another instance or a configuration object.
      menu.ion({
        name: menuListenersName,
        beforeShow: 'onMenuBeforeShow',
        hide: 'onMenuHide',
        show: 'onMenuShow',
        thisObj: this
      });
    } else {
      oldMenu === null || oldMenu === void 0 ? void 0 : oldMenu.destroy();
    }
    return menu;
  }
  onMenuBeforeShow({
    source
  }) {
    /**
     * This event is triggered when the button's menu is about to be shown.
     * @event beforeShowMenu
     * @param {Core.widget.Button} source This Button instance.
     * @param {Core.widget.Menu} menu This button's menu instance.
     */
    return this.trigger('beforeShowMenu', {
      menu: source
    });
  }
  onMenuShow() {
    this.ariaElement.setAttribute('aria-expanded', true);
  }
  onMenuHide() {
    this.ariaElement.setAttribute('aria-expanded', false);
    // We must react to its state change to hidden by becoming unpressed.
    // If we just hid it in the toggle method, this will be a no-op.
    this.toggle(false);
  }
  updateMenu(menu) {
    // We are toggleable if there's a menu.
    // Pressed means menu visible, not pressed means menu hidden.
    this.toggleable = Boolean(menu);
  }
  updatePressed(pressed) {
    const me = this;
    if (!me.toggleable || me.isConfiguring) {
      return;
    }
    const {
      menu
    } = me;
    if (pressed) {
      DomHelper.forEachSelector(me.rootElement, `button[data-group=${me.toggleGroup}]`, btnEl => {
        if (btnEl !== me.element) {
          Widget.getById(btnEl.id).pressed = false;
        }
      });
    }
    if (menu) {
      if (!menu.initialConfig.minWidth) {
        menu.minWidth = me.width;
      }
      // The presence of a number indicates to the align constraining algorithm
      // that it is *willing* to shrink in that dimension. It will never end up this small.
      // Use the properties because the getter will return 0 if not set.
      menu.align.minHeight = menu._minHeight ?? 100;
      menu.align.minWidth = menu._minWidth ?? 100;
      menu[pressed ? 'show' : 'hide']();
    }
    /**
     * Fires when the button is toggled via a UI interaction (the {@link #property-pressed} state is changed). If the button is part of a
     * {@link #config-toggleGroup} and you need to process the pressed button only, consider using
     * {@link #event-click} event or {@link #event-action} event.
     * @event toggle
     * @param {Core.widget.Button} source Toggled button
     * @param {Boolean} pressed New pressed state
     * @param {Boolean} userAction `true` if the toggle was triggered by a user action (click), `false` if it was
     * triggered programmatically.
     */
    me.trigger('toggle', {
      pressed,
      userAction: me._isUserAction
    });
  }
  //endregion
  //region Events
  onInternalMousedown(event) {
    var _this$_menu2;
    // Do not allow focus to hide the menu if it's focused - the impending click must do that.
    // Use the _property name because menu is lazy and we do not want to call it into existence.
    if ((_this$_menu2 = this._menu) !== null && _this$_menu2 !== void 0 && _this$_menu2.containsFocus && this.pressed) {
      event.preventDefault();
    }
  }
  /**
   * Triggers events when user clicks button
   * @fires click
   * @fires action
   * @internal
   */
  onInternalClick(event) {
    const me = this,
      bryntumEvent = {
        event
      };
    // Safari && FF trigger click on disabled button, Chrome does not. Handling it here
    if (me.disabled) {
      return;
    }
    me._isUserAction = true;
    if (me.toggleable) {
      // Clicking the pressed button in a toggle group should do nothing
      if (me.toggleGroup && me.pressed && !me.supportsPressedClick) {
        return;
      }
      if (!me.toggleGroup || !me.pressed) {
        me.toggle(!me.pressed);
      }
      // Edge case in dragfromgrid demo, where toggling mode destroys the Scheduler and thus destroys the toolbar
      // and the button in it
      if (me.isDestroyed) {
        return;
      }
    }
    /**
     * Fires when the button is clicked
     * @event click
     * @param {Core.widget.Button} source The button
     * @param {Event} event DOM event
     */
    me.trigger('click', bryntumEvent);
    /**
     * Fires when the default action is performed (the button is clicked)
     * @event action
     * @param {Core.widget.Button} source The button
     * @param {Event} event DOM event
     */
    // A handler may have resulted in destruction.
    if (!me.isDestroyed) {
      me.trigger('action', bryntumEvent);
    }
    // since Widget has Events mixed in configured with 'callOnFunctions' this will also call onClick and onAction
    if (!me.href) {
      // stop the event since it has been handled
      event.preventDefault();
      event.stopPropagation();
    }
    me._isUserAction = false;
  }
  //endregion
  //region Misc
  /**
   * Toggle button state (only use with toggleable = true)
   * @param {Boolean} pressed Specify to force a certain toggle state
   * @fires toggle
   */
  toggle(pressed = !this.pressed) {
    /**
     * Fires before the button is toggled (the {@link #property-pressed} state is changed). If the button is part of
     * a {@link #config-toggleGroup} and you need to process the pressed button only, consider using
     * {@link #event-click} event or {@link #event-action} event.
     * Return `false` to prevent the toggle to the new pressed state.
     * @event beforeToggle
     * @param {Core.widget.Button} source Toggled button
     * @param {Boolean} pressed New pressed state
     * @param {Boolean} userAction `true` if the toggle was triggered by a user action (click), `false` if it was
     * triggered programmatically.
     * @preventable
     */
    if (this.trigger('beforeToggle', {
      pressed,
      userAction: this._isUserAction
    }) !== false) {
      this.pressed = pressed;
    }
  }
  //endregion
}
// Register this widget type with its Factory
Button.initClass();
Button._$name = 'Button';

/**
 * @module Core/widget/Toolbar
 */
const asElementRefs = {
    refs: 'element'
  },
  onCreateTwin = overflowTwin => overflowTwin.element.style.margin = '',
  isToolbar = w => w.isToolbar,
  itemScoreFn = ent => ent[0] + (ent[1].minifiable ? 0 : 9e9),
  twinOverrides = {
    // If the initialConfig was hidden, we must override that
    hidden: false,
    // Item must obey menu's align-items : stretch style.
    width: ''
  },
  twinOverridesHorz = {
    ...twinOverrides,
    // Don't allow horizontal flex styles to apply in the vertical layout of the Menu.
    flex: ''
  },
  _axisProps = [{
    box: 'hbox',
    clientSizeProp: 'clientWidth',
    edgeProp: 'right',
    flexDir: 'row',
    horizontal: true,
    max: 'maxX',
    overflow: 'overflowX',
    pos: 'x',
    scrollSize: 'scrollWidth',
    sizeProp: 'width'
  }, {
    box: 'vbox',
    clientSizeProp: 'clientHeight',
    edgeProp: 'bottom',
    flexDir: 'column',
    horizontal: false,
    max: 'maxY',
    overflow: 'overflowY',
    pos: 'y',
    scrollSize: 'scrollHeight',
    sizeProp: 'height'
  }],
  defaultRepeat = {
    delay: 0,
    startRate: 40,
    endRate: 200,
    accelerateDuration: 500
  },
  nonSyncedConfigs = {
    menu: 1,
    pressed: 1
  };
/**
 * A container widget that can contain Buttons or other widgets, and is docked to the bottom or top of
 * a {@link Core.widget.Panel Panel}.
 *
 * {@inlineexample Core/widget/Toolbar.js}
 *
 * ## Arranging widgets
 *
 * You can use the special `->` item to push widgets to the right side:
 *
 * ```javascript
 * items    : [
 *     { text : 'Left button 1', icon : 'b-fa b-fa-plus' },
 *     { text : 'Left button 2', icon : 'b-fa b-fa-minus' },
 *     '->',
 *     { text : 'Right button 1', icon : 'b-fa b-fa-gear'}
 * ]
 * ```
 *
 * {@inlineexample Core/widget/ToolbarPositioning.js}
 * @extends Core/widget/Container
 * @mixes Core/widget/mixin/Toolable
 * @classType toolbar
 * @widget
 */
class Toolbar extends Container.mixin(Toolable) {
  static get $name() {
    return 'Toolbar';
  }
  // Factoryable type name
  static get type() {
    return 'toolbar';
  }
  static get delayable() {
    return {
      syncOverflowVisibility: {
        type: 'raf',
        cancelOutstanding: true
      } // && 50   // restore the "&& 50" here to help when debugging syncOverflowVisibility
    };
  }

  static get configurable() {
    return {
      defaultType: 'button',
      dock: 'top',
      layout: {
        type: 'box'
      },
      /**
       * How this Toolbar should deal with items that overflow its main axis.
       *
       * Values may be:
       * - `'menu'` A button with a menu is shown and the menu contains the overflowing items.
       * - `'scroll'` The items overflow and mey be scrolled into view using the mouse or scroll buttons.
       * - `null` Disable overflow handling
       *
       * When mode is `'menu'`, clones of overflowing toolbar item are created and added to a Menu. Any config
       * changes to the original toolbar item are propagated to the menu's clone, so disabling a toolbar
       * item will make the clone in the menu disabled.
       *
       * The clone of an input field will propagate its `value` changes back to the original. The
       * overflow button, its menu, and the clones should not be accessed or manipulated by application code.
       *
       * Note that cloned items will be allocated a unique, generated ID because all IDs must be unique,
       * so CSS targeting an element ID will not apply to a clone in the overflow menu.
       *
       * Values may also be specified in object form containing the following properties:
       * @config {String|Object|null} overflow
       * @property {'scroll'|'menu'} overflow.type `'scroll'` or `'menu'`
       * @property {ClickRepeaterConfig} overflow.repeat A config object to reconfigure the
       * {@link Core.util.ClickRepeater} which controls auto repeat speed when holding down the scroll buttons
       * when `type` is `'scroll'`
       * @property {Function} overflow.filter A filter function which may return a falsy value to prevent toolbar
       * items from being cloned into the overflow menu.
       * @default 'menu'
       */
      overflow: {
        // Wait until first paint to evaluate so that we can read our CSS style.
        // Set to null on destroy which destroys the overflow Tools and Scroller.
        $config: ['lazy', 'nullify'],
        value: {
          type: 'menu'
        }
      },
      toolDefaults: {
        overflowMenuButton: {
          type: 'button',
          hidden: true,
          icon: 'b-icon-menu',
          menuIcon: null,
          defaultCls: {
            'b-overflow-button': 1
          }
        },
        overflowScrollEnd: {
          handler: 'up.onEndScrollClick',
          hidden: true,
          defaultCls: {
            'b-icon-angle-right': 1,
            'b-overflow-button': 1,
            'b-icon': 1
          }
        },
        overflowScrollStart: {
          align: 'start',
          handler: 'up.onStartScrollClick',
          hidden: true,
          defaultCls: {
            'b-icon-angle-left': 1,
            'b-overflow-button': 1,
            'b-icon': 1
          }
        }
      },
      /**
       * Custom CSS class to add to toolbar widgets
       * @config {String}
       * @category CSS
       */
      widgetCls: null,
      /**
       * Determines if the toolbars read-only state should be controlled by its parent.
       *
       * When set to `false`, setting a parent container to read-only will not affect the widget. When set to
       * `true`, it will.
       *
       * @category Misc
       * @config {Boolean}
       * @default
       */
      ignoreParentReadOnly: true
    };
  }
  static get prototypeProperties() {
    return {
      flexRowCls: 'b-hbox',
      flexColCls: 'b-vbox'
    };
  }
  /**
   * Returns the Core.widget.Widget[] of items to hide to clear an overflow. The `visibleItems` array should be in
   * order of the `items` in the container.
   * @param {Core.widget.Widget[]} visibleItems
   * @returns {Array}
   * @private
   */
  static getEvictionList(visibleItems) {
    // this is a static method to allow unit testing
    const ret = visibleItems.filter(it => it.overflowable !== 'none');
    ret.forEach((it, n) => ret[n] = [n, it]);
    ret.sort((a, b) => itemScoreFn(b) - itemScoreFn(a)); // b - a => reverse order
    return ret;
  }
  compose() {
    const me = this,
      {
        axisProps,
        dock
      } = me,
      endToolElementRefs = me.getEndTools(asElementRefs),
      startToolElementRefs = me.getStartTools(asElementRefs);
    return {
      class: {
        [`b-dock-${dock}`]: 1,
        [`b-${dock}-toolbar`]: 1,
        [`b-${axisProps.box}`]: 1
      },
      children: {
        ...startToolElementRefs,
        toolbarContent: {
          class: {
            'b-box-center': 1,
            'b-toolbar-content': 1
          }
        },
        ...endToolElementRefs
      }
    };
  }
  get axisProps() {
    return _axisProps[this.layout.horizontal ? 0 : 1];
  }
  get contentElement() {
    return this.toolbarContent;
  }
  get overflowMenuButton() {
    var _this$tools;
    return (_this$tools = this.tools) === null || _this$tools === void 0 ? void 0 : _this$tools.overflowMenuButton;
  }
  get overflowType() {
    const {
      overflow
    } = this;
    return typeof overflow === 'string' ? overflow : overflow === null || overflow === void 0 ? void 0 : overflow.type;
  }
  onChildAdd(item) {
    var _item$syncRotationToD;
    super.onChildAdd(item);
    this.processAddedLeafItem(item);
    (_item$syncRotationToD = item.syncRotationToDock) === null || _item$syncRotationToD === void 0 ? void 0 : _item$syncRotationToD.call(item, this.dock);
  }
  onChildRemove(item) {
    super.onChildRemove(item);
    this.syncOverflowVisibility();
  }
  processAddedLeafItem(item) {
    // Any configurable config changes in the original are propagated to a possible clone.
    // Also a reevaluation of scroll state may be necessary. Any part of the UI may have changed,
    FunctionHelper.after(item, 'onConfigChange', this.onLeafItemConfigChange, item);
    // And all the way down. Eg, hiding a ButtonGroup must schedule a syncOverflowVisibility
    // but also hiding any of its children must also schedule a syncOverflowVisibility
    if (item.isContainer) {
      item.eachWidget(w => this.processAddedLeafItem(w));
    }
  }
  onPaint({
    firstPaint
  }) {
    var _super$onPaint;
    (_super$onPaint = super.onPaint) === null || _super$onPaint === void 0 ? void 0 : _super$onPaint.call(this, ...arguments);
    // Evaluate the overflow late so that we have access to styles and measurements.
    if (firstPaint) {
      this.getConfig('overflow');
    }
  }
  updateDock(dock) {
    const me = this,
      {
        layout
      } = me,
      {
        vertical
      } = layout;
    layout.vertical = canonicalDock(dock)[1];
    if (!me.initialItems) {
      if (vertical !== layout.vertical) {
        me.updateOverflow(me.overflow);
      }
      for (const item of me.childItems) {
        var _item$syncRotationToD2;
        (_item$syncRotationToD2 = item.syncRotationToDock) === null || _item$syncRotationToD2 === void 0 ? void 0 : _item$syncRotationToD2.call(item, dock);
      }
    }
  }
  updateOverflow(overflow, oldOverflow) {
    var _me$overflowMenuButto;
    const me = this,
      {
        axisProps,
        contentElement,
        overflowType
      } = me,
      {
        flexDir
      } = axisProps,
      overflowMenu = (_me$overflowMenuButto = me.overflowMenuButton) === null || _me$overflowMenuButto === void 0 ? void 0 : _me$overflowMenuButto._menu,
      overflowTools = {};
    if (overflowMenu) {
      if (overflow) {
        // Save the overflowTwins from destruction
        overflowMenu === null || overflowMenu === void 0 ? void 0 : overflowMenu.removeAll();
      } else {
        // Break link between original and clone
        overflowMenu.eachWidget(overflowTwin => {
          overflowTwin._overflowTwinOrigin.overflowTwin = null;
        });
      }
    }
    if (oldOverflow === 'menu') {
      overflowTools.overflowMenuButton = null;
    } else if (oldOverflow === 'scroll') {
      overflowTools.overflowScrollStart = overflowTools.overflowScrollEnd = null;
    }
    if (overflowType === 'menu') {
      var _me$scrollable;
      // Not needed for menu type overflowing
      (_me$scrollable = me.scrollable) === null || _me$scrollable === void 0 ? void 0 : _me$scrollable.destroy();
      // Must allow things like Badges to escape the bounds.
      contentElement.style.overflow = contentElement.style.overflowX = contentElement.style.overflowY = '';
      overflowTools.overflowMenuButton = {
        cls: {
          [`b-${flexDir}-menu`]: 1
        }
      };
    } else if (overflowType === 'scroll') {
      const repeat = typeof overflow === 'object' && (overflow === null || overflow === void 0 ? void 0 : overflow.repeat) || defaultRepeat;
      // We need a scroller.
      me.scrollable = {
        [axisProps.overflow]: 'hidden-scroll',
        element: contentElement,
        internalListeners: {
          scroll: 'onContentScroll',
          thisObj: me
        }
      };
      overflowTools.overflowScrollStart = {
        repeat,
        invertRotate: true,
        cls: {
          [`b-${flexDir}-start-scroller`]: 1
        }
      };
      overflowTools.overflowScrollEnd = {
        repeat,
        invertRotate: true,
        cls: {
          [`b-${flexDir}-end-scroller`]: 1
        }
      };
    }
    me.tools = overflowTools;
    if (overflowType) {
      // Stops items from flex-shrinking down now that we have a way of showing them in full.
      contentElement.classList.add('b-overflow');
      // Need to hide/show overflow buttons when necessary
      me.monitorResize = true;
      me.syncOverflowVisibility();
    } else {
      contentElement.classList.remove('b-overflow');
      me.monitorResize = false;
    }
  }
  onContentScroll() {
    this.syncScrollerState();
  }
  onStartScrollClick() {
    this.scrollable[this.axisProps.pos] -= 2;
  }
  onEndScrollClick() {
    this.scrollable[this.axisProps.pos] += 2;
  }
  // Only called when monitorResize is true, which is only set when we have an overflow mode
  onInternalResize() {
    super.onInternalResize(...arguments);
    // If it's not the initial undefined->first size from the initial paint, reevaluate overflow
    if (this.isPainted) {
      this.syncOverflowVisibility();
    }
  }
  syncOverflowVisibility() {
    const me = this,
      {
        overflowType,
        contentElement,
        isVisible
      } = me,
      {
        clientSizeProp,
        edgeProp,
        sizeProp
      } = me.axisProps,
      {
        overflowMenuButton,
        overflowScrollStart,
        overflowScrollEnd
      } = me.tools,
      rtl = me.rtl && me.layout.horizontal,
      menuOverflow = overflowType === 'menu',
      getAvailSpace = () => Math.ceil(contentElement[clientSizeProp] + (
      // Since we cannot simply hide these to remove their influence, we need to add their width/height:
      !overflowScrollStart || overflowScrollStart.hidden ? 0 : overflowScrollStart.rectangle('outer')[sizeProp]) + (!overflowScrollEnd || overflowScrollEnd.hidden ? 0 : overflowScrollEnd.rectangle('outer')[sizeProp])),
      getContentSize = () => {
        if (visibleItems.length === 0) {
          return 0;
        }
        // Firefox doesn't calculate scrollWidth correctly if overflow is hidden which it has to be. To get
        // around this, we use the edge of the most "extreme" widget (the one laid out last in the flow)
        const rect = visibleItems[visibleItems.length - 1].rectangle(contentElement);
        // Elements in an RTL ct are basically at right:0 and then have increasing right coordinates. To see
        // how much space is occupied we subtract the left edge of the last widget (which may be negative) from
        // the rightmost side of the contentElement container (i.e., the width).
        return Math.floor(rtl ? contentElement[clientSizeProp] - rect.left : rect[edgeProp]); // right or bottom
        // we use Math.floor() to discard fractional px sizes of content (it is ok to just clip that)
      };

    let availableSpace, contentSize, eviction, evictionList, it, itemSize, minifiable, minifiables, minified, overflowable, overflowItems, visibleItems;
    // Method can be called for hidden toolbar (e.g. after event editor is hidden), bail out early in such case
    if (!isVisible || !overflowType || me.items.length === 0) {
      return;
    }
    // Prevent recursion
    me.inSyncOverflowVisibility = true;
    // Give the contents a chance to lay out with no scroll tools taking space.
    overflowMenuButton === null || overflowMenuButton === void 0 ? void 0 : overflowMenuButton.hide();
    // NOTE: if we hide the scroller buttons that will affect the scroll range and can trigger a scroll. The scroll
    // does not fire synchronously (at least in Chrome) so it cannot be swallowed here.
    // Iterate all leaf widgets.
    // Restore only the ones that we hid to visibility so that we can accurately ascertain overflow.
    // Collect all visible leaf widgets. These are what we are interested in hiding and showing.
    // Anything may have changed. Text inside buttons, label of fields, visibility or
    // disabled status. The only way to ascertain overflow is to show them all, and
    // force a synchronous layout by measuring the resulting scrollWidth/Height
    me.eachWidget((item, control) => {
      minifiable = item.minifiable;
      // We want to descend into containers (esp ButtonGroup) but don't want to descend into normal widgets (like
      // button's which may have menus).
      overflowable = item.overflowable;
      // falsy overflowable normally means to descend into its items, but if item is minifiable, we do not
      // descend into the widget. It becomes all or nothing just like overflowable:true. Since overflowable can
      // also be set to 'none', we need to keep whatever it has for a value if truthy.
      overflowable = minifiable ? overflowable || minifiable : overflowable;
      if (item.floating) {
        // not in the flow of the container (i.e., no space occupied in the way we handle it), so skip
        control.down = false;
      } else {
        control.down = !overflowable;
        if (item.innerItem) {
          // Undo whatever we may have done to the items on a previous cycle:
          if (item._toolbarOverflow) {
            // Order is important here. _toolbarOverflow must be set first
            // so that onLeafItemConfigChange doesn't recurse infinitely.
            item.hidden = item._toolbarOverflow = false;
          }
          if (item._toolbarMinified) {
            // Order is important here. _toolbarMinified must be set first
            // so that onLeafItemConfigChange doesn't recurse infinitely.
            item.minified = item._toolbarMinified = false;
          }
          if (item.isVisible) {
            minifiable && (minifiables || (minifiables = [])).push(item);
            overflowable && (visibleItems || (visibleItems = [])).push(item);
          }
        }
      }
    });
    if (visibleItems) {
      availableSpace = getAvailSpace(); // get the size of the content area
      contentSize = getContentSize();
    }
    if (visibleItems && contentSize > availableSpace) {
      if (menuOverflow) {
        /*
              | contentSize |
            
            
             visItem[0]  visItem[1]  visItem[2]  visItem[3]  visItem[4]  visItem[5] 
            
            
                                                    
                                                    
            
                                                                                     
                                                                                      = 
                                                                                     
            
            | availableSpace |  
                                                                                        
                                                                                  overflowMenuButton
            If any of the visibleItems is marked as "overflow = 'none'" then we skip it, and its size must
            be accommodated by hiding other items. This means we cannot use item edges to determine when we
            have cleared enough space, so we just use sizes (and mind the gap).
            For example, visibleItem[5] has overflowable='none', so [4] gets hidden:
            
               
             visItem[0]  visItem[1]  visItem[2]  visItem[3]  visItem[5]     = 
               
            
        */
        // Minify the minifiables (starting at the end) and see if that frees up enough space
        while (contentSize > availableSpace && (it = (_minifiables = minifiables) === null || _minifiables === void 0 ? void 0 : _minifiables.pop())) {
          var _minifiables;
          itemSize = contentSize;
          // Order is important here. _toolbarMinified must be set first
          // so that onLeafItemConfigChange doesn't recurse infinitely.
          it._toolbarMinified = true;
          it.minified = true;
          contentSize = getContentSize();
          itemSize -= contentSize; // number of px saved by minification
          // Remember these fellows since we may be able to revert their minification
          (minified || (minified = [])).push([it, itemSize]);
        }
        if (contentSize > availableSpace) {
          // Not enough space, so we'll need that overflow button (most likely)
          overflowMenuButton.show();
          availableSpace = getAvailSpace(); // get the new size of the content area
          // Process the visibleItems (starting from the end) and see if any are willing to be moved to the
          // overflow menu. We prefer to keep the minifiables
          evictionList = Toolbar.getEvictionList(visibleItems);
          for (eviction of evictionList) {
            if (contentSize > availableSpace) {
              it = eviction[1];
              it._toolbarOverflowWidth = it.width;
              // Order is important here. _toolbarOverflow must be set first
              // so that onLeafItemConfigChange doesn't recurse infinitely.
              it._toolbarOverflow = true;
              it.hidden = true; // hide things as we go to make getContentSize() work
              visibleItems.splice(visibleItems.indexOf(it), 1); // also important for getContentSize()
              // Remember these pairs of [itemIndex, item] as we hide them so that we can add them to the
              // menu in the correct order (the itemIndex is used make the menu item order match the
              // toolbar order since this won't match the eviction order)
              (overflowItems || (overflowItems = [])).push(eviction);
              contentSize = getContentSize();
            }
          }
          if (overflowItems) {
            // Restore the items to the order in the toolbar and unwrap the entries to be just widgets
            overflowItems.sort((a, b) => a[0] - b[0]).forEach((ent, n) => overflowItems[n] = ent[1]);
            // Space was created by moving items out... see if we can unminify any minified items. This
            // is a FIFO so we revert from the start, but we'll revert any items we can. We just give
            // priority to items as we go from start to end.
            while ((_minified = minified) !== null && _minified !== void 0 && _minified.length) {
              var _minified;
              [it, itemSize] = minified.pop();
              // In dire cases we'll hide minified items, so check to see if the item is in the
              // overflowItems bucket and ignore it if so:
              if (contentSize + itemSize <= availableSpace && !it._toolbarOverflow) {
                contentSize += itemSize;
                it.minified = it._toolbarMinified = false;
              }
            }
            me.syncOverflowMenuButton(overflowItems);
          } else {
            overflowMenuButton.hide(); // no items were willing to move into the overflow menu...
          }
        }
      } else {
        overflowScrollEnd.show();
        overflowScrollStart.show();
        me.syncScrollerState();
      }
    } else if (!menuOverflow) {
      overflowScrollEnd === null || overflowScrollEnd === void 0 ? void 0 : overflowScrollEnd.hide();
      overflowScrollStart === null || overflowScrollStart === void 0 ? void 0 : overflowScrollStart.hide();
    }
    me.inSyncOverflowVisibility = false;
  }
  syncOverflowMenuButton(overflowItems) {
    var _overflowMenuButton$_;
    const me = this,
      {
        axisProps,
        overflowMenuButton
      } = me,
      menu = {
        cls: 'b-toolbar-overflow-menu',
        minWidth: 280,
        items: [],
        align: {
          align: axisProps.horizontal ? 't100-b100' : 'r100-l100',
          axisLock: 'flexible'
        }
      };
    // Add clones, or surrogates of the overflowing things to the menu.
    // Input fields will be cloned, buttons will result in a MenuItem.
    // Any Containers
    me.addToMenu(menu, overflowItems.filter(item => me.overflowItemFilter(item)));
    if ((_overflowMenuButton$_ = overflowMenuButton._menu) !== null && _overflowMenuButton$_ !== void 0 && _overflowMenuButton$_.isMenu) {
      const existingMenu = overflowMenuButton.menu,
        {
          toAdd,
          toRemove
        } = ArrayHelper.delta(menu.items, existingMenu.items, 1);
      existingMenu.remove(toRemove);
      if (existingMenu.items.length) {
        // Insert the ones which we just got too narrow to show at the top of the menu
        for (let i = toAdd.length - 1; i >= 0; i--) {
          existingMenu.insert(toAdd[i], 0);
        }
      } else {
        existingMenu.add(toAdd);
      }
    } else {
      overflowMenuButton.menu = menu;
    }
  }
  syncScrollerState() {
    const me = this,
      {
        axisProps,
        scrollable
      } = me,
      {
        overflowScrollStart,
        overflowScrollEnd
      } = me.tools,
      scrollPos = scrollable[axisProps.pos],
      maxScrollPos = scrollable[axisProps.max];
    overflowScrollStart.disabled = !scrollPos;
    // abs for rtl, which uses negative values
    overflowScrollEnd.disabled = Math.abs(Math.ceil(scrollPos)) >= Math.abs(maxScrollPos);
  }
  overflowItemFilter(item) {
    const {
      filter
    } = this.overflow;
    return Boolean(filter
    // Allow user-defined filter
    ? filter.call(this, item)
    // If no Elements, for example displaying text which will have a Node type 3
    // or a toolbar spacer or separator, then omit it from the menu
    : DomHelper.getChildElementCount(item.element));
  }
  addToMenu(menu, overflowingItems) {
    const overrides = this.horizontal ? twinOverridesHorz : twinOverrides;
    for (const item of overflowingItems) {
      const overflowTwin = item.ensureOverflowTwin(overrides, onCreateTwin);
      menu.items.push(overflowTwin);
    }
  }
  // Note that this is called with the thisObj of the tbar item being reconfigured.
  // It propagates the new setting into its toolbar overflow clone.
  onLeafItemConfigChange(origResult, {
    name,
    value
  }) {
    const item = this,
      toolbar = item.up(isToolbar),
      overflow = toolbar.hasConfig('overflow'),
      {
        overflowTwin
      } = item;
    // If it's a hide/show, and its in sync with its _toolbarOverflow state, do nothing
    if (!overflow || toolbar !== null && toolbar !== void 0 && toolbar.inSyncOverflowVisibility || name === 'hidden' && value === item._toolbarOverflow) {
      return;
    }
    // If the changed item has a clone in the overflow menu and the config is not one
    // of the unshared ones, sync the clone
    if (overflowTwin && !nonSyncedConfigs[name]) {
      overflowTwin[name] = value;
    }
    // Any part of the UI might have changed shape, so we must reevaluate scroll state.
    if (toolbar !== null && toolbar !== void 0 && toolbar.isPainted && item.ref !== 'overflowMenuButton') {
      if (!(item.isTextField && name === 'value' && (item.containsFocus || overflowTwin !== null && overflowTwin !== void 0 && overflowTwin.containsFocus))) {
        toolbar.syncOverflowVisibility();
      }
    }
  }
  createWidget(widget) {
    if (widget === '->') {
      widget = {
        type: 'widget',
        cls: 'b-toolbar-fill'
      };
    } else if (widget === '|') {
      widget = {
        type: 'widget',
        cls: 'b-toolbar-separator'
      };
    } else if (typeof widget === 'string') {
      widget = {
        type: 'widget',
        cls: 'b-toolbar-text',
        html: widget
      };
    }
    const result = super.createWidget(widget);
    if (this.widgetCls) {
      result.element.classList.add(this.widgetCls);
    }
    return result;
  }
}
// Register this widget type with its Factory
Toolbar.initClass();
Toolbar._$name = 'Toolbar';

/**
 * @module Core/widget/Panel
 */
/**
 * An object that describes a Panel's header.
 *
 * @typedef {Object} PanelHeader
 * @property {String|Object} [cls] Additional CSS class or classes to add to the header element.
 * @property {'top'|'right'|'bottom'|'left'} [dock="top"] Specify "left", "bottom", or "right" to control panel edge to which the header docks.
 * @property {String} title
 * @property {'start'|'center'|'end'} [titleAlign="start"] Specify "center" or "end" to align the panel's title differently.
 */
const acceptNode = e => !e.classList.contains('b-focus-trap') && DomHelper.isFocusable(e) ? DomHelper.NodeFilter.FILTER_ACCEPT : DomHelper.NodeFilter.FILTER_SKIP,
  emptyArray$1 = [],
  emptyObject = {},
  emptySplit = [emptyArray$1, emptyArray$1],
  finishBodyWrap = (config, classes, final) => {
    const {
      vertical
    } = config;
    delete config.vertical;
    return {
      ...config,
      class: {
        ...classes,
        [`b-${vertical ? 'v' : 'h'}box`]: 1,
        'b-box-center': 1,
        'b-panel-bar-wrap': !final
      }
    };
  },
  wrapBody = (inner, bodyWrapTag, vertical = false) => {
    const wrap = {
      vertical,
      children: inner ? [inner] : []
    };
    if (bodyWrapTag) {
      wrap.tag = bodyWrapTag;
    }
    return wrap;
  },
  setCls = (elOrConfig, cls) => {
    if (elOrConfig !== null && elOrConfig !== void 0 && elOrConfig.classList) {
      elOrConfig === null || elOrConfig === void 0 ? void 0 : elOrConfig.classList.add(cls);
    } else if (elOrConfig !== null && elOrConfig !== void 0 && elOrConfig.class) {
      if (typeof elOrConfig.class === 'string') {
        elOrConfig.class = {
          [elOrConfig.class]: 1
        };
      }
      elOrConfig.class[cls] = 1;
    }
  },
  barConfigs = {
    dock: 1,
    hidden: 1,
    weight: 1
  },
  dockDirection = {
    //       [vertical, before]
    top: [true, true],
    bottom: [true, false],
    left: [false, true],
    right: [false, false]
  },
  headerDock = {
    header: 1,
    'pre-header': 1
  };
/**
 * Panel widget. A general purpose container which may be used to contain child {@link Core.widget.Container#config-items}
 * or {@link Core.widget.Widget#config-html}.
 *
 * Also may dock a {@link #config-header} and {@link #config-footer} either at top/bottom or left/right
 *
 * @example
 * let panel = new Panel({
 *   title : 'A Test Panel',
 *   items : {
 *     customerName : { type : 'text', placeholder: 'Text' },
 *   },
 *   bbar : {
 *     items : {
 *       proceedButton : {
 *         text : 'Proceed',
 *         onClick : () => {
 *           alert('Proceeding!');
 *         }
 *       }
 *     }
 * });
 *
 * @classType panel
 *
 * @mixes Core/mixin/State
 * @mixes Core/widget/mixin/Toolable
 * @extends Core/widget/Container
 * @inlineexample Core/widget/Panel.js
 * @widget
 */
class Panel extends Container.mixin(State, Toolable) {
  //region Config
  static get $name() {
    return 'Panel';
  }
  // Factoryable type name
  static get type() {
    return 'panel';
  }
  static get configurable() {
    return {
      localizableProperties: ['title'],
      /**
       * Controls whether the panel is collapsed (the body of the panel is hidden while only the header is
       * visible). Only valid if the panel is {@link #config-collapsible}.
       * @config {Boolean}
       * @category Layout
       */
      collapsed: {
        value: null,
        $config: null,
        default: false
      },
      /**
       * This config enables collapsibility for the panel. See {@link #config-collapsed}.
       *
       * For example:
       * ```javascript
       *      {
       *          type        : 'panel',
       *          collapsible : true
       *      }
       * ```
       * This is managed by an instance of {@link Core.widget.panel.PanelCollapser} which can be configured if an
       * object is passed for this config property:
       * ```javascript
       *      {
       *          type        : 'panel',
       *          collapsible : {
       *              direction : 'left'
       *          }
       *      }
       * ```
       * The config object form can contain a `type` property to specify the type of collapse the panel will use.
       * This property can be one of the following:
       *
       * - `'inline'` (see {@link Core.widget.panel.PanelCollapser})
       * - `'overlay'` (see {@link Core.widget.panel.PanelCollapserOverlay})
       *
       * @config {Boolean|PanelCollapserConfig|PanelCollapserOverlayConfig}
       * @category Layout
       */
      collapsible: {
        value: null,
        $config: 'nullify'
      },
      /**
       * Custom CSS classes to add to the panel's body element.
       *
       * May be specified as a space separated string, or as an object in which property names
       * with truthy values are used as the class names:
       *
       * ```javascript
       *  bodyCls : {
       *      'b-my-class'     : 1,
       *      [this.extraCls]  : 1,
       *      [this.activeCls] : this.isActive
       *  }
       *  ```
       *
       * @config {String|Object}
       * @category CSS
       */
      bodyCls: {
        $config: {
          merge: 'classList'
        },
        value: null
      },
      bodyTag: null,
      bodyWrapTag: null,
      /**
       * By default, tabbing within a Panel is not contained, ie you can TAB out of the Panel
       * forwards or backwards.
       * Configure this as `true` to disallow tabbing out of the Panel, and make tabbing circular within this Panel.
       * @config {Boolean}
       * @default false
       * @category Content
       */
      trapFocus: null,
      /**
       * Get/set this Panel's title. This may only be set when a header exists. If a header
       * has been disabled by configuring the {@link #config-header} as `false`, setting it
       * will have no effect.
       * @member {String} title
       */
      /**
       * A title to display in the header. Causes creation and docking of a header
       * to the top if no header is configured.
       *
       * If specified, overrides any title configured within the {@link #config-header} configuration.
       * @default
       * @config {String}
       * @category Misc
       */
      title: null,
      /**
       * A config {@link PanelHeader object} for the panel's header or a string in place of a `title`.
       *
       * Configuring this as `false` explicitly removes the header bar, overriding any
       * {@link #config-tools} or {@link #config-title} configs.
       * @default
       * @config {String|Boolean|PanelHeader}
       * @category Content
       */
      header: null,
      stateful: ['collapsed'],
      /**
       * An object containing config defaults for corresponding {@link #config-strips} objects with a matching name.
       *
       * By default, this object contains the keys `'bbar'` and `'tbar'` to provide default config values for the
       * {@link #config-bbar} and {@link #config-tbar} configs.
       *
       * This object also contains a key named `'*'` with default config properties to apply to all strips. This
       * object provides the default `type` (`'toolbar') and {@link Core.widget.Widget#config-dock} (`'top'`)
       * property for strips.
       * @config {Object} stripDefaults
       * @internal
       * @category Content
       */
      stripDefaults: {
        '*': {
          type: 'toolbar',
          dock: 'top'
        },
        bbar: {
          dock: 'bottom',
          weight: -1000
        },
        tbar: {
          weight: -1000
        }
      },
      /**
       * An object containing widgets keyed by name. By default (when no `type` is given), strips are
       * {@link Core.widget.Toolbar toolbars}. If the value assigned to a strip is an array, it is converted to
       * the toolbar's {@link Core.widget.Container#config-items}.
       *
       * The {@link #config-bbar} and {@link #config-tbar} configs are shortcuts for adding toolbars to the
       * panel's `strips`.
       *
       * Strips are arranged based on their {@link Core.widget.Widget#config-dock} and
       * {@link Core.widget.Widget#config-weight} configs.
       *
       * For widgets using a `dock` of `'top'`, `'bottom'`, `'left'`, `'right'`, `'start'` or `'end'`(an "edge
       * strip"), the higher the `weight` assigned to a widget, the closer that widget will be to the panel body.
       *
       * For widgets with `'header'` or `'pre-header'` for `dock` (a "header strip"), higher `weight` values
       * cause the widget to be placed closer to the panel's title.
       *
       * ```javascript
       *  new Panel({
       *      title : 'Test',
       *      html  : 'Panel strip test',
       *      strips : {
       *          left : [{
       *              text : 'Go'
       *          }]
       *      }
       *  });
       * ```
       * @config {Object<String,ContainerItemConfig>} strips
       * @category Content
       */
      strips: {
        value: null,
        $config: 'nullify'
      },
      toolDefaults: {
        close: {
          weight: -1000
        },
        collapse: {
          weight: -990
        }
      },
      /**
       * Config object of a footer. May contain a `dock`, `html` and a `cls` property. A footer is not a widget,
       * but rather plain HTML that follows the last element of the panel's body and {@link #config-strips}.
       *
       * The `dock` property may be `top`, `right`, `bottom`, `left`, `start` or `end`
       *
       * @config {Object|String}
       * @property {'top'|'right'|'bottom'|'left'|'start'|'end'} dock Where to dock
       * @property {String} html Html to populate the footer with
       * @property {String} cls CSS class to add to the footer
       * @default
       * @category Content
       */
      footer: null,
      /**
       * This config is used with {@link Core.widget.panel.PanelCollapserOverlay} to programmatically control the
       * visibility of the panel's body. In this mode of collapse, the body of a collapsed panel is a floating
       * overlay. Setting this config to `true` will show this element, while `false` will hide it.
       * @config {Boolean}
       * @private
       */
      revealed: null,
      /**
       * The tool Widgets as specified by the {@link #config-tools} configuration
       * (and the {@link Core.widget.Popup#config-closable} configuration in the Popup subclass).
       * Each is a {@link Core.widget.Widget} instance which may be hidden, shown and observed and styled
       * just like any other widget.
       *
       * ```javascript
       * panel.tools.add = {
       *     cls : 'b-fa b-fa-plus',
       *     handler() {
       *         // Clicked the tool
       *     }
       * }
       * ```
       * @member {Object<String,Core.widget.Tool>} tools
       * @accepts {Object<String,Core.widget.Tool|ToolConfig>}
       */
      /**
       * The {@link Core.widget.Tool tools} to add either before or after the `title` in the Panel header. Each
       * property name is the reference by which an instantiated tool may be retrieved from the live
       * `{@link Core.widget.mixin.Toolable#property-tools}` property.
       * ```javascript
       * new Panel({
       *     ...
       *     tools : {
       *         add : {
       *             cls : 'b-fa b-fa-plus',
       *             handler() {
       *                 // Clicked the tool
       *             }
       *         }
       *     }
       * });
       * ```
       * @config {Object<string,ToolConfig>} tools
       * @category Content
       */
      /**
       * Get toolbar {@link Core.widget.Toolbar} docked to the top of the panel
       * @member {Core.widget.Toolbar} tbar
       * @readonly
       * @category Content
       */
      /**
       * A Config object representing the configuration of a {@link Core.widget.Toolbar},
       * or array of config objects representing the child items of a Toolbar.
       *
       * This creates a toolbar docked to the top of the panel immediately below the header.
       * @config {Array<ContainerItemConfig|String>|ToolbarConfig}
       * @category Content
       */
      tbar: null,
      /**
       * Get toolbar {@link Core.widget.Toolbar} docked to the bottom of the panel
       * @member {Core.widget.Toolbar} bbar
       * @readonly
       * @category Content
       */
      /**
       * A Config object representing the configuration of a {@link Core.widget.Toolbar},
       * or array of config objects representing the child items of a Toolbar.
       *
       * This creates a toolbar docked to the bottom of the panel immediately above the footer.
       * @config {Array<ContainerItemConfig|String>|ToolbarConfig}
       * @category Content
       */
      bbar: null,
      role: 'region'
    };
  }
  //endregion
  /**
   * A header {@link #config-tools tool} has been clicked.
   * @event toolClick
   * @param {Core.widget.Tool} source - This Panel.
   * @param {Core.widget.Tool} tool - The tool which is being clicked.
   */
  //region Composition
  updateElement(element, oldElement) {
    const result = super.updateElement(element, oldElement);
    if (this.titleElement) {
      DomHelper.setAttributes(this.ariaElement, {
        'aria-describedby': this.titleElement.id
      });
    }
    return result;
  }
  compose() {
    const me = this,
      {
        collapsible,
        focusable,
        hasItems,
        revealed,
        tools
      } = me,
      header = me.composeHeader(),
      horz = (header === null || header === void 0 ? void 0 : header.class['b-dock-left']) || (header === null || header === void 0 ? void 0 : header.class['b-dock-right']);
    let body = me.composeBody(),
      key = 'bodyWrapElement';
    if (collapsible) {
      [key, body] = collapsible.wrapCollapser(key, body);
    }
    return {
      tabIndex: hasItems && focusable !== false || focusable ? 0 : null,
      class: {
        [`b-panel-collapsible-${collapsible === null || collapsible === void 0 ? void 0 : collapsible.type}`]: collapsible,
        [`b-panel-collapse-${collapsible === null || collapsible === void 0 ? void 0 : collapsible.collapseDir}`]: collapsible,
        [`b-${horz ? 'h' : 'v'}box`]: 1,
        'b-panel-collapsible': collapsible,
        'b-panel-has-header': header,
        'b-panel-has-tools': tools ? 1 : 0,
        'b-panel-overlay-revealed': revealed
      },
      children: {
        topFocusTrap: {
          'aria-hidden': true,
          tabIndex: 0,
          class: {
            'b-focus-trap': 1
          }
        },
        // Note: we always put header before bodyWrap since it is likely (though untested) to be better for
        // a11y. We use flexbox order to make the right/bottom docking appear correct but it is likely that
        // the DOM order of the <header> element vs (optional) <footer> is important to screen readers.
        headerElement: header,
        [key]: body,
        bottomFocusTrap: {
          'aria-hidden': true,
          tabIndex: 0,
          class: {
            'b-focus-trap': 1,
            'b-end-focus-trap': 1
          }
        }
      }
    };
  }
  composeBody() {
    var _me$layout, _me$layout2;
    const me = this,
      {
        bodyCls,
        bodyConfig,
        bodyWrapTag,
        footer,
        uiClassList
      } = me,
      strips = ObjectHelper.values(me.strips, (k, v) => !dockDirection[v === null || v === void 0 ? void 0 : v.dock]).sort(me.byWeightSortFn),
      innermostStrips = {
        top: null,
        right: null,
        bottom: null,
        left: null
      };
    let bar, before, dock, i, name, vertical, wrap;
    if (footer) {
      dock = footer.dock || 'bottom';
      strips.unshift({
        dock,
        element: {
          tag: 'footer',
          reference: 'footerElement',
          html: typeof footer === 'string' ? footer : footer.html,
          class: {
            ...uiClassList,
            [`b-dock-${dock}`]: 1,
            [`${footer.cls || ''}`]: 1
          }
        }
      });
    }
    if (bodyCls) {
      if (!bodyConfig[name = 'className']) {
        name = 'class';
      }
      bodyConfig[name] = new DomClassList(bodyConfig[name]).assign(bodyCls);
    }
    /*
        The higher the weight, the closer to the center we place the toolbar. Consider:
            {
                tbar : ...,
                bbar :...,
                strips : {
                    lbar1 : { weight : 10, ... },
                    tbar2 : { weight : 20, ... },
                    lbar2 : { weight : 30, ... },
                    rbar  : { weight : 40, ... }
                }
            }
            +---------------------------------------------------+
            | tbar                                              |
            +---------+-----------------------------------------+
            |         | tbar2                                   |
            |         +---------+----------------------+--------+
            |         |         |                      |        |
            |  lbar1  |         |                      |        |
            |         |  lbar2  |                      |  rbar  |
            |         |         |                      |        |
            |         |         |                      |        |
            +---------+---------+----------------------+--------+
            | bbar                                              |
            +---------------------------------------------------+
     */
    for /* empty */
    (i = strips.length; i-- > 0;) {
      bar = strips[i];
      [vertical, before] = dockDirection[bar.dock];
      if (!wrap) {
        wrap = wrapBody(bodyConfig, bodyWrapTag, vertical);
      } else if (wrap.vertical !== vertical) {
        wrap = wrapBody(finishBodyWrap(wrap, uiClassList), '', vertical);
      }
      wrap.children[before ? 'unshift' : 'push'](bar.element);
      innermostStrips[bar.dock] = bar;
    }
    // Flag strips which touch the bodyElement
    setCls(innermostStrips.top, 'b-innermost');
    setCls(innermostStrips.right, 'b-innermost');
    setCls(innermostStrips.bottom, 'b-innermost');
    setCls(innermostStrips.left, 'b-innermost');
    const body = finishBodyWrap(wrap || wrapBody(bodyConfig, bodyWrapTag), uiClassList, true);
    body.class[`${(_me$layout = me.layout) === null || _me$layout === void 0 ? void 0 : _me$layout.containerCls}-panel`] = Boolean((_me$layout2 = me.layout) === null || _me$layout2 === void 0 ? void 0 : _me$layout2.containerCls);
    body.class['b-panel-body-wrap'] = 1;
    body.class[`b-${me.$$name.toLowerCase()}-body-wrap`] = 1;
    return body;
  }
  get hasHeader() {
    // Shortcut to avoid instantiating tools if header has been configured away
    if (this.header === false) {
      return false;
    }
    const {
        header,
        title,
        tools,
        parent
      } = this,
      hasVisibleTools = this.maximizable || Object.values(tools || {}).some(tool => !tool.hidden);
    // Explicitly declared header should always be shown.
    // Implicitly created from title or tools can be suppressed by parent.
    // Explicitly disabled header using false should mean no header at all.
    return header || !(parent !== null && parent !== void 0 && parent.suppressChildHeaders) && (title || hasVisibleTools);
  }
  get rootUiClass() {
    return Panel;
  }
  composeHeader(force) {
    var _me$collapsible;
    const me = this;
    // Don't add a header unless we have one configured, have a title or have visible tools (or are forced to)
    if (!me.hasHeader && !force) {
      return;
    }
    const header = me.header || {},
      dock = header.dock || 'top',
      [before, after] = me.splitHeaderItems({
        as: 'element',
        dock
      }),
      classes = me.$meta.hierarchy,
      title = me.composeTitle(header),
      cls = new DomClassList({
        [`b-dock-${dock}`]: 1,
        ...me.uiClassList
      }, header.cls);
    let i, name;
    for (i = classes.indexOf(Panel); i < classes.length; ++i) {
      name = classes[i].$$name;
      if (name !== 'Grid') {
        cls[`b-${name.toLowerCase()}-header`] = 1;
      }
    }
    const headerConfig = {
      tag: 'header',
      class: cls,
      children: [...before, title, ...after]
    };
    return ((_me$collapsible = me.collapsible) === null || _me$collapsible === void 0 ? void 0 : _me$collapsible.composeHeader(headerConfig)) || headerConfig;
  }
  composeTitle(header) {
    var _this$collapsible;
    const title = typeof header === 'string' ? header : this.title || header.title,
      titleConfig = {
        reference: 'titleElement',
        id: `${this.id}-panel-title`,
        html: title ?? '\xA0',
        class: {
          [`b-align-${header.titleAlign || 'start'}`]: 1,
          'b-header-title': 1,
          ...this.uiClassList
        }
      };
    if (ObjectHelper.isObject(title)) {
      delete titleConfig.html;
      ObjectHelper.merge(titleConfig, title);
    }
    return ((_this$collapsible = this.collapsible) === null || _this$collapsible === void 0 ? void 0 : _this$collapsible.composeTitle(titleConfig)) || titleConfig;
  }
  // Needed to make title go through recompose
  updateTitle() {}
  afterRecompose() {
    var _me$_headerClickDetac;
    super.afterRecompose();
    const me = this,
      {
        headerElement
      } = me;
    (_me$_headerClickDetac = me._headerClickDetacher) === null || _me$_headerClickDetac === void 0 ? void 0 : _me$_headerClickDetac.call(me);
    me._headerClickDetacher = headerElement && EventHelper.on({
      element: headerElement,
      // Click might have lead to panel being destroyed (clicking close tool with `hideAction : 'destroy'`)
      click: ev => {
        var _me$trigger;
        return (_me$trigger = me.trigger) === null || _me$trigger === void 0 ? void 0 : _me$trigger.call(me, 'headerClick', {
          event: ev
        });
      }
    });
  }
  onHeaderClick(info) {
    var _this$collapsible2;
    (_this$collapsible2 = this.collapsible) === null || _this$collapsible2 === void 0 ? void 0 : _this$collapsible2.onHeaderClick(info);
  }
  onPaint() {
    var _this$collapsible3;
    super.onPaint(...arguments);
    (_this$collapsible3 = this.collapsible) === null || _this$collapsible3 === void 0 ? void 0 : _this$collapsible3.onPanelPaint(this);
  }
  splitHeaderItems({
    as,
    dock,
    alt
  } = emptyObject) {
    const me = this,
      asElement = as === 'element',
      {
        collapsed
      } = me,
      endTools = me.getEndTools({
        alt
      }),
      startTools = me.getStartTools({
        alt
      }),
      strips = ObjectHelper.values(me.strips, (k, v) => !headerDock[v === null || v === void 0 ? void 0 : v.dock] && v.isCollapsified({
        collapsed,
        alt
      }));
    let ret = emptySplit,
      after,
      before,
      i;
    if (strips.length + endTools.length + startTools.length) {
      // The "natural" order of equal weight tools/strips is: tool -> strip -> header <- strip <- tool
      ret = [
      // the problem w/mixing tools and strips is the strip weight needs to do two jobs (one when docked
      // in the body and one when docked in the header)
      before = [...startTools, ...strips.filter(e => e.dock === 'pre-header').sort(me.byWeightSortFn)], after = [...strips.filter(e => e.dock === 'header').sort(me.byWeightReverseSortFn), ...endTools]];
      for (i = 0; i < before.length; ++i) {
        var _before$i$syncRotatio, _before$i;
        dock && ((_before$i$syncRotatio = (_before$i = before[i]).syncRotationToDock) === null || _before$i$syncRotatio === void 0 ? void 0 : _before$i$syncRotatio.call(_before$i, dock));
        if (asElement) {
          before[i] = before[i].element;
        }
      }
      for (i = 0; i < after.length; ++i) {
        var _after$i$syncRotation, _after$i;
        dock && ((_after$i$syncRotation = (_after$i = after[i]).syncRotationToDock) === null || _after$i$syncRotation === void 0 ? void 0 : _after$i$syncRotation.call(_after$i, dock));
        if (asElement) {
          after[i] = after[i].element;
        }
      }
    }
    return ret;
  }
  set bodyConfig(bodyConfig) {
    this._bodyConfig = bodyConfig;
  }
  get bodyConfig() {
    const me = this,
      {
        bodyTag
      } = me,
      result = ObjectHelper.merge({
        reference: 'bodyElement',
        className: {
          ...me.getStaticWidgetClasses(Panel, '-content'),
          'b-box-center': 1,
          'b-text-content': me.textContent && me.hasNoChildren
        }
      }, me._bodyConfig);
    if (bodyTag) {
      result.tag = bodyTag;
    }
    if (me.initializingElement || !me._element) {
      // we cannot use the html config since a getter reads innerHTML
      result.html = me.content || me._html;
    }
    return result;
  }
  //endregion
  //region Configs
  changeBodyCls(cls) {
    return DomClassList.from(cls);
  }
  changeTbar(bar) {
    this.getConfig('strips');
    this.strips = {
      tbar: bar
    };
    return this.strips.tbar;
  }
  changeBbar(bar) {
    this.getConfig('strips');
    this.strips = {
      bbar: bar
    };
    return this.strips.bbar;
  }
  // Override to iterate docked Toolbars in the correct order around contained widgets.
  get childItems() {
    var _me$collapsible2;
    const me = this,
      strips = ObjectHelper.values(me.strips, (k, v) => !dockDirection[v === null || v === void 0 ? void 0 : v.dock]).sort(me.byWeightSortFn),
      [before, after] = me.splitHeaderItems(),
      // tools and header strips
      [before2, after2] = ((_me$collapsible2 = me.collapsible) === null || _me$collapsible2 === void 0 ? void 0 : _me$collapsible2.splitHeaderItems()) || emptySplit;
    return [...before, ...before2, ...after, ...after2, ...strips.filter(b => dockDirection[b.dock][1]),
    // the "before" strips come before the items
    ...(me._items || emptyArray$1), ...strips.filter(b => !dockDirection[b.dock][1]).reverse()];
  }
  changeStrips(strips, oldStrips) {
    const me = this,
      manager = me.$strips || (me.$strips = new DynamicObject({
        configName: 'strips',
        factory: Widget,
        inferType: false,
        // the name of a bar in the strips object is not its type
        owner: me,
        created(instance) {
          var _instance$layout;
          const {
            dock
          } = instance;
          if (!headerDock[dock] && !dockDirection[dock]) {
            throw new Error(`Invalid dock value "${dock}"; must be: top, left, right, bottom, header, or pre-header`);
          }
          FunctionHelper.after(instance, 'onConfigChange', (ret, {
            name
          }) => {
            if (barConfigs[name]) {
              me.onConfigChange({
                name: 'strips',
                value: manager.target
              });
            }
          });
          instance.innerItem = false;
          me.onChildAdd(instance);
          instance.parent = me; // in case we are given an instanced widget
          (_instance$layout = instance.layout) === null || _instance$layout === void 0 ? void 0 : _instance$layout.renderChildren();
          if (instance.hasItems) {
            me.hasItems = true;
          }
        },
        setup(config, name) {
          config = ObjectHelper.merge(ObjectHelper.clone(me.stripDefaults['*']), me.stripDefaults[name], config);
          config.parent = me; // so parent can be accessed during construction
          config.ref = name;
          return config;
        },
        transform(config) {
          if (Array.isArray(config)) {
            config = {
              items: config
            };
          }
          return config || null;
        }
      }));
    manager.update(strips);
    if (!oldStrips) {
      // Only return the target once. Further calls are processed above so we need to return undefined to ensure
      // onConfigChange is called. By returning the same target on 2nd+ call, it passes the === test and won't
      // trigger onConfigChange.
      return manager.target;
    }
  }
  //endregion
  //region Collapse/Expand
  /**
   * This property is `true` if the panel is currently collapsing.
   * @property {Boolean}
   * @readonly
   * @category Layout
   */
  get collapsing() {
    var _this$collapsible4;
    return (_this$collapsible4 = this.collapsible) === null || _this$collapsible4 === void 0 ? void 0 : _this$collapsible4.collapsing;
  }
  /**
   * This property is `true` if the panel is currently either collapsing or expanding.
   * @property {Boolean}
   * @readonly
   * @internal
   * @category Layout
   */
  get collapsingExpanding() {
    var _this$collapsible5;
    return (_this$collapsible5 = this.collapsible) === null || _this$collapsible5 === void 0 ? void 0 : _this$collapsible5.collapsingExpanding;
  }
  /**
   * This property is `true` if the panel is currently expanding.
   * @property {Boolean}
   * @readonly
   * @category Layout
   */
  get expanding() {
    var _this$collapsible6;
    return (_this$collapsible6 = this.collapsible) === null || _this$collapsible6 === void 0 ? void 0 : _this$collapsible6.expanding;
  }
  changeCollapsed(value) {
    const me = this,
      {
        collapsible
      } = me;
    me.recompose.flush();
    value = Boolean(value);
    if (!collapsible || me.changingCollapse || !me.isPainted) {
      // if (the collapser is asking...)
      return value;
    }
    collapsible === null || collapsible === void 0 ? void 0 : collapsible.collapse({
      animation: null,
      collapsed: value
    });
  }
  changeCollapsible(collapsible, was) {
    const me = this;
    me.getConfig('tools');
    if (collapsible) {
      if (collapsible === true) {
        collapsible = {};
      } else if (typeof collapsible === 'string') {
        collapsible = {
          [dockDirection[collapsible] ? 'direction' : 'type']: collapsible
        };
      }
    }
    return PanelCollapser.reconfigure(was, collapsible, {
      owner: me,
      defaults: {
        panel: me
      },
      cleanup() {
        if (me.collapsed) {
          was.collapse({
            animation: null,
            collapsed: false
          });
          me._collapsed = 1;
        }
      }
    });
  }
  updateCollapsible(collapsible) {
    const me = this,
      tools = collapsible === null || collapsible === void 0 ? void 0 : collapsible.toolsConfig;
    me.tools = {
      collapse: (tools === null || tools === void 0 ? void 0 : tools.collapse) || null,
      recollapse: (tools === null || tools === void 0 ? void 0 : tools.recollapse) || null
    };
    if (collapsible && me.isPainted && me.collapsed) {
      me._collapsed = 1;
    }
    if (me.collapsed === 1) {
      me.collapsed = true;
    }
  }
  _collapse(collapsed, options) {
    var _this$collapsible7;
    if (options !== true && options !== undefined) {
      // allow expand(false) to be equivalent to collapse(true)
      // or collapse(false) to be equivalent to expand(true)
      if (options === false) {
        collapsed.collapsed = !collapsed.collapsed;
      } else if (typeof options === 'number') {
        collapsed.animation = {
          duration: options
        };
      } else if (options === null) {
        collapsed.animation = options;
      } else if (options === true) ;
      // Must be an options object...
      else if ('animation' in options) {
        ObjectHelper.merge(collapsed, options);
      } else {
        collapsed.animation = options;
      }
    }
    return (_this$collapsible7 = this.collapsible) === null || _this$collapsible7 === void 0 ? void 0 : _this$collapsible7.collapse(collapsed);
  }
  collapse(options) {
    return this._collapse({
      collapsed: true
    }, options);
  }
  expand(options) {
    return this._collapse({
      collapsed: false
    }, options);
  }
  toggleCollapsed(options) {
    return this.collapsed ? this.expand(options) : this.collapse(options);
  }
  //endregion
  //region Misc
  get expandedHeaderDock() {
    var _this$initialConfig$h;
    return this._expandedHeaderDock ?? ((_this$initialConfig$h = this.initialConfig.header) === null || _this$initialConfig$h === void 0 ? void 0 : _this$initialConfig$h.dock) ?? 'top';
  }
  set expandedHeaderDock(v) {
    this._expandedHeaderDock = v === null || v === void 0 ? void 0 : v.toLowerCase();
  }
  updateHeader(header) {
    if (!this.changingCollapse) {
      this.expandedHeaderDock = header === null || header === void 0 ? void 0 : header.dock;
    }
  }
  updateTrapFocus(trapFocus) {
    var _me$focusTrapListener;
    const me = this;
    me.element.classList[trapFocus ? 'add' : 'remove']('b-focus-trapped');
    me.focusTrapListener = (_me$focusTrapListener = me.focusTrapListener) === null || _me$focusTrapListener === void 0 ? void 0 : _me$focusTrapListener.call(me);
    if (trapFocus) {
      me.focusTrapListener = EventHelper.on({
        element: me.element,
        focusin: 'onFocusTrapped',
        delegate: '.b-focus-trap',
        thisObj: me
      });
      // Create a TreeWalker which visits focusable elements.
      if (!me.treeWalker) {
        me.treeWalker = this.setupTreeWalker(me.element, DomHelper.NodeFilter.SHOW_ELEMENT, acceptNode);
      }
    }
  }
  setupTreeWalker(root, whatToShow, filter) {
    return document.createTreeWalker(root, whatToShow, filter);
  }
  onFocusTrapped(e) {
    const me = this,
      treeWalker = me.treeWalker;
    // The only way of focusing these invisible elements is by TAB-ing to them.
    // If we hit the bottom one, wrap to the top.
    if (e.target === me.bottomFocusTrap) {
      treeWalker.currentNode = me.topFocusTrap;
      treeWalker.nextNode();
    }
    // If we hit the top one, wrap to the bottom.
    else if (e.target === me.topFocusTrap) {
      treeWalker.currentNode = me.bottomFocusTrap;
      treeWalker.previousNode();
    }
    // It was the focus trap of a child widget
    else {
      return;
    }
    me.requestAnimationFrame(() => treeWalker.currentNode.focus());
  }
  get focusElement() {
    // Either use our Containerness to yield the focus element of
    // a descendant or fall back to the encapsulating element.
    return this.hasItems && (super.focusElement || this.element);
  }
  get contentElement() {
    return this.element && this.bodyElement;
  }
  get widgetClassList() {
    const me = this,
      result = super.widgetClassList;
    if (me.hasHeader) {
      var _me$header;
      result.push('b-panel-has-header', `b-header-dock-${((_me$header = me.header) === null || _me$header === void 0 ? void 0 : _me$header.dock) || 'top'}`);
    }
    if (me.tbar) {
      result.push('b-panel-has-top-toolbar');
    }
    if (me.bbar) {
      result.push('b-panel-has-bottom-toolbar');
    }
    return result;
  }
}
// Register this widget type with its Factory
Panel.initClass();
Panel._$name = 'Panel';

/**
 * @module Core/widget/Popup
 */
/**
 * A floating Popup widget, which can contain child {@link Core.widget.Container#config-items widgets} or plain html. Serves as the base class
 * for Menu / Tooltip.
 *
 * When it contains focus, the `Escape` key {@link #config-closeAction closes} the picker. When it hides,
 * focus is reverted to the element from which it entered the Popup, or, if that is no longer focusable,
 * a close relative of that element.
 *
 * @example
 * let popup = new Popup({
 *   forElement : document.querySelector('button'),
 *   items      : [
 *     { type : 'text', placeholder: 'Text' },
 *     { type: 'button', text: 'Okay', style: 'width: 100%', color: 'b-orange'}
 *   ]
 * });
 *
 * @classType popup
 * @inlineexample Core/widget/Popup.js
 *
 * @extends Core/widget/Panel
 */
class Popup extends Panel {
  //region Config
  static get $name() {
    return 'Popup';
  }
  // Factoryable type name
  static get type() {
    return 'popup';
  }
  static get configurable() {
    return {
      /**
       * Auto show flag for Popup.
       * If truthy then Popup is shown automatically upon hover.
       * @config {Boolean}
       * @default
       */
      autoShow: true,
      /**
       * By default a Popup is transient, and will {@link #function-close} when the user clicks or
       * taps outside its owned widgets and when focus moves outside its owned widgets.
       *
       * **Note**: {@link #config-modal Modal} popups won't {@link #function-close} when focus moves outside even if autoClose is `true`.
       *
       * Configure as `false` to make a Popup non-transient.
       * @config {Boolean}
       * @default
       */
      autoClose: true,
      /**
       * Show popup when user clicks the element that it is anchored to. Cannot be combined with showOnHover
       * @config {Boolean}
       * @default
       */
      showOnClick: false,
      /**
       * DOM element to attach popup.
       * @config {HTMLElement}
       */
      forElement: null,
      monitorResize: true,
      floating: true,
      hidden: true,
      axisLock: true,
      // Flip edges if align violates constrainTo
      hideAnimation: {
        opacity: {
          from: 1,
          to: 0,
          duration: '.3s',
          delay: '0s'
        }
      },
      showAnimation: {
        opacity: {
          from: 0,
          to: 1,
          duration: '.4s',
          delay: '0s'
        }
      },
      stripDefaults: {
        bbar: {
          layout: {
            justify: 'flex-end'
          }
        }
      },
      testConfig: {
        hideAnimation: null,
        showAnimation: null
      },
      /**
       * The action to take when calling the {@link #function-close} method.
       * By default, the popup is hidden.
       *
       * This may be set to `'destroy'` to destroy the popup upon close.
       * @config {'hide'|'destroy'}
       * @default
       */
      closeAction: 'hide',
      /**
       * By default, tabbing within a Popup is circular - that is it does not exit.
       * Configure this as `false` to allow tabbing out of the Popup.
       * @config {Boolean}
       * @default
       */
      trapFocus: true,
      /**
       * By default a Popup is focused when it is shown.
       * Configure this as `false` to prevent automatic focus on show.
       * @config {Boolean}
       * @default
       */
      focusOnToFront: true,
      /**
       * Show a tool in the header to close this Popup, and allow `ESC` close it.
       * The tool is available in the {@link Core.widget.mixin.Toolable#property-tools} object
       * under the name `close`. It uses the CSS class `b-popup-close` to apply a
       * default close icon. This may be customized with your own CSS rules.
       * @default false
       * @config {Boolean}
       */
      closable: null,
      /**
       * Show a tool in the header to maximize this popup
       * @config {Boolean}
       * @default false
       */
      maximizable: null,
      /**
       * Optionally show an opaque mask below this Popup when shown.
       * Configure this as `true` to show the mask.
       *
       * When a Popup is modal, it defaults to being {@link Core.widget.Widget#config-centered centered}.
       * Also it won't {@link #function-close} when focus moves outside even if {@link #config-autoClose} is `true`.
       *
       * May also be an object containing the following properties:
       * * `closeOnMaskTap` Specify as `true` to {@link #function-close} when mask is tapped.
       * The default action is to focus the popup.
       *
       * Usage:
       * ```javascript
       * new Popup({
       *     title  : 'I am modal',
       *     modal  : {
       *         closeOnMaskTap : true
       *     },
       *     height : 100,
       *     width  : 200
       * });
       * ```
       *
       * @default false
       * @config {Boolean}
       */
      modal: null,
      /**
       * Set to `true` to make this widget take all available space in the visible viewport.
       * @member {Boolean} maximized
       * @category Float & align
       */
      /**
       * Set to `true` to make this widget take all available space in the visible viewport.
       * @config {Boolean}
       * @default false
       * @category Float & align
       */
      maximized: null,
      tools: {
        close: {
          cls: 'b-popup-close',
          handler: 'close',
          weight: -1000,
          ariaLabel: 'L{Popup.close}',
          hidden: true // shown when closable set to true
        },

        maximize: {
          cls: 'b-popup-expand',
          handler: 'toggleMaximized',
          weight: -999,
          hidden: true // shown when maximizable set to true
        }
      },

      highlightReturnedFocus: true,
      role: 'dialog'
    };
  }
  //endregion
  //region Init & destroy
  finalizeInit() {
    const me = this,
      {
        forElement
      } = me;
    me.anchoredTo = forElement;
    me.initialAnchor = me.anchor;
    if (forElement && me.showOnClick) {
      // disable autoShow if not enabled by config
      if (!me.initialConfig.autoShow) {
        me.autoShow = false;
      }
      EventHelper.on({
        element: forElement,
        click: 'onElementUserAction',
        thisObj: me
      });
    }
    super.finalizeInit();
    // We must not autoShow if there's a forElement but it's not visible
    if (me.autoShow && (!forElement || DomHelper.isVisible(forElement))) {
      if (me.autoShow === true) {
        me.show();
      } else {
        me.setTimeout(() => me.show(), me.autoShow);
      }
    }
  }
  onPaint({
    firstPaint
  }) {
    var _super$onPaint;
    (_super$onPaint = super.onPaint) === null || _super$onPaint === void 0 ? void 0 : _super$onPaint.call(this, ...arguments);
    const me = this;
    // Only add the listener the frst time we paint. If we are not maximizable, it does no harm.
    if (firstPaint && me.headerElement) {
      EventHelper.on({
        element: me.headerElement,
        dblclick: me.onHeaderDblClick,
        thisObj: me
      });
    }
  }
  doDestroy() {
    this.syncModalMask();
    super.doDestroy();
  }
  //endregion
  compose() {
    const {
      hasNoChildren,
      textContent
    } = this;
    return {
      class: {
        // Popup has extra CSS responsibilities at the top level.
        // The CSS needs to know whether it should impose a max-width.
        'b-text-popup': Boolean(textContent && hasNoChildren)
      }
    };
  }
  //region Show/hide
  /**
   * Performs the configured {@link #config-closeAction} upon this popup.
   * By default, the popup hides. The {@link #config-closeAction} may be
   * configured as `'destroy'`.
   * @fires beforeclose If popup is not hidden
   */
  close() {
    const me = this;
    /**
     * Fired when the {@link #function-close} method is called and the popup is not hidden.
     * May be vetoed by returning `false` from a handler.
     * @event beforeClose
     * @param {Core.widget.Popup} source - This Popup
     */
    if (!me._hidden && me.trigger('beforeClose') !== false ||
    // we should destroy it even if it's hidden just omit beforeclose event
    me._hidden && me.closeAction === 'destroy') {
      // Revert focus early when closing a modal popup will lead to destruction, to give listeners a shot at doing
      // their thing. Without this, focus will be reverted as part of the destruction process, and listeners won't
      // be called.
      me.modal && me.closeAction === 'destroy' && me.revertFocus();
      me.unmask();
      // Focus moves unrelated to where the user's attention is upon this gesture.
      // Go into the keyboard mode where the focused widget gets a rendition so that
      // it is obvious where focus now is.
      // Must jump over EventHelper's global mousedown listener which will remove this class.
      if (me.containsFocus && me.highlightReturnedFocus) {
        me.setTimeout(() => me.element.classList.add('b-using-keyboard'), 0);
      }
      return me[me.closeAction]();
    }
  }
  toggleMaximized() {
    this.maximized = !this.maximized;
  }
  updateMaximized(value) {
    DomHelper.toggleClasses(this.element, ['b-maximized'], value);
  }
  //endregion
  //region Events
  onInternalKeyDown(event) {
    const me = this;
    // Close or collapse/unreveal on escape key
    if (event.key === 'Escape') {
      event.stopImmediatePropagation();
      if (me.floating || me.positioned) {
        me.close(true);
      } else if (me.collapsible) {
        if (me.revealed) {
          me.collapsible.toggleReveal();
        } else {
          me.collapse();
        }
      }
    }
  }
  onDocumentMouseDown({
    event
  }) {
    const me = this,
      {
        owner
      } = me,
      {
        target
      } = event;
    // If mousedown was on our owning Button, it is that button's responsibility to
    // toggle its pressed state thereby hiding its menu, so prevent the focus move of the mousedown.
    if (event.type !== 'touchend' && owner !== null && owner !== void 0 && owner.isButton && owner._menu === me && owner.element.contains(target)) {
      event.preventDefault();
      return false;
    }
    if (me.modal && target === Popup.modalMask) {
      event.preventDefault();
      if (me.modal.closeOnMaskTap) {
        me.close();
      } else if (!me.containsFocus) {
        me.focus();
      }
    }
    // in case of outside click and if popup is focused, focusout will trigger closing
    else if (!me.owns(target) && me.autoClose && !me.containsFocus) {
      me.close();
    }
  }
  get isTopModal() {
    return DomHelper.isVisible(Popup.modalMask) && this.element.previousElementSibling === Popup.modalMask;
  }
  onFocusIn(e) {
    const activeEl = DomHelper.getActiveElement(this);
    super.onFocusIn(e);
    // No event handler has moved focus, and target is outermost el
    // then delegate to the focusElement which for a Container
    // is found by finding the first visible, focusable descendant widget.
    if (DomHelper.getActiveElement(this) === activeEl && e.target === this.element) {
      this.focus();
    }
  }
  onFocusOut(e) {
    // For mobile browsers with virtual keyboard, when pressing Done key, focus should move back to the popup
    // https://github.com/bryntum/support/issues/2903
    // window.visualViewport.height could be a decimal value. Using 1px threshold for correct comparing
    const usingVirtualKeyboard = globalThis.visualViewport && globalThis.visualViewport.height < document.documentElement.clientHeight - 1;
    if (!usingVirtualKeyboard && !this.modal && this.autoClose) {
      this.close();
    }
    super.onFocusOut(e);
  }
  onShow() {
    var _super$onShow;
    const me = this;
    if (me.autoClose) {
      me.addDocumentMouseDownListener();
    }
    if (me.focusOnToFront) {
      me.focus();
    }
    (_super$onShow = super.onShow) === null || _super$onShow === void 0 ? void 0 : _super$onShow.call(this);
    // Insert the modal mask below this Popup if needed
    me.syncModalMask();
  }
  addDocumentMouseDownListener() {
    if (!this.mouseDownRemover) {
      this.mouseDownRemover = GlobalEvents.ion({
        globaltap: 'onDocumentMouseDown',
        thisObj: this
      });
    }
  }
  updateModal(modal) {
    // Modal implies that this is floating. Theres no ability for positioned widgets
    // to acquire a modal mask.
    if (modal) {
      this.floating = true;
    }
  }
  syncModalMask() {
    const me = this,
      {
        modal,
        element
      } = me;
    // Cast because modal may be specified as an object
    element.setAttribute('aria-modal', Boolean(modal));
    // Note the difference between Popup.modalMask and this.modalMask.
    // this.modalMask syncs the position of the element in the DOM
    // to be below this element. Popup.modalMask just returns the element.
    if (modal && me.isVisible) {
      // If we have not been explicitly positioned, a modal is centered.
      // And if it's centered, it cannot show an anchor arrow.
      if (typeof me._x !== 'number' && typeof me._y !== 'number') {
        me.centered = true;
        me.anchor = false;
      }
      me.modalMask.classList.remove('b-hide-display');
      element.classList.add('b-modal');
    } else if (me.isPainted) {
      element.classList.remove('b-modal');
      const remainingModals = me.floatRoot.querySelectorAll('.b-modal'),
        topModal = remainingModals.length ? Popup.fromElement(remainingModals[remainingModals.length - 1], 'popup') : null;
      // If there are any other visible modals, drop the mask to just below the new topmost
      if (topModal) {
        topModal.syncModalMask();
      } else {
        Popup.modalMask.classList.add('b-hide-display');
      }
    }
  }
  onHide() {
    var _me$mouseDownRemover, _super$onHide;
    const me = this;
    (_me$mouseDownRemover = me.mouseDownRemover) === null || _me$mouseDownRemover === void 0 ? void 0 : _me$mouseDownRemover.call(me);
    me.mouseDownRemover = null;
    (_super$onHide = super.onHide) === null || _super$onHide === void 0 ? void 0 : _super$onHide.call(this);
    // Insert the modal mask below the topmost Popup if needed, else hide it
    me.syncModalMask();
  }
  onElementUserAction() {
    this.show();
  }
  onHeaderDblClick() {
    if (this.maximizable) {
      this.toggleMaximized();
    }
  }
  //endregion
  updateClosable(closable) {
    this.tools.close.hidden = !closable;
  }
  updateMaximizable(maximizable) {
    this.tools.maximize.hidden = !maximizable;
  }
  /**
   * Returns the modal mask element for this Popup correctly positioned just below this Popup.
   * @internal
   */
  get modalMask() {
    const {
      modalMask
    } = Popup;
    if (modalMask.nextElementSibling !== this.element) {
      this.floatRoot.insertBefore(modalMask, this.element);
    }
    return modalMask;
  }
  /**
   * Returns the modal mask element. It does NOT guarantee its placement in the DOM relative
   * to any Popup. To get the modal mask for a particular Popup, use the instance property.
   * @internal
   */
  static get modalMask() {
    if (!this._modalMask) {
      this._modalMask = DomHelper.createElement({
        className: 'b-modal-mask b-hide-display'
      });
      // Mousewheel should not scroll the body "through" a modal mask.
      EventHelper.on({
        element: this._modalMask,
        wheel: e => e.preventDefault()
      });
    }
    return this._modalMask;
  }
}
// Register this widget type with its Factory
Popup.initClass();
Popup._$name = 'Popup';

/**
 * @module Core/widget/MenuItem
 */
const bIcon = /^b-icon-/,
  bFa = /^b-fa-/;
/**
 * A widget representing a single menu item in a {@link Core.widget.Menu}. May be configured with a
 * {@link #config-checked} state which creates a checkbox which may be toggled. Can also be
 * {@link Core.widget.Widget#config-disabled}, which affects item appearance and blocks interactions.
 *
 * Fires events when activated which bubble up through the parent hierarchy and may be listened for on an ancestor. See
 * {@link Core.widget.Menu Menu} for more details on usage.
 *
 * To add a border above a menu item, you can set {@link #config-separator} to `true`. The separator is automatically
 * hidden if the menu item is the first visible item in the menu.
 *
 * @extends Core/widget/Widget
 * @classType menuitem
 */
class MenuItem extends Widget {
  //region Config
  static get $name() {
    return 'MenuItem';
  }
  // Factoryable type name
  static get type() {
    return 'menuitem';
  }
  static get configurable() {
    return {
      /**
       * If configured with a `Boolean` value, a checkbox is displayed
       * as the start icon, and the {@link #event-toggle} event is fired
       * when the checked state changes.
       * @config {Boolean}
       */
      checked: null,
      /**
       * Set to `true` to display a border above this menu item, if there are other visible menu items before it.
       * @config {Boolean}
       * @default false
       */
      separator: null,
      /**
       * Indicates that this menu item is part of a group where only one can be checked. Assigning a value
       * also sets `toggleable` to `true`.
       * ```
       * const yesButton = new Button({
       *    toggleGroup : 'yesno',
       *    text        : 'Yes'
       * });
       *
       * const noButton = new Button({
       *    toggleGroup : 'yesno',
       *    text        : 'No'
       * });
       * ```
       * @config {String}
       */
      toggleGroup: null,
      /**
       * Returns the instantiated menu widget as configured by {@link #config-menu}.
       * @member {Core.widget.Widget} menu
       * @readonly
       */
      /**
       * A submenu configuration object, or an array of MenuItem configuration
       * objects from which to create a submenu.
       *
       * Configuration object example:
       * ```javascript
       * new Menu({
       *     // Menu items
       *     items : {
       *         move : {
       *             text : 'Main item',
       *             menu : {
       *                 // Submenu items
       *                 firstItem : {
       *                     text : 'Sub-item 1',
       *                     onItem({ eventRecord }) {}
       *                 },
       *                 secondItem : {
       *                     text : 'Sub-item 2',
       *                     onItem({ eventRecord }) {}
       *                 }
       *             }
       *         }
       *     }
       * });
       * ```
       *
       * Array of items example:
       * ```javascript
       * new Menu({
       *     // Menu items
       *     items : {
       *         move : {
       *             text : 'Main item',
       *             // Submenu items
       *             menu : [
       *                 {
       *                     text : 'Sub-item 1',
       *                     onItem({ eventRecord }) {}
       *                 },
       *                 {
       *                     text : 'Sub-item 2',
       *                     onItem({ eventRecord }) {}
       *                 }
       *             ]
       *         }
       *     }
       * });
       * ```
       *
       * Note that this does not have to be a Menu. The `type` config can be used to specify any widget as the submenu.
       * ```javascript
       * new Menu({
       *     // Menu items
       *     items : {
       *         move : {
       *             text : 'Main item',
       *             // Submenu items
       *             menu : [
       *                 {
       *                     type  : 'textfield',
       *                     label : 'Type here'
       *                 },
       *                 {
       *                     type : 'button',
       *                     text : 'Confirm'
       *                 }
       *             ]
       *         }
       *     }
       * });
       * ```
       *
       * @config {Object<String,MenuItemConfig|ContainerItemConfig>|Array<MenuItemConfig|ContainerItemConfig>}
       */
      menu: {
        value: null,
        $config: ['lazy', 'nullify']
      },
      /**
       * Item icon class.
       *
       * All [Font Awesome](https://fontawesome.com/cheatsheet) icons may also be specified as `'b-fa-' + iconName`.
       *
       * Otherwise this is a developer-defined CSS class string which results in the desired icon.
       * @config {String}
       */
      icon: null,
      /**
       * The text to be displayed in the item
       * @config {String} text
       */
      /**
       * By default, upon activate, non-checkbox menu items will collapse
       * the owning menu hierarchy.
       *
       * Configure this as `false` to cause the menu to persist after
       * activating an item
       * @config {Boolean}
       */
      closeParent: null,
      /**
       * If provided, turns the menu item into a link
       * @config {String}
       */
      href: null,
      /**
       * The `target` attribute for the {@link #config-href} config
       * @config {'_self'|'_blank'|'_parent'|'_top'|null}
       */
      target: null,
      localizableProperties: ['text'],
      role: 'menuitem',
      closeMenuDelay: 200
    };
  }
  updateElement(element, oldElement) {
    const result = super.updateElement(element, oldElement);
    if (typeof this.checked === 'boolean') {
      this.role = 'menuitemcheckbox';
    }
    this.ariaHasPopup = this.hasMenu ? 'menu' : false;
    return result;
  }
  compose() {
    var _me$cls;
    const me = this,
      {
        checked,
        href,
        hasMenu,
        separator,
        target,
        text,
        toggleGroup
      } = me,
      isCheckItem = typeof checked === 'boolean',
      icon = me.icon || (isCheckItem ? 'b-fw-icon' : ''),
      checkCls = `b-icon-${toggleGroup ? 'radio-' : ''}`,
      hasCustomContent = typeof text === 'object';
    return {
      tag: href ? 'a' : 'div',
      tabIndex: -1,
      href,
      target,
      class: {
        'b-has-submenu': hasMenu,
        'b-checked': checked,
        // Support both separator config and directly setting separator class
        'b-separator': separator || ((_me$cls = me.cls) === null || _me$cls === void 0 ? void 0 : _me$cls['b-separator'])
      },
      dataset: {
        group: me.toggleGroup
      },
      // Only set aria-checked if it's a check item
      [isCheckItem ? 'aria-checked' : '']: checked,
      // Only set expanded if there's a submenu to expand
      [hasMenu ? 'aria-expanded' : '']: false,
      children: {
        iconElement: icon && {
          // This element is a purely visual cue with no meaning to the A11Y tree
          'aria-hidden': true,
          tag: 'i',
          class: {
            'b-fa': bFa.test(icon),
            'b-icon': bIcon.test(icon),
            'b-menuitem-icon': 1,
            [`${checkCls}checked`]: checked === true,
            [`${checkCls}unchecked`]: checked === false,
            ...DomClassList.normalize(icon, 'object')
          }
        },
        textElement: {
          tag: 'span',
          html: hasCustomContent ? null : text,
          class: {
            'b-menu-text': 1,
            'b-menu-custom-content': hasCustomContent
          },
          children: hasCustomContent ? [text] : null
        },
        subMenuIcon: hasMenu && {
          // This element is a purely visual cue with no meaning to the A11Y tree
          'aria-hidden': true,
          tag: 'i',
          class: {
            'b-fw-icon': 1,
            'b-icon-sub-menu': 1
          }
        }
      }
    };
  }
  /**
   * Actions this item. Fires the {@link #event-item} event, and if this is a {@link #config-checked} item, toggles
   * the checked state, firing the {@link #event-toggle} event.
   */
  doAction(event) {
    const item = this,
      menu = this.parent,
      itemEvent = {
        menu,
        item,
        element: item.element,
        bubbles: true,
        domEvent: event
      };
    if (typeof item.checked === 'boolean') {
      const newCheckedState = !item.checked;
      // Do not allow uncheck in a toggleGroup.
      // A toggleGroup means that one member must always be checked.
      if (!item.toggleGroup || newCheckedState) {
        item.checked = !item.checked;
      }
    }
    // Give internal handlers a chance to inject extra information before
    // user-supplied "item" handlers see the event.
    // Grid's CellMenu feature, HeaderMenu feature and other context menu features do this.
    item.trigger('beforeItem', itemEvent);
    /**
     * This menu item has been activated.
     *
     * Note that this event bubbles up through parents and can be
     * listened for on a top level {@link Core.widget.Menu Menu} for convenience.
     * @event item
     * @param {Core.widget.MenuItem} item - The menu item which is being actioned.
     * @param {Core.widget.Menu} menu - Menu containing the menu item
     * @param {Event} domEvent The user interaction event
     */
    item.trigger('item', itemEvent);
    // Collapse the owning menu hierarchy if configured to do so
    if (item.closeParent && menu) {
      menu.rootMenu.close();
      // Don't prevent links doing their thing
      if (event && !item.href) {
        event.preventDefault();
      }
    }
  }
  get focusElement() {
    return this.element;
  }
  get contentElement() {
    return this.textElement;
  }
  get isFocusable() {
    const {
      focusElement
    } = this;
    // We are only focusable if the focusEl is deeply visible, that means
    // it must have layout - an offsetParent. Body does not have offsetParent.
    // Disabled menu items are focusable but cannot be activated.
    // https://www.w3.org/TR/wai-aria-practices/#h-note-17
    return focusElement && this.isVisible && (focusElement === document.body || focusElement.offsetParent);
  }
  get hasMenu() {
    return this.hasConfig('menu');
  }
  get childItems() {
    // Do not call Menu into existence
    const {
      _menu
    } = this;
    return _menu ? [_menu] : [];
  }
  get text() {
    return this.html;
  }
  set text(text) {
    this.html = text;
  }
  onFocusIn(e) {
    super.onFocusIn(e);
    if (!this.disabled && this.menu) {
      // Small delay so that when mousing down a Menu, every item moved over
      // doesn't instantiate its lazy-create menu and show it.
      this.delay('openMenu', 200);
    }
  }
  onFocusOut(e) {
    this.clearTimeout('openMenu');
    super.onFocusOut(e);
    // If this item has as menu, wait a bit before hiding it to allow cursor to move over it
    // https://github.com/bryntum/support/issues/4080
    if (this._menu) {
      this.menu.closeTimer = this.menu.setTimeout(() => this.closeMenu(), this.closeMenuDelay);
    }
  }
  openMenu(andFocus) {
    const {
      menu
    } = this;
    if (!this.disabled && menu) {
      menu.focusOnToFront = andFocus;
      menu.show();
    }
  }
  onChildShow(shown) {
    super.onChildShow(shown);
    this.ariaElement.setAttribute('aria-expanded', true);
  }
  closeMenu() {
    if (this._menu instanceof Widget) {
      this.menu.close();
    }
  }
  onChildHide(hidden) {
    super.onChildHide(hidden);
    this.ariaElement.setAttribute('aria-expanded', false);
  }
  changeToggleGroup(toggleGroup) {
    if (toggleGroup && typeof this.checked !== 'boolean') {
      this.checked = false;
    }
    return toggleGroup;
  }
  /**
   * Get/sets the checked state of this `MenuItem` and fires the {@link #event-toggle}
   * event upon change.
   *
   * Note that this must be configured as a `Boolean` to enable the checkbox UI.
   * @member {Boolean} checked
   */
  changeChecked(checked, old) {
    if (this.isConfiguring || typeof old === 'boolean') {
      return Boolean(checked);
    }
  }
  updateChecked(checked) {
    const me = this;
    if (!me.isConfiguring) {
      if (me.toggleGroup) {
        me.uncheckToggleGroupMembers();
      }
      me.element.setAttribute('aria-checked', checked);
      /**
       * The checked state of this menu item has changed.
       *
       * Note that this event bubbles up through parents and can be listened for on a top level
       * {@link Core.widget.Menu Menu} for convenience.
       * @event toggle
       * @param {Core.widget.MenuItem} item - The menu item whose checked state changed.
       * @param {Core.widget.Menu} menu - Menu containing the menu item
       * @param {Boolean} checked - The _new_ checked state.
       */
      me.trigger('toggle', {
        menu: me.owner,
        item: me,
        element: me.element,
        bubbles: true,
        checked
      });
    }
  }
  getToggleGroupMembers() {
    const me = this,
      {
        checked,
        toggleGroup,
        element
      } = me,
      result = [];
    if (checked && toggleGroup) {
      DomHelper.forEachSelector(me.rootElement, `[data-group=${toggleGroup}]`, otherElement => {
        if (otherElement !== element) {
          const partnerCheckItem = Widget.fromElement(otherElement);
          partnerCheckItem && result.push(partnerCheckItem);
        }
      });
    }
    return result;
  }
  uncheckToggleGroupMembers() {
    if (this.checked && this.toggleGroup) {
      this.getToggleGroupMembers().forEach(widget => widget.checked = false);
    }
  }
  get closeParent() {
    const result = typeof this.checked === 'boolean' ? this._closeParent : this._closeParent !== false;
    return result && !this.hasMenu;
  }
  changeMenu(config, existingMenu) {
    const me = this,
      {
        constrainTo,
        scrollAction
      } = me.owner;
    // This covers both Array and Object which are valid items config formats.
    // menu could be { itemRef : { text : 'sub item 1 } }. But if it has
    // child items or html property in it, it's the main config
    if (config && typeof config === 'object' && !('items' in config) && !('widgets' in config) && !('html' in config)) {
      config = {
        lazyItems: config
      };
    }
    return Menu.reconfigure(existingMenu, config, {
      owner: me,
      defaults: {
        type: 'menu',
        align: 's0-e0',
        anchor: true,
        autoClose: true,
        autoShow: false,
        cls: 'b-sub-menu',
        // Makes the anchor hoverable to avoid mouseleave
        forElement: me.element,
        owner: me,
        ariaLabel: me.text,
        constrainTo,
        scrollAction
      }
    });
  }
}
// Register this widget type with its Factory
MenuItem.initClass();
MenuItem._$name = 'MenuItem';

const validKeys = {
  ArrowUp: 1,
  ArrowDown: 1,
  ArrowRight: 1,
  ArrowLeft: 1,
  Enter: 1,
  Escape: 1
};
/**
 * @module Core/widget/Menu
 */
/**
 * Menu widget, displays a list of items which the user can select from using mouse or keyboard. Can have submenus.
 *
 * {@inlineexample Core/widget/Menu.js}
 *
 * ## Menu item interaction handling in a complex widget
 *
 * In the case of a menu which is part of a complex UI within a larger Bryntum widget, use
 * of the string form for handlers is advised. A handler which starts with `'up.'` will
 * be resolved by looking in owning widgets of the Menu. For example a Calendar may
 * have handlers for its MenuItems configured in:
 *
 * ```javascript
 * new Calendar({
 *     appendTo : document.body,
 *     project  : myProjectConfig,
 *     tbar  : {
 *         items : {
 *             settings : {
 *                 type : 'button',
 *                 text : 'Settings',
 *
 *                 // High weight so it goes at the end
 *                 weight : 800,
 *                 menu   : [{
 *                     text     : 'Hide non working days',
 *                     checked  : false,
 *
 *                      // The Menu's ownership will be traversed to find this function name.
 *                     onToggle : 'up.toggleHideNonWorkingDays'
 *                 }, {
 *                     text    : 'Clear changes',
 *
 *                      // The Menu's ownership will be traversed to find this function name.
 *                     onClick : 'up.clearUncommittedChanges'
 *                 }]
 *             }
 *         }
 *     },
 *
 *     // Menu handlers found here
 *     toggleHideNonWorkingDays({ checked }) {
 *         // Use Calendar API which creates event in the selected date
 *         this.hideNonWorkingDays = checked;
 *     },
 *
 *     clearUncommittedChanges() {
 *         // Clear changes to our event store which are not yet synced to the server
 *         this.eventStore.revertChanges();
 *     }
 * });
 * ```
 *
 * ```javascript
 * let menu = new Menu({
 *     forElement : btn.element,
 *     items      : [
 *         {
 *             icon : 'b-icon b-icon-add',
 *             text : 'Add'
 *         },
 *         {
 *             icon : 'b-icon b-icon-trash',
 *             text : 'Remove'
 *         },
 *         {
 *             icon     : 'b-icon b-icon-lock',
 *             disabled : true,
 *             text     : 'I am disabled'
 *         },
 *         {
 *             text : 'Sub menu',
 *             menu : [{
 *                 icon : 'b-icon b-fa-play',
 *                 text : 'Play'
 *             }]
 *         }
 *     ],
 *     // Method is called for all ancestor levels
 *     onItem({ item }) {
 *         Toast.show('You clicked ' + item.text);
 *     }
 * });
 * ```
 *
 * @classType menu
 *
 * @extends Core/widget/Popup
 */
class Menu extends Popup {
  //region Config
  static get $name() {
    return 'Menu';
  }
  // Factoryable type name
  static get type() {
    return 'menu';
  }
  static get configurable() {
    return {
      layout: 'vbox',
      focusable: true,
      align: 't-b',
      scrollAction: 'hide',
      /**
       * Specify false to prevent the menu from getting focus when hovering items
       * @default
       * @config {Boolean}
       */
      focusOnHover: null,
      // We do need a Scroller so that we can use its API to scroll around.
      // But the overflow flags default to false.
      scrollable: false,
      defaultType: 'menuitem',
      tools: {
        // To get rid of the close tool from Popup
        close: false
      },
      role: 'menu',
      ariaElement: 'bodyElement'
    };
  }
  /**
   * Currently open sub menu, if any
   * @member {Core.widget.Menu} currentSubMenu
   * @readonly
   */
  //endregion
  /**
   * A descendant menu item has been activated.
   *
   * Note that this event bubbles up through parents and can be
   * listened for on a top level {@link Core.widget.Menu Menu} for convenience.
   * @event item
   * @param {Core.widget.MenuItem} item - The menu item which is being actioned.
   * @param {Core.widget.Menu} menu - Menu containing the menu item
   */
  /**
   * The checked state of a descendant menu item has changed.
   *
   * Note that this event bubbles up through parents and can be
   * listened for on a top level {@link Core.widget.Menu Menu} for convenience.
   * @event toggle
   * @param {Core.widget.MenuItem} item - The menu item whose checked state changed.
   * @param {Core.widget.Menu} menu - Menu containing the menu item
   * @param {Boolean} checked - The _new_ checked state.
   */
  /* break doc comment */
  //region Init
  construct(config) {
    if (Array.isArray(config)) {
      config = {
        lazyItems: config
      };
    }
    super.construct(config);
    EventHelper.on({
      element: this.element,
      click: 'onMouseClick',
      mouseover: 'onMouseOver',
      mouseenter: 'onMouseEnter',
      mouseleave: 'onMouseLeave',
      thisObj: this
    });
  }
  afterShow() {
    // Don't instantiate all our items' subMenus right now.
    // Use our private _menu property which will still be a config item.
    const {
        items,
        element
      } = this,
      hasSubmenu = items.some(item => Boolean(item._menu));
    // afterShow is called before alignment, so this is the correct time
    // to mutate things which will change this Widget's size.
    if (hasSubmenu) {
      element.classList.add('b-menu-with-submenu');
    }
    // Add CSS class to menu if any item has an icon, to allow aligning icon-less items
    const hasIcon = items.some(item => item.icon);
    if (hasIcon) {
      element.classList.add('b-menu-with-icon');
    }
    super.afterShow(...arguments);
  }
  createWidget(item) {
    if (typeof item === 'string') {
      item = {
        text: item
      };
    }
    return super.createWidget(item);
  }
  get focusElement() {
    var _me$parentMenu;
    const me = this,
      fromParentMenu = (_me$parentMenu = me.parentMenu) === null || _me$parentMenu === void 0 ? void 0 : _me$parentMenu.element.contains(DomHelper.getActiveElement(me.parentMenu)),
      firstWidget = me.items[0];
    if (fromParentMenu || DomHelper.usingKeyboard || !(firstWidget instanceof MenuItem)) {
      return super.focusElement;
    }
    return me.element;
  }
  //endregion
  onDocumentMouseDown({
    event
  }) {
    // It's not a click outside if its a click on our owner Menu
    if (!this.parentMenu || !this.parentMenu.owns(event.target)) {
      return super.onDocumentMouseDown(...arguments);
    }
  }
  //region Show
  hide(animate) {
    const me = this;
    // We need to be _hidden when any focused descendants try to revertFocus
    // so that they continue to fall back through the getFocusRevertTarget upward chain.
    super.hide(animate);
    if (!me.isVisible) {
      var _me$currentSubMenu, _me$currentSubMenu$hi;
      // Will have no hide method if destroyed
      (_me$currentSubMenu = me.currentSubMenu) === null || _me$currentSubMenu === void 0 ? void 0 : (_me$currentSubMenu$hi = _me$currentSubMenu.hide) === null || _me$currentSubMenu$hi === void 0 ? void 0 : _me$currentSubMenu$hi.call(_me$currentSubMenu, animate);
      if (me.parentMenu) {
        me.parentMenu.currentSubMenu = null;
      }
    }
  }
  show() {
    super.show(...arguments);
    const {
      parentMenu
    } = this;
    if (this.isVisible && parentMenu) {
      parentMenu.currentSubMenu = this;
    }
  }
  //endregion
  //region Events
  /**
   * Activates a menu item if user clicks on it
   * @private
   */
  onMouseClick(event) {
    const menuItem = event.target.closest('.b-menuitem');
    if (menuItem) {
      this.triggerElement(menuItem, event);
    }
  }
  /**
   * Activates menu items on hover. On real mouse hover, not on a touchstart.
   * @private
   */
  onMouseOver(event) {
    if (this.focusOnHover !== false) {
      var _event$relatedTarget;
      const fromItemElement = (_event$relatedTarget = event.relatedTarget) === null || _event$relatedTarget === void 0 ? void 0 : _event$relatedTarget.closest('.b-widget'),
        toItemElement = event.target.closest('.b-widget'),
        overItem = Widget.fromElement(toItemElement);
      // Activate soon in case they're moving fast over items.
      if (!DomHelper.isTouchEvent && toItemElement && toItemElement !== fromItemElement && overItem.parent === this) {
        this.setTimeout({
          fn: 'handleMouseOver',
          delay: 30,
          args: [overItem],
          cancelOutstanding: true
        });
      }
    }
  }
  handleMouseOver(overItem) {
    overItem.focus();
  }
  onMouseEnter() {
    // If we entered a submenu, ensure any close timer is cancelled
    this.clearTimeout(this.closeTimer);
  }
  // unselect any menu item if mouse leaves the menu element (unless it enters a child menu)
  onMouseLeave(event) {
    const me = this,
      {
        relatedTarget
      } = event,
      leavingToChild = relatedTarget && me.owns(relatedTarget);
    let targetCmp = relatedTarget instanceof HTMLElement && Widget.fromElement(relatedTarget),
      shouldHideMenu = !leavingToChild;
    if (targetCmp) {
      while (targetCmp.ownerCmp) {
        targetCmp = targetCmp.ownerCmp;
      }
      // Or was found and does not belong to current menu DOM tree
      // This condition will not allow possibly existing picker to hide
      // Covered by Menu.t.js
      shouldHideMenu &= !DomHelper.getAncestor(targetCmp.element, [event.target]);
    }
    if (!leavingToChild && shouldHideMenu) {
      // Hide menu unless it was already initiated
      if (me.currentSubMenu && !me.currentSubMenu.closeTimer) {
        me.currentSubMenu.hide();
      }
      // Deactivate currently active *menu items* on mouseleave
      if (me.element.contains(DomHelper.getActiveElement(me)) && DomHelper.getActiveElement(me).matches('.b-menuitem')) {
        me.focusElement.focus();
      }
    }
  }
  /**
   * Keyboard navigation. Up/down, close with esc, activate with enter
   * @private
   */
  onInternalKeyDown(event) {
    const sourceWidget = Widget.fromElement(event),
      isFromWidget = sourceWidget && sourceWidget !== this && !(sourceWidget instanceof MenuItem);
    if (event.key === 'Escape') {
      // Only close this menu if the ESC was in a child input Widget
      (isFromWidget ? this : this.rootMenu).close();
      return;
    }
    super.onInternalKeyDown(event);
    // Do not process keys from certain elements
    if (isFromWidget) {
      return;
    }
    if (validKeys[event.key]) {
      event.preventDefault();
    }
    const el = this.element,
      active = DomHelper.getActiveElement(el);
    this.navigateFrom(active !== el && el.contains(active) ? active : null, event.key, event);
  }
  navigateFrom(active, key, event) {
    const me = this,
      {
        treeWalker
      } = me,
      item = active && me.getItem(active),
      enterSubMenu = me.rtl ? 'ArrowLeft' : 'ArrowRight',
      exitSubMenu = me.rtl ? 'ArrowRight' : 'ArrowLeft';
    let toActivate;
    switch (key) {
      case 'ArrowUp':
        treeWalker.currentNode = active || (active = me.bottomFocusTrap);
        treeWalker.previousNode();
        toActivate = treeWalker.currentNode;
        break;
      case 'ArrowDown':
        treeWalker.currentNode = active || (active = me.topFocusTrap);
        treeWalker.nextNode();
        toActivate = treeWalker.currentNode;
        break;
      case ' ':
        if (active && !active.classList.contains('b-disabled')) {
          if (item !== null && item !== void 0 && item.menu) {
            me.openSubMenu(active, item);
          } else {
            me.triggerElement(active, event);
          }
        }
        break;
      case enterSubMenu:
        if (active && item !== null && item !== void 0 && item.menu && !active.classList.contains('b-disabled')) {
          // opening with arrow keys highlights first item (as in menus on mac)
          const openedMenu = me.openSubMenu(active, item);
          // If show hs not been vetoed, ask it to focus.
          // Container will delegate focus inward if possible.
          openedMenu === null || openedMenu === void 0 ? void 0 : openedMenu.focus();
        } else {
          treeWalker.currentNode = active || (active = me.topFocusTrap);
          treeWalker.nextNode();
          toActivate = treeWalker.currentNode;
        }
        break;
      case exitSubMenu:
        if (me.isSubMenu) {
          me.hide();
        } else if (!active) {
          treeWalker.currentNode = active || (active = me.topFocusTrap);
          treeWalker.nextNode();
          toActivate = treeWalker.currentNode;
        }
        break;
      case 'Enter':
        if (active && !active.classList.contains('b-disabled')) {
          me.triggerElement(active, event);
        }
        break;
    }
    // Move focus to wherever we have calculated
    if (toActivate) {
      // Previous moved to encapsulating element; wrap from end
      if (toActivate === me.element) {
        me.navigateFrom(me.bottomFocusTrap, 'ArrowUp', event);
      }
      // Next could not move because we're at the end; wrap from top
      else if (toActivate === active) {
        me.navigateFrom(me.topFocusTrap, 'ArrowDown', event);
      } else {
        toActivate.focus();
      }
    }
  }
  //endregion
  //region Activate menu item
  getItem(item) {
    // Cannot use truthiness test because index zero may be passed.
    if (item != null) {
      // Access by index
      if (typeof item === 'number') {
        return this.items[item];
      }
      // Access by element
      if (item.nodeType === Element.ELEMENT_NODE) {
        return Widget.fromElement(item, 'menuitem', this.contentElement);
      }
      // Access by id
      return this.items.find(c => c.id == item);
    }
  }
  /**
   * Activate a menu item (from its element)
   * @private
   * @fires item
   * @param menuItemElement
   */
  triggerElement(menuItemElement, event) {
    const item = this.getItem(menuItemElement);
    // If the trigger gesture happened on a non-MenuItem
    // item will be undefined. Do not action on a non-MenuItem
    // or a disabled MenuItem
    if (item && !item.disabled) {
      item.doAction(event);
    }
  }
  /**
   * Returns true if this menu is a sub menu.
   * To find out which menu is the parent, check {@link #property-parentMenu}.
   * @type {Boolean}
   * @readonly
   */
  get isSubMenu() {
    var _this$owner;
    return this === ((_this$owner = this.owner) === null || _this$owner === void 0 ? void 0 : _this$owner.menu);
  }
  /**
   * Opens a submenu anchored to a menu item
   * @private
   * @param element
   * @param item
   */
  openSubMenu(element, item) {
    const me = this,
      subMenu = item.menu;
    if (subMenu) {
      if (!subMenu.isVisible) {
        var _item$onBeforeSubMenu;
        const event = {
          item,
          element
        };
        if (me.trigger('beforeSubMenu', event) === false) {
          return;
        }
        if (((_item$onBeforeSubMenu = item.onBeforeSubMenu) === null || _item$onBeforeSubMenu === void 0 ? void 0 : _item$onBeforeSubMenu.call(item, event)) === false) {
          return;
        }
        subMenu.show();
      }
      return me.currentSubMenu = subMenu;
    }
  }
  /**
   * Get/set focused menu item.
   * Shows submenu if newly focused item has a menu and is not disabled.
   * @property {HTMLElement}
   */
  set selectedElement(element) {
    const me = this,
      lastSelected = me._selectedElement;
    if (lastSelected) {
      const lastItem = me.getItem(lastSelected),
        lastItemMenu = lastItem === null || lastItem === void 0 ? void 0 : lastItem.menu;
      lastItemMenu === null || lastItemMenu === void 0 ? void 0 : lastItemMenu.hide();
      lastSelected.classList.remove('b-active');
    }
    me._selectedElement = element;
    // might set to null to deselect
    if (element) {
      const doFocus = DomHelper.isFocusable(element);
      element.classList.add('b-active');
      me.scrollable.scrollIntoView(element, {
        animate: !doFocus,
        focus: doFocus
      });
    }
  }
  get selectedElement() {
    return this._selectedElement;
  }
  selectFirst() {
    const treeWalker = this.treeWalker;
    treeWalker.currentNode = this.topFocusTrap;
    treeWalker.nextNode();
    // If we are under keyboard control, this must happen in the next
    // animation frame so that the keydown event doesn't fire on the
    // newly focused node.
    this.requestAnimationFrame(() => treeWalker.currentNode.focus());
  }
  //endregion
  //region Close
  /**
   * Gets the parent Menu if this Menu is a submenu, or `undefined`.
   * @property {Core.widget.Menu}
   */
  get parentMenu() {
    var _result$up;
    const result = this.owner;
    return result && (result.isMenu ? result : (_result$up = result.up) === null || _result$up === void 0 ? void 0 : _result$up.call(result, 'menu'));
  }
  /**
   * Gets this menus root menu, the very first menu shown in a sub menu hierarchy
   * @property {Core.widget.Menu}
   * @private
   */
  get rootMenu() {
    let menu = this;
    while (menu.parentMenu instanceof this.constructor) {
      menu = menu.parentMenu;
    }
    return menu;
  }
  //endregion
}
// Register this widget type with its Factory
Menu.initClass();
Menu._$name = 'Menu';

/**
 * @module Core/feature/base/ContextMenuBase
 */
let contextMenuKeyEvent;
/**
 * Abstract base class used by other context menu features.
 *
 * ## Keyboard shortcuts
 * This base class has the following default keyboard shortcuts:
 *
 * | Keys       | Action               | Action description                               |
 * |------------|----------------------|--------------------------------------------------|
 * | Space      | showContextMenuByKey | Shows context menu for currently focused element |
 * | Ctrl+Space | showContextMenuByKey | Shows context menu for currently focused element |
 *
 * For more information on how to customize keyboard shortcuts, please see our guide
 * (Guides/Customization/Keyboard shortcuts)
 *
 * @extends Core/mixin/InstancePlugin
 * @abstract
 */
class ContextMenuBase extends InstancePlugin {
  static get $name() {
    return 'ContextMenuBase';
  }
  //region Config
  static get configurable() {
    return {
      /**
       * This is a type of the context menu used to generate correct names for methods and events.
       * Should be in camel case. Required to be set in subclass.
       * @config {String}
       * @readonly
       */
      type: null,
      /**
       * Gets the Menu instance that this feature is using.
       * @member {Core.widget.Menu} menu
       * @readonly
       */
      /**
       * A config which will be applied when creating the Menu component.
       * @config {MenuConfig}
       */
      menu: {
        $config: ['lazy', 'nullify'],
        value: {
          type: 'menu',
          autoShow: false,
          closeAction: 'hide',
          scrollAction: 'hide',
          constrainTo: globalThis
        }
      },
      /**
       * {@link Core/widget/Menu} items object containing named child menu items to apply to the feature's
       * provided context menu.
       *
       * This may add extra items as below, but may also remove any of the default items by configuring the name
       * of the item as `null`.
       *
       * ```javascript
       * features : {
       *     cellMenu : {
       *         // This object is applied to the Feature's predefined default items
       *         items : {
       *             switchToDog : {
       *                 text : 'Dog',
       *                 icon : 'b-fa b-fa-fw b-fa-dog',
       *                 onItem({record}) {
       *                     record.dog = true;
       *                     record.cat = false;
       *                 },
       *                 weight : 500     // Make this second from end
       *             },
       *             switchToCat : {
       *                 text : 'Cat',
       *                 icon : 'b-fa b-fa-fw b-fa-cat',
       *                 onItem({record}) {
       *                     record.dog = false;
       *                     record.cat = true;
       *                 },
       *                 weight : 510     // Make this sink to end
       *             },
       *             add : null // We do not want the "Add" submenu to be available
       *         }
       *     }
       * }
       * ```
       *
       * @config {Object<String,MenuItemConfig|Boolean|null>}
       */
      items: {},
      /**
       * Event which is used to show context menu.
       * Available options are: 'contextmenu', 'click', 'dblclick' or `false` to disable.
       * Default value is used from {@link Grid/view/GridBase#config-contextMenuTriggerEvent}
       * @config {String|Boolean}
       */
      triggerEvent: false,
      /**
       * A CSS selector targeting an element, such as an ellipsis icon that when
       * clicked will trigger the menu to show.
       * @config {String}
       */
      clickTriggerSelector: null,
      /**
       * See {@link #keyboard-shortcuts Keyboard shortcuts} for details
       * @config {Object<String,String>} keyMap
       */
      keyMap: {
        ' ': {
          handler: 'showContextMenuByKey',
          weight: 100
        },
        'Ctrl+Space': 'showContextMenuByKey'
      }
    };
  }
  // Plugin configuration. This plugin chains some of the functions in Grid.
  // The contextmenu event is emulated from a taphold gesture on touch platforms.
  static get pluginConfig() {
    return {
      assign: ['showContextMenu'],
      chain: ['onElementContextMenu', 'onElementClick', 'onElementDblClick']
    };
  }
  //endregion
  //region Init
  construct(...args) {
    var _this$type;
    super.construct(...args);
    if (!((_this$type = this.type) !== null && _this$type !== void 0 && _this$type.length)) {
      throw new Error(`Config 'type' is required to be specified for context menu`);
    }
  }
  //endregion
  //region Events
  /**
   * This event fires on the owning widget when an item is selected in the context menu.
   * @event contextMenuItem
   * @on-owner
   * @param {Core.widget.Widget} source The owning widget
   * @param {Core.widget.Menu} menu The menu
   * @param {Core.widget.MenuItem} item Selected menu item
   */
  /**
   * This event fires on the owning widget when a check item is toggled in the context menu.
   * @event contextMenuToggleItem
   * @on-owner
   * @param {Core.widget.Widget} source The owning widget
   * @param {Core.widget.Menu} menu The menu
   * @param {Core.widget.MenuItem} item Selected menu item
   * @param {Boolean} checked Checked or not
   */
  onElementContextMenu(event) {
    this.onElementEvent(event);
  }
  onElementClick(event) {
    this.onElementEvent(event);
  }
  onElementDblClick(event) {
    this.onElementEvent(event);
  }
  onElementEvent(event) {
    // Check if already handled, to only show one context menu
    if (!event.handled && this.triggerEvent === event.type) {
      // Don't show anything if ctrlKey pressed (except on Mac, where it is used for context menu with click)
      if (event.ctrlKey === true && !BrowserHelper.isMac) {
        event.preventDefault();
        return;
      }
      const originalEvent = event;
      // Point the context menu target at the original invoking key event's target
      if (contextMenuKeyEvent) {
        const {
          target
        } = contextMenuKeyEvent;
        // To define properties on the event object in salesforce env first we need to "fix" it
        // https://github.com/bryntum/support/issues/4432
        event = EventHelper.fixEvent(new MouseEvent(event.type, event));
        Object.defineProperty(event, 'target', {
          get: () => target,
          configurable: true
        });
        event.preventDefault = function () {
          originalEvent.preventDefault();
          // Set handled to let other menus know not to act on this fake event
          originalEvent.handled = true;
        };
      }
      this.internalShowContextMenu(event);
    } else if (event.type === 'click' && this.clickTriggerSelector && event.target.matches(this.clickTriggerSelector)) {
      this.internalShowContextMenu(event);
    }
  }
  showContextMenuByKey(event) {
    // Convert space on a non-editable element to a contextmenu event
    if (!DomHelper.isEditable(event.target)) {
      const target = this.getKeyboardContextMenuTarget(event.target);
      if (target) {
        contextMenuKeyEvent = event;
        DomHelper.triggerMouseEvent(target, this.triggerEvent);
        event.handled = true;
        event.preventDefault();
        event.stopImmediatePropagation();
        contextMenuKeyEvent = null;
        // Returning true to let KeyMap know that the event is handled.
        return true;
      }
    }
    // Returning false to let KeyMap know that other actions can be called for this event.
    return false;
  }
  // Pick a target child of a keydowned element to fire a contextmenu event through.
  getKeyboardContextMenuTarget(targetElement) {
    const targetRect = DomHelper.isInView(targetElement);
    return targetElement.children.length ? DomHelper.childFromPoint(targetElement, targetRect.width / 2, targetRect.height / 2) : targetElement;
  }
  //endregion
  //region Menu handlers
  internalShowContextMenu(domEvent) {
    const me = this;
    if (me.disabled) {
      return;
    }
    const data = me.getDataFromEvent(domEvent);
    if (!domEvent.handled && !domEvent.defaultPrevented && data && me.shouldShowMenu(data)) {
      // CTRL + click in Safari triggers contextmenu + click, prevent click to not immediately close menu
      if (domEvent.type === 'contextmenu' && BrowserHelper.isSafari && domEvent.ctrlKey && !domEvent.metaKey) {
        EventHelper.on({
          element: domEvent.target,
          capture: true,
          once: true,
          thisObj: this,
          click(e) {
            e.preventDefault();
            e.stopImmediatePropagation();
          }
        });
      }
      data.domEvent = domEvent;
      me.showContextMenu(data);
    }
  }
  getDataFromEvent(event) {
    return {
      event,
      targetElement: this.getTargetElementFromEvent(event)
    };
  }
  getTargetElementFromEvent(event) {
    return event.target;
  }
  /**
   * Shows the context menu.
   * @param {Event} event The initiating event.
   * @param {Object|HTMLElement} [alignSpec] Menu alignment specification, or an element to align to
   * @param {HTMLElement|Core.helper.util.Rectangle} alignSpec.target The Element or Rectangle to align to.
   * @param {Boolean} [alignSpec.anchor] True to show a pointer arrow connecting to the target. Defaults to false.
   * @param {Boolean} [alignSpec.overlap] True to allow this to overlap the target.
   * @param {String} alignSpec.align The alignment specification string, `[trbl]n-[trbl]n`.
   * @on-owner
   */
  async showContextMenu(event, alignSpec) {
    var _me$_menu;
    const me = this,
      isDOMEvent = DomHelper.isDOMEvent(event),
      menuContext = isDOMEvent ? me.getDataFromEvent(event) : event,
      domEvent = isDOMEvent ? event : menuContext.domEvent;
    // If our menu was visible from last invocation, hide it.
    // Apps may need the ${type}MenuShow event which is triggered in onShow.
    (_me$_menu = me._menu) === null || _me$_menu === void 0 ? void 0 : _me$_menu.hide();
    if (me.disabled) {
      return;
    }
    /**
     * @member {Object} menuContext
     * An informational object containing contextual information about the last activation
     * of the context menu. The base properties are listed below. Some subclasses may add extra
     * contextual information such as `eventRecord` and `resourceRecord` to the block.
     * @property {Event} menuContext.domEvent The initiating event.
     * @property {Event} menuContext.event DEPRECATED: The initiating event.
     * @property {Number[]} menuContext.point The client `X` and `Y` position of the initiating event.
     * @property {HTMLElement} menuContext.targetElement The target to which the menu is being applied.
     * @property {Object<String,MenuItemConfig|Boolean|null>} menuContext.items The context menu **configuration** items.
     * @property {Core.data.Model[]} menuContext.selection The record selection in the client (Grid, Scheduler, Gantt or Calendar).
     * @readonly
     */
    me.menuContext = menuContext;
    const {
        type,
        client,
        processItems
      } = me,
      elCenter = DomHelper.isInView(menuContext.targetElement).center;
    Objects.assign(menuContext, {
      feature: me,
      point: domEvent !== null && domEvent !== void 0 && domEvent.clientX ? [domEvent.clientX + 1, domEvent.clientY + 1] : [elCenter.x, elCenter.y],
      menu: me,
      items: {},
      selection: client.selectedRecords
    });
    // Call the chainable method which other features use to add or remove their own menu items.
    me.callChainablePopulateMenuMethod(menuContext);
    // Merge with user defined items
    Objects.merge(menuContext.items, me.baseItems);
    // Do not drop through to browser context menu if all our items have been hidden, or processItems
    // returns false to veto the show.
    me.preventDefaultEvent(menuContext);
    // Allow user a chance at processing the items and preventing the menu from showing
    if ((!processItems || me.callback(processItems, client, [menuContext]) !== false) && me.hasActiveMenuItems(menuContext)) {
      me.populateItemsWithData(menuContext);
      // beforeContextMenuShow is a lifecycle method which may be implemented in subclasses to preprocess the event.
      if (me.beforeContextMenuShow(menuContext) !== false) {
        const {
          menu
        } = me;
        // Trigger event that allows preventing menu or manipulating its items.
        let result = client.trigger(`${type}MenuBeforeShow`, menuContext);
        if (ObjectHelper.isPromise(result)) {
          // Let others know that this event has been handled.
          domEvent.handled = true;
          result = await result;
        }
        if (result !== false) {
          var _me$touchMoveDetacher;
          menu.items = menuContext.items;
          menu.showBy(alignSpec || {
            target: menuContext.domEvent
          });
          // Any drag drop type action should hide the menu
          (_me$touchMoveDetacher = me.touchMoveDetacher) === null || _me$touchMoveDetacher === void 0 ? void 0 : _me$touchMoveDetacher.call(me);
          me.touchMoveDetacher = EventHelper.on({
            element: client.element,
            touchmove: () => menu.hide(),
            thisObj: menu,
            once: true
          });
          // A DOM event will not be present if this is being called programatically
          // with a generated eventParams block which has no `domEvent` property.
          // ContextMenuBase#internalShowContextMenu injects that property when
          // reacting to a contextmenu event.
          if (domEvent) {
            domEvent.preventDefault();
            // Let others know that this event has been handled
            domEvent.handled = true;
          }
        }
      }
    }
  }
  /**
   * Returns the base, configured-in menu items set from the configured items, taking into
   * account the namedItems the feature offers.
   * @property {Object[]}
   * @readonly
   * @internal
   */
  get baseItems() {
    if (!this._baseItems) {
      const me = this,
        {
          namedItems
        } = me,
        baseItems = me._baseItems = Objects.assign({}, me.items);
      // Substitute any named items into any of our items that reference them.
      for (const ref in baseItems) {
        const item = baseItems[ref];
        if (item) {
          // If this class or instance has a "namedItems" object
          // named by this ref, then use it as the basis for the item
          if (namedItems && ref in namedItems) {
            baseItems[ref] = typeof item === 'object' ? Objects.merge(Objects.clone(namedItems[ref]), item) : namedItems[ref];
          } else if (item === true) {
            delete baseItems[ref];
          }
        }
      }
    }
    return this._baseItems;
  }
  /**
   * Hides the context menu
   * @internal
   */
  hideContextMenu(animate) {
    var _this$menu;
    (_this$menu = this.menu) === null || _this$menu === void 0 ? void 0 : _this$menu.hide(animate);
  }
  callChainablePopulateMenuMethod(eventParams) {
    var _this$client, _this$client2;
    // For example `populateCellMenu`
    (_this$client = (_this$client2 = this.client)[`populate${StringHelper.capitalize(this.type)}Menu`]) === null || _this$client === void 0 ? void 0 : _this$client.call(_this$client2, eventParams);
  }
  hasActiveMenuItems(eventParams) {
    // We only have a viable menu if we have some non-null items which are visible.
    // Some Menu features hide certain menu options under conditions like
    // client being readOnly. This can result in no menu options being visible.
    // Under these circumstances, showContextMenu must not attempt to show an empty Menu.
    return Object.values(eventParams.items).some(item => item && !item.hidden);
  }
  /**
   * Override this function and return `false` to prevent the context menu from being shown. Returns `true` by default.
   * @returns {Boolean}
   * @internal
   */
  shouldShowMenu() {
    return true;
  }
  beforeContextMenuShow(eventParams) {}
  populateItemsWithData(eventParams) {}
  preventDefaultEvent(eventParams) {
    var _eventParams$event;
    (_eventParams$event = eventParams.event) === null || _eventParams$event === void 0 ? void 0 : _eventParams$event.preventDefault();
  }
  //endregion
  //region Configurables
  changeTriggerEvent(triggerEvent) {
    return triggerEvent || this.client.contextMenuTriggerEvent;
  }
  changeMenu(menu, oldMenu) {
    const me = this,
      {
        client,
        type
      } = me;
    if (menu) {
      return Menu.reconfigure(oldMenu, menu ? Menu.mergeConfigs({
        owner: client,
        rootElement: client.rootElement,
        onItem(itemEvent) {
          client.trigger(`${type}MenuItem`, itemEvent);
        },
        onToggle(itemEvent) {
          client.trigger(`${type}MenuToggleItem`, itemEvent);
        },
        onDestroy() {
          me.menu = null;
        },
        // Load up the item event with the contextual info
        onBeforeItem(itemEvent) {
          Object.assign(itemEvent, me.menuContext);
        },
        onShow({
          source: menu
        }) {
          me.menuContext.menu = menu;
          client.trigger(`${type}MenuShow`, me.menuContext);
        }
      }, menu) : null, me);
    } else if (oldMenu !== null && oldMenu !== void 0 && oldMenu.isWidget) {
      oldMenu.destroy();
    }
  }
  //endregion
}

ContextMenuBase._$name = 'ContextMenuBase';

/**
 * @module Core/helper/TemplateHelper
 */
const tagSpaceRe = />[ \t\r\n]+</g,
  multiSpaceRe = /\s\s+/g;
/**
 * Helper for template strings, use as tag function
 * @example
 * TemplateHelper.tpl`...`
 * @internal
 */
class TemplateHelper {
  /**
   * Tag function for template literals that does some basic cleanup
   * @private
   */
  static tpl(strings, ...values) {
    let count = 0,
      output = values.map((val, i) => {
        let ret = strings[i];
        if (Array.isArray(val)) {
          ret += val.reduce((ack, item) => ack += (typeof item === 'string' ? item.trim() : item) + '\n', '');
        } else {
          if (val === undefined) {
            val = '';
          }
          ret += typeof val === 'string' ? val.trim() : val;
        }
        count++;
        return ret;
      }).join('');
    if (count <= strings.length) {
      output += strings[strings.length - 1];
    }
    // Excise unnecessary *soft* whitespace textNodes. We cannot use \s because that
    // matches non-breaking spaces which need to be preserved.
    // Also reduce any usage of multiple spaces to single, since they have no value in html
    return output.replace(tagSpaceRe, '><').replace(multiSpaceRe, ' ').trim();
  }
  /**
   * Tag function for template literals that does some basic cleanup. Version for docs that do not remove blank space,
   * to keep code snippets formatting intact.
   * @private
   */
  static docsTpl(strings, ...values) {
    let count = 0,
      output = values.map((val, i) => {
        let ret = strings[i];
        if (Array.isArray(val)) {
          ret += val.reduce((ack, item) => ack += (typeof item === 'string' ? item.trim() : item) + '\n', '');
        } else {
          if (val === undefined) {
            val = '';
          }
          ret += typeof val === 'string' ? val.trim() : val;
        }
        count++;
        return ret;
      }).join('');
    if (count <= strings.length) {
      output += strings[strings.length - 1];
    }
    // Excise unnecessary *soft* whitespace textNodes. We cannot use \s because that
    // matches non-breaking spaces which need to be preserved.
    return output.replace(tagSpaceRe, '><').trim();
  }
  static repeat(times) {
    return function (...args) {
      return TemplateHelper.tpl(...args).repeat(times);
    };
  }
  static loop(times) {}
}
TemplateHelper._$name = 'TemplateHelper';

/**
 * @module Core/helper/TimeZoneHelper
 */
// region Internal
// Used internally to save offset info
class TimeZoneOffsetInfo extends Array {
  constructor(timeZone, year) {
    super();
    this.timeZone = timeZone;
    this.year = year;
  }
}
// Used internally to handle more info than possible with ordinary Date
class TimeZoneDate {
  constructor(asString, timeZone) {
    this.asString = asString;
    this.timeZone = timeZone;
    this.asArray = parseStringDate(asString);
  }
  // Lazy, used in TZH.toTimeZone
  get asLocalDate() {
    if (!this._asLocalDate) {
      this._asLocalDate = new Date(...this.asArray);
    }
    return this._asLocalDate;
  }
  // Lazy, used when finding offsets
  get asTicksUtc() {
    if (!this._asTicksUtc) {
      this._asTicksUtc = new Date(Date.UTC(...this.asArray)).getTime();
    }
    return this._asTicksUtc;
  }
}
// Takes a local date and converts it to a TimeZoneDate by converting to string and parsing it
const toTimeZoneInternal = (date, timeZone) => {
    const tzDateString = date.toLocaleString('sv-SE', {
      timeZone
    });
    return new TimeZoneDate(tzDateString, timeZone);
  },
  // Takes ticks (Date.getTime()) and a timezone and returns the difference
  getOffsetUtc = (ticks, timeZone) => {
    const {
      asTicksUtc,
      asString
    } = toTimeZoneInternal(new Date(ticks), timeZone);
    return {
      offset: (ticks - asTicksUtc) / 60000,
      tzTicksUtc: asTicksUtc,
      tzString: asString
    };
  },
  // Parse a 'YYYY-MM-DD HH:MM' formatted datetime into an array of numbers (month is zero-based)
  parseStringDate = stringDate => {
    const parsed = stringDate.split(/[\s-:]/).map(i => i * 1);
    parsed[1] -= 1;
    return parsed;
  },
  min = -60000,
  hour = 3600000,
  day = -86400000,
  month = 2592000000,
  // This function will take a IANA time zone and any year, and then loop through each month and test for UTC offsets
  // If it finds more than one, that implies that current time zone has DST that actual year. The function will then go
  // deeper and find the exact datetimes where DST changes occurs.
  // All data is cached, so when same year is asked for later it's already calculated
  findOffsetDates = (timeZone, year) => {
    const cached = offsetDateCache.get(timeZone, year);
    if (cached) {
      return cached;
    }
    const offsets = new TimeZoneOffsetInfo(timeZone, year),
      // The check runs with UTC ticks
      startUtcTicks = new Date(Date.UTC(year, 0, 1)).getTime();
    let ticks = startUtcTicks,
      incr = month,
      monthIndex = 0,
      previousOffset = [],
      currentOffset = null,
      tzTicksUtc,
      tzString,
      offset,
      done;
    // Loop is perhaps a bit difficult to understand. Basically, what it does is this:
    // (1) Go forward month by month looking for changed offsets, if found continue reading (2), else no DST found.
    // (2) Go backwards from date found in (1) day by day until offset changes back to the first one found.
    // (3) Go forwards hour by hour from date found in (2) until offset changes again.
    // (4) Go backwards minute by minute from date found in (3) until offset changes back to the first one found.
    // (5) The offset we're looking for is the one previous to that found in (4).
    // (6) Continue loop for next DST change date.
    while (!done) {
      // Gets UTC offset for current utc ticks
      ({
        offset,
        tzTicksUtc,
        tzString
      } = getOffsetUtc(ticks, timeZone));
      // If first call, add that offset to the list of found offsets.
      // Also save this offset as the current one found
      if (currentOffset == null) {
        currentOffset = offset;
        offsets.push({
          offset
        });
      }
      // If we are looping months or hours and the offset has changed from the one previously found
      else if (incr > 0 && offset !== currentOffset) {
        // Change to loop days or minutes
        incr = incr === month ? day : min;
      }
      // If we are looping days or minutes and the offset again equals the one previously found
      else if (incr < 0 && offset === currentOffset) {
        // If we are looping days, change to loop hours
        if (incr === day) {
          incr = hour;
        }
        // If we are looping minutes, that means that we have found the exact DST change position
        else {
          // Just one offset, add another
          if (offsets.length === 1) {
            offsets.push(previousOffset);
            currentOffset = previousOffset.offset;
            // Continue to find the ending of offset2/start of offset1
          }
          // Has two offset, found ending of offset2/start of offset1
          else {
            offsets[0].startTicks = previousOffset.startTicks;
            offsets[0].startDateString = previousOffset.startDateString;
            // We are done
            done = true;
          }
          // Change to loop months again
          incr = month;
        }
      }
      // Always store previous offset as to easily be able to get back to it in loop
      previousOffset = {
        offset,
        startDateString: tzString,
        startTicks: tzTicksUtc
      };
      // If we're looping months, we need to ignore the day/hour/minute loop on ticks
      if (incr === month) {
        ticks = startUtcTicks;
        ticks += monthIndex * month;
        monthIndex += 1;
      }
      ticks += incr;
      // If now DST, we are done after 12 months
      if (monthIndex > 11) {
        done = true;
      }
    }
    // Save to cache
    offsetDateCache.set(offsets);
    return offsets;
  },
  offsetDateCache = {
    _cache: {},
    get(timeZone, year) {
      var _this$_cache$timeZone;
      return (_this$_cache$timeZone = this._cache[timeZone]) === null || _this$_cache$timeZone === void 0 ? void 0 : _this$_cache$timeZone[year];
    },
    set(offsetInfo) {
      const {
          timeZone
        } = offsetInfo,
        {
          _cache
        } = this;
      if (!_cache[timeZone]) {
        _cache[timeZone] = {};
      }
      _cache[timeZone][offsetInfo.year] = offsetInfo;
    }
  };
// endregion
/**
 * Helper for time zone manipulation.
 */
class TimeZoneHelper {
  static get $name() {
    return 'TimeZoneHelper';
  }
  /**
   * Adjusts the time of the specified date to match the specified time zone. i.e. "what time is it now in this
   * timezone?"
   *
   * JavaScript dates are always in the local time zone. This function adjusts the time to match the time in the
   * specified time zone, without altering the time zone. Thus, it won't hold the same time as the original date.
   *
   * Note that this time zone calculation relies on the browsers built-in functionality to convert a local date to a
   * string in a given time zone and then converting the string back into a date. If browsers time zone information
   * or interpretation is inaccurate or lacks data, the conversion will probably be inaccurate as well.
   *
   * ```javascript
   * const localDate = new Date(2020, 7, 31, 7); // UTC+2 ('Europe/Stockholm')
   * const cstDate   = TimeZoneHelper.toTimezone(localDate, 'America/Chicago'); // 2020, 7, 31, 0 (still UTC+2, but
   * // appear as UTC-6)
   * ```
   *
   * @static
   * @param {Date} date
   * @param {String|Number} timeZone Timezone supported by `Intl.DateFormat` or a UTC offset in minutes
   * @returns {Date}
   */
  static toTimeZone(date, timeZone) {
    if (typeof timeZone === 'number') {
      return this.toUtcOffset(date, timeZone);
    }
    const tzDate = toTimeZoneInternal(date, timeZone);
    if (tzDate.asArray[3] !== tzDate.asLocalDate.getHours()) {
      console.warn('Incorrect time zone conversion due to local DST-switch detected');
    }
    return tzDate.asLocalDate;
  }
  /**
   * Adjusts the time of the specified date to match local system time zone in the specified time zone. i.e. "what
   * time in my timezone would match time in this timezone?"
   *
   * JavaScript dates are always in the local time zone. This function adjusts the time to match the time in the
   * specified time zone, without altering the time zone. Thus, it won't hold the same time as the original date.
   *
   * Note that this time zone calculation relies on the browsers built-in functionality to convert a date from a given
   * timezone into a local date by calculating specified time zone UTC offsets and using those to perform the date
   * conversion. If browsers time zone information or interpretation is inaccurate or lacks data, the conversion will
   * probably be inaccurate as well.
   *
   * ```javascript
   * const cstDate   = new Date(2022, 8, 27, 4); // CST 'America/Chicago'
   * const localDate = TimeZoneHelper.fromTimeZone(cstDate, 'America/Chicago'); // 2022, 8, 27, 11 (UTC+2 Europe/Stockholm)
   * ```
   *
   * @static
   * @param {Date} date
   * @param {String|Number} timeZone Timezone supported by Intl.DateFormat or a UTC offset in minutes
   * @returns {Date}
   */
  static fromTimeZone(date, timeZone) {
    if (typeof timeZone === 'number') {
      return this.fromUtcOffset(date, timeZone);
    }
    const dateArr = this.dateAsArray(date),
      offsetDates = findOffsetDates(timeZone, date.getUTCFullYear());
    let useOffset = offsetDates[0].offset;
    if (offsetDates.length === 2) {
      const utcTicks = Date.UTC(...dateArr);
      if (utcTicks >= offsetDates[1].startTicks && utcTicks < offsetDates[0].startTicks) {
        useOffset = offsetDates[1].offset;
      }
    }
    // Converting without having to deal with local time
    dateArr[4] += useOffset; // Adds offset minutes
    return new Date(Date.UTC(...dateArr));
  }
  /**
   * Adjusts the time of the specified date with provided UTC offset in minutes
   *
   * JavaScript dates are always in the local time zone. This function adjusts the time to match the time in the
   * specified time zone, without altering the time zone. Thus, it won't hold the same time as the original date.
   *
   * ```javascript
   * const localDate = new Date(2020, 7, 31, 7); // UTC+2
   * const utcDate   = TimeZoneHelper.toUtcOffset(localDate, 0); // 2020, 7, 31, 5 (still UTC+2, but appear as UTC+0)
   * ```
   *
   * @static
   * @private
   * @param {Date} date
   * @param {Number} utcOffset in minutes
   * @returns {Date}
   */
  static toUtcOffset(date, utcOffset) {
    const offset = date.getTimezoneOffset() + utcOffset;
    return new Date(date.getTime() + offset * 60 * 1000);
  }
  /**
   * Adjusts the time of the specified date by removing the provided UTC offset in minutes.
   *
   * JavaScript dates are always in the local time zone. This function adjusts the time to match the time in the
   * specified time zone, without altering the time zone. Thus, it won't hold the same time as the original date.
   *
   * ```javascript
   * const utcDate = new Date(2020, 7, 31, 7); // UTC
   * const utcDate = TimeZoneHelper.fromUtcOffset(localDate, 0); // 2020, 7, 31, 9 (matches 2020-08-31 07:00+00:00)
   * ```
   *
   * @static
   * @private
   * @param {Date} date
   * @param {Number} utcOffset in minutes
   * @returns {Date}
   */
  static fromUtcOffset(date, utcOffset) {
    const offset = -date.getTimezoneOffset() - utcOffset;
    return new Date(date.getTime() + offset * 60 * 1000);
  }
  // Converts a date into an array of its parts ([year, month, day, etc.]).
  // Convenient as a date info bearer which is not affected by local time zone
  static dateAsArray(date) {
    return [date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()];
  }
}
TimeZoneHelper.findOffsetDates = findOffsetDates;
TimeZoneHelper._$name = 'TimeZoneHelper';

/**
 * @module Core/widget/Toast
 */
/**
 * Basic toast. Toasts are stacked on top of each other
 * @example
 * // simplest possible
 * Toast.show('Just toasting');
 *
 * // with config
 * Toast.show({
 *   html: 'Well toasted',
 *   showProgress: false
 * });
 *
 * // as instance (instance is also returned from Toast.show()
 * let toast = new Toast({
 *   html: 'Not going away',
 *   timeout: 0
 * });
 *
 * toast.show();
 *
 * @classType toast
 * @extends Core/widget/Widget
 * @inlineexample Core/widget/Toast.js
 */
class Toast extends Widget {
  static get $name() {
    return 'Toast';
  }
  // Factoryable type name
  static get type() {
    return 'toast';
  }
  static get configurable() {
    return {
      testConfig: {
        destroyTimeout: 1,
        timeout: 1000
      },
      floating: true,
      /**
       * Timeout (in ms) until the toast is automatically dismissed. Set to 0 to never hide.
       * @config {Number}
       * @default
       */
      timeout: 2500,
      autoDestroy: null,
      // How long to wait after hide before destruction
      destroyTimeout: 200,
      /**
       * Show a progress bar indicating the time remaining until the toast is dismissed.
       * @config {Boolean}
       * @default
       */
      showProgress: true,
      /**
       * Toast color (should have match in toast.scss or your custom styling).
       * Valid values in Bryntum themes are:
       * * b-amber
       * * b-blue
       * * b-dark-gray
       * * b-deep-orange
       * * b-gray
       * * b-green
       * * b-indigo
       * * b-lime
       * * b-light-gray
       * * b-light-green
       * * b-orange
       * * b-purple
       * * b-red
       * * b-teal
       * * b-white
       * * b-yellow
       *
       * ```
       * new Toast({
       *    color : 'b-blue'
       * });
       * ```
       *
       * @config {String}
       */
      color: null,
      bottomMargin: 20
    };
  }
  compose() {
    const {
      appendTo,
      color,
      html,
      showProgress,
      style,
      timeout
    } = this;
    return {
      parent: appendTo || this.floatRoot,
      class: {
        ...DomClassList.normalize(color, 'object'),
        'b-toast-hide': 1 // toasts start hidden so we can animate them into view
      },

      html,
      style,
      children: {
        progressElement: showProgress && {
          style: `animation-duration:${timeout / 1000}s;`,
          class: {
            'b-toast-progress': 1
          }
        }
      },
      // eslint-disable-next-line bryntum/no-listeners-in-lib
      listeners: {
        click: 'hide'
      }
    };
  }
  doDestroy() {
    this.untoast();
    super.doDestroy();
  }
  get nextBottom() {
    const {
      bottomMargin,
      element
    } = this;
    return parseInt(element.style.bottom, 10) + element.offsetHeight + bottomMargin;
  }
  /**
   * Show the toast
   */
  async show() {
    await super.show(...arguments);
    const me = this,
      {
        element
      } = me,
      {
        toasts
      } = Toast;
    if (!toasts.includes(me)) {
      var _toasts$;
      element.style.bottom = (((_toasts$ = toasts[0]) === null || _toasts$ === void 0 ? void 0 : _toasts$.nextBottom) ?? me.bottomMargin) + 'px';
      toasts.unshift(me);
      element.getBoundingClientRect(); // force layout so that removing b-toast-hide runs our transition
      element.classList.remove('b-toast-hide');
      if (me.timeout > 0) {
        me.hideTimeout = me.setTimeout('hide', me.timeout);
      }
    }
  }
  /**
   * Hide the toast
   */
  async hide() {
    const me = this;
    me.untoast();
    me.element.classList.add('b-toast-hide');
    if (me.autoDestroy && !me.destroyTimer) {
      me.destroyTimer = me.setTimeout('destroy', me.destroyTimeout);
    }
  }
  untoast() {
    const {
      toasts
    } = Toast;
    if (toasts.includes(this)) {
      toasts.splice(toasts.indexOf(this), 1);
    }
  }
  /**
   * Hide all visible toasts
   */
  static hideAll() {
    Toast.toasts.slice().reverse().forEach(toast => toast.hide());
  }
  /**
   * Easiest way to show a toast
   * @example
   * Toast.show('Hi');
   * @example
   * Toast.show({
   *   html   : 'Read quickly, please',
   *   timeout: 1000
   * });
   * @param {String|ToastConfig} config Message or toast config object
   * @returns {Core.widget.Toast}
   */
  static show(config) {
    const toast = Toast.new({
      autoDestroy: true,
      rootElement: document.body
    }, typeof config === 'string' ? {
      html: config
    } : config);
    toast.show();
    return toast;
  }
}
Toast.toasts = [];
// Register this widget type with its Factory
Toast.initClass();
Toast._$name = 'Toast';

/**
 * @module Core/helper/util/Navigator
 */
/**
 * A helper class which allows keyboard navigation within the {@link #config-target} element.
 * @private
 */
class Navigator extends Base.mixin(Events, Factoryable) {
  static get $name() {
    return 'Navigator';
  }
  // Factoryable type name
  static get type() {
    return 'navigator';
  }
  static get configurable() {
    return {
      /**
       * The owning Widget which is using this Navigator.
       * @config {Core.widget.Widget}
       */
      ownerCmp: null,
      /**
       * If the items in the owning widget are naturally tabbable, then the Navigator does not
       * need to listen for navigation keys and move focus. It just reacts to natural focus
       * movement.
       * @config {Boolean}
       */
      itemsTabbable: null,
      /**
       * The encapsulating element in which navigation takes place.
       * @config {HTMLElement}
       */
      target: null,
      /**
       * The element which provides key events for navigation. Optional. Defaults to the {@link #config-target} element.
       * @config {HTMLElement}
       */
      keyEventTarget: null,
      /**
       * An optional key event processor which may preprocess the key event. Returning `null` prevents processing of the event.
       * @config {Function}
       */
      processEvent: null,
      /**
       * A query selector which identifies descendant elements within the {@link #config-target} which are navigable.
       * @config {String}
       */
      itemSelector: null,
      /**
       * The currently focused element within the {@link #config-target}.
       * @config {HTMLElement}
       */
      activeItem: null,
      /**
       * A CSS class name to add to focused elements.
       * @config {String}
       * @default
       */
      focusCls: 'b-active',
      /**
       * An object containing key definitions keyed by the key name eg:
       *
       * ```javascript
       *  keys : {
       *      "CTRL+Space" : 'onCtrlSpace',
       *      Enter        : 'onEnterKey'
       *  }
       * ```
       *
       * The {@link #config-ownerCmp} is used as the `this` reference and to resolve string method names.
       *
       * Modified key names must be created prepending one or more `'CTRL+'`, `'SHIFT+'`, `'ALT+'`
       * in that order, for example `"CTRL+SHIFT+Enter" : 'showMenu'`
       * @config {Object<String,String>}
       * @default
       */
      keys: null,
      /**
       * Configure as `true` to also navigate when the `CTRL` modifier key is used along with
       * navigation keys.
       * @config {Boolean}
       * @default false
       */
      allowCtrlKey: null,
      /**
       * Configure as `true` to also navigate when the `SHIFT` modifier key is used along with
       * navigation keys.
       * @config {Boolean}
       * @default false
       */
      allowShiftKey: null,
      scrollDuration: 50,
      /**
       * Configure as, or set to `true` to disable the processing of keys.
       * @config {Boolean}
       */
      disabled: null,
      datasetIdProperty: 'id',
      testConfig: {
        scrollDuration: 1
      }
    };
  }
  static get factoryable() {
    return {
      defaultType: 'navigator'
    };
  }
  get activeItem() {
    const {
      _activeItem
    } = this;
    if (this.target.contains(_activeItem)) {
      return _activeItem;
    }
    this._activeItem = null;
  }
  updateOwnerCmp(ownerCmp) {
    if (!this.itemSelector) {
      this.itemSelector = `.${this.ownerCmp.itemCls}`;
    }
    DomHelper.setAttributes(this.keyEventTarget, {
      'aria-activedescendant': `${this.owner.id}-active-descendant`
    });
  }
  set navigationEvent(navigationEvent) {
    const {
      owner
    } = this;
    // Both us and our owning component need to know about the navigation event.
    // Used by the owning component's navigation to detect what interaction event if any caused
    // the focus to be moved. If it's a programmatic focus, there won't be one.
    this._navigationEvent = owner.navigationEvent = navigationEvent;
    // But it's transient. As soon as it has been processed, it goes.
    if (navigationEvent) {
      Promise.resolve(1).then(() => this.navigationEvent = null);
    }
  }
  get navigationEvent() {
    return this._navigationEvent;
  }
  static getComposedKeyName(keyEvent) {
    const keyName = (keyEvent.key || '').trim() || keyEvent.code;
    return `${keyEvent.ctrlKey ? 'CTRL+' : ''}${keyEvent.shiftKey ? 'SHIFT+' : ''}${keyEvent.altKey ? 'ALT+' : ''}${keyName}`;
  }
  onKeyDown(keyEvent) {
    const me = this,
      {
        ownerCmp,
        itemSelector,
        activeItem,
        itemsTabbable
      } = me,
      {
        target
      } = keyEvent,
      firstItem = me.target.querySelector(itemSelector),
      // Not all key events have 'key'
      keyName = (keyEvent.key || '').trim() || keyEvent.code,
      composedKeyName = me.constructor.getComposedKeyName(keyEvent),
      validTarget = target.matches(itemSelector) || target === me.keyEventTarget;
    // Feed the key event through our configured processor, process the event that returns if any.
    // We need to do this even if no items because there may be other widgets inside the owner.
    if (!me.disabled && me.processEvent) {
      keyEvent = me.processEvent.call(ownerCmp, keyEvent);
    }
    // Process the key gesture if there are items and we are visible.
    // Also, if key emanated from a valid target element (Not an owned positioned Widget).
    if (keyEvent && !me.disabled && firstItem && me.target.offsetParent && validTarget) {
      // Only set navigation key names if we are *not* using tabbing.
      if (!itemsTabbable) {
        // Detect whether the navigable items flow inline or downwards.
        if (me.inlineFlow == null) {
          const itemContainer = firstItem.parentNode,
            itemPositionStyle = DomHelper.getStyleValue(firstItem, 'position'),
            itemDisplayStyle = DomHelper.getStyleValue(firstItem, 'display'),
            itemFloatStyle = DomHelper.getStyleValue(firstItem, 'float');
          // This is how we know that RIGHT and LEFT arrow should be used for next and previous.
          // If inlineFlow is false, we use UP and DOWN. Consider tabs in a tab bar.
          me.inlineFlow = itemPositionStyle === 'absolute' || itemDisplayStyle === 'inline' || itemDisplayStyle === 'inline-block' || itemFloatStyle === 'left' || itemFloatStyle === 'right' || DomHelper.getStyleValue(itemContainer, 'display') === 'flex' && DomHelper.getStyleValue(itemContainer, 'flex-direction') === 'row';
        }
        if (!me.prevKey) {
          if (me.inlineFlow) {
            me.prevKey = 'ArrowLeft';
            me.nextKey = 'ArrowRight';
          } else {
            me.prevKey = 'ArrowUp';
            me.nextKey = 'ArrowDown';
          }
        }
      }
      // So that we and our owning component know how we are being told to navigate
      me.navigationEvent = keyEvent;
      if (activeItem) {
        switch (keyName) {
          case me.prevKey:
            if (me.disabled || keyEvent.ctrlKey && !me.allowCtrlKey) {
              return;
            }
            if (keyEvent.shiftKey && !me.allowShiftKey) {
              return;
            }
            keyEvent.preventDefault();
            /* Flagging the event as handled to let KeyMap know that it should ignore it. Need to do it here
             * because navigatePrevious is throttled in Scheduler.
             */
            keyEvent.handled = true;
            me.navigatePrevious(keyEvent);
            break;
          case me.nextKey:
            if (me.disabled || keyEvent.ctrlKey && !me.allowCtrlKey) {
              return;
            }
            if (keyEvent.shiftKey && !me.allowShiftKey) {
              return;
            }
            keyEvent.preventDefault();
            /* Flagging the event as handled to let KeyMap know that it should ignore it. Need to do it here
             * because navigatePrevious is throttled in Scheduler.
             */
            keyEvent.handled = true;
            me.navigateNext(keyEvent);
            break;
          default:
            {
              var _me$keys;
              const keyHandler = (_me$keys = me.keys) === null || _me$keys === void 0 ? void 0 : _me$keys[composedKeyName];
              if (keyHandler && !me.disabled) {
                if (me.callback(keyHandler, me.thisObj || ownerCmp, [keyEvent]) === false) {
                  return;
                }
              }
              // Note that even if this.disabled, the ownerCmp will expect
              // to have its key down handler invoked.
              else if (ownerCmp.onInternalKeyDown) {
                ownerCmp.onInternalKeyDown(keyEvent);
              }
              // One of the handlers moved focus.
              // This KeyDown should not act upon the new target.
              // For example popped up a Popup and focused its "close" Tool.
              if (DomHelper.getActiveElement(target) !== target) {
                keyEvent.preventDefault();
              }
              // No navigation must take place when items are tabbable.
              if (itemsTabbable) {
                return;
              }
            }
        }
      } else {
        // We don't need to handle navigation into the list if the items are naturally tabbable
        if (itemsTabbable) {
          return;
        }
        if (keyName === me.nextKey || keyName === me.prevKey) {
          me.activeItem = me.getDefaultNavigationItem(keyEvent);
        }
      }
      if (me.activeItem !== activeItem) {
        /**
         * Fired when a user gesture causes the active item to change _or become `null`_.
         * @event navigate
         * @param {Event} event The browser event which instigated navigation. May be a click or key or focus move event.
         * @param {HTMLElement} item The newly active item, or `null` if focus moved out.
         * @param {HTMLElement} oldItem The previously active item, or `null` if focus is moving in.
         */
        me.triggerNavigate(keyEvent);
      }
    }
  }
  getDefaultNavigationItem(keyEvent) {
    const {
      target,
      itemSelector,
      prevKey,
      nextKey
    } = this;
    // Navigating backwards from after the component, we default to last item
    if (target.compareDocumentPosition(keyEvent.target) & 4 && keyEvent.key === prevKey) {
      return target.querySelector(`${itemSelector}:last-of-type`);
    }
    // Navigating forwards from before the component we default to the first item
    if (target.compareDocumentPosition(keyEvent.target) & 2 && keyEvent.key === nextKey) {
      return target.querySelector(`${itemSelector}`);
    }
  }
  navigatePrevious(keyEvent) {
    const me = this,
      previous = me.previous;
    keyEvent.preventDefault();
    if (previous) {
      me.ownerCmp.scrollable.scrollIntoView(previous, {
        animate: me.scrollDuration
      }).then(() => {
        me.activeItem = previous;
        me.triggerNavigate(keyEvent);
      });
    }
  }
  navigateNext(keyEvent) {
    const me = this,
      next = me.next;
    keyEvent.preventDefault();
    if (next) {
      me.ownerCmp.scrollable.scrollIntoView(next, {
        animate: me.scrollDuration
      }).then(() => {
        me.activeItem = next;
        me.triggerNavigate(keyEvent);
      });
    }
  }
  get owner() {
    return this.ownerCmp;
  }
  get previous() {
    return this.getAdjacent(-1);
  }
  get next() {
    return this.getAdjacent(1);
  }
  /**
   * Returns the next or previous navigable element starting from the passed `from` element,
   * navigating in the passed direction.
   * @param {HTMLElement} [from] The start point. Defaults to the current {@link #config-activeItem}
   * @param {Number} [direction=1] The direction. -1 for backwards, else forwards.
   */
  getAdjacent(direction = 1, from = this.activeItem) {
    const treeWalker = this.treeWalker;
    treeWalker.currentNode = from;
    treeWalker[direction < 0 ? 'previousNode' : 'nextNode']();
    if (treeWalker.currentNode !== this.activeItem) {
      return treeWalker.currentNode;
    }
  }
  onTargetFocusIn(focusInEvent) {
    const me = this,
      {
        target,
        relatedTarget
      } = focusInEvent,
      {
        owner,
        itemsTabbable,
        skipScrollIntoView,
        previousActiveItem
      } = me;
    // Ignore navigating to a focus trap. It will bounce back in
    if (!target.matches('.b-focus-trap')) {
      if (target.matches(me.itemSelector)) {
        // We may need to know this in downstream code.
        // for example set activeItem must not scrollIntoView on click
        me.skipScrollIntoView = true;
        me.activeItem = target;
        me.skipScrollIntoView = skipScrollIntoView;
        // If we are using natural, TAB based navigation, trigger the navigate event after it really happens.
        if (me.activeItem && itemsTabbable) {
          me.triggerNavigate(focusInEvent);
        }
      }
      // Focus onto target
      else if (target === me.target) {
        const fromWhere = relatedTarget ? target.compareDocumentPosition(relatedTarget) : 0;
        // Upward focusing from within means a SHIFT+TAB, so go to previous sibling
        if (fromWhere & Node.DOCUMENT_POSITION_CONTAINED_BY) {
          var _owner$previousSiblin;
          (_owner$previousSiblin = owner.previousSibling) === null || _owner$previousSiblin === void 0 ? void 0 : _owner$previousSiblin.focus();
        }
        // From outside means go to last active item or first item
        else {
          me.activeItem = previousActiveItem && me.target.contains(previousActiveItem) ? previousActiveItem : 0;
        }
      }
    }
  }
  onTargetFocusOut(focusOutEvent) {
    const me = this,
      {
        relatedTarget
      } = focusOutEvent;
    // Ignore navigating to a focus trap. It will bounce back in
    if (!(relatedTarget !== null && relatedTarget !== void 0 && relatedTarget.matches('.b-focus-trap'))) {
      if (!relatedTarget || !me.target.contains(relatedTarget) || !relatedTarget.matches(me.itemSelector)) {
        if (me.activeItem) {
          me.activeItem = null;
          // If we are using natural, TAB based navigation, trigger the navigate event after it really happens.
          if (me.itemsTabbable) {
            me.triggerNavigate(focusOutEvent);
          }
        }
      }
    }
  }
  onTargetMouseDown(mouseDownEvent) {
    const me = this,
      target = mouseDownEvent.target.closest(me.itemSelector);
    me.navigationEvent = mouseDownEvent;
    if (me.itemsTabbable) {
      // We will already be focused, but selection is driven off navigation
      // so announce that we have "renavigated" to the curremt active item.
      if (target === me.activeItem) {
        me.triggerNavigate(mouseDownEvent);
      }
    }
    // Mousedown is the focus gesture.
    // This holds true even on touch platforms
    // where the mousedown event is synthesized -
    // preventing default prevents focus on the upcoming touchend.
    else if (me.ownerCmp.itemsFocusable === false) {
      me.onFocusGesture(mouseDownEvent);
    }
    // Preempt browser's focusing behaviour which focuses the closest focusable
    // element, and scrolls it into view.
    else if (target) {
      mouseDownEvent.preventDefault();
      // We attempt to focus the target without scrolling.
      DomHelper.focusWithoutScrolling(target);
    }
  }
  onTargetClick(clickEvent) {
    var _me$navigationEvent;
    const me = this,
      {
        skipScrollIntoView
      } = me;
    if (me.skipNextClick || (_me$navigationEvent = me.navigationEvent) !== null && _me$navigationEvent !== void 0 && _me$navigationEvent.ignoreNavigation) {
      me.skipNextClick = false;
      return;
    }
    if (me.disabled) {
      return;
    }
    // We may need to know this in downstream code.
    // for example set activeItem must not scrollIntoView on click
    me.skipScrollIntoView = true;
    // ownerCmp's preprocessing of any navigate event.
    if (me.processEvent) {
      clickEvent = me.processEvent.call(me.ownerCmp, clickEvent);
    }
    if (clickEvent) {
      me.activeItem = clickEvent.target.closest(me.itemSelector);
      me.triggerNavigate(clickEvent);
    }
    me.skipScrollIntoView = skipScrollIntoView;
  }
  // We have to prevent focus moving from eg, an input field when we mousedown
  // or touchtap a non focusable item when ownerCmp has itemsFocusable: false.
  // If the event was not on an item, we must allow it through to allow Lists
  // to contain other widgets.
  onFocusGesture(event) {
    if (event.target === this.ownerCmp.contentElement || event.target.closest(this.itemSelector) && this.ownerCmp.itemsFocusable === false) {
      event.preventDefault();
    }
  }
  acceptNode(node) {
    return node.offsetParent && node.matches && node.matches(this.itemSelector) ? DomHelper.NodeFilter.FILTER_ACCEPT : DomHelper.NodeFilter.FILTER_SKIP;
  }
  changeActiveItem(activeItem) {
    if (activeItem != null) {
      // List and Menu's getItem API allows number, or node or record or record id to be passed
      if (this.ownerCmp.getItem) {
        activeItem = this.ownerCmp.getItem(activeItem);
      }
    }
    return activeItem;
  }
  updateActiveItem(activeItem, oldActiveItem) {
    const me = this,
      {
        ownerCmp
      } = me,
      isActive = oldActiveItem && me.target.contains(oldActiveItem),
      // If we are being called in response to focus movement, it will already be the document.activeElement
      // so in that case, behave is if we were in non-focusing mode, and just add the focused class.
      needsFocus = activeItem && DomHelper.isFocusable(activeItem) && activeItem !== DomHelper.getActiveElement(activeItem);
    if (isActive) {
      me.previousActiveItem = oldActiveItem;
    }
    if (oldActiveItem) {
      oldActiveItem.classList.remove(me.focusCls);
      oldActiveItem.removeAttribute('id');
    }
    // This may be set to null on focusout of the target element.
    // Cannot use truthiness test because index zero may be passed.
    if (activeItem != null) {
      // If the user was able to click the event, they will not expect it to attempt to scroll.
      if (me.skipScrollIntoView) {
        if (needsFocus) {
          DomHelper.focusWithoutScrolling(activeItem);
        }
      } else {
        var _ownerCmp$scrollable;
        (_ownerCmp$scrollable = ownerCmp.scrollable) === null || _ownerCmp$scrollable === void 0 ? void 0 : _ownerCmp$scrollable.scrollIntoView(activeItem, {
          block: 'nearest',
          focus: needsFocus,
          silent: me.scrollSilently
        });
      }
      // No change in active item, do nothing after we've ensured it's fully in view.
      if (activeItem === oldActiveItem && isActive) {
        return;
      }
      activeItem.classList.add(me.focusCls);
      activeItem.id = `${me.owner.id}-active-descendant`;
      me._activeItem = activeItem;
    } else {
      me._activeItem = null;
      // We are clearing the activeItem.
      // If it's focused, keep focus close by actively reverting it.
      if (oldActiveItem === DomHelper.getActiveElement(oldActiveItem)) {
        ownerCmp.revertFocus();
      }
    }
  }
  updateTarget(target, oldTarget) {
    const me = this,
      listeners = {
        element: target,
        thisObj: me,
        focusin: 'onTargetFocusIn',
        focusout: 'onTargetFocusOut',
        // If items are tabbable the mousedown handler will not force the issue by focusing
        // the closest item. We just need to trigger the method so that it is hookable
        mousedown: {
          handler: 'onTargetMouseDown',
          delegate: me.itemSelector
        }
      };
    if (!me.itemsTabbable && !me.itemsFocusable) {
      // We only need to listen for clicks if the items cannot receive focus.
      // If focusable in any way, selection is triggered by navigation.
      listeners.click = 'onTargetClick';
    }
    if (!Object.prototype.hasOwnProperty.call(me, 'acceptNode')) {
      me.acceptNode = me.acceptNode.bind(me);
      // https://github.com/webcomponents/webcomponentsjs/issues/556
      // Work around Internet Explorer wanting a function instead of an object.
      // IE also *requires* this argument where other browsers don't.
      me.acceptNode.acceptNode = me.acceptNode;
    }
    EventHelper.on(listeners);
    // This Navigator object acts as the filter for the TreeWalker. We must implement acceptNode(node)
    me.treeWalker = me.setupTreeWalker(target, DomHelper.NodeFilter.SHOW_ELEMENT, me.acceptNode);
    // If we were not configured with an outside key event provider (think the input field providing UP/DOWN keys for the dropdown)
    // then use the target element as the source.
    if (!me.keyEventTarget) {
      me.keyEventTarget = target;
    }
    // If the activeItem gets removed, we must know, and deactivate.
    (me.targetMutationMonitor = new MutationObserver(me.onTargetChildListChange.bind(me))).observe(target, {
      childList: true,
      subtree: true
    });
  }
  setupTreeWalker(root, whatToShow, filter) {
    // This Navigator object acts as the filter for the TreeWalker. We must implement acceptNode(node)
    return document.createTreeWalker(root, whatToShow, filter);
  }
  onTargetChildListChange() {
    const me = this,
      {
        activeItem,
        datasetIdProperty
      } = me;
    // On DOM mutation, if the activeItem got changed, pull the one with the same ID out again.
    if (activeItem) {
      if (me.target.contains(activeItem)) {
        // This seeminly redundant hack is important.
        // Adding an already present class causes DOM mutation and style recalc.
        if (!activeItem.classList.contains(me.focusCls)) {
          activeItem.classList.add(me.focusCls);
        }
      } else {
        var _me$target$querySelec;
        // Try to focus the same record id, or if not present, the same item index.
        // Passing undefined results in the config setter assuming no-change
        // So we must use null to clear.
        me.activeItem = me.target.querySelector(`${me.itemSelector}.${me.focusCls}[data-${StringHelper.hyphenate(datasetIdProperty)}="${activeItem.dataset[datasetIdProperty]}"]`) || ((_me$target$querySelec = me.target.querySelector(`${me.itemSelector}.${me.focusCls}`)) === null || _me$target$querySelec === void 0 ? void 0 : _me$target$querySelec[activeItem.dataset.index]) || null;
      }
    }
  }
  changeKeyEventTarget(keyEventTarget) {
    this._keyEventTarget = keyEventTarget;
    EventHelper.on({
      element: keyEventTarget,
      keydown: 'onKeyDown',
      thisObj: this
    });
  }
  triggerNavigate(event, item = this.activeItem) {
    var _this$ownerCmp;
    const navEvent = {
      event,
      item,
      oldItem: this.previousActiveItem
    };
    this.trigger('navigate', navEvent);
    (_this$ownerCmp = this.ownerCmp) === null || _this$ownerCmp === void 0 ? void 0 : _this$ownerCmp.trigger('navigate', navEvent);
  }
}
Navigator._$name = 'Navigator';

/**
 * @module Core/mixin/LoadMaskable
 */
/**
 * Simple mixin for load masking configs and helper methods.
 * @mixin
 */
var LoadMaskable = (Target => class LoadMaskable extends Target {
  static $name = 'LoadMaskable';
  static get configurable() {
    return {
      /**
       * A {@link Core.widget.Mask} config object to adjust the {@link Core.widget.Widget#config-maskDefaults}
       * when data is loading. The message and optional configuration from the
       * {@link Core.mixin.LoadMaskable#config-loadMask} config take priority over these options, just as they do
       * for `maskDefaults`, respectively.
       *
       * The final mask configuration for a load mask is as if the following were applied:
       *
       * ```
       *  Object.assign({},
       *      widget.maskDefaults,
       *      widget.loadMaskDefaults,
       *      widget.loadMask);
       * ```
       * @config {MaskConfig}
       * @category Masking
       */
      loadMaskDefaults: {
        useTransition: true,
        showDelay: 1000
      },
      /**
       * A {@link Core.widget.Mask} config object to adjust the {@link Core.widget.Widget#config-maskDefaults}
       * when an error occurs loading data.
       *
       * Set to `false` to disable showing data loading error mask.
       *
       * The final mask configuration for an error mask is as if the following were applied:
       *
       * ```
       *  Object.assign({},
       *      widget.maskDefaults,
       *      widget.loadMaskDefaults,
       *      widget.loadMaskError,
       *      errorMessage);
       * ```
       * @config {MaskConfig|Core.widget.Mask|Boolean}
       * @category Masking
       */
      loadMaskError: {
        icon: 'b-icon b-icon-warning',
        autoClose: 3000,
        showDelay: 0
      },
      /**
       * A {@link Core.widget.Mask} config object, or a message to be shown when a store is performing a remote
       * operation, or Crud Manager is loading data from the sever. Set to `null` to disable default load mask.
       *
       * @config {String|MaskConfig|null}
       * @default "Loading..."
       * @category Masking
       */
      loadMask: {
        text: 'L{GridBase.loadMask}'
      },
      /**
       * A {@link Core.widget.Mask} config object, or a message to be shown when Crud Manager
       * is persisting changes on the server. Set to `null` to disable default sync mask.
       *
       * This config is similar to {@link Core.mixin.LoadMaskable#config-loadMask} but designed for saving data.
       *
       * To create a custom sync mask need to subscribe to the Crud Manager events and show
       * {@link Core.widget.Mask Mask} on `beforeSend` and hide it on `requestDone` and `requestFail`.
       *
       * To create a custom sync mask, set this config to `null` and subscribe to the CrudManager's events to
       * show or hide the {@link Core.widget.Widget#config-masked mask} as desired.
       *
       * ```javascript
       *  widget.crudManager.on({
       *      loadStart() {
       *          widget.masked = {
       *              text : 'Data is loading...'
       *          };
       *      },
       *      load() {
       *          widget.masked = null;
       *      },
       *      loadCanceled() {
       *          widget.masked = null;
       *      },
       *      syncStart() {
       *          widget.masked = null;
       *      },
       *      sync() {
       *          widget.masked = null;
       *      },
       *      syncCanceled() {
       *          widget.masked = null;
       *      },
       *      requestFail({ response }) {
       *          widget.masked.error = response.message || 'Sync failed';
       *      }
       *  });
       *
       *  store.load();
       * ```
       *
       * @config {String|MaskConfig|null}
       * @default "Saving changes, please wait..."
       * @category Masking
       */
      syncMask: {
        text: 'L{GridBase.syncMask}'
      },
      localizableProperties: ['loadMask.text', 'syncMask.text'],
      testConfig: {
        loadMaskError: {
          icon: 'b-icon b-icon-warning',
          autoClose: 500,
          showDelay: 0
        }
      }
    };
  }
  /**
   * Applies the {@link Core.mixin.LoadMaskable#config-loadMask} as the {@link Core.widget.Widget#config-masked mask}
   * for this widget.
   * @returns {Core.widget.Mask}
   * @internal
   */
  applyLoadMask() {
    const me = this,
      {
        loadMask
      } = me;
    if (loadMask) {
      me.masked = Mask.mergeConfigs(me.loadMaskDefaults, loadMask);
    }
    return me.masked;
  }
  /**
   * Updates the current {@link Core.widget.Widget#config-masked mask} for this widget to present the specified
   * `error`.
   * @param {String} error The error message to display in the mask.
   * @returns {Core.widget.Mask}
   * @internal
   */
  applyMaskError(error) {
    const {
      loadMaskError,
      masked
    } = this;
    if (loadMaskError === false) {
      masked.hide();
    } else if (masked) {
      ObjectHelper.assign(masked.errorDefaults, loadMaskError);
      masked.error = error;
    }
    return masked;
  }
  // This does not need a className on Widgets.
  // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
  // to the Widget it's mixed in to should implement thus.
  get widgetClass() {}
});

/**
 * @module Core/util/DayTime
 */
const MILLIS_PER_MINUTE = 60 * 1000,
  MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE,
  MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR,
  timeRe = /(\d+)?:?(\d*)/;
/**
 * This class encapsulates time of day calculations.
 *
 * The goal is to describe a "day" (a 24-hour period) that starts at a specific time (other than midnight). In a
 * calendar day view, this would look like this:
 *
 * ```text
 *              startShift=0                          startShift='12:00'
 *       00:00  +-------+                      12:00  +-------+
 *              |       |                             |       |
 *       01:00  |- - - -|                      13:00  |- - - -|
 *                 ...                                   ...
 *              |       |                             |       |
 *       08:00  |- - - -|   <-- timeStart -->  20:00  |- - - -|
 *              |       |                             |       |
 *       09:00  |- - - -|                      21:00  |- - - -|
 *              |       |                             |       |
 *       10:00  |- - - -|                      22:00  |- - - -|
 *              |       |                             |       |
 *       11:00  |- - - -|                      23:00  |- - - -|
 *              |       |                             |       |
 *       12:00  |- - - -|                      00:00  |- - - -|
 *              |       |                             |       |
 *       13:00  |- - - -|                      01:00  |- - - -|
 *              |       |                             |       |
 *       14:00  |- - - -|                      02:00  |- - - -|
 *              |       |                             |       |
 *       15:00  |- - - -|                      03:00  |- - - -|
 *              |       |                             |       |
 *       16:00  |- - - -|                      04:00  |- - - -|
 *              |       |                             |       |
 *       17:00  |- - - -|    <-- timeEnd -->   05:00  |- - - -|
 *              |       |                             |       |
 *                 ...                                   ...
 *              |       |                             |       |
 *       23:00  |- - - -|                      11:00  |- - - -|
 *              |       |                             |       |
 *       00:00  +-------+                      12:00  +-------+
 * ```
 *
 * In a horizontal format with X for times to render:
 *
 * ```text
 *  startShift = 0
 *
 *      +---+---+---  --+---+---+---+--   --+---+---+---+--   --+---+
 *      |   |   |  ...  |   |XXX|XXX|  ...  |XXX|XXX|   |  ...  |   |
 *      +---+---+---  --+---+---+---+--   --+---+---+---+--   --+---+
 *      00  01  02      07  08  09  10      15  16  17  18      23  00
 *                          ^                       ^
 *                      timeStart               timeEnd
 *
 *  startShift = '12:00'
 *
 *      +---+---+---  --+---+---+---+--   --+---+---+---+--   --+---+
 *      |   |   |  ...  |   |XXX|XXX|X ... X|XXX|XXX|   |  ...  |   |
 *      +---+---+---  --+---+---+---+--   --+---+---+---+--   --+---+
 *      12  13  14      19  20  21  22      03  04  05  06      11  12
 *                          ^                       ^
 *                      timeStart               timeEnd
 * ```
 *
 * When the day wraps over midnight, it is describing this (note timeEnd < timeStart):
 *
 * ```text
 *      +---+---+---  --+---+---+---+--   --+---+---+---+--   --+---+
 *      |XXX|XXX|X ... X|XXX|   |   |  ...  |   |   |XXX|X ... X|XXX|
 *      +---+---+---  --+---+---+---+--   --+---+---+---+--   --+---+
 *      00  01  02      04  05  06  07      18  19  20  21      23  00
 *                          ^                       ^
 *                      timeEnd                 timeStart
 * ```
 *
 * @internal
 */
class DayTime {
  /**
   * Returns a string of "HH:MM" for a given time of day in milliseconds.
   * @param {Number} timeOfDay The time of day in milliseconds.
   * @returns {String}
   * @private
   */
  static format(timeOfDay) {
    const h = Math.floor(timeOfDay / MILLIS_PER_HOUR),
      m = Math.floor(timeOfDay / MILLIS_PER_MINUTE) % 60;
    return `${h}:${m < 10 ? '0' : ''}${m}`;
  }
  /**
   * Parses a time of day which may be a number (0-24 for the hour of the day) or a string in "H:MM" format and
   * returns the time of day as a number of milliseconds.
   *
   * If `time` is a `Date` instance, its time of day is returned.
   * @param {Date|Number|String} time
   * @returns {Number}
   * @private
   */
  static parse(time) {
    const type = typeof time;
    if (type === 'string') {
      const match = timeRe.exec(time);
      time = Number(match[1] || 0) * MILLIS_PER_HOUR + Number(match[2] || 0) * MILLIS_PER_MINUTE;
    } else if (type !== 'number') {
      time = DateHelper.getTimeOfDay(time);
    } else if (time <= 24) {
      // if number of hours (as provided during config)
      time *= MILLIS_PER_HOUR;
    }
    return Math.min(Math.max(Math.floor(time), 0), MILLIS_PER_DAY);
  }
  constructor(config) {
    let startShift = 0,
      startTime,
      endTime;
    if (config !== null && config !== void 0 && config.isDayView) {
      // These are raw configs in hrs or 'HH:MM' on construction and millis after:
      startShift = config.dayStartShift;
      startTime = config.dayStartTime;
      endTime = config.dayEndTime;
    } else if (typeof config === 'number') {
      startShift = startTime = endTime = config;
    } else if (config) {
      /**
       * Either the hour number or a *24 hour* `HH:MM` string denoting the start time for the day. This is
       * midnight by default.
       * @config {Number|String} startShift
       * @default 0
       */
      startShift = config.startShift;
      /**
       * Either the hour number or a *24 hour* `HH:MM` string denoting the first visible time of day. You can also
       * set this value to a ms timestamp representing time from midnight.
       * @config {Number|String} timeStart
       * @default 0
       */
      startTime = config.timeStart;
      /**
       * Either the hour number or a *24 hour* `HH:MM` string denoting the last visible time of day. You can also
       * set this value to a ms timestamp representing time from midnight.
       * @config {Number|String} timeEnd
       * @default 24
       */
      endTime = config.timeEnd;
    }
    this.startShift = startShift = DayTime.parse(startShift || 0);
    this.timeEnd = (endTime == null ? (startShift + MILLIS_PER_DAY) % MILLIS_PER_DAY : DayTime.parse(endTime)) || MILLIS_PER_DAY;
    this.timeStart = startTime == null ? startShift : DayTime.parse(startTime);
  }
  get startHour() {
    return Math.floor(this.timeStart / MILLIS_PER_HOUR);
  }
  get endHour() {
    return Math.floor(this.timeEnd / MILLIS_PER_HOUR);
  }
  /**
   * The number of milliseconds from the day's `startShift` to its `timeStart`.
   * @member {Number}
   */
  get startTimeOffsetMs() {
    const {
      startShift,
      timeStart
    } = this;
    return timeStart < startShift ? MILLIS_PER_DAY - startShift + timeStart : timeStart - startShift;
  }
  /**
   * The `Date` object for the most recently started, shifted day. The time of this `Date` will be the `startShift`.
   * It is possible for this date to be yesterday on a midnight-based calendar. For example, if the `startShift` is
   * 6PM and the current time is 6AM on May 20, this value will be 6PM of May 19 (the most recently started day).
   * @member {Date}
   */
  get today() {
    return this.startOfDay(new Date());
  }
  /**
   * Returns `Date` object for the nearest (shifted) day ending after the given `date`. The time of this `Date` will
   * be the `startShift`.
   *
   * It is possible for this date to be in the next day on a midnight-based calendar. For example, if the `startShift`
   * is 6PM and `date` is 7PM on May 20, this method will return 6PM of May 21 (the nearest day ending).
   * @param {Date} date The date for which to find the nearest day ending.
   * @returns {Date}
   */
  ceil(date) {
    const ret = this.startOfDay(date);
    if (ret < date) {
      ret.setDate(ret.getDate() + 1);
    }
    return ret;
  }
  /**
   * Returns `true` if the time of day for the given `date` is between `timeStart` and `timeEnd`.
   * @param {Date|Number|String} date The hour number, 'HH:MM' time or a `Date` instance to test.
   * @returns {Boolean}
   */
  contains(date) {
    return !this.outside(date);
  }
  /**
   * Returns a "YYYY-MM-DD" string for the given `date`. This value will match the `date` if the time of day is at or
   * after `startShift`, but will be the prior date otherwise.
   * @param {Date|Number} date The date from which to compute the 'YYYY-MM-DD' key.
   * @returns {String}
   */
  dateKey(date) {
    date = this.shiftDate(date, -1);
    return DateHelper.makeKey(date);
  }
  /**
   * Returns a `Date` instance with `startShift` as the time of day and the Y/M/D of the given `date`.
   * @param {Date} date The date's year, month, and day values.
   * @returns {Date}
   */
  dayOfDate(date) {
    return this.shiftDate(DateHelper.clearTime(date)); // return the Date w/the matching YYYY-MM-DD value
  }
  /**
   * Returns the day of week (0-8) for the given `date`. This value will match the `date` if the time of day is at or
   * after `startShift`, but will be the prior day otherwise.
   * @param {Date|Number} date The date from which to compute the day of week.
   * @returns {Number}
   */
  dayOfWeek(date) {
    date = this.shiftDate(date, -1);
    return date.getDay();
  }
  /**
   * Returns the difference between the time of day of the given `date` and `timeStart` in the specified time `unit`.
   * @param {Date|Number|String} date The hour number, 'HH:MM' time or a `Date` instance.
   * @param {String} unit The desired unit of time to return (see {@link Core.helper.DateHelper#function-as-static}).
   * @returns {Number}
   */
  delta(date, unit = 'ms') {
    const {
        timeStart
      } = this,
      time = DayTime.parse(date),
      t = (this.startShift && time < timeStart ? time + MILLIS_PER_DAY : time) - timeStart;
    return unit === 'ms' ? t : DateHelper.as(unit, t, 'ms');
  }
  /**
   * Returns the duration of the visible day (between `timeStart` and `timeEnd`) in the specified time `unit`.
   * @param {String} unit The desired unit of time to return (see {@link Core.helper.DateHelper#function-as-static}).
   * @returns {Number}
   */
  duration(unit = 'ms') {
    const {
        timeStart,
        timeEnd
      } = this,
      millis = timeStart < timeEnd ? timeEnd - timeStart : MILLIS_PER_DAY - timeStart + timeEnd;
    return unit === 'ms' ? millis : DateHelper.as(unit, millis, 'ms');
  }
  /**
   * Returns `true` if this instance describes the same day as the `other`.
   * @param {Core.util.DayTime} other The other instance to which `this` instance should be tested for equality.
   * @returns {Boolean}
   */
  equals(other) {
    // we only need on "?." operator since we short-circuit
    return this.startShift === (other === null || other === void 0 ? void 0 : other.startShift) && this.timeStart === other.timeStart && this.timeEnd === other.timeEnd;
  }
  /**
   * Returns `true` if the times of day described by `startDate` and `endDate` intersect the visible time of this day.
   * @param {Date} startDate The start date of the date range or an event record containing both startDate and endDate
   * fields.
   * @param {Date} [endDate] The end date if `startDate` is not an event record.
   * @returns {Boolean}
   */
  intersects(startDate, endDate) {
    const me = this,
      {
        timeStart,
        timeEnd
      } = me,
      [date0, date1] = me._dateRangeArgs(startDate, endDate),
      [start, end] = me.timeRange(date0, date1);
    if (timeStart < timeEnd) {
      if (start < end) {
        return start < timeEnd && timeStart <= end;
      }
      return start < timeEnd || timeStart <= end;
    }
    return !(start < end) || start < timeEnd || timeStart <= end;
  }
  /**
   * Returns `true` if the given date range is contained within one day.
   * @param {Date} startDate The start date of the date range or an event record containing both startDate and endDate
   * fields.
   * @param {Date} [endDate] The end date if `startDate` is not an event record.
   * @returns {Boolean}
   */
  isIntraDay(startDate, endDate) {
    const me = this,
      [date0, date1] = me._dateRangeArgs(startDate, endDate),
      dayStart = me.startOfDay(date0),
      diff = MILLIS_PER_DAY - DateHelper.diff(dayStart, date1, 'ms');
    // Not <= to match isInterDay
    if (diff < 0) {
      return false;
    }
    // diff > 0 means less than 24hrs, so intraDay... diff==0 means date1 was EOD so we are intraDay if date0 is not
    // also at EOD.
    return diff > 0 || dayStart < date0;
  }
  /**
   * Returns `true` if the given date range or event crosses the day boundary.
   * @param {Date} startDate The start date of the date range or an event record containing both startDate and endDate
   * fields.
   * @param {Date} [endDate] The end date if `startDate` is not an event record.
   * @returns {Boolean}
   */
  isInterDay(timeSpan) {
    return timeSpan.allDay || !this.isIntraDay(...arguments);
  }
  /**
   * Returns -1, 0, or 1 based on whether the time of day for the given `date` is before `timeStart` (-1), or after
   * `timeEnd` (1), or between these times (0).
   * @param {Date|Number|String} date The hour number, 'HH:MM' time or a `Date` instance to test.
   * @returns {Number}
   */
  outside(date) {
    const {
        startShift,
        timeStart,
        timeEnd
      } = this,
      time = DayTime.parse(date);
    if (timeStart < timeEnd) {
      /*
       *      +---+---+---  --+---+---+---+--   --+---+---+---+--   --+---+
       *      |   |   |  ...  |   |XXX|XXX|  ...  |XXX|XXX|   |  ...  |   |
       *      +---+---+---  --+---+---+---+--   --+---+---+---+--   --+---+
       *      00  01  02      07  08  09  10      15  16  17  18      23  00
       *                          ^                       ^
       *                      timeStart               timeEnd
       */
      if (time < timeStart) {
        return time < startShift ? 1 : -1;
      }
      if (time < timeEnd) {
        return 0;
      }
      return time < startShift ? -1 : 1;
    }
    /*
     *      +---+---+---  --+---+---+---+--   --+---+---+---+--   --+---+
     *      |XXX|XXX|X ... X|XXX|   |   |  ...  |   |   |XXX|X ... X|XXX|
     *      +---+---+---  --+---+---+---+--   --+---+---+---+--   --+---+
     *      00  01  02      04  05  06  07      18  19  20  21      23  00
     *                          ^                       ^
     *                      timeEnd                 timeStart
     */
    if (time < timeEnd || time >= timeStart) {
      return 0;
    }
    return time < startShift ? 1 : -1;
  }
  parseKey(key) {
    return this.dayOfDate(DateHelper.parseKey(key));
  }
  /**
   * Returns the given `date` shifted forward (`direction` > 0) or backward (`direction` < 0) by the `startShift`.
   * @param {Number|Date} date The date as a `Date` or the millisecond UTC epoch.
   * @param {Number} direction A value > 0 to shift `date` forward, or < 0 to shift it backwards.
   * @returns {Date}
   */
  shiftDate(date, direction = 1) {
    const {
        startShift
      } = this,
      type = typeof date;
    date = type === 'number' ? new Date(date) : type === 'string' ? DateHelper.parse(date) : new Date(date.getTime());
    // Not this:
    // return (direction && startShift) ? DH.add(date, (direction > 0) ? startShift : -startShift, 'ms') : date;
    // the DH.add() goes via UTC timestamp and so will not end on the correct time of day when DST is hit
    if (direction && startShift) {
      date.setMilliseconds(direction > 0 ? startShift : -startShift);
    }
    return date;
  }
  /**
   * Sorts the given set of `events` by the maximum of `startDate` and `startOfDay` for the given `date`, followed
   * by `duration` in case of a tie.
   * @param {Date} date The day for which events are to be sorted.
   * @param {Object[]} events The events to sort, typically an `Scheduler.model.EventModel[]` but any objects with
   * both `startDate` and `endDate` fields are acceptable.
   * @returns {Object[]} The passed `events` array.
   * @internal
   */
  sortEvents(date, events) {
    const startOfDay = this.startOfDay(date);
    return events === null || events === void 0 ? void 0 : events.sort((event1, event2) => {
      event1 = event1.eventRecord || event1;
      event2 = event2.eventRecord || event2;
      let {
          startDate: start1
        } = event1,
        {
          startDate: start2
        } = event2;
      // Unscheduled events sort to the top.
      if (!start1) {
        return -1;
      }
      if (!start2) {
        return 1;
      }
      // Limit startDates to the start of the day. In other words, all events that start before "midnight" are
      // equally considered as starting at midnight:
      start1 = start1 < startOfDay ? startOfDay : start1;
      start2 = start2 < startOfDay ? startOfDay : start2;
      // Sort by start timestamp first, then duration with respect to clipped start dates.
      return start1 - start2 || event2.endDate - start2 - (event1.endDate - start1);
    });
  }
  /**
   * Returns `Date` object for the nearest started (shifted) day prior to the given `date`. The time of this `Date`
   * will be the `startShift`.
   *
   * It is possible for this date to be in the prior day on a midnight-based calendar. For example, if the `startShift`
   * is 6PM and `date` is 6AM on May 20, this method will return 6PM of May 19 (the nearest started day).
   * @param {Date} date The date for which to find the nearest started day.
   * @returns {Date}
   */
  startOfDay(date) {
    date = this.shiftDate(date, -1);
    date = DateHelper.clearTime(date);
    date = this.shiftDate(date);
    return date;
  }
  /**
   * Returns a range of {@link Core.helper.DateHelper#function-getTimeOfDay-static times of day} for the given
   * date range.
   * @param {Date} startDate The start date of the date range or an event record containing both `startDate` and `endDate` fields
   * @param {Date} [endDate] The end date if `startDate` is not an event record
   * @returns {Number[]}
   */
  timeRange(startDate, endDate) {
    const [start, end] = this._dateRangeArgs(startDate, endDate);
    return [DateHelper.getTimeOfDay(start), DateHelper.getTimeOfDay(end)];
  }
  toString() {
    const {
        startShift,
        timeEnd,
        timeStart
      } = this,
      suffix = startShift ? `@${DayTime.format(startShift)}` : '',
      prefix = DayTime.format(timeStart);
    if (timeStart === timeEnd) {
      return startShift ? suffix : prefix;
    }
    return `${prefix}-${DayTime.format(timeEnd)}${suffix}`;
  }
  /**
   * Decodes the arguments and returns a pair of `Date` objects for the start and end of the date range.
   * @param {Date} startDate The start date of the date range or an event record containing both startDate and endDate
   * fields.
   * @param {Date} [endDate] The end date if `startDate` is not an event record.
   * @returns {Date[]}
   * @private
   */
  _dateRangeArgs(startDate, endDate) {
    return startDate.isModel ? [startDate.startDate, startDate.endingDate] : [startDate, endDate];
  }
}
/**
 * The `DayTime` instance representing a canonical calendar day (starting at midnight).
 * @member {Core.util.DayTime} MIDNIGHT
 * @static
 * @readonly
 */
DayTime.MIDNIGHT = new DayTime({
  startShift: 0,
  timeStart: 0,
  timeEnd: 24
});
DayTime.MILLIS_PER_MINUTE = MILLIS_PER_MINUTE;
DayTime.MILLIS_PER_HOUR = MILLIS_PER_HOUR;
DayTime.MILLIS_PER_DAY = MILLIS_PER_DAY;
DayTime._$name = 'DayTime';

/**
 * @module Core/util/ScrollManager
 */
/**
 * Monitors the mouse position over an element and scrolls the element if the cursor is close to edges. This is used by
 * various features to scroll the grid section element, for example dragging elements close to edges.
 *
 * ```javascript
 * // Instantiate manager for the container element having overflowing content
 * const manager = new ScrollManager({ element : document.querySelector('.container') });
 *
 * // Start monitoring. When pointer approaches 50px region within monitored element edge, scrolling begins
 * manager.startMonitoring();
 *
 * // Stop monitoring.
 * manager.stopMonitoring();
 * ```
 */
class ScrollManager extends Delayable(Base) {
  //region Default config
  static get configurable() {
    return {
      /**
       * Default element to use for scrolling. Can be overridden in calls to `startMonitoring()`.
       * @config {HTMLElement}
       */
      element: null,
      /**
       * Width in pixels of the area at the edges of an element where scrolling should be triggered
       * @config {Number}
       * @default
       */
      zoneWidth: 50,
      /**
       * Scroll speed, higher number is slower. Calculated as "distance from zone edge / scrollSpeed"
       * @config {Number}
       * @default
       */
      scrollSpeed: 5,
      /**
       * The direction(s) to scroll ('horizontal', 'vertical' or 'both')
       * @config {'horizontal'|'vertical'|'both'}
       * @default
       */
      direction: 'both',
      /**
       * Number of milliseconds to wait before scroll starts when the mouse is moved close to an edge monitored by this scroll manager
       * @config {Number}
       * @default
       */
      startScrollDelay: 500,
      /**
       * Set to true to stop scrolling when pointing device leaves the scrollable element.
       * @config {Boolean}
       * @default
       */
      // https://github.com/bryntum/support/issues/394
      stopScrollWhenPointerOut: false,
      testConfig: {
        scrollSpeed: 2,
        startScrollDelay: 100
      },
      activeScroll: {
        $config: ['lazy'],
        value: {}
      },
      monitoring: {
        $config: ['lazy', 'nullify'],
        value: true
      },
      owner: null
    };
  }
  changeMonitoring(value, was) {
    was === null || was === void 0 ? void 0 : was.clear();
    return new Map();
  }
  //endregion
  doDestroy() {
    this.stopMonitoring();
    super.doDestroy();
  }
  /**
   * Returns true if some of the monitored elements is being scrolled at the moment.
   * @property {Boolean}
   * @readonly
   */
  get isScrolling() {
    return Object.keys(this.activeScroll).length !== 0;
  }
  get rtl() {
    var _this$owner;
    return (_this$owner = this.owner) === null || _this$owner === void 0 ? void 0 : _this$owner.rtl;
  }
  //region Start/stop monitoring
  /**
   * Starts monitoring an element. It will be scrolled if mouse is pressed and within `zoneWidth` pixels from element
   * edge. Supports monitoring multiple elements using `scrollables` option:
   *
   * ```javascript
   * new ScrollManager({ element : '.item' }).startMonitoring({
   *     scrollables : [
   *         {
   *             // Applies config to all elements matching `.item .child-item`
   *             // selector
   *             element : '.child-item',
   *             // Only manage vertical scroll
   *             direction : 'vertical',
   *             // Specific callback for this scrollable. Shared callback is
   *             // ignored.
   *             callback : () => console.log('Specific callback')
   *         },
   *         {
   *             // Instance can be used
   *             element : document.querySelector('.item .child2')
   *             // Direction and callback are not provided, so element will
   *             // be scrollable in horizontal direction and will use shared
   *             // callback
   *         }
   *     ],
   *     direction : 'horizontal',
   *     callback  : () => console.log('Shared callback')
   * })
   * ```
   *
   * @param {Object} config Element which might be scrolled or config { element, callback, thisObj }
   * @param {'horizontal'|'vertical'|'both'} [config.direction] Direction to scroll. Overrides default scroll direction
   * @param {Function} [config.callback] Callback to execute on every scroll of the target element.
   *
   * ```javascript
   * startMonitoring({
   *     callback(monitor) {
   *         // Current left and top scroll of the monitored element
   *         console.log(monitor.scrollLeft)
   *         console.log(monitor.scrollTop)
   *         // Scroll position relative to the initial position
   *         console.log(monitor.relativeScrollLeft)
   *         console.log(monitor.relativeScrollTop)
   *     }
   * })
   * ```
   *
   * @param {Object} [config.thisObj] Scope for the callback.
   * @param {Object[]} [config.scrollables] Array of configs if multiple elements should be monitored.
   * @param {HTMLElement|String} [config.scrollables.0.element] Element or selector.
   * @param {'horizontal'|'vertical'|'both'} [config.scrollables.0.direction] Direction to scroll. Overrides upper config object direction.
   * @param {Function} [config.scrollables.0.callback] Callback to execute on every scroll of the target element.
   * Overrides upper config object callback.
   * @returns {Function} Returns function to cleanup instantiated monitors
   * ```javascript
   * const detacher = new ScrollManager({ element }).startMonitoring({ ... });
   * detacher(); // All monitors setup by the previous call are removed
   * ```
   */
  startMonitoring(config = {}) {
    const me = this,
      {
        element,
        direction: defaultDirection
      } = me,
      {
        scrollables = [],
        direction = defaultDirection,
        callback
      } = config,
      attachedElements = [];
    if (!scrollables.length) {
      scrollables.push({
        element
      });
    }
    scrollables.forEach(scrollable => {
      const target = scrollable.element;
      if (typeof target === 'string') {
        DomHelper.forEachSelector(element, target, element => {
          me.createMonitor(element, scrollable.direction || direction, scrollable.callback || callback);
          attachedElements.push(element);
        });
      } else {
        me.createMonitor(target, scrollable.direction || direction, scrollable.callback || callback);
        attachedElements.push(target);
      }
    });
    return function detacher() {
      var _me$stopMonitoring;
      // May have been destroyed when DragContext cleaner is called.
      (_me$stopMonitoring = me.stopMonitoring) === null || _me$stopMonitoring === void 0 ? void 0 : _me$stopMonitoring.call(me, attachedElements);
    };
  }
  createMonitor(element, direction, callback) {
    const {
      monitoring
    } = this;
    if (!monitoring.has(element)) {
      monitoring.set(element, new ScrollManagerMonitor({
        scrollManager: this,
        element,
        direction,
        callback
      }));
    }
  }
  /**
   * Stops monitoring an element. If no particular element is given, stop monitoring everything.
   * @param {HTMLElement|HTMLElement[]} [element] Element or array of elements for which monitoring is not desired any
   * more and should stop as soon as possible.
   */
  stopMonitoring(element) {
    const me = this,
      {
        monitoring
      } = me;
    element = ArrayHelper.asArray(element);
    if (monitoring) {
      // Stop all if no element given
      if (!element) {
        monitoring.forEach(monitor => me.stopMonitoring(monitor.element));
        return;
      }
      element.forEach(element => {
        const monitor = monitoring.get(element);
        // Ensure the scrolling CSS class is removed immediately
        element.classList.remove('b-scrolling');
        // cant stop nothing...
        if (monitor) {
          monitor.destroy();
          monitoring.delete(element);
        }
      });
    }
  }
  //endregion
  /*
   * Attempts to reserve given scrolling direction for the given monitor.
   * @param {String} direction 'horizontal' or 'vertical'
   * @param {Object} monitor
   * @returns {Boolean} Returns true in case scroll direction was reserved for given monitor. False otherwise.
   * @private
   */
  requestScroll(direction, monitor) {
    const {
      activeScroll
    } = this;
    if (direction in activeScroll && activeScroll[direction] !== monitor) {
      return false;
    } else {
      activeScroll[direction] = monitor;
      return true;
    }
  }
  /*
   * Releases all scroll directions, blocked by given monitor
   * @param {Object} monitor
   * @private
   */
  releaseScroll(monitor) {
    const {
      activeScroll = {}
    } = this;
    Object.keys(activeScroll).forEach(key => {
      if (activeScroll[key] === monitor) {
        delete activeScroll[key];
      }
    });
  }
  //#region Scroll position
  getRelativeScroll(element, direction = 'left') {
    let result = 0;
    this.monitoring.forEach((monitor, monitoredElement) => {
      if (DomHelper.isDescendant(monitoredElement, element)) {
        result += direction === 'left' ? monitor.scrollRelativeLeft : monitor.scrollRelativeTop;
      }
    });
    return result;
  }
  //#endregion
}

class ScrollManagerMonitor extends Base {
  construct(config) {
    const me = this,
      {
        element
      } = config,
      startScrollLeft = element.scrollLeft,
      startScrollTop = element.scrollTop;
    Object.assign(config, {
      startScrollLeft,
      startScrollTop
    });
    super.construct(config);
    // listen to mousemove to determine if scroll needed or not
    EventHelper.on({
      element,
      scroll: 'onElementScroll',
      pointermove: 'onMouseMove',
      // Capture pointermove events early to start scrolling from top elements
      capture: true,
      thisObj: me
    });
    // `pointerleave` should have `capture: false`, otherwise it works much like `pointerout`
    EventHelper.on({
      element,
      pointerleave: 'onPointerLeave',
      thisObj: me
    });
  }
  doDestroy() {
    this.stopScroll();
    super.doDestroy();
  }
  /**
   * Starts scrolling (see #performScroll). Called from onMouseMove.
   * @private
   */
  startScroll() {
    const me = this;
    if (me.pendingScrollFinalize) {
      me.scrollManager.releaseScroll(me);
      me.pendingScrollFinalize = false;
    }
    me.scrolling = true;
    me.performScroll();
  }
  /**
   * Stops scrolling. Called from onMouseMove.
   * @private
   */
  stopScroll(force = null) {
    const me = this,
      finalize = () => {
        me.pendingScrollFinalize = false;
        if (!me.isDestroyed) {
          me.scrollManager.releaseScroll(me);
          me.scrolling = false;
        }
      };
    if (me.scrollRequested) {
      me.scrollManager.cancelAnimationFrame(me.frameId);
      me.scrollRequested = false;
    }
    me.scrollManager.clearTimeout(me.scrollTimeout);
    me.scrollTimeout = null;
    if (!force && (me.ongoingScrollTop || me.ongoingScrollLeft)) {
      me.pendingScrollFinalize = true;
      // here's another race condition, that we might actually have started
      // another scroll while waiting for this one to complete
      Promise.all([me.ongoingScrollTop, me.ongoingScrollLeft].filter(Boolean)).then(() => me.pendingScrollFinalize && finalize());
    } else {
      me.ongoingScrollTop = me.ongoingScrollLeft = null;
      finalize();
    }
  }
  onPointerLeave() {
    this.scrollManager.stopScrollWhenPointerOut && this.stopScroll();
  }
  /**
   * Listener for mouse move on monitored element. Determines if scrolling is needed, and if so how fast to scroll.
   * See #zoneWidth & #scrollSpeed configs.
   * @private
   * @param {MouseEvent} event
   */
  onMouseMove(event) {
    const me = this,
      {
        scrollManager
      } = me,
      box = me.element.getBoundingClientRect(),
      width = scrollManager.zoneWidth,
      speed = scrollManager.scrollSpeed;
    // scroll left, right, up or down?
    me.scrollDeltaX = me.scrollDeltaY = 0;
    if (me.direction !== 'vertical') {
      const {
        scrollLeft,
        scrollWidth,
        clientWidth
      } = me.element;
      if (scrollManager.rtl) {
        if (event.clientX < box.left + width && scrollWidth + scrollLeft - clientWidth >= 1) {
          me.scrollDeltaX = -Math.round((width + (box.left - event.clientX)) / speed) - 1;
        } else if (event.clientX > box.right - width && scrollLeft < 0) {
          me.scrollDeltaX = Math.round((width - (box.right - event.clientX)) / speed) + 1;
        }
      } else {
        // Only start scrolling if it is possible
        if (event.clientX > box.right - width && scrollWidth - scrollLeft - clientWidth >= 1) {
          me.scrollDeltaX = Math.round((width - (box.right - event.clientX)) / speed) + 1;
        } else if (event.clientX < box.left + width && scrollLeft > 0) {
          me.scrollDeltaX = -Math.round((width + (box.left - event.clientX)) / speed) - 1;
        }
      }
    }
    if (me.direction !== 'horizontal') {
      const {
        scrollTop,
        scrollHeight,
        clientHeight
      } = me.element;
      // Only start scrolling if it is possible
      if (event.clientY > box.bottom - width && scrollHeight - scrollTop - clientHeight >= 1) {
        me.scrollDeltaY = Math.round((width - (box.bottom - event.clientY)) / speed) + 1;
      } else if (event.clientY < box.top + width && scrollTop > 0) {
        me.scrollDeltaY = -Math.round((width + (box.top - event.clientY)) / speed) - 1;
      }
    }
    if (me.scrollDeltaX !== 0 && !scrollManager.requestScroll('horizontal', me)) {
      me.scrollDeltaX = 0;
    }
    if (me.scrollDeltaY !== 0 && !scrollManager.requestScroll('vertical', me)) {
      me.scrollDeltaY = 0;
    }
    if (me.scrollDeltaX === 0 && me.scrollDeltaY === 0) {
      me.scrolling && me.stopScroll();
    } else if (!me.scrollTimeout) {
      me.scrollTimeout = scrollManager.setTimeout(() => me.startScroll(), scrollManager.startScrollDelay);
    }
  }
  /**
   * Scrolls by an amount determined by config.scrollDeltaX/Y on each frame. Start/stop by calling #startScroll and
   * #stopScroll.
   * @private
   */
  performScroll() {
    const me = this,
      {
        element
      } = me;
    // this function is called repeatedly on each frame for as long as scrolling is needed
    // check that scrolling is needed
    if (me.scrolling && !me.scrollRequested) {
      // Scroll the determined amount of pixels if possible
      if (me.scrollDeltaX !== 0) {
        const oldScrollLeft = element.scrollLeft,
          newScrollLeft = Math.min(oldScrollLeft + me.scrollDeltaX, element.scrollWidth - element.clientWidth);
        element.scrollLeft = newScrollLeft;
        if (element.scrollLeft !== oldScrollLeft) {
          me.ongoingScrollLeft = new Promise(resolve => element.addEventListener('scroll', resolve, {
            once: true
          }));
        } else {
          me.ongoingScrollLeft = null;
          me.scrollDeltaX = 0;
        }
      }
      if (me.scrollDeltaY !== 0) {
        const oldScrollTop = element.scrollTop,
          newScrollTop = Math.min(oldScrollTop + me.scrollDeltaY, element.scrollHeight - element.clientHeight);
        element.scrollTop = newScrollTop;
        // after we've assigned a new value to the `scrollTop` property element
        // we need to check if the properties value has actually changed
        if (element.scrollTop !== oldScrollTop) {
          // if it does - scrolling will happen "soon" (we don't know precisely yet when, need to listen to event)
          me.ongoingScrollTop = new Promise(resolve => element.addEventListener('scroll', resolve, {
            once: true
          }));
        } else {
          // if it does not - then scrolling won't happen at all
          me.ongoingScrollTop = null;
          me.scrollDeltaY = 0;
        }
      }
      if (me.scrollDeltaX !== 0 || me.scrollDeltaY !== 0) {
        // scroll some more on next frame
        me.scrollRequested = true;
        me.frameId = me.scrollManager.requestAnimationFrame(() => {
          me.scrollRequested = false;
          me.performScroll(me);
        });
      } else {
        me.stopScroll();
      }
    }
  }
  onElementScroll() {
    var _this$config, _this$config$callback;
    (_this$config = this.config) === null || _this$config === void 0 ? void 0 : (_this$config$callback = _this$config.callback) === null || _this$config$callback === void 0 ? void 0 : _this$config$callback.call(this.thisObj || this.scrollManager, this);
  }
  get scrollLeft() {
    return this.element.scrollLeft;
  }
  get scrollTop() {
    return this.verticalElement ? this.verticalElement.scrollTop : this.element.scrollTop;
  }
  get scrollRelativeLeft() {
    return this.scrollLeft - this.startScrollLeft;
  }
  get scrollRelativeTop() {
    return this.scrollTop - this.startScrollTop;
  }
  // There could be several scrollables controlling different axes. If we want to calculate combined scroll from all
  // those monitors (e.g. for the case when we drag scheduler event in both directions), we should ask scroll manager
  // to iterate over monitored elements and aggregate scroll.
  getRelativeLeftScroll(element) {
    return this.scrollManager.getRelativeScroll(element, 'left');
  }
  getRelativeTopScroll(element) {
    return this.scrollManager.getRelativeScroll(element, 'top');
  }
}
ScrollManager._$name = 'ScrollManager';

const realignTransitions = {
    left: true,
    right: true,
    top: true,
    bottom: true,
    transform: true
  },
  isBoolean = {
    true: 1,
    false: 1
  },
  immediatePromise = Promise.resolve();
/**
 * @module Core/widget/Tooltip
 */
/**
 * Tooltip. Easiest way of assigning a tooltip to a widget is by setting {@link Core.widget.Widget#config-tooltip}, see example below.
 *
 * ```javascript
 * new Button {
 *     text    : 'Hover me',
 *     tooltip : 'Click me and you won\'t believe what happens next'
 * });
 * ```
 *
 * By default, tooltips of widgets use a singleton Tooltip instance which may be accessed from the
 * `{@link Core.widget.Widget}` class under the name `Widget.tooltip`.
 * This is configured according to the config object on pointer over.
 *
 * To request a separate instance be created just for this widget, add `newInstance : true`
 * to the configuration:
 *
 * ```javascript
 * new Button {
 *     text    : 'Hover me',
 *     tooltip : {
 *         html        : 'Click me and you won\'t believe what happens next',
 *         newInstance : true
 *     }
 * });
 * ```
 *
 * You can ask for the singleton instance to display configured tips for your own DOM structure using
 * `data-btip` element attributes:
 *
 * ```html
 * <button class="my-button" data-btip="Contextual help for my button" data-btip-scroll-action="realign">Hover me</button>
 * ```
 *
 * ## Showing async content
 * To load remote content into a simple tooltip, just load your data in the `beforeShow` listener (but ensure that the {@link #property-activeTarget} is the same when the data arrives)
 *
 * ```javascript
 * new Tooltip({
 *     listeners : {
 *         beforeShow : ({ source : tip }) => tip.html = AjaxHelper.get('someurl').then(response => response.text());
 *     }
 * });
 * ```
 *
 * If you have multiple targets that should show a tooltip when hovered over, look at {@link #config-forSelector} and {@link #config-getHtml}.
 *
 * ```javascript
 * new Tooltip({
 *     forSelector : '.myCssClass',
 *     getHtml     : ({ source : tip }) => AjaxHelper.fetch('data').then(response => response.text())
 * });
 * ```
 *
 * @extends Core/widget/Popup
 * @classType tooltip
 * @inlineexample Core/widget/Tooltip.js
 */
class Tooltip extends Popup {
  //region Default config
  static get $name() {
    return 'Tooltip';
  }
  // Factoryable type name
  static get type() {
    return 'tooltip';
  }
  /**
   * Triggered before tooltip widget is shown. Return `false` to prevent the action.
   * @preventable
   * @event beforeShow
   * @param {Core.widget.Tooltip} source The Tooltip
   * @param {Event} source.triggeredByEvent The event that triggered this Tooltip to show.
   */
  static get configurable() {
    return {
      /**
       * Horizontal offset from mouse when {@link #config-anchorToTarget} is `false`.
       *
       * Direction independent, the value is internally flipped (by multiplying it with -1) for RTL.
       *
       * @config {Number}
       * @default
       */
      mouseOffsetX: 15,
      /**
       * Vertical offset from mouse when {@link #config-anchorToTarget} is `false`
       * @config {Number}
       * @default
       */
      mouseOffsetY: 15,
      html: {
        // Ensure the html setter can never veto the operation as a no-change.
        // Because of beforeShow listeners augmenting the content.
        $config: {
          equals: () => false
        }
      },
      /**
       * A method, or the *name* of a method called to update the tooltip's content when the
       * cursor is moved over a target. It receives one argument containing context about the
       * tooltip and show operation. The function should return a string, or a Promise yielding
       * a string.
       *
       * ```javascript
       * new Grid({
       *     title    : 'Client list',
       *     appendTo : myElement,
       *     store    : myStore,
       *     columns  : myColumns,
       *     tbar     : {
       *         items : {
       *             text : 'Reload,
       *             tooltip : {
       *                 // Will look in ownership hierarchy for the method
       *                 // which will be found on the grid.
       *                 getHtml : 'up.getReloadButtonTip'
       *             }
       *         }
       *     },
       *     getReloadButtonTip() {
       *         return `Reload ${this.title}`;
       *     }
       * });
       * ```
       * @param {Object} context
       * @param {Core.widget.Tooltip} context.tip The tooltip instance
       * @param {HTMLElement} context.element The Element for which the Tooltip is monitoring mouse movement
       * @param {HTMLElement} context.activeTarget The target element that triggered the show
       * @param {Event} context.event The raw DOM event
       * @returns {String|Promise}
       * @config {Function|String}
       */
      getHtml: null,
      /**
       * DOM element to attach tooltip to. By default, the mouse entering this element will kick off a timer
       * (see {@link #config-hoverDelay}) to show itself.
       *
       * If the {@link #config-forSelector} is specified, then mouse entering matching elements within the `forElement`
       * will trigger the show timer to start.
       *
       * Note that when moving from matching element to matching element within the `forElement`, the tooltip
       * will remain visible for {@link #config-hideDelay} milliseconds after exiting one element, so that rapidly
       * entering another matching element will not cause hide+show flicker. To prevent this behaviour configure
       * with `hideDelay: 0`.
       * @config {HTMLElement}
       */
      forElement: null,
      /**
       * By default, once a tooltip is shown aligned as requested, it stays put.
       *
       * Setting this to `true` causes the tooltip to be aligned by the mouse,
       * offset by `[{@link #config-mouseOffsetX}, {@link #config-mouseOffsetY}]` and
       * keeps the tooltip aligned to the mouse maintaining the configured offsets
       * as the mouse moves within its activating element.
       * @config {Boolean}
       * @default false
       */
      trackMouse: null,
      /**
       * By default, a tooltip displays static content. In the Scheduler however, there are
       * plenty of uses cases when the tip content is based on the current mouse position (dragging events, resizing events, schedule hover tip, drag creation of events etc). Set
       * to `true` to update contents on mouse movement.
       * @config {Boolean}
       * @private
       */
      updateContentOnMouseMove: false,
      /**
       * A CSS selector which targets child elements of the {@link #config-forElement} that should produce a
       * tooltip when hovered over.
       * @config {String}
       */
      forSelector: null,
      /**
       * By default, when moving rapidly from target to target, if, when mouseovering
       * a new target, the tip is still visible, the tooltip does not hide, it remains
       * visible, but updates its content however it is configured to do so.
       *
       * Configure `hideOnDelegateChange : true` to have the tip hide, and then trigger
       * a new show delay upon entry of a new target while still visible.
       * @config {Boolean}
       * @default false
       */
      hideOnDelegateChange: null,
      /**
       * Set to true to anchor tooltip to the triggering target. If set to `false`, the tooltip
       * will align to the mouse position. When set to `false`, it will also set `anchor: false`
       * to hide anchor arrow.
       * @config {Boolean}
       * @default true
       */
      anchorToTarget: true,
      /**
       * Show on hover
       * @config {Boolean}
       * @default
       */
      showOnHover: false,
      /**
       * The amount of time to hover before showing
       * @config {Number}
       * @default
       */
      hoverDelay: 500,
      /**
       * Show immediately when created
       * @config {Boolean}
       * @default
       */
      autoShow: false,
      /**
       * The time (in milliseconds) that the Tooltip should stay visible for when it shows over its
       * target. If the tooltip is anchored to its target, then moving the mouse during this time
       * resets the timer so that the tooltip will remain visible.
       *
       * Defaults to `0` which means the Tooltip will persist until the mouse leaves the target.
       * @config {Number}
       * @default
       */
      dismissDelay: 0,
      /**
       * The time (in milliseconds) for which the Tooltip remains visible when the mouse leaves the target.
       *
       * May be configured as `false` to persist visible after the mouse exits the target element. Configure it
       * as 0 to always retrigger `hoverDelay` even when moving mouse inside `fromElement`
       * @config {Number}
       * @default
       */
      hideDelay: 500,
      /**
       * The message to show while an async tooltip is fetching its content.
       * @config {String}
       * @default
       */
      loadingMsg: 'Loading...',
      /**
       * Keep the tooltip open if user moves the mouse it.
       *
       * If this is *not* explicitly configured as `false`, then this is automatically set
       * when there are any visible, interactive child items added such as {@link #config-tools}, or
       * {@link #config-items} which are interactive such as buttons or input fields.
       * @config {Boolean}
       * @default false
       */
      allowOver: null,
      anchor: true,
      align: {
        align: 'b-t',
        // This signals to the align code that this widget is prepared to shrink
        // in height in order to comply with alignTo specifications.
        // Without a minHeight, it is assumed that the height of the widget
        // is inviolable.
        minHeight: 300
      },
      axisLock: true,
      /**
       * The HTML element that triggered this Tooltip to show
       * @readonly
       * @member {HTMLElement} activeTarget
       */
      activeTarget: null,
      testConfig: {
        hideDelay: 100,
        hoverDelay: 100,
        showAnimation: null,
        hideAnimation: null
      }
    };
  }
  //endregion
  //region Events
  /**
   * Triggered when a mouseover event is detected on a potential target element.
   * Return false to prevent the action
   * @event pointerOver
   * @param {Core.widget.Tooltip} sourceThe tooltip instance.
   * @param {Event} event The mouseover event.
   */
  //endregion
  //region Properties
  //endregion
  //region Init & destroy
  afterConfigure() {
    const me = this,
      {
        forSelector
      } = me;
    if (forSelector) {
      me.showOnHover = true;
      if (!me.forElement) {
        if (!me.anchorToTarget) {
          me.trackMouse = true;
        }
        me.forElement = me.rootElement.host || me.rootElement;
      }
    }
    super.afterConfigure();
    // There's a triggering element, and we're showing on hover, add the mouse listeners
    if (me.forElement && me.showOnHover) {
      me.pointerOverOutDetacher = EventHelper.on({
        element: me.forElement,
        // Using pointerover/pointerout since mouseover events are not fired in Chrome when the native `disabled`
        // attribute is present https://github.com/bryntum/support/issues/3179
        pointerover: 'internalOnPointerOver',
        pointerout: 'internalOnPointerOut',
        thisObj: me
      });
    }
  }
  doDestroy() {
    var _this$pointerOverOutD;
    (_this$pointerOverOutD = this.pointerOverOutDetacher) === null || _this$pointerOverOutD === void 0 ? void 0 : _this$pointerOverOutD.call(this);
    super.doDestroy();
  }
  set focusOnToFront(focusOnToFront) {
    super.focusOnToFront = focusOnToFront;
  }
  get focusOnToFront() {
    // Transient things like tooltips should not focus when invoked by pointer events
    return super.focusOnToFront && DomHelper.usingKeyboard;
  }
  get focusElement() {
    const result = super.focusElement;
    if (result !== this.element) {
      return result;
    }
  }
  get anchorToTarget() {
    // We do not anchor to the target if we are tracking the mouse
    return this._anchorToTarget && !this.trackMouse;
  }
  get anchor() {
    // We do not anchor to the target if we are tracking the mouse
    return super.anchor && !this.trackMouse;
  }
  set anchor(anchor) {
    super.anchor = anchor;
  }
  //endregion
  //region Hovering, show and hide
  onDocumentMouseDown({
    event
  }) {
    const me = this,
      {
        triggeredByEvent
      } = me;
    // If it's a tap that is caused by the touch that was converted into a mouseover we should not hide.
    // That is if it's a touch and at the same place and within 500ms
    if (triggeredByEvent && DomHelper.isTouchEvent) {
      if (event.pageX === triggeredByEvent.pageX && event.pageY === triggeredByEvent.pageY && me.activeTarget.contains(event.target) && performance.now() - triggeredByEvent.timeStamp < 500) {
        return;
      }
    }
    me.abortDelayedShow();
    super.onDocumentMouseDown({
      event
    });
  }
  internalOnPointerOver(event) {
    const me = this,
      {
        target,
        relatedTarget
      } = event,
      {
        forElement,
        forSelector,
        activeTarget
      } = me;
    let newTarget;
    // Respect our owner's wish to not show when it's disabled
    if (me.disabled || me.owner && !me.owner.showTooltipWhenDisabled && me.owner.disabled) {
      return;
    }
    // If the mouse moves over this tooltip, it is theoretically a mouseout of its
    // forElement, but allowOver lets us tolerate this ane remain visible.
    if (me.allowOver && me.element.contains(target)) {
      return;
    }
    // There's been a mouseover. If we have a forSelector, we have to check
    // if it's an enter of a matching child
    if (forSelector) {
      newTarget = me.filterTarget(target);
      // Bail out if moving inside a forSelector matching element, unless nested element matching the selector
      if (activeTarget !== null && activeTarget !== void 0 && activeTarget.contains(target) && activeTarget.contains(relatedTarget) && newTarget === activeTarget) {
        return;
      }
      // Mouseovers while within a target do nothing
      if (newTarget && (relatedTarget === null || relatedTarget === void 0 ? void 0 : relatedTarget.closest(forSelector)) === newTarget) {
        return;
      }
    }
    // There's no forSelector, so check if we moved from outside the target
    else if (!forElement.contains(relatedTarget)) {
      newTarget = forElement;
    }
    // Mouseover caused by moving from child to child inside the target
    else {
      return;
    }
    // If pointer entered the target or a forSelector child, then show.
    if (newTarget) {
      me.handleForElementOver(event, newTarget);
    }
    // If over a non-forSelector child, behave as in forElement out
    else if (activeTarget) {
      me.handleForElementOut();
    }
  }
  filterTarget(element) {
    return element.closest(this.forSelector);
  }
  // Handle a transitioned reposition when the activeTarget moved beneath the pointer.
  // When it comes to an end, if the mouseout has not hidden, then realign at the new position
  // if the activeTarget is still beneath the pointer.
  onTransitionEnd(event) {
    const me = this,
      {
        currentOverElement
      } = Tooltip;
    if (realignTransitions[event.propertyName]) {
      var _me$activeTarget;
      // Don't realign if the mouse is over this, and is allowed to be over this
      // If user is interacting with this Tooltip, they won't expect it to move.
      if (me.allowOver && me.element.contains(currentOverElement)) {
        return;
      }
      // If we are still visible, and mouse is still over the activeTarget, realign
      if ((_me$activeTarget = me.activeTarget) !== null && _me$activeTarget !== void 0 && _me$activeTarget.contains(currentOverElement) && !me.trackMouse) {
        me.realign();
      }
    }
  }
  async handleForElementOver(event, newTarget) {
    const me = this,
      {
        activeTarget,
        hideOnDelegateChange,
        anchorToTarget
      } = me,
      isNewTarget = newTarget !== activeTarget,
      needsHide = isNewTarget && hideOnDelegateChange;
    // Vetoed, then behave as if a targetout
    if (me.trigger('pointerOver', {
      event,
      target: newTarget
    }) === false) {
      me.internalOnPointerOut(event);
    } else {
      me.triggeredByEvent = event;
      // Not actually hidden yet - mouse moved back over a target before the timer hid us.
      if (me.hasTimeout('hide')) {
        me.abortDelayedHide();
        // It's back into the same target so basically nothing has happened.
        if (!isNewTarget) {
          return;
        }
      }
      // Abort any in-flight animated hide.
      // This is needed when entering a new delegate immeditely from a previous delegate
      // or when allowOver is false (which is the default), and mouseovering
      // hides, but that immediately causes the mouse to be over another delegate.
      // We need to abort the animation.
      // This brings us back into full visibility.
      if (!hideOnDelegateChange && me.element.classList.contains('b-hiding')) {
        me.cancelHideShowAnimation();
      }
      // If we have changed targets and we have to hide on delegate change.
      if (!me._hidden && needsHide) {
        me.hide(false);
      }
      me.activeTarget = newTarget;
      // We are visible. This could be if we made an immediate delegate change and the
      // hide timer has not yet fired and we don't have hide on delegate change, or
      // the target has not in fact changed.
      // In this case, we need to ensure the content is corrected before beforeShow
      // is triggered which is how user code augments content
      if (me.isVisible) {
        const result = me.updateContent();
        // Edge case, we have no loadingMsg meaning we're not visible until content has arrived
        if (Objects.isPromise(result) && !me.loadingMsg) {
          await result;
        }
        // Allow user code to augment in a beforeShow listener even if we have not actually hidden.
        if (me.trigger('beforeShow') === false) {
          return me.hide();
        }
        me.alignTo({
          [anchorToTarget ? 'target' : 'position']: anchorToTarget ? newTarget : 'mouse',
          overlap: !(anchorToTarget && me.anchor)
        });
        me.trigger('show');
        me.afterShowByTarget();
      }
      // We are not visible. Either we have never been shown, or the hide timeout
      // fired, and hid us, or we aborted a hideAnimation and cleaned up to the final state,
      // or we had to hide on delegate change.
      else {
        me.delayShow(newTarget);
      }
    }
  }
  async delayShow(target) {
    var _me$currentAnimation;
    const me = this;
    // Caught in a show animation - cancel it,
    // If we're fading away, that's fine.
    if ((_me$currentAnimation = me.currentAnimation) !== null && _me$currentAnimation !== void 0 && _me$currentAnimation.showing) {
      me.cancelHideShowAnimation();
    }
    if (!me.isVisible && !me.hasTimeout('show')) {
      // Allow hoverDelay:0 or rapid movement from delegate to delegate to show immediately
      if (!me.hoverDelay || me.forSelector && Date.now() - me.lastHidden < me.quickShowInterval) {
        const result = me.updateContent();
        // Edge case, we have no loadingMsg meaning we're not visible until content has arrived
        if (Objects.isPromise(result) && !me.loadingMsg) {
          await result;
        }
        me.showByTarget(target);
      } else {
        // If a mouse down happens during the delay period, we cancel the show
        me.addDocumentMouseDownListener();
        // If we're not going to anchor to the hovered element, then we need to keep track
        // of mousemoves until the show happens so we can show where the mouse currently is.
        if (!me.listeningForMouseMove && !me.anchorToTarget) {
          me.mouseMoveRemover = EventHelper.on({
            element: me.rootElement,
            mousemove: 'onMouseMove',
            thisObj: me
          });
        }
        // If a tap event triggered, do not wait. Show immediately.
        me.setTimeout(async () => {
          if (target.isConnected) {
            const result = me.updateContent();
            // Edge case, we have no loadingMsg meaning we're not visible until content has arrived
            if (Objects.isPromise(result) && !me.loadingMsg) {
              await result;
            }
            me.showByTarget(target);
          }
        }, !me.triggeredByEvent || me.triggeredByEvent.type === 'pointerover' ? me.hoverDelay : 0, 'show');
      }
    } else if (me.isVisible) {
      me.showByTarget(target);
    }
  }
  changeAllowOver(allowOver) {
    // Only cache it when configured from outside, not when temporarily set upon show.
    if (!this.inAfterShow) {
      this.configuredAllowOver = allowOver;
    }
    return allowOver;
  }
  updateAllowOver(allowOver) {
    const me = this,
      {
        element
      } = me;
    element.classList.toggle('b-allow-over', Boolean(allowOver));
    if (allowOver) {
      me.allowOverlisteners = EventHelper.on({
        element,
        mouseenter: 'onOwnElementMouseEnter',
        mouseleave: 'internalOnPointerOut',
        thisObj: me
      });
    } else {
      var _me$allowOverlistener;
      (_me$allowOverlistener = me.allowOverlisteners) === null || _me$allowOverlistener === void 0 ? void 0 : _me$allowOverlistener.call(me);
    }
  }
  updateContent() {
    const me = this;
    if (me.getHtml) {
      const result = me.callback(me.getHtml, me, [{
        tip: me,
        element: me.element,
        activeTarget: me.activeTarget,
        event: me.triggeredByEvent
      }]);
      me.html = result;
      return result;
    }
  }
  // There are 3 possible scenarios:
  // - Static content
  // - Remote content being loaded (meaning we (possibly) set a loading message as the `html`
  // - Tooltip acts as a Container
  get hasContent() {
    return Boolean(DomHelper.isReactElement(this._html) || this._html !== '' && typeof this.html === 'string' && this.html.length || this.items.length);
  }
  internalBeforeShow() {
    // In case we update content on mouse move, need to show empty tooltip first
    return (this.updateContentOnMouseMove || this.hasContent) && !this.disabled;
  }
  /**
   * Shows a spinner and a message to indicate an async flow is ongoing
   * @param {String} message The message, defaults to {@link #config-loadingMsg}
   */
  showAsyncMessage(message = this.optionalL(this.loadingMsg)) {
    if (message) {
      this.html = `
                <div class="b-tooltip-loading">
                    <i class="b-icon b-icon-spinner"></i>
                    ${message}
                </div>
            `;
    }
  }
  showByTarget(target) {
    var _me$mouseMoveRemover;
    const me = this,
      {
        anchorToTarget
      } = me;
    me.mouseMoveRemover = (_me$mouseMoveRemover = me.mouseMoveRemover) === null || _me$mouseMoveRemover === void 0 ? void 0 : _me$mouseMoveRemover.call(me);
    // Show by the correct thing.
    // If we are not anchored to the target, then it's the current pointer event, handled in beforeAlignTo() above.
    // Otherwise it's the activeTarget.
    me.showBy({
      [anchorToTarget ? 'target' : 'position']: anchorToTarget ? target : 'mouse',
      overlap: !(anchorToTarget && me.anchor)
    });
  }
  afterShowByTarget() {
    const me = this,
      {
        dismissDelay
      } = me;
    me.abortDelayedShow();
    if (dismissDelay) {
      me.setTimeout('hide', dismissDelay);
    }
    // Bring the element to front if it's not detached
    if (me.element.parentNode) {
      me.toFront();
    }
    // If we've shown, and are tracking the mouse and not anchored to (aligned to) the target, track the mouse
    if (!me.mouseMoveRemover && (me.trackMouse || me.updateContentOnMouseMove)) {
      me.mouseMoveRemover = EventHelper.on({
        element: me.rootElement,
        pointermove: 'onMouseMove',
        thisObj: me
      });
    }
    // Set allowOver to true if there are things that the user is able to interact with.
    // Unless it is explicitly configured as false
    me.inAfterShow = true;
    me.allowOver = me.allowOver || me.configuredAllowOver != false && me.childItems.some(w => w.isVisible && !w.disabled && w.focusElement);
    me.inAfterShow = false;
  }
  updateActiveTarget(newTarget, lastTarget) {
    if (newTarget && !this.isConfiguring) {
      this.trigger('overTarget', {
        newTarget,
        lastTarget
      });
    }
  }
  internalOnPointerOut(event) {
    var _me$activeTarget2;
    const me = this,
      toElement = event.relatedTarget;
    // Edge case: If there is no space to fit the tooltip, and as a result of showing the tooltip - the mouse is over the tooltip
    // Make sure we don't end up in an infinite hide/show loop
    if (me.allowOver && me.element.contains(toElement)) {
      return;
    }
    // If we were in an allowOver situation and exited
    // into the activeTarget, do nothing; in this situation
    // the tip is treated as if it were part of the target.
    if (me.element.contains(event.target) && (_me$activeTarget2 = me.activeTarget) !== null && _me$activeTarget2 !== void 0 && _me$activeTarget2.contains(toElement)) {
      return;
    }
    // We have exited the active target
    if (me.activeTarget && !me.activeTarget.contains(toElement)) {
      me.handleForElementOut();
    }
  }
  handleForElementOut() {
    // Separated from onTargetOut so that subclasses can handle target out in any way.
    const me = this,
      {
        hideDelay
      } = me;
    // Allow outside world to veto the hide
    if (me.trigger('pointerOut') === false) {
      me.activeTarget = null;
      return;
    }
    me.abortDelayedShow();
    // Even if there is a hide timer, it's a *dismiss* timer which hides the tip
    // after a hover time. We begin a new delay on target out.
    if (me.isVisible && hideDelay !== false) {
      me.abortDelayedHide();
      if (hideDelay > 0) {
        me.setTimeout('hide', hideDelay);
      } else {
        // Hide immediately when configured with `hideDelay: 0`. Used by async cell tooltips that always should
        // retrigger `hoverDelay`, to not spam the backend
        me.hide();
      }
    }
  }
  show(spec) {
    const me = this;
    // If we know what element to show it by, and we are anchoring to it
    // and there's no ambiguity with a selector for sub elements,
    // then show it by our forElement (Unless we're being called from showBy)
    if (!spec && me.forElement && me.anchorToTarget && !me.forSelector) {
      me.showByTarget(me.forElement);
    }
    // All we can do is the basic Widget show.
    else {
      super.show(...arguments);
    }
    // Show may be been vetoed
    if (me.isVisible) {
      me.afterShowByTarget();
      if (me.forElement && !me.transitionEndDetacher && !me._hidden) {
        me.transitionEndDetacher = EventHelper.on({
          element: me.forElement,
          transitionend: 'onTransitionEnd',
          thisObj: me
        });
      }
    }
  }
  hide() {
    const me = this;
    // If we are asked to hide, we must always abort any impending show.
    me.abortDelayedShow();
    // But if we are not hidden, go ahead and hide
    if (!me._hidden) {
      var _me$mouseMoveRemover2, _me$transitionEndDeta;
      me.abortDelayedHide();
      const result = super.hide(...arguments);
      me.lastHidden = Date.now();
      me.activeTarget = null;
      (_me$mouseMoveRemover2 = me.mouseMoveRemover) === null || _me$mouseMoveRemover2 === void 0 ? void 0 : _me$mouseMoveRemover2.call(me);
      me.mouseMoveRemover = null;
      (_me$transitionEndDeta = me.transitionEndDetacher) === null || _me$transitionEndDeta === void 0 ? void 0 : _me$transitionEndDeta.call(me);
      me.transitionEndDetacher = null;
      return result;
    } else {
      return immediatePromise;
    }
  }
  abortDelayedShow() {
    const me = this;
    if (me.hasTimeout('show')) {
      var _me$mouseDownRemover, _me$mouseMoveRemover3, _me$transitionEndDeta2;
      // This listener is added in delayShow to make a mousedown abort,
      // So we must remove it here because it's only removed in onHide.
      (_me$mouseDownRemover = me.mouseDownRemover) === null || _me$mouseDownRemover === void 0 ? void 0 : _me$mouseDownRemover.call(me);
      me.mouseDownRemover = null;
      me.clearTimeout('show');
      (_me$mouseMoveRemover3 = me.mouseMoveRemover) === null || _me$mouseMoveRemover3 === void 0 ? void 0 : _me$mouseMoveRemover3.call(me);
      me.mouseMoveRemover = null;
      (_me$transitionEndDeta2 = me.transitionEndDetacher) === null || _me$transitionEndDeta2 === void 0 ? void 0 : _me$transitionEndDeta2.call(me);
      me.transitionEndDetacher = null;
    }
  }
  /**
   * Stops both timers which may hide this tooltip, the one which counts down from mouseout
   * and the one which counts down from mouseover show for dismissDelay ms
   * @private
   */
  abortDelayedHide() {
    this.clearTimeout('hide');
  }
  realign() {
    const me = this,
      spec = me.lastAlignSpec;
    // If we are hidden because our align target scrolled, or otherwise
    // moved out of its clipping boundaries, then check if it's moved back in.
    // For example EventDrag might move the element outside of the scheduler
    // SubGrid, which will cause the tip to hide, but then moving it back in
    // must reshow it.
    if (!me.isConfiguring && !me.isVisible && spec !== null && spec !== void 0 && spec.targetOutOfView) {
      // If there is an intersecting Rectangle with the forElement, align
      if (spec.allowTargetOut || DomHelper.isInView(spec.target, false, me)) {
        me.show();
        spec.targetOutOfView = false;
      }
    }
    super.realign();
  }
  alignTo(spec) {
    const me = this,
      {
        mouseOffsetX,
        mouseOffsetY
      } = me;
    if (!me.isVisible) {
      return;
    }
    let mousePosition;
    if (!me.anchorToTarget && spec.position === 'mouse') {
      mousePosition = new Point(me.triggeredByEvent.pageX - globalThis.scrollX, me.triggeredByEvent.pageY - globalThis.scrollY);
      spec.position = new Point(mousePosition.x + me.mouseOffsetX * (me.rtl ? -1 : 1), mousePosition.y + me.mouseOffsetY);
    }
    // If mouse pointer is over this, do not attempt
    // to call the getHtml method.
    if (spec && !(me.triggeredByEvent && me.element.contains(me.triggeredByEvent.target))) {
      if (spec.nodeType === Node.ELEMENT_NODE) {
        spec = {
          target: spec
        };
      }
    }
    super.alignTo(spec);
    // If the mouse comes within 5 pixels of our result position, flip the mouseOffsets to the opposite sides
    if (mousePosition && me.lastAlignSpec.result.inflate(5).contains(mousePosition)) {
      me.lastAlignSpec.position = 'mouse';
      me.mouseOffsetY = -mouseOffsetY - me.height;
      me.mouseOffsetX = -mouseOffsetX - me.width;
      me.realign();
      me.mouseOffsetY = mouseOffsetY;
      me.mouseOffsetX = mouseOffsetX;
    }
  }
  //endregion
  //region Tooltip contents
  /**
   * Get/set the HTML to display. When specifying HTML, this widget's element will also have `b-html` added to its
   * classList, to allow targeted styling. To create async tooltip and show the {@link #config-loadingMsg}, see code below:
   * For example:
   *
   * ```javascript
   * new Tooltip({
   *     listeners : {
   *         beforeShow : ({ source : tip }) => {
   *             tip.showAsyncMessage();
   *             AjaxHelper.get('someurl').then(response => tip.html = 'Done!');
   *         }
   *     }
   * });
   * ```
   *
   * @member {String} html
   * @category DOM
   */
  changeHtml(htmlOrPromise) {
    const me = this;
    if (Objects.isPromise(htmlOrPromise)) {
      me.showAsyncMessage();
      htmlOrPromise.target = me.activeTarget;
      htmlOrPromise.then(html => {
        // Cursor might have exited the element while loading
        if (htmlOrPromise.target === me.activeTarget) {
          me.html = html;
        }
      });
      return;
    }
    // Allow objects to pass through, to be used with DomSync
    if (typeof htmlOrPromise !== 'object') {
      // Stringify in case a number was passed in
      htmlOrPromise = htmlOrPromise != null ? me.optionalL(String(htmlOrPromise)) : '';
    }
    return htmlOrPromise;
  }
  updateHtml(value, was) {
    const me = this;
    let empty = value === '';
    // As setting empty string as content should hide the tooltip, we don't want to actually update the
    // element innerHTML with blank space during the hide transition, we check _html for emptiness in hasContent
    if (!empty) {
      super.updateHtml(value, was);
      if (me.hasContent) {
        if (me.isVisible) {
          me.realign();
        }
        if (!Objects.isPromise(value)) {
          me.trigger('innerHtmlUpdate', {
            value
          });
        }
      } else {
        empty = true;
      }
    }
    if (empty) {
      // Hide empty tooltips
      me.hide();
    }
  }
  //endregion
  //region Events
  /**
   * Mouse move event listener which updates tooltip
   * @private
   */
  onMouseMove(event) {
    const me = this,
      {
        forElement,
        activeTarget
      } = me,
      // If we are trackMouse: true
      // we must keep out of the way of the mouse by continuing
      // to track if we are on the way out due to a hide timer.
      isHiding = me.hasTimeout('hide'),
      target = event.target;
    // MouseMove is listened for during the hover show timer wait phase if anchorToTarget is false
    // so that when the timer fires, it can show near the most recent pointer position.
    // It's also listened for after show when we are not anchored to the target and so tracking the mouse.
    /**
     * The DOM event that triggered this tooltip to show
     * @member {Event} triggeredByEvent
     * @readonly
     */
    me.triggeredByEvent = event;
    // Check that we are still valid to be visible, and if so, track the mouse.
    if (!me._hidden) {
      let hideVetoed;
      const
        // It's a move within our target
        isWithinTarget = activeTarget === null || activeTarget === void 0 ? void 0 : activeTarget.contains(target),
        // Work out whether we have just exited our target.
        // If we are still *inside* the target, do not test the selector.
        isElementOut = !isWithinTarget && me.forSelector && activeTarget && !isHiding && target.nodeType === Node.ELEMENT_NODE && !target.matches(me.forSelector) && !(me.allowOver && me.element.contains(target)),
        // We need an element we can ask the "contains" question about our target.
        // If we are using window, we need to step down to the documentElement.
        containingElement = forElement !== null && forElement !== void 0 && forElement.document ? forElement.document.documentElement : forElement,
        // If the forElement is a ShadowRoot, it won't implement contains
        // but it does implement compareDocumentPosition.
        forElementContainsTarget = containingElement && (containingElement.contains ? containingElement.contains(target) : containingElement.compareDocumentPosition(target) & 16);
      // Check whether the element we are over is still a valid delegate matching the forSelector,
      // or it's the tip element, and we're allowOver. If not, we have to hide.
      // nodeType check is for FF on Linux, event.target is sometimes a text node
      if (isElementOut) {
        hideVetoed = me.handleForElementOut();
      }
      // If we are not hiding due to moving mouse outside our forElement (or hide being vetoed), tooltip stays visible and optionally realigns based on trackMouse setting.
      if (hideVetoed || !isHiding || forElementContainsTarget) {
        // Mousemoves restart the dismiss timer.
        if (me.dismissDelay && !isHiding) {
          me.setTimeout('hide', me.dismissDelay);
        }
        if (me.updateContentOnMouseMove && me.getHtml) {
          me.html = me.callback(me.getHtml, me, [{
            tip: me,
            element: me.element,
            forElement: activeTarget,
            event
          }]);
          if (!me.html) {
            // Nothing to display, hide
            me.hide();
            return;
          }
        }
        // If we're not anchoring to the target, track the mouse
        if (me.trackMouse) {
          me.alignTo({
            position: 'mouse',
            ignorePageScroll: true
          });
        }
      }
    }
  }
  onOwnElementMouseEnter(event) {
    this.abortDelayedHide();
  }
  //endregion
  // rootElement = where to find the float root
  // forElement = where to set up listeners
  // Can be different when using a shadowRoot not part of a webcomponent
  static getSharedTooltip(rootElement, forElement, skipCreating) {
    var _forElement$bryntum, _forElement$bryntum$t;
    let sharedTooltip = (_forElement$bryntum = forElement.bryntum) === null || _forElement$bryntum === void 0 ? void 0 : (_forElement$bryntum$t = _forElement$bryntum.tooltip) === null || _forElement$bryntum$t === void 0 ? void 0 : _forElement$bryntum$t.get(Tooltip);
    if (!sharedTooltip && !skipCreating) {
      var _forElement$bryntum2;
      // Store shared tooltips in a map on root element,
      // keyed by the class to work with multiple bundles on page
      if (!((_forElement$bryntum2 = forElement.bryntum) !== null && _forElement$bryntum2 !== void 0 && _forElement$bryntum2.tooltip)) {
        ObjectHelper.setPath(forElement, 'bryntum.tooltip', new Map());
      }
      const map = forElement.bryntum.tooltip;
      // Avoid infinite loop as the Tooltip gets created with rootElement too
      map.set(Tooltip, true);
      sharedTooltip = new Tooltip({
        forElement,
        rootElement,
        forSelector: '[data-btip]',
        resetCfg: {},
        isShared: true,
        cls: 'b-tooltip-shared',
        internalListeners: {
          // Reconfigure on pointerOver
          pointerOver({
            source: me,
            target
          }) {
            // Revert last pointerOver config set to initial setting.
            for (const key in me.resetCfg) {
              if (key === 'listeners') {
                me.un(me.resetCfg[key].set);
              }
              // Do not reset HTML to "". It causes an unwanted inter-delegate hide.
              // hideOnDelegateChange defaults to false.
              else if (key !== 'html') {
                me[key] = me.resetCfg[key].was;
              }
            }
            me.resetCfg = {};
            const forComponent = Widget.getById(target.id),
              // If it's a component's tooltip, configure from the component,
              // Otherwise gather from the dataset
              config = (forComponent === null || forComponent === void 0 ? void 0 : forComponent.tipConfig) || me.gatherDataConfigs(target.dataset);
            // getById might find an entry with same id in different context, or element might belong to a
            // widget that could not be resolved since it is in another context -> ignore
            if (forComponent && forComponent.element !== target || !forComponent && target.matches('.b-widget') ||
            // Respect our forComponent's wish to not show when it's disabled
            forComponent !== null && forComponent !== void 0 && forComponent.disabled && !forComponent.showTooltipWhenDisabled) {
              return false;
            }
            // Tooltip must be linked to an activating owner before it shows
            // so that configs which use 'up.propName' will be work as expected.
            me.owner = forComponent;
            for (const key in config) {
              me.resetCfg[key] = {
                set: config[key],
                was: me[key]
              };
              if (key === 'listeners') {
                me.ion(config[key]);
              } else {
                me[key] = config[key];
              }
            }
          },
          hide({
            source: me
          }) {
            me.owner = null;
          }
        },
        gatherDataConfigs(dataset) {
          const me = this,
            config = {};
          for (const key in dataset) {
            if (key.startsWith('btip')) {
              if (key.length > 4) {
                const configProp = StringHelper.uncapitalize(key.substr(4)); // Snip off "btip" prefix to convert to property name
                // If we have a config by the name, set it
                if (configProp in me.getDefaultConfiguration()) {
                  const value = dataset[key];
                  // gather the found config value
                  config[configProp] = isBoolean[value] ? value === 'true' : isNaN(value) ? value : parseInt(value, 10);
                }
              } else {
                config.html = dataset[key];
              }
            }
          }
          return config;
        },
        filterTarget(element) {
          const target = element.closest(this.forSelector);
          if (target) {
            return target;
          }
          if (Tooltip.showOverflow) {
            while (((_element = element) === null || _element === void 0 ? void 0 : _element.nodeType) === Element.ELEMENT_NODE) {
              var _element;
              if (DomHelper.getStyleValue(element, 'text-overflow') === 'ellipsis' && element.clientWidth < element.scrollWidth) {
                this.html = StringHelper.encodeHtml(element.textContent);
                return element;
              }
              element = element.parentNode;
            }
          }
        }
      });
      EventHelper.on({
        element: forElement,
        mouseenter: event => Tooltip.currentOverElement = event.target,
        // If mouse is not used for editing cell then Tooltip has no `currentOverElement` and no error tooltip is shown. We use keydown event.target for this
        keydown: event => Tooltip.currentOverElement = event.target,
        capture: true,
        thisObj: sharedTooltip
      });
      map.set(Tooltip, sharedTooltip);
    }
    return sharedTooltip;
  }
  static encodeConfig(tooltip) {
    const dataset = {};
    if (typeof tooltip === 'string') {
      dataset.btip = tooltip;
    }
    // Encode a full config into data-btip-allow-over etc.
    else {
      for (const config in tooltip) {
        dataset[`btip${config === 'html' ? '' : StringHelper.capitalize(config)}`] = tooltip[config];
      }
    }
    return dataset;
  }
}
// Register this widget type with its Factory
Tooltip.initClass();
// This is documented as a member in Widget
Object.defineProperty(Widget, 'tooltip', {
  get() {
    return Tooltip.getSharedTooltip(document.body, document.body);
  }
});
/**
 * Updated dynamically with the current element that the mouse is over. For use when showing a Tooltip
 * from code which is not triggered by a pointer event so that a tooltip can be positioned.
 * @member {HTMLElement} currentOverElement
 * @readonly
 * @static
 */
/**
 * Set this to true to have the {@link Core.widget.Widget#property-tooltip-static shared tooltip} pop up
 * to show the full text for elements which have overflowing text and have `text-overflow:ellipsis`.
 * @member {Boolean} showOverflow
 * @static
 */
// Register this widget type with its Factory
Widget.Tooltip = Tooltip;
Tooltip._$name = 'Tooltip';

/**
 * @module Core/widget/mixin/Labelable
 */
/**
 * This mixin provides label functionality to {@link Core.widget.Field} and {@link Core.widget.FieldSet}.
 *
 * Not to be used directly.
 *
 * @mixin
 */
var Labelable = (Target => class Labelable extends (Target || Base) {
  //region Config
  static get $name() {
    return 'Labelable';
  }
  static get configurable() {
    return {
      /**
       * Get/set fields label. Please note that the Field needs to have a label specified from start for this to
       * work, otherwise no element is created.
       * @member {String} label
       */
      /**
       * Label, prepended to field
       * @config {String}
       * @category Label
       */
      label: null,
      /**
       * Label position, either 'before' the field or 'above' the field
       * @config {'before'|'above'}
       * @default
       * @category Label
       */
      labelPosition: 'before',
      /**
       * CSS class name or class names to add to any configured {@link #config-label}
       * @config {String|Object}
       * @category Label
       */
      labelCls: null,
      /**
       * The width to apply to the `<label>` element. If a number is specified, `px` will be used.
       * @config {String|Number}
       * @localizable
       * @category Label
       */
      labelWidth: {
        value: null,
        $config: {
          localeKey: 'L{labelWidth}'
        }
      }
    };
  }
  get hasLabel() {
    return Boolean(this.label);
  }
  compose() {
    const {
      hasLabel,
      labelPosition
    } = this;
    return {
      class: {
        [`b-label-${labelPosition}`]: hasLabel,
        'b-has-label': hasLabel
      }
    };
  }
  changeLabel(label) {
    return label || '';
  }
  setupLabel(lbl) {
    return ObjectHelper.assign({
      tag: 'label',
      for: `${this.id}-input`,
      class: `b-label b-align-${lbl.align || 'start'}`
    }, lbl);
  }
  updateLabelWidth(newValue) {
    if (this.labelElement) {
      this.labelElement.style.flex = `0 0 ${DomHelper.setLength(newValue)}`;
      // If there's a label width, the input must conform with it, and not try to expand to 100%
      this.inputWrap.style.flexBasis = newValue == null ? '' : 'auto';
    }
  }
  //endregion
  // This does not need a className on Widgets.
  // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
  // to the Widget it's mixed in to should implement thus.
  get widgetClass() {}
});

/**
 * @module Core/widget/FieldContainer
 */
/**
 * This widget is created by {@link Core.widget.Field#config-container} and is not created directly.
 * @extends Core/widget/Container
 */
class FieldContainer extends Container {
  //region Config
  static get $name() {
    return 'FieldContainer';
  }
  // Factoryable type name
  static get type() {
    return 'fieldcontainer';
  }
  static get configurable() {
    return {
      /**
       * An animation config object to use when expanding or collapsing the field's
       * {@link Core.widget.Field#config-container}.
       * @config {Object} animation
       * @property {Number} [animation.duration=300] The duration of the animation (in milliseconds).
       * @internal
       */
      animation: {
        duration: 300
      },
      /**
       * Controls whether the field is collapsed (that is, the field's {@link Core.widget.Field#config-container}
       * is hidden).
       * @config {Boolean}
       * @default false
       */
      collapsed: null,
      /**
       * The animator performing the field's currently running expand or collapse animation.
       * @config {Core.util.Animator}
       * @private
       */
      collapser: {
        value: null,
        $config: 'nullify' // to abort animations on destroy
      },

      /**
       * A mapping object for config properties of the items in the {@link Core.widget.Field#config-container}.
       * The keys are the config names and the values are functions that compute the config value when passed
       * the field instance.
       *
       * For example, this is the default:
       * ```javascript
       *      syncableConfigs : {
       *          disabled : field => field.disabled
       *      }
       * ```
       * This indicates that the config property named with the key ('disabled') should be assigned to the result
       * of the function assigned to that key (`field => field.disabled`). In other words, when the field is
       * {@link Core.widget.Field#config-disabled}, all of the field's items should also be disabled.
       *
       * @config {Object}
       * @internal
       */
      syncableConfigs: null,
      /**
       * This object holds truthy values for each config property that, when modified, should trigger a sync of
       * this field's items as defined in {@link #config-syncableConfigs}.
       * @config {Object}
       * @internal
       */
      syncConfigTriggers: {
        $config: {
          merge: 'classList'
        },
        value: null
      },
      testConfig: {
        animation: {
          duration: 10
        }
      }
    };
  }
  static get delayable() {
    return {
      syncChildConfigs: 'raf'
    };
  }
  get inline() {
    return this.owner.inline ?? this.ensureItems().count === 1;
  }
  changeCollapsed(collapsed) {
    if (this.togglingCollapse) {
      this.togglingCollapse = false;
      return collapsed;
    }
    this.toggleCollapse(Boolean(collapsed));
  }
  updateCollapsed(collapsed) {
    var _this$collapser;
    this.collapser = (_this$collapser = this.collapser) === null || _this$collapser === void 0 ? void 0 : _this$collapser.destroy();
    this.setCollapsedCls(collapsed);
  }
  updateCollapser(collapser, was) {
    if (was && was.completed == null) {
      if (!was.reverting || !collapser) {
        was.destroy();
      }
    }
    this.setOwnerCls('b-collapsing', collapser);
  }
  //endregion
  /**
   * This property is `true` if the field container is currently collapsing.
   * @property {Boolean}
   * @readonly
   */
  get collapsing() {
    const {
      collapser
    } = this;
    return collapser != null && collapser.collapsed;
  }
  /**
   * This property is `true` if the field container is currently either collapsing or expanding.
   * @property {Boolean}
   * @readonly
   * @internal
   */
  get collapsingExpanding() {
    return this.collapser != null;
  }
  /**
   * This property is `true` if the field container is currently expanding.
   * @property {Boolean}
   * @readonly
   */
  get expanding() {
    const {
      collapser
    } = this;
    return collapser != null && !collapser.collapsed;
  }
  collapse(animation) {
    this.toggleCollapse(true, animation);
  }
  expand(animation) {
    this.toggleCollapse(false, animation);
  }
  setCollapsedCls(collapsed) {
    this.setOwnerCls('b-collapsed', collapsed);
  }
  setOwnerCls(cls, state) {
    var _this$owner, _this$owner$element;
    (_this$owner = this.owner) === null || _this$owner === void 0 ? void 0 : (_this$owner$element = _this$owner.element) === null || _this$owner$element === void 0 ? void 0 : _this$owner$element.classList[state ? 'add' : 'remove'](cls);
  }
  syncChildConfigs() {
    const me = this,
      {
        owner,
        syncableConfigs
      } = me;
    if (syncableConfigs) {
      let destProp, val;
      for (destProp in syncableConfigs) {
        val = syncableConfigs[destProp](owner);
        me.eachWidget(item => {
          item[destProp] = val;
        }, /* deep = */false);
      }
    }
    owner.afterSyncChildConfigs(me);
  }
  syncContainer() {
    const {
      inline,
      layout
    } = this;
    if (this.autoLayout) {
      layout.horizontal = inline;
      layout.justify = inline ? 'center' : 'stretch';
    }
  }
  toggleCollapse(collapsed, animation) {
    const me = this,
      {
        animation: collapseAnimation,
        collapser,
        inline
      } = me,
      {
        containerWrapElement
      } = me.owner,
      finalize = complete => {
        if (complete) {
          me.element.style.height = '';
          me.togglingCollapse = true;
          me.collapsed = collapsed;
          me.collapser = null; // in case we reverted
        }
      };

    if (collapsed == null) {
      collapsed = !me.collapsed;
    }
    if (animation !== false && animation !== null) {
      if (!containerWrapElement || !me.isVisible) {
        animation = null;
      } else {
        if (animation === true) {
          animation = {};
        } else if (typeof animation === 'number') {
          animation = {
            duration: animation
          };
        }
        animation = collapseAnimation || animation ? ObjectHelper.merge({}, collapseAnimation, animation) : null;
      }
    }
    if (!animation) {
      me.togglingCollapse = true;
      me.collapsed = collapsed;
    } else if (collapser && collapsed !== collapser.collapsed) {
      me.collapser = collapser.revert({
        finalize
      });
      me.collapser.collapsed = collapsed;
    } else if (!collapser && collapsed !== me.collapsed) {
      // to expand, we need to briefly become expanded in order to get a proper measurement
      !collapsed && me.setCollapsedCls(false);
      const {
          element
        } = me,
        {
          height
        } = element.getBoundingClientRect(),
        expanded = inline ? 1 : height;
      !collapsed && me.setCollapsedCls(true);
      element.style.height = `${height}px`;
      me.collapser = Animator.run(ObjectHelper.merge({
        finalize,
        element: containerWrapElement,
        [inline ? 'opacity' : 'height']: {
          from: collapsed ? expanded : 0,
          to: collapsed ? 0 : expanded
        }
      }, animation));
      me.collapser.collapsed = collapsed;
    }
  }
}
FieldContainer.initClass();
FieldContainer._$name = 'FieldContainer';

/**
 * @module Core/widget/Field
 */
const byWeight = (l, r) => (l.weight || 0) - (r.weight || 0),
  byWeightReverse = (l, r) => (r.weight || 0) - (l.weight || 0),
  emptyArray = [],
  triggerConfigs = {
    align: true,
    weight: true
  };
/**
 * Base class for {@link Core.widget.TextField} and {@link Core.widget.NumberField}. Not to be used directly.
 *
 * Most subclasses can be used as editors for the {@link Grid.column.Column}. The most popular are:
 * - {@link Core.widget.TextField}
 * - {@link Core.widget.NumberField}
 * - {@link Core.widget.DateField}
 * - {@link Core.widget.TimeField}
 * - {@link Core.widget.Combo}
 *
 * @extends Core/widget/Widget
 * @mixes Core/widget/mixin/Badge
 * @mixes Core/widget/mixin/Labelable
 * @abstract
 */
class Field extends Widget.mixin(Badge, Labelable) {
  //region Config
  static get $name() {
    return 'Field';
  }
  // Factoryable type name
  static get type() {
    return 'field';
  }
  static get configurable() {
    return {
      defaultBindProperty: 'value',
      /**
       * @hideconfigs htmlCls, content, tag, scrollable, html
       */
      /**
       * Text to display in empty field.
       * @config {String} placeholder
       */
      placeholder: null,
      /**
       * Gets or sets the value. The returned type will depend upon the Field subclass.
       *
       * `TextField` returns a `String`.
       *
       * `NumberField` returns a `Number`.
       *
       * `DateField` and `TimeField` return a `Date` object, and `null` if the field is empty.
       *
       * `Combo` will return a `String` if configured with `items` as a simple string array.
       * Otherwise it will return the {@link Core.widget.Combo#config-valueField} value from the
       * selected record, or `null` if no selection has been made.
       * @member {*} value
       */
      /**
       * Default value
       * @config {String}
       */
      value: '',
      /**
       * Name of the field which is used as a key to get/set values from/to the field.
       * Used prior to {@link Core.widget.Widget#config-ref ref} and {@link Core.widget.Widget#config-id id} in
       * {@link Core.widget.Container#property-values Container.values}.
       *
       * The config is useful when the field is used in EventEditor or TaskEditor to load/save values automatically.
       * @config {String}
       */
      name: null,
      /**
       * The labels to add either before or after the input field.
       * Each label may have the following properties:
       * * `html` The label text.
       * * `align` `'start'` or `'end'` which end of the field the label should go.
       * @config {Object[]}
       * @property {String} html Label text
       * @property {'start'|'end'} align Which end of the file the label should go
       * @category Label
       */
      labels: null,
      /**
       * Configure as `true` to indicate that a `null` field value is to be marked as invalid.
       * @config {Boolean}
       * @default false
       */
      required: null,
      /**
       * Show a trigger to clear field, and allow `SHIFT+BACKSPACE` key to clear field if this field is
       * not {@link #config-readOnly}. The trigger is available in the {@link #property-triggers} object
       * under the name `clear`. May also be an object which configures the `clear`
       * {@link #property-triggers trigger}.
       * @config {Boolean|FieldTriggerConfig}
       * @default false
       */
      clearable: null,
      /**
       * If this field is not {@link #config-readOnly}, then setting this option means that pressing
       * the `ESCAPE` key after editing the field will revert the field to the value it had when
       * the user focused the field. If the field is _not_ changed from when focused, the {@link #config-clearable}
       * behaviour will be activated.
       * @config {Boolean}
       * @default false
       */
      revertOnEscape: null,
      /**
       * An optional string to display inside the input field as an overlay. This can be useful for displaying
       * a field's units.
       *
       * This config is ignored if {@link #config-hintHtml} is set.
       *
       * For example:
       * ```javascript
       *  {
       *      type  : 'numberfield',
       *      label : 'Temperature',
       *      hint  : 'C'
       *  }
       * ```
       *
       * This config can be set to a function to dynamically generate the `hint` text:
       * ```javascript
       *  {
       *      type  : 'numberfield',
       *      label : 'Duration',
       *      hint  : ({ value }) => (value === 1) ? 'Day' : 'Days'
       *  }
       * ```
       *
       * The function is passed an object with the following properties:
       *
       *  - `source` A reference to the field instance.
       *  - `value` The current value of the field.
       *
       * A `hint` function will be called when the field changes value.
       *
       * @config {String|Function}
       * @category Label
       */
      hint: null,
      /**
       * This config is similar to {@link #config-hint} except that this config is used to display HTML content.
       * Since this can allow malicious content to be executed, be sure not to include user-entered data or to
       * encode such data (see {@link Core.helper.StringHelper#function-encodeHtml-static}).
       *
       * If this config is set, {@link #config-hint} is ignored.
       *
       * For example:
       * ```javascript
       *  {
       *      type     : 'numberfield',
       *      label    : 'Temperature',
       *      hintHtml : '<i>C</i>'
       *  }
       * ```
       *
       * This config can be set to a function to dynamically generate the `hintHtml` text:
       * ```javascript
       *  {
       *      type     : 'numberfield',
       *      label    : 'Duration',
       *      hintHtml : ({ value }) => (value === 1) ? '<i>Day</i>' : '<i>Days</i>'
       *  }
       * ```
       *
       * The function is passed an object with the following properties:
       *
       *  - `source` A reference to the field instance.
       *  - `value` The current value of the field.
       *
       * A `hintHtml` function will be called when the field changes value.
       *
       * @config {String|Function}
       * @category Label
       */
      hintHtml: null,
      /**
       * The width to apply to the `<input>` element. If a number is specified, `px` will be used.
       * @config {String|Number}
       * @category Input element
       */
      inputWidth: null,
      /**
       * The delay in milliseconds to wait after the last keystroke before triggering a change event.
       * Set to 0 to not trigger change events from keystrokes (listen for input event instead to have
       * immediate feedback, change will still be triggered on blur).
       *
       * If the field is {@link #config-clearable}, the change event fires immediately on receiving
       * the clear gesture.
       * @config {Number}
       * @default
       */
      keyStrokeChangeDelay: 0,
      /**
       * Makes the field unmodifiable by user action. The input area is not editable, and triggers
       * are unresponsive.
       *
       * This is a wider-acting setting than {@link #config-editable} which *only* sets the
       * `readOnly` attribute of the `<input>` field.
       *
       * {@link Core.widget.PickerField}s such as `Combo` and `DateField` can be `editable : false`, but still
       * modifiable through the UI.
       * @prp {Boolean}
       */
      readOnly: null,
      /**
       * Set to false to prevent user from editing the field. For TextFields it is basically the same as setting
       * {@link #config-readOnly}, but for PickerFields there is a distinction where it allows you to pick a value
       * but not to type one in the field.
       *
       * {@link Core.widget.PickerField}s such as `Combo` and `DateField` can be `editable : false`, but still
       * modifiable through the UI.
       *
       * On mobile devices, {@link Core.widget.PickerField}s are set to `editable : false` by
       * default so that the user must select a value from the dropdown picker rather than having
       * to type a value which will cause a display of the virtual keyboard.
       *
       * If typing is essential to the functioning of the field, configuring the field
       * with `editable : true` will override this behaviour.
       * @prp {Boolean}
       * @default true
       */
      editable: true,
      defaultAction: 'change',
      /**
       * The trigger Widgets as specified by the {@link #config-triggers} configuration and the
       * {@link #config-clearable} configuration. Each is a {@link Core.widget.Widget} instance which may
       * be hidden, shown and observed and styled just like any other widget.
       * @member {Object<String,Core.widget.Widget>} triggers
       */
      /**
       * The triggers to add either before or after the input field. Each property name is the reference by which
       * an instantiated Trigger Widget may be retrieved from the live `{@link #property-triggers}` property.
       *
       * Each trigger may have the following properties:
       * * `cls` The CSS class to apply.
       * * `handler` A method in the field to call upon click
       * * `align` `'start'` or `'end'` which end of the field the trigger should go.
       * * `weight` (Optional) Higher weighted triggers gravitate towards the input field.
       *
       * ```javascript
       * const textField = new TextField({
       *   triggers : {
       *       check : {
       *           cls : 'b-fa b-fa-check',
       *           handler() {
       *               ...
       *           }
       *       },
       *       ...
       *   }
       * })
       * ```
       *
       * @config {Object<String,FieldTriggerConfig>}
       */
      triggers: null,
      /**
       * Specify `false` to prevent field from being highlighted when on external value changes
       * @config {Boolean}
       */
      highlightExternalChange: true,
      localizableProperties: ['label', 'title', 'placeholder', 'labelWidth'],
      /**
       * Specify `true` to auto select field contents on focus
       * @config {Boolean}
       * @default
       */
      autoSelect: false,
      /**
       * Sets the native `autocomplete` property of the underlying input element. For more information, please refer to
       * [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete)
       * @config {String}
       * @default
       * @category Input element
       */
      autoComplete: 'off',
      /**
       * Sets the native `spellcheck` property of the underlying input element. For more information, please refer to
       * [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/spellcheck)
       * @config {Boolean}
       * @category Input element
       */
      spellCheck: null,
      /**
       * Set to `false` to not highlight a field as invalid while typing, to instead show it on ENTER key press
       * or similar.
       * @config {Boolean}
       * @category Input element
       */
      validateOnInput: true,
      /**
       * Sets custom attributes of the underlying input element. For more information, please refer to
       * [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes)
       * @config {Object}
       * @default
       * @category Input element
       */
      inputAttributes: null,
      /**
       * Sets the `type` attribute of the underlying input element (password, hidden, date, color, etc).
       * @config {String}
       * @category Input element
       */
      inputType: 'text',
      /**
       * Text alignment for the input field.
       * @config {String}
       * @category Input element
       */
      inputAlign: null,
      /**
       * A list of property names to be set in the underlying input element from properties
       * by the same name in this Field object if the value is not `== null`.
       * @private
       * @category Input element
       */
      attributes: {
        value: ['placeholder', 'autoComplete', 'spellCheck', 'minLength', 'maxLength', 'pattern', 'tabIndex', 'min', 'max'],
        $config: {
          merge: 'distinct'
        }
      },
      nullValue: {
        $config: null,
        value: null,
        default: null // store _value=null on prototype
      },

      updatedClsDuration: 500,
      inputReadOnly: false,
      ariaElement: 'input',
      /**
       * The configuration for additional items associated to this field. This is typically used to add contextual
       * fields related to a {@link Core.widget.Checkbox checkbox} or {@link Core.widget.Radio radio button}. See
       * these classes for examples of nested fields.
       *
       * This config can be provided as an array of widget config objects, an object with named widgets (see
       * {@link Core.widget.FieldContainer#config-namedItems}, or a config object for the whole
       * {@link Core.widget.FieldContainer field container}.
       *
       * To determine if the object is a `namedItems` object or a {@link Core.widget.FieldContainer field container}
       * config, the object is checked for either a `type` or an `items` property. If it has either of these
       * properties, it is a field container config object. Configuring the container is useful for applying
       * {@link Core.widget.FieldContainer#config-cls classes} or {@link Core.widget.FieldContainer#config-style styles}
       * to the container as a whole.
       *
       * For example, to add named items:
       * ```javascript
       *  new Checkbox({
       *      text : 'Separate shipping address',
       *      container : {
       *          address1 : {
       *              type : 'textfield'
       *          },
       *          address2 : {
       *              type : 'textfield'
       *          }
       *      }
       *  });
       * ```
       *
       * To style the container as well, move the items to the `items` property and add `cls`:
       * ```javascript
       *  new Checkbox({
       *      text : 'Separate shipping address',
       *      container : {
       *          cls   : 'address-form',
       *          items : {
       *              address1 : {
       *                  type : 'textfield'
       *              },
       *              address2 : {
       *                  type : 'textfield'
       *              }
       *          }
       *      }
       *  });
       * ```
       *
       * @config {Core.widget.FieldContainer}
       * @accepts {Object<string,ContainerItemConfig>|ContainerItemConfig[]|FieldContainerConfig}
       * @category Container
       */
      container: {
        $config: 'nullify',
        value: null
      },
      /**
       * The default configuration for the {@link #config-container}.
       * @config {Core.widget.FieldContainer}
       * @accepts {FieldContainerConfig|Core.widget.FieldContainer}
       * @category Container
       * @internal
       */
      containerDefaults: {
        type: 'fieldcontainer',
        syncableConfigs: {
          disabled: field => field.disabled
        },
        syncConfigTriggers: {
          disabled: 1
        }
      },
      /**
       * The config controls how the value of nested items are handled when a parent container gets or sets its
       * {@link Core.widget.Container#property-values}.
       *
       * The valid values for this config are:
       *  - `null` (the default) will include the values of this field's items if this field stores its own value.
       *  - `true` to always include the values of this field's items.
       *  - `false` to never include the values of this field's items.
       *  - `'nested'` to include the values of this field's items as a nested object under the field's `name`.
       *    This field's `value` is stored as the `'value'` property of that object.
       *  - Any other string is treated as the name of a property on this field. When truthy, the values of this
       *    field's items will be included.
       *  - A function can be supplied that must return a value given this field as its sole argument. If that
       *    value is truthy, this field's items will be included.
       *
       * @config {Boolean|String|Function}
       * @category Container
       */
      containValues: null,
      /**
       * Set this config to `true` to always display items horizontally along with this field. This assigns an
       * {@link Core.widget.layout.Box hbox} as the {@link Core.widget.Container#config-layout} to the
       * {@link #config-container}.
       *
       * Alternatively, set this config to `false` to wrap this field's items below. This assigns a
       * {@link Core.widget.layout.VBox} as the {@link Core.widget.Container#config-layout} to the
       * {@link #config-container}.
       *
       * This config defaults to `true` if there is exactly one item, and `false` otherwise.
       * @config {Boolean}
       * @category Container
       */
      inline: null,
      testConfig: {
        updatedClsDuration: 10
      },
      keyMap: {}
    };
  }
  static get delayable() {
    return {
      highlightChanged: 'raf'
    };
  }
  doDestroy() {
    var _me$inputListenerRemo, _me$keyListenerRemove, _me$container;
    const me = this,
      {
        triggers
      } = me,
      errorTip = me.isPainted && Field.getSharedErrorTooltip(me.rootElement, true);
    (_me$inputListenerRemo = me.inputListenerRemover) === null || _me$inputListenerRemo === void 0 ? void 0 : _me$inputListenerRemo.call(me);
    (_me$keyListenerRemove = me.keyListenerRemover) === null || _me$keyListenerRemove === void 0 ? void 0 : _me$keyListenerRemove.call(me);
    (_me$container = me.container) === null || _me$container === void 0 ? void 0 : _me$container.destroy();
    super.doDestroy();
    if (triggers) {
      for (const t of Object.values(triggers)) {
        t.destroy();
      }
    }
    // The errorTip references this field, hide it when we die.
    if ((errorTip === null || errorTip === void 0 ? void 0 : errorTip.field) === me) {
      errorTip.hide();
    }
  }
  get childItems() {
    const {
        container,
        triggers
      } = this,
      ret = triggers ? Object.values(triggers) : [];
    return container ? [...ret, ...container.childItems] : ret;
  }
  get invalidValueError() {
    return 'L{invalidValue}';
  }
  /**
   * A singleton error tooltip which activates on hover of invalid fields.
   * before show, it gets a reference to the field and interrogates its
   * active error list to display as the tip content.
   * @member {Core.widget.Tooltip}
   * @readonly
   */
  get errorTip() {
    return this.constructor.getSharedErrorTooltip(this.rootElement);
  }
  static getSharedErrorTooltip(rootElement, doNotCreate) {
    var _rootElement$bryntum;
    let sharedErrorTooltip = (_rootElement$bryntum = rootElement.bryntum) === null || _rootElement$bryntum === void 0 ? void 0 : _rootElement$bryntum.errorTooltip;
    if (!sharedErrorTooltip && !doNotCreate) {
      rootElement.bryntum = rootElement.bryntum || {};
      sharedErrorTooltip = new Tooltip({
        cls: 'b-field-error-tip',
        forSelector: '.b-field.b-invalid .b-field-inner',
        align: {
          align: 'l-r',
          monitorTargetMutation: true
        },
        scrollAction: 'realign',
        trapFocus: false,
        rootElement,
        onBeforeShow() {
          const tip = this,
            field = Widget.fromElement(tip.activeTarget);
          if (field) {
            const errors = field.getErrors();
            if (errors) {
              tip.html = errors.join('<br>');
              tip.field = field;
              return true;
            }
          }
          // Veto show
          return false;
        }
      });
      rootElement.bryntum.errorTooltip = sharedErrorTooltip;
    }
    return sharedErrorTooltip;
  }
  /**
   * A singleton error tooltip which activates on hover of invalid fields.
   * before show, it gets a reference to the field and interrogates its
   * active error list to display as the tip content.
   *
   * Please note: Not applicable when using widgets inside a shadow root
   * @member {Core.widget.Tooltip}
   * @readonly
   * @static
   */
  static get errorTip() {
    return this.getSharedErrorTooltip(document.body);
  }
  //endregion
  //region Event
  /**
   * Fired when the user types into this field.
   * @event input
   * @param {Core.widget.Field} source This field.
   * @param {String} value - This field's value
   * @param {Event} event - The triggering DOM event.
   */
  /**
   * Fired when this field's value changes.
   * @event change
   * @param {String} value - This field's value
   * @param {String} oldValue - This field's previous value
   * @param {Boolean} valid - True if this field is in a valid state.
   * @param {Event} [event] - The triggering DOM event if any.
   * @param {Boolean} userAction - Triggered by user taking an action (`true`) or by setting a value (`false`)
   * @param {Core.widget.Field} source - This Field
   */
  /**
   * User performed default action (typed into this field).
   * @event action
   * @param {String} value - This field's value
   * @param {String} oldValue - This field's previous value
   * @param {Boolean} valid - True if this field is in a valid state.
   * @param {Event} [event] - The triggering DOM event if any.
   * @param {Boolean} userAction - Triggered by user taking an action (`true`) or by setting a value (`false`)
   * @param {Core.widget.Field} source - This Field
   */
  /**
   * Fired when this field is {@link #function-clear cleared}.
   *
   * This will be triggered when a user clicks this field's clear {@link #property-triggers trigger}
   * @event clear
   * @param {Core.widget.Field} source - This Field
   */
  /**
   * User clicked one of this field's {@link #property-triggers}
   * @event trigger
   * @param {Core.widget.Field} source This field
   * @param {Core.widget.Widget} trigger The trigger activated by click or touch tap.
   */
  //endregion
  //region Init
  construct(config) {
    super.construct(config);
    const me = this;
    if (me.keyStrokeChangeDelay) {
      me.changeOnKeyStroke = me.buffer(me.internalOnChange, me.keyStrokeChangeDelay);
    }
  }
  // Adding triggers keymap to field keymap with prefix 'triggerName.';
  changeKeyMap(keyMap) {
    const me = this;
    let mergedKeyMap = {};
    if (keyMap) {
      if (!me._fieldKeyMap) {
        me._fieldKeyMap = keyMap;
        ObjectHelper.assign(mergedKeyMap, keyMap);
      } else {
        ObjectHelper.assign(mergedKeyMap, me._fieldKeyMap);
      }
    }
    for (const triggerName in me.triggers) {
      var _me$triggers$triggerN;
      if ((_me$triggers$triggerN = me.triggers[triggerName]) !== null && _me$triggers$triggerN !== void 0 && _me$triggers$triggerN.keyMap) {
        mergedKeyMap = me.mergeKeyMaps(mergedKeyMap, me.triggers[triggerName].keyMap, triggerName);
      }
    }
    return mergedKeyMap;
  }
  get keyMapSubComponents() {
    return this.triggers;
  }
  onFocusIn(e) {
    const me = this;
    me.valueOnFocus = ObjectHelper.clone(me.value);
    me.validOnFocus = !(me.errors && Object.keys(me.errors).length);
    super.onFocusIn(e);
    // Inform user about the validity state when they focus on the field.
    me.focusing = true;
    me.syncInvalid();
    me.focusing = false;
  }
  onFocusOut(e) {
    super.onFocusOut(e);
    // Required field not flagged with error initially, flag on blur instead for better appearance
    this.syncRequired();
    // Check field consistency on blur
    this.onEditComplete();
  }
  /**
   * Template function which may be implemented by subclasses to synchronize
   * input state and validity state upon completion of the edit.
   * @internal
   */
  onEditComplete() {}
  get rootUiClass() {
    return Field;
  }
  compose() {
    // Force evaluation of clearable so triggers include the clearable trigger. We can't bury this inside
    // changeTriggers since there may be no other triggers defined (which would mean changeTriggers would never
    // be run)
    this.getConfig('clearable');
    const me = this,
      {
        container,
        innerElements,
        label,
        labels,
        labelCls,
        readOnly,
        triggers
      } = me,
      triggerInstances = ObjectHelper.values(triggers, (k, v) => !v),
      // The triggers at each end are sorted "gravitationally".
      // Higher weight sorts towards the center which is the input element.
      startTriggers = triggerInstances.filter(t => t.align === 'start').sort(byWeight),
      endTriggers = triggerInstances.filter(t => t.align !== 'start').sort(byWeightReverse),
      setupLabel = me.setupLabel.bind(me),
      innerChildren = [...startTriggers.map(t => t.element), ...innerElements, ...endTriggers.map(t => t.element)];
    return {
      class: {
        'b-has-start-trigger': startTriggers.length,
        'b-no-input': !innerElements.length,
        'b-readonly': readOnly,
        'b-field-container': Boolean(container),
        'b-field-container-inline': container === null || container === void 0 ? void 0 : container.inline
      },
      children: [...(labels || emptyArray).filter(t => t && t.align !== 'end').map(setupLabel), (label || null) && setupLabel({
        reference: 'labelElement',
        class: `b-label b-align-start ${labelCls || ''}`,
        html: label
      }), innerChildren.length ? {
        class: 'b-field-inner',
        reference: 'inputWrap',
        children: innerChildren
      } : null, ...(labels || emptyArray).filter(t => (t === null || t === void 0 ? void 0 : t.align) === 'end').map(setupLabel), ...(container ? [{
        reference: 'containerWrapElement',
        children: [container.element],
        class: {
          'b-field-container-wrap': 1
        }
      }] : emptyArray)]
    };
  }
  updateElement(element, was) {
    var _me$keyListenerRemove2;
    const me = this,
      value = me.initialConfig.value,
      {
        input
      } = me;
    super.updateElement(element, was);
    // Value must be injected into the input element after it has been constructed, not in the
    // initial template, otherwise the caret position will not be as expected.
    if (value != null) {
      me.value = value;
    }
    me.syncEmpty();
    me.updateInputReadOnly(me.inputReadOnly);
    me.syncInvalid();
    const keyEventElement = input || me.focusElement;
    (_me$keyListenerRemove2 = me.keyListenerRemover) === null || _me$keyListenerRemove2 === void 0 ? void 0 : _me$keyListenerRemove2.call(me);
    me.keyListenerRemover = keyEventElement && EventHelper.on({
      element: keyEventElement,
      thisObj: me,
      keydown: 'internalOnKeyEvent',
      keypress: 'internalOnKeyEvent',
      keyup: 'internalOnKeyEvent'
    });
  }
  // Subclasses may implement this.
  // Needed because Checkbox produces an array of two elements as its innerElements
  get innerElements() {
    return [this.inputElement];
  }
  /**
   * The input element at the heart if this field
   * @member {HTMLElement} input
   */
  get inputElement() {
    const {
        attributes,
        inputAttributes,
        id,
        inputCls,
        inputType,
        name
      } = this,
      domConfig = ObjectHelper.assign({
        reference: 'input',
        tag: 'input',
        type: inputType,
        name: name || id,
        id: `${id}-input`,
        retainElement: true // allow the input to be transplanted as in combo/chipView
      }, inputAttributes);
    if (inputCls) {
      domConfig.class = inputCls;
    }
    for /* empty */
    (let key, value, i = attributes.length; i-- > 0;) {
      key = attributes[i];
      value = this[key];
      if (value != null) {
        // don't smash properties already in domConfig w/null values...
        domConfig[key] = value;
      }
    }
    return domConfig;
  }
  //endregion
  //region Focus & select
  get caretPos() {
    return this.textSelection[0];
  }
  set caretPos(value) {
    this.textSelection = value;
  }
  get focusElement() {
    return this.input;
  }
  get textSelection() {
    const input = this.input;
    let ret;
    try {
      ret = [input.selectionStart, input.selectionEnd, input.selectionDirection];
    } catch (e) {
      var _input$value;
      // ignore (some input types cannot do this)
      ret = ((_input$value = input.value) === null || _input$value === void 0 ? void 0 : _input$value.length) || 0;
      ret = [ret, ret];
    }
    return ret;
  }
  set textSelection(value) {
    if (typeof value === 'number') {
      this.select(value, value);
    } else {
      this.select(...value);
    }
  }
  get hasTextSelection() {
    const [selectionStart, selectionEnd] = this.textSelection;
    return selectionStart && selectionEnd - selectionStart > 0;
  }
  /**
   * Returns the input value for this field's input element that will be present if
   * the event carrying the given text is allowed to proceed.
   * @param {String} text
   * @returns {String}
   * @private
   */
  getAfterValue(text) {
    const [begin, end] = this.textSelection,
      value = this.input.value;
    return `${value.substr(0, begin)}${text}${value.substr(end || begin)}`;
  }
  /**
   * Selects the field contents. Optionally may be passed a start and end.
   * @param {Number} [start] The start index from which to select the input.
   * @param {Number} [end] The index at which to end the selection of the input.
   */
  select(start, end) {
    // Use focusElement which is the input field in this class
    // but allows subclasses to use other elements.
    // See, for example, TextAreaPickerField
    const input = this.focusElement;
    if (input.value.length) {
      if (arguments.length === 0) {
        this.selectAll();
        return;
      }
      // Only allowed to select range in certain element / input types
      if (!this.supportsTextSelection) {
        return;
        // throw new Error('Trying to select text on an invalid element type');
      }

      input.setSelectionRange(start, end);
    }
  }
  moveCaretToEnd() {
    const input = this.input;
    if (input.createTextRange) {
      const range = input.createTextRange();
      range.collapse(false);
      range.select();
    } else if (this.supportsTextSelection) {
      // Move caret to the end if possible
      this.select(input.value.length, input.value.length);
    }
  }
  selectAll() {
    this.focusElement.select();
  }
  // called on value changes to update styling of empty vs non-empty field
  syncEmpty() {
    var _this$triggers;
    const {
        isEmptyInput,
        isEmpty,
        element
      } = this,
      clear = (_this$triggers = this.triggers) === null || _this$triggers === void 0 ? void 0 : _this$triggers.clear,
      empty = isEmptyInput && isEmpty;
    if (element) {
      if (clear) {
        clear[empty ? 'hide' : 'show']();
      }
      element.classList.toggle('b-empty', empty);
    }
  }
  updateHint() {
    this.syncHint();
  }
  updateHintHtml() {
    this.syncHint();
  }
  syncHint() {
    const me = this,
      {
        input,
        hint,
        hintHtml
      } = me,
      parent = input === null || input === void 0 ? void 0 : input.parentElement;
    if (input) {
      let hintValue = hintHtml || hint;
      const hintElement = me.hintElement || hintValue && (me.hintElement = DomHelper.createElement({
        parent,
        className: 'b-field-hint',
        nextSibling: input.nextSibling,
        children: [{
          className: 'b-field-hint-content'
        }]
      }));
      if (hintElement) {
        if (typeof hintValue === 'function') {
          hintValue = hintValue({
            source: me,
            value: me.value
          });
        }
        hintElement.firstChild[hintHtml ? 'innerHTML' : 'textContent'] = hintValue || '';
      }
      me.element.classList[hintValue ? 'remove' : 'add']('b-field-no-hint');
    }
  }
  syncInvalid() {
    const me = this,
      {
        isPainted
      } = me;
    me.updatingInvalid = true;
    if (isPainted) {
      const {
        isValid,
        element,
        inputWrap
      } = me;
      element.classList[isValid ? 'remove' : 'add']('b-invalid');
      // We achieved validity, so ensure the error tip is hidden
      if (isValid) {
        const errorTip = me.constructor.getSharedErrorTooltip(me.rootElement, true);
        if (errorTip !== null && errorTip !== void 0 && errorTip.isVisible && errorTip.field === me) {
          errorTip.hide();
        }
      }
      // If the mouse is over, the tip should spring into view
      else {
        // errorTip needs Tooltip.listenersTarget to be there
        // otherwise it doesn't setup listeners and cannot notice we mouseover an invalid field
        const errorTip = me.errorTip;
        // Show the error UI if this field is focused, or if the field is under the mouse pointer
        if (errorTip && (me.containsFocus || me.isVisible && inputWrap.contains(Tooltip.currentOverElement))) {
          // Already shown by this field's inputWrap, just update content.
          if (errorTip.activeTarget === inputWrap && errorTip.isVisible) {
            errorTip.onBeforeShow();
          } else {
            errorTip.activeTarget = inputWrap;
            errorTip.showBy(inputWrap);
          }
        }
      }
    }
    me.updatingInvalid = false;
  }
  //endregion
  //region Getters/setters
  updateEditable() {
    this.syncInputReadOnly();
  }
  syncInputReadOnly() {
    this.getConfig('readOnly'); // make sure our config is initialized...
    // but since the readOnly getter conflates disabled into it, we ultimately have to look at _readOnly:
    this.inputReadOnly = this._readOnly || this.editable === false;
  }
  updateInputReadOnly(readOnly) {
    const me = this,
      {
        input,
        inputListenerRemover
      } = me;
    // Editable refers *ONLY* to the readOnly state of the <input> field within the field.
    // It does *NOT* imply that the field is not modifiable by user interaction.
    // For example, a Combo or DateField may be not editable, but may still be set through the UI.
    // It is the readOnly config which disables user interaction from modifying the field.
    if (input) {
      input.readOnly = readOnly ? 'readOnly' : null;
      if (readOnly) {
        me.inputListenerRemover = inputListenerRemover === null || inputListenerRemover === void 0 ? void 0 : inputListenerRemover();
      } else if (!inputListenerRemover) {
        me.inputListenerRemover = EventHelper.on({
          element: input,
          thisObj: me,
          focus: 'internalOnInputFocus',
          change: 'internalOnChange',
          input: 'internalOnInput'
        });
      }
    }
  }
  changeReadOnly(value) {
    return Boolean(value);
  }
  updateReadOnly(readOnly) {
    this.syncInputReadOnly();
  }
  updateClearable(clearable) {
    const me = this;
    me.getConfig('triggers');
    me.triggers = {
      clear: clearable && ObjectHelper.assign({
        cls: 'b-icon-remove',
        weight: 1000,
        key: 'Shift+backspace',
        handler() {
          me._isUserAction = true;
          me.clear(...arguments);
          me._isUserAction = false;
        }
      }, clearable) || null
    };
  }
  changeTriggers(triggers, was) {
    const me = this,
      manager = me.$triggers || (me.$triggers = new DynamicObject({
        configName: 'triggers',
        factory: Field.Trigger,
        inferType: false,
        // the name of a trigger in the triggers object is not its type
        owner: me,
        created(instance) {
          FunctionHelper.after(instance, 'onConfigChange', (ret, {
            name
          }) => {
            if (triggerConfigs[name]) {
              me.onConfigChange({
                name: 'triggers',
                value: manager.target
              });
            }
          });
        },
        setup(config, name) {
          config.reference = config.ref = name;
          config.parent = me;
        }
      }));
    if (me.stepTriggers === false && (triggers.back || triggers.forward)) {
      triggers = ObjectHelper.assign({}, triggers);
      delete triggers.back;
      delete triggers.forward;
    }
    manager.update(triggers);
    if (me.element) {
      // Force changeKeyMap to be called
      // eslint-disable-next-line no-self-assign
      me.keyMap = me.keyMap;
    }
    if (!was) {
      // Only return the target once. Further calls are processed above so we need to return undefined to ensure
      // onConfigChange is called. By returning the same target on 2nd+ call, it passes the === test and won't
      // trigger onConfigChange.
      return manager.target;
    }
  }
  updateInputWidth(newValue) {
    this.input.style.width = DomHelper.setLength(newValue);
    this.element.classList.add('b-has-width');
  }
  updateInputAlign(newValue) {
    this.input.style.textAlign = newValue;
  }
  /**
   * Returns true if the field value is valid
   * @type {Boolean}
   * @readonly
   */
  get isValid() {
    const me = this;
    // Disabled fields are considered valid
    if (!me.disabled) {
      me.syncRequired();
      if (me.errors && Object.keys(me.errors).length) {
        return false;
      }
      const validity = me.validity;
      if (validity) {
        return validity.valid;
      }
    }
    return true;
  }
  /**
   * Returns `true` if this field is empty. That is, if it would violate the {@link #config-required}
   * setting.
   *
   * This may have different definitions in subclasses from simple text fields.
   * @type {Boolean}
   * @readonly
   */
  get isEmpty() {
    return this.value == null || this.value === '';
  }
  /**
   * Returns true if the field's input is empty
   * @type {Boolean}
   * @readonly
   */
  get isEmptyInput() {
    return !this.input || this.input.value == null || this.input.value === '';
  }
  /**
   * Returns the DOM `ValidityState` for this widget's input element, or `null` if there
   * isn't one.
   * @returns {ValidityState}
   * @private
   */
  get validity() {
    const input = this.input;
    return input === null || input === void 0 ? void 0 : input.validity;
  }
  // Called by Editor.js, for overriding in subclasses that require async setting of values (custom editors in React)
  async setValue(value) {
    this.value = value;
  }
  changeValue(value, was) {
    if (value == null) {
      value = this.nullValue;
    }
    // In cases of arrays, for example, we need to return "was" to pass the === check in the setter to convince
    // the config that, in fact, no change has occurred.
    if (this.hasChanged(was, value)) {
      return value;
    }
    // When loading a record into a form, an empty value might be loaded into a field, which is not detected as a
    // change. In this scenario it should still be flagged as invalid
    if (value === '') {
      this.syncRequired();
    }
    return was;
  }
  updateValue(value, oldValue) {
    const me = this;
    // Do not flag with error if configured empty, looks ugly to have fields start red
    if (!me.isConfiguring) {
      me.syncRequired();
      // Do not trigger change event during configuration phase
      // or during keyboard input
      if (!me.inputting) {
        // trigger change event, signaling that origin is from set operation,
        // makes it easier to ignore such events in applications that set value on load etc
        me.triggerChange();
      }
    }
    // lastValue is used for IE to check if a change event should be triggered when pressing ENTER
    if (!me.inputting) {
      me._lastValue = value;
    }
    me.syncInputFieldValue();
    if (me.overflowTwin && !me._overflowTwinSync) {
      me._overflowTwinSync = true;
      me.overflowTwin.value = value;
      me._overflowTwinSync = false;
    }
  }
  /**
   * Compares this field's value with its previous value. May be overridden in subclasses
   * which have more complex value types. See, for example, {@link Core.widget.DurationField}.
   * @param {*} oldValue
   * @param {*} newValue
   * @private
   */
  hasChanged(oldValue, newValue) {
    return newValue !== oldValue;
  }
  /**
   * Called by the base Field class's `set value` to sync the state of the UI with the field's value.
   *
   * Relies upon the class implementation of `get inputValue` to return a string representation of
   * the value for user consumption and editing.
   * @private
   */
  syncInputFieldValue(skipHighlight = false) {
    const me = this,
      {
        input,
        parent,
        inputValueAttr,
        inputValue
      } = me;
    // If we are updating from internalOnInput, we must not update the input field
    if (input && !me.inputting && input[inputValueAttr] !== inputValue) {
      // Subclasses may implement their own read only inputValue property.
      input[inputValueAttr] = inputValue;
      // If it's being manipulated from the outside, highlight it
      if (!me.isConfiguring && !me.containsFocus && me.highlightExternalChange) {
        input.classList.remove('b-field-updated');
        me.clearTimeout('removeUpdatedCls');
        if (parent) {
          const {
            assigningValues
          } = parent;
          if (assigningValues === true || (assigningValues === null || assigningValues === void 0 ? void 0 : assigningValues.highlight) === false) {
            skipHighlight = true;
          }
        }
        // if (!skipHighlight && (!parent || !(parent.isSettingValues || parent.assigningValues?.preventHighlight))) {
        if (!skipHighlight) {
          me.highlightChanged();
        }
      }
    }
    me.syncEmpty();
    me.syncInvalid();
  }
  highlightChanged() {
    this.input.classList.add('b-field-updated');
    this.setTimeout('removeUpdatedCls', this.updatedClsDuration);
  }
  removeUpdatedCls() {
    this.input.classList.remove('b-field-updated');
  }
  /**
   * A String representation of the value of this field for {@link #function-syncInputFieldValue} to use
   * as the input element's value.
   *
   * Subclasses may override this to create string representations.
   *
   * For example, {@link Core.widget.DateField}'s implementation will format the field date
   * value according to its configured {@link Core.widget.DateField#config-format}. And {@link Core.widget.Combo}'s
   * implementation will return the {@link Core.widget.Combo#config-displayField} of the selected record.
   * @internal
   * @readOnly
   */
  get inputValue() {
    // Do not use the _value property. If called during configuration, this
    // will import the configured value from the config object.
    return this.value == null ? '' : this.value;
  }
  get inputValueAttr() {
    return 'value';
  }
  get supportsTextSelection() {
    const input = this.focusElement;
    // Text selection using setSelectionRange is allowed in Chrome for certain elements.
    return input && (input.tagName.toLowerCase() === 'textarea' || input.type && /text|search|password|tel|url/.test(input.type));
  }
  //endregion
  //region Events
  internalOnInputFocus() {
    if (this.autoSelect) {
      this.selectAll();
    }
  }
  /**
   * Trigger event when fields input changes
   * @fires change
   * @private
   */
  internalOnChange(event) {
    const me = this;
    // Don't trigger change if we enter invalid value or if value has not changed (for IE when pressing ENTER)
    if (me.hasChanged(me._lastValue, me.value) && me.isValid) {
      me.triggerChange(event, true);
      me._lastValue = me.value;
    }
  }
  triggerChange(event, userAction = Boolean(this._isUserAction)) {
    const me = this,
      {
        value,
        _lastValue: oldValue,
        isValid: valid
      } = me;
    me.syncHint();
    // trigger change event, signaling that origin is from user
    me.triggerFieldChange({
      value,
      oldValue,
      event,
      userAction,
      valid
    });
    // per default Field triggers action event on change, but might be reconfigured in subclasses (such as Combo)
    if (me.defaultAction === 'change') {
      me.trigger('action', {
        value,
        oldValue,
        event,
        userAction,
        valid
      });
    }
    // since Widget has Events mixed in configured with 'callOnFunctions' this will also call onClick and onAction
  }

  fetchInputValue() {
    this.value = this.input[this.inputValueAttr];
  }
  /**
   * Trigger event when user inputs into field
   * @fires input
   * @param event
   * @private
   */
  internalOnInput(event) {
    var _me$changeOnKeyStroke;
    const me = this;
    if (!me.validateOnInput) {
      me.errorTip.hide();
    }
    // Keep the value synced with the inputValue at all times.
    me.inputting = true;
    me.fetchInputValue();
    me.inputting = false;
    me.trigger('input', {
      value: me.value,
      event
    });
    (_me$changeOnKeyStroke = me.changeOnKeyStroke) === null || _me$changeOnKeyStroke === void 0 ? void 0 : _me$changeOnKeyStroke.call(me, event);
    // since Widget has Events mixed in configured with 'callOnFunctions' this will also call onInput
  }
  /**
   * Returns `true` if the {@link #property-input} field needs to be synced with the internal
   * {@link #property-value} of this field.
   *
   * May be overridden in subclasses where this is more complex such as multiSelect Combo
   * with a `ChipView` where the input area does not reflect the field's value.
   * @private
   */
  get needsInputSync() {
    return this.input[this.inputValueAttr] !== String(this.inputValue ?? '');
  }
  internalOnKeyEvent(event) {
    const me = this,
      {
        value
      } = me;
    let stopEvent = false;
    if (event.type === 'keydown') {
      if (event.key === 'Escape' && !(me.readOnly || me.disabled)) {
        // We can be started with an initialValue which takes precedence over the valueOnFocus.
        // Because in some situations focus can move out and back in after a change which needs
        // to be revertable. For example in cell editing.
        const wasValid = me.isValid,
          initialValue = 'initialValue' in me ? me.initialValue : me.valueOnFocus,
          valueChanged = me.hasChanged(initialValue, value),
          {
            needsInputSync
          } = me;
        // We revert on escape if we are configured to do so AND:
        // We are in an invalid state, or the value has changed, or the displayed value doesn't match the field value.
        if (me.revertOnEscape && (!wasValid || valueChanged || needsInputSync)) {
          if (valueChanged) {
            me.value = initialValue;
          }
          if (needsInputSync) {
            me.syncInputFieldValue(true);
          }
          me.clearError();
          // If this processing changed the value or input field's value back to valid, or
          // the validity state was different to that upon focus
          // then this was a revert operation, so prevent further ESC processing.
          stopEvent = (valueChanged || needsInputSync) && me.isValid || wasValid !== me.validOnFocus;
        }
      }
    }
    // The above processing might have destructive consequences.
    if (!me.isDestroyed) {
      // If the keystroke had the effect of changing the field, prevent other handlers
      // which may mask that effect. Such as ESC exiting some UI context. Keep it contained.
      if (stopEvent) {
        event.stopImmediatePropagation();
      }
      me.trigger(event.type, {
        event
      });
    }
  }
  /**
   * Clears the value of this Field, and triggers the {@link #event-clear} event.
   */
  clear(event) {
    const me = this,
      {
        value
      } = me;
    if (value !== me.nullValue || me.input.value.length > 0) {
      me.value = me.nullValue;
      me.clearError();
      me.syncInvalid();
      // event will be present if called from the clearTrigger click
      me.trigger('clear', {
        event
      });
    }
  }
  /**
   * Called when disabled state is changed.
   * Used to add or remove 'b-invalid' class for the invalid field based on current disabled state.
   * @private
   */
  onDisabled() {
    this.syncInvalid();
  }
  //endregion
  //region Error
  syncRequired() {
    var _me$parent;
    const me = this;
    // Empty valid if any ancestor Container is setting values
    if (!me.isConfiguring && !me.focusing && me.required && me.isEmpty && !((_me$parent = me.parent) !== null && _me$parent !== void 0 && _me$parent.isSettingValues)) {
      me.setError('L{fieldRequired}', me.updatingInvalid);
    } else {
      me.clearError('L{fieldRequired}', me.updatingInvalid);
    }
  }
  /**
   * Adds an error message to the list of errors on this field.
   * By default the field's valid/invalid state is updated; pass
   * `false` as the second parameter to disable that if multiple
   * changes are being made to the error state.
   * @param {String} error A locale string, or message to use as an error message.
   * @param {Boolean} [silent=false] Pass as `true` to skip updating the field's valid/invalid state.
   * @privateparam {Boolean} [temporary=false] Pass as `true` to remove the error upon the next user interaction.
   */
  setError(error, silent, temporary) {
    const me = this;
    // Error messages are deduplicated by using them as the property names in an object.
    (me.errors || (me.errors = {}))[me.optionalL(error)] = 1;
    if (!silent) {
      me.syncInvalid();
    }
    if (temporary) {
      const clearError = () => {
          me.clearError(error);
          remover();
        },
        remover = me.ion({
          keydown: clearError,
          focusOut: clearError
        });
    }
  }
  /**
   * Removes an error message from the list of errors on this field.
   *
   * By default, the field's valid/invalid state is updated; pass `false` as the second parameter to disable that if
   * multiple changes are being made to the error state.
   *
   * @param {String} [error] A locale string, or message to remove. If not passed, all errors are cleared.
   * @param {Boolean} [silent=false] Pass as `true` to skip updating the field's valid/invalid state.
   */
  clearError(error, silent) {
    const me = this;
    if (me.errors) {
      if (error) {
        delete this.errors[this.optionalL(error)];
      } else {
        me.errors = {};
      }
    }
    if (!silent) {
      me.syncInvalid();
    }
  }
  /**
   * Returns an array of error messages as set by {@link #function-setError}, or
   * `undefined` if there are currently no errors.
   * @returns {String[]} The errors for this field, or `undefined` if there are no errors.
   */
  getErrors() {
    const me = this;
    if (!me.isValid) {
      var _errors;
      const validity = me.validity,
        // See possible state names: https://developer.mozilla.org/en-US/docs/Web/API/ValidityState
        stateName = ObjectHelper.keys(validity).find(key => key !== 'valid' && key !== 'customError' && validity[key]),
        errorKeys = me.errors && Object.keys(me.errors);
      let errors;
      if (errorKeys !== null && errorKeys !== void 0 && errorKeys.length) {
        errors = errorKeys;
      }
      // If custom error message was set using https://developer.mozilla.org/en-US/docs/Web/API/HTMLObjectElement/setCustomValidity
      else if (validity.customError) {
        errors = [me.input.validationMessage];
      }
      // If invalid state found, translate it
      else if (stateName) {
        errors = [me.L(stateName, {
          // In case min/max limits are present they will be used in the translation
          min: me.min,
          max: me.max
        })];
      }
      // If built-in state is 'valid' but me.isValid is false, show our invalid message
      else {
        errors = [me.L(me.invalidValueError)];
      }
      if (((_errors = errors) === null || _errors === void 0 ? void 0 : _errors.length) > 0) {
        return errors;
      }
    }
  }
  //endregion
  createOverflowTwin(overrides) {
    const me = this,
      overflowTwin = super.createOverflowTwin(overrides);
    // Clone's changes must propagate to original.
    overflowTwin.ion({
      change({
        value
      }) {
        me._overflowTwinSync = true;
        me.value = value;
        me._overflowTwinSync = false;
      }
    });
    return overflowTwin;
  }
  //region Container
  get containerCollapsed() {
    var _this$container;
    return (_this$container = this.container) === null || _this$container === void 0 ? void 0 : _this$container.collapsed;
  }
  set containerCollapsed(collapsed) {
    const {
      container
    } = this;
    if (container) {
      container.collapsed = collapsed;
    }
  }
  afterSyncChildConfigs(container) {
    //
  }
  changeContainer(config, existing) {
    if (config && (Array.isArray(config) || !('type' in config || 'items' in config))) {
      // When "container" is an array or an object that has neither type nor items properties, it is the items
      // of the container:
      config = {
        items: config
      };
    }
    const me = this,
      defaults = config && ObjectHelper.merge({
        owner: me,
        layout: 'box'
      }, me.containerDefaults),
      container = Widget.reconfigure(existing, config, {
        owner: me,
        defaults
      });
    if (container) {
      container.autoLayout = (defaults === null || defaults === void 0 ? void 0 : defaults.layout) === 'box';
      if (container === existing) {
        container.syncContainer();
        // just return to retain the config's value but also call onConfigChange (since we handled the change)
        return;
      }
    }
    return container;
  }
  onConfigChange(info) {
    var _this$container2, _this$container2$sync;
    super.onConfigChange(info);
    if ((_this$container2 = this.container) !== null && _this$container2 !== void 0 && (_this$container2$sync = _this$container2.syncConfigTriggers) !== null && _this$container2$sync !== void 0 && _this$container2$sync[info.name]) {
      this.container.syncChildConfigs();
    }
  }
  assignValue(values, options) {
    const me = this,
      {
        container,
        containValues
      } = me,
      valueName = me.getValueName(options),
      storedValue = values && valueName in values;
    if (container && containValues !== false) {
      if (values && containValues === 'nested') {
        if (storedValue) {
          values = ObjectHelper.clone(values[valueName]); // could be null
          super.assignValue({
            // Removing 'value:true' from nested values is a trick done by checkbox (could be done by
            // any toggle-like thing) so just put true back in:
            [valueName]: values && !('value' in values) || values.value
          }, options);
          if (values) {
            delete values.value;
          }
          container.assignValue(values, options);
        }
      } else {
        super.assignValue(values, options);
        container.assignValue(values, options);
      }
    } else {
      super.assignValue(values, options);
    }
  }
  gatherValue(values) {
    super.gatherValue(values);
    this.gatherValues(values);
  }
  gatherValues(values, storedValue) {
    const me = this,
      {
        container,
        containValues,
        valueName
      } = me,
      cvt = typeof containValues;
    storedValue = storedValue ?? valueName in values;
    if (container && containValues !== false) {
      if (containValues === 'nested') {
        if (storedValue) {
          values[valueName] = {
            value: values[valueName],
            ...container.values
          };
        }
      } else if (containValues === true || containValues == null && storedValue || cvt === 'string' && me[containValues] || cvt === 'function' && containValues(me)) {
        container.gatherValues(values);
      }
    }
  }
  updateContainer(container, was) {
    was && this.detachListeners(was.id);
    if (container) {
      if (!container.rendered) {
        container.render();
      }
      container.syncContainer();
      container.syncChildConfigs();
    }
  }
  //endregion
}
/**
 * Config object for a field trigger.
 *
 * @typedef {Object} FieldTriggerConfig
 * @property {String} cls The CSS class to apply.
 * @property {Function|String} handler A method in the field to call upon click.
 * @property {'start'|'end'} [align] Which end of the field the trigger should go.
 * @property {Number} [weight] Higher weighted triggers gravitate towards the input field.
 */
/**
 * Base class for field triggers. May be configured with a `cls` and a `handler` which is a function (or name of a
 * function) in the owning Field.
 * @classtype trigger
 * @extends Core/widget/Widget
 */
Field.Trigger = class FieldTrigger extends Widget {
  static get $name() {
    return 'FieldTrigger';
  }
  static get factoryable() {
    return {
      defaultType: Field.Trigger,
      extends: null
    };
  }
  // Factoryable type name
  static get type() {
    return 'trigger';
  }
  // Align is a simple string at this level
  static get configurable() {
    return {
      align: null,
      weight: null,
      role: undefined
    };
  }
  get field() {
    return this.parent;
  }
  construct() {
    super.construct(...arguments);
    if (this.key) {
      this.keyMap = {
        [this.key]: 'onClick'
      };
    }
  }
  compose() {
    return {
      'aria-hidden': true,
      class: {
        [`b-align-${this.align || 'end'}`]: 1,
        'b-icon': 1
      },
      // eslint-disable-next-line bryntum/no-listeners-in-lib
      listeners: {
        click: 'onClick',
        mousedown: 'onMousedown'
      }
    };
  }
  changeAlign(align) {
    return align; // Widget base class converts to an object
  }

  onClick(e) {
    const me = this,
      {
        field
      } = me;
    if (!(field.disabled || field.readOnly)) {
      // If invoked by a key, don't go ahead with that key's default browser action
      if (e.key) {
        e.preventDefault();
      }
      if (field.trigger('trigger', {
        trigger: me
      }) !== false && me.handler) {
        field.callback(me.handler, field, [e, me]);
      }
    }
  }
  onMousedown(e) {
    const field = this.field,
      isKeyEvent = ('key' in e);
    // If it's a touch tap on the trigger of an editable, then
    // avoid the keyboard by setting the field to not be editable
    // before focusing the field. Reset to be editable after focusing
    // has happened. Keyboard will not appear.
    if (!isKeyEvent && DomHelper.isTouchEvent) {
      if (field.editable) {
        field.editable = false;
        field.setTimeout(() => field.editable = true, 500);
      }
    }
    e.preventDefault();
    if (DomHelper.getActiveElement(field.input) !== field.input) {
      field.focus();
    }
  }
};
Field.SpinTrigger = class SpinTrigger extends Field.Trigger {
  static get $name() {
    return 'SpinTrigger';
  }
  // Factoryable type name
  static get type() {
    return 'spintrigger';
  }
  static get configurable() {
    return {
      repeat: {
        $config: ['nullify'],
        value: true
      }
    };
  }
  compose() {
    return {
      children: {
        upButton: {
          class: {
            'b-icon': 1,
            'b-spin-up': 1
          }
        },
        downButton: {
          class: {
            'b-icon': 1,
            'b-spin-down': 1
          }
        }
      }
    };
  }
  updateRepeat(repeat) {
    var _this$clickRepeater;
    (_this$clickRepeater = this.clickRepeater) === null || _this$clickRepeater === void 0 ? void 0 : _this$clickRepeater.destroy();
    this.clickRepeater = repeat ? ClickRepeater.new({
      element: this.element
    }, repeat) : null;
  }
  onClick(e) {
    const me = this,
      {
        field
      } = me;
    if (!(field.disabled || field.readOnly)) {
      if (e.target === me.upButton) {
        field.doSpinUp(e.shiftKey);
      } else if (e.target === me.downButton) {
        field.doSpinDown(e.shiftKey);
      }
    }
  }
};
// Register trigger widgets type with their Factory
Field.Trigger.initClass();
Field.SpinTrigger.initClass();
Widget.register(Field.Trigger, 'trigger');
Widget.register(Field.SpinTrigger, 'spintrigger');
Field._$name = 'Field';

/**
 * @module Core/widget/TextField
 */
/**
 * Textfield widget. Wraps native &lt;input type="text"&gt;
 *
 * This field can be used as an {@link Grid.column.Column#config-editor editor} for the {@link Grid.column.Column Column}.
 * It is used as the default editor for the {@link Grid.column.Column Column}, {@link Grid.column.TemplateColumn TemplateColumn},
 * {@link Grid.column.TreeColumn TreeColumn}, and for other columns if another editor is not specified explicitly,
 * or disabled by setting `false` value.
 *
 * @extends Core/widget/Field
 *
 * @example
 * let textField = new TextField({
 *   placeholder: 'Enter some text'
 * });
 *
 * @classType textfield
 * @inlineexample Core/widget/TextField.js
 * @inputfield
 */
class TextField extends Field {
  // Factoryable type name
  static get type() {
    return 'textfield';
  }
  // Factoryable type alias
  static get alias() {
    return 'text';
  }
  static get configurable() {
    return {
      /**
       * The tab index of the input field
       * @config {Number} tabIndex
       * @category Input element
       */
      /**
       * The min number of characters for the input field
       * @config {Number} minLength
       * @category Field
       */
      /**
       * The max number of characters for the input field
       * @config {Number} maxLength
       * @category Field
       */
      nullValue: ''
    };
  }
  static get $name() {
    return 'TextField';
  }
  construct(config) {
    if ((config === null || config === void 0 ? void 0 : config.inputType) === 'hidden') {
      config.hidden = true;
    }
    super.construct(...arguments);
  }
}
// Register this widget type with its Factory
TextField.initClass();
TextField._$name = 'TextField';

/**
 * @module Core/widget/PickerField
 */
/**
 * Base class used for {@link Core.widget.Combo Combo}, {@link Core.widget.DateField DateField}, and {@link Core.widget.TimeField TimeField}.
 * Displays a picker ({@link Core.widget.List List}, {@link Core.widget.DatePicker DatePicker}) anchored to the field.
 * Not intended to be used directly.
 *
 * This field's subclasses can be used as editors for the {@link Grid.column.Column Column}.
 *
 * When focused by means of *touch* tapping on the trigger element (eg, the down arrow on a Combo)
 * on a tablet, the keyboard will not be shown by default to allow for interaction with the dropdown.
 *
 * A second tap on the input area will then show the keyboard if required.
 *
 * @extends Core/widget/TextField
 * @abstract
 */
class PickerField extends TextField {
  //region Config
  static get $name() {
    return 'PickerField';
  }
  // Factoryable type name
  static get type() {
    return 'pickerfield';
  }
  static get configurable() {
    return {
      /**
       * User can edit text in text field (otherwise only pick from attached picker)
       * @config {Boolean}
       * @default
       */
      editable: true,
      /**
       * The name of the element property to which the picker should size and align itself.
       * @config {String}
       * @default element
       */
      pickerAlignElement: 'inputWrap',
      // Does not get set, but prevents PickerFields inheriting value:'' from Field.
      value: null,
      triggers: {
        expand: {
          cls: 'bars'
        }
      },
      /**
       * By default PickerField's picker is transient, and will {@link #function-hidePicker} when the user clicks or
       * taps outside or when focus moves outside picker.
       *
       * Configure as `false` to make picker non-transient.
       * @config {Boolean}
       * @default
       */
      autoClose: true,
      /**
       * Configure as `true` to have the picker expand upon focus enter.
       * @config {Boolean}
       */
      autoExpand: null,
      /**
       * Returns the instantiated picker widget as configured by {@link #config-picker}.
       * @readonly
       * @member {Core.widget.Widget} picker
       */
      /**
       * A config object which is merged into the generated picker configuration to allow specific use cases
       * to override behaviour. For example:
       *
       *     picker: {
       *         align: {
       *             anchor: true
       *         }
       *     }
       *
       * @config {Object}
       */
      picker: {
        value: {
          floating: true
        },
        $config: ['lazy', 'nullify']
      },
      inputType: 'text',
      // We need to realign the picker if we resize (eg a multiSelect Combo's ChipView wrapping)
      monitorResize: true,
      nullValue: null
    };
  }
  //endregion
  //region Init & destroy
  doDestroy() {
    var _this$globalTapListen;
    // Remove touch keyboard showing listener if we added it
    (_this$globalTapListen = this.globalTapListener) === null || _this$globalTapListen === void 0 ? void 0 : _this$globalTapListen.call(this);
    super.doDestroy();
  }
  changeEditable(editable) {
    // If we are on a mobile device, the better UX is to use the picker over typing.
    // If typing is really required editable can be configured as true
    if (BrowserHelper.isMobile && this.initialConfig.editable !== true) {
      editable = false;
    }
    return editable;
  }
  updateEditable(editable) {
    const me = this,
      {
        element,
        ariaElement,
        nonEditableClickTarget
      } = me,
      {
        expand
      } = me.triggers,
      narrow = globalThis.matchMedia('(max-width: 410px)').matches;
    super.updateEditable(...arguments);
    element.classList.toggle('b-not-editable', !editable);
    if (editable === false) {
      var _me$globalTapListener;
      // To save space, on small mobile devices, when not editable, we hide the expand trigger
      if (BrowserHelper.isMobile && narrow) {
        expand === null || expand === void 0 ? void 0 : expand.hide();
      }
      ariaElement.removeAttribute('aria-autocomplete');
      (_me$globalTapListener = me.globalTapListener) === null || _me$globalTapListener === void 0 ? void 0 : _me$globalTapListener.call(me);
      EventHelper.on({
        element: nonEditableClickTarget,
        click: e => {
          // If clicking directly on the input (or chip view in case of non-editable Combo), show the picker
          // As label triggers click on its related input, we need to check that we actually clicked the input
          const target = nonEditableClickTarget.getRootNode().elementFromPoint(e.clientX, e.clientY);
          if (e.target === nonEditableClickTarget && target === nonEditableClickTarget) {
            me.onTriggerClick(e);
          }
        },
        thisObj: me
      });
    } else {
      expand === null || expand === void 0 ? void 0 : expand.show();
      ariaElement.setAttribute('aria-autocomplete', 'list');
      // In case the field was temporarily set to readOnly="true" to prevent
      // the intrusive keyboard (This happens when tapping the trigger
      // and when focused by the container in response to a touch tap),
      // allow a subsequent touch tap to show the keyboard.
      me.globalTapListener = GlobalEvents.ion({
        globaltap: 'showKeyboard',
        thisObj: me
      });
    }
  }
  get nonEditableClickTarget() {
    return this.input;
  }
  updateElement(element, oldElement) {
    var _this$constructor$res;
    const result = super.updateElement(element, oldElement),
      picker = this.peekConfig('picker'),
      role = picker ? picker.isWidget ? picker.role : (_this$constructor$res = this.constructor.resolveType(picker.type)) === null || _this$constructor$res === void 0 ? void 0 : _this$constructor$res.$meta.config.role : false;
    this.ariaHasPopup = role;
    return result;
  }
  //endregion
  //region Picker
  changePicker(picker, oldPicker) {
    throw new Error('changePicker(oldPicker, newPicker) must be implemented in PickerField subclass implementations');
  }
  /**
   * Iterate over all widgets owned by this widget and any descendants.
   *
   * *Note*: Due to this method aborting when the function returns `false`, beware of using short form arrow
   * functions. If the expression executed evaluates to `false`, iteration will terminate.
   *
   * _Due to the {@link #config-picker} config being a lazy config and only being converted to be a
   * `List` instance just before it's shown, the picker will not be part of the iteration before
   * it has been shown once_.
   * @function eachWidget
   * @param {Function} fn A function to execute upon all descendant widgets.
   * Iteration terminates if this function returns `false`.
   * @param {Boolean} [deep=true] Pass as `false` to only consider immediate child widgets.
   * @returns {Boolean} Returns `true` if iteration was not aborted by a step returning `false`
   */
  get childItems() {
    const result = super.childItems;
    if (this._picker) {
      result.push(this.picker);
    }
    return result;
  }
  //endregion
  //region Events
  /**
   * Check if field value is valid
   * @internal
   */
  onEditComplete() {
    super.onEditComplete();
    this.autoClosePicker();
  }
  onElementResize(resizedElement) {
    const me = this;
    // If the field changes size while the picker is visible, the picker
    // must be kept in alignment. For example a multiSelect: true
    // ComboBox with a wrapped ChipView.
    if (me.pickerVisible) {
      // Push realignment out to the next AF, because this picker itself may move in
      // response to the element resize, and the picker must realign *after* that happens.
      // For example a multiSelect: true ComboBox with a wrapped ChipView inside
      // a Popup that is aligned *above* an element. When the ChipView gains or
      // loses height, the Popup must realign first, and then the List must align to the
      // new position of the ComboBox.
      me.picker.requestAnimationFrame(me.picker.realign, null, me.picker);
    }
    super.onElementResize(resizedElement);
  }
  /**
   * Allows using arrow keys to open/close list. Relays other keypresses to list if open.
   * @private
   */
  internalOnKeyEvent(event) {
    const me = this;
    let callSuper = true;
    if (event.type === 'keydown' && !me.disabled && !event.shiftKey && !event.ctrlKey) {
      if (me.pickerVisible) {
        const {
          picker
        } = me;
        if (event.key === 'Escape') {
          event.preventDefault();
          event.stopImmediatePropagation();
          me.hidePicker();
          // EC has multiple effects. First stage is hide the picker.
          // If we do this, then the superclass's ESC handling must
          // not be called.
          callSuper = false;
        } else if (picker.onInternalKeyDown) {
          // if picker is visible, give it a shot at the event
          picker.onInternalKeyDown(event);
        } else if (event.key === 'ArrowDown') {
          if (picker.focusable) {
            picker.focus();
          }
        }
      } else if (event.key === 'ArrowDown') {
        // navigator should not react to initial DOWN keypress that triggers the List to show
        event.stopImmediatePropagation();
        // If we not prevent default handler page might scroll. Siesta cannot reproduce this behavior, have to
        // leave it untested.
        // https://github.com/bryntum/support/issues/885
        event.preventDefault();
        me.onTriggerClick(event);
      }
    }
    if (callSuper) {
      super.internalOnKeyEvent(event);
    }
  }
  onFocusIn(e) {
    const me = this;
    super.onFocusIn(e);
    if (me.autoExpand) {
      // If expand is configured for focus, minChars should be zero.
      me.minChars = 0;
      me.onTriggerClick(e);
      // We should not react twice when the trigger click was the focusin origin
      me.ignoreTriggerClick = true;
      me.setTimeout(() => me.ignoreTriggerClick = false, 100);
    }
  }
  /**
   * User clicked trigger icon, toggle list.
   * @private
   */
  onTriggerClick(event) {
    if (!this.disabled) {
      // Pass focus flag as true if invoked by a key event
      this.togglePicker('key' in event);
    }
  }
  /**
   * User clicked on an editable input field. If it's a touch event
   * ensure that the keyboard is shown.
   * @private
   */
  showKeyboard({
    event
  }) {
    const input = this.input;
    if (DomHelper.isTouchEvent && DomHelper.getActiveElement(input) === input && event.target === input) {
      GlobalEvents.suspendFocusEvents();
      input.blur();
      input.focus();
      GlobalEvents.resumeFocusEvents();
    }
  }
  //endregion
  //region Toggle picker
  /**
   * Toggle the {@link #property-picker} visibility
   * @privateparam {Boolean} [focus] Pass `true` to focus the picker when it gets shown.
   */
  togglePicker(focus) {
    if (this.pickerVisible) {
      this.hidePicker();
    } else {
      this.showPicker(focus);
    }
  }
  /**
   * Show the {@link #property-picker}
   * @privateparam {Boolean} [focus] Pass `true` to focus the picker when it gets shown.
   */
  showPicker(focus) {
    const me = this,
      {
        picker
      } = me;
    if (!me.pickerHideShowListenersAdded) {
      picker.ion({
        show: 'onPickerShow',
        hide: 'onPickerHide',
        thisObj: me
      });
      me.pickerHideShowListenersAdded = true;
    }
    DomHelper.setAttributes(me.ariaElement, {
      'aria-controls': picker.id,
      'aria-expanded': true
    });
    picker.autoClose = me.autoClose;
    picker.show();
    // Not been vetoed
    if (picker.isVisible) {
      if (focus) {
        me.focusPicker();
      }
    }
  }
  onPickerShow() {
    const me = this;
    me.pickerVisible = true;
    me.element.classList.add('b-open');
    me.trigger('togglePicker', {
      show: true
    });
    me.pickerTapOutRemover = GlobalEvents.ion({
      globaltap: 'onPickerTapOut',
      thisObj: me
    });
    me.pickerKeyDownRemover = EventHelper.on({
      element: me.picker.element,
      keydown: 'onPickerKeyDown',
      thisObj: me
    });
  }
  onPickerHide() {
    var _me$pickerTapOutRemov, _me$pickerKeyDownRemo;
    const me = this;
    me.ariaElement.setAttribute('aria-expanded', false);
    me.pickerVisible = false;
    me.element.classList.remove('b-open');
    me.trigger('togglePicker', {
      show: false
    });
    (_me$pickerTapOutRemov = me.pickerTapOutRemover) === null || _me$pickerTapOutRemov === void 0 ? void 0 : _me$pickerTapOutRemov.call(me);
    (_me$pickerKeyDownRemo = me.pickerKeyDownRemover) === null || _me$pickerKeyDownRemo === void 0 ? void 0 : _me$pickerKeyDownRemo.call(me);
  }
  onPickerTapOut({
    event
  }) {
    if (!this.containsFocus && !this.owns(event.target)) {
      this.autoClosePicker();
    }
  }
  onPickerKeyDown(event) {
    if (event.key === 'Tab' && !this.picker.trapFocus) {
      const activeEl = DomHelper.getActiveElement(this.input),
        forwardedEvent = new KeyboardEvent('keydown', event);
      // Offer our own element a shot at the TAB event.
      // Some widgets or plugins may actively navigate.
      this.input.dispatchEvent(forwardedEvent);
      // Somebody might preventDefault on the synthesized event. We must honour that.
      // For example if we are the field for a cell Editor, and it started an edit on the adjacent cell.
      if (forwardedEvent.defaultPrevented) {
        event.preventDefault();
      }
      // No listener intervened, point the TAB event at the input,
      // and user agent default navigation will proceed.
      if (DomHelper.getActiveElement(this.input) === activeEl) {
        this.input.focus();
      }
      // Some listener *did* navigate, prevent user agent default.
      else {
        event.preventDefault();
      }
      // If listeners have not destroyed us, close our picker.
      if (!this.isDestroyed) {
        this.hidePicker();
      }
    }
  }
  //endregion
  //region Visibility
  autoClosePicker() {
    if (this.autoClose) {
      this.hidePicker();
    }
  }
  /**
   * Hide picker
   */
  hidePicker() {
    if (this.pickerVisible) {
      this.picker.hide();
    }
  }
  focusPicker() {}
  focus() {
    const input = this.input;
    // If we are focusing an editable PickerField from a touch event, temporarily
    // set it to readOnly to prevent the showing of the intrusive keyboard.
    // It's more likely that a user on a touch device will interact with the picker
    // rather than the input field.
    // A second touch tap on an already focused input will show the keyboard;
    // see the showKeyboard method.
    if (DomHelper.isTouchEvent && this.editable) {
      input.readOnly = true;
      this.setTimeout(() => input.readOnly = false, 500);
    }
    super.focus();
  }
  //endregion
}

PickerField._$name = 'PickerField';

/**
 * @module Core/widget/List
 */
const itemRange = document.createRange();
/**
 * Displays a list of items which the user can navigate using the keyboard and select using either pointer gestures or the keyboard.
 * @extends Core/widget/Widget
 *
 * @classType list
 * @inlineexample Core/widget/List.js
 * @widget
 */
class List extends Widget {
  //region Config
  static get $name() {
    return 'List';
  }
  // Factoryable type name
  static get type() {
    return 'list';
  }
  static get configurable() {
    return {
      itemCls: 'b-list-item',
      selectedCls: 'b-selected',
      selectIconCls: 'b-icon-check',
      tag: 'ul',
      /**
       * An array of Objects which are converted into records and used to create this
       * List's {@link #config-store}
       * @config {Object[]}
       */
      items: null,
      /**
       * The model field to render into each list item
       * @config {String}
       * @default
       */
      displayField: 'text',
      /**
       * A {@link Core.data.Store} which provides the records which map to List items. Each record is passed through the
       * {@link #config-itemTpl} to produce the DOM structure of the List. May be generated from an array of {@link #config-items}.
       *
       * The store may also be configured as an array of records, or record data objects from which records may be constructed.
       * @config {Object|Object[]|Core.data.Store}
       */
      store: null,
      navigator: true,
      scrollable: {
        overflowX: false,
        overflowY: true
      },
      itemsFocusable: true,
      /**
       * Configure as `true` to allow multi select and add checkboxes to the items
       * @config {Boolean}
       * @default
       */
      multiSelect: false,
      /**
       * Select/deselect all if `CMD`/`CTRL` is pressed when clicking
       * @config {Boolean}
       * @default false
       */
      toggleAllIfCtrlPressed: false,
      /**
       * Set to `true` to add a "Select all" item to the list to select/unselect all items at once.
       * Only applies when {@link #config-multiSelect} mode is enabled.
       * @config {Boolean|String}
       * @default false
       */
      selectAllItem: false,
      /**
       * Template function which, when passed a record, returns the textual HTML for that item. Defaults to a
       * function returning the value of the records {@link #config-displayField}
       * @config {Function} itemTpl
       * @param {Core.data.Model} record The record
       */
      itemTpl(record) {
        let text = StringHelper.encodeHtml(record.getValue(this.displayField));
        if (text == null || text === '') {
          // Make sure we have some content to fill the item element and have equal height for all items
          text = '&nbsp;';
        }
        return text;
      },
      /**
       * Configure this as a function or the name of a function, which when passed a record in the
       * list, returns a style string to apply to its list item.
       * @config {Function|String} getItemStyle
       * @param {Core.data.Model} record The record
       */
      getItemStyle: null,
      /**
       * Configure this as a function or the name of a function, which when passed a record in the
       * list, returns a CSS class name string to apply to its list item.
       * @config {Function|String} getItemCls
       * @param {Core.data.Model} record The record
       */
      getItemCls: null,
      /**
       * Template function which is passed a group record and the uppercased group field name. The text returned
       * will be rendered as the group header.
       * @config {Function} groupHeaderTpl
       * @param {Core.data.Model} record The record
       * @param {String} groupName The current group name
       */
      groupHeaderTpl(record, groupName) {
        let name = StringHelper.encodeHtml(groupName);
        if (name == null || name === '') {
          // Make sure we have some content to fill the item element and have equal height for all items
          name = '&nbsp;';
        }
        return `${this.allowGroupSelect ? this.itemIconTpl(record) : ''}${name}`;
      },
      /**
       * Configure as `true` to allow selecting groups (all the group child records will be toggled). Only
       * applicable when the store is grouped.
       * @config {Boolean}
       * @default
       */
      allowGroupSelect: true,
      /**
       * A {@link Core.util.Collection}, or Collection config object to use to contain this List's selected
       * records.
       *
       * Or, an array encapsulating the initial selection which this List is to have upon Store load. This may be
       * an array of `id`s , or an array of objects with an `id` property:
       *
       * ```javascript
       * new List({
       *     // initially select record IDs 1 and 5 when store loads
       *     selected : [1, 5]
       * });
       * ```
       * @config {Object[]|Number[]|String[]|Core.util.Collection|CollectionConfig}
       */
      selected: {
        $config: 'nullify',
        value: {}
      },
      /**
       * Configure as `true` to activate items on mouseover. This is used by the Combo
       * field when using a List as its dropdown.
       * @config {Boolean}
       */
      activateOnMouseover: null,
      role: 'listbox',
      keyMap: {
        'Ctrl+a': 'selectAll'
      }
    };
  }
  //endregion
  //region Events
  /**
   * User activated an item in the list either by pointer or keyboard.
   * The active record, list item index, and the triggering event are passed.
   * @event item
   * @param {Core.data.Model} record Activated record
   * @param {Number} index List item index
   * @param {Event} event Triggering event
   */
  /**
   * User going to activate an item in the list either by pointer or keyboard.
   * The active record, list item index, and the triggering event are passed.
   * It is preventable by returning `false`
   * @event beforeItem
   * @preventable
   * @param {Core.data.Model} record Activated record
   * @param {Number} args List item index
   * @param {Event} event Triggering event
   */
  //endregion
  construct(config, ...args) {
    var _me$store;
    const me = this;
    // We can be created from a raw array. It becomes our items which we translate to a Store.
    if (Array.isArray(config)) {
      config = {
        items: config
      };
    }
    super.construct(config, ...args);
    const {
        element
      } = me,
      {
        classList
      } = element;
    if (me.multiSelect) {
      classList.add('b-multiselect');
    }
    if ((_me$store = me.store) !== null && _me$store !== void 0 && _me$store.count) {
      me.refresh();
    } else {
      classList.add('b-empty');
    }
    EventHelper.on({
      element,
      delegate: me.itemSelector,
      mouseover: 'onMouseOver',
      click: 'onClick',
      thisObj: me
    });
  }
  doDestroy() {
    var _this$navigator;
    this.detachListeners('store');
    (_this$navigator = this.navigator) === null || _this$navigator === void 0 ? void 0 : _this$navigator.destroy();
    super.doDestroy();
  }
  onFocusIn(e) {
    var _e$_target;
    this.restoreActiveItem((_e$_target = e._target) === null || _e$_target === void 0 ? void 0 : _e$_target.closest(this.itemSelector));
    super.onFocusIn(e);
  }
  contentTpl() {
    const me = this,
      allRecordsTpl = me.store.records.map((record, i) => me.itemWrapperTpl(record, i));
    if (me.multiSelect && me.selectAllItem !== false) {
      allRecordsTpl.unshift(me.selectAllItemTpl());
    }
    return TemplateHelper.tpl`${allRecordsTpl}`;
  }
  itemWrapperTpl(record, i) {
    const {
        selected,
        getItemStyle
      } = this,
      style = getItemStyle ? `style="${this.callback(getItemStyle, this, [record])}"` : '';
    return TemplateHelper.tpl`<li ${style} class="${this.getItemClasses(record, i)}" role="option" aria-selected="${selected.includes(record)}" data-index="${i}" data-id="${StringHelper.encodeHtml(record.id)}" ${this.itemsFocusable ? 'tabindex="-1"' : ''}>${this.itemContentTpl(record, i)}</li>`;
  }
  itemContentTpl(record, i) {
    if ('groupRowFor' in record.meta) {
      return this.groupHeaderTpl(record, StringHelper.capitalize(record.groupChildren[0][record.meta.groupField]));
    }
    return `${this.itemIconTpl(record, i)}${this.itemTpl(record, i)}`;
  }
  itemIconTpl(record, i) {
    return this.multiSelect ? `<i class="b-selected-icon b-icon ${this.selectIconCls}"></i>` : '';
  }
  selectAllItemTpl() {
    const selectedCls = this.allSelected ? 'b-selected' : '';
    return `<li class="${this.itemCls} b-select-all-item ${selectedCls}" data-noselect data-select-all data-id="select-all">${this.itemIconTpl({})}<div>${this.L('selectAll')}</div></li>`;
  }
  getItemClasses(record) {
    var _me$_navigator;
    const me = this,
      {
        getItemCls
      } = me,
      activeItem = (_me$_navigator = me._navigator) === null || _me$_navigator === void 0 ? void 0 : _me$_navigator.activeItem,
      isActive = (activeItem === null || activeItem === void 0 ? void 0 : activeItem.dataset.id) == record.id,
      groupHeaderCls = 'groupRowFor' in record.meta ? 'b-list-item-group-header' : '',
      isSelected = me.selected.includes(record) || record.isSpecialRow && record.groupChildren.every(r => me.selected.includes(r)),
      itemCls = getItemCls ? this.callback(getItemCls, this, [record]) : '';
    return `${me.itemCls} ${record.cls || ''} ${itemCls} ${isSelected ? me.selectedCls : ''} ${isActive ? me.navigator.focusCls : ''} ${groupHeaderCls}`;
  }
  onBeforeStoreLoad() {
    this.mask(this.L('L{loading}'));
  }
  onAfterStoreRequest() {
    this.unmask();
  }
  onStoreChange({
    source: store,
    action,
    records,
    record,
    changes
  }) {
    const me = this,
      {
        selected
      } = me;
    switch (action) {
      // We must keep the selected Collection in sync with the new dataset.
      // Some selected items may not be part of the new dataset.
      // If some items with the same id *are* in the new dataset, the
      // selected Collection must hold the new instance.
      case 'dataset':
        {
          selected.match(store.storage, !me._externallyOwnedSelection);
          break;
        }
      case 'remove':
        selected.remove(records);
        break;
      case 'clear':
        me.deselectAll();
        break;
      case 'update':
        {
          const {
            id
          } = changes;
          // update elements data-id when changing id, to allow refreshItem to find correct element
          if (id) {
            DomHelper.setAttributes(me.contentElement.querySelector(StringHelper.encodeAttributeSelector(`data-id`, id.oldValue)), {
              'data-id': id.value
            });
          }
          me.refreshItem(record);
          return;
        }
    }
    me.refresh();
  }
  onStoreRefresh() {
    this.refresh();
  }
  refresh() {
    const me = this;
    if (me.isVisible) {
      var _me$navigator;
      const activeItem = (_me$navigator = me.navigator) === null || _me$navigator === void 0 ? void 0 : _me$navigator.activeItem;
      // Ensure that the next call to refresh when not visible queues a refresh
      me.paintListener = null;
      // IMPORTANT! DO NOT INLINE!
      // This is a fix for issue: https://github.com/bryntum/support/issues/2171
      // Long story short: DomHelper returns document-fragment and first time we insert node, nothing is actually
      // inserted if (and only) fragment is not stored as a variable.
      const node = DomHelper.createElementFromTemplate(me.contentTpl(), {
        fragment: true
      });
      me.clearItems().insertNode(node);
      // The item elements will be all new, so restore the active item.
      // Navigator will reacquire it by its id.
      if (activeItem) {
        me.restoreActiveItem(activeItem);
      }
      me.refreshCount = (me.refreshCount || 0) + 1;
      me.element.classList[me.store.count > 0 ? 'remove' : 'add']('b-empty');
      me.updateSelectAllState();
    }
    // Only queue a refresh if not already queued
    else if (!me.paintListener) {
      me.paintListener = me.ion({
        paint: 'refresh',
        thisObj: me,
        once: true
      });
    }
  }
  clearItems() {
    const me = this,
      firstItem = me.contentElement.querySelector(me.itemSelector),
      lastChild = me.contentElement.lastChild;
    if (firstItem) {
      // Can't use :last-of-type when other elements of same type may be present.
      // Have to pluck the last element of the NodeList.
      const items = me.contentElement.querySelectorAll(`${me.itemSelector}:not(.b-mask)`);
      itemRange.setStartBefore(firstItem);
      itemRange.setEndAfter(items[items.length - 1]);
      itemRange.deleteContents();
    } else {
      // Allow a static set of elements to be at the top of the list
      if (lastChild) {
        itemRange.setStartAfter(lastChild);
        itemRange.setEndAfter(lastChild);
      } else {
        itemRange.setStart(me.contentElement, 0);
        itemRange.setEnd(me.contentElement, 0);
      }
    }
    return itemRange;
  }
  refreshItem(...records) {
    for (const record of records) {
      const item = this.getItem(record);
      // Maybe a record which is filtered out announces a change.
      // There will be no item.
      if (item) {
        const index = this.store.indexOf(record),
          newItem = DomHelper.createElementFromTemplate(this.itemWrapperTpl(record, index));
        DomHelper.sync(newItem, item);
      }
    }
  }
  getItem(recordOrId) {
    // Cannot use truthiness test because index zero may be passed.
    if (recordOrId != null) {
      var _recordOrId;
      if (typeof recordOrId === 'number') {
        // -ve index means indexing from beyond the end.
        // So -1 gets the last item, -2 the penultimate etc
        return this.contentElement.querySelector(`[data-index="${recordOrId < 0 ? this.store.count + recordOrId : recordOrId}"]`);
      } else if (recordOrId.nodeType === Element.ELEMENT_NODE) {
        recordOrId = recordOrId.dataset.id;
      }
      if (((_recordOrId = recordOrId) === null || _recordOrId === void 0 ? void 0 : _recordOrId.id) != null) {
        recordOrId = recordOrId.id;
      }
      return this.contentElement.querySelector(StringHelper.encodeAttributeSelector(`data-id`, recordOrId));
    }
  }
  /**
   * Searches up from the specified element for a list item and returns the associated record.
   * @param {HTMLElement} element Element somewhere within a list item element
   * @returns {Core.data.Model} Record for the item
   */
  getRecordFromElement(element) {
    if (element.target) {
      element = element.target;
    }
    element = element.closest(this.itemSelector);
    return this.store.getAt(parseInt(element.dataset.index));
  }
  //region getters/setters
  /**
   * May be *set* as an array of Objects which are converted into records and used to create this
   * List's {@link #config-store}
   * @member {Object[]} items
   */
  updateItems(items) {
    const me = this;
    if (me.store && me.store.autoCreated) {
      me.store.destroy();
    }
    me.store = Store.getStore(items);
  }
  updateDisabled(disabled) {
    super.updateDisabled(...arguments);
    this.navigator && (this.navigator.disabled = disabled);
  }
  changeSelected(selected, oldSelected) {
    if (selected) {
      let initialSelection;
      // We convert incoming selected block to a Collection.
      // We may be configured with an initial selection array
      if (selected.isCollection) {
        this._externallyOwnedSelection = true;
      } else {
        if (Array.isArray(selected)) {
          initialSelection = selected;
          selected = {};
        } else if (selected.values) {
          initialSelection = selected.values;
          selected = {
            ...selected,
            values: []
          };
        }
        selected = new Collection(selected);
      }
      selected.ion({
        change: 'onSelectionChange',
        thisObj: this
      });
      // We will inject any configured initial selection array only after
      // the store has been loaded. Set the property even if it's zero length
      // because it acts as a flag that an initial selection was requested.
      this.initialSelection = initialSelection;
    } else {
      oldSelected === null || oldSelected === void 0 ? void 0 : oldSelected.destroy();
    }
    return selected;
  }
  get itemSelector() {
    return `.${this.itemCls}`;
  }
  /**
   * Get the collection of selected records
   * @property {Core.util.Collection}
   * @readonly
   */
  get selected() {
    return this._selected;
  }
  /**
   * Get the backing store, a {@link Core.data.Store} holding the records used to generate list items
   * @property {Core.data.Store}
   * @readonly
   */
  get store() {
    // Ensure any configured items is processed into a store before we try to return it.
    this.getConfig('items');
    return this._store;
  }
  changeStore(store) {
    const me = this;
    if (!(store instanceof Store)) {
      if (Array.isArray(store)) {
        store = {
          data: store
        };
      }
      store = new Store(store);
    }
    me.detachListeners('store');
    if (store) {
      const storeListeners = {
        name: 'store',
        change: 'onStoreChange',
        refresh: 'onStoreRefresh',
        thisObj: me
      };
      if (store.readUrl) {
        storeListeners.beforeLoad = 'onBeforeStoreLoad';
        storeListeners.afterRequest = 'onAfterStoreRequest';
      }
      if (store.isGrouped) {
        me.element.classList.add('b-grouped');
        storeListeners.groupchange = 'onStoreRefresh';
      }
      store.ion(storeListeners);
    }
    return store;
  }
  updateStore(store) {
    const {
      initialSelection
    } = this;
    // If our selected config contained an initial selection array,
    // apply it when the store is loaded.
    if (Array.isArray(initialSelection)) {
      if (store.count) {
        this.select(initialSelection);
        // We must process the fact that the selection is empty.
        // There will have been no event from the Collection if nothing was selected.
        // Note: The initialSelection array may have invalid ids in which could
        // not be selected, so a check of the actual Collection count is necessary.
        if (!this.selected.count) {
          this.onSelectionChange({
            action: 'clear',
            removed: []
          });
        }
      } else {
        store.ion({
          refresh: () => this.select(initialSelection),
          once: true
        });
      }
    }
    this.refresh();
  }
  changeNavigator(navigator, oldNavigator) {
    const me = this,
      {
        element
      } = me;
    if (element) {
      var _navigator;
      navigator = Navigator.reconfigure(oldNavigator, navigator ? Navigator.mergeConfigs({
        ownerCmp: me,
        disabled: me.disabled,
        target: element,
        keyEventTarget: element
      }, navigator) : null, me);
      // This widget is responsible for relaying keyboard events into the navigator
      // So it must be able to receive focus if its items do not receive focus.
      if (((_navigator = navigator) === null || _navigator === void 0 ? void 0 : _navigator.keyEventTarget) === element && !me.itemsTabbable) {
        element.tabIndex = 0;
      }
    }
    return navigator;
  }
  get minAlignHeight() {
    const lastItem = this.element.lastElementChild,
      minHeight = this.minHeight;
    // No minHeight specified, always defer to the items height
    if (minHeight != null) {
      return lastItem ? Math.min(lastItem.offsetTop + lastItem.offsetHeight, minHeight) : 0;
    }
  }
  //endregion
  //region Hide/Show
  alignTo(...args) {
    // When aligning, if the items total height is less than minHeight, use that.
    super.minHeight = this.minAlignHeight;
    super.alignTo(...args);
  }
  hide(...args) {
    this.navigator && (this.navigator.activeItem = null);
    return super.hide(...args);
  }
  show() {
    const {
        refreshCount
      } = this,
      {
        previousActiveItem
      } = this.navigator;
    // Restore the configured minHeight
    super.minHeight = this._minHeight;
    const retVal = super.show(...arguments);
    // If no refresh on paint took place, we need to restore the activeItem.
    // Refresh does that itself.
    if (this.refreshCount === refreshCount) {
      this.restoreActiveItem(previousActiveItem, true);
    }
    return retVal;
  }
  /**
   * Sets the passed record as the current focused record for keyboard navigation and selection purposes.
   * @param {Core.data.Model} activeItem The item to highlight as the active ("focused") item.
   * @param {String|Boolean} [block='nearest'] The block scroll specification to scroll
   * the item into view. Defaults to `'nearest'` which means a minimal scroll, only if
   * the item is actually out of view. Passing `true` is for when the List is aligned
   * to a picker and the selected item should be scrolled to be close to the picker,
   * however that is aligned. See `Combo.showPicker` for usage.
   * @internal
   */
  restoreActiveItem(activeItem = this.navigator.previousActiveItem, block = 'nearest') {
    const me = this,
      {
        navigator,
        lastAlignSpec
      } = me;
    // Zero may be passed to select first item, so cannot use truthiness.
    // This won't mean *clear* the active item if any. Falsy means
    // nothing to restore so leave it as is.
    if (activeItem != null) {
      if (typeof block !== 'string') {
        const alignZone = lastAlignSpec ? lastAlignSpec.zone : 1;
        // Scroll item into view appropriately, meaning closest to any align target.
        // Align zones are T,R,B,L => 0,1,2,3
        // If 1 or 3 (right or left), align nearest.
        // if 0 (above) align end.
        // else, we're below so align start.
        block = alignZone & 1 ? 'nearest' : alignZone ? 'start' : 'end';
      }
      activeItem = me.getItem(activeItem);
      if (activeItem && !me.disabled) {
        // If we are aligned to a target, first, scroll the required item to the optimal
        // position to avoid Navigator's default minimal scroll to block: 'nearest'.
        // If we are aligned below a combo, move the point of interest to the top.
        // If we are aligned above a combo, move the point of interest to the bottom.
        me.scrollable.scrollIntoView(activeItem, {
          block
        });
        navigator.activeItem = activeItem;
      }
    }
  }
  //endregion
  //region Events
  /**
   * Focuses list items on hover.
   * @private
   */
  onMouseOver(event) {
    const me = this,
      itemElement = event.currentTarget;
    // Activate soon in case they're moving fast over items.
    if (!DomHelper.isTouchEvent && itemElement && me.navigator && me.activateOnMouseover) {
      me.setTimeout({
        fn: 'handleMouseOver',
        delay: 30,
        args: [itemElement],
        cancelOutstanding: true
      });
    }
  }
  handleMouseOver(itemElement) {
    this.navigator.activeItem = itemElement;
  }
  /**
   * Selects list items on click.
   * @private
   */
  onClick(event) {
    const itemElement = event.target.closest(this.itemSelector);
    if (itemElement) {
      this.onItemClick(itemElement, event);
    }
  }
  /**
   * Key events which are not navigation are delegated up to here by the Navigator
   * @private
   */
  onInternalKeyDown(event) {
    const me = this,
      active = me.navigator.activeItem;
    if (me.disabled) {
      return;
    }
    switch (event.key) {
      case ' ':
        // If it's an input field that's providing events, allow it to process space.
        // Otherwise, it falls through and is processed the same as ENTER to make a click.
        if (event.target.nodeName.toUpperCase() === 'INPUT' && !event.target.readOnly) {
          break;
        }
      case 'Enter':
        // eslint-disable-line
        if (active) {
          this.onItemClick(active, event);
          // Stop the keydown from bubbling.
          // And stop it from creating a keypress event.
          // No further action should be taken after item selection.
          event.stopImmediatePropagation();
          event.preventDefault();
        }
    }
  }
  //endregion
  onItemClick(item, event) {
    const me = this,
      {
        allowGroupSelect
      } = me,
      index = parseInt(item.dataset.index),
      record = me.store.getAt(index),
      isSpecialRow = record === null || record === void 0 ? void 0 : record.isSpecialRow;
    if (me.disabled || me.trigger('beforeItem', {
      item,
      record,
      index,
      event,
      userAction: true
    }) === false) {
      return;
    }
    me._isUserAction = true;
    // It's the selectAll item
    if (item.contains(event.target.closest('[data-select-all]'))) {
      me.onSelectAllClick(item, event);
    }
    // Clicking on any element with the data-noselect attribute means no selection
    else if (record && !item.contains(event.target.closest('[data-noselect]')) && (!isSpecialRow || allowGroupSelect)) {
      const {
          selected
        } = me,
        {
          groupParent
        } = record.instanceMeta(this.store);
      if (me.multiSelect) {
        let isSelected = selected.includes(record),
          toAddRemove = record;
        if (me.toggleAllIfCtrlPressed && event.ctrlKey) {
          toAddRemove = me.store.records;
        } else if (allowGroupSelect && isSpecialRow) {
          isSelected = !record.groupChildren.some(rec => !selected.includes(rec));
          item.classList.toggle('b-selected', !isSelected);
          toAddRemove = record.groupChildren;
        }
        selected[isSelected ? 'remove' : 'add'](toAddRemove);
        // Update the selected status of the group parent
        if (!isSpecialRow && groupParent && allowGroupSelect) {
          const groupItem = me.getItem(groupParent);
          groupItem.classList.toggle('b-selected', groupParent.groupChildren.every(r => selected.includes(r)));
        }
      } else {
        selected.splice(0, selected.count, record);
      }
    }
    if (me.isDestroyed) {
      return;
    }
    me.lastClicked = record;
    me.trigger('item', {
      item,
      record,
      index,
      event,
      userAction: true
    });
    me._isUserAction = false;
  }
  /**
   * Handles items being added or removed from the selected Collection
   * @param {Object} changeEvent
   * @private
   */
  onSelectionChange({
    action,
    removed,
    added,
    replaced
  }) {
    const me = this,
      {
        selectedCls,
        unselectedCls
      } = me;
    let record, item;
    if (action === 'clear') {
      for (item of me.element.querySelectorAll(`.${selectedCls}`)) {
        item.classList.remove(selectedCls);
        item.setAttribute('aria-selected', false);
        unselectedCls && item.classList.remove(unselectedCls);
      }
    } else if (action !== 'replaceValues') {
      for (record of removed) {
        item = me.getItem(record);
        if (item) {
          item.classList.remove(selectedCls);
          item.setAttribute('aria-selected', false);
        }
      }
      for (record of added) {
        item = me.getItem(record);
        if (item) {
          item.classList.add(selectedCls);
          item.setAttribute('aria-selected', true);
        }
      }
    }
    me.selectAllItem && me.updateSelectAllState();
  }
  onSelectAllClick(item) {
    const checked = item.classList.contains(this.selectedCls);
    if (checked) {
      this.deselectAll();
    } else {
      this.selectAll();
    }
  }
  updateSelectAllState() {
    var _this$element$querySe;
    (_this$element$querySe = this.element.querySelector('.b-select-all-item')) === null || _this$element$querySe === void 0 ? void 0 : _this$element$querySe.classList.toggle(this.selectedCls, this.allSelected);
  }
  /**
   * Yields `true` if all the available items are selected.
   * @property {Boolean}
   * @readonly
   */
  get allSelected() {
    const {
      selected,
      store
    } = this;
    return selected.count && (store.isFiltered ? store.records.every(r => selected.includes(r)) : store.count === selected.count);
  }
  /**
   * Selects all items in this list.
   * @category Selection
   */
  selectAll(keyEvent) {
    const me = this;
    // A programmatic selectAll must work. A UI-invoked call must honour multiSelect:false
    if (me.multiSelect || !keyEvent) {
      me.selected.add(me.store.records);
      if (keyEvent && !me.navigator.activeItem) {
        me.navigator.activeItem = me.getItem(-1);
      }
    }
  }
  /**
   * Deselects all selected items
   * @category Selection
   */
  deselectAll() {
    this.selected.clear();
  }
  /**
   * Selects the passed item(s).
   *
   * An item to select may be the `id` of a record in this List's {@link #config-store}, or
   * it may be an object with an `id` __property__ which is the `id` of a record in this List's
   * {@link #config-store} (For example one of the records).
   * @param {String|String[]|Number|Number[]|Object|Object[]} toSelect
   * @category Selection
   */
  select(toSelect) {
    const {
        store
      } = this,
      {
        modelClass
      } = store;
    toSelect = ArrayHelper.asArray(toSelect).reduce((v, c) => {
      c = store.getById(modelClass.asId(c));
      if (c) {
        v.push(c);
      }
      return v;
    }, []);
    this.selected.add(toSelect);
  }
  /**
   * Deselects the passed item(s).
   *
   * An item to deselect may be the `id` of a record in this List's {@link #config-store}, or
   * it may be an object with an `id` __property__ which is the `id` of a record in this List's
   * {@link #config-store} (For example one of the records).
   * @param {String|String[]|Number|Number[]|Object|Object[]} toSelect
   * @category Selection
   */
  deselect(toDeselect) {
    const {
      modelClass
    } = this.store;
    toDeselect = ArrayHelper.asArray(toDeselect).reduce((v, c) => {
      c = this.selected.get(modelClass.asId(c));
      if (c) {
        v.push(c);
      }
      return v;
    }, []);
    this.selected.remove(toDeselect);
  }
}
// Register this widget type with its Factory
List.initClass();
List.prototype.navigatorClass = Navigator;
List._$name = 'List';

/**
 * @module Core/widget/ChipView
 */
/**
 * Displays an inline series of Chips which may be navigated to, selected and deleted. You can provide a
 * {@link #config-closeHandler} to decide what should happen when a chip is closed. If not provided, by default the
 * record representing the chip is removed from the store.
 *
 * {@inlineexample Core/widget/ChipView.js}
 *
 * @classType chipview
 * @extends Core/widget/List
 * @widget
 */
class ChipView extends List {
  //region Config
  static get $name() {
    return 'ChipView';
  }
  // Factoryable type name
  static type = 'chipview';
  static get configurable() {
    return {
      itemCls: 'b-chip',
      /**
       * Configure as `true` to allow multi select and allow clicking and key navigation
       * to select multiple chips.
       * @config {Boolean}
       * @default
       */
      multiSelect: false,
      /**
       * Configure as `true` to display a clickable close icon after the {@link Core.widget.List#config-itemTpl}.
       * When tapped, the configured {@link #config-closeHandler} is called passing the
       * associated record.
       *
       * Chips may also be selected using the `LEFT` and `RIGHT` arrows (And the `Shift` key to
       * do multiple, contiguous election). Pressing the `DELETE` or `BACKSPACE` key passes the
       * selected records to the {@link #config-closeHandler}
       * @config {Boolean}
       * @default
       */
      closable: true,
      /**
       * A template function, which, when passed a record, returns the markup which
       * encapsulates a chip's icon to be placed before the {@link Core.widget.List#config-itemTpl}.
       * @config {Function}
       */
      iconTpl: null,
      /**
       * If {@link #config-closable} is `true`, this is the name of a callback function
       * to handle what the "close" action means. If not provided, the record representing the chip is removed
       * from the store
       * @config {String|Function}
       */
      closeHandler: null
    };
  }
  itemContentTpl(record, i) {
    const me = this;
    return TemplateHelper.tpl`${me.iconTpl ? this.iconTpl(record) : ''}
            ${me.itemTpl(record, i)}
            ${me.closable ? '<div class="b-icon b-close-icon b-icon-clear" data-noselect></div>' : ''}`;
  }
  onInternalKeyDown(event) {
    const me = this;
    if (me.closable && me.selected.count && (event.key === 'Delete' || event.key === 'Backspace')) {
      me.callback(me.closeHandler, me.owner, [me.selected.values, {
        isKeyEvent: true
      }]);
    } else {
      super.onInternalKeyDown(event);
    }
  }
  updateClosable(closable) {
    this.element.classList[closable ? 'add' : 'remove']('b-chips-closable');
    this.navigator && (this.navigator.disabled = !closable);
    if (!this.isConfiguring) {
      this.refresh();
    }
  }
  onClick(event) {
    const me = this,
      item = event.target.closest(`.${me.itemCls}`);
    if (me.closable && event.target.classList.contains('b-close-icon')) {
      const record = me.store.getAt(parseInt(item.dataset.index));
      if (me.closeHandler) {
        me.callback(me.closeHandler, me.owner, [[record]]);
      } else {
        me.store.remove(record);
      }
    } else {
      super.onClick(event);
    }
  }
}
// Register this widget type with its Factory
ChipView.initClass();
ChipView._$name = 'ChipView';

const errorFieldRequired = 'L{Field.fieldRequired}',
  errorValidateFilter = 'L{Field.validateFilter}',
  errorRecordNotCommitted = 'L{Combo.recordNotCommitted}';
/**
 * @module Core/widget/Combo
 */
/**
 * Combo (dropdown) widget. Consists of a text field with a trigger icon, which displays a List. Can be
 * populated from a Store.
 *
 * This field can be used as an {@link Grid/column/Column#config-editor} for the {@link Grid/column/Column}.
 *
 * Please be aware that when populating the Combo with objects or records you have to configure {@link #config-valueField} and {@link #config-displayField}
 * to point to the correct field names in your data.
 *
 * ### Basic scenarios
 * {@inlineexample Core/widget/Combo.js vertical}
 *
 * ### Multiselect + grouped list
 *
 * {@inlineexample Core/widget/ComboMultiselect.js}
 *
 * ## Snippet: Loading data from simple string array
 * ```javascript
 * const combo = new Combo({
 *     items       : ['Small', 'Smaller', 'Really small', 'Tiny'],
 *     placeholder : 'Pick size of diamond for ring'
 * });
 *```
 *
 * ## Snippet: Loading data from array with item configs
 * ```javascript
 * const combo = new Combo({
 *     items : [{ value: 'a', text: 'First' }, { value: 'z', text: 'Last' }]
 * });
 *```
 *
 * ## Snippet: Loading data from store
 * ```javascript
 * const combo = new Combo({
 *     store        : memberStore,
 *     valueField   : 'id',
 *     displayField : 'name'
 * });
 *```
 *
 * ## Snippet: Grouped list
 * To group the list contents, simply group your store using {@link Core.data.mixin.StoreGroup#config-groupers}. You
 * can decide if clicking a header should toggle all group children (or if it should do nothing) with the
 * {@link Core.widget.List#config-allowGroupSelect} flag.
 * ```javascript
 * const combo = new Combo({
 *     width            : 400,
 *     displayField     : 'name',
 *     valueField       : 'id',
 *     multiSelect      : true,
 *     picker : {
 *         allowGroupSelect : false,
 *         // Show icon based on group name
 *         groupHeaderTpl   : (record, groupName) => `
 *             <i class="icon-${groupName}"></i>${groupName}
 *         `
 *     },
 *     value : [1, 4],
 *     store : new Store({
 *         fields : [
 *             'type'
 *         ],
 *         groupers : [
 *             { field : 'type', ascending : true }
 *         ],
 *         data : [
 *             { id : 1, name : 'pizza', type : 'food' },
 *             { id : 2, name : 'bacon', type : 'food' },
 *             { id : 3, name : 'egg', type : 'food' },
 *             { id : 4, name : 'Gin tonic', type : 'drinks' },
 *             { id : 5, name : 'Wine', type : 'drinks' },
 *             { id : 6, name : 'Beer', type : 'drinks' }
 *         ]
 *     })
 * });
 *```
 *
 * ## Shared Stores
 * More than one Combo may share a Store if they are required to draw their values from a shared
 * data set.
 *
 * The only limitation here is that the characteristics of the filter that is applied to the store
 * by typing are inherited from the __first__ combo. So for example, all would be
 * {@link #config-caseSensitive} or all case-insensitve, and all would use the same
 * {@link #config-filterOperator}.
 *
 * In the example below, all three email address inputs use the same store of recipients.
 *
 * {@inlineexample Core/widget/EmailMultiselect.js}
 *
 * This may be operated using the keyboard. `ArrowDown` opens the picker, ann then `ArrowDown` and
 * `ArrowUp` navigate the picker's options. `Enter` selects an active option in the picker. `Escape`
 * closes the picker.
 *
 * @extends Core/widget/PickerField
 * @classType combo
 * @inputfield
 */
class Combo extends PickerField {
  //region Config
  static get $name() {
    return 'Combo';
  }
  // Factoryable type name
  static get type() {
    return 'combo';
  }
  // Factoryable type aliases
  static get alias() {
    return 'combobox,dropdown';
  }
  static delayable = {
    filterOnInput: 0
  };
  static get configurable() {
    return {
      /**
       * Optionally a {@link Core.util.CollectionFilter Filter} config object which the combo should use for
       * filtering using the typed value.
       * This may use a `filterBy` property to test its `value` against any field in the passed record.
       * ```javascript
       * {
       *     type          : 'combo',
       *     store         : myStore,
       *     primaryFilter : {
       *         filterBy(record) {
       *             if (this.value == null) {
       *                 return true;
       *             }
       *             const value = this.value.toLowerCase();
       *
       *             // Match typed value with forename or surname
       *             return record.forename.toLowerCase().startsWith(value)
       *                 || record.surname.toLowerCase().startsWith(value);
       *         }
       *     }
       * }
       * ```
       * @config {CollectionFilterConfig}
       */
      primaryFilter: {},
      picker: {
        type: 'list',
        floating: true,
        scrollAction: 'realign',
        itemsFocusable: false,
        activateOnMouseover: true,
        align: {
          align: 't0-b0',
          axisLock: true
        },
        maxHeight: 324,
        scrollable: {
          overflowY: true
        },
        autoShow: false,
        focusOnHover: false
      },
      /**
       * Configure as `true` to allow selection of multiple values from the dropdown list.
       *
       * Each value is displayed as a "Chip" to the left of the input area. Chips may be
       * selected using the `LEFT` and `RIGHT` arrow keys and deleted using the `DELETE` key
       * to remove values from the field. There is also a clickable close icon in each chip.
       *
       * Use {@link Core.widget.List#config-toggleAllIfCtrlPressed} to implement "select all" behaviour.
       *
       * ```javascript
       * {
       *     type   : 'combo',
       *     store  : myStore,
       *     picker : {
       *         toggleAllIfCtrlPressed : true
       *     }
       * }
       * ```
       *
       * @config {Boolean}
       * @default false
       */
      multiSelect: null,
      /**
       * Rows to display in the dropdown (list items).
       *
       * If an object, the property names provide the {@link #config-value} for the Combo, and
       * the property values provide the displayed test in the list and input area eg:
       *
       *     items : {
       *         small  : 'Small',
       *         medium : 'Medium',
       *         large  : 'Large'
       *     }
       *
       * If an array, each entry may be
       *  - an object containing properties which must include
       * the {@link #config-valueField} and {@link #config-displayField} which populates the dropdown
       * with text and provides the corresponding field value.
       *  - An array whose first value provides the {@link #config-value} for the Combo and whose
       * second value provides the displayed test in the list and input area.
       *  - An array of values where the {@link #config-valueField} and {@link #config-displayField} are the same.
       *
       * eg:
       *
       *     items : [
       *         {value : 'small',  text : 'Small'},
       *         {value : 'medium', text : 'Medium'},
       *         {value : 'large',  text : 'Large'},
       *     ]
       *
       * or
       *
       *     items : [
       *         ['small',  'Small'],
       *         ['medium', 'Medium'],
       *         ['large',  'Large'],
       *     ]
       *
       * or
       *
       *     items : [ 'Small', 'Medium', 'Large' ]
       *
       * @config {Object[]|String[]|Object}
       */
      items: null,
      /**
       * Store used to populate items. Also accepts a Store config object
       * @prp {Core.data.Store|StoreConfig}
       */
      store: null,
      /**
       * Field used for item value when populating from store. Setting this to `null` will
       * yield the selected record as the Combo's {@link #property-value}.
       * @config {String|null}
       */
      valueField: undefined,
      /**
       * Field used for item text when populating from store
       * @config {String}
       * @default
       */
      displayField: 'text',
      /**
       * Width of picker, defaults to this combo's {@link #config-pickerAlignElement} width
       * @config {Number}
       */
      pickerWidth: null,
      /**
       * The minimum string length to trigger the filtering, only relevant when {@link #config-editable} is `true`.
       *
       * This defaults to `1` in the case of local filtering, but `4` if the
       * {@link #config-filterParamName} is set to cause remote dropdown loading.
       *
       * @config {Number}
       * @default
       */
      minChars: null,
      selected: null,
      /**
       * Template string used to render the list items in the dropdown list
       *
       * ```javascript
       * new Combo({
       *     listItemTpl : ({ text }) => `<div class="combo-color-box ${text}"></div>${text}`,
       *     editable    : false,
       *     items       : [
       *         'Black',
       *         'Green',
       *         'Orange',
       *         'Pink',
       *         'Purple',
       *         'Red',
       *         'Teal'
       *     ]
       * });
       * ```
       *
       * @config {Function}
       * @param {Core.data.Model} record The record representing the item being rendered
       * @returns {String}
       */
      listItemTpl: null,
      /**
       * Template function that can be used to customize the displayed value
       * @param {Core.data.Model} record The record to provide a textual value for.
       * @param {Core.widget.Combo} combo A reference to this Combo.
       * @config {Function}
       * @returns {String}
       */
      displayValueRenderer: null,
      /**
       * CSS class to add to picker
       * @config {String}
       */
      listCls: null,
      triggers: {
        expand: {
          cls: 'b-icon-picker',
          handler: 'onTriggerClick'
        }
      },
      /**
       * If the dropdown is to be populated with a filtered query to a remote server, specify the
       * name of the parameter to pass the typed string here. By default, the string is simply sent
       * as the value of the parameter. For special encoding, configure the combo with {@link #config-encodeFilterParams}
       * @config {String}
       */
      filterParamName: null,
      /**
       * A function which creates an array of values for the {#config-filterParamName} to pass
       * any filters to the server upon load.
       *
       * The default behaviour is just to set the parameter value to the filter's `value`,
       * but the filter can be fully encoded for example:
       *
       * ```javascript
       *    {
       *        encodeFilterParams(filters) {
       *            const result = [];
       *
       *            for (const { property, operator, value, caseSensitive } of filters) {
       *                result.push(JSON.stringify({
       *                    field : property,
       *                    operator,
       *                    value,
       *                    caseSensitive
       *                }));
       *           }
       *        return result;
       *    }
       * ```
       * @config {Function}
       */
      encodeFilterParams: filters => filters.map(f => f.value),
      /**
       * If `false`, filtering will be triggered once you exceed {@link #config-minChars}. To filter only when
       * hitting Enter key, set this to `true`;
       * @config {Boolean}
       */
      filterOnEnter: false,
      /**
       * Configure as `true` to hide the expand trigger. This is automatically set to `true` if
       * remote filtering is enabled by setting the {@link #config-filterParamName} config.
       * @config {Boolean}
       * @default false
       */
      hideTrigger: null,
      /**
       * This implies that the picker will display an anchor pointer, but also means that the picker will align closer
       * to the input field so that the pointer pierces the {@link #config-pickerAlignElement}
       * @config {Boolean}
       * @default false
       */
      overlayAnchor: null,
      /**
       * The delay in milliseconds to wait after the last keystroke before filtering the list.
       *
       * This is a minimum of 300ms for remote filtering to keep network requests manageable, and
       * defaults to 10ms for locally filtered stores.
       * @config {Number}
       * @default
       */
      keyStrokeFilterDelay: null,
      defaultAction: 'select',
      /**
       * How to query the store upon click of the expand trigger. Specify one of these values:
       *
       *  - `'all'` - Clear the filter and display the whole dataset in the dropdown.
       *  - `'last'` - Filter the dataset using the last filter value.
       *  - `null`/any other - Use the value in the input field to filter the dataset.
       *
       * @config {'all'|'last'|null}
       * @default
       */
      triggerAction: 'all',
      /**
       * The name of an operator type as implemented in {@link Core.util.CollectionFilter#config-operator}
       * to use when filtering the dropdown list based upon the typed value.
       *
       * This defaults to `'startsWith'`, but the `'*'` operator may be used to match all
       * values which _contain_ the typed value.
       *
       * Not used when {@link #config-filterParamName} is set to cause remote dropdown loading.
       * The exact filtering operation is up to the server.
       *
       * @default
       * @prp {'='|'!='|'>'|'>='|'<'|'<='|'*'|'startsWith'|'endsWith'|'isIncludedIn'}
       */
      filterOperator: 'startsWith',
      /**
       * Configure as `true` to force case matching when filtering the dropdown list based upon the typed value.
       *
       * @config {Boolean}
       * @default false
       */
      caseSensitive: false,
      /**
       * By default, the picker is hidden on selection in single select mode, and
       * remains to allow more selections when {@link #config-multiSelect} is `true`.
       * Setting this to a `Boolean` value can override that default.
       * @config {Boolean}
       */
      hidePickerOnSelect: null,
      /**
       * A config object to configure the {@link Core.widget.ChipView} to display the
       * selected value set when {@link #config-multiSelect} is `true`.
       *
       * For example the {@link Core.widget.List#config-itemTpl} or
       * {@link Core.widget.ChipView#config-iconTpl} might be configured to display
       * richer chips for selected items.
       * @config {ChipViewConfig}
       */
      chipView: {
        $config: ['lazy', 'nullify'],
        value: {
          type: 'combochipview'
        }
      },
      chipStore: {
        $config: ['lazy', 'nullify'],
        value: {}
      },
      /**
       * When {@link #config-multiSelect} is `true`, you may configure `filterSelected` as
       * `true` to hide items in the dropdown when they are added to the selection.
       * It will appear as if the requested item has "moved" into the field's
       * {@link #config-chipView ChipView}.
       *
       * @config {Boolean}
       * @default false
       */
      filterSelected: null,
      /**
       * Text to display in the drop down when there are no items in the underlying store
       * @config {String}
       * @default
       */
      emptyText: null,
      /**
       * Get/sets combo value, selects corresponding item in the list
       * Setting null clears the field.
       *
       * If {@link #config-multiSelect} is `true`, then multiple values may be passed as an array.
       * If the values are records, these become the selected record set held by {@link #property-valueCollection},
       * and the `value` yielded by this field is an array of all the {@link #config-valueField}s from the records.
       * @fires select
       * @fires action
       * @member {Object|Number|String} value
       */
      /**
       * The initial value of this Combo box. In single select mode (default) it's a simple string value, for
       * {@link #config-multiSelect} mode, it should be an array of record ids.
       * @config {String|Number|String[]|Number[]}
       * @default
       */
      value: null,
      valueCollection: {
        $config: ['nullify', 'lazy'],
        value: {}
      },
      /**
       * `true` to cause the field to be in an invalid state while the typed filter string does not match a record in the store.
       * @config {Boolean}
       * @default
       */
      validateFilter: true,
      /**
       * `true` to clear value typed to a multiselect combo when picker is collapsed
       * @config {Boolean}
       * @default
       */
      clearTextOnPickerHide: true,
      // set to true to destroy the old combo store when it is replaced with a new store
      destroyStore: false,
      /**
       * A key value which, when typed in a {@link #config-multiSelect} Combo, selects the
       * currently active item in the picker, and clears the input field ready for another
       * match to be typed.
       * @config {String}
       * @default
       */
      multiValueSeparator: ',',
      /**
       * If configured as `true`, this means that when an unmatched string is typed into the
       * combo's input field, and `ENTER`, or the {@link #config-multiValueSeparator} is typed,
       * a new record will be created using the typed string as the {@link #config-displayField}.
       *
       * If configured as a function, or the name of a function in the owning component hierarchy, the function
       * will be called passing the string and combo field instance and should return the record to add (if any).
       *
       * The new record will be appended to the store, and the value selected.
       *
       * If the Store is an {@link Core.data.AjaxStore}, the new record will be eiligible for
       * syncing to the database through its {@link Core.data.AjaxStore#config-createUrl createUrl}.
       *
       * If the `AjaxStore` is configured to {@link Core.data.AjaxStore#config-autoCommit autoCommit},
       * the record will be synced immediately. If the server does not accept the new addition,
       * the field is placed temporarily into an invalid state with a message that explains this.
       *
       * For example:
       *
       * ```javascript
       *     new Combo({
       *         label : 'Employee name',
       *         store : employees,
       *         createOnUnmatched(name, combo) {
       *             name = validateEmployeeName(name);
       *
       *             if (name) {
       *                 return new Employee({
       *                     name,
       *                     email : generateEmployeeEmail(name)
       *                 });
       *             }
       *             else {
       *                 combo.setError('Invalid new employee name');
       *             }
       *         }
       *     });
       * ```
       * @config {Function|String|Boolean}
       */
      createOnUnmatched: null,
      role: 'combobox',
      /**
       * Configure this as `true` to render the dropdown list as a permanently visible list
       * in the document flow immediately below the input area instead of as a popup.
       *
       * This also hides the expand trigger since it is not needed.
       * @config {Boolean}
       * @default false
       */
      inlinePicker: null,
      testConfig: {
        // So that locally filtered tests do not have to wait after type gestures.
        // Note that for remote filtering, we set a min of 300ms
        keyStrokeFilterDelay: 0
      },
      /**
       * Configure this as `true` and the items display field values will be localized. The display field values
       * need to be a locale string.
       * @config {Boolean}
       * @private
       * @default
       */
      localizeDisplayFields: false,
      /**
       * Provide a function that returns items to be shown in the combo's selector.
       * @config {Function}
       * @private
       */
      buildItems: null
    };
  }
  /**
   * A constant value for the {@link #config-triggerAction} config to indicate that clicking the trigger should
   * filter the dataset using the last filter query string, *not* the input field value.
   * @member {String} queryLast
   * @readonly
   * @static
   */
  static get queryLast() {
    return 'last';
  }
  //endregion
  construct(config) {
    super.construct(...arguments);
    // Ensure there will always be a store created if Combo is created without items/store
    if (!this.store) {
      this.items = [];
    }
    if (this.filterOnEnter) {
      this.hideTrigger = true;
    }
  }
  startConfigure(config) {
    this.usingRecordAsValue = config.valueField === null;
    super.startConfigure(...arguments);
  }
  afterConfigure() {
    super.afterConfigure();
    const me = this;
    if (!ObjectHelper.hasOwn(me, '_value')) {
      me._value = me.valueField === me.displayField ? '' : null;
      // _lastValue should stay keeping an initial value if any
      me._lastValue = me._lastValue || me._value;
    }
  }
  get childItems() {
    const {
        _chipView,
        _picker
      } = this,
      result = super.childItems;
    if (_chipView) {
      result.push(_chipView);
    }
    if (_picker) {
      result.push(_picker);
    }
    return result;
  }
  get innerElements() {
    var _this$_chipView;
    const chipViewElement = (_this$_chipView = this._chipView) === null || _this$_chipView === void 0 ? void 0 : _this$_chipView.element,
      // don't trigger chipView create on first compose()
      {
        input,
        inputElement
      } = this;
    if (chipViewElement) {
      // Once the input el is transplanted inside the chipView, normal compose() calls won't sync it, so we
      // have to do so now:
      DomSync.sync({
        targetElement: input,
        domConfig: inputElement
      });
    }
    return [chipViewElement || inputElement];
  }
  updateInlinePicker(inlinePicker) {
    if (inlinePicker) {
      this.element.classList.add('b-inline-picker');
      // Force eager ingestion of picker
      this.getConfig('picker');
      // No expand trigger
      this.triggers.expand = null;
      this.pickerVisible = true;
    }
  }
  hidePicker() {
    if (!this.inlinePicker) {
      return super.hidePicker(...arguments);
    }
  }
  changeChipStore(chipStore) {
    if (chipStore && !(chipStore instanceof Store)) {
      chipStore = new Store(Store.mergeConfigs({
        storage: this.valueCollection
      }, chipStore));
    }
    return chipStore;
  }
  updateChipStore(store, was) {
    was === null || was === void 0 ? void 0 : was.destroy();
  }
  changeChipView(chipView, oldChipView) {
    const me = this;
    me.element.classList[chipView ? 'add' : 'remove']('b-uses-chipview');
    if (chipView) {
      const {
        input
      } = me;
      if (!me.chipStore) {
        me.chipStore = {};
      }
      return ComboChipView.reconfigure(oldChipView, chipView, {
        defaults: {
          parent: me,
          insertBefore: input,
          store: me.chipStore,
          closable: !me.readOnly,
          navigator: {
            type: 'combochipnavigator',
            keyEventTarget: input
          }
        }
      });
    }
    oldChipView === null || oldChipView === void 0 ? void 0 : oldChipView.destroy();
  }
  updateChipView(chipView) {
    var _me$_chipViewEventDet;
    const me = this;
    me._chipViewEventDetacher = (_me$_chipViewEventDet = me._chipViewEventDetacher) === null || _me$_chipViewEventDet === void 0 ? void 0 : _me$_chipViewEventDet.call(me);
    me.chipStore = chipView === null || chipView === void 0 ? void 0 : chipView.store;
    if (chipView) {
      // Insert the input field
      chipView.element.appendChild(me.input);
      // Focus must flow into our field from the ChipView
      me._chipViewEventDetacher = EventHelper.on({
        element: chipView.element,
        mousedown: 'onChipViewMousedown',
        thisObj: me
      });
    }
  }
  updateMultiSelect(multiSelect, oldMultiSelect) {
    const me = this,
      {
        input,
        element
      } = me,
      fixValue = !me.isConfiguring;
    let {
      value
    } = me;
    element.classList[multiSelect ? 'add' : 'remove']('b-multiselect');
    if (multiSelect) {
      const {
          chipView
        } = me,
        {
          parentNode
        } = input,
        chipViewEl = chipView === null || chipView === void 0 ? void 0 : chipView.element;
      // If the input's parentNode is not the chipView's element, we need to restore that DOM arrangement
      if (chipViewEl && chipViewEl !== parentNode) {
        // This is where the chipView is created in the DOM but it may have been removed.
        parentNode.insertBefore(chipViewEl, input);
        chipViewEl.appendChild(input);
        me.chipView.refresh();
      }
      input.value = '';
      if (fixValue) {
        value = ArrayHelper.asArray(value);
      }
    }
    // else when !multiSelect, if the input's parentNode is the chipView's element, we need to put things back the
    // other way
    else {
      // avoid triggering lazy config if !multiSelect
      const chipView = me._chipView,
        {
          parentNode
        } = input,
        chipViewEl = chipView === null || chipView === void 0 ? void 0 : chipView.element;
      if (chipViewEl === parentNode) {
        // Put the input back in its proper place
        chipViewEl.parentNode.insertBefore(input, chipViewEl);
        // When no longer multiSelect, remove the chipView from the DOM. We do not destroy it because derived
        // classes or the instance config may have specified chipView config options. If we destroyed it, we could
        // not then properly recreate it.
        chipViewEl.remove();
        element.classList.remove('b-uses-chipview');
      }
      if (fixValue && typeof value !== 'string') {
        var _value;
        value = (_value = value) !== null && _value !== void 0 && _value.length ? value[0] : null;
      }
    }
    if (fixValue) {
      me.value = value;
    }
  }
  onChipViewMousedown(mousedownEvent) {
    mousedownEvent.preventDefault();
    if (!this.containsFocus) {
      this.focus();
    }
  }
  onChipClose(records, options = {}) {
    // Do not clean value collection if input field is not empty - probably text is selected
    // and user just wants to remove it, not the picked values
    if (options.isKeyEvent && this.input.value === '' || !options.isKeyEvent) {
      this._isUserAction = true;
      this.valueCollection.remove(records);
      this._isUserAction = false;
    }
  }
  updateFilterParamName(filterParamName) {
    if (this.hideTrigger !== false) {
      this.hideTrigger = Boolean(filterParamName);
    }
  }
  updateHideTrigger(hideTrigger) {
    this.element.classList[hideTrigger ? 'add' : 'remove']('b-hide-trigger');
  }
  //region Getters/setters
  updateKeyStrokeFilterDelay(delay) {
    this.filterOnInput.delay = delay;
  }
  updateReadOnly(readOnly) {
    super.updateReadOnly(...arguments);
    // Disable closing (removing) chips when we are read-only.
    this._chipView && (this._chipView.closable = !readOnly);
  }
  updateDisabled(disabled) {
    super.updateDisabled(...arguments);
    // Disable closing (removing) chips when we are disabled
    this._chipView && (this._chipView.closable = !disabled);
  }
  updateFilterOperator(filterOperator) {
    if (this.primaryFilter) {
      this.primaryFilter.operator = filterOperator;
    }
  }
  get minChars() {
    const minChars = this._minChars;
    if (minChars != null) {
      return minChars;
    }
    // If it's not actually set, default differently for remote filtering.
    return this.remoteFilter ? 4 : 1;
  }
  get validateFilter() {
    // Do not show the error if the user has the opportunity to add the typed filter string
    return this._validateFilter && !this.createOnUnmatched;
  }
  get items() {
    return this.store.allRecords;
  }
  updateBuildItems(fn) {
    if (fn) {
      this.items = fn.call(this);
    }
  }
  /**
   * Prepares items to work in attached menu (converts strings to items)
   * @private
   */
  changeItems(items) {
    var _items;
    const me = this;
    if (items == null) {
      if (me.store && !me.store.isItemStore) {
        return;
      }
      items = [];
    }
    if (me.buildItems && !((_items = items) !== null && _items !== void 0 && _items.length)) {
      items = me.buildItems();
    }
    if (items instanceof Store) {
      me.store = items;
      return;
    }
    const displayField = me.displayField;
    let itemModel,
      valueField = me.valueField,
      storeData;
    if (Array.isArray(items)) {
      storeData = items.map(item => {
        let result = item;
        if (item instanceof Model) {
          itemModel = item.constructor;
          if (!valueField) {
            me.valueField = valueField = itemModel.idField;
          }
        } else {
          if (typeof item === 'string' || typeof item === 'number') {
            if (!valueField) {
              me.valueField = valueField = me.displayField;
            }
            result = {
              [valueField]: item,
              [displayField]: item
            };
          } else {
            if (!valueField) {
              me.valueField = valueField = 'value';
            }
            if (Array.isArray(item)) {
              result = {
                [valueField]: item[0],
                [displayField]: item[1]
              };
            }
          }
        }
        if (item.selected) {
          me.value = result;
        }
        return result;
      });
    }
    // Must be a value -> text map
    else {
      if (!valueField) {
        me.valueField = valueField = 'value';
      }
      storeData = [];
      Object.entries(items).forEach(([key, value]) => {
        storeData.push({
          [valueField]: key,
          [displayField]: value
        });
      });
    }
    // Allow reconfiguring with a new set of items
    if (me.store) {
      me.store.data = storeData;
    } else {
      const valueFieldDefinition = valueField === displayField ? {
        name: 'value',
        dataSource: displayField
      } : valueField;
      if (!itemModel) {
        // angular prod build messes up "Foo = class extends Base" (https://github.com/bryntum/support/issues/6395)
        class ModelClass extends Model {
          static get idField() {
            // Need to use instance var and not rely on closure for cases where valueField changes
            // (like first assigning [] and then ['a'] without configured valueField
            return me.valueField;
          }
          static set idField(idField) {
            super.idField = idField;
          }
          static get fields() {
            return [valueFieldDefinition, displayField];
          }
        }
        itemModel = ModelClass;
      }
      me.store = new Store({
        isItemStore: true,
        data: storeData,
        idField: valueField,
        // We frequently populate combos with data from other stores, don't want warnings for consuming local
        // records from those stores with generated ids
        verifyNoGeneratedIds: false,
        modelClass: itemModel
      });
    }
  }
  get value() {
    const me = this,
      {
        valueCollection,
        valueField
      } = me;
    if (valueField == null) {
      return me.multiSelect ? valueCollection.values.slice() : valueCollection.first;
    }
    let value;
    if (me.multiSelect) {
      value = valueCollection.count ? valueCollection.map(r => r[valueField]) : me._lastValue || [];
    } else {
      value = valueCollection.count ? valueCollection.first[valueField] : me._lastValue;
    }
    return value;
  }
  set value(value) {
    super.value = value;
  }
  // Documented in superclass.
  get needsInputSync() {
    // Syncing the input field to the internal value is only needed in a Combo
    // if there's no ChipView which reflects the value, and the input field
    // is *not* being used as a type-to-filter input.
    return this.usesChipView ? false : !this.editable;
  }
  changeValue(value, oldValue) {
    const me = this;
    if (value === oldValue) {
      // Sync without highlight
      me.syncInputFieldValue(true);
      return;
    }
    if (!me.multiSelect && Array.isArray(value) && value.length > 1) {
      throw new Error('Multiple values cannot be set to a non-multiSelect Combo');
    }
    // This forces promotion of the items config into a Store if it has not already been injected
    me.triggerConfig('items');
    // On programmatic value change, we need to clear the chip view selection.
    // Use the _property name in order not to call it into existence
    if (!me.inputting) {
      var _me$_chipView;
      (_me$_chipView = me._chipView) === null || _me$_chipView === void 0 ? void 0 : _me$_chipView.selected.clear();
    }
    // Set an empty items array if no data or store was given
    if (!me.store) {
      me.items = [];
    }
    const {
        valueField,
        displayField,
        store,
        valueCollection,
        _picker
      } = me,
      {
        storage
      } = store,
      hidePicker = me.hidePickerOnSelect ?? !me.multiSelect,
      isUserAction = me._isUserAction || (_picker === null || _picker === void 0 ? void 0 : _picker._isUserAction) || hidePicker && me.pickerVisible || false;
    // if not remoteFilter mode and AjaxStore has been used, try again to set a value after first store loading
    if (!me.remoteFilter && store.isAjaxStore && !store.count) {
      store.ion({
        load: () => me.value = value,
        once: true,
        thisObj: me
      });
      // save value to make sure getter returns the correct data fot multiSelect while data loading
      me._lastValue = value;
      return;
    }
    let record;
    if (value != null) {
      // If value is set as an array, make sure to slice it to not mutate original array below
      const arrayPassed = Array.isArray(value),
        values = arrayPassed ? value.slice() : [value];
      // It's a remote filter store, so we have to do a filter down to just match(es)
      // and add the result to the valueCollection
      if (me.remoteFilter) {
        // The null case will drop through and be processed as for local just by clearing the valueCollection
        if (value != null) {
          if (ObjectHelper.isObject(value) || value.isModel) {
            me.store.data = [value];
            me.valueCollection.splice(0, me.valueCollection.count, me.store.first);
          } else {
            const wasConfiguring = me.isConfiguring;
            me.primaryFilter.setConfig({
              value,
              disabled: false
            });
            store.performFilter(true).then(() => {
              if (me.isDestroyed) {
                return;
              }
              const {
                isConfiguring
              } = me;
              // Carry the wasConfiguring flag from the set value call frame so that
              // if it's the configuring set value, we do not now fire the change event.
              me.isConfiguring = wasConfiguring;
              valueCollection.splice(0, valueCollection.count, store.allRecords);
              me.isConfiguring = isConfiguring;
            });
          }
          return;
        }
      }
      // Else, if it's a *locally* filtered store, then unfilter it, so we can do the value lookup.
      else if (store.isFiltered) {
        me.primaryFilter.disabled = true;
        store.filter();
      }
      for (let i = 0, len = values.length; i < len; i++) {
        let currentValue = values[i];
        if (currentValue instanceof Model) {
          // The required record value may not yet be in the store. Add it if not.
          // Be sure to look past filters when checking if value is already present.
          if (!storage.includes(currentValue, true)) {
            store.add(currentValue);
          }
        } else {
          const isObject = ObjectHelper.isObject(currentValue);
          // If they passed a data object, match the valueField
          if (isObject) {
            currentValue = currentValue[store.modelClass.fieldMap[valueField].dataSource];
          }
          // Use the Store Collection's extra indices to quickly find a match.
          // They may not be found if the current valueCollection state and
          // filterSelected mean that some are filtered out, so check in
          // valueCollection if not found in the Store.
          record = storage.getBy(displayField, currentValue) || storage.getBy(valueField, currentValue) || valueCollection.getBy(displayField, currentValue) || valueCollection.getBy(valueField, currentValue);
          // If it's a potentially non-unique index (such as the by-displayField index)
          // then key lookups yield a Set. Use the first entry as the match.
          if (record instanceof Set) {
            record = [...record][0];
          }
          if (record) {
            // If the incoming value was a matched object, use it to update the record
            if (isObject) {
              record.set(values[i]);
            }
            values[i] = record;
          } else {
            values.splice(i, 1);
            len--;
            i--;
          }
        }
      }
      const noMatches = !values.length;
      // Remove all old values, add new values in one shot.
      const vcGen = valueCollection.generation;
      valueCollection.splice(0, valueCollection.count, values);
      // If we got no matches, onValueCollectionChange will set the _value to null.
      // Tests specify that the _value should be set to the incoming unmatched value.
      // Handle the case that an array was passed.
      if (noMatches) {
        me._value = arrayPassed && value.length === 0 ? null : value;
        // _lastValue has to be updated here to have an actual value for syncInputFieldValue() and syncEmpty() below
        me._lastValue = me._value;
      }
      // If no change has fed through to onValueCollectionChange, just ensure the input matches.
      // Must be done last so that the fallback of using this._value if the passed value did
      // not match a record can be used.
      if (noMatches || valueCollection.generation === vcGen) {
        me.syncInputFieldValue();
      }
      me.syncEmpty();
      // If there were matches, onValueCollectionChange would have triggered the change event.
      // If not, we trigger it here.
      if (noMatches && !me.isConfiguring) {
        me.triggerFieldChange({
          value,
          oldValue,
          userAction: isUserAction,
          valid: me.isValid
        });
      }
    } else {
      if (valueCollection.count) {
        valueCollection.clear();
      } else {
        const oldValue = me._value;
        // Cache the value for use by our change handler next time, and also so that
        // when get value yields null, the fallback to ._value will be correct
        me._value = null;
        me.syncInputFieldValue();
        me.syncEmpty();
        if (!me.isConfiguring) {
          me.triggerFieldChange({
            value,
            oldValue,
            userAction: isUserAction,
            valid: me.isValid
          });
        }
      }
    }
    me._lastValue = me._value;
  }
  hasChanged(oldValue, newValue) {
    if (this.multiSelect) {
      return !ObjectHelper.isEqual(oldValue, newValue);
    }
    return super.hasChanged(...arguments);
  }
  onComboStoreChange({
    action
  }) {
    // Local filter-on-type is happening, do not sync the input value.
    if (action !== 'filter') {
      this.syncInputFieldValue(true);
    }
  }
  syncInputFieldValue(skipHighlight) {
    // We only sync the input's value if we are not using the chip view (DependencyField).
    // If we are multiselecting, our value is represented by a ChipView.
    // The ChipView automatically syncs itself with our valueCollection.
    // If the valueCollection gets updated silently, we may still need this function.
    if (this.usesChipView) {
      var _this$chipView;
      (_this$chipView = this.chipView) === null || _this$chipView === void 0 ? void 0 : _this$chipView.refresh();
    } else {
      super.syncInputFieldValue(skipHighlight);
    }
  }
  get usesChipView() {
    return Boolean(this.multiSelect && this._chipView);
  }
  /**
   * Returns `true` if this field has no selected records.
   * @property {Boolean}
   * @readonly
   */
  get isEmpty() {
    return this.valueCollection.count === 0;
  }
  get inputValue() {
    // This must be evaluated first, and NOT moved to be directly used as the
    // second expression in the ternary. If called during configuration, this
    // will import the configured value from the config object and ensure the
    // value is matched against the store, and that the "selected" property is set.
    const me = this;
    let result = me.selected ? me.selected[me.displayField] : me.value;
    if (me.displayValueRenderer) {
      result = me.callback(me.displayValueRenderer, me, [me.selected, me]);
    }
    return result == null ? '' : result;
  }
  get nonEditableClickTarget() {
    var _this$chipView2;
    return this.multiSelect && ((_this$chipView2 = this.chipView) === null || _this$chipView2 === void 0 ? void 0 : _this$chipView2.element) || super.nonEditableClickTarget;
  }
  /**
   * A {@link Core/util/Collection} which holds the currently selected records
   * from the store which dictates this field's value.
   *
   * Usually, this will contain one record, the record selected.
   *
   * When {@link #config-multiSelect} is `true`, there may be several records selected.
   * @member {Core.util.Collection} valueCollection
   * @readonly
   */
  changeValueCollection(valueCollection, oldValueCollection) {
    oldValueCollection === null || oldValueCollection === void 0 ? void 0 : oldValueCollection.destroy();
    if (valueCollection) {
      if (!valueCollection.isCollection) {
        valueCollection = new Collection({
          internalListeners: {
            noChange: 'onValueCollectionNoChange',
            change: 'onValueCollectionChange',
            prio: -1000,
            // The ChipView must react to changes first.
            thisObj: this
          }
        });
      }
      return valueCollection;
    }
  }
  changePrimaryFilter(primaryFilter) {
    if (primaryFilter.isCollectionFilter) {
      primaryFilter.setConfig({
        disabled: true,
        property: this.displayField,
        operator: this.filterOperator,
        caseSensitive: this.caseSensitive
      });
    } else {
      if (typeof primaryFilter === 'function') {
        primaryFilter = {
          filterBy: primaryFilter
        };
      }
      // This is the filter that performs filtering on typing.
      primaryFilter = new CollectionFilter({
        // Need an id to replace any existing combo filter on the store.
        id: 'primary',
        disabled: true,
        property: this.displayField,
        operator: this.filterOperator,
        caseSensitive: this.caseSensitive,
        ...primaryFilter
      });
    }
    return primaryFilter;
  }
  changeStore(store) {
    const me = this,
      storeFilters = [],
      {
        valueCollection,
        keyStrokeFilterDelay,
        filterParamName
      } = me;
    if (Array.isArray(store)) {
      me.items = store;
      return;
    }
    let remoteFilter;
    if (store) {
      // We are using an Store which we do not own.
      if (store.isStore) {
        const sharedFilter = store.filters.get('primary');
        if (me.remoteFilter) {
          store.filterParamName = filterParamName;
        }
        remoteFilter = store.remoteFilter || store.restfulFilter;
        // If the Store is from another combo, we also share the incoming filter
        if (sharedFilter) {
          me.primaryFilter = sharedFilter;
        } else {
          storeFilters.push(me.primaryFilter);
        }
      } else {
        if (typeof store === 'string') {
          store = Store.getStore(store);
        } else {
          store = new (store.readUrl ? AjaxStore : Store)(store);
          me.destroyStore = true;
        }
        remoteFilter = me.remoteFilter || store.restfulFilter;
        if (remoteFilter && filterParamName) {
          store.filterParamName = filterParamName;
          if (me.encodeFilterParams) {
            store.encodeFilterParams = me.encodeFilterParams;
          }
        }
        // We add our primary filter to stores we own
        storeFilters.push(me.primaryFilter);
      }
      // If no value field provided, read it off of the Store's modelClass
      // Unless we want to use full record as the value
      if (!me.valueField && !me.usingRecordAsValue) {
        me.valueField = store.modelClass.idField;
      }
      // Filtering of already-selected values is always done locally.
      // So if we are filtering remotely, add filter directly to Store's Collection
      if (me.filterSelected) {
        const selectedItemsFilter = r => !me.containsFocus || !valueCollection.includes(r);
        if (remoteFilter) {
          store.storage.autoFilter = true;
          store.storage.addFilter({
            id: `${me.id}-selected-filter`,
            filterBy: selectedItemsFilter
          });
        } else {
          storeFilters.push(selectedItemsFilter);
          store.reapplyFilterOnAdd = true;
        }
      }
      // Allow fast lookup in the valueCollection by value or displayed value.
      // We add these now because we are now guaranteed to have inferred
      // displayField and startField from any passed items array items is
      // promoted to a Store.
      valueCollection.addIndex({
        property: me.displayField,
        unique: false
      });
      valueCollection.addIndex({
        property: me.valueField,
        unique: true
      });
      // *Add* our filters in case the store already has its own filters
      storeFilters.forEach(f => store.addFilter(f, true));
      // If there's no configured delay, use sensible defaults.
      // AjaxStore, we don't want a network request fired off on every single keystroke.
      // Local store, delay it just a little to save data and DOM churn.
      if (remoteFilter) {
        // We enforce at least a 300ms delay when firing off network requests
        me.keyStrokeFilterDelay = Math.max(300, keyStrokeFilterDelay || 0);
      } else {
        me.keyStrokeFilterDelay = keyStrokeFilterDelay ?? 10;
      }
    }
    return store;
  }
  updateStore(store, oldStore) {
    const me = this,
      {
        _picker
      } = me;
    let storeListeners;
    if (me.destroyStore && oldStore) {
      oldStore.destroy();
    }
    if (_picker) {
      _picker.store = store;
    }
    // Allow fast lookup by value or displayed value
    store.storage.addIndex({
      property: me.displayField,
      unique: false
    });
    store.storage.addIndex({
      property: me.valueField,
      unique: true
    });
    storeListeners = {
      filter: 'onStoreFilter'
    };
    if (me.displayValueRenderer) {
      (storeListeners || (storeListeners = {})).change = 'onComboStoreChange';
    }
    me.detachListeners('store');
    // Update selected records collection to match what is in Store.
    // Incoming records of the same id will be replaced in the valueCollection.
    // Records in the valueCollection which are no longer in the Store will
    // be removed.
    (store === null || store === void 0 ? void 0 : store.storage) && me.valueCollection.match(store.storage);
    // Ensure UI matches potential new record values.
    me.syncInputFieldValue();
    if (storeListeners) {
      storeListeners.name = 'store';
      storeListeners.thisObj = me;
      store.ion(storeListeners);
    }
  }
  get remoteFilter() {
    var _this$_store;
    // Don't use "this.store" since we need to run during changeStore()
    return Boolean(this.filterParamName || ((_this$_store = this._store) === null || _this$_store === void 0 ? void 0 : _this$_store.restfulFilter));
  }
  /**
   * Get selected record.
   * @property {Core.data.Model[]}
   * @readonly
   */
  get record() {
    return this.selected;
  }
  /**
   * Get the selected record(s).
   * @property {Core.data.Model[]}
   * @readonly
   */
  get records() {
    return this.valueCollection.values.slice();
  }
  get selected() {
    const {
      store
    } = this;
    // If multiSelect, choose as a single selected value the item which comes first
    // in the dropdown.
    return this.multiSelect ? this.valueCollection.values.slice().sort((l, r) => store.indexOf(l) - store.indexOf(r))[0] : this.valueCollection.first;
  }
  //endregion
  //region Value handling
  /**
   * Check if field value is valid
   * @internal
   */
  onEditComplete() {
    const me = this,
      selectionCount = me.valueCollection.count;
    super.onEditComplete();
    // Ensure the input area matches the selected value
    if (selectionCount) {
      me.clearError(errorValidateFilter);
      me.syncInputFieldValue();
    }
    if (me.required && !selectionCount) {
      me.setError(errorFieldRequired);
    }
  }
  //endregion
  //region Events
  /**
   * User clicked trigger icon, toggle list.
   * @private
   */
  onTriggerClick(event) {
    const me = this,
      activatePicker = ('key' in event);
    // Bail out if enter key is required to trigger a filter
    if (me.ignoreTriggerClick || me.remoteFilter && me.filterOnEnter) {
      return;
    }
    if (me.pickerVisible) {
      me.hidePicker();
    } else if (!me.readOnly && !me.disabled) {
      var _me$triggerAction;
      switch ((_me$triggerAction = me.triggerAction) === null || _me$triggerAction === void 0 ? void 0 : _me$triggerAction.toLowerCase()) {
        case 'all':
          me.doFilter(null, activatePicker);
          break;
        case 'last':
          me.doFilter(me.lastQuery, activatePicker);
          break;
        default:
          me.doFilter(me.input.value, activatePicker);
      }
    }
  }
  /**
   * User types into input field in editable combo, show list and filter it.
   * @private
   */
  internalOnInput(event) {
    const me = this;
    me.syncEmpty();
    me.syncInputWidth();
    // This method may be buffered by keyStrokeFilterDelay milliseconds
    me.filterOnInput(event);
    /**
     * User typed into the field. Please note that the value attached to this event is the raw input field value and
     * not the combos value
     * @event input
     * @param {Core.widget.Combo} source The combo
     * @param {String} value Raw input value
     */
    me.trigger('input', {
      value: me.input.value,
      event
    });
  }
  filterOnInput(event) {
    const me = this,
      {
        value
      } = event.type === 'input' ? event.target : me.input,
      inputLen = value.length;
    me.inputting = true;
    // If the picker is inline, as opposed to a floating popup,
    // or the minChars limit is met (or its a filter on enter gesture)
    // then perform the filtering.
    if (me.inlinePicker || inputLen >= me.minChars && (!me.filterOnEnter || event.key === 'Enter')) {
      me.doFilter(value);
    } else {
      // During typing, the field is invalid
      if (me.validateFilter && !me.remoteFilter) {
        me[inputLen ? 'setError' : 'clearError'](errorValidateFilter);
      }
      me.hidePicker();
    }
    me.inputting = false;
  }
  syncInputWidth() {
    const me = this;
    if (me.usesChipView) {
      const input = me.input,
        // padding on the input el won't change, so cache the measurement:
        inputPadding = me._inputPadding || (me._inputPadding = DomHelper.getEdgeSize(input, 'padding', 'lr')),
        value = input.value || '',
        width =
        // +'W' to avoid text getting clipped or horizontal scrolling
        DomHelper.measureText(value + 'W', input, false, me.element) + inputPadding.width;
      // Normally the input is given "flex: 1 1 0px" so it will fill the space
      // so we just need to adjust the flex-basis to ensure the input is at least
      // as long as the text. Since it is also flex-shrink, it will not become
      // any larger than one "row".
      input.style.flex = `1 1 ${Math.ceil(width)}px`;
    }
  }
  doFilter(queryString, activatePicker) {
    var _me$filterPromise;
    const me = this,
      {
        store,
        // Force the lazy config to create picker since the List needs to add its beforeLoad listener
        picker
      } = me,
      disableFilter = queryString == null || queryString === '';
    me.lastQuery = queryString;
    me.primaryFilter.setConfig({
      value: queryString,
      disabled: disableFilter
    });
    if (me.remoteFilter) {
      store.clear(true);
    }
    const onAfterFilter = () => {
      const {
        navigator,
        isVisible
      } = picker;
      if (store.count) {
        // If we are filtering, activate the first match
        if (!disableFilter && navigator) {
          navigator.activeItem = 0;
        }
      }
      // If we were actively *locally* filtering on a string but there were no matches...
      //  Ensure there's no orphaned active item in the picker.
      //  If we are validateFilter: true, then mark as invalid even though we
      //  may have an underlying valid selected value.
      else if (!me.remoteFilter && !disableFilter) {
        if (navigator) {
          navigator.activeItem = null;
        }
        if (me.validateFilter) {
          me.setError(errorValidateFilter);
        }
      }
      // filtering will have changed the store count.
      // If the height was set due to constraining, this may need to be released.
      isVisible && picker.realign();
    };
    // We have the property 'filterPromise' while a filter operation is in flight.
    (_me$filterPromise = me.filterPromise = store.filter()) === null || _me$filterPromise === void 0 ? void 0 : _me$filterPromise.then(() => {
      me.filterPromise = null;
      onAfterFilter();
    });
    if (!me.inlinePicker) {
      if (picker !== null && picker !== void 0 && picker.isVisible) {
        // If aligned above, filtering will change its height so will need realigning
        if (picker.lastAlignSpec.zone === 0) {
          picker.realign();
        }
      } else {
        me.showPicker(activatePicker);
      }
    }
    if (!me.filterPromise) {
      onAfterFilter();
    }
  }
  onStoreFilter({
    source: store
  }) {
    const me = this,
      picker = me._picker,
      dataset = picker === null || picker === void 0 ? void 0 : picker.element.dataset,
      {
        count
      } = store;
    if (me.remoteFilter) {
      // If we are filtering, activate the first match
      if (count) {
        if (picker) {
          picker.navigator.activeItem = 0;
        }
      }
      // Invalid if no matches after filtering
      else {
        if (me.validateFilter) {
          me.setError(errorValidateFilter);
        }
      }
      // If we have selection, evict selected items from the newly remote-filtered list
      if (me.filterSelected && me.valueCollection.count) {
        store.storage.onFiltersChanged({
          action: 'splice',
          oldCount: 1
        });
        // Store does not react to Collection filtering yet because it does its own filtering and
        // then fires its own event. So we have to refresh the picker to hide the selected items.
        if (picker) {
          picker.refresh();
        }
      }
    }
    // If createOnUnmatched, we add a hint to add the value
    if (dataset) {
      if (me.createOnUnmatched && !count) {
        dataset.addNewValue = me.L('L{addNewValue}')(me.primaryFilter.value);
      } else {
        dataset === null || dataset === void 0 ? true : delete dataset.addNewValue;
      }
    }
  }
  /**
   * This reacts to our {@link #property-valueCollection} being mutated in any way.
   * The `change`, `select` and `action` events are fired here.
   *
   * This could happen in four ways:
   *
   *  - User selected or deselected an item in the dropdown list.
   *  - `set value` changes the content.
   *  - The {@link #config-multiSelect} Chip view (which uses this in its store) deletes a record.
   *  - The application programmatically mutates the {@link #property-valueCollection}.
   *
   * @private
   */
  onValueCollectionChange({
    source: valueCollection
  }) {
    const me = this,
      {
        multiSelect,
        _picker
      } = me,
      hidePicker = me.hidePickerOnSelect ?? !multiSelect,
      record = multiSelect ? valueCollection.values.slice() : valueCollection.first,
      records = valueCollection.values.slice(),
      isUserAction = me._isUserAction || (_picker === null || _picker === void 0 ? void 0 : _picker._isUserAction) || hidePicker && me.pickerVisible || false,
      oldValue = me._value;
    if (hidePicker) {
      me.hidePicker();
    }
    if (!valueCollection.count && me.required) {
      me.setError(errorFieldRequired);
    } else {
      me.clearError(errorFieldRequired);
      me.clearError(errorValidateFilter);
    }
    if (me.validateFilter && record) {
      me.clearError(errorValidateFilter);
    }
    // Re-evaluate *local* filtering so that selected items are filtered out of the dropdown.
    // For remote filtering, we programmatically add a filter to the store's storage
    if (me.filterSelected) {
      if (me.remoteFilter) {
        me.store.storage.onFiltersChanged({
          action: 'splice',
          oldCount: 1
        });
        // Store does not react to Collection filtering yet because it does its own filtering and
        // then fires its own event. So we have to refresh the picker to hide the selected items.
        if (me._picker) {
          me._picker.refresh();
        }
      } else {
        me.store.filter();
      }
    }
    // Clear the cached value so that there's no fallback when we read back the value below
    me._value = null;
    me._lastValue = null;
    // Cache the value for use by our change handler next time, and also so that
    // if we just cleared the valueCollection, the fallback to ._value will be correct
    const value = me.cacheCurrentValue(me.value);
    me.syncInputFieldValue();
    me.syncEmpty();
    if (!me.isConfiguring) {
      var _me$trigger;
      me.triggerFieldChange({
        value,
        oldValue,
        userAction: isUserAction,
        valid: me.isValid
      });
      /**
       * An item in the list was selected
       * @event select
       * @param {Core.widget.Combo} source The combo
       * @param {Core.data.Model} record Selected record
       * @param {Core.data.Model[]} records Selected records as an array if {@link #config-multiSelect} is `true`
       * @param {Boolean} userAction `true` if the value change is due to user interaction.
       */
      (_me$trigger = me.trigger) === null || _me$trigger === void 0 ? void 0 : _me$trigger.call(me, 'select', {
        record,
        records,
        userAction: isUserAction
      });
      /**
       * The default action was performed (an item in the list was selected)
       * @event action
       * @param {Core.widget.Combo} source The combo
       * @param {*} value The {@link #config-valueField value} of the selected record
       * @param {Core.data.Model} record Selected record
       * @param {Core.data.Model[]} records Selected records as an array if {@link #config-multiSelect} is `true`
       * @param {Boolean} userAction `true` if the value change is due to user interaction.
       */
      if (me.defaultAction === 'select') {
        me.trigger('action', {
          value,
          record,
          records,
          userAction: isUserAction
        });
      }
    }
  }
  // Caching a copy of current value, which can be changed by subclasses (see AssignmentField for reference)
  cacheCurrentValue(v) {
    return this._value = v;
  }
  /**
   * This listens for when a record from the list is selected, but is already part of
   * the selection and so the {@link #property-valueCollection} rejects that as a no-op.
   * At this point, the user will still expect the picker to hide.
   * @param {Object} event The noChange event containing the splice parameters
   * @private
   */
  onValueCollectionNoChange({
    toAdd
  }) {
    if (!this.inlinePicker && !this.multiSelect && toAdd.length && this.pickerVisible) {
      this.picker.hide();
    }
  }
  //endregion
  //region Picker
  showPicker() {
    const me = this,
      {
        picker
      } = me;
    if (me.readOnly || me.inlinePicker) {
      return;
    }
    picker.multiSelect = me.multiSelect;
    super.showPicker(...arguments);
    // Once we have access to the anchor size, overlay the anchor pointer over the target if configured to do so.
    if (me.overlayAnchor && !picker.align.offset) {
      picker.align.offset = -picker.anchorSize[1];
      picker.realign();
    }
    // Picker type might have been reconfigured from being a List
    if (picker.restoreActiveItem) {
      // Activate and make visible an active item.
      // If we are multiSelect, only pass the selected value if the user has not
      // previously navigated to her item of interest.
      // If single select, it's always value to navigate to the value item.
      // In either case, if there is no target, navigate to item 0.
      if (me.multiSelect) {
        var _picker$navigator;
        picker.restoreActiveItem(((_picker$navigator = picker.navigator) === null || _picker$navigator === void 0 ? void 0 : _picker$navigator.previousActiveItem) || me.selected || 0, true);
      } else {
        picker.restoreActiveItem(me.selected || 0, true);
      }
    }
    me.input.focus();
  }
  /**
   * Creates default picker widget
   *
   * @internal
   */
  changePicker(picker, oldPicker) {
    var _picker2;
    const me = this,
      pickerWidth = me.pickerWidth || ((_picker2 = picker) === null || _picker2 === void 0 ? void 0 : _picker2.width),
      config = List.mergeConfigs({
        owner: me,
        store: me.store,
        selected: me.valueCollection,
        multiSelect: me.multiSelect,
        cls: me.listCls,
        displayField: me.displayField,
        forElement: me[me.pickerAlignElement],
        align: {
          matchSize: pickerWidth == null,
          anchor: me.overlayAnchor,
          target: me[me.pickerAlignElement],
          // Reasonable minimal height to fit few combo items below the combo.
          // When height is not enough, list will appear on top. That works for windows higher than 280px,
          // worrying about shorter windows sounds overkill.
          // We cannot use relative measures here, each combo list item is ~40px high
          minHeight: me.inlinePicker ? null : Math.min(3, me.store.count) * 40
        },
        [me.listItemTpl ? 'itemTpl' : undefined]: me.listItemTpl,
        width: pickerWidth,
        navigator: {
          keyEventTarget: me.input
        }
      }, picker);
    if (me.inlinePicker) {
      Object.assign(config, {
        floating: false,
        align: null,
        activateOnMouseover: false,
        maxHeight: null,
        appendTo: me.element
      });
    }
    picker = List.reconfigure(oldPicker, picker ? config : null, me);
    if (picker) {
      picker.element.classList.add('b-combo-picker');
      picker.element.dataset.emptyText = me.emptyText ? me.L(me.emptyText) : me.L('L{noResults}');
      // We have to handle the click on "Add new value" when createOnUnmatched is set
      // because it's not a real list item, it's a repurposing of the .b-empty:after pseudo el.
      picker.ion({
        navigate: 'onPickerNavigate',
        thisObj: me
      });
      // "Add new *" option is rendered as a ::before element, therefore there would be no navigation event.
      // We need separate mousedown listener on the list element
      EventHelper.on({
        element: picker.element,
        pointerdown: event => me.onPickerNavigate({
          event
        }),
        thisObj: me
      });
    }
    return picker;
  }
  onPickerNavigate({
    event
  }) {
    // It's a click on the "Add new value" prompt
    if (event.target.matches('[data-add-new-value]')) {
      this.addNewRecord(this.primaryFilter.value);
    }
  }
  onPickerHide() {
    const me = this;
    super.onPickerHide();
    // https://app.assembla.com/spaces/bryntum/tickets/7736
    if (me.multiSelect && me.clearTextOnPickerHide) {
      me.input.value = '';
    }
  }
  //endregion
  async internalOnKeyEvent(keyEvent) {
    const me = this,
      value = me.input[me.inputValueAttr],
      inputLen = value.length,
      {
        key
      } = keyEvent,
      {
        store,
        _picker: picker,
        multiSelect
      } = me;
    // Typing the multiValueSeparator character selects the active list item, or
    // if there is no active item, and we are creating new records, creates the selected item.
    // The picker may not be a List with a Navigator.
    // We can only honour this functionality for normal, unoverridden List Pickers.
    // Some subclasses use Grids as pickers.
    if (keyEvent.type === 'keydown' && picker !== null && picker !== void 0 && picker.isVisible && picker.navigator) {
      const {
        activeItem
      } = picker.navigator;
      // If they type `,` in a multiSelect, it means add the active matched item if any
      if (activeItem && multiSelect && key === me.multiValueSeparator) {
        me.input.value = '';
        me.primaryFilter.setConfig({
          value: '',
          disabled: true
        });
        store.filter();
        picker.onItemClick(activeItem, keyEvent);
        picker.hide();
        keyEvent.preventDefault();
        return;
      }
      // Else, if there's no matched item and we are creating new records for unmatched keys
      // then `,` and Enter add a new record with the string as the displayField
      if (!activeItem && me.createOnUnmatched && (multiSelect && key === me.multiValueSeparator || key === 'Enter')) {
        keyEvent.preventDefault();
        await me.addNewRecord(value);
        return;
      }
    }
    super.internalOnKeyEvent(...arguments);
    if (keyEvent.type === 'keydown' && key === 'Enter' && me.filterOnEnter && inputLen >= me.minChars) {
      keyEvent.stopPropagation();
      me.filterOnInput.now(keyEvent);
    }
  }
  async addNewRecord(value) {
    const me = this,
      {
        store,
        _picker: picker,
        valueCollection,
        multiSelect,
        primaryFilter
      } = me,
      remoteAutoCommit = store.remoteFilter && store.autoCommit;
    // We have to wait for remote filtering to finish before we add a new record to the added Bag
    // because store load (filter is a load) clears added records, and if the load returned during
    // the create commit that would invalidate the upcoming create return values by leaving no added
    // records to update with correct new IDs, and so the new record would appear to still
    // be a phantom, and therefore we would throw an error that the server has not accepted the addition..
    if (me.filterPromise) {
      await me.filterPromise;
    }
    // We can do this early if it's *NOT* a remote filtered, auto-committing AjaxStore.
    // If remote filtered and autoCommit, this will instigate a load which cannot be
    // concurrent with the upcoming auto commit.
    if (!remoteAutoCommit) {
      primaryFilter.setConfig({
        value: '',
        disabled: true
      });
      store.filter();
    }
    const [newRecord] = store.add(me.callback(me.createOnUnmatched, me, [value, me]));
    // It's an AjaxStore which is autoCommitting the new record to its createUrl
    // We wait to see if it's successful.
    if (store.isCommitting) {
      let error;
      try {
        await store.commitPromise;
      } catch (exception) {
        var _exception$response, _exception$response$p;
        error = (_exception$response = exception.response) === null || _exception$response === void 0 ? void 0 : (_exception$response$p = _exception$response.parsedJson) === null || _exception$response$p === void 0 ? void 0 : _exception$response$p.error;
      }
      // If the sync from the server did not return a concrete id, the record gets
      // left as phantom, so we have to remove it.
      if (newRecord.isPhantom) {
        me.clearError();
        me.setError(error || errorRecordNotCommitted, false, true);
        store.remove(newRecord);
        // AjaxStore adds to its removed Bag here because it clears down the addded Bag even
        // if not all added records were successfully synced, and remove adds to removed Bag
        // if the  record is *not* in the added Bag.
        store.removed.remove(newRecord);
      }
    }
    // Have to wait until now if its a remote filtered, auto-committing AjaxStore.
    if (remoteAutoCommit) {
      primaryFilter.setConfig({
        value: '',
        disabled: true
      });
      store.filter();
    }
    me.input.value = '';
    // If an AjaxStore's sync of the add failed, do not select the new record
    if (store.includes(newRecord)) {
      // Append for multiSelect, or replace for non-multiSelect
      valueCollection.splice(multiSelect ? valueCollection.count : 0, multiSelect ? 0 : valueCollection.count, newRecord);
    }
    picker === null || picker === void 0 ? void 0 : picker.hide();
  }
  changeCreateOnUnmatched(createOnUnmatched) {
    if (createOnUnmatched === true) {
      createOnUnmatched = this.defaultRecordCreater;
    }
    return createOnUnmatched;
  }
  defaultRecordCreater(value) {
    return this.store.createRecord({
      [this.displayField]: value
    });
  }
  updateLocalization() {
    super.updateLocalization();
    const me = this,
      {
        displayField
      } = me;
    let {
      localizedDisplayFieldsMap
    } = me;
    if (me.localizeDisplayFields === true) {
      // Create a map in which to save the original locale strings.
      if (!localizedDisplayFieldsMap) {
        me.localizedDisplayFieldsMap = localizedDisplayFieldsMap = new Map();
      }
      if (!me.store && me.buildItems) {
        me.items = me.buildItems();
      }
      for (const item of me.items) {
        // Uses .id an unique identifier
        if (item.id) {
          var _item$displayField;
          let localeString = localizedDisplayFieldsMap.get(item.id);
          // If not already saved, save the locale string in the map
          if (!localeString && (_item$displayField = item[displayField]) !== null && _item$displayField !== void 0 && _item$displayField.startsWith('L{')) {
            localeString = item[displayField];
            localizedDisplayFieldsMap.set(item.id, localeString);
          }
          // If a locale string is provided, localize it and set it to items display field
          if (localeString) {
            item[displayField] = me.L(localeString);
          }
        }
      }
      // Update the current value of the combo
      me.syncInputFieldValue();
    }
  }
}
class ComboChipView extends ChipView {
  static get $name() {
    return 'ComboChipView';
  }
  static get type() {
    return 'combochipview';
  }
  static get defaultConfig() {
    return {
      closeHandler: 'up.onChipClose',
      itemsFocusable: false,
      multiSelect: true,
      itemTpl(record) {
        return StringHelper.encodeHtml(record.getValue(this.owner.displayField));
      },
      scrollable: {
        overflowY: 'auto'
      }
    };
  }
}
class ComboChipNavigator extends Navigator {
  static get $name() {
    return 'ComboChipNavigator';
  }
  // Factoryable type name
  static get type() {
    return 'combochipnavigator';
  }
  static get configurable() {
    return {
      allowShiftKey: true
    };
  }
  onTargetClick(clickEvent) {
    const me = this,
      item = clickEvent.target.closest(me.itemSelector);
    // Only activate the item if the click was not on the close icon
    if (item && !clickEvent.target.classList.contains('b-close-icon')) {
      if (!clickEvent.shiftKey && !item.contains(clickEvent.target.closest('[data-noselect]'))) {
        me.ownerCmp.selected.clear();
      }
      // Our own updateActiveItem also selects because on superclass *key* navigation
      // (which is async on scroll end), it sets activeItem, and we select at that time.
      // So set a flag which disables this.
      me.inClickHandler = true;
      me.activeItem = item;
      me.inClickHandler = false;
    }
  }
  onKeyDown(keyEvent) {
    // ENTER does not toggle selectedness in a ChipView.
    // ChipView's selection is bound to navigation.
    // Ignore key presses not at the edge of the input field, those are handled by the input field (to avoid
    // left/right from both moving the cursor and navigating the chips)
    if (keyEvent.key !== 'Enter' && !keyEvent.target.selectionStart && !keyEvent.target.selectionEnd) {
      super.onKeyDown(keyEvent);
    }
  }
  updateActiveItem(activeItem, oldActiveItem) {
    const chipView = this.ownerCmp;
    super.updateActiveItem(activeItem, oldActiveItem);
    // Selection simply follows navigation in a ChipView
    if (activeItem && !this.inClickHandler) {
      chipView.selected.add(chipView.getRecordFromElement(activeItem));
    }
  }
  navigatePrevious(keyEvent) {
    const chipView = this.ownerCmp;
    if (chipView.navigator.activeItem && !keyEvent.shiftKey) {
      chipView.selected.clear();
    }
    if (this.previous) {
      super.navigatePrevious(keyEvent);
    } else {
      this.activeItem = null;
    }
  }
  navigateNext(keyEvent) {
    const chipView = this.ownerCmp;
    // SHIFT+navigate preserves selection
    if (chipView.navigator.activeItem && !keyEvent.shiftKey) {
      chipView.selected.clear();
    }
    if (this.next) {
      super.navigateNext(keyEvent);
    } else {
      this.activeItem = null;
    }
  }
}
// Register this widget type and associated classes with their Factories
Combo.initClass();
ComboChipView.initClass();
ComboChipNavigator.initClass();
Combo._$name = 'Combo';

/**
 * @module Core/widget/Checkbox
 */
const whenNotChecked = field => !field.value;
/**
 * Checkbox field, wraps <code>&lt;input type="checkbox"&gt;</code>.
 * Color can be specified and you can optionally configure {@link #config-text}
 * to display in a label to the right of the checkbox in addition to a standard
 * field {@link #config-label}.
 *
 * {@inlineexample Core/widget/Checkbox.js vertical}
 *
 * This field can be used as an {@link Grid.column.Column#config-editor} for the {@link Grid.column.Column}.
 *
 * ## Nested Items
 * A checkbox can also have a {@link #config-container} of additional {@link Core.widget.Container#config-items}. These
 * items can be displayed immediately following the field's label (which is the default when there is only one item) or
 * below the checkbox. This can be controlled using the {@link #config-inline} config.
 *
 * In the demo below notice how additional fields are displayed when the checkboxes are checked:
 *
 * {@inlineexample Core/widget/Checkbox-items.js vertical}
 *
 * @extends Core/widget/Field
 * @classType checkbox
 * @inputfield
 */
class Checkbox extends Field {
  //region Config
  static get $name() {
    return 'Checkbox';
  }
  // Factoryable type name
  static get type() {
    return 'checkbox';
  }
  // Factoryable type alias
  static get alias() {
    return 'check';
  }
  static get configurable() {
    return {
      inputType: 'checkbox',
      /**
       * Specify `true` to automatically {@link Core.widget.FieldContainer#config-collapsed collapse} the field's
       * {@link #config-container} when the field is not {@link #property-checked}.
       *
       * Alternatively, this can be a function that returns the desired `collapse` state when passed the field
       * instance as its one parameter.
       *
       * @config {Boolean|Function}
       * @default false
       */
      autoCollapse: null,
      containerDefaults: {
        syncableConfigs: {
          disabled: field => field.disabled || !field.value
        },
        syncConfigTriggers: {
          autoCollapse: 1,
          value: 1
        }
      },
      /**
       * Get/set label
       * @member {String} name
       */
      /**
       * Text to display on checkbox label
       * @config {String}
       */
      text: '',
      /**
       * The value to provide for this widget in {@link Core.widget.Container#property-values} when it is
       * {@link #property-checked}.
       * A value of `undefined` will cause this widget not to include its value when checked.
       * @config {*}
       * @default
       */
      checkedValue: true,
      /**
       * The value to provide for this widget in {@link Core.widget.Container#property-values} when it is not
       * {@link #property-checked}.
       *
       * A value of `undefined` will cause this widget to not include its value when it is unchecked.
       * @config {*}
       * @default
       */
      uncheckedValue: false,
      /**
       * The checked state. The same as `value`.
       * @config {Boolean} checked
       */
      /**
       * Checkbox color, must have match in CSS
       * @config {String}
       */
      color: null,
      /**
       * Get/set value
       * @member {String} value
       */
      /**
       * Sets input fields value attribute
       * @config {String}
       */
      value: '',
      toggleGroup: null,
      localizableProperties: ['label', 'text']
    };
  }
  //endregion
  //region Init
  construct(config) {
    // Convert checked to value so that initializing getter can read it if requested prior to trying to set it.
    if ('checked' in config) {
      config = ObjectHelper.assign({}, config); // copy inherited properties unlike Object.assign()
      config.value = config.checked;
      delete config.checked;
    }
    super.construct(config);
    this.syncHasText();
  }
  get textLabelCls() {
    return 'b-checkbox-label';
  }
  // Implementation needed at this level because it has two inner elements in its inputWrap
  get innerElements() {
    return [this.inputElement, {
      tag: 'label',
      class: this.textLabelCls,
      for: `${this.id}-input`,
      reference: 'textLabel',
      html: this.text || ''
    }];
  }
  get inputElement() {
    const config = super.inputElement;
    if (this.toggleGroup) {
      config.dataset = {
        group: this.toggleGroup
      };
    }
    config.listeners = {
      click: 'internalOnClick',
      change: 'internalOnChange',
      input: 'internalOnInput'
    };
    return config;
  }
  //endregion
  //region Toggle
  /**
   * Get/set checked state. Equivalent to `value` config.
   * @property {Boolean}
   */
  get checked() {
    return this.value;
  }
  set checked(value) {
    this.value = value;
  }
  syncHasText() {
    this.element.classList[this.text ? 'add' : 'remove']('b-text');
  }
  updateText(value) {
    if (this.textLabel) {
      this.syncHasText();
      this.textLabel.innerHTML = value;
    }
  }
  afterSyncChildConfigs(container) {
    super.afterSyncChildConfigs(container);
    let {
      autoCollapse
    } = this;
    if (autoCollapse) {
      autoCollapse = autoCollapse === true ? whenNotChecked : autoCollapse;
      container.collapsed = autoCollapse(this);
    }
  }
  assignFieldValue(values, key, value) {
    this.value = value === this.checkedValue || (value === this.uncheckedValue ? false : null);
  }
  fetchInputValue() {
    if (!this.readOnly) {
      this.value = this.input.checked;
    }
  }
  gatherValue(values) {
    var _values$valueName;
    const me = this,
      value = me.value ? me.checkedValue : me.uncheckedValue,
      storedValue = value !== undefined,
      {
        valueName
      } = me;
    if (storedValue) {
      values[valueName] = value;
    }
    me.gatherValues(values, storedValue);
    if (value === true && ((_values$valueName = values[valueName]) === null || _values$valueName === void 0 ? void 0 : _values$valueName.value) === value) {
      delete values[valueName].value;
    }
  }
  changeValue(value) {
    return value === 'false' ? false : Boolean(value);
  }
  updateValue(value) {
    var _me$container;
    const me = this,
      changed = me.input.checked !== value;
    me.input.checked = value;
    (_me$container = me.container) === null || _me$container === void 0 ? void 0 : _me$container.syncChildConfigs();
    if (changed && !me.inputting && !me.isConfiguring) {
      me.uncheckToggleGroupMembers();
      // The change event does not fire on programmatic change of input.
      me.triggerChange(false);
    }
  }
  get inputValueAttr() {
    return 'checked';
  }
  updateColor(value, was) {
    const classes = this.element.classList;
    if (was) {
      classes.remove(was);
    }
    if (value) {
      classes.add(value);
    }
  }
  getToggleGroupMembers() {
    const me = this,
      {
        checked,
        toggleGroup,
        input: checkedElement,
        type
      } = me,
      result = [];
    if (checked && toggleGroup) {
      DomHelper.forEachSelector(me.rootElement, `input[type=${type}][data-group=${toggleGroup}]`, inputEl => {
        if (inputEl !== checkedElement) {
          const partnerCheckbox = Widget.fromElement(inputEl);
          partnerCheckbox && result.push(partnerCheckbox);
        }
      });
    }
    return result;
  }
  uncheckToggleGroupMembers() {
    if (this.checked && this.toggleGroup) {
      this.getToggleGroupMembers().forEach(widget => widget.checked = false);
    }
  }
  /**
   * Check the box
   */
  check() {
    this.checked = true;
  }
  /**
   * Uncheck the box
   */
  uncheck() {
    this.checked = false;
  }
  /**
   * Toggle checked state. If you want to force a certain state, assign to {@link #property-checked} instead.
   */
  toggle() {
    this.checked = !this.checked;
  }
  //endregion
  //region Events
  internalOnClick(event) {
    // Native checkboxes has no readonly attribute, we prevent toggling it here instead
    if (this.readOnly) {
      event.preventDefault();
      return false;
    }
    /**
     * Fires when the checkbox is clicked
     * @event click
     * @param {Core.widget.Checkbox} source The checkbox
     * @param {Event} event DOM event
     */
    return this.trigger('click', {
      event
    });
  }
  /**
   * Triggers events when user toggles the checkbox
   * @fires beforeChange
   * @fires change
   * @fires action
   * @private
   */
  internalOnChange(event) {
    const me = this;
    // Chrome somehow sets checked state when re-enabling, have to reset that
    if (me.readOnly && me.value !== me.input.checked) {
      me.input.checked = me.value;
      return;
    }
    me.value = me.input.checked;
    if (!me.inputting) {
      me.inputting = true;
      me.triggerChange(true);
      me.inputting = false;
    }
  }
  // Need to catch changes even if readOnly, because of chrome behaviour when re-enabling
  updateInputReadOnly(readOnly) {}
  /**
   * Triggers events when checked state is changed
   * @fires beforeChange
   * @fires change
   * @fires action
   * @private
   */
  triggerChange(userAction) {
    const me = this,
      {
        checked
      } = me.input;
    /**
     * Fired before checkbox is toggled. Returning false from a listener prevents the checkbox from being toggled.
     * @event beforeChange
     * @preventable
     * @param {Core.widget.Checkbox} source Checkbox
     * @param {Boolean} checked Checked or not
     */
    /**
     * Fired when checkbox is toggled
     * @event change
     * @param {Core.widget.Checkbox} source Checkbox
     * @param {Boolean} checked Checked or not
     */
    // Prevent uncheck if this checkbox is part of a toggleGroup (radio-button mode) ..also ensure the group has
    // visible active members
    const eventObject = {
        checked,
        value: checked,
        userAction,
        valid: true
      },
      prevented = !checked && userAction && me.toggleGroup && me.getToggleGroupMembers().filter(widget => widget.isVisible && !widget.disabled).length ||
      // Since Widget has Events mixed in configured with 'callOnFunctions' this will also call onBeforeChange,
      // onChange and onAction
      me.trigger('beforeChange', eventObject) === false;
    // If prevented need to rollback the checkbox input
    if (prevented) {
      // Input change is not preventable, so need to revert the changes
      // The change event does not fire on programmatic change of input, so no need to suspend
      me.input.checked = me._value = !checked;
    } else {
      me.triggerFieldChange(eventObject, false);
      if (userAction) {
        me.uncheckToggleGroupMembers();
      }
      /**
       * User performed the default action (toggled the checkbox)
       * @event action
       * @param {Core.widget.Checkbox} source Checkbox
       * @param {Boolean} checked Checked or not
       */
      me.trigger('action', eventObject);
      me.trigger('change', eventObject);
      return true;
    }
  }
  //endregion
}
// Register this widget type with its Factory
Checkbox.initClass();
Checkbox._$name = 'Checkbox';

/**
 * @module Core/widget/ColorPicker
 */
/**
 * A color picker that displays a list of {@link #config-colors} which the user can select by using mouse or keyboard.
 *
 * {@inlineexample Core/widget/ColorPicker.js}
 *
 * ```javascript
 * new ColorPicker({
 *    appendTo : 'container',
 *    width    : '10em',
 *    colorSelected() {
 *        console.log(...arguments);
 *    }
 * });
 * ```
 *
 * @classType colorpicker
 *
 * @extends Core/widget/List
 */
class ColorPicker extends List {
  static $name = 'ColorPicker';
  static type = 'colorpicker';
  static configurable = {
    itemsFocusable: false,
    navigator: {
      focusCls: 'b-color-active'
    },
    itemWrapperTpl(record, i) {
      const {
          selected
        } = this,
        {
          color,
          text
        } = record,
        colorClassName = this.getColorClassName(color);
      return TemplateHelper.tpl`
                    <li
                        class="${this.getItemClasses(record, i)} ${colorClassName}"
                        role="option"
                        aria-selected="${selected.includes(record)}"
                        data-index="${i}"
                        data-id="${StringHelper.encodeHtml(color)}"
                        data-btip="${text}"
                        ${this.itemsFocusable ? 'tabindex="-1"' : ''}
                        style="${colorClassName ? '' : 'background-color: ' + color}"
                    ></li>`;
    },
    /**
     * Array of internal color class names, without prefix, like `red`, `violet` etc. If specified, this will
     * take precedence over {@link #config-colors}.
     * @config {String[]}
     * @private
     */
    colorClasses: null,
    /**
     * Prefix to be inserted before the color class names in {@link #config-colorClasses}, like `b-sch-`
     * @config {String}
     * @private
     */
    colorClassPrefix: null,
    /**
     * Array of CSS color strings from which the user can chose from.
     *
     * Provide an array of string CSS colors:
     * ```javascript
     * new ColorMenu({
     *     colors : ['#00FFFF', '#F0FFFF', '#89CFF0', '#0000FF', '#7393B3']
     * });
     * ```
     *
     * The colors can also be named. To do that, put them in an object with a `color` and a `text` property, like:
     * ```javascript
     * new ColorMenu({
     *    colors : [
     *        { color : '#000000', text : 'Black'},
     *        { color : '#FF0000', text : 'Red'},
     *        { color : '#00FF00', text : 'Green'},
     *        { color : '#0000FF', text : 'Blue'},
     *        { color : '#FFFFFF', text : 'White'},
     *    ]
     * });
     * ```
     *
     * Default colors are:
     * <div class="b-colorbox b-inline" style="background-color: #45171D"></div>#45171D
     * <div class="b-colorbox b-inline" style="background-color: #F03861"></div>#F03861
     * <div class="b-colorbox b-inline" style="background-color: #FF847C"></div>#FF847C
     * <div class="b-colorbox b-inline" style="background-color: #FECEA8"></div>#FECEA8
     * <div class="b-colorbox b-inline" style="background-color: #A5F2E7"></div>#A5F2E7
     * <div class="b-colorbox b-inline" style="background-color: #AA83F3"></div>#AA83F3
     * <div class="b-colorbox b-inline" style="background-color: #8983F3"></div>#8983F3
     * <div class="b-colorbox b-inline" style="background-color: #A10054"></div>#A10054
     * <div class="b-colorbox b-inline" style="background-color: #073059"></div>#073059
     * <div class="b-colorbox b-inline" style="background-color: #2866AB"></div>#2866AB
     * <div class="b-colorbox b-inline" style="background-color: #5FBDC5"></div>#5FBDC5
     * <div class="b-colorbox b-inline" style="background-color: #D8D95C"></div>#D8D95C
     * <div class="b-colorbox b-inline" style="background-color: #FFDEDE"></div>#FFDEDE
     * <div class="b-colorbox b-inline" style="background-color: #F7F3CE"></div>#F7F3CE
     * <div class="b-colorbox b-inline" style="background-color: #C5ECBE"></div>#C5ECBE
     * <div class="b-colorbox b-inline" style="background-color: #3E3E3E"></div>#3E3E3E
     * <div class="b-colorbox b-inline" style="background-color: #405559"></div>#405559
     * <div class="b-colorbox b-inline" style="background-color: #68868C"></div>#68868C
     * <div class="b-colorbox b-inline" style="background-color: #EDEDED"></div>#EDEDED
     * <div class="b-colorbox b-inline" style="background-color: #D3D6DB"></div>#D3D6DB
     * <div class="b-colorbox b-inline" style="background-color: #3A4750"></div>#3A4750
     * <div class="b-colorbox b-inline" style="background-color: #303841"></div>#303841
     * <div class="b-colorbox b-inline" style="background-color: #BE3144"></div>#BE3144
     * @prp {String[]}
     */
    colors: ['#45171D', '#F03861', '#FF847C', '#FECEA8', '#A5F2E7', '#AA83F3', '#8983F3', '#A10054', '#073059', '#2866AB', '#5FBDC5', '#D8D95C', '#FFDEDE', '#F7F3CE', '#C5ECBE', '#3E3E3E', '#405559', '#68868C', '#EDEDED', '#D3D6DB', '#3A4750', '#303841', '#BE3144'],
    /**
     * Adds an option to set no background color
     * @prp {Boolean}
     */
    addNoColorItem: true,
    /**
     * The color items is displayed in a grid layout with 6 columns as default. Change this to another number to
     * affect appearance.
     * @prp {Number}
     */
    columns: 6,
    /**
     * A callback function that will be called when the user selects a color in the picker.
     * @param {Object} event Object containing event data
     * @param {Core.data.Model} event.record The selected color's record instance
     * @param {String} event.color The string color value
     * @config {Function}
     * @private
     */
    colorSelected: null
  };
  configure(config) {
    super.configure(config);
    this.setItems();
    this.ion({
      item: 'onColorSelect'
    });
  }
  setItems() {
    const me = this,
      {
        colors,
        colorClasses
      } = me;
    let useColors = colorClasses || colors;
    if (me.addNoColorItem) {
      useColors = [...useColors];
      useColors.push(null);
    }
    me.items = useColors.map(color => !color || typeof color == 'string' ? {
      color,
      text: (colorClasses ? StringHelper.capitalize(color) : color) || me.L('L{noColor}')
    } : color);
  }
  afterConfigure() {
    super.afterConfigure(...arguments);
    if (this.addNoColorItem || this.value) {
      this.select(this.value ?? null);
    }
  }
  updateColors() {
    if (!this.isConfiguring) {
      this.setItems();
    }
  }
  updateAddNoColorItem() {
    if (!this.isConfiguring) {
      this.setItems();
    }
  }
  onColorSelect({
    record
  }) {
    var _this$colorSelected;
    this.refresh();
    const event = {
      color: record.color,
      record,
      bubbles: true
    };
    (_this$colorSelected = this.colorSelected) === null || _this$colorSelected === void 0 ? void 0 : _this$colorSelected.call(this, event);
    this.trigger('colorSelected', event);
  }
  select(value) {
    if (!value || typeof value === 'string') {
      value = this.store.findRecord('color', value ?? null);
    }
    value && super.select(value);
  }
  updateColumns(columns) {
    this.style = `grid-template-columns:repeat(${columns}, 1fr);`;
  }
  getColorClassName(color) {
    var _this$colorClasses, _this$colorClasses2;
    if ((_this$colorClasses = this.colorClasses) !== null && _this$colorClasses !== void 0 && _this$colorClasses.includes(color) || (_this$colorClasses2 = this.colorClasses) !== null && _this$colorClasses2 !== void 0 && _this$colorClasses2.find(r => r && r.color === color)) {
      return this.colorClassPrefix + color;
    }
    return color ? '' : 'b-no-color';
  }
}
ColorPicker.initClass();
ColorPicker._$name = 'ColorPicker';

/**
 * @module Core/widget/layout/Fit
 */
/**
 * A helper class for containers which must manage a single child widget which must fit the container's
 * {@link Core.widget.Widget#property-contentElement}.
 * @layout
 * @classtype fit
 */
class Fit extends Layout {
  static $name = 'Fit';
  static type = 'fit';
  static configurable = {
    containerCls: 'b-fit-container',
    itemCls: 'b-fit-item'
  };
}
// Layouts must register themselves so that the static layout instantiation
// in Layout knows what to do with layout type names
Fit.initClass();
Fit._$name = 'Fit';

/**
 * @module Core/widget/Editor
 */
/**
 * Displays an input field, optionally editing a field of a record at a particular position.
 *
 * Offers events to signal edit completion upon `ENTER` or focus loss (if configured to do so),
 * or edit cancellation on `ESC`, or focus loss if configured that way.
 * @extends Core/widget/Container
 *
 * @classType Editor
 * @widget
 */
class Editor extends Container {
  //region Config
  static $name = 'Editor';
  // Factoryable type name
  static type = 'editor';
  static configurable = {
    positioned: true,
    hidden: true,
    layout: 'fit',
    /**
     * The alignment config for how this editor aligns to a target when asked to {@link #function-startEdit}
     * @config {AlignSpec}
     * @default
     */
    align: {
      align: 't0-t0',
      offset: [0, 0]
    },
    /**
     * Controls whether to hide the target element when asked to {@link #function-startEdit}
     * @config {Boolean}
     * @default
     */
    hideTarget: false,
    /**
     * By default, an Editor matches both dimensions, width and height of the element it is targeted at in the
     * {@link #function-startEdit} function.
     *
     * Configure this as false to allow the editor's configured dimensions, or its CSS-imposed dimensions size it.
     *
     * This may also operate with more granularity by specifying both dimensions in an object:
     *
     * ```javascript
     *     // Editor can exceed its target's height
     *     matchSize : {
     *         width  : true,
     *         height : false
     *     }
     * ```
     * @config {Boolean|Object}
     * @property {Boolean} width `true` to match width
     * @property {Boolean} height `true`to match height
     * @default
     */
    matchSize: true,
    /**
     * Controls whether the editor should match target element's font when asked to {@link #function-startEdit}
     * @config {Boolean}
     * @default
     */
    matchFont: true,
    /**
     * Controls whether the editor should expand its width if the input field has overflow {@link #function-startEdit}
     * @config {Boolean}
     * @default
     */
    fitTargetContent: false,
    /**
     * A config object, or the `type` string of the widget (usually a {@link Core.widget.Field} subclass,
     * i.e. {@link Core.widget.TextField}) which this editor will encapsulate.
     * @prp {Core.widget.Widget}
     * @accepts {InputFieldConfig|String}
     * @default
     */
    inputField: 'textfield',
    /**
     * What action should be taken when focus moves out of the editor, either by `TAB` or clicking outside.
     * May be `'complete'` or `'cancel`'. Any other value results in no action being taken upon focus leaving the editor
     * leaving the application to listen for the {@link #event-focusOut focusOut} event.
     * @config {'complete'|'cancel'|null}
     * @default
     */
    blurAction: 'complete',
    /**
     * The name of the `key` which completes the edit.
     *
     * See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values for key names.
     * @config {String}
     * @default
     */
    completeKey: 'Enter',
    /**
     * The name of the `key` which cancels the edit.
     *
     * See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values for key names.
     * @config {String}
     * @default
     */
    cancelKey: 'Escape',
    /**
     * How to handle a request to complete the edit if the field is invalid. There are three choices:
     *  - `block` The default. The edit is not exited, the field remains focused.
     *  - `allow` Allow the edit to be completed.
     *  - `revert` The field value is reverted and the edit is completed.
     * @config {'block'|'allow'|'revert'}
     * @default
     */
    invalidAction: 'block',
    /**
     * Configure as `true` to have editing complete as soon as the field fires its `change` event.
     * @config {Boolean}
     * @default false
     */
    completeOnChange: null,
    isolateFields: true
  };
  //endregion
  //region Events
  /**
   * Fired before the editor is shown to start an edit operation. Returning `false` from a handler vetoes the edit operation.
   * @event beforeStart
   * @param {HTMLElement} target The element which the Editor is to overlay to edit its content.
   * @param {Core.data.Model} [record] The record being edited.
   * @param {String} [field] The name of the field if a record is being edited.
   * @param {Object} value - The value to be edited.
   * @param {String|AlignSpec} align - How to align the editor.
   * @param {Boolean} hideTarget `true` if the target is to be hidden during the edit.
   * @param {Boolean|Object} matchSize Whether to match the target size. See {@link #config-matchSize}
   * @param {Boolean} matchSize.width Match width
   * @param {Boolean} matchSize.height Match height
   * @param {Boolean} matchFont Whether to match the target's font. See {@link #config-matchFont}
   * @param {Boolean} focus Whether to focus the editor's field.
   * @preventable
   */
  /**
   * Fired when an edit operation has begun.
   * @event start
   * @param {Object} value - The starting value of the field.
   * @param {Core.widget.Editor} source - The Editor that triggered the event.
   */
  /**
   * Fired when an edit completion has been requested, either by `ENTER`, or focus loss (if configured to complete on blur).
   * The completion may be vetoed, in which case, focus is moved back into the editor.
   * @event beforeComplete
   * @param {Object} oldValue - The original value.
   * @param {Object} value - The new value.
   * @param {Core.widget.Editor} source - The Editor that triggered the event.
   * @param {Function} [finalize] An async function may be injected into this property
   * which performs asynchronous finalization tasks such as complex validation of confirmation. The
   * value `true` or `false` must be returned.
   * @param {Object} [finalize.context] An object describing the editing context upon requested completion of the edit.
   * @preventable
   */
  /**
   * Edit has been completed, and any associated record or element has been updated.
   * @event complete
   * @param {Object} oldValue - The original value.
   * @param {Object} value - The new value.
   * @param {Core.widget.Editor} source - The Editor that triggered the event.
   */
  /**
   * Fired when cancellation has been requested, either by `ESC`, or focus loss (if configured to cancel on blur).
   * The cancellation may be vetoed, in which case, focus is moved back into the editor.
   * @event beforeCancel
   * @param {Object} oldValue - The original value.
   * @param {Object} value - The new value.
   * @param {Event} event - Included if the cancellation was triggered by a DOM event
   * @param {Core.widget.Editor} source - The Editor that triggered the event.
   * @preventable
   */
  /**
   * Edit has been canceled without updating the associated record or element.
   * @event cancel
   * @param {Object} oldValue - The original value.
   * @param {Object} value - The value of the field.
   * @param {Event} event - Included if the cancellation was triggered by a DOM event
   * @param {Core.widget.Editor} source - The Editor that triggered the event.
   */
  /**
   * Fire to relay a `keypress` event from the field.
   * @event keypress
   * @param {Event} event - The key event.
   */
  //endregion
  afterConfigure() {
    const me = this;
    super.afterConfigure();
    me.onTargetSizeChange = me.onTargetSizeChange.bind(me);
    EventHelper.on({
      element: me.element,
      keydown: 'onKeyDown',
      contextmenu: 'stopMouseEvents',
      mousedown: 'stopMouseEvents',
      mouseover: 'stopMouseEvents',
      mouseout: 'stopMouseEvents',
      mouseup: 'stopMouseEvents',
      click: 'stopMouseEvents',
      dblclick: 'stopMouseEvents',
      thisObj: me
    });
    me.ion({
      beforeHide: 'beforeEditorHide',
      hide: 'afterEditorHide',
      thisObj: me
    });
    LocaleManagerSingleton.ion({
      locale: 'onLocaleChange',
      thisObj: me
    });
  }
  onLocaleChange() {
    const {
      inputField
    } = this;
    if (inputField && !inputField.isDestroyed) {
      // All Field subclasses have this method, but if `inputField` is a custom widget,
      // `syncInputFieldValue` has to be implemented
      if (inputField.syncInputFieldValue) {
        inputField.syncInputFieldValue(true);
      }
    }
  }
  render(renderTo) {
    const oldParent = this.element.parentNode,
      [parentElement] = this.getRenderContext(this, renderTo);
    // Ensure that wherever we are hosted, it gets the correct tag class added/removed
    parentElement.classList.add('b-editing');
    super.render(...arguments);
    if (oldParent !== null && oldParent !== void 0 && oldParent.classList && parentElement !== oldParent) {
      oldParent.classList.remove('b-editing');
    }
  }
  /**
   * Start editing
   * @param {Object} editObject An object containing details about what to edit.
   * @param {HTMLElement|Core.helper.util.Rectangle} editObject.target the element or Rectangle to align to.
   * @param {String} [editObject.align=t0-t0] How to align to the target.
   * @param {Boolean} [editObject.matchSize=true] Match editor size to target size.
   * @param {Boolean} [editObject.matchFont=true] Match editor's font-size size to target's font-size.
   * @param {Core.data.Model} [editObject.record] The record to edit.
   * @param {String} [editObject.field] The field name in the record to edit. This defaults to the `name` of the
   * {@link #config-inputField}. Also if record has method set + capitalized field, method will be called, e.g. if
   * record has method named `setFoobar` and this config is `foobar`, then instead of `record.foobar = value`,
   * `record.setFoobar(value)` will be called.
   * @param {Object} [editObject.value] The value to edit.
   * @param {Boolean} [editObject.focus=true] Focus the field.
   * @param {Boolean} [editObject.fitTargetContent] Pass `true` to allow the Editor to expand beyond the width of its
   * target element if its content overflows horizontally. This is useful if the editor has triggers to display, such
   * as a combo.
   * @returns {Promise} Resolved promise returns`true` if editing has been started, `false` if an
   * {@link #event-beforeStart} listener has vetoed the edit.
   */
  async startEdit(editObject) {
    const me = this;
    editObject = ObjectHelper.assignIf(editObject, {
      align: me.align,
      hideTarget: me.hideTarget,
      matchSize: me.matchSize,
      matchFont: me.matchFont,
      fitTargetContent: me.fitTargetContent,
      focus: true
    });
    if (me.trigger('beforeStart', editObject) !== false) {
      var _inputField$clearErro, _inputField$focus, _convertedValue$;
      const {
          target,
          hideTarget,
          matchSize,
          matchFont,
          fitTargetContent,
          record,
          field = me.inputField.name,
          focus
        } = editObject,
        {
          inputField
        } = me,
        {
          input
        } = inputField,
        targetFontSize = DomHelper.getStyleValue(target, 'font-size'),
        targetFontFamily = DomHelper.getStyleValue(target, 'font-family');
      let {
        value,
        align
      } = editObject;
      if (record && field) {
        me.record = record;
        me.dataField = field;
        if (value === undefined) {
          value = record.getValue(field);
        }
      }
      if (matchSize) {
        if (target instanceof HTMLElement) {
          me.updateSize(target, matchSize);
        }
        // If we are editing and sizing based on an element,
        // we need to update editor size if grid cell size changes
        // Removed in 'hide' listener
        if (target instanceof HTMLElement) {
          ResizeMonitor.addResizeListener(target, me.onTargetSizeChange);
        }
      }
      if (input) {
        if (matchFont) {
          input.style.fontSize = targetFontSize;
          input.style.fontFamily = targetFontFamily;
        } else {
          input.style.fontSize = input.style.fontFamily = '';
        }
      }
      me.assigningValues = true;
      // In case our finalize code set it to invalid, start it clear of errors.
      (_inputField$clearErro = inputField.clearError) === null || _inputField$clearErro === void 0 ? void 0 : _inputField$clearErro.call(inputField);
      if ('setValue' in inputField) {
        await inputField.setValue(value);
      }
      // Backwards compat for widgets that don't have setValue
      else {
        inputField.value = value;
      }
      me.assigningValues = false;
      // Simplest form is 't0-t0', but may be passed as full object spec.
      // It gets expanded below so must be an object.
      if (typeof align === 'string') {
        align = {
          align
        };
      }
      // Allow target to be out of view. We always align to it.
      await me.showBy({
        target,
        allowTargetOut: true,
        ...align
      });
      if (fitTargetContent) {
        // Input doesn't fit, so widen it
        const overflow = input.scrollWidth - input.clientWidth;
        if (overflow > 0) {
          me.width += overflow + DomHelper.scrollBarWidth;
        }
      }
      focus && ((_inputField$focus = inputField.focus) === null || _inputField$focus === void 0 ? void 0 : _inputField$focus.call(inputField));
      if (target.nodeType === Element.ELEMENT_NODE) {
        if (hideTarget) {
          target.classList.add('b-hide-visibility');
        }
      }
      me.editing = true;
      const convertedValue = inputField.value;
      // Passed value may have been '10/06/2019', send the live field value to startedit
      me.trigger('start', {
        value: convertedValue
      });
      if (Array.isArray(convertedValue) && inputField.editingRecords && (_convertedValue$ = convertedValue[0]) !== null && _convertedValue$ !== void 0 && _convertedValue$.isModel) {
        // If this editor is editing model instances, save a cloned copy in case fields
        // are changed
        me.oldValue = convertedValue.map(record => record.copy(record.id));
      } else {
        me.oldValue = convertedValue;
        // If the value from the value getter is an array, we must clone it because
        // if it's the same *instance*, the ObjectHelper.isEqual test in completeEdit
        // will find that there are no changes.
        if (Array.isArray(me.oldValue)) {
          me.oldValue = me.oldValue.slice();
        }
      }
      // The initialValue is what the revertOnEscape uses by preference before it uses its valueOnFocus.
      // In an Editor, it can focus in and out but still need that correct initial value.
      inputField.initialValue = me.oldValue;
      return true;
    }
    return false;
  }
  async refreshEdit() {
    if (this.isVisible) {
      const {
        record,
        dataField,
        inputField
      } = this;
      if (record && dataField) {
        const value = record.getValue(dataField);
        // Only update the field if the value has changed
        if (!ObjectHelper.isEqual(inputField.value, value)) {
          await inputField.setValue(value);
        }
      }
    }
  }
  finishEdit() {
    const {
      target,
      aligningToElement
    } = this.lastAlignSpec;
    if (aligningToElement) {
      target.classList.remove('b-editing');
      target.classList.remove('b-hide-visibility');
    }
    this.editing = false;
    // Internal event, to be able to destroy etc. no matter if completed or cancelled
    this.trigger('finishEdit');
  }
  onKeyDown(event) {
    var _me$trigger;
    const me = this;
    switch (event.key) {
      case me.completeKey:
        me.completeEdit(null, event);
        event.stopImmediatePropagation();
        break;
      case me.cancelKey:
        me.cancelEdit(event);
        event.stopImmediatePropagation();
        break;
    }
    // In case destroyed by complete or cancel
    (_me$trigger = me.trigger) === null || _me$trigger === void 0 ? void 0 : _me$trigger.call(me, 'keydown', {
      event
    });
  }
  stopMouseEvents(e) {
    // React editor wrapper uses this flag to enable mouse events pass through to editor
    if (!this.allowMouseEvents) {
      e.stopPropagation();
    }
  }
  onFocusOut(event) {
    super.onFocusOut(event);
    const me = this;
    if (!me.isFinishing && me.editing) {
      // Calls have different signatures.
      switch (me.blurAction) {
        case 'cancel':
          me.cancelEdit(event);
          break;
        case 'complete':
          me.completeEdit(null, event);
      }
    }
  }
  /**
   * Complete the edit, and, if associated with a record, update the record if possible.
   * If editing is completed, the editor is hidden.
   *
   * If the field is invalid, the `{@link #config-invalidAction}` config is used to decide
   * upon the course of action.
   *
   * If a {@link #event-beforeComplete} handler returns `false` then editing is not completed.
   *
   * If the field's values has not been changed, then editing is terminated through {@link #function-cancelEdit}.
   *
   * @returns {Boolean} `true` if editing ceased, `false` if the editor is still active.
   */
  async completeEdit(finalize, triggeredByEvent) {
    const me = this,
      {
        inputField,
        oldValue,
        record
      } = me,
      invalidAction = inputField.invalidAction || (inputField.allowInvalid === false ? 'block' : me.invalidAction),
      {
        value
      } = inputField;
    // If we are not editing, we should manipulate the field or not fire any events
    if (!me.isVisible) {
      return;
    }
    // If we're configured not to allow invalid values, refocus the field in case complete was triggered by focusout.
    if (!inputField.isValid && invalidAction !== 'allow') {
      if (invalidAction === 'block') {
        var _inputField$focus2;
        (_inputField$focus2 = inputField.focus) === null || _inputField$focus2 === void 0 ? void 0 : _inputField$focus2.call(inputField);
        return false;
      } else if (invalidAction === 'revert') {
        me.cancelEdit(triggeredByEvent);
        return true;
      }
    }
    // No change means a cancel.
    else if (ObjectHelper.isEqual(value, oldValue)) {
      me.cancelEdit(triggeredByEvent);
      return true;
    }
    // Allow veto of the completion
    else {
      const context = {
        inputField,
        record,
        value,
        oldValue
      };
      if (me.trigger('beforeComplete', context) === false) {
        var _inputField$focus3;
        (_inputField$focus3 = inputField.focus) === null || _inputField$focus3 === void 0 ? void 0 : _inputField$focus3.call(inputField);
      } else {
        // CellEdit#onEditorBeforeComplete injects editorContext into the basic context
        if (!finalize) {
          var _context$editorContex;
          finalize = context.finalize || ((_context$editorContex = context.editorContext) === null || _context$editorContex === void 0 ? void 0 : _context$editorContex.finalize);
        }
        // Allow async finalization of the editing, implementer may want to show a confirmation popup etc
        if (finalize) {
          let result = await finalize(context);
          if (result === true) {
            me.onEditComplete();
          } else {
            if (inputField.setError) {
              const error = result || inputField.invalidValueError,
                clearError = () => {
                  listeners();
                  inputField.clearError(error);
                },
                listeners = inputField.ion({
                  change: clearError,
                  input: clearError
                });
              // Mark as invalid. Because this is decided upon without the knowledge
              // of the field, this state will be rescinded upon the next change of
              // input field.
              inputField.setError(error);
            }
            if (invalidAction === 'block') {
              var _inputField$focus4;
              (_inputField$focus4 = inputField.focus) === null || _inputField$focus4 === void 0 ? void 0 : _inputField$focus4.call(inputField);
            } else if (invalidAction === 'revert') {
              await inputField.setValue(oldValue);
              result = true;
            }
            result = false;
          }
          return result;
        }
        // Successful completion
        else {
          me.onEditComplete();
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Cancel the edit and hide the editor.
   */
  cancelEdit(triggeredByEvent) {
    const me = this,
      {
        inputField,
        oldValue
      } = me,
      {
        value
      } = inputField;
    if (me.editing && !me.isFinishing && me.trigger('beforeCancel', {
      value,
      oldValue,
      event: triggeredByEvent
    }) !== false) {
      var _inputField$clearErro2;
      // Hiding must not trigger our blurAction
      (_inputField$clearErro2 = inputField.clearError) === null || _inputField$clearErro2 === void 0 ? void 0 : _inputField$clearErro2.call(inputField);
      me.isFinishing = true;
      me.hide();
      me.trigger('cancel', {
        value,
        oldValue,
        event: triggeredByEvent
      });
      me.finishEdit();
      me.isFinishing = false;
    }
  }
  // Handle updating what needs to be updated.
  onEditComplete() {
    const me = this,
      {
        record,
        dataField,
        inputField,
        oldValue
      } = me,
      {
        value
      } = inputField;
    if (!me.isFinishing) {
      // Hiding must not trigger our blurAction
      me.isFinishing = true;
      me.hide();
      if (record) {
        const setterName = `set${StringHelper.capitalize(dataField)}`;
        if (record[setterName]) {
          record[setterName](value);
        } else {
          record.setValue(dataField, value);
        }
      }
      me.trigger('complete', {
        value,
        oldValue
      });
      me.finishEdit();
      me.isFinishing = false;
    }
  }
  doDestroy() {
    if (this.createdInputField) {
      this.inputField.destroy();
    }
    super.doDestroy();
  }
  set owner(owner) {
    this._owner = owner;
  }
  // This is a positioned widget appended to a Widget's contentElement. It may have no owner link.
  // Grab the owner by finding what widget it is inside.
  get owner() {
    return this._owner || Widget.fromElement(this.element.parentNode);
  }
  changeInputField(inputField, oldInputField) {
    const me = this;
    if (oldInputField) {
      oldInputField.destroy();
    }
    if (typeof inputField === 'string') {
      inputField = {
        type: inputField
      };
    }
    if (!(inputField instanceof Widget)) {
      inputField = Widget.create(inputField);
      me.createdInputField = true; // So we know we can destroy it
    }

    if (me.completeOnChange) {
      inputField.ion({
        change: 'onInputFieldChange',
        thisObj: me
      });
    }
    inputField.parent = me;
    return inputField;
  }
  updateInputField(inputField) {
    this.removeAll();
    this.add(inputField);
  }
  get inputField() {
    return this.items[0];
  }
  onInputFieldChange() {
    if (this.containsFocus) {
      this.completeEdit();
    }
  }
  onTargetSizeChange(resizedElement, oldRect, newRect) {
    if (oldRect && newRect) {
      this.updateSize(resizedElement);
    }
  }
  updateSize(targetEl, matchSize = this.lastMatchSize) {
    const me = this,
      rect = Rectangle.inner(targetEl);
    // matchSize is granular allowing either dimension to be matched
    me.width = matchSize.width === false ? 'auto' : rect.width - me.align.offset[0];
    me.height = matchSize.height === false ? 'auto' : rect.height;
    me.lastMatchSize = matchSize;
  }
  beforeEditorHide() {
    // If we are hidden during an edit, *not as part of our finishing sequence*
    // then cancel the edit. For example we were scrolled out of view with
    // align having allowTargetOut : false
    if (this.editing && !this.isFinishing) {
      this.cancelEdit();
      // cancelEdit will have hidden. do not allow calling code to
      // continue to call furether listeners. The Editor will be in an invalid
      // state because cancelEdit will have triggered those listeners.
      return false;
    }
  }
  afterEditorHide() {
    // Floating Widgets automatically remove themselves.
    // Editors which are positioned also need to get out the way of content
    // to allow content updating to be unobstructed.
    if (this.positioned) {
      this.element.remove();
    }
    ResizeMonitor.removeResizeListener(this.lastAlignSpec.target, this.onTargetSizeChange);
  }
}
// Register this widget type with its Factory
Editor.initClass();
Editor._$name = 'Editor';

export { AjaxHelper, AjaxStore, Animator, ArrayDataField, ArrayHelper, AsyncHelper, Badge, Bag, Base, BooleanDataField, BrowserHelper, Button, CSSHelper, Checkbox, ChipView, ClickRepeater, CollapseTool, Collection, CollectionFilter, CollectionSorter, ColorPicker, Combo, Config, Container, ContextMenuBase, DataField, DateDataField, DateHelper, DayTime, Delayable, DomClassList, DomDataStore, DomHelper, DomSync, Duration, DynamicObject, Editor, EventHelper, Events, Factoryable, Field, FieldContainer, Fullscreen, FunctionHelper, GlobalEvents, IdHelper, Identifiable, InstancePlugin, IntegerDataField, KeyMap, Labelable, Layout, List, LoadMaskable, LocaleHelper, LocaleManagerSingleton, Localizable, Mask, Menu, MenuItem, Model, ModelDataField, ModelLink, ModelStm, Navigator, NumberDataField, ObjectDataField, ObjectHelper, Objects, Panel, PanelCollapser, PickerField, Pluggable, Point, Popup, Promissory, RTL, Rectangle, Renderable, ResizeMonitor, Ripple, Rotatable, ScrollManager, Scroller, State, StateProvider, StateStorage, Store, StoreCRUD, StoreChained, StoreChanges, StoreDataField, StoreFilter, StoreGroup, StoreProxy, StoreRelation, StoreSearch, StoreSort, StoreState, StoreStm, StoreSum, StoreSync, StoreTree, StringDataField, StringHelper, TemplateHelper, TextField, TimeZoneHelper, Toast, Tool, Toolable, Toolbar, Tooltip, TreeNode, VersionHelper, WalkHelper, Wbs, Widget, parseAlign, unitMagnitudes };
//# sourceMappingURL=Editor.js.map
