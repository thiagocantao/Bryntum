{"version":3,"file":"Override.js","sources":["../../../../Core/lib/Core/mixin/Override.js"],"sourcesContent":["import VersionHelper from '../helper/VersionHelper.js';\n\n/**\n * @module Core/mixin/Override\n */\n\nconst excludedPropNames = {\n    constructor : 1,\n    prototype   : 1,\n    name        : 1,\n    length      : 1,\n    arguments   : 1,\n    caller      : 1,\n    callee      : 1,\n    __proto__   : 1\n};\n\n/**\n * Simplifies overriding class methods by allowing methods from another class to be used as overrides.\n * Overrides are defined as own classes. They must at a minimum contain a static getter named targetClass, which\n * should return the class to override. Apply the override by calling {@link #function-apply-static apply()}.\n *\n * @example\n * class TemplateColumnOverride {\n *     static get target() {\n *         return {\n *             class      : TemplateColumn,\n *             product    : 'grid',\n *             minVersion : '1.0',\n *             maxVersion : '1.5'\n *         }\n *     }\n *\n *     renderer(renderData) {\n *         // call overridden function (optional)\n *         const value = this._overridden.renderer.call(this, renderData);\n *\n *         return 'HELLO' + value;\n *     }\n * }\n * Override.apply(TemplateColumnOverride);\n */\nexport default class Override {\n    /**\n     * Apply override. We strongly suggest that you at least specify a maxVersion for your overrides.\n     * ```\n     * class OriginalOverride {\n     *     static get target() {\n     *         return {\n     *             class      : Original,\n     *             product    : 'grid',\n     *             minVersion : '1.0',\n     *             maxVersion : '1.5'\n     *         }\n     *     }\n     * }\n     * ```\n     * @param {Object} override An override class definition\n     */\n    static apply(override) {\n        if (!override.target) throw new Error('Override must specify what it overrides, using static getter target');\n        if (!override.target.class) throw new Error('Override must specify which class it overrides, using target.class');\n\n        if (!this.shouldApplyOverride(override)) return false;\n\n        const staticKeys   = Object.getOwnPropertyNames(override),\n            instanceKeys = Object.getOwnPropertyNames(override.prototype);\n\n        staticKeys.splice(staticKeys.indexOf('target'), 1);\n\n        this.internalOverrideAll(override.target.class, staticKeys, override);\n        this.internalOverrideAll(override.target.class.prototype, instanceKeys, override.prototype);\n\n        return true;\n    }\n\n    static internalOverrideAll(targetClass, properties, overrideDefinition) {\n        Reflect.ownKeys(overrideDefinition).forEach(key => {\n            if (properties.includes(key) && !excludedPropNames[key]) {\n                const desc = Object.getOwnPropertyDescriptor(overrideDefinition, key);\n                let currentTargetClass = targetClass;\n\n                let targetProperty = null;\n\n                // Walk up the prototype chain to find fn, needed for mixin overrides applied to class that has them\n                // mixed in\n                while (!targetProperty && currentTargetClass) {\n                    targetProperty = Object.getOwnPropertyDescriptor(currentTargetClass, key);\n                    if (!targetProperty) {\n                        currentTargetClass = Object.getPrototypeOf(currentTargetClass);\n                    }\n                }\n\n                if (targetProperty) {\n                    this.internalOverride(currentTargetClass, key, desc, targetProperty);\n                }\n            }\n        });\n    }\n\n    static internalOverride(target, key, desc, targetDesc) {\n        const overrides = target._overridden = target._overridden || {};\n\n        overrides[key] = target[key];\n\n        if (targetDesc.get) {\n            Object.defineProperty(target, key, {\n                enumerable   : false,\n                configurable : true,\n                get          : desc.get\n            });\n        }\n        else {\n            target[key] = desc.value;\n        }\n    }\n\n    /**\n     * Checks versions if an override should be applied. Specify version in your overrides target config\n     * @param override\n     * @returns {Boolean}\n     * @example\n     * class OriginalOverride {\n     *     static get target() {\n     *         return {\n     *             class      : Original,\n     *             product    : 'grid',\n     *             minVersion : '1.0',\n     *             maxVersion : '1.5'\n     *         }\n     *     }\n     * }\n     * @private\n     */\n    static shouldApplyOverride(override) {\n        const config = override.target;\n        // not using versioning, allow override\n        if (!config.maxVersion && !config.minVersion) return true;\n\n        // must specify product to be able to lookup versions\n        if (!config.product) throw new Error('Override must specify product when using versioning');\n\n        // override is for older version, disallow\n        if (config.maxVersion && VersionHelper[config.product].isNewerThan(config.maxVersion)) {\n            //<debug>\n            console.log(`Override ${override.name} for class ${config.class.name} is for an older version of ${config.product} and will not be applied`);\n            //</debug>\n            return false;\n        }\n\n        // override is for newer version, disallow\n        if (config.minVersion && VersionHelper[config.product].isOlderThan(config.minVersion)) {\n            //<debug>\n            console.log(`Override ${override.name} for class ${config.class.name} is for a newer version of ${config.product} and will not be applied`);\n            //</debug>\n            return false;\n        }\n\n        // override is for current version, allow\n        return true;\n    }\n}\n"],"names":["excludedPropNames","constructor","prototype","name","length","arguments","caller","callee","__proto__","Override","apply","override","target","Error","class","shouldApplyOverride","staticKeys","Object","getOwnPropertyNames","instanceKeys","splice","indexOf","internalOverrideAll","targetClass","properties","overrideDefinition","Reflect","ownKeys","forEach","key","includes","desc","getOwnPropertyDescriptor","currentTargetClass","targetProperty","getPrototypeOf","internalOverride","targetDesc","overrides","_overridden","get","defineProperty","enumerable","configurable","value","config","maxVersion","minVersion","product","VersionHelper","isNewerThan","isOlderThan","_$name"],"mappings":"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"}